// Azimuth Telemetry System - Data Integrity Validation Test Suite
// This file contains comprehensive test cases for data integrity validation

// Test 1: Trace Data Integrity Validation
test "trace data integrity validation" {
  // Test trace ID format validation
  let valid_trace_ids = [
    "0af7651916cd43dd8448eb211c80319c",
    "1234567890abcdef1234567890abcdef",
    "abcdef0123456789abcdef0123456789"
  ]
  
  let invalid_trace_ids = [
    "",                           // Empty
    "short",                      // Too short
    "0af7651916cd43dd8448eb211c80319c123",  // Too long
    "ghijklmnopqrstuvwxyz0123456789012345", // Invalid characters
    "0AF7651916CD43DD8448EB211C80319C",     // Uppercase (should be lowercase)
    "0af7651916cd43dd8448eb211c80319",      // Missing characters
    "0af7651916cd43dd8448eb211c80319c "     // Trailing space
  ]
  
  // Validate valid trace IDs
  for trace_id in valid_trace_ids {
    assert_eq(trace_id.length(), 32)
    assert_true(trace_id.chars().all(|c| c.is_ascii_hexdigit()))
  }
  
  // Validate invalid trace IDs
  for trace_id in invalid_trace_ids {
    if trace_id.length() == 0 {
      assert_eq(trace_id.length(), 0)
    } else if trace_id.length() != 32 {
      assert_true(trace_id.length() != 32)
    } else {
      // Check for invalid characters
      let has_invalid_chars = trace_id.chars().any(|c| !c.is_ascii_hexdigit())
      assert_true(has_invalid_chars || trace_id != trace_id.to_lowercase())
    }
  }
  
  // Test span ID format validation
  let valid_span_ids = [
    "b7ad6b7169203331",
    "1234567890abcdef",
    "ffffffffffffffff"
  ]
  
  let invalid_span_ids = [
    "",                    // Empty
    "1234",               // Too short
    "1234567890abcdef1",  // Too long
    "ghijklmnopqrstu",    // Invalid characters
    "B7AD6B7169203331",   // Uppercase
    "b7ad6b716920333"     // Missing characters
  ]
  
  // Validate valid span IDs
  for span_id in valid_span_ids {
    assert_eq(span_id.length(), 16)
    assert_true(span_id.chars().all(|c| c.is_ascii_hexdigit()))
  }
  
  // Validate invalid span IDs
  for span_id in invalid_span_ids {
    if span_id.length() == 0 {
      assert_eq(span_id.length(), 0)
    } else if span_id.length() != 16 {
      assert_true(span_id.length() != 16)
    } else {
      let has_invalid_chars = span_id.chars().any(|c| !c.is_ascii_hexdigit())
      assert_true(has_invalid_chars || span_id != span_id.to_lowercase())
    }
  }
  
  // Test parent-child relationship integrity
  let trace_id = "0af7651916cd43dd8448eb211c80319c"
  let parent_span_id = "b7ad6b7169203331"
  let child_span_id = "c8be7c827a314442"
  
  // Different span IDs should be unique
  assert_not_eq(parent_span_id, child_span_id)
  assert_not_eq(parent_span_id, trace_id)
  assert_not_eq(child_span_id, trace_id)
  
  // Length validation
  assert_eq(trace_id.length(), 32)
  assert_eq(parent_span_id.length(), 16)
  assert_eq(child_span_id.length(), 16)
}

// Test 2: Metric Data Integrity Validation
test "metric data integrity validation" {
  // Test metric name validation
  let valid_metric_names = [
    "http.requests",
    "database.connections",
    "cpu.usage",
    "memory.bytes_used",
    "custom.metric.with.dots",
    "metric_with_underscores",
    "metric123withnumbers"
  ]
  
  let invalid_metric_names = [
    "",                    // Empty
    ".leading.dot",        // Leading dot
    "trailing.dot.",       // Trailing dot
    "double..dot",         // Double dot
    "metric with spaces",  // Spaces
    "metric/with/slashes", // Slashes
    "metric\\with\\backslashes", // Backslashes
    "metric@with#special$chars%" // Special characters
  ]
  
  // Validate valid metric names
  for name in valid_metric_names {
    assert_true(name.length() > 0)
    assert_false(name.starts_with("."))
    assert_false(name.ends_with("."))
    assert_false(name.contains(".."))
    assert_false(name.contains(" "))
    assert_false(name.contains("/"))
    assert_false(name.contains("\\"))
  }
  
  // Validate invalid metric names
  for name in invalid_metric_names {
    if name.length() == 0 {
      assert_eq(name.length(), 0)
    } else if name.starts_with(".") || name.ends_with(".") || name.contains("..") {
      assert_true(true)
    } else if name.contains(" ") || name.contains("/") || name.contains("\\") {
      assert_true(true)
    }
  }
  
  // Test metric value validation
  let valid_metric_values = [
    0.0,
    1.0,
    42.5,
    -1.0,
    3.14159,
    1000000.0,
    0.000001,
    1.7976931348623157e308,  // Max double
    -1.7976931348623157e308  // Min double
  ]
  
  // Validate metric values
  for value in valid_metric_values {
    assert_true(value.is_finite())
  }
  
  // Test metric aggregation integrity
  let measurements = [10.5, 20.0, 15.5, 30.0, 25.0, 18.0, 22.5]
  let sum = measurements.reduce(|acc, val| acc + val, 0.0)
  let count = measurements.length().to_float()
  let avg = sum / count
  let min = measurements.reduce(|acc, val| if val < acc { val } else { acc }, measurements[0])
  let max = measurements.reduce(|acc, val| if val > acc { val } else { acc }, measurements[0])
  
  // Validate aggregation results
  assert_eq(sum, 141.5)
  assert_eq(count, 7.0)
  assert_eq(avg, 20.214285714285715)
  assert_eq(min, 10.5)
  assert_eq(max, 30.0)
  
  // Validate aggregation consistency
  assert_true(min <= avg)
  assert_true(avg <= max)
  assert_true(sum >= max)
  assert_true(sum <= max * count)
}

// Test 3: Log Data Integrity Validation
test "log data integrity validation" {
  // Test log severity level validation
  let valid_severity_levels = [
    ("trace", 1),
    ("debug", 2),
    ("info", 3),
    ("warn", 4),
    ("error", 5),
    ("fatal", 6)
  ]
  
  let invalid_severity_levels = [
    ("", 0),        // Empty name, invalid number
    ("invalid", 7), // Invalid name, invalid number
    ("info", 0),    // Valid name, invalid number
    ("", 3)         // Invalid name, valid number
  ]
  
  // Validate valid severity levels
  for (name, number) in valid_severity_levels {
    assert_true(name.length() > 0)
    assert_true(number >= 1 && number <= 6)
  }
  
  // Validate invalid severity levels
  for (name, number) in invalid_severity_levels {
    if name.length() == 0 || !["trace", "debug", "info", "warn", "error", "fatal"].any(|valid| valid == name) {
      assert_true(true)
    }
    if number < 1 || number > 6 {
      assert_true(true)
    }
  }
  
  // Test timestamp validation
  let valid_timestamps = [
    1640995200000,  // 2022-01-01 00:00:00 UTC
    1640995201000,  // 2022-01-01 00:00:01 UTC
    1640995260000,  // 2022-01-01 00:01:00 UTC
    1641081600000   // 2022-01-02 00:00:00 UTC
  ]
  
  let invalid_timestamps = [
    -1,              // Negative
    0,               // Zero (epoch)
    18446744073709551615  // Max uint64 (future)
  ]
  
  // Validate valid timestamps
  for timestamp in valid_timestamps {
    assert_true(timestamp > 0)
    assert_true(timestamp < 253402300799000)  // Year 9999
  }
  
  // Validate invalid timestamps
  for timestamp in invalid_timestamps {
    if timestamp < 0 {
      assert_true(timestamp < 0)
    } else if timestamp == 0 {
      assert_eq(timestamp, 0)
    } else {
      assert_true(timestamp > 253402300799000)
    }
  }
  
  // Test log message validation
  let valid_log_messages = [
    "Simple log message",
    "Log message with numbers 123",
    "Log message with special chars: !@#$%^&*()",
    "Log message with unicode: æµ‹è¯•",
    "Log message with emoji: ðŸš€",
    "Log message with\nnewlines",
    "Log message with\ttabs",
    "Log message with \"quotes\"",
    "Log message with 'apostrophes'",
    "A".repeat(1000)  // Long message
  ]
  
  let invalid_log_messages = [
    "",  // Empty message
    "   "  // Only whitespace
  ]
  
  // Validate valid log messages
  for message in valid_log_messages {
    assert_true(message.length() > 0)
    if message.trim() != message {
      // Message has leading/trailing whitespace
      assert_true(message.trim().length() > 0)
    }
  }
  
  // Validate invalid log messages
  for message in invalid_log_messages {
    assert_eq(message.trim().length(), 0)
  }
}

// Test 4: Resource Attribute Integrity Validation
test "resource attribute integrity validation" {
  // Test attribute key validation
  let valid_attribute_keys = [
    "service.name",
    "service.version",
    "service.namespace",
    "host.name",
    "host.ip",
    "process.id",
    "process.executable.name",
    "deployment.environment",
    "telemetry.sdk.name",
    "telemetry.sdk.version",
    "custom.attribute.with.dots",
    "attribute_with_underscores",
    "attribute123withnumbers"
  ]
  
  let invalid_attribute_keys = [
    "",                    // Empty
    ".leading.dot",        // Leading dot
    "trailing.dot.",       // Trailing dot
    "double..dot",         // Double dot
    "attribute with spaces",  // Spaces
    "attribute/with/slashes",   // Slashes
    "attribute\\with\\backslashes", // Backslashes
    "attribute@with#special$chars%", // Special characters
    "a".repeat(256)        // Too long
  ]
  
  // Validate valid attribute keys
  for key in valid_attribute_keys {
    assert_true(key.length() > 0)
    assert_true(key.length() <= 255)
    assert_false(key.starts_with("."))
    assert_false(key.ends_with("."))
    assert_false(key.contains(".."))
    assert_false(key.contains(" "))
    assert_false(key.contains("/"))
    assert_false(key.contains("\\"))
  }
  
  // Validate invalid attribute keys
  for key in invalid_attribute_keys {
    if key.length() == 0 {
      assert_eq(key.length(), 0)
    } else if key.length() > 255 {
      assert_true(key.length() > 255)
    } else if key.starts_with(".") || key.ends_with(".") || key.contains("..") {
      assert_true(true)
    } else if key.contains(" ") || key.contains("/") || key.contains("\\") {
      assert_true(true)
    }
  }
  
  // Test attribute value validation
  let valid_attribute_values = [
    "simple-value",
    "value_with_underscores",
    "value-with-dashes",
    "value123withnumbers",
    "value.with.dots",
    "value with spaces",
    "value/with/slashes",
    "value\\with\\backslashes",
    "value@with#special$chars%",
    "value with unicode: æµ‹è¯•",
    "value with emoji: ðŸš€",
    "value with\nnewlines",
    "value with\ttabs",
    "value with \"quotes\"",
    "value with 'apostrophes'",
    "",  // Empty value is allowed
    "A".repeat(10000)  // Long value
  ]
  
  // Validate valid attribute values
  for value in valid_attribute_values {
    // All values should be valid (no restrictions on attribute values)
    assert_true(true)
  }
  
  // Test resource attribute consistency
  let resource_attributes = [
    ("service.name", "azimuth-service"),
    ("service.version", "1.0.0"),
    ("service.namespace", "production"),
    ("host.name", "web-server-01"),
    ("host.ip", "192.168.1.100"),
    ("process.id", "12345"),
    ("process.executable.name", "azimuth-binary")
  ]
  
  // Validate service attributes consistency
  let service_name = resource_attributes.filter(|(k, _)| k == "service.name")[0][1]
  let service_version = resource_attributes.filter(|(k, _)| k == "service.version")[0][1]
  let service_namespace = resource_attributes.filter(|(k, _)| k == "service.namespace")[0][1]
  
  assert_eq(service_name, "azimuth-service")
  assert_eq(service_version, "1.0.0")
  assert_eq(service_namespace, "production")
  
  // Validate host attributes consistency
  let host_name = resource_attributes.filter(|(k, _)| k == "host.name")[0][1]
  let host_ip = resource_attributes.filter(|(k, _)| k == "host.ip")[0][1]
  
  assert_eq(host_name, "web-server-01")
  assert_eq(host_ip, "192.168.1.100")
  
  // Validate process attributes consistency
  let process_id = resource_attributes.filter(|(k, _)| k == "process.id")[0][1]
  let process_executable = resource_attributes.filter(|(k, _)| k == "process.executable.name")[0][1]
  
  assert_eq(process_id, "12345")
  assert_eq(process_executable, "azimuth-binary")
}

// Test 5: Context Propagation Integrity Validation
test "context propagation integrity validation" {
  // Test traceparent header validation
  let valid_traceparents = [
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",
    "00-1234567890abcdef1234567890abcdef-1234567890abcdef-01",
    "00-abcdef0123456789abcdef0123456789-ffffffffffffffff-01"
  ]
  
  let invalid_traceparents = [
    "",  // Empty
    "invalid-format",  // Wrong format
    "00-0af7651916cd43dd8448eb211c80319c",  // Missing parts
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331",  // Missing flags
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01-extra",  // Too many parts
    "invalid-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // Invalid version
    "00-invalid_trace_id-b7ad6b7169203331-01",  // Invalid trace ID
    "00-0af7651916cd43dd8448eb211c80319c-invalid_span_id-01",  // Invalid span ID
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-invalid"  // Invalid flags
  ]
  
  // Validate valid traceparent headers
  for traceparent in valid_traceparents {
    let parts = traceparent.split("-")
    assert_eq(parts.length(), 4)
    assert_eq(parts[0], "00")  // Version
    assert_eq(parts[1].length(), 32)  // Trace ID
    assert_eq(parts[2].length(), 16)  // Span ID
    assert_eq(parts[3].length(), 2)   // Flags
    assert_true(parts[1].chars().all(|c| c.is_ascii_hexdigit()))
    assert_true(parts[2].chars().all(|c| c.is_ascii_hexdigit()))
    assert_true(parts[3].chars().all(|c| c.is_ascii_hexdigit()))
  }
  
  // Validate invalid traceparent headers
  for traceparent in invalid_traceparents {
    let parts = traceparent.split("-")
    if parts.length() != 4 {
      assert_true(parts.length() != 4)
    } else if parts[0] != "00" {
      assert_true(parts[0] != "00")
    } else if parts[1].length() != 32 || parts[2].length() != 16 || parts[3].length() != 2 {
      assert_true(parts[1].length() != 32 || parts[2].length() != 16 || parts[3].length() != 2)
    }
  }
  
  // Test baggage validation
  let valid_baggage_items = [
    ("user.id", "12345"),
    ("session.id", "abcdef"),
    ("request.id", "req-789"),
    ("service.version", "1.0.0"),
    ("deployment.environment", "production")
  ]
  
  let invalid_baggage_items = [
    ("user.id", "123,456"),  // Comma in value
    ("session=id", "abcdef"),  // Equals in key
    ("", "empty_key"),  // Empty key
    ("valid.key", ""),  // Empty value
    ("space key", "value"),  // Space in key
    ("valid.key", "space value")  // Space in value
  ]
  
  // Validate valid baggage items
  for (key, value) in valid_baggage_items {
    assert_true(key.length() > 0)
    assert_false(key.contains(","))
    assert_false(key.contains("="))
    assert_false(key.contains(" "))
  }
  
  // Validate invalid baggage items
  for (key, value) in invalid_baggage_items {
    if key.length() == 0 || key.contains(",") || key.contains("=") || key.contains(" ") {
      assert_true(true)
    }
    if value.contains(",") || value.contains(" ") {
      assert_true(true)
    }
  }
  
  // Test baggage serialization integrity
  let baggage_items = [
    ("user.id", "12345"),
    ("session.id", "abcdef"),
    ("request.id", "req-789")
  ]
  
  let serialized_baggage = baggage_items.map(|(k, v)| k + "=" + v).reduce(|acc, item| acc + "," + item, "")
  assert_eq(serialized_baggage, "user.id=12345,session.id=abcdef,request.id=req-789")
  
  // Test baggage deserialization integrity
  let deserialized_items = serialized_baggage.split(",").map(|item| {
    let kv = item.split("=")
    if kv.length() == 2 {
      (kv[0], kv[1])
    } else {
      ("", "")
    }
  })
  
  assert_eq(deserialized_items.length(), 3)
  assert_eq(deserialized_items[0], ("user.id", "12345"))
  assert_eq(deserialized_items[1], ("session.id", "abcdef"))
  assert_eq(deserialized_items[2], ("request.id", "req-789"))
}

// Test 6: Serialization/Deserialization Integrity Validation
test "serialization deserialization integrity validation" {
  // Test span serialization/deserialization
  let span_data = [
    ("trace.id", "0af7651916cd43dd8448eb211c80319c"),
    ("span.id", "b7ad6b7169203331"),
    ("parent.span.id", "1111111111111111"),
    ("span.name", "http.request"),
    ("span.kind", "client"),
    ("start.time", "1640995200000"),
    ("end.time", "1640995201000"),
    ("status.code", "200"),
    ("status.message", "OK")
  ]
  
  // Serialize span data
  let serialized_span = span_data.map(|(k, v)| k + "=" + v).reduce(|acc, pair| acc + "," + pair, "")
  
  // Deserialize span data
  let deserialized_pairs = serialized_span.split(",").map(|pair| {
    let kv = pair.split("=")
    if kv.length() == 2 {
      (kv[0], kv[1])
    } else {
      ("", "")
    }
  })
  
  // Validate serialization/deserialization integrity
  assert_eq(deserialized_pairs.length(), span_data.length())
  for i = 0; i < span_data.length(); i = i + 1 {
    assert_eq(span_data[i], deserialized_pairs[i])
  }
  
  // Test metric serialization/deserialization
  let metric_data = [
    ("metric.name", "http.requests"),
    ("metric.type", "counter"),
    ("metric.value", "1000.0"),
    ("metric.unit", "count"),
    ("metric.time", "1640995200000"),
    ("metric.attributes", "method=GET,status=200")
  ]
  
  // Serialize metric data
  let serialized_metric = metric_data.map(|(k, v)| k + "=" + v).reduce(|acc, pair| acc + "," + pair, "")
  
  // Deserialize metric data
  let deserialized_metric = serialized_metric.split(",").map(|pair| {
    let kv = pair.split("=")
    if kv.length() == 2 {
      (kv[0], kv[1])
    } else {
      ("", "")
    }
  })
  
  // Validate serialization/deserialization integrity
  assert_eq(deserialized_metric.length(), metric_data.length())
  for i = 0; i < metric_data.length(); i = i + 1 {
    assert_eq(metric_data[i], deserialized_metric[i])
  }
  
  // Test log serialization/deserialization
  let log_data = [
    ("log.level", "info"),
    ("log.message", "Request processed successfully"),
    ("log.timestamp", "1640995201500"),
    ("trace.id", "0af7651916cd43dd8448eb211c80319c"),
    ("span.id", "b7ad6b7169203331"),
    ("log.attributes", "source=server,component=http")
  ]
  
  // Serialize log data
  let serialized_log = log_data.map(|(k, v)| k + "=" + v).reduce(|acc, pair| acc + "," + pair, "")
  
  // Deserialize log data
  let deserialized_log = serialized_log.split(",").map(|pair| {
    let kv = pair.split("=")
    if kv.length() == 2 {
      (kv[0], kv[1])
    } else {
      ("", "")
    }
  })
  
  // Validate serialization/deserialization integrity
  assert_eq(deserialized_log.length(), log_data.length())
  for i = 0; i < log_data.length(); i = i + 1 {
    assert_eq(log_data[i], deserialized_log[i])
  }
  
  // Test special characters in serialization
  let special_char_data = [
    ("message", "Line1\nLine2\tTabbed"),
    ("unicode", "æµ‹è¯•ä¸­æ–‡å­—ç¬¦"),
    ("emoji", "ðŸš€ðŸ“Š"),
    ("quotes", "Message with \"quotes\""),
    ("apostrophes", "Message with 'apostrophes'"),
    ("backslashes", "Path\\to\\file"),
    ("equals", "key=value pair"),
    ("commas", "value,with,commas")
  ]
  
  // Serialize and deserialize special character data
  let serialized_special = special_char_data.map(|(k, v)| k + "=" + v).reduce(|acc, pair| acc + "," + pair, "")
  let deserialized_special = serialized_special.split(",").map(|pair| {
    let kv = pair.split("=")
    if kv.length() >= 2 {
      (kv[0], kv[1])
    } else {
      ("", "")
    }
  })
  
  // Note: This test assumes simple KV serialization; in practice, special characters
  // would need proper escaping
  assert_eq(deserialized_special.length(), special_char_data.length())
}

// Test 7: Sampling Decision Integrity Validation
test "sampling decision integrity validation" {
  // Test sampling probability validation
  let valid_sampling_probabilities = [0.0, 0.001, 0.01, 0.1, 0.5, 0.9, 0.99, 1.0]
  let invalid_sampling_probabilities = [-0.1, -1.0, 1.1, 2.0, 100.0]
  
  // Validate valid probabilities
  for prob in valid_sampling_probabilities {
    assert_true(prob >= 0.0 && prob <= 1.0)
  }
  
  // Validate invalid probabilities
  for prob in invalid_sampling_probabilities {
    assert_true(prob < 0.0 || prob > 1.0)
  }
  
  // Test sampling decision consistency
  let sampling_probability = 0.1  // 10% sampling rate
  let total_requests = 10000
  
  // Simulate sampling decisions
  let mut sampled_count = 0
  for i = 0; i < total_requests; i = i + 1 {
    // Simple deterministic sampling based on index
    if i % 10 == 0 {
      sampled_count = sampled_count + 1
    }
  }
  
  let actual_sampling_rate = sampled_count.to_float() / total_requests.to_float()
  assert_eq(actual_sampling_rate, 0.1)
  
  // Test parent-based sampling consistency
  let parent_decisions = [true, false, true, true, false, true, false, false, true, false]
  let mut child_decisions = []
  
  for parent_sampled in parent_decisions {
    // Child follows parent decision
    let child_sampled = parent_sampled
    child_decisions = child_decisions.concat([child_sampled])
  }
  
  // Validate parent-child consistency
  assert_eq(parent_decisions.length(), child_decisions.length())
  for i = 0; i < parent_decisions.length(); i = i + 1 {
    assert_eq(parent_decisions[i], child_decisions[i])
  }
  
  // Test sampling attributes integrity
  let sampling_attributes = [
    ("sampler.type", "probabilistic"),
    ("sampler.param", "0.1"),
    ("decision", "record_and_sample"),
    ("trace.id", "0af7651916cd43dd8448eb211c80319c"),
    ("span.id", "b7ad6b7169203331")
  ]
  
  // Validate sampler type
  let sampler_type = sampling_attributes.filter(|(k, _)| k == "sampler.type")[0][1]
  assert_true(["probabilistic", "rate_limiting", "always_on", "always_off", "parent_based"].any(|valid| valid == sampler_type))
  
  // Validate sampler parameter
  let sampler_param = sampling_attributes.filter(|(k, _)| k == "sampler.param")[0][1]
  let param_value = sampler_param.to_float()
  assert_true(param_value >= 0.0 && param_value <= 1.0)
  
  // Validate decision
  let decision = sampling_attributes.filter(|(k, _)| k == "decision")[0][1]
  assert_true(["drop", "record_only", "record_and_sample"].any(|valid| valid == decision))
}

// Test 8: Cross-Component Data Consistency Validation
test "cross component data consistency validation" {
  // Test trace consistency across components
  let trace_id = "0af7651916cd43dd8448eb211c80319c"
  
  // Span data
  let span_data = [
    ("trace.id", trace_id),
    ("span.id", "b7ad6b7169203331"),
    ("span.name", "http.request")
  ]
  
  // Log data
  let log_data = [
    ("trace.id", trace_id),
    ("span.id", "b7ad6b7169203331"),
    ("log.level", "info"),
    ("log.message", "Processing request")
  ]
  
  // Metric data
  let metric_data = [
    ("metric.name", "http.requests"),
    ("trace.id", trace_id),
    ("metric.value", "1.0")
  ]
  
  // Validate trace ID consistency
  let span_trace_id = span_data.filter(|(k, _)| k == "trace.id")[0][1]
  let log_trace_id = log_data.filter(|(k, _)| k == "trace.id")[0][1]
  let metric_trace_id = metric_data.filter(|(k, _)| k == "trace.id")[0][1]
  
  assert_eq(span_trace_id, trace_id)
  assert_eq(log_trace_id, trace_id)
  assert_eq(metric_trace_id, trace_id)
  assert_eq(span_trace_id, log_trace_id)
  assert_eq(log_trace_id, metric_trace_id)
  
  // Test timestamp consistency
  let base_timestamp = 1640995200000
  
  let span_start = base_timestamp
  let span_end = base_timestamp + 1000
  let log_timestamp = base_timestamp + 500
  let metric_timestamp = base_timestamp + 1000
  
  // Validate timestamp ordering
  assert_true(span_start <= log_timestamp)
  assert_true(log_timestamp <= span_end)
  assert_true(span_end == metric_timestamp)
  
  // Test resource consistency across components
  let resource_attributes = [
    ("service.name", "azimuth-service"),
    ("service.version", "1.0.0"),
    ("host.name", "web-server-01")
  ]
  
  // Simulate resource attachment to different components
  let span_with_resource = span_data.concat(resource_attributes)
  let log_with_resource = log_data.concat(resource_attributes)
  let metric_with_resource = metric_data.concat(resource_attributes)
  
  // Validate resource consistency
  for (key, value) in resource_attributes {
    let span_value = span_with_resource.filter(|(k, _)| k == key)[0][1]
    let log_value = log_with_resource.filter(|(k, _)| k == key)[0][1]
    let metric_value = metric_with_resource.filter(|(k, _)| k == key)[0][1]
    
    assert_eq(span_value, value)
    assert_eq(log_value, value)
    assert_eq(metric_value, value)
  }
  
  // Test attribute consistency across components
  let shared_attributes = [
    ("user.id", "12345"),
    ("operation.type", "http.request"),
    ("http.method", "GET"),
    ("http.url", "/api/users")
  ]
  
  // Add shared attributes to components
  let span_with_attrs = span_with_resource.concat(shared_attributes)
  let log_with_attrs = log_with_resource.concat(shared_attributes)
  
  // Validate shared attributes consistency
  for (key, value) in shared_attributes {
    let span_value = span_with_attrs.filter(|(k, _)| k == key)[0][1]
    let log_value = log_with_attrs.filter(|(k, _)| k == key)[0][1]
    
    assert_eq(span_value, value)
    assert_eq(log_value, value)
  }
}