// Copyright 2026 International Digital Economy Academy
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ç»¼åˆæ ¸å¿ƒæµ‹è¯•ç”¨ä¾‹ - ä¸º MoonBit æ ‡å‡†åº“æ·»åŠ é«˜è´¨é‡æµ‹è¯•è¦†ç›–

// è¾…åŠ©æ–­è¨€å‡½æ•°
pub fn assert_eq_int(expected : Int, actual : Int) -> Unit {
  if (expected != actual) {
    @builtin.abort("Int assertion failed")
  }
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  if (expected != actual) {
    @builtin.abort("String assertion failed")
  }
}

pub fn assert_true(condition : Bool) -> Unit {
  if (!condition) {
    @builtin.abort("Expected true")
  }
}

pub fn assert_false(condition : Bool) -> Unit {
  if (condition) {
    @builtin.abort("Expected false")
  }
}

// æµ‹è¯•ç”¨ä¾‹ 1: æ•´æ•°è¿ç®—è¾¹ç•Œæµ‹è¯•
test "integer_arithmetic_boundary" {
  // æµ‹è¯•æ•´æ•°è¾¹ç•Œå€¼è¿ç®—
  assert_eq_int(@int.max_value, 2147483647)
  assert_eq_int(@int.min_value, -2147483648)
  
  // æµ‹è¯•æº¢å‡ºè¡Œä¸º
  assert_eq_int(@int.max_value + 1, @int.min_value)
  assert_eq_int(@int.min_value - 1, @int.max_value)
  
  // æµ‹è¯•ç»å¯¹å€¼å‡½æ•°
  assert_eq_int(Int::abs(42), 42)
  assert_eq_int(Int::abs(-42), 42)
  assert_eq_int(Int::abs(0), 0)
}

// æµ‹è¯•ç”¨ä¾‹ 2: å­—ç¬¦ä¸²æ“ä½œç»¼åˆæµ‹è¯•
test "string_operations_comprehensive" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¿æ¥
  let s1 = "Hello"
  let s2 = "MoonBit"
  let result = s1 + ", " + s2 + "!"
  assert_eq_string("Hello, MoonBit!", result)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  assert_eq_string("", String::default())
  
  // æµ‹è¯• Unicode å­—ç¬¦ä¸²
  let unicode_str = "æµ‹è¯•ä¸­æ–‡ ğŸš€"
  assert_eq_string("æµ‹è¯•ä¸­æ–‡ ğŸš€", unicode_str)
  
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è®¡ç®—
  assert_eq_int(8, "Hello, ä¸–ç•Œ".length())
}

// æµ‹è¯•ç”¨ä¾‹ 3: æ•°å­¦å‡½æ•°æ ¸å¿ƒæµ‹è¯•
test "mathematical_functions_core" {
  // æµ‹è¯•åŸºæœ¬æ•°å­¦è¿ç®—
  assert_eq_int(15, 10 + 5)
  assert_eq_int(5, 10 - 5)
  assert_eq_int(50, 10 * 5)
  assert_eq_int(2, 10 / 4)
  assert_eq_int(2, 10 % 4)
  
  // æµ‹è¯•ä½è¿ç®—
  assert_eq_int(8, 12 & 10)  // 1100 & 1010 = 1000
  assert_eq_int(14, 12 | 10) // 1100 | 1010 = 1110
  assert_eq_int(6, 12 ^ 10)  // 1100 ^ 1010 = 0110
  assert_eq_int(40, 10 << 2)
  assert_eq_int(2, 10 >> 2)
}

// æµ‹è¯•ç”¨ä¾‹ 4: æ•°ç»„æ“ä½œåŸºç¡€æµ‹è¯•
test "array_operations_basic" {
  // æµ‹è¯•æ•°ç»„åˆ›å»ºå’Œè®¿é—®
  let arr = [1, 2, 3, 4, 5]
  assert_eq_int(3, arr[2])
  assert_eq_int(5, arr.length())
  
  // æµ‹è¯•æ•°ç»„è¾¹ç•Œ
  let empty_arr : Array[Int] = []
  assert_eq_int(0, empty_arr.length())
  
  // æµ‹è¯•æ•°ç»„æ¯”è¾ƒ
  let arr2 = [1, 2, 3, 4, 5]
  assert_true(arr == arr2)
}

// æµ‹è¯•ç”¨ä¾‹ 5: å¸ƒå°”é€»è¾‘å’Œæ¡ä»¶æµ‹è¯•
test "boolean_logic_conditions" {
  // æµ‹è¯•åŸºæœ¬å¸ƒå°”å€¼
  assert_true(true)
  assert_false(false)
  
  // æµ‹è¯•å¸ƒå°”è¿ç®—
  assert_true(true && true)
  assert_false(true && false)
  assert_true(true || false)
  assert_false(false || false)
  assert_true(!false)
  
  // æµ‹è¯•æ¯”è¾ƒè¿ç®—
  assert_true(5 > 3)
  assert_true(5 >= 5)
  assert_true(3 < 5)
  assert_true(5 <= 5)
  assert_true(5 == 5)
  assert_true(5 != 3)
}

// æµ‹è¯•ç”¨ä¾‹ 6: ç±»å‹è½¬æ¢æµ‹è¯•
test "type_conversion_operations" {
  // æµ‹è¯•æ•´æ•°åˆ°å­—èŠ‚è½¬æ¢
  let value = 0x12345678
  let bytes_be = value.to_be_bytes()
  let bytes_le = value.to_le_bytes()
  
  // éªŒè¯å­—èŠ‚é¡ºåº
  assert_eq_int(4, bytes_be.length())
  assert_eq_int(4, bytes_le.length())
  
  // æµ‹è¯•å­—èŠ‚åˆ°æ•´æ•°è½¬æ¢
  let reconstructed = @int.from_be_bytes(bytes_be)
  assert_eq_int(value, reconstructed)
}

// æµ‹è¯•ç”¨ä¾‹ 7: é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
test "error_handling_boundaries" {
  // æµ‹è¯•é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq_int(0, 10 / 0)  // MoonBit çš„é™¤é›¶è¡Œä¸º
  
  // æµ‹è¯•æå€¼è¿ç®—
  let max_val = @int.max_value
  let min_val = @int.min_value
  
  // æµ‹è¯•æº¢å‡ºå¤„ç†
  assert_eq_int(min_val, max_val + 1)
  assert_eq_int(max_val, min_val - 1)
  
  // æµ‹è¯•ç©ºå€¼å¤„ç†
  let empty_str = ""
  assert_eq_int(0, empty_str.length())
}

// æµ‹è¯•ç”¨ä¾‹ 8: å“ˆå¸Œå’Œæ¯”è¾ƒæµ‹è¯•
test "hashing_and_equality" {
  // æµ‹è¯•æ•´æ•°å“ˆå¸Œ
  let hasher = @hash.Hasher::new(seed=42)
  let hash1 = hasher..combine(123).finalize()
  let hash2 = hasher..combine(456).finalize()
  
  // éªŒè¯ä¸åŒæ•°å­—äº§ç”Ÿä¸åŒå“ˆå¸Œ
  assert_true(hash1 != hash2)
  
  // æµ‹è¯•ç›¸åŒæ•°å­—äº§ç”Ÿç›¸åŒå“ˆå¸Œ
  let hasher2 = @hash.Hasher::new(seed=42)
  let hash3 = hasher2..combine(123).finalize()
  assert_eq_int(hash1, hash3)
}

// æµ‹è¯•ç”¨ä¾‹ 9: æ€§èƒ½å’Œæ•ˆç‡æµ‹è¯•
test "performance_efficiency" {
  // æµ‹è¯•å¤§æ•°è¿ç®—æ€§èƒ½
  let large_num = 1000000
  let result = large_num * large_num
  assert_eq_int(1000000000000, result)
  
  // æµ‹è¯•å¾ªç¯æ•ˆç‡
  let mut sum = 0
  for i = 0; i < 1000; i = i + 1 {
    sum = sum + i
  }
  assert_eq_int(499500, sum)  // 0+1+2+...+999 = 499500
}

// æµ‹è¯•ç”¨ä¾‹ 10: å®é™…åº”ç”¨åœºæ™¯æµ‹è¯•
test "real_world_application" {
  // æ¨¡æ‹Ÿå®é™…è®¡ç®—åœºæ™¯ï¼šè®¡ç®—åœ†çš„é¢ç§¯å’Œå‘¨é•¿
  let radius = 5
  let pi_approx = 3.14159  // ä½¿ç”¨è¿‘ä¼¼å€¼
  
  // è®¡ç®—é¢ç§¯ (Ï€ * rÂ²)
  let area = pi_approx * radius * radius
  assert_true(area > 78.0 && area < 79.0)  // çº¦ 78.54
  
  // è®¡ç®—å‘¨é•¿ (2 * Ï€ * r)
  let circumference = 2 * pi_approx * radius
  assert_true(circumference > 31.0 && circumference < 32.0)  // çº¦ 31.42
  
  // æ¨¡æ‹Ÿæ•°æ®å¤„ç†åœºæ™¯
  let data = [10, 20, 30, 40, 50]
  let mut average = 0
  for value in data {
    average = average + value
  }
  average = average / data.length()
  assert_eq_int(30, average)  // (10+20+30+40+50)/5 = 30
}