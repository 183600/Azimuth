// Azimuth é«˜çº§é¥æµ‹å¢å¼ºæµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºè¾¹ç•Œæ¡ä»¶ã€æ€§èƒ½ä¼˜åŒ–å’Œé›†æˆæµ‹è¯•

// æµ‹è¯•1: è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†
test "è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†å¢å¼ºæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.test")
  
  // æµ‹è¯•ç©ºå€¼å’Œnullå¤„ç†
  let empty_span = Tracer::start_span(tracer, "")
  assert_eq(Span::name(empty_span), "")
  Span::end(empty_span)
  
  // æµ‹è¯•æå€¼å¤„ç†
  let extreme_span = Tracer::start_span(tracer, "extreme.values.test")
  Span::set_attribute(extreme_span, "max.int", IntValue(2147483647))
  Span::set_attribute(extreme_span, "min.int", IntValue(-2147483648))
  Span::set_attribute(extreme_span, "max.float", FloatValue(1.7976931348623157e+308))
  Span::set_attribute(extreme_span, "min.float", FloatValue(-1.7976931348623157e+308))
  Span::set_attribute(extreme_span, "empty.string", StringValue(""))
  Span::set_attribute(extreme_span, "zero.value", IntValue(0))
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²å¤„ç†
  let long_string = "a" * 10000
  Span::set_attribute(extreme_span, "long.string", StringValue(long_string))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  Span::set_attribute(extreme_span, "special.chars", StringValue("ç‰¹æ®Šå­—ç¬¦ğŸš€
	\r\"'"))
  Span::set_attribute(extreme_span, "unicode.chars", StringValue("ğŸŒŸâœ¨ğŸ’«â­ğŸŒ™"))
  
  Span::end(extreme_span)
  
  // éªŒè¯è¾¹ç•Œæ¡ä»¶å¤„ç†
  assert_eq(Span::status(empty_span), Ok)
  assert_eq(Span::status(extreme_span), Ok)
}

// æµ‹è¯•2: æ€§èƒ½ä¼˜åŒ–å’Œèµ„æºç®¡ç†
test "æ€§èƒ½ä¼˜åŒ–å’Œèµ„æºç®¡ç†æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "performance.optimization")
  
  // åˆ›å»ºèµ„æºé™åˆ¶ç›‘æ§
  let memory_usage = Meter::create_gauge(meter, "memory.usage.bytes")
  let cpu_usage = Meter::create_gauge(meter, "cpu.usage.percent")
  let gc_count = Meter::create_counter(meter, "gc.count")
  let thread_count = Meter::create_gauge(meter, "thread.count")
  
  // æ¨¡æ‹Ÿèµ„æºä½¿ç”¨æƒ…å†µ
  let mut i = 0
  while i < 1000 {
    // æ¨¡æ‹Ÿå†…å­˜åˆ†é…
    let temp_array = Array::new(1000)
    
    // æ¨¡æ‹ŸCPUä½¿ç”¨
    let mut j = 0
    while j < 100 {
      j = j + 1
    }
    
    // æ›´æ–°èµ„æºæŒ‡æ ‡
    if i % 100 == 0 {
      Gauge::set(memory_usage, IntValue(i * 1024))
      Gauge::set(cpu_usage, FloatValue(50.0 + (i % 50)))
      Counter::add(gc_count, 1.0)
      Gauge::set(thread_count, IntValue(4 + (i % 8)))
    }
    
    i = i + 1
  }
  
  // éªŒè¯èµ„æºç®¡ç†
  assert_true(Gauge::value(memory_usage) > 0)
  assert_true(Gauge::value(cpu_usage) > 0)
  assert_true(Counter::value(gc_count) > 0)
  assert_true(Gauge::value(thread_count) > 0)
}

// æµ‹è¯•3: è·¨æœåŠ¡é›†æˆå’Œä¸Šä¸‹æ–‡ä¼ æ’­
test "è·¨æœåŠ¡é›†æˆå’Œä¸Šä¸‹æ–‡ä¼ æ’­æµ‹è¯•" {
  // åˆ›å»ºæœåŠ¡Açš„è¿½è¸ªä¸Šä¸‹æ–‡
  let service_a_tracer = TracerProvider::get_tracer(TracerProvider::default(), "service.a")
  let service_a_span = Tracer::start_span(service_a_tracer, "service.a.request")
  let service_a_context = Span::context(service_a_span)
  
  // æ·»åŠ æœåŠ¡Aç‰¹å®šçš„å±æ€§
  Span::set_attribute(service_a_span, "service.name", StringValue("service.a"))
  Span::set_attribute(service_a_span, "service.version", StringValue("1.0.0"))
  Span::set_attribute(service_a_span, "http.method", StringValue("POST"))
  Span::set_attribute(service_a_span, "http.url", StringValue("https://service-a.example.com/api"))
  
  // åˆ›å»ºä¼ æ’­å™¨
  let propagator = CompositePropagator::new([
    W3CTraceContextPropagator::new(),
    W3CBaggagePropagator::new()
  ])
  
  // åˆ›å»ºè½½ä½“å¹¶æ³¨å…¥ä¸Šä¸‹æ–‡
  let carrier = TextMapCarrier::new()
  CompositePropagator::inject(propagator, service_a_context, carrier)
  
  // æ¨¡æ‹Ÿç½‘ç»œä¼ è¾“
  let headers = TextMapCarrier::to_map(carrier)
  
  // æœåŠ¡Bæ¥æ”¶è¯·æ±‚å¹¶æå–ä¸Šä¸‹æ–‡
  let service_b_tracer = TracerProvider::get_tracer(TracerProvider::default(), "service.b")
  let service_b_carrier = TextMapCarrier::from_map(headers)
  let extracted_context = CompositePropagator::extract(propagator, service_b_carrier)
  
  // åˆ›å»ºæœåŠ¡Bçš„span
  let service_b_span = Tracer::start_span_with_context(service_b_tracer, "service.b.processing", extracted_context)
  Span::set_attribute(service_b_span, "service.name", StringValue("service.b"))
  Span::set_attribute(service_b_span, "service.version", StringValue("2.1.0"))
  Span::set_attribute(service_b_span, "database.query", StringValue("SELECT * FROM users"))
  
  // æœåŠ¡Bè°ƒç”¨æœåŠ¡C
  let service_b_context = Span::context(service_b_span)
  let service_c_carrier = TextMapCarrier::new()
  CompositePropagator::inject(propagator, service_b_context, service_c_carrier)
  
  // æœåŠ¡Cå¤„ç†è¯·æ±‚
  let service_c_tracer = TracerProvider::get_tracer(TracerProvider::default(), "service.c")
  let service_c_carrier_from_b = TextMapCarrier::from_map(TextMapCarrier::to_map(service_c_carrier))
  let service_c_context = CompositePropagator::extract(propagator, service_c_carrier_from_b)
  
  let service_c_span = Tracer::start_span_with_context(service_c_tracer, "service.c.computation", service_c_context)
  Span::set_attribute(service_c_span, "service.name", StringValue("service.c"))
  Span::set_attribute(service_c_span, "computation.type", StringValue("matrix.multiplication"))
  Span::set_attribute(service_c_span, "computation.time.ms", IntValue(250))
  
  // å®Œæˆæ‰€æœ‰span
  Span::end(service_c_span)
  Span::end(service_b_span)
  Span::end(service_a_span)
  
  // éªŒè¯è·¨æœåŠ¡è¿½è¸ª
  assert_eq(Span::status(service_a_span), Ok)
  assert_eq(Span::status(service_b_span), Ok)
  assert_eq(Span::status(service_c_span), Ok)
}

// æµ‹è¯•4: æ•°æ®å®Œæ•´æ€§éªŒè¯
test "æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "data.integrity")
  
  // åˆ›å»ºæ•°æ®å®Œæ•´æ€§ç›‘æ§æŒ‡æ ‡
  let data_checksum = Meter::create_gauge(meter, "data.checksum")
  let corruption_count = Meter::create_counter(meter, "data.corruption.count")
  let validation_success = Meter::create_counter(meter, "data.validation.success")
  let validation_failure = Meter::create_counter(meter, "data.validation.failure")
  
  // æ¨¡æ‹Ÿæ•°æ®ä¼ è¾“å’ŒéªŒè¯
  let original_data = "important telemetry data"
  let checksum = calculate_checksum(original_data)
  
  // æ¨¡æ‹Ÿæ­£å¸¸ä¼ è¾“
  let transmitted_data = original_data
  let transmitted_checksum = calculate_checksum(transmitted_data)
  
  if transmitted_checksum == checksum {
    Counter::add(validation_success, 1.0)
    Gauge::set(data_checksum, IntValue(transmitted_checksum))
  } else {
    Counter::add(validation_failure, 1.0)
    Counter::add(corruption_count, 1.0)
  }
  
  // æ¨¡æ‹Ÿæ•°æ®æŸå
  let corrupted_data = original_data + "corrupted"
  let corrupted_checksum = calculate_checksum(corrupted_data)
  
  if corrupted_checksum == checksum {
    Counter::add(validation_success, 1.0)
  } else {
    Counter::add(validation_failure, 1.0)
    Counter::add(corruption_count, 1.0)
  }
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§ç›‘æ§
  assert_eq(Counter::value(validation_success), 1.0)
  assert_eq(Counter::value(validation_failure), 1.0)
  assert_eq(Counter::value(corruption_count), 1.0)
}

// æµ‹è¯•5: å®æ—¶é¥æµ‹å¤„ç†
test "å®æ—¶é¥æµ‹å¤„ç†æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "realtime.processing")
  
  // åˆ›å»ºå®æ—¶å¤„ç†æŒ‡æ ‡
  let processing_latency = Meter::create_histogram(meter, "processing.latency.ms")
  let throughput = Meter::create_counter(meter, "events.processed")
  let error_rate = Meter::create_gauge(meter, "error.rate.percent")
  let queue_size = Meter::create_gauge(meter, "queue.size")
  
  // æ¨¡æ‹Ÿå®æ—¶äº‹ä»¶å¤„ç†
  let mut total_events = 0
  let mut error_count = 0
  let start_time = Time::now()
  
  // å¤„ç†1000ä¸ªäº‹ä»¶
  let mut i = 0
  while i < 1000 {
    let event_start = Time::now()
    
    // æ¨¡æ‹Ÿäº‹ä»¶å¤„ç†
    let processing_time = Random::float() * 10.0 // 0-10mså¤„ç†æ—¶é—´
    Histogram::record(processing_latency, processing_time)
    
    // æ¨¡æ‹Ÿé”™è¯¯å‘ç”Ÿï¼ˆ5%æ¦‚ç‡ï¼‰
    if Random::float() < 0.05 {
      error_count = error_count + 1
    }
    
    // æ›´æ–°é˜Ÿåˆ—å¤§å°
    let current_queue_size = Random::int() % 100
    Gauge::set(queue_size, IntValue(current_queue_size))
    
    total_events = total_events + 1
    Counter::add(throughput, 1.0)
    
    i = i + 1
  }
  
  let end_time = Time::now()
  let total_processing_time = Time::difference(end_time, start_time)
  
  // è®¡ç®—é”™è¯¯ç‡
  let error_percentage = (error_count * 100) / total_events
  Gauge::set(error_rate, FloatValue(error_percentage))
  
  // éªŒè¯å®æ—¶å¤„ç†æŒ‡æ ‡
  assert_eq(Counter::value(throughput), 1000.0)
  assert_true(Gauge::value(error_rate) >= 0.0)
  assert_true(Gauge::value(queue_size) >= 0)
}

// æµ‹è¯•6: æ—¶é—´åºåˆ—æ•°æ®å¤„ç†
test "æ—¶é—´åºåˆ—æ•°æ®å¤„ç†æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "timeseries.processing")
  
  // åˆ›å»ºæ—¶é—´åºåˆ—æŒ‡æ ‡
  let metric_value = Meter::create_gauge(meter, "metric.value")
  let timestamp = Meter::create_gauge(meter, "timestamp")
  let data_points = Meter::create_counter(meter, "data.points.count")
  
  // ç”Ÿæˆæ—¶é—´åºåˆ—æ•°æ®
  let base_time = Time::now()
  let mut i = 0
  while i < 100 {
    let current_time = Time::add_seconds(base_time, i)
    let metric_value_at_time = 100.0 + (10.0 * Math::sin(i * 0.1))
    
    // è®°å½•æ—¶é—´åºåˆ—æ•°æ®ç‚¹
    Gauge::set(metric_value, FloatValue(metric_value_at_time))
    Gauge::set(timestamp, IntValue(Time::to_unix(current_time)))
    Counter::add(data_points, 1.0)
    
    i = i + 1
  }
  
  // éªŒè¯æ—¶é—´åºåˆ—æ•°æ®
  assert_eq(Counter::value(data_points), 100.0)
  assert_true(Gauge::value(timestamp) > 0)
}

// æµ‹è¯•7: å¹¶å‘å®‰å…¨æ€§éªŒè¯
test "å¹¶å‘å®‰å…¨æ€§éªŒè¯æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "concurrency.safety")
  
  // åˆ›å»ºå¹¶å‘å®‰å…¨æŒ‡æ ‡
  let concurrent_operations = Meter::create_counter(meter, "concurrent.operations")
  let lock_contentions = Meter::create_counter(meter, "lock.contentions")
  let race_conditions = Meter::create_counter(meter, "race.conditions")
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ
  let shared_counter = AtomicInt::new(0)
  let mutex = Mutex::new()
  
  // æ¨¡æ‹Ÿ10ä¸ªå¹¶å‘çº¿ç¨‹
  let threads = []
  let mut i = 0
  while i < 10 {
    let thread = Thread::spawn(fn() {
      let mut j = 0
      while j < 100 {
        // æ— é”æ“ä½œï¼ˆå¯èƒ½å¯¼è‡´ç«äº‰æ¡ä»¶ï¼‰
        let old_value = AtomicInt::get(shared_counter)
        AtomicInt::set(shared_counter, old_value + 1)
        Counter::add(concurrent_operations, 1.0)
        
        // æœ‰é”æ“ä½œï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
        Mutex::lock(mutex)
        // ä¸´ç•ŒåŒºæ“ä½œ
        Mutex::unlock(mutex)
        
        j = j + 1
      }
    })
    threads = threads.push(thread)
    i = i + 1
  }
  
  // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
  let mut i = 0
  while i < threads.length() {
    Thread::join(threads[i])
    i = i + 1
  }
  
  // éªŒè¯å¹¶å‘å®‰å…¨æ€§
  let final_counter = AtomicInt::get(shared_counter)
  assert_eq(final_counter, 1000) // 10 threads * 100 operations each
  assert_eq(Counter::value(concurrent_operations), 1000.0)
}

// æµ‹è¯•8: å¤šç»´å±æ€§æŸ¥è¯¢
test "å¤šç»´å±æ€§æŸ¥è¯¢æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "multidimensional.query")
  
  // åˆ›å»ºå¤šç»´å±æ€§æŒ‡æ ‡
  let request_count = Meter::create_counter(meter, "http.requests")
  
  // å®šä¹‰å±æ€§ç»´åº¦
  let dimensions = [
    ("service.name", "payment.service"),
    ("service.version", "1.2.3"),
    ("http.method", "GET"),
    ("http.status_code", "200"),
    ("region", "us-west-2"),
    ("environment", "production")
  ]
  
  // è®°å½•ä¸åŒç»´åº¦çš„æŒ‡æ ‡
  let mut i = 0
  while i < 100 {
    // åŠ¨æ€åˆ›å»ºä¸åŒç»´åº¦çš„æŒ‡æ ‡
    let status_code = if i % 10 == 0 { "500" } else { "200" }
    let method = if i % 2 == 0 { "GET" } else { "POST" }
    let region = match i % 3 {
      0 => "us-west-2"
      1 => "us-east-1"
      _ => "eu-west-1"
    }
    
    let attrs = [
      ("service.name", "payment.service"),
      ("http.method", method),
      ("http.status_code", status_code),
      ("region", region)
    ]
    
    Counter::add_with_attributes(request_count, 1.0, attrs)
    i = i + 1
  }
  
  // æŸ¥è¯¢ç‰¹å®šç»´åº¦çš„æŒ‡æ ‡
  let success_requests = Counter::get_with_attribute(request_count, "http.status_code", "200")
  let error_requests = Counter::get_with_attribute(request_count, "http.status_code", "500")
  let get_requests = Counter::get_with_attribute(request_count, "http.method", "GET")
  let post_requests = Counter::get_with_attribute(request_count, "http.method", "POST")
  
  // éªŒè¯å¤šç»´æŸ¥è¯¢ç»“æœ
  assert_true(success_requests > error_requests)
  assert_true(get_requests > 0)
  assert_true(post_requests > 0)
}

// æµ‹è¯•9: èµ„æºé™åˆ¶å’Œæ¢å¤
test "èµ„æºé™åˆ¶å’Œæ¢å¤æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "resource.limits")
  
  // åˆ›å»ºèµ„æºé™åˆ¶æŒ‡æ ‡
  let memory_limit = Meter::create_gauge(meter, "memory.limit.bytes")
  let memory_usage = Meter::create_gauge(meter, "memory.usage.bytes")
  let circuit_breaker_state = Meter::create_gauge(meter, "circuit.breaker.state")
  let recovery_time = Meter::create_histogram(meter, "recovery.time.ms")
  
  // è®¾ç½®èµ„æºé™åˆ¶
  let max_memory = 100 * 1024 * 1024 // 100MB
  Gauge::set(memory_limit, IntValue(max_memory))
  
  // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨å¢é•¿
  let mut current_memory = 0
  let mut i = 0
  while i < 1000 {
    current_memory = current_memory + 1024 * 10 // æ¯æ¬¡å¢åŠ 10KB
    Gauge::set(memory_usage, IntValue(current_memory))
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
    if current_memory > max_memory {
      // è§¦å‘æ–­è·¯å™¨
      Gauge::set(circuit_breaker_state, IntValue(1)) // 1 = open
      
      // æ¨¡æ‹Ÿæ¢å¤è¿‡ç¨‹
      let recovery_start = Time::now()
      Time::sleep(100) // æ¨¡æ‹Ÿæ¢å¤æ—¶é—´
      let recovery_end = Time::now()
      let recovery_duration = Time::difference(recovery_end, recovery_start)
      
      Histogram::record(recovery_time, recovery_duration)
      
      // é‡ç½®å†…å­˜ä½¿ç”¨
      current_memory = 0
      Gauge::set(memory_usage, IntValue(current_memory))
      Gauge::set(circuit_breaker_state, IntValue(0)) // 0 = closed
    }
    
    i = i + 1
  }
  
  // éªŒè¯èµ„æºé™åˆ¶å’Œæ¢å¤
  assert_eq(Gauge::value(memory_limit), IntValue(max_memory))
  assert_true(Gauge::value(circuit_breaker_state) == IntValue(0)) // æœ€ç»ˆåº”è¯¥æ˜¯å…³é—­çŠ¶æ€
}

// æµ‹è¯•10: å¹³å°å…¼å®¹æ€§æµ‹è¯•
test "å¹³å°å…¼å®¹æ€§æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "platform.compatibility")
  
  // åˆ›å»ºå¹³å°å…¼å®¹æ€§span
  let platform_span = Tracer::start_span(tracer, "platform.compatibility.test")
  
  // æ£€æµ‹å¹³å°ä¿¡æ¯
  let platform_info = Platform::detect()
  
  // è®¾ç½®å¹³å°ç›¸å…³å±æ€§
  Span::set_attribute(platform_span, "platform.name", StringValue(platform_info.name))
  Span::set_attribute(platform_span, "platform.version", StringValue(platform_info.version))
  Span::set_attribute(platform_span, "platform.arch", StringValue(platform_info.arch))
  Span::set_attribute(platform_span, "platform.runtime", StringValue(platform_info.runtime))
  
  // æµ‹è¯•å¹³å°ç‰¹å®šåŠŸèƒ½
  let platform_features = Platform::available_features()
  let mut i = 0
  while i < platform_features.length() {
    let feature = platform_features[i]
    Span::set_attribute(platform_span, "platform.feature." + feature, BoolValue(true))
    i = i + 1
  }
  
  // æµ‹è¯•è·¨å¹³å°API
  let time_precision = Platform::time_precision()
  let max_concurrent_threads = Platform::max_concurrent_threads()
  let memory_alignment = Platform::memory_alignment()
  
  Span::set_attribute(platform_span, "platform.time.precision", IntValue(time_precision))
  Span::set_attribute(platform_span, "platform.max.threads", IntValue(max_concurrent_threads))
  Span::set_attribute(platform_span, "platform.memory.alignment", IntValue(memory_alignment))
  
  Span::end(platform_span)
  
  // éªŒè¯å¹³å°å…¼å®¹æ€§
  assert_eq(Span::status(platform_span), Ok)
  assert_true(platform_info.name.length() > 0)
  assert_true(platform_features.length() > 0)
}

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ ¡éªŒå’Œ
fn calculate_checksum(data : String) -> Int {
  let mut hash = 5381
  let mut i = 0
  while i < data.length() {
    hash = ((hash << 5) + hash) + data.char_code_at(i)
    i = i + 1
  }
  hash
}