// Azimuth é¡¹ç›®é¢å¤–æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ï¼ŒåŒ…å«é«˜çº§åŠŸèƒ½å’Œè¾¹ç•Œæµ‹è¯•

test "add_fibonacci_sequence" {
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­çš„åŠ æ³•
  assert_eq(azimuth::add(5, 8), 13)
  assert_eq(azimuth::add(13, 21), 34)
  assert_eq(azimuth::add(34, 55), 89)
}

test "multiply_powers_of_two" {
  // æµ‹è¯•2çš„å¹‚æ¬¡ä¹˜æ³•
  assert_eq(azimuth::multiply(2, 4), 8)
  assert_eq(azimuth::multiply(8, 16), 128)
  assert_eq(azimuth::multiply(32, 64), 2048)
}

test "greet_unicode_characters" {
  // æµ‹è¯•Unicodeå­—ç¬¦é—®å€™
  assert_eq(azimuth::greet("ä¸–ç•Œ"), "Hello, ä¸–ç•Œ!")
  assert_eq(azimuth::greet("ğŸš€"), "Hello, ğŸš€!")
  assert_eq(azimuth::greet("CafÃ©"), "Hello, CafÃ©!")
}

test "mathematical_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•å¯¹åŠ æ³•çš„åˆ†é…å¾‹
  let a = 6
  let b = 4
  let c = 3
  
  // a * (b + c) = a * b + a * c
  let left_side = azimuth::multiply(a, azimuth::add(b, c))
  let right_side = azimuth::add(azimuth::multiply(a, b), azimuth::multiply(a, c))
  assert_eq(left_side, right_side)
}

test "prime_number_operations" {
  // æµ‹è¯•è´¨æ•°è¿ç®—
  assert_eq(azimuth::add(17, 19), 36)
  assert_eq(azimuth::multiply(7, 11), 77)
  assert_eq(azimuth::add(23, 29), 52)
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­è¿ç®—
  let result1 = azimuth::add(1, 2)
  let result2 = azimuth::add(result1, 3)
  let result3 = azimuth::add(result2, 4)
  assert_eq(result3, 10)
  
  let mult_result1 = azimuth::multiply(2, 3)
  let mult_result2 = azimuth::multiply(mult_result1, 4)
  assert_eq(mult_result2, 24)
}

test "greet_with_whitespace" {
  // æµ‹è¯•åŒ…å«ç©ºç™½å­—ç¬¦çš„é—®å€™
  assert_eq(azimuth::greet("  leading"), "Hello,   leading!")
  assert_eq(azimuth::greet("trailing  "), "Hello, trailing  !")
  assert_eq(azimuth::greet("  both  "), "Hello,   both  !")
}

test "mathematical_associative_property" {
  // æµ‹è¯•åŠ æ³•å’Œä¹˜æ³•çš„ç»“åˆå¾‹
  let a = 5
  let b = 7
  let c = 9
  
  // (a + b) + c = a + (b + c)
  let add_left = azimuth::add(azimuth::add(a, b), c)
  let add_right = azimuth::add(a, azimuth::add(b, c))
  assert_eq(add_left, add_right)
  
  // (a * b) * c = a * (b * c)
  let mult_left = azimuth::multiply(azimuth::multiply(a, b), c)
  let mult_right = azimuth::multiply(a, azimuth::multiply(b, c))
  assert_eq(mult_left, mult_right)
}

test "extreme_value_operations" {
  // æµ‹è¯•æå€¼è¿ç®—
  let very_large = 1000000
  let very_small = -1000000
  
  assert_eq(azimuth::add(very_large, very_small), 0)
  assert_eq(azimuth::multiply(very_large, 0), 0)
  assert_eq(azimuth::multiply(very_small, 1), very_small)
}