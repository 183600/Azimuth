// Azimuth é¡¹ç›®ç»¼åˆæµ‹è¯•å¥—ä»¶
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ï¼Œæä¾›å…¨é¢çš„æµ‹è¯•è¦†ç›–

test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  let a = 42
  let b = 17
  
  // æµ‹è¯•åŠ æ³•
  let sum_result = @azimuth.add(a, b)
  @azimuth.assert_eq(59, sum_result)
  
  // æµ‹è¯•ä¹˜æ³•
  let mul_result = @azimuth.multiply(a, b)
  @azimuth.assert_eq(714, mul_result)
  
  // æµ‹è¯•ä¸0çš„è¿ç®—
  @azimuth.assert_eq(a, @azimuth.add(a, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(a, 0))
  @azimuth.assert_eq(a, @azimuth.multiply(a, 1))
}

test "boundary_value_testing" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼è¾¹ç•Œ
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 0))
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 1))
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, 1))
  
  // æµ‹è¯•æœ€å°å€¼è¾¹ç•Œ
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, 0))
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, -1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 1))
  
  // æµ‹è¯•æå€¼ç»„åˆ
  @azimuth.assert_eq(-1, @azimuth.add(max_val, min_val))
  @azimuth.assert_eq(0, @azimuth.multiply(max_val, 0))
}

test "string_processing_comprehensive" {
  // å…¨é¢å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  let normal_string = "MoonBit"
  let empty_string = ""
  let whitespace_string = "   "
  let special_chars = "!@#$%^&*()"
  let unicode_string = "æµ‹è¯•ğŸš€"
  
  // æµ‹è¯•æ™®é€šå­—ç¬¦ä¸²
  let normal_result = @azimuth.greet(normal_string)
  @azimuth.assert_eq_string("Hello, MoonBit!", normal_result)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_result = @azimuth.greet(empty_string)
  @azimuth.assert_eq_string("Hello, !", empty_result)
  
  // æµ‹è¯•ç©ºç™½å­—ç¬¦ä¸²
  let whitespace_result = @azimuth.greet(whitespace_string)
  @azimuth.assert_eq_string("Hello,    !", whitespace_result)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_result = @azimuth.greet(special_chars)
  @azimuth.assert_eq_string("Hello, !@#$%^&*()!", special_result)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_result = @azimuth.greet(unicode_string)
  @azimuth.assert_eq_string("Hello, æµ‹è¯•ğŸš€!", unicode_result)
}

test "mathematical_series_calculations" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼š1 + 3 + 5 + ... + (2n-1) = nÂ²
  let n = 10
  let sum_of_odds = @azimuth.multiply(n, n)
  @azimuth.assert_eq(100, sum_of_odds)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œï¼š2 + 4 + 8 + ... + 2^n = 2^(n+1) - 2
  // ç®€åŒ–è®¡ç®—ï¼š2 + 4 + 8 + 16 = 30
  let geometric_sum = @azimuth.add(@azimuth.add(@azimuth.add(2, 4), 8), 16)
  @azimuth.assert_eq(30, geometric_sum)
  
  // è®¡ç®—å¹³æ–¹å’Œï¼š1Â² + 2Â² + 3Â² + 4Â² + 5Â² = 55
  let square_sum = @azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(
    @azimuth.multiply(1, 1), 
    @azimuth.multiply(2, 2)), 
    @azimuth.multiply(3, 3)), 
    @azimuth.add(@azimuth.multiply(4, 4), @azimuth.multiply(5, 5)))
  @azimuth.assert_eq(55, square_sum)
}

test "real_world_financial_scenarios" {
  // å®é™…é‡‘èåœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè´·æ¬¾è®¡ç®—
  let loan_amount = 100000
  let interest_rate = 6  // 6%
  let loan_term = 10     // 10å¹´
  
  // ç®€åŒ–åˆ©æ¯è®¡ç®—ï¼šæ€»åˆ©æ¯ = æœ¬é‡‘ Ã— åˆ©ç‡ Ã— å¹´æ•°
  let total_interest = @azimuth.multiply(loan_amount, @azimuth.multiply(interest_rate, loan_term))
  let total_repayment = @azimuth.add(loan_amount, total_interest)
  
  @azimuth.assert_eq(7000000, total_repayment)
  
  // åœºæ™¯2ï¼šæŠ•èµ„å›æŠ¥è®¡ç®—
  let investment = 50000
  let annual_return = 8  // 8%
  let years = 5
  
  let total_return = @azimuth.multiply(investment, @azimuth.add(1, @azimuth.multiply(annual_return, years)))
  @azimuth.assert_eq(2500000, total_return)
  
  // åœºæ™¯3ï¼šæŠ˜æ‰£è®¡ç®—
  let original_price = 1200
  let discount_percentage = 15  // 15%
  
  let discount_amount = @azimuth.multiply(original_price, discount_percentage) / 100
  let discounted_price = @azimuth.add(original_price, -discount_amount)
  
  @azimuth.assert_eq(1020, discounted_price)
}

test "physics_simulation_calculations" {
  // ç‰©ç†æ¨¡æ‹Ÿè®¡ç®—æµ‹è¯•
  // åœºæ™¯1ï¼šè‡ªç”±è½ä½“è¿åŠ¨ï¼ˆç®€åŒ–ï¼‰ï¼šh = vâ‚€t + 0.5gtÂ²
  // ç®€åŒ–ä¸ºæ•´æ•°ï¼šh = vâ‚€t + gtÂ²
  let initial_velocity = 10
  let time = 3
  let gravity = 10  // ç®€åŒ–é‡åŠ›åŠ é€Ÿåº¦
  
  let height = @azimuth.add(@azimuth.multiply(initial_velocity, time), 
                          @azimuth.multiply(gravity, @azimuth.multiply(time, time)))
  @azimuth.assert_eq(120, height)
  
  // åœºæ™¯2ï¼šåœ†å‘¨è¿åŠ¨ï¼šv = 2Ï€r/Tï¼Œç®€åŒ–ä¸º v = 6r/T
  let radius = 5
  let period = 2
  
  let velocity = @azimuth.multiply(6, radius) / period
  @azimuth.assert_eq(15, velocity)
  
  // åœºæ™¯3ï¼šåŠ¨èƒ½è®¡ç®—ï¼šE = 0.5mvÂ²ï¼Œç®€åŒ–ä¸º E = mvÂ²
  let mass = 10
  let velocity_squared = @azimuth.multiply(velocity, velocity)
  let kinetic_energy = @azimuth.multiply(mass, velocity_squared)
  
  @azimuth.assert_eq(2250, kinetic_energy)
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹ŸO(nÂ²)ç®—æ³•çš„è®¡ç®—é‡
  let n = 100
  
  // è®¡ç®—æ¯”è¾ƒæ¬¡æ•°ï¼šn Ã— (n-1) / 2
  let comparisons = @azimuth.multiply(n, @azimuth.add(n, -1)) / 2
  @azimuth.assert_eq(4950, comparisons)
  
  // æ¨¡æ‹ŸO(n log n)ç®—æ³•ï¼ˆç®€åŒ–ï¼‰
  let log_approx = 7  // logâ‚‚100 â‰ˆ 6.64ï¼Œå–æ•´æ•°7
  let n_log_n = @azimuth.multiply(n, log_approx)
  @azimuth.assert_eq(700, n_log_n)
  
  // æ¨¡æ‹ŸO(2â¿)ç®—æ³•ï¼ˆå°è§„æ¨¡ï¼‰
  let small_n = 5
  let power_of_2 = @azimuth.multiply(@azimuth.multiply(2, 2), @azimuth.multiply(2, 2))
  @azimuth.assert_eq(16, power_of_2)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ•°ç»„ç´¢å¼•è®¡ç®—ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„
  let row = 3
  let col = 4
  let width = 10
  
  let index = @azimuth.add(@azimuth.multiply(row, width), col)
  @azimuth.assert_eq(34, index)
  
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špushå’Œpop
  let stack_size = 0
  let push_count = 5
  let pop_count = 2
  
  let final_size = @azimuth.add(@azimuth.add(stack_size, push_count), -pop_count)
  @azimuth.assert_eq(3, final_size)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼šenqueueå’Œdequeue
  let queue_size = 3
  let enqueue_count = 4
  let dequeue_count = 2
  
  let queue_final_size = @azimuth.add(@azimuth.add(queue_size, enqueue_count), -dequeue_count)
  @azimuth.assert_eq(5, queue_final_size)
}

test "error_handling_and_edge_cases" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let overflow_add = @azimuth.add(max_val, max_val)
  @azimuth.assert_eq(max_val, overflow_add)
  
  let underflow_add = @azimuth.add(min_val, min_val)
  @azimuth.assert_eq(min_val, underflow_add)
  
  let overflow_mul = @azimuth.multiply(max_val, 2)
  @azimuth.assert_eq(max_val, overflow_mul)
  
  // æµ‹è¯•ç‰¹æ®Šæƒ…å†µ
  let special_case1 = @azimuth.multiply(min_val, -1)
  @azimuth.assert_eq(min_val, special_case1)
  
  let special_case2 = @azimuth.multiply(min_val, 1)
  @azimuth.assert_eq(min_val, special_case2)
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°
  @azimuth.assert_true(true)
  @azimuth.assert_false(false)
  @azimuth.assert_eq(42, 42)
  @azimuth.assert_eq_string("test", "test")
}

test "comprehensive_business_logic" {
  // ç»¼åˆä¸šåŠ¡é€»è¾‘æµ‹è¯•
  // åœºæ™¯1ï¼šåº“å­˜ç®¡ç†
  let initial_stock = 1000
  let incoming_stock = 500
  let sold_items = 300
  let returned_items = 20
  
  let current_stock = @azimuth.add(@azimuth.add(@azimuth.add(initial_stock, incoming_stock), -sold_items), returned_items)
  @azimuth.assert_eq(1220, current_stock)
  
  // åœºæ™¯2ï¼šè®¢å•å¤„ç†
  let unit_price = 199
  let quantity = 5
  let discount_threshold = 500
  let discount_rate = 10
  let tax_rate = 8
  let shipping = 25
  
  // è®¡ç®—è®¢å•æ€»é¢
  let subtotal = @azimuth.multiply(unit_price, quantity)
  
  // è®¡ç®—æŠ˜æ‰£
  let discount = if (subtotal > discount_threshold) {
    @azimuth.multiply(subtotal, discount_rate) / 100
  } else {
    0
  }
  
  // è®¡ç®—ç¨è´¹å’Œæ€»ä»·
  let after_discount = @azimuth.add(subtotal, -discount)
  let tax = @azimuth.multiply(after_discount, tax_rate) / 100
  let total = @azimuth.add(@azimuth.add(after_discount, tax), shipping)
  
  @azimuth.assert_eq(1084, total)
  
  // åœºæ™¯3ï¼šç”¨æˆ·ç§¯åˆ†è®¡ç®—
  let base_points = 100
  let purchase_amount = 299
  let point_rate = 2  // æ¯æ¶ˆè´¹2å…ƒè·å¾—1ç§¯åˆ†
  let bonus_threshold = 200
  let bonus_points = 50
  
  let points_from_purchase = @azimuth.multiply(purchase_amount, point_rate) / 100
  let bonus = if (purchase_amount > bonus_threshold) { bonus_points } else { 0 }
  let total_points = @azimuth.add(base_points, @azimuth.add(points_from_purchase, bonus))
  
  @azimuth.assert_eq(299, total_points)
}

test "performance_benchmark_simulation" {
  // æ€§èƒ½åŸºå‡†æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æ€§èƒ½æ¯”è¾ƒ
  
  // ç®—æ³•Aï¼šO(n)çº¿æ€§æœç´¢
  let array_size = 1000
  let linear_operations = array_size
  @azimuth.assert_eq(1000, linear_operations)
  
  // ç®—æ³•Bï¼šO(log n)äºŒåˆ†æœç´¢
  let log_operations = 10  // logâ‚‚1024 = 10
  @azimuth.assert_eq(10, log_operations)
  
  // ç®—æ³•Cï¼šO(nÂ²)å†’æ³¡æ’åº
  let bubble_operations = @azimuth.multiply(array_size, array_size)
  @azimuth.assert_eq(1000000, bubble_operations)
  
  // ç®—æ³•Dï¼šO(n log n)å¿«é€Ÿæ’åº
  let quicksort_operations = @azimuth.multiply(array_size, log_operations)
  @azimuth.assert_eq(10000, quicksort_operations)
  
  // æ€§èƒ½æå‡è®¡ç®—
  let improvement_factor = @azimuth.divide_with_ceil(linear_operations, log_operations)
  @azimuth.assert_eq(100, improvement_factor)
  
  // å†…å­˜ä½¿ç”¨æ¨¡æ‹Ÿ
  let item_size = 8
  let total_items = 500
  let memory_usage = @azimuth.multiply(item_size, total_items)
  @azimuth.assert_eq(4000, memory_usage)
}