// Enhanced MoonBit Test Suite for Azimuth Telemetry System
// New comprehensive test cases covering advanced functionality

// Test 1: Async Telemetry Export Operations
pub test "å¼‚æ­¥é¥æµ‹å¯¼å‡ºæ“ä½œ" {
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "async-test")
  
  // åˆ›å»ºå¤šä¸ªSpan
  let spans = []
  for i in 0..5 {
    let span = azimuth::Tracer::start_span(tracer, "async-operation-" + i.to_string())
    azimuth::Span::set_attribute(span, "operation.id", azimuth::StringValue("op-" + i.to_string()))
    azimuth::Span::add_event(span, "operation.started", None)
    spans.push(span)
  }
  
  // æ¨¡æ‹Ÿå¼‚æ­¥å¯¼å‡º
  let export_batch = []
  for span in spans {
    let span_data = {
      "name": azimuth::Span::name(span),
      "kind": azimuth::Span::kind(span),
      "recording": azimuth::Span::is_recording(span)
    }
    export_batch.push(span_data)
    azimuth::Span::end(span)
  }
  
  // éªŒè¯å¯¼å‡ºæ‰¹æ¬¡
  assert_eq(export_batch.length(), 5)
  assert_eq(export_batch[0]["name"], "async-operation-0")
  assert_eq(export_batch[4]["name"], "async-operation-4")
  
  // éªŒè¯æ‰€æœ‰Spanå·²ç»“æŸ
  for span in spans {
    assert_false(azimuth::Span::is_recording(span))
  }
}

// Test 2: Internationalization and Localization Support
pub test "å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æ”¯æŒ" {
  let logger_provider = azimuth::LoggerProvider::default()
  let logger = azimuth::LoggerProvider::get_logger(logger_provider, "i18n-test")
  
  // æµ‹è¯•å¤šè¯­è¨€æ—¥å¿—æ¶ˆæ¯
  let english_log = azimuth::LogRecord::new(azimuth::Info, "Operation completed successfully")
  let chinese_log = azimuth::LogRecord::new(azimuth::Info, "æ“ä½œæˆåŠŸå®Œæˆ")
  let japanese_log = azimuth::LogRecord::new(azimuth::Info, "æ“ä½œãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
  let emoji_log = azimuth::LogRecord::new(azimuth::Info, "Operation completed ğŸš€âœ…")
  
  // éªŒè¯å¤šè¯­è¨€æ”¯æŒ
  assert_eq(azimuth::LogRecord::body(english_log), Some("Operation completed successfully"))
  assert_eq(azimuth::LogRecord::body(chinese_log), Some("æ“ä½œæˆåŠŸå®Œæˆ"))
  assert_eq(azimuth::LogRecord::body(japanese_log), Some("æ“ä½œãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ"))
  assert_eq(azimuth::LogRecord::body(emoji_log), Some("Operation completed ğŸš€âœ…"))
  
  // æµ‹è¯•æœ¬åœ°åŒ–å±æ€§
  let localized_attrs = azimuth::Attributes::new()
  azimuth::Attributes::set(localized_attrs, "message.zh", azimuth::StringValue("æ“ä½œæˆåŠŸ"))
  azimuth::Attributes::set(localized_attrs, "message.ja", azimuth::StringValue("æ“ä½œæˆåŠŸ"))
  azimuth::Attributes::set(localized_attrs, "message.en", azimuth::StringValue("Operation successful"))
  azimuth::Attributes::set(localized_attrs, "region", azimuth::StringValue("asia-pacific"))
  
  // éªŒè¯æœ¬åœ°åŒ–å±æ€§
  let zh_message = azimuth::Attributes::get(localized_attrs, "message.zh")
  let ja_message = azimuth::Attributes::get(localized_attrs, "message.ja")
  let en_message = azimuth::Attributes::get(localized_attrs, "message.en")
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(zh_message, Some(azimuth::StringValue("test_value")))
  assert_eq(ja_message, Some(azimuth::StringValue("test_value")))
  assert_eq(en_message, Some(azimuth::StringValue("test_value")))
}

// Test 3: Metrics Dashboard and Real-time Streaming
pub test "åº¦é‡ä»ªè¡¨ç›˜å’Œå®æ—¶æµå¼ä¼ è¾“" {
  let meter_provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(meter_provider, "dashboard-test")
  
  // åˆ›å»ºå®æ—¶åº¦é‡
  let cpu_usage = azimuth::Meter::create_gauge(meter, "system.cpu.usage")
  let memory_usage = azimuth::Meter::create_gauge(meter, "system.memory.usage")
  let request_rate = azimuth::Meter::create_counter(meter, "http.requests.rate")
  let response_time = azimuth::Meter::create_histogram(meter, "http.response.time")
  
  // æ¨¡æ‹Ÿå®æ—¶æ•°æ®æµ
  let time_series_data = []
  
  for i in 0..10 {
    let timestamp = azimuth::Clock::now_unix_nanos(azimuth::Clock::system())
    let data_point = {
      "timestamp": timestamp,
      "cpu": 50.0 + (i.to_double() * 5.0),
      "memory": 60.0 + (i.to_double() * 2.0),
      "requests": 100.0 + i.to_double(),
      "response_time": 100.0 + (i.to_double() * 10.0)
    }
    time_series_data.push(data_point)
    
    // è®°å½•åº¦é‡
    azimuth::Counter::add(request_rate, 1.0)
    azimuth::Histogram::record(response_time, data_point["response_time"])
  }
  
  // éªŒè¯æ—¶é—´åºåˆ—æ•°æ®
  assert_eq(time_series_data.length(), 10)
  assert_true(time_series_data[0]["cpu"] == 50.0)
  assert_true(time_series_data[9]["cpu"] == 95.0)
  
  // éªŒè¯åº¦é‡åˆ›å»º
  assert_eq(cpu_usage.name, "system.cpu.usage")
  assert_eq(memory_usage.name, "system.memory.usage")
  assert_eq(request_rate.name, "http.requests.rate")
  assert_eq(response_time.name, "http.response.time")
  
  // æµ‹è¯•ä»ªè¡¨ç›˜æ•°æ®èšåˆ
  let avg_cpu = time_series_data.map(d => d["cpu"]).reduce((a, b) => a + b) / time_series_data.length().to_double()
  let avg_memory = time_series_data.map(d => d["memory"]).reduce((a, b) => a + b) / time_series_data.length().to_double()
  
  assert_true(avg_cpu > 50.0 && avg_cpu < 100.0)
  assert_true(avg_memory > 60.0 && avg_memory < 80.0)
}

// Test 4: High Concurrency Safety Testing
pub test "é«˜å¹¶å‘å®‰å…¨æ€§æµ‹è¯•" {
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "concurrency-test")
  
  // åˆ›å»ºå…±äº«èµ„æº
  let shared_counter = azimuth::Meter::create_counter(
    azimuth::MeterProvider::get_meter(azimuth::MeterProvider::default(), "shared-meter"),
    "shared.operations"
  )
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ
  let concurrent_spans = []
  let operation_ids = []
  
  for i in 0..20 {
    let span = azimuth::Tracer::start_span(tracer, "concurrent-operation-" + i.to_string())
    azimuth::Span::set_attribute(span, "thread.id", azimuth::StringValue("thread-" + (i % 4).to_string()))
    azimuth::Span::set_attribute(span, "operation.id", azimuth::StringValue("op-" + i.to_string()))
    
    concurrent_spans.push(span)
    operation_ids.push("op-" + i.to_string())
    
    // å¹¶å‘æ›´æ–°å…±äº«è®¡æ•°å™¨
    azimuth::Counter::add(shared_counter, 1.0)
  }
  
  // éªŒè¯å¹¶å‘æ“ä½œç»“æœ
  assert_eq(concurrent_spans.length(), 20)
  assert_eq(operation_ids.length(), 20)
  
  // éªŒè¯å…±äº«è®¡æ•°å™¨çŠ¶æ€
  assert_eq(shared_counter.name, "shared.operations")
  
  // å¹¶å‘ç»“æŸæ‰€æœ‰Span
  for span in concurrent_spans {
    azimuth::Span::add_event(span, "operation.completed", None)
    azimuth::Span::end(span)
  }
  
  // éªŒè¯æ‰€æœ‰Spanå·²æ­£ç¡®ç»“æŸ
  for span in concurrent_spans {
    assert_false(azimuth::Span::is_recording(span))
  }
}

// Test 5: Resource Merge Strategy Testing
pub test "èµ„æºåˆå¹¶ç­–ç•¥æµ‹è¯•" {
  // åˆ›å»ºå¤šä¸ªèµ„æºå±‚çº§
  let global_resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("service.name", azimuth::StringValue("global-service")),
    ("service.version", azimuth::StringValue("1.0.0")),
    ("environment", azimuth::StringValue("production")),
    ("datacenter", azimuth::StringValue("dc-global"))
  ])
  
  let region_resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("service.name", azimuth::StringValue("should-not-override")), // ä¸åº”è¦†ç›–å…¨å±€
    ("region", azimuth::StringValue("us-west")),
    ("datacenter", azimuth::StringValue("dc-west")), // åº”è¦†ç›–å…¨å±€
    ("availability.zone", azimuth::StringValue("us-west-1a"))
  ])
  
  let instance_resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("instance.id", azimuth::StringValue("inst-12345")),
    ("host.name", azimuth::StringValue("host-abc")),
    ("service.name", azimuth::StringValue("should-not-override-either")), // ä¸åº”è¦†ç›–
    ("custom.tag", azimuth::StringValue("instance-specific"))
  ])
  
  // é€å±‚åˆå¹¶èµ„æº
  let merged_region = azimuth::Resource::merge(global_resource, region_resource)
  let final_resource = azimuth::Resource::merge(merged_region, instance_resource)
  
  // éªŒè¯åˆå¹¶ç­–ç•¥
  assert_eq(azimuth::Resource::get_attribute(final_resource, "service.name"), Some(azimuth::StringValue("global-service")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "service.version"), Some(azimuth::StringValue("1.0.0")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "environment"), Some(azimuth::StringValue("production")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "datacenter"), Some(azimuth::StringValue("dc-west")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "region"), Some(azimuth::StringValue("us-west")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "availability.zone"), Some(azimuth::StringValue("us-west-1a")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "instance.id"), Some(azimuth::StringValue("inst-12345")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "host.name"), Some(azimuth::StringValue("host-abc")))
  assert_eq(azimuth::Resource::get_attribute(final_resource, "custom.tag"), Some(azimuth::StringValue("instance-specific")))
}

// Test 6: Time Series Operations Testing
pub test "æ—¶é—´åºåˆ—æ“ä½œæµ‹è¯•" {
  let clock = azimuth::Clock::system()
  let meter = azimuth::MeterProvider::get_meter(azimuth::MeterProvider::default(), "timeseries-test")
  
  // åˆ›å»ºæ—¶é—´åºåˆ—åº¦é‡
  let temperature_gauge = azimuth::Meter::create_gauge(meter, "sensor.temperature")
  let humidity_gauge = azimuth::Meter::create_gauge(meter, "sensor.humidity")
  let pressure_histogram = azimuth::Meter::create_histogram(meter, "sensor.pressure")
  
  // ç”Ÿæˆæ—¶é—´åºåˆ—æ•°æ®
  let measurements = []
  let base_time = azimuth::Clock::now_unix_nanos(clock)
  
  for i in 0..24 { // 24å°æ—¶æ•°æ®
    let timestamp = base_time + (i.to_int64() * 3600000000000L) // æ¯å°æ—¶
    let measurement = {
      "timestamp": timestamp,
      "temperature": 20.0 + (i.to_double() * 0.5), // æ¸©åº¦å˜åŒ–
      "humidity": 60.0 + (i.to_double() * 0.2), // æ¹¿åº¦å˜åŒ–
      "pressure": 1013.25 + (i.to_double() * 0.1) // æ°”å‹å˜åŒ–
    }
    measurements.push(measurement)
    
    // è®°å½•åº¦é‡
    azimuth::Histogram::record(pressure_histogram, measurement["pressure"])
  }
  
  // éªŒè¯æ—¶é—´åºåˆ—æ•°æ®
  assert_eq(measurements.length(), 24)
  assert_true(measurements[0]["timestamp"] == base_time)
  assert_true(measurements[23]["timestamp"] == base_time + 23 * 3600000000000L)
  
  // æµ‹è¯•æ—¶é—´çª—å£æŸ¥è¯¢
  let window_start = base_time + 6 * 3600000000000L // 6å°æ—¶å
  let window_end = base_time + 18 * 3600000000000L   // 18å°æ—¶å
  
  let window_data = measurements.filter(m => m["timestamp"] >= window_start && m["timestamp"] <= window_end)
  
  assert_eq(window_data.length(), 13) // 6-18å°æ—¶ inclusive
  
  // è®¡ç®—çª—å£ç»Ÿè®¡
  let avg_temp = window_data.map(d => d["temperature"]).reduce((a, b) => a + b) / window_data.length().to_double()
  let max_temp = window_data.map(d => d["temperature"]).reduce((a, b) => if a > b { a } else { b })
  let min_temp = window_data.map(d => d["temperature"]).reduce((a, b) => if a < b { a } else { b })
  
  assert_true(avg_temp > 20.0 && avg_temp < 25.0)
  assert_true(max_temp > min_temp)
  
  // éªŒè¯åº¦é‡åˆ›å»º
  assert_eq(temperature_gauge.name, "sensor.temperature")
  assert_eq(humidity_gauge.name, "sensor.humidity")
  assert_eq(pressure_histogram.name, "sensor.pressure")
}

// Test 7: Error Boundary and Recovery Testing
pub test "é”™è¯¯è¾¹ç•Œå’Œæ¢å¤æµ‹è¯•" {
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "error-boundary-test")
  let logger = azimuth::LoggerProvider::get_logger(azimuth::LoggerProvider::default(), "error-recovery")
  
  // åˆ›å»ºé”™è¯¯è¿½è¸ªSpan
  let error_span = azimuth::Tracer::start_span(tracer, "error-prone-operation")
  
  // æ¨¡æ‹Ÿé”™è¯¯åœºæ™¯
  let error_scenarios = [
    {"type": "timeout", "message": "Operation timed out after 30s"},
    {"type": "connection", "message": "Failed to connect to database"},
    {"type": "permission", "message": "Access denied to resource"},
    {"type": "validation", "message": "Invalid input parameter"}
  ]
  
  for scenario in error_scenarios {
    // åˆ›å»ºå­Spanå¤„ç†é”™è¯¯
    let child_span = azimuth::Tracer::start_span(tracer, "handle-" + scenario["type"])
    
    // è®¾ç½®é”™è¯¯å±æ€§
    azimuth::Span::set_attribute(child_span, "error.type", azimuth::StringValue(scenario["type"]))
    azimuth::Span::set_attribute(child_span, "error.message", azimuth::StringValue(scenario["message"]))
    azimuth::Span::set_status(child_span, azimuth::Error)
    
    // æ·»åŠ é”™è¯¯äº‹ä»¶
    azimuth::Span::add_event(child_span, "error.occurred", Some([
      ("error.type", azimuth::StringValue(scenario["type"])),
      ("retry.count", azimuth::IntValue(3))
    ]))
    
    // åˆ›å»ºé”™è¯¯æ—¥å¿—
    let error_log = azimuth::LogRecord::new_with_context(
      azimuth::Error,
      Some("Error occurred: " + scenario["message"]),
      Some([("error.type", azimuth::StringValue(scenario["type"]))]),
      Some(azimuth::Clock::now_unix_nanos(azimuth::Clock::system())),
      None,
      Some(azimuth::SpanContext::trace_id(azimuth::Span::span_context(child_span))),
      Some(azimuth::SpanContext::span_id(azimuth::Span::span_context(child_span))),
      Some(azimuth::Context::root())
    )
    
    // å‘å‡ºé”™è¯¯æ—¥å¿—
    azimuth::Logger::emit(logger, error_log)
    
    // æ¨¡æ‹Ÿæ¢å¤æ“ä½œ
    let recovery_span = azimuth::Tracer::start_span(tracer, "recovery-operation")
    azimuth::Span::set_attribute(recovery_span, "recovery.from", azimuth::StringValue(scenario["type"]))
    azimuth::Span::set_status(recovery_span, azimuth::Ok)
    
    azimuth::Span::end(recovery_span)
    azimuth::Span::end(child_span)
  }
  
  // è®¾ç½®ä¸»SpançŠ¶æ€
  azimuth::Span::set_status(error_span, azimuth::Ok)
  azimuth::Span::add_event(error_span, "error.handling.completed", Some([
    ("total.errors", azimuth::IntValue(error_scenarios.length()))
  ]))
  
  azimuth::Span::end(error_span)
  
  // éªŒè¯é”™è¯¯å¤„ç†å®Œæˆ
  assert_false(azimuth::Span::is_recording(error_span))
  assert_eq(azimuth::Span::name(error_span), "error-prone-operation")
}

// Test 8: Advanced HTTP Client Operations
pub test "é«˜çº§HTTPå®¢æˆ·ç«¯æ“ä½œ" {
  let client = azimuth::HttpClient::new()
  
  // æµ‹è¯•å„ç§HTTPæ–¹æ³•
  let http_methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
  
  for method in http_methods {
    let headers = [
      ("Content-Type", "application/json"),
      ("Authorization", "Bearer token123"),
      ("X-Request-ID", "req-" + method.to_lowercase()),
      ("User-Agent", "azimuth-telemetry/1.0")
    ]
    
    let request = azimuth::HttpRequest::new(
      method,
      "https://api.example.com/" + method.to_lowercase(),
      headers,
      Some("{\"test\": \"" + method + "\"}")
    )
    
    // éªŒè¯è¯·æ±‚åˆ›å»º
    assert_eq(azimuth::HttpRequest::http_method(request), method)
    assert_eq(azimuth::HttpRequest::url(request), "https://api.example.com/" + method.to_lowercase())
    assert_eq(azimuth::HttpRequest::body(request), Some("{\"test\": \"" + method + "\"}"))
  }
  
  // æµ‹è¯•å“åº”å¤„ç†
  let response_scenarios = [
    {"status": 200, "body": "{\"status\": \"success\"}", "type": "success"},
    {"status": 201, "body": "{\"id\": 123}", "type": "created"},
    {"status": 400, "body": "{\"error\": \"bad request\"}", "type": "client_error"},
    {"status": 500, "body": "{\"error\": \"internal error\"}", "type": "server_error"}
  ]
  
  for scenario in response_scenarios {
    let response_headers = [
      ("Content-Type", "application/json"),
      ("X-Response-Time", "150ms"),
      ("Cache-Control", "no-cache")
    ]
    
    let response = azimuth::HttpResponse::new(
      scenario["status"],
      response_headers,
      Some(scenario["body"])
    )
    
    // éªŒè¯å“åº”åˆ›å»º
    assert_eq(azimuth::HttpResponse::status_code(response), scenario["status"])
    assert_eq(azimuth::HttpResponse::body(response), Some(scenario["body"]))
  }
  
  // æµ‹è¯•HTTPå®¢æˆ·ç«¯é…ç½®
  let configured_client = azimuth::HttpClient::with_config({
    "timeout": 30000,
    "retries": 3,
    "follow_redirects": true,
    "max_redirects": 5
  })
  
  // éªŒè¯å®¢æˆ·ç«¯é…ç½®ï¼ˆåŸºäºç®€åŒ–å®ç°ï¼‰
  assert_true(configured_client != client)
}