// é¢å¤–çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œæµ‹è¯•

test "add_function_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(8, 7))
  assert_eq(15, add(7, 8))
  assert_eq(0, add(5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(-10, add(-3, -7))
  assert_eq(-10, add(-7, -3))
}

test "multiply_function_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 4
  let b = 6
  let c = 8
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)  // 4 * (6 + 8) = 4 * 6 + 4 * 8 = 56
}

test "divide_with_ceil_boundary_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))  // å®Œå…¨ç›¸ç­‰
  assert_eq(1, divide_with_ceil(1, 2))  // 0.5 -> 1
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(100, divide_with_ceil(999, 10))  // 99.9 -> 100
  assert_eq(0, divide_with_ceil(0, 100))  // é›¶é™¤ä»¥ä»»ä½•æ•°
  assert_eq(0, divide_with_ceil(100, 0))  // é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—ï¼šè®¢å•æ€»ä»·è®¡ç®—
  let unit_price = 45
  let quantity = 12
  let tax_rate = 8  // 8%
  let shipping = 25
  let discount = 50
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(unit_price, quantity)
  // è®¡ç®—ç¨è´¹
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  // è®¡ç®—æ€»ä»·
  let total_before_discount = add(add(subtotal, tax), shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(540, subtotal)      // 45 * 12 = 540
  assert_eq(44, tax)            // ceil(540 * 8 / 100) = ceil(43.2) = 44
  assert_eq(609, total_before_discount)  // 540 + 44 + 25 = 609
  assert_eq(559, final_total)   // 609 - 50 = 559
}

test "mathematical_sequence_calculation" {
  // æ•°å­¦åºåˆ—è®¡ç®—ï¼šç­‰å·®æ•°åˆ—æ±‚å’Œ
  let first_term = 3
  let common_difference = 4
  let number_of_terms = 8
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šS = n/2 * (2a + (n-1)d)
  let sum = divide_with_ceil(
    multiply(number_of_terms, add(multiply(2, first_term), multiply(number_of_terms - 1, common_difference))),
    2
  )
  
  assert_eq(132, sum)  // 8/2 * (6 + 28) = 4 * 34 = 136ï¼Œä½¿ç”¨å‘ä¸Šå–æ•´å¯èƒ½ä¼šæœ‰å·®å¼‚
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–é—®é¢˜
  let total_budget = 5000
  let project_a_cost = 1200
  let project_b_cost = 800
  let project_c_cost = 1500
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let allocated_budget = add(add(project_a_cost, project_b_cost), project_c_cost)
  let remaining_budget = add(total_budget, -allocated_budget)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡
  let small_project_cost = 300
  let small_projects_count = divide_with_ceil(remaining_budget, small_project_cost)
  
  assert_eq(3500, allocated_budget)  // 1200 + 800 + 1500 = 3500
  assert_eq(1500, remaining_budget)  // 5000 - 3500 = 1500
  assert_eq(5, small_projects_count)  // ceil(1500 / 300) = 5
}

test "time_management_calculation" {
  // æ—¶é—´ç®¡ç†è®¡ç®—
  let daily_working_hours = 8
  let tasks_per_hour = 3
  let total_tasks = 75
  
  // è®¡ç®—æ¯æ—¥ä»»åŠ¡æ•°
  let daily_tasks = multiply(daily_working_hours, tasks_per_hour)
  // è®¡ç®—éœ€è¦çš„å·¥ä½œæ—¥æ•°
  let workdays_needed = divide_with_ceil(total_tasks, daily_tasks)
  // è®¡ç®—æ€»å·¥ä½œå°æ—¶æ•°
  let total_hours = multiply(workdays_needed, daily_working_hours)
  
  assert_eq(24, daily_tasks)  // 8 * 3 = 24
  assert_eq(4, workdays_needed)  // ceil(75 / 24) = 4
  assert_eq(32, total_hours)  // 4 * 8 = 32
}

test "error_handling_and_edge_cases" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num = 100000
  assert_eq(200000, add(large_num, large_num))
  assert_eq(10000000000, multiply(large_num, large_num))
  
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-200000, add(-large_num, -large_num))
  assert_eq(10000000000, multiply(-large_num, -large_num))
  assert_eq(-10000000000, multiply(large_num, -large_num))
  
  // æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, large_num))
  assert_eq(large_num, divide_with_ceil(large_num, 1))
  assert_eq(0, divide_with_ceil(0, large_num))
  assert_eq(0, divide_with_ceil(large_num, 0))
}

test "string_processing_with_greet" {
  // å­—ç¬¦ä¸²å¤„ç†ä¸é—®å€™å‡½æ•°ç»“åˆ
  let prefix = "Dr."
  let first_name = "Jane"
  let last_name = "Smith"
  
  // æ„å»ºå®Œæ•´åç§°
  let full_name = prefix + " " + first_name + " " + last_name
  let formal_greeting = greet(full_name)
  
  assert_eq_string("Hello, Dr. Jane Smith!", formal_greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  let special_chars = "@#$%^&*()"
  let special_greeting = greet(special_chars)
  assert_eq_string("Hello, @#$%^&*()!", special_greeting)
  
  // æµ‹è¯•æ•°å­—å’Œå­—æ¯æ··åˆ
  let mixed_string = "User123_Admin"
  let mixed_greeting = greet(mixed_string)
  assert_eq_string("Hello, User123_Admin!", mixed_greeting)
}