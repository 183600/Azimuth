// æ–°çš„é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

test "mathematical_properties_commutative" {
  // éªŒè¯åŠ æ³•å’Œä¹˜æ³•äº¤æ¢å¾‹
  let a = 12
  let b = 28
  assert_eq(add(a, b), add(b, a))
  assert_eq(multiply(a, b), multiply(b, a))
}

test "divide_with_ceil_precision_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦æƒ…å†µ
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(4, divide_with_ceil(11, 3)) // 3.666... -> 4
  assert_eq(7, divide_with_ceil(13, 2)) // 6.5 -> 7
  assert_eq(1, divide_with_ceil(1, 100)) // 0.01 -> 1
}

test "greet_function_multilingual_support" {
  // æµ‹è¯•å¤šè¯­è¨€é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate_percent = 8
  let years = 3
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let year1_amount = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2_amount = add(year1_amount, divide_with_ceil(multiply(year1_amount, rate_percent), 100))
  let year3_amount = add(year2_amount, divide_with_ceil(multiply(year2_amount, rate_percent), 100))
  
  assert_eq(10800, year1_amount)
  assert_eq(11664, year2_amount)
  assert_eq(12597, year3_amount)
}

test "inventory_management_system" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯•
  let initial_stock = 500
  let daily_sales = 25
  let restock_amount = 100
  let days_to_simulate = 7
  
  let total_sold = multiply(daily_sales, days_to_simulate)
  let stock_after_sales = add(initial_stock, -total_sold)
  let final_stock = add(stock_after_sales, restock_amount)
  
  assert_eq(175, total_sold)
  assert_eq(325, stock_after_sales)
  assert_eq(425, final_stock)
}

test "engineering_structural_calculation" {
  // å·¥ç¨‹ç»“æ„è®¡ç®—æµ‹è¯•
  let beam_length = 15
  let load_per_meter = 200
  let safety_factor = 2
  
  // è®¡ç®—æ€»è½½è·
  let total_load = multiply(beam_length, load_per_meter)
  
  // åº”ç”¨å®‰å…¨ç³»æ•°
  let safe_load_capacity = divide_with_ceil(total_load, safety_factor)
  
  assert_eq(3000, total_load)
  assert_eq(1500, safe_load_capacity)
}

test "data_analysis_statistics" {
  // æ•°æ®åˆ†æç»Ÿè®¡æµ‹è¯•
  let data_points = [45, 67, 23, 89, 12, 56, 78, 34, 90, 41]
  let sum_manual = add(add(add(add(add(add(add(add(add(45, 67), 23), 89), 12), 56), 78), 34), 90), 41)
  let average = divide_with_ceil(sum_manual, 10)
  
  assert_eq(535, sum_manual)
  assert_eq(54, average)
}

test "time_zone_conversion" {
  // æ—¶åŒºè½¬æ¢è®¡ç®—æµ‹è¯•
  let local_time = 14  // 2 PM
  let time_difference = 8  // 8å°æ—¶å·®å¼‚
  
  // è®¡ç®—ç›®æ ‡æ—¶åŒºæ—¶é—´
  let target_time = add(local_time, time_difference)
  let adjusted_time = if target_time >= 24 {
    add(target_time, -24)
  } else {
    target_time
  }
  
  assert_eq(22, adjusted_time)
}

test "resource_optimization_algorithm" {
  // èµ„æºä¼˜åŒ–ç®—æ³•æµ‹è¯•
  let total_resources = 1000
  let project_a_needs = 300
  let project_b_needs = 250
  let project_c_needs = 400
  
  // åˆ†é…èµ„æº
  let allocated_a = project_a_needs
  let allocated_b = project_b_needs
  let allocated_c = project_c_needs
  let total_allocated = add(add(allocated_a, allocated_b), allocated_c)
  let remaining_resources = add(total_resources, -total_allocated)
  
  assert_eq(950, total_allocated)
  assert_eq(50, remaining_resources)
}

test "error_boundary_conditions" {
  // é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•é™¤é›¶ä¿æŠ¤
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-50, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•æå€¼è¿ç®—
  assert_eq(0, add(2147483647, -2147483647))
  assert_eq(1, multiply(1, 1))
  assert_eq(0, multiply(0, 2147483647))
}