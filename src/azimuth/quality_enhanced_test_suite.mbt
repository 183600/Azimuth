// é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

test "subtract_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„å‡æ³•åŠŸèƒ½
  azimuth::assert_eq(5, azimuth::subtract(10, 5))
  azimuth::assert_eq(-5, azimuth::subtract(5, 10))
  azimuth::assert_eq(0, azimuth::subtract(7, 7))
  azimuth::assert_eq(10, azimuth::subtract(0, -10))
}

test "mathematical_identity_laws" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¾‹
  let a = 15
  
  // åŠ æ³•å•ä½å…ƒ
  azimuth::assert_eq(a, azimuth::add(a, 0))
  azimuth::assert_eq(a, azimuth::add(0, a))
  
  // ä¹˜æ³•å•ä½å…ƒ
  azimuth::assert_eq(a, azimuth::multiply(a, 1))
  azimuth::assert_eq(a, azimuth::multiply(1, a))
  
  // å‡æ³•æ’ç­‰å¼
  azimuth::assert_eq(0, azimuth::subtract(a, a))
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let product_price = 89
  let quantity = 4
  let discount = 20
  let shipping = 12
  
  let subtotal = azimuth::multiply(product_price, quantity)
  let discounted_total = azimuth::subtract(subtotal, discount)
  let final_total = azimuth::add(discounted_total, shipping)
  
  azimuth::assert_eq(356, subtotal)
  azimuth::assert_eq(336, discounted_total)
  azimuth::assert_eq(348, final_total)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–é—®é¢˜
  let total_budget = 1000
  let project_a_cost = 350
  let project_b_cost = 280
  let project_c_cost = 220
  
  let allocated_budget = azimuth::add(azimuth::add(project_a_cost, project_b_cost), project_c_cost)
  let remaining_budget = azimuth::subtract(total_budget, allocated_budget)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„é¢å¤–å°é¡¹ç›®æ•°é‡
  let small_project_cost = 50
  let additional_projects = azimuth::divide_with_ceil(remaining_budget, small_project_cost)
  
  azimuth::assert_eq(850, allocated_budget)
  azimuth::assert_eq(150, remaining_budget)
  azimuth::assert_eq(3, additional_projects)
}

test "time_management_calculation" {
  // æ—¶é—´ç®¡ç†è®¡ç®—
  let daily_work_hours = 8
  let task_complexity_factor = 3
  let break_time = 2
  
  let total_time_needed = azimuth::multiply(daily_work_hours, task_complexity_factor)
  let actual_work_time = azimuth::subtract(total_time_needed, break_time)
  let days_required = azimuth::divide_with_ceil(actual_work_time, daily_work_hours)
  
  azimuth::assert_eq(24, total_time_needed)
  azimuth::assert_eq(22, actual_work_time)
  azimuth::assert_eq(3, days_required)
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†ç®¡é“æ¨¡æ‹Ÿ
  let input_data = 1000
  let filter_rate = 75  // 75% çš„æ•°æ®é€šè¿‡è¿‡æ»¤
  let transformation_factor = 2
  let validation_overhead = 50
  
  let filtered_data = azimuth::multiply(input_data, filter_rate) / 100
  let transformed_data = azimuth::multiply(filtered_data, transformation_factor)
  let final_result = azimuth::subtract(transformed_data, validation_overhead)
  
  azimuth::assert_eq(750, filtered_data)
  azimuth::assert_eq(1500, transformed_data)
  azimuth::assert_eq(1450, final_result)
}

test "greeting_multilingual_support" {
  // å¤šè¯­è¨€é—®å€™æ”¯æŒæµ‹è¯•
  azimuth::assert_eq_string("Hello, ä¸–ç•Œ!", azimuth::greet("ä¸–ç•Œ"))
  azimuth::assert_eq_string("Hello, ğŸŒ!", azimuth::greet("ğŸŒ"))
  azimuth::assert_eq_string("Hello, MoonBit!", azimuth::greet("MoonBit"))
  azimuth::assert_eq_string("Hello, ç”¨æˆ·123!", azimuth::greet("ç”¨æˆ·123"))
  azimuth::assert_eq_string("Hello, !", azimuth::greet(""))
}

test "performance_benchmark_calculation" {
  // æ€§èƒ½åŸºå‡†è®¡ç®—
  let baseline_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 15
  
  let optimized_operations = azimuth::multiply(baseline_operations, optimization_factor)
  let overhead = azimuth::divide_with_ceil(azimuth::multiply(optimized_operations, overhead_percentage), 100)
  let net_performance = azimuth::subtract(optimized_operations, overhead)
  
  azimuth::assert_eq(3000, optimized_operations)
  azimuth::assert_eq(450, overhead)
  azimuth::assert_eq(2550, net_performance)
}

test "inventory_turnover_calculation" {
  // åº“å­˜å‘¨è½¬ç‡è®¡ç®—
  let initial_inventory = 500
  let monthly_sales = 120
  let months_to_simulate = 3
  let new_stock_received = 200
  
  let total_sales = azimuth::multiply(monthly_sales, months_to_simulate)
  let ending_inventory = azimuth::subtract(azimuth::add(initial_inventory, new_stock_received), total_sales)
  let turnover_rate = azimuth::divide_with_ceil(total_sales, initial_inventory)
  
  azimuth::assert_eq(360, total_sales)
  azimuth::assert_eq(340, ending_inventory)
  azimuth::assert_eq(1, turnover_rate)
}

test "error_handling_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•é™¤é›¶å®‰å…¨
  azimuth::assert_eq(0, azimuth::divide_with_ceil(100, 0))
  azimuth::assert_eq(0, azimuth::divide_with_ceil(-50, 0))
  azimuth::assert_eq(0, azimuth::divide_with_ceil(0, 0))
  
  // æµ‹è¯•æç«¯å€¼
  azimuth::assert_eq(1, azimuth::divide_with_ceil(1, 1000000))
  azimuth::assert_eq(1000000, azimuth::divide_with_ceil(1000000, 1))
  
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  azimuth::assert_eq(-10, azimuth::subtract(0, 10))
  azimuth::assert_eq(10, azimuth::subtract(0, -10))
}