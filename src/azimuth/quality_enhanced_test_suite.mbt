// é«˜è´¨é‡å¢å¼ºæµ‹è¯•å¥—ä»¶
// é’ˆå¯¹ azimuth åº“çš„å…¨é¢æµ‹è¯•ï¼ŒåŒ…å«è¾¹ç•Œæƒ…å†µã€å®é™…åº”ç”¨åœºæ™¯å’Œæ•°å­¦æ€§è´¨éªŒè¯

test "advanced_mathematical_series" {
  // æµ‹è¯•ç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—è®¡ç®—
  let first_term = 3
  let common_diff = 4
  let terms_count = 6
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—ç¬¬né¡¹ï¼ša_n = a_1 + (n-1)d
  let nth_term = add(first_term, multiply(common_diff, terms_count - 1))
  assert_eq(23, nth_term)  // 3 + 5*4 = 23
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼šS_n = n/2 * (a_1 + a_n)
  let series_sum = divide_with_ceil(multiply(terms_count, add(first_term, nth_term)), 2)
  assert_eq(78, series_sum)  // 6/2 * (3 + 23) = 3 * 26 = 78
}

test "financial_compound_interest" {
  // æµ‹è¯•å¤åˆ©è®¡ç®—
  let principal = 10000
  let annual_rate = 8
  let _years = 3
  
  // ç¬¬ä¸€å¹´æœ«
  let year1 = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  // ç¬¬äºŒå¹´æœ«
  let year2 = add(year1, divide_with_ceil(multiply(year1, annual_rate), 100))
  // ç¬¬ä¸‰å¹´æœ«
  let year3 = add(year2, divide_with_ceil(multiply(year2, annual_rate), 100))
  
  assert_eq(10800, year1)  // 10000 + 800
  assert_eq(11664, year2)  // 10800 + 864
  assert_eq(12597, year3)  // 11664 + 933
}

test "inventory_optimization" {
  // æµ‹è¯•åº“å­˜ä¼˜åŒ–ç®—æ³•
  let monthly_demand = 450
  let order_cost = 50
  let holding_cost_per_unit = 2
  
  // è®¡ç®—ç»æµè®¢è´§é‡ (EOQ) çš„ç®€åŒ–ç‰ˆæœ¬
  let annual_demand = multiply(monthly_demand, 12)
  let eoq_numerator = multiply(multiply(2, annual_demand), order_cost)
  let eoq = divide_with_ceil(eoq_numerator, holding_cost_per_unit)
  
  // è®¡ç®—å¹´è®¢è´§æ¬¡æ•°
  let orders_per_year = divide_with_ceil(annual_demand, eoq)
  
  assert_eq(5400, annual_demand)
  assert_eq(270000, eoq_numerator)
  assert_eq(135000, eoq)
  assert_eq(1, orders_per_year)
}

test "geometry_area_calculations" {
  // æµ‹è¯•å‡ ä½•é¢ç§¯è®¡ç®—
  let length = 12
  let width = 8
  let height = 5
  
  // è®¡ç®—çŸ©å½¢é¢ç§¯
  let rectangle_area = multiply(length, width)
  assert_eq(96, rectangle_area)
  
  // è®¡ç®—çŸ©å½¢å‘¨é•¿
  let rectangle_perimeter = multiply(2, add(length, width))
  assert_eq(40, rectangle_perimeter)
  
  // è®¡ç®—é•¿æ–¹ä½“è¡¨é¢ç§¯
  let surface_area = multiply(2, add(add(multiply(length, width), multiply(width, height)), multiply(height, length)))
  assert_eq(392, surface_area)
  
  // è®¡ç®—é•¿æ–¹ä½“ä½“ç§¯
  let volume = multiply(multiply(length, width), height)
  assert_eq(480, volume)
}

test "time_management_scenarios" {
  // æµ‹è¯•æ—¶é—´ç®¡ç†åœºæ™¯
  let total_tasks = 127
  let tasks_per_hour = 8
  let work_hours_per_day = 8
  let work_days_per_week = 5
  
  // è®¡ç®—éœ€è¦çš„å·¥ä½œå°æ—¶æ•°
  let total_hours = divide_with_ceil(total_tasks, tasks_per_hour)
  // è®¡ç®—éœ€è¦çš„å·¥ä½œå¤©æ•°
  let total_days = divide_with_ceil(total_hours, work_hours_per_day)
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let total_weeks = divide_with_ceil(total_days, work_days_per_week)
  
  assert_eq(16, total_hours)   // ceil(127/8) = 16
  assert_eq(2, total_days)     // ceil(16/8) = 2
  assert_eq(1, total_weeks)    // ceil(2/5) = 1
}

test "data_analysis_statistics" {
  // æµ‹è¯•æ•°æ®åˆ†æç»Ÿè®¡
  let _data_points = [15, 22, 18, 25, 20, 17, 23, 19, 21, 16]
  let sum_manual = add(add(add(add(add(add(add(add(add(15, 22), 18), 25), 20), 17), 23), 19), 21), 16)
  
  // è®¡ç®—å¹³å‡å€¼
  let mean = divide_with_ceil(sum_manual, 10)
  
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let sorted_sum = add(add(add(add(16, 17), 18), 19), 20)  // å‰5ä¸ªæ•°çš„å’Œ
  let median = divide_with_ceil(sorted_sum, 5)
  
  assert_eq(196, sum_manual)
  assert_eq(20, mean)
  assert_eq(18, median)
}

test "telecommunications_bandwidth" {
  // æµ‹è¯•ç”µä¿¡å¸¦å®½è®¡ç®—
  let file_size_mb = 850
  let network_speed_mbps = 50
  let overhead_percentage = 10
  
  // è®¡ç®—åŸºç¡€ä¼ è¾“æ—¶é—´
  let base_time = divide_with_ceil(file_size_mb, network_speed_mbps)
  
  // è®¡ç®—å¼€é”€æ—¶é—´
  let overhead_time = divide_with_ceil(multiply(base_time, overhead_percentage), 100)
  
  // è®¡ç®—æ€»ä¼ è¾“æ—¶é—´
  let total_time = add(base_time, overhead_time)
  
  assert_eq(17, base_time)      // ceil(850/50) = 17
  assert_eq(2, overhead_time)   // ceil(17*10/100) = 2
  assert_eq(19, total_time)     // 17 + 2 = 19
}

test "agricultural_planning" {
  // æµ‹è¯•å†œä¸šè§„åˆ’è®¡ç®—
  let field_area_hectares = 25
  let crop_yield_per_hectare = 800
  let market_price_per_ton = 250
  let labor_cost_per_hectare = 120
  let fertilizer_cost_per_hectare = 80
  
  // è®¡ç®—æ€»äº§é‡
  let total_yield = multiply(field_area_hectares, crop_yield_per_hectare)
  
  // è®¡ç®—æ€»æ”¶å…¥
  let total_revenue = multiply(total_yield, market_price_per_ton)
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_labor_cost = multiply(field_area_hectares, labor_cost_per_hectare)
  let total_fertilizer_cost = multiply(field_area_hectares, fertilizer_cost_per_hectare)
  let total_cost = add(total_labor_cost, total_fertilizer_cost)
  
  // è®¡ç®—åˆ©æ¶¦
  let profit = add(total_revenue, -total_cost)
  
  assert_eq(20000, total_yield)
  assert_eq(5000000, total_revenue)
  assert_eq(3000, total_labor_cost)
  assert_eq(2000, total_fertilizer_cost)
  assert_eq(5000, total_cost)
  assert_eq(4995000, profit)
}

test "string_processing_multilingual" {
  // æµ‹è¯•å¤šè¯­è¨€å­—ç¬¦ä¸²å¤„ç†
  let english_greeting = greet("World")
  let chinese_greeting = greet("ä¸–ç•Œ")
  let spanish_greeting = greet("Mundo")
  let arabic_greeting = greet("Ø§Ù„Ø¹Ø§Ù„Ù…")
  let emoji_greeting = greet("ğŸŒ")
  
  // éªŒè¯å¤šè¯­è¨€æ”¯æŒ
  assert_eq_string("Hello, World!", english_greeting)
  assert_eq_string("Hello, ä¸–ç•Œ!", chinese_greeting)
  assert_eq_string("Hello, Mundo!", spanish_greeting)
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø§Ù„Ù…!", arabic_greeting)
  assert_eq_string("Hello, ğŸŒ!", emoji_greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  let mixed_greeting = greet("User123@email.com")
  assert_eq_string("Hello, User123@email.com!", mixed_greeting)
}

test "advanced_algorithmic_complexity" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦è®¡ç®—
  let input_size = 1000
  let linear_constant = 2
  let quadratic_constant = 3
  let logarithmic_base = 2
  
  // O(n) çº¿æ€§å¤æ‚åº¦
  let linear_operations = multiply(input_size, linear_constant)
  
  // O(nÂ²) äºŒæ¬¡å¤æ‚åº¦ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let quadratic_operations = multiply(multiply(input_size, input_size), quadratic_constant) / 1000
  
  // O(log n) å¯¹æ•°å¤æ‚åº¦ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let log_operations = divide_with_ceil(input_size, logarithmic_base)
  
  // å¤æ‚ç®—æ³•æ€»æ“ä½œæ•°
  let total_operations = add(add(linear_operations, quadratic_operations), log_operations)
  
  assert_eq(2000, linear_operations)
  assert_eq(3000, quadratic_operations)
  assert_eq(500, log_operations)
  assert_eq(5500, total_operations)
}