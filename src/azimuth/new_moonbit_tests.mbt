// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›–å„ç§åœºæ™¯ï¼Œä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•

test "string_length_validation" {
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦éªŒè¯åŠŸèƒ½
  let short_name = "Bob"
  let medium_name = "Alexander"
  let long_name = "VeryLongNameThatExceedsNormalExpectations"
  
  // éªŒè¯greetå‡½æ•°å¤„ç†ä¸åŒé•¿åº¦å­—ç¬¦ä¸²çš„èƒ½åŠ›
  assert_eq_string("Hello, Bob!", greet(short_name))
  assert_eq_string("Hello, Alexander!", greet(medium_name))
  assert_eq_string("Hello, VeryLongNameThatExceedsNormalExpectations!", greet(long_name))
}

test "numeric_precision_tests" {
  // æµ‹è¯•æ•°å€¼ç²¾åº¦å’Œè¾¹ç•Œæƒ…å†µ
  let large_positive = 1000000
  let large_negative = -1000000
  
  // æµ‹è¯•å¤§æ•°ç›¸åŠ 
  let sum_result = add(large_positive, large_positive)
  assert_eq(2000000, sum_result)
  
  // æµ‹è¯•å¤§æ•°ç›¸ä¹˜
  let product_result = multiply(large_positive, 2)
  assert_eq(2000000, product_result)
  
  // æµ‹è¯•å¤§è´Ÿæ•°è¿ç®—
  let negative_sum = add(large_negative, large_negative)
  assert_eq(-2000000, negative_sum)
  
  // æµ‹è¯•æ­£è´Ÿæ•°ç›¸ä¹˜
  let mixed_product = multiply(large_positive, -2)
  assert_eq(-2000000, mixed_product)
}

test "complex_arithmetic_expressions" {
  // æµ‹è¯•å¤æ‚ç®—æœ¯è¡¨è¾¾å¼
  // è®¡ç®—ï¼š(a + b) * (c - d) + e * f
  let a = 10
  let b = 5
  let c = 20
  let d = 8
  let e = 3
  let f = 4
  
  let sum_ab = add(a, b)        // 15
  let diff_cd = add(c, -d)      // 12
  let product_ef = multiply(e, f) // 12
  let product_ab_cd = multiply(sum_ab, diff_cd) // 180
  let final_result = add(product_ab_cd, product_ef) // 192
  
  assert_eq(192, final_result)
}

test "error_boundary_conditions" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œæ¡ä»¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼è¾¹ç•Œ
  assert_true(add(max_val, 0) == max_val)
  assert_true(add(max_val, -1) == 2147483646)
  assert_true(add(max_val, 1) == max_val)  // æº¢å‡ºä¿æŠ¤
  
  // æµ‹è¯•æœ€å°å€¼è¾¹ç•Œ
  assert_true(add(min_val, 0) == min_val)
  assert_true(add(min_val, 1) == -2147483647)
  assert_true(add(min_val, -1) == min_val)  // æº¢å‡ºä¿æŠ¤
  
  // æµ‹è¯•ä¹˜æ³•è¾¹ç•Œ
  assert_true(multiply(max_val, 1) == max_val)
  assert_true(multiply(min_val, 1) == min_val)
  assert_true(multiply(max_val, -1) == min_val)
  assert_true(multiply(min_val, -1) == min_val)
}

test "string_special_characters_handling" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let unicode_name = "å¼ ä¸‰æå››"
  let emoji_name = "ğŸŒŸğŸš€"
  let mixed_special = "Test@123#$"
  let quoted_name = "\"John\""
  let newline_name = "Line1\nLine2"
  
  assert_eq_string("Hello, å¼ ä¸‰æå››!", greet(unicode_name))
  assert_eq_string("Hello, ğŸŒŸğŸš€!", greet(emoji_name))
  assert_eq_string("Hello, Test@123#$!", greet(mixed_special))
  assert_eq_string("Hello, \"John\"!", greet(quoted_name))
  assert_eq_string("Hello, Line1\nLine2!", greet(newline_name))
}

test "mathematical_sequence_calculations" {
  // æµ‹è¯•æ•°å­¦åºåˆ—è®¡ç®—
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—å‰å‡ é¡¹çš„å’Œï¼š1, 1, 2, 3, 5, 8, 13, 21
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  let fib6 = add(fib4, fib5)  // 8
  let fib7 = add(fib5, fib6)  // 13
  let fib8 = add(fib6, fib7)  // 21
  
  // è®¡ç®—å‰8é¡¹çš„å’Œ
  let sum_fib = add(add(add(add(add(add(add(fib1, fib2), fib3), fib4), fib5), fib6), fib7), fib8)
  assert_eq(54, sum_fib)
}

test "real_world_financial_calculations" {
  // æµ‹è¯•å®é™…é‡‘èè®¡ç®—åœºæ™¯
  // è®¡ç®—è´·æ¬¾æœˆä¾›ï¼šP * r * (1 + r)^n / ((1 + r)^n - 1)
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—
  let principal = 100000  // æœ¬é‡‘
  let annual_rate = 6     // å¹´åˆ©ç‡6%
  let years = 30          // è´·æ¬¾å¹´é™
  
  // ç®€åŒ–è®¡ç®—ï¼šæœˆä¾› â‰ˆ æœ¬é‡‘ / (å¹´é™ * 12) + åˆ©æ¯
  let monthly_principal = principal / (years * 12)
  let total_interest = multiply(principal, annual_rate) / 100
  let monthly_interest = total_interest / (years * 12)
  let monthly_payment = add(monthly_principal, monthly_interest)
  
  assert_eq(444, monthly_payment)  // ç®€åŒ–è®¡ç®—ç»“æœ
}

test "performance_stress_tests" {
  // æµ‹è¯•æ€§èƒ½å‹åŠ›åœºæ™¯
  let base = 2
  
  // è®¡ç®—2çš„10æ¬¡æ–¹ï¼š2^10 = 1024
  let power_2 = multiply(base, base)
  let power_4 = multiply(power_2, power_2)
  let power_8 = multiply(power_4, power_4)
  let power_10 = multiply(power_8, multiply(base, base))
  
  assert_eq(1024, power_10)
  
  // è¿ç»­åŠ æ³•æµ‹è¯•
  let sum_1_to_100 = multiply(100, add(100, 1)) / 2  // ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼
  assert_eq(5050, sum_1_to_100)
}

test "data_structure_simulation" {
  // æ¨¡æ‹Ÿæ•°æ®ç»“æ„æ“ä½œ
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špush, push, pop, peek
  let stack_initial = 0
  let push1 = add(stack_initial, 10)
  let push2 = add(push1, 20)
  let push3 = add(push2, 30)
  
  // æ¨¡æ‹Ÿpopæ“ä½œï¼ˆç§»é™¤æœ€åä¸€ä¸ªå…ƒç´ ï¼‰
  let after_pop = add(push3, -30)
  
  // æ¨¡æ‹Ÿpeekæ“ä½œï¼ˆæŸ¥çœ‹æ ˆé¡¶å…ƒç´ ï¼‰
  let peek_value = 20
  
  assert_eq(30, push3)      // æ ˆä¸­æœ‰ä¸‰ä¸ªå…ƒç´ ï¼š10, 20, 30
  assert_eq(20, after_pop)  // popåæ ˆä¸­æœ‰ä¸¤ä¸ªå…ƒç´ ï¼š10, 20
  assert_eq(20, peek_value) // æ ˆé¡¶å…ƒç´ æ˜¯20
}

test "conditional_calculation_logic" {
  // æµ‹è¯•æ¡ä»¶è®¡ç®—é€»è¾‘
  let x = 15
  let y = 25
  let z = 10
  
  // æ¡ä»¶1ï¼šå¦‚æœx < yï¼Œåˆ™è®¡ç®—x + zï¼Œå¦åˆ™è®¡ç®—y - z
  let condition1 = x < y
  let result1 = if condition1 { add(x, z) } else { add(y, -z) }
  assert_eq(25, result1)  // 15 < 25ä¸ºçœŸï¼Œæ‰€ä»¥15 + 10 = 25
  
  // æ¡ä»¶2ï¼šå¦‚æœy > zä¸”x > 5ï¼Œåˆ™è®¡ç®—x * yï¼Œå¦åˆ™è®¡ç®—x + y
  let condition2a = y > z
  let condition2b = x > 5
  let condition2 = condition2a && condition2b
  let result2 = if condition2 { multiply(x, y) } else { add(x, y) }
  assert_eq(375, result2)  // 25 > 10ä¸”15 > 5ä¸ºçœŸï¼Œæ‰€ä»¥15 * 25 = 375
  
  // æ¡ä»¶3ï¼šå¤æ‚æ¡ä»¶åˆ¤æ–­
  let complex_condition = (x + y > z) && (y - x < x)
  let result3 = if complex_condition { multiply(add(x, y), z) } else { add(multiply(x, y), z) }
  assert_eq(400, result3)  // (15+25 > 10)ä¸”(25-15 < 15)ä¸ºçœŸï¼Œæ‰€ä»¥(15+25) * 10 = 400
}