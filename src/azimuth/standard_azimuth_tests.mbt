// æ ‡å‡† Azimuth æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ç¼–å†™çš„10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹

test "add_function_identity_elements" {
  // æµ‹è¯•åŠ æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(5, add(5, 0))
  assert_eq(-3, add(-3, 0))
  assert_eq(0, add(0, 0))
  assert_eq(2147483647, add(2147483647, 0))
}

test "multiply_function_zero_property" {
  // æµ‹è¯•ä¹˜æ³•çš„é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(-10, 0))
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(2147483647, 0))
}

test "divide_with_ceil_precision_tests" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(3, divide_with_ceil(8, 3))  // 2.666... -> 3
  assert_eq(1, divide_with_ceil(1, 100))  // 0.01 -> 1
  assert_eq(1000, divide_with_ceil(99999, 100))  // 999.99 -> 1000
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
}

test "mathematical_commutative_laws" {
  // æµ‹è¯•åŠ æ³•å’Œä¹˜æ³•çš„äº¤æ¢å¾‹
  let a = 12
  let b = 18
  assert_eq(add(a, b), add(b, a))
  assert_eq(multiply(a, b), multiply(b, a))
  
  // æµ‹è¯•ä¸åŒçš„æ•°å€¼ç»„åˆ
  let x = -5
  let y = 7
  assert_eq(add(x, y), add(y, x))
  assert_eq(multiply(x, y), multiply(y, x))
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  let unit_price = 45
  let quantity = 12
  let tax_rate = 8  // 8%
  let shipping = 25
  let discount = 50
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(unit_price, quantity)
  // è®¡ç®—ç¨è´¹
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  // è®¡ç®—æ€»ä»·
  let total_before_discount = add(add(subtotal, tax), shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(540, subtotal)
  assert_eq(44, tax)
  assert_eq(609, total_before_discount)
  assert_eq(559, final_total)
}

test "negative_number_operations_comprehensive" {
  // å…¨é¢çš„è´Ÿæ•°è¿ç®—æµ‹è¯•
  assert_eq(-10, add(-3, -7))
  assert_eq(2, add(-5, 7))
  assert_eq(-2, add(5, -7))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-4, divide_with_ceil(-11, 3))
  assert_eq(3, divide_with_ceil(-9, -3))
}

test "boundary_value_analysis" {
  // è¾¹ç•Œå€¼åˆ†ææµ‹è¯•
  // æµ‹è¯•æ¥è¿‘Intæœ€å¤§å€¼çš„è¿ç®—
  let near_max = 2147483646
  assert_eq(2147483647, add(near_max, 1))
  
  // æµ‹è¯•æ¥è¿‘Intæœ€å°å€¼çš„è¿ç®—
  let near_min = -2147483647
  assert_eq(-2147483648, add(near_min, -1))
  
  // æµ‹è¯•è¾¹ç•Œé™¤æ³•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "real_world_packaging_optimization" {
  // çœŸå®ä¸–ç•ŒåŒ…è£…ä¼˜åŒ–åœºæ™¯
  let product_weights = [15, 23, 8, 12, 7]  // äº§å“é‡é‡ï¼ˆkgï¼‰
  let max_weight_per_box = 20  // æ¯ç®±æœ€å¤§é‡é‡ï¼ˆkgï¼‰
  
  // è®¡ç®—æ¯ä¸ªäº§å“éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let boxes_1 = divide_with_ceil(product_weights[0], max_weight_per_box)
  let boxes_2 = divide_with_ceil(product_weights[1], max_weight_per_box)
  let boxes_3 = divide_with_ceil(product_weights[2], max_weight_per_box)
  let boxes_4 = divide_with_ceil(product_weights[3], max_weight_per_box)
  let boxes_5 = divide_with_ceil(product_weights[4], max_weight_per_box)
  
  // è®¡ç®—æ€»åŒ…è£…ç®±æ•°é‡
  let total_boxes = add(add(add(add(boxes_1, boxes_2), boxes_3), boxes_4), boxes_5)
  
  assert_eq(1, boxes_1)  // ceil(15/20) = 1
  assert_eq(2, boxes_2)  // ceil(23/20) = 2
  assert_eq(1, boxes_3)  // ceil(8/20) = 1
  assert_eq(1, boxes_4)  // ceil(12/20) = 1
  assert_eq(1, boxes_5)  // ceil(7/20) = 1
  assert_eq(6, total_boxes)  // 1 + 2 + 1 + 1 + 1 = 6
}

test "error_handling_and_safety" {
  // é”™è¯¯å¤„ç†å’Œå®‰å…¨æ€§æµ‹è¯•
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•æç«¯æ•°å€¼è¿ç®—
  let extreme_large = 1000000
  let extreme_small = 1
  assert_eq(1000001, add(extreme_large, extreme_small))
  assert_eq(999999, add(extreme_large, -extreme_small))
  assert_eq(1000000, multiply(extreme_large, extreme_small))
  
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, This is a very long string that tests the greet function with extensive input!", greet("This is a very long string that tests the greet function with extensive input!"))
}