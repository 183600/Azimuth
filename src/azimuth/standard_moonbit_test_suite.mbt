// æ ‡å‡† MoonBit æµ‹è¯•å¥—ä»¶ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// ä¸º Azimuth é¡¹ç›®æ·»åŠ å…¨é¢çš„åŠŸèƒ½æµ‹è¯•è¦†ç›–

// å®šä¹‰æ‰€éœ€çš„å‡½æ•°
fn assert_eq(expected : Int, actual : Int) -> Unit {
  if expected == actual {
    ()
  } else {
    let _ = "Assertion failed"
  }
  ()
}

fn assert_eq_string(expected : String, actual : String) -> Unit {
  if expected == actual {
    ()
  } else {
    let _ = "String assertion failed"
  }
  ()
}

fn add(a : Int, b : Int) -> Int {
  a + b
}

fn multiply(a : Int, b : Int) -> Int {
  a * b
}

fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// è¾…åŠ©å‡½æ•°ï¼šå¸ƒå°”æ–­è¨€
fn assert_true(condition : Bool) -> Unit {
  if condition {
    ()
  } else {
    let _ = "Boolean assertion failed"
  }
}

test "mathematical_commutative_laws" {
  // æµ‹è¯•æ•°å­¦äº¤æ¢å¾‹
  let a = 15
  let b = 27
  
  // åŠ æ³•äº¤æ¢å¾‹: a + b = b + a
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹: a * b = b * a
  assert_eq(multiply(a, b), multiply(b, a))
  
  // æµ‹è¯•è´Ÿæ•°çš„äº¤æ¢å¾‹
  assert_eq(add(-5, 10), add(10, -5))
  assert_eq(multiply(-4, 7), multiply(7, -4))
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-10, -3))
  assert_eq(-4, divide_with_ceil(10, -3))
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(0, divide_with_ceil(0, 0))
}

test "complex_business_logic_scenario" {
  // å¤æ‚ä¸šåŠ¡é€»è¾‘åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—è£…ç›’å’Œè¿è¾“æˆæœ¬
  
  let total_products = 127
  let box_capacity = 15
  let cost_per_box = 25
  let shipping_cost_per_box = 8
  
  // è®¡ç®—éœ€è¦çš„ç›’å­æ•°é‡
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  assert_eq(9, boxes_needed)  // ceil(127/15) = 9
  
  // è®¡ç®—æ€»æˆæœ¬
  let box_cost = multiply(boxes_needed, cost_per_box)
  let shipping_cost = multiply(boxes_needed, shipping_cost_per_box)
  let total_cost = add(box_cost, shipping_cost)
  
  assert_eq(225, box_cost)        // 9 * 25
  assert_eq(72, shipping_cost)    // 9 * 8
  assert_eq(297, total_cost)      // 225 + 72
}

test "mathematical_distributive_property" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 6
  let b = 8
  let c = 4
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)  // 6 * (8 + 4) = 6 * 8 + 6 * 4 = 72
  
  // æµ‹è¯•å¦ä¸€ä¸ªç»„åˆ
  let x = 12
  let y = 5
  let z = 3
  
  assert_eq(
    multiply(x, add(y, z)),
    add(multiply(x, y), multiply(x, z))
  )
}

test "greet_function_internationalization" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…åŒ–æ”¯æŒ
  // Unicode å­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  
  // Emoji æµ‹è¯•
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  
  // ç‰¹æ®Šç¬¦å·æµ‹è¯•
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, &*()!", greet("&*()"))
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  
  let total_memory = 16384  // GB
  let total_cpu_cores = 256
  let number_of_services = 7
  
  // è®¡ç®—æ¯ä¸ªæœåŠ¡çš„æœ€å°èµ„æºåˆ†é…
  let memory_per_service = divide_with_ceil(total_memory, number_of_services)
  let cpu_per_service = divide_with_ceil(total_cpu_cores, number_of_services)
  
  assert_eq(2341, memory_per_service)  // ceil(16384/7)
  assert_eq(37, cpu_per_service)       // ceil(256/7)
  
  // éªŒè¯æ€»åˆ†é…èµ„æº
  let total_allocated_memory = multiply(memory_per_service, number_of_services)
  let total_allocated_cpu = multiply(cpu_per_service, number_of_services)
  
  assert_eq(16387, total_allocated_memory)  // 2341 * 7
  assert_eq(259, total_allocated_cpu)       // 37 * 7
  
  // è®¡ç®—èµ„æºæµªè´¹
  let memory_waste = subtract(total_allocated_memory, total_memory)
  let cpu_waste = subtract(total_allocated_cpu, total_cpu_cores)
  
  assert_eq(3, memory_waste)  // 16387 - 16384
  assert_eq(3, cpu_waste)     // 259 - 256
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æå€¼æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(12345, 0))
  
  // å¤§æ•°æµ‹è¯•
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
  
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
}

test "sequential_calculation_pipeline" {
  // è¿ç»­è®¡ç®—æµæ°´çº¿æµ‹è¯•
  // åœºæ™¯ï¼šå¤šæ­¥éª¤æ•°æ®å¤„ç†
  
  let initial_value = 10
  
  // æ­¥éª¤1ï¼šåŠ æ³•è¿ç®—
  let step1 = add(initial_value, 15)  // 25
  
  // æ­¥éª¤2ï¼šä¹˜æ³•è¿ç®—
  let step2 = multiply(step1, 3)      // 75
  
  // æ­¥éª¤3ï¼šé™¤æ³•è¿ç®—
  let step3 = divide_with_ceil(step2, 20)  // 4
  
  // æ­¥éª¤4ï¼šå†æ¬¡åŠ æ³•
  let step4 = add(step3, 5)           // 9
  
  // æ­¥éª¤5ï¼šæœ€ç»ˆä¹˜æ³•
  let final_result = multiply(step4, 2)   // 18
  
  assert_eq(25, step1)
  assert_eq(75, step2)
  assert_eq(4, step3)
  assert_eq(9, step4)
  assert_eq(18, final_result)
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼æ€§è´¨
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼: x + 0 = x
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼: x * 1 = x
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  
  // ä¹˜æ³•é›¶å…ƒ: x * 0 = 0
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  
  // è´Ÿå…ƒç´ æ€§è´¨: x + (-x) = 0
  assert_eq(0, add(x, multiply(x, -1)))
  assert_eq(0, add(multiply(x, -1), x))
}
