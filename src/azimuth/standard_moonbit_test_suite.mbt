// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

// å¯¼å…¥ azimuth åº“
use azimuth

test "add_function_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 15
  let b = 27
  assert_eq(azimuth.add(a, b), azimuth.add(b, a))
  assert_eq(42, azimuth.add(15, 27))
  assert_eq(42, azimuth.add(27, 15))
}

test "multiply_function_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 5
  let b = 8
  let c = 12
  let left_side = azimuth.multiply(a, azimuth.add(b, c))
  let right_side = azimuth.add(azimuth.multiply(a, b), azimuth.multiply(a, c))
  assert_eq(left_side, right_side)
  assert_eq(100, left_side)  // 5 * (8 + 12) = 5 * 20 = 100
}

test "divide_with_ceil_comprehensive_scenarios" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å„ç§åœºæ™¯
  // æ­£æ•°é™¤æ³•
  assert_eq(4, azimuth.divide_with_ceil(10, 3))   // 10/3 = 3.333... -> 4
  assert_eq(3, azimuth.divide_with_ceil(9, 3))    // 9/3 = 3 -> 3
  assert_eq(1, azimuth.divide_with_ceil(1, 100))  // 1/100 = 0.01 -> 1
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, azimuth.divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
  assert_eq(3, azimuth.divide_with_ceil(10, -3))   // 10/-3 = -3.333... -> -3
  assert_eq(4, azimuth.divide_with_ceil(-10, -3))  // -10/-3 = 3.333... -> 4
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, azimuth.divide_with_ceil(5, 0))     // é™¤æ•°ä¸º0ï¼Œè¿”å›0
  assert_eq(0, azimuth.divide_with_ceil(0, 5))     // 0é™¤ä»¥ä»»ä½•æ•°ï¼Œè¿”å›0
}

test "greet_function_internationalization" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…åŒ–æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", azimuth.greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒ!", azimuth.greet("ğŸŒ"))
  assert_eq_string("Hello, EspaÃ±ol!", azimuth.greet("EspaÃ±ol"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", azimuth.greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", azimuth.greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 89
  let quantity = 6
  let tax_rate = 8
  let shipping_cost = 25
  let discount = 50
  
  // è®¡ç®—å°è®¡
  let subtotal = azimuth.multiply(unit_price, quantity)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = azimuth.divide_with_ceil(azimuth.multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æ€»ä»·ï¼ˆå«è¿è´¹å’ŒæŠ˜æ‰£ï¼‰
  let total_before_discount = azimuth.add(azimuth.add(subtotal, tax_amount), shipping_cost)
  let final_total = azimuth.add(total_before_discount, -discount)
  
  assert_eq(534, subtotal)      // 89 * 6 = 534
  assert_eq(43, tax_amount)     // ceil(534 * 8 / 100) = ceil(42.72) = 43
  assert_eq(602, total_before_discount)  // 534 + 43 + 25 = 602
  assert_eq(552, final_total)   // 602 - 50 = 552
}

test "mathematical_sequence_calculation" {
  // æ•°å­¦åºåˆ—è®¡ç®—ï¼šç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—
  // ç­‰å·®æ•°åˆ—ï¼š2, 5, 8, 11, 14 çš„å’Œ
  let arithmetic_sum = azimuth.add(azimuth.add(azimuth.add(azimuth.add(2, 5), 8), 11), 14)
  
  // ç­‰æ¯”æ•°åˆ—ï¼š2, 4, 8, 16, 32 çš„å’Œ
  let geometric_sum = azimuth.add(azimuth.add(azimuth.add(azimuth.add(2, 4), 8), 16), 32)
  
  assert_eq(40, arithmetic_sum)   // 2 + 5 + 8 + 11 + 14 = 40
  assert_eq(62, geometric_sum)   // 2 + 4 + 8 + 16 + 32 = 62
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–é—®é¢˜
  let total_budget = 10000
  let project_a_cost = 3200
  let project_b_cost = 2800
  let project_c_cost = 2100
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let used_budget = azimuth.add(azimuth.add(project_a_cost, project_b_cost), project_c_cost)
  let remaining_budget = azimuth.add(total_budget, -used_budget)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡ï¼ˆæ¯ä¸ªå°é¡¹ç›®æˆæœ¬500ï¼‰
  let small_projects_count = azimuth.divide_with_ceil(remaining_budget, 500)
  
  assert_eq(8100, used_budget)           // 3200 + 2800 + 2100 = 8100
  assert_eq(1900, remaining_budget)      // 10000 - 8100 = 1900
  assert_eq(4, small_projects_count)     // ceil(1900 / 500) = ceil(3.8) = 4
}

test "time_and_work_calculation" {
  // æ—¶é—´ä¸å·¥ä½œé‡è®¡ç®—
  let total_tasks = 87
  let workers_count = 4
  let tasks_per_worker_per_day = 6
  let working_days = 5
  
  // è®¡ç®—æ¯ä¸ªå·¥äººçš„ä»»åŠ¡é‡
  let tasks_per_worker = azimuth.divide_with_ceil(total_tasks, workers_count)
  
  // è®¡ç®—å®Œæˆæ—¶é—´ï¼ˆå¤©æ•°ï¼‰
  let days_needed = azimuth.divide_with_ceil(tasks_per_worker, tasks_per_worker_per_day)
  
  // è®¡ç®—æ€»å·¥ä½œæ—¥ï¼ˆè€ƒè™‘å‘¨æœ«ï¼‰
  let total_calendar_days = azimuth.multiply(days_needed, 2)  // å‡è®¾å·¥ä½œæ—¥å’Œä¼‘æ¯æ—¥1:1
  
  assert_eq(22, tasks_per_worker)        // ceil(87 / 4) = ceil(21.75) = 22
  assert_eq(4, days_needed)              // ceil(22 / 6) = ceil(3.666...) = 4
  assert_eq(8, total_calendar_days)      // 4 * 2 = 8
}

test "data_analysis_statistics" {
  // æ•°æ®åˆ†æç»Ÿè®¡è®¡ç®—
  let data_points = [15, 23, 31, 42, 38, 27, 19]  // æ¨¡æ‹Ÿæ•°æ®ç‚¹
  let data_count = 7
  
  // è®¡ç®—æ€»å’Œï¼ˆæ‰‹åŠ¨ç›¸åŠ ï¼‰
  let total_sum = azimuth.add(azimuth.add(azimuth.add(azimuth.add(azimuth.add(azimuth.add(15, 23), 31), 42), 38), 27), 19)
  
  // è®¡ç®—å¹³å‡å€¼ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let average = azimuth.divide_with_ceil(total_sum, data_count)
  
  // è®¡ç®—æœ€å¤§å€¼å’Œæœ€å°å€¼çš„å·®
  let max_value = 42
  let min_value = 15
  let range = azimuth.add(max_value, -min_value)
  
  assert_eq(195, total_sum)     // 15 + 23 + 31 + 42 + 38 + 27 + 19 = 195
  assert_eq(28, average)        // ceil(195 / 7) = ceil(27.857...) = 28
  assert_eq(27, range)          // 42 - 15 = 27
}

test "error_handling_and_edge_cases" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µæµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num1 = 100000
  let large_num2 = 200000
  let large_sum = azimuth.add(large_num1, large_num2)
  let large_product = azimuth.multiply(1000, 1000)
  
  // æµ‹è¯•é›¶å€¼è¿ç®—
  let zero_addition = azimuth.add(0, 12345)
  let zero_multiplication = azimuth.multiply(0, 12345)
  let zero_division = azimuth.divide_with_ceil(0, 12345)
  
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  let negative_addition = azimuth.add(-100, 50)
  let negative_division = azimuth.divide_with_ceil(-25, 4)
  
  assert_eq(300000, large_sum)           // 100000 + 200000 = 300000
  assert_eq(1000000, large_product)     // 1000 * 1000 = 1000000
  assert_eq(12345, zero_addition)       // 0 + 12345 = 12345
  assert_eq(0, zero_multiplication)     // 0 * 12345 = 0
  assert_eq(0, zero_division)           // 0 / 12345 = 0
  assert_eq(-50, negative_addition)     // -100 + 50 = -50
  assert_eq(-6, negative_division)      // ceil(-25 / 4) = ceil(-6.25) = -6
}