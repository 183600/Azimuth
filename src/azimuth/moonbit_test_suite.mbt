// MoonBit æµ‹è¯•å¥—ä»¶ - æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// åŒ…å« 10 ä¸ªå…¨é¢çš„æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–å„ç§åŠŸèƒ½å’Œåœºæ™¯

test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(10, azimuth::add(7, 3))
  assert_eq(0, azimuth::add(-5, 5))
  assert_eq(-8, azimuth::add(-3, -5))
  assert_eq(15, azimuth::multiply(3, 5))
  assert_eq(-12, azimuth::multiply(-3, 4))
  assert_eq(0, azimuth::multiply(0, 100))
}

test "boundary_value_handling" {
  // è¾¹ç•Œå€¼å¤„ç†æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼è¾¹ç•Œ
  assert_eq(max_val, azimuth::add(max_val, 0))
  assert_eq(max_val, azimuth::add(max_val, 1))
  assert_eq(max_val, azimuth::multiply(max_val, 1))
  
  // æµ‹è¯•æœ€å°å€¼è¾¹ç•Œ
  assert_eq(min_val, azimuth::add(min_val, 0))
  assert_eq(min_val, azimuth::add(min_val, -1))
  assert_eq(min_val, azimuth::multiply(min_val, 1))
  assert_eq(min_val, azimuth::multiply(min_val, -1))
  
  // æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆ
  assert_eq(-1, azimuth::add(max_val, min_val))
}

test "string_processing_comprehensive" {
  // ç»¼åˆå­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, MoonBit!", azimuth::greet("MoonBit"))
  assert_eq_string("Hello, !", azimuth::greet(""))
  assert_eq_string("Hello, ä¸–ç•Œ!", azimuth::greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, 123!", azimuth::greet("123"))
  assert_eq_string("Hello, special@#$%!", azimuth::greet("special@#$%"))
  assert_eq_string("Hello, Line1\nLine2!", azimuth::greet("Line1\nLine2"))
  assert_eq_string("Hello, ğŸŒ!", azimuth::greet("ğŸŒ"))
}

test "complex_calculation_scenarios" {
  // å¤æ‚è®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯1: è®¡ç®—çŸ©å½¢é¢ç§¯å’Œå‘¨é•¿
  let length = 8
  let width = 5
  let area = azimuth::multiply(length, width)
  let perimeter = azimuth::multiply(azimuth::add(length, width), 2)
  assert_eq(40, area)
  assert_eq(26, perimeter)
  
  // åœºæ™¯2: è®¡ç®—å¹³å‡åˆ†
  let score1 = 85
  let score2 = 92
  let score3 = 78
  let total = azimuth::add(azimuth::add(score1, score2), score3)
  let average = total / 3
  assert_eq(85, average)
  
  // åœºæ™¯3: è®¡ç®—æŠ˜æ‰£ä»·æ ¼
  let original_price = 200
  let discount_rate = 15  // 15% æŠ˜æ‰£
  let discount_amount = azimuth::multiply(original_price, discount_rate) / 100
  let final_price = azimuth::add(original_price, -discount_amount)
  assert_eq(170, final_price)
}

test "real_world_business_calculations" {
  // å®é™…ä¸šåŠ¡è®¡ç®—æµ‹è¯•
  // åœºæ™¯1: è®¢å•æ€»ä»·è®¡ç®—
  let item_price = 99
  let quantity = 3
  let shipping_fee = 12
  let tax_rate = 8  // 8% ç¨ç‡
  
  let subtotal = azimuth::multiply(item_price, quantity)
  let tax_amount = azimuth::multiply(subtotal, tax_rate) / 100
  let total = azimuth::add(azimuth::add(subtotal, tax_amount), shipping_fee)
  assert_eq(332, total)  // 99*3 + 99*3*8/100 + 12 = 297 + 23 + 12 = 332
  
  // åœºæ™¯2: è´§å¸è½¬æ¢
  let usd_amount = 150
  let exchange_rate = 7  // 1 USD = 7 CNY
  let conversion_fee = 10  // å›ºå®šæ‰‹ç»­è´¹
  let cny_amount = azimuth::multiply(usd_amount, exchange_rate)
  let final_amount = azimuth::add(cny_amount, conversion_fee)
  assert_eq(1060, final_amount)  // 150*7 + 10 = 1050 + 10 = 1060
}

test "mathematical_properties_verification" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let a = 12
  let b = 8
  let c = 5
  
  // éªŒè¯åŠ æ³•äº¤æ¢å¾‹
  assert_eq(azimuth::add(a, b), azimuth::add(b, a))
  
  // éªŒè¯ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(azimuth::multiply(a, b), azimuth::multiply(b, a))
  
  // éªŒè¯åˆ†é…å¾‹
  let distributive_left = azimuth::multiply(a, azimuth::add(b, c))
  let distributive_right = azimuth::add(azimuth::multiply(a, b), azimuth::multiply(a, c))
  assert_eq(distributive_left, distributive_right)
  
  // éªŒè¯ç»“åˆå¾‹
  let associative_left = azimuth::add(azimuth::add(a, b), c)
  let associative_right = azimuth::add(a, azimuth::add(b, c))
  assert_eq(associative_left, associative_right)
}

test "error_handling_and_edge_cases" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  assert_true(azimuth::add(max_val, 100) == max_val)
  assert_true(azimuth::add(min_val, -100) == min_val)
  assert_true(azimuth::multiply(max_val, 2) == max_val)
  assert_true(azimuth::multiply(min_val, 2) == min_val)
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°
  azimuth::assert_true(true)
  azimuth::assert_false(false)
  azimuth::assert_eq(42, 42)
  azimuth::assert_eq_string("test", "test")
  
  // æµ‹è¯•ç‰¹æ®Šæƒ…å†µ
  assert_eq(0, azimuth::multiply(0, max_val))
  assert_eq(0, azimuth::multiply(0, min_val))
  assert_eq(max_val, azimuth::add(0, max_val))
  assert_eq(min_val, azimuth::add(0, min_val))
}

test "performance_and_efficiency" {
  // æ€§èƒ½å’Œæ•ˆç‡æµ‹è¯•
  // æµ‹è¯•å¤§é‡æ•°æ®è®¡ç®—
  let base_value = 100
  let multiplier = 1000
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—å’Œï¼š1 + 2 + ... + 100 = 100 * 101 / 2 = 5050
  let series_sum = azimuth::multiply(multiplier, azimuth::add(multiplier, 1)) / 2
  assert_eq(500500, series_sum)
  
  // æµ‹è¯•è¿ç»­è¿ç®—
  let consecutive_result = azimuth::add(
    azimuth::multiply(10, 20),
    azimuth::multiply(30, 40)
  )
  assert_eq(1400, consecutive_result)  // 10*20 + 30*40 = 200 + 1200 = 1400
  
  // æµ‹è¯•åµŒå¥—è¿ç®—
  let nested_result = azimuth::multiply(
    azimuth::add(5, 3),
    azimuth::add(7, 2)
  )
  assert_eq(72, nested_result)  // (5+3)*(7+2) = 8*9 = 72
}

test "data_type_operations" {
  // æ•°æ®ç±»å‹æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿå¸ƒå°”è¿ç®—
  let true_as_int = 1
  let false_as_int = 0
  
  // æ¨¡æ‹Ÿé€»è¾‘ä¸ï¼ša && b = a * b
  let logical_and = azimuth::multiply(true_as_int, false_as_int)
  assert_eq(0, logical_and)
  
  // æ¨¡æ‹Ÿé€»è¾‘æˆ–ï¼ša || b = a + b - a * b
  let logical_or = azimuth::add(
    azimuth::add(true_as_int, false_as_int),
    azimuth::multiply(true_as_int, false_as_int)
  )
  assert_eq(1, logical_or)
  
  // æµ‹è¯•å­—ç¬¦ä¸²åˆ°æ•°å­—çš„é—´æ¥æ“ä½œ
  let number_str = "42"
  let greeting_result = azimuth::greet(number_str)
  assert_eq_string("Hello, 42!", greeting_result)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let special_chars = "!@#$%^&*()"
  let special_result = azimuth::greet(special_chars)
  assert_eq_string("Hello, !@#$%^&*()!", special_result)
}

test "comprehensive_application_scenario" {
  // ç»¼åˆåº”ç”¨åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—ä¸€ä¸ªé¡¹ç›®çš„æ€»æˆæœ¬å’Œæ”¶ç›Š
  
  // é¡¹ç›®å‚æ•°
  let initial_cost = 10000
  let monthly_cost = 1500
  let duration_months = 12
  let monthly_revenue = 2500
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = azimuth::add(
    initial_cost,
    azimuth::multiply(monthly_cost, duration_months)
  )
  
  // è®¡ç®—æ€»æ”¶å…¥
  let total_revenue = azimuth::multiply(monthly_revenue, duration_months)
  
  // è®¡ç®—å‡€åˆ©æ¶¦
  let net_profit = azimuth::add(total_revenue, -total_cost)
  
  // è®¡ç®—æŠ•èµ„å›æŠ¥ç‡ï¼ˆç®€åŒ–ä¸ºç™¾åˆ†æ¯”ï¼‰
  let roi_percentage = azimuth::multiply(net_profit, 100) / total_cost
  
  // éªŒè¯ç»“æœ
  assert_eq(28000, total_cost)    // 10000 + 1500*12 = 10000 + 18000 = 28000
  assert_eq(30000, total_revenue)  // 2500*12 = 30000
  assert_eq(2000, net_profit)      // 30000 - 28000 = 2000
  assert_eq(7, roi_percentage)     // 2000*100/28000 â‰ˆ 7.14 â‰ˆ 7 (æ•´æ•°é™¤æ³•)
  
  // éªŒè¯é¡¹ç›®æ˜¯å¦ç›ˆåˆ©
  azimuth::assert_true(net_profit > 0)
  
  // æµ‹è¯•é¡¹ç›®æŠ¥å‘Šç”Ÿæˆ
  let project_name = "MoonBit Project"
  let report = azimuth::greet(project_name)
  assert_eq_string("Hello, MoonBit Project!", report)
}