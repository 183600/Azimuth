// é¢å¤–çš„ç»¼åˆæµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“çš„é«˜çº§æµ‹è¯•
// åŒ…å«å®é™…åº”ç”¨åœºæ™¯ã€è¾¹ç•Œæ¡ä»¶å’Œå¤åˆè¿ç®—æµ‹è¯•

test "data_processing_aggregation" {
  // æ•°æ®å¤„ç†èšåˆæµ‹è¯•
  let data_points = [10, 15, 20, 25, 30]
  let sum = add(add(add(add(data_points[0], data_points[1]), data_points[2]), data_points[3]), data_points[4])
  let average = divide_with_ceil(sum, 5)
  let max_value = 30
  
  assert_eq(100, sum)
  assert_eq(20, average)
  assert_eq(30, max_value)
}

test "algorithm_binary_search_simulation" {
  // æ¨¡æ‹ŸäºŒåˆ†æŸ¥æ‰¾ç®—æ³•çš„ç´¢å¼•è®¡ç®—
  let low = 0
  let high = 15
  let mid = divide_with_ceil(add(low, high), 2)
  
  assert_eq(8, mid)
  
  // æ¨¡æ‹Ÿä¸‹ä¸€æ­¥æŸ¥æ‰¾èŒƒå›´
  let new_low = add(mid, 1)
  let new_mid = divide_with_ceil(add(new_low, high), 2)
  
  assert_eq(12, new_mid)
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let rate_percent = 5
  let years = 3
  
  // ç¬¬ä¸€å¹´
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  // ç¬¬äºŒå¹´
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  // ç¬¬ä¸‰å¹´
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(10500, year1)
  assert_eq(11025, year2)
  assert_eq(11576, year3)
}

test "extreme_boundary_conditions" {
  // æç«¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  let max_positive = 2147483647
  let min_negative = -2147483648
  
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(1, add(max_positive, -max_positive))
  assert_eq(-1, add(min_negative, max_positive))
  
  // æµ‹è¯•é›¶çš„è¾¹ç•Œ
  assert_eq(0, multiply(0, max_positive))
  assert_eq(0, multiply(min_negative, 0))
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 100
  let project_requirements = [15, 25, 30, 20]
  
  // è®¡ç®—æ€»éœ€æ±‚
  let total_required = add(add(add(project_requirements[0], project_requirements[1]), project_requirements[2]), project_requirements[3])
  
  // è®¡ç®—å‰©ä½™èµ„æº
  let remaining = add(total_resources, -total_required)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„é¢å¤–é¡¹ç›®æ•°ï¼ˆæ¯ä¸ªé¡¹ç›®éœ€è¦10ä¸ªèµ„æºï¼‰
  let additional_projects = divide_with_ceil(remaining, 10)
  
  assert_eq(90, total_required)
  assert_eq(10, remaining)
  assert_eq(1, additional_projects)
}

test "error_robustness_validation" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§éªŒè¯
  // æµ‹è¯•é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•æå¤§æ•°è¿ç®—çš„ç¨³å®šæ€§
  let large_num = 1000000
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(1000000000000, multiply(large_num, large_num))
}

test "string_processing_validation" {
  // å­—ç¬¦ä¸²å¤„ç†éªŒè¯æµ‹è¯•
  let username = "user123"
  let domain = "example.com"
  let email = username + "@" + domain
  let greeting = greet(email)
  
  assert_eq_string("Hello, user123@example.com!", greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let special_chars = "!@#$%^&*()"
  assert_eq_string("Hello, !@#$%^&*()!", greet(special_chars))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_text = "ğŸš€ MoonBit æµ‹è¯•"
  assert_eq_string("Hello, ğŸš€ MoonBit æµ‹è¯•!", greet(unicode_text))
}

test "complex_mathematical_series" {
  // å¤æ‚æ•°å­¦çº§æ•°è®¡ç®—
  // è®¡ç®—ç­‰å·®æ•°åˆ—ï¼š3, 7, 11, 15, 19 çš„å’Œ
  let a1 = 3
  let d = 4
  let n = 5
  
  // ä½¿ç”¨ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼ï¼šS = n/2 * (2a1 + (n-1)d)
  let sum_formula = divide_with_ceil(
    multiply(n, add(multiply(2, a1), multiply(n - 1, d))),
    2
  )
  
  // éªŒè¯ç»“æœ
  assert_eq(55, sum_formula)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—ï¼š2, 4, 8, 16 çš„å’Œ
  let g1 = 2
  let r = 2
  let gn = 4
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼šS = g1 * (r^n - 1) / (r - 1)
  let geometric_sum = multiply(g1, divide_with_ceil(multiply(r, gn) - 1, r - 1))
  assert_eq(30, geometric_sum)
}