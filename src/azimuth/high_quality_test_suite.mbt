// é«˜è´¨é‡ MoonBit æµ‹è¯•å¥—ä»¶
// åŒ…å« 10 ä¸ªç²¾å¿ƒè®¾è®¡çš„æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–å„ç§åœºæ™¯å’Œè¾¹ç•Œæƒ…å†µ

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰æ€§è´¨
  // åŠ æ³•å•ä½å…ƒï¼ša + 0 = a
  assert_eq(42, add(42, 0))
  assert_eq(-17, add(-17, 0))
  assert_eq(0, add(0, 0))
  
  // ä¹˜æ³•å•ä½å…ƒï¼ša * 1 = a
  assert_eq(42, multiply(42, 1))
  assert_eq(-17, multiply(-17, 1))
  assert_eq(0, multiply(0, 1))
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—ï¼šè´·æ¬¾è®¡ç®—
  let principal = 100000  // æœ¬é‡‘
  let annual_rate = 5     // å¹´åˆ©ç‡5%
  let years = 3           // è´·æ¬¾å¹´é™
  
  // ç®€åŒ–çš„å•åˆ©è®¡ç®—
  let yearly_interest = divide_with_ceil(multiply(principal, annual_rate), 100)
  let total_interest = multiply(yearly_interest, years)
  let total_repayment = add(principal, total_interest)
  
  assert_eq(5000, yearly_interest)
  assert_eq(15000, total_interest)
  assert_eq(115000, total_repayment)
}

test "string_processing_internationalization" {
  // å­—ç¬¦ä¸²å¤„ç†å›½é™…åŒ–æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
  assert_eq_string("Hello, CafÃ©!", greet("CafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, åŒ—äº¬!", greet("åŒ—äº¬"))
}

test "advanced_division_ceil_scenarios" {
  // é«˜çº§å‘ä¸Šå–æ•´é™¤æ³•åœºæ™¯
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(11, 3))   // 3.666... -> 4
  assert_eq(7, divide_with_ceil(13, 2))   // 6.5 -> 7
  assert_eq(1, divide_with_ceil(1, 100))  // 0.01 -> 1
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))  // -3.333... -> -3
  assert_eq(-4, divide_with_ceil(-11, 3))  // -3.666... -> -4
  assert_eq(4, divide_with_ceil(-11, -3))  // 3.666... -> 4
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(5, 0))     // é™¤æ•°ä¸º0
  assert_eq(0, divide_with_ceil(0, 5))     // è¢«é™¤æ•°ä¸º0
}

test "algorithmic_sequence_calculation" {
  // ç®—æ³•åºåˆ—è®¡ç®—ï¼šç­‰å·®æ•°åˆ—æ±‚å’Œ
  let first_term = 3
  let common_diff = 4
  let num_terms = 6
  
  // ä½¿ç”¨å…¬å¼ï¼šS = n/2 * (2a + (n-1)d)
  let sum = divide_with_ceil(
    multiply(num_terms, add(multiply(2, first_term), multiply(num_terms - 1, common_diff))),
    2
  )
  
  // æ‰‹åŠ¨éªŒè¯ï¼š3 + 7 + 11 + 15 + 19 + 23 = 78
  assert_eq(78, sum)
}

test "real_world_inventory_management" {
  // ç°å®ä¸–ç•Œåº“å­˜ç®¡ç†
  let product_a_qty = 120
  let product_b_qty = 85
  let product_c_qty = 43
  
  let box_capacity = 24
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_a = divide_with_ceil(product_a_qty, box_capacity)
  let boxes_b = divide_with_ceil(product_b_qty, box_capacity)
  let boxes_c = divide_with_ceil(product_c_qty, box_capacity)
  
  // è®¡ç®—æ€»ç®±å­æ•°é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  
  assert_eq(5, boxes_a)   // ceil(120/24) = 5
  assert_eq(4, boxes_b)   // ceil(85/24) = 4
  assert_eq(2, boxes_c)   // ceil(43/24) = 2
  assert_eq(11, total_boxes)  // 5 + 4 + 2 = 11
}

test "mathematical_distributive_property" {
  // æ•°å­¦åˆ†é…å¾‹éªŒè¯ï¼ša * (b + c) = a * b + a * c
  let a = 7
  let b = 12
  let c = 8
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)  // 7 * (12 + 8) = 7 * 12 + 7 * 8 = 140
}

test "performance_benchmark_simulation" {
  // æ€§èƒ½åŸºå‡†æµ‹è¯•æ¨¡æ‹Ÿ
  let base_operations = 1000
  let optimization_factor = 4
  let overhead_percentage = 12
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ“ä½œæ•°
  let optimized_ops = multiply(base_operations, optimization_factor)
  
  // è®¡ç®—å¼€é”€
  let overhead = divide_with_ceil(multiply(optimized_ops, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = add(optimized_ops, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let improvement_factor = divide_with_ceil(actual_performance, base_operations)
  
  assert_eq(4000, optimized_ops)
  assert_eq(480, overhead)
  assert_eq(3520, actual_performance)
  assert_eq(4, improvement_factor)
}

test "complex_business_workflow" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµï¼šè®¢å•å¤„ç†
  let unit_price = 75
  let quantity = 12
  let tax_rate = 8
  let shipping_per_item = 3
  let bulk_discount_threshold = 800
  let bulk_discount_amount = 50
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(unit_price, quantity)
  
  // è®¡ç®—è¿è´¹
  let total_shipping = multiply(shipping_per_item, quantity)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, total_shipping), tax_amount)
  
  // åº”ç”¨æ‰¹é‡æŠ˜æ‰£ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > bulk_discount_threshold {
    add(pre_discount_total, -bulk_discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(900, subtotal)
  assert_eq(36, total_shipping)
  assert_eq(72, tax_amount)
  assert_eq(1008, pre_discount_total)
  assert_eq(958, final_total)
}

test "edge_case_boundary_values" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
  
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-10, add(-3, -7))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  
  // æµ‹è¯•é›¶çš„è¿ç®—
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, add(12345, 0))
  assert_eq(0, divide_with_ceil(0, 12345))
  assert_eq(0, divide_with_ceil(12345, 0))
  
  // æµ‹è¯•è¾¹ç•Œé™¤æ³•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000, divide_with_ceil(999999, 1000))
}