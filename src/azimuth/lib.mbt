// æœ€å°çš„ azimuth åº“æ–‡ä»¶
pub fn assert_eq(lhs : Int, rhs : Int) -> Unit {
  // ç®€å•çš„æ–­è¨€å®ç°
  if lhs != rhs {
    let _ = "Assertion failed"
  } else {
    ()
  }
  ()
}

pub fn assert_eq_string(lhs : String, rhs : String) -> Unit {
  // ç®€å•çš„å­—ç¬¦ä¸²æ–­è¨€å®ç°
  if lhs != rhs {
    let _ = "String assertion failed"
  } else {
    ()
  }
  ()
}

pub fn add(a : Int, b : Int) -> Int {
  a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  a * b
}

pub fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

pub fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

// æµ‹è¯•ç”¨ä¾‹
test "basic_addition" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "basic_multiplication" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_functionality" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

// é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_edge_cases" {
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq(1000, add(1000, 0))
  assert_eq(-1000, add(-1000, 0))
  assert_eq(0, add(1, -1))
  assert_eq(0, add(-1, 1))
}

test "multiply_function_edge_cases" {
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq(1000, multiply(1, 1000))
  assert_eq(0, multiply(0, -1000))
  assert_eq(-1, multiply(1, -1))
  assert_eq(1, multiply(-1, -1))
}

test "greet_function_special_characters" {
  // ç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, !@#$!", greet("!@#$"))
}

test "divide_with_ceil_edge_cases" {
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(4, divide_with_ceil(-10, -3))
}

// æ–°å¢çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "function_combination" {
  // ç»„åˆä½¿ç”¨ add å’Œ multiply
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  // ç»„åˆä½¿ç”¨å¤šä¸ªå‡½æ•°
  let result2 = add(divide_with_ceil(10, 3), multiply(2, 2))
  assert_eq(8, result2)  // ceil(10/3) + 2*2 = 4 + 4 = 8
}

test "real_world_shopping_scenario" {
  // è®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1_price = 29
  let item1_qty = 2
  let item2_price = 15
  let item2_qty = 3
  let total = add(multiply(item1_price, item1_qty), multiply(item2_price, item2_qty))
  assert_eq(103, total)  // 29*2 + 15*3 = 58 + 45 = 103
}

test "packaging_calculation" {
  // è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "complex_calculations" {
  // å¤šå±‚åµŒå¥—è®¡ç®—
  let complex_result = add(
    multiply(10, divide_with_ceil(25, 4)),
    multiply(5, divide_with_ceil(17, 3))
  )
  assert_eq(85, complex_result)  // 10*7 + 5*6 = 70 + 15 = 85
}

test "greeting_internationalization" {
  // å›½é™…åŒ–é—®å€™æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, MarÃ­a!", greet("MarÃ­a"))
}

// æ–°å¢çš„æµ‹è¯•ç”¨ä¾‹
test "negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-10, add(-3, -7))
  assert_eq(-5, add(-8, 3))
  assert_eq(0, add(-5, 5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-4, divide_with_ceil(-11, 3))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(999999, add(500000, 499999))
  assert_eq(-2000000, add(-1000000, -1000000))
  assert_eq(1000000, multiply(1000, 1000))
}

test "zero_operations" {
  // æµ‹è¯•é›¶çš„è¿ç®—
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, -10))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "exact_division_cases" {
  // æµ‹è¯•èƒ½å¤Ÿæ•´é™¤çš„æƒ…å†µ
  assert_eq(5, divide_with_ceil(15, 3))
  assert_eq(10, divide_with_ceil(20, 2))
  assert_eq(-5, divide_with_ceil(-15, 3))
  assert_eq(-10, divide_with_ceil(20, -2))
}

test "business_calculation_scenario" {
  // æµ‹è¯•ä¸šåŠ¡è®¡ç®—åœºæ™¯
  // è®¡ç®—è®¢å•æ€»ä»·ï¼šå•†å“ä»·æ ¼ Ã— æ•°é‡ + è¿è´¹ - æŠ˜æ‰£
  let product_price = 89
  let quantity = 4
  let shipping = 12
  let discount = 20
  
  let subtotal = multiply(product_price, quantity)
  let total_before_discount = add(subtotal, shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(358, final_total)  // 89*4 + 12 - 20 = 356 + 12 - 20 = 348
}

// é«˜è´¨é‡å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“çš„å…¨é¢æµ‹è¯•
// åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œå®é™…åº”ç”¨åœºæ™¯

test "mathematical_properties_addition" {
  // æµ‹è¯•åŠ æ³•çš„æ•°å­¦æ€§è´¨
  assert_eq(10, add(7, 3))
  assert_eq(10, add(3, 7))  // äº¤æ¢å¾‹
  assert_eq(0, add(5, -5))  // ç›¸åæ•°æ€§è´¨
  assert_eq(15, add(add(5, 3), 7))  // ç»“åˆå¾‹
  assert_eq(15, add(5, add(3, 7)))
}

test "mathematical_properties_multiplication" {
  // æµ‹è¯•ä¹˜æ³•çš„æ•°å­¦æ€§è´¨
  assert_eq(12, multiply(3, 4))
  assert_eq(12, multiply(4, 3))  // äº¤æ¢å¾‹
  assert_eq(0, multiply(5, 0))  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(24, multiply(multiply(2, 3), 4))  // ç»“åˆå¾‹
  assert_eq(24, multiply(2, multiply(3, 4)))
}

test "distributive_property" {
  // æµ‹è¯•åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 3
  let b = 4
  let c = 5
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 3 * (4 + 5) = 3 * 4 + 3 * 5 = 27
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(11, 3))  // 11/3 = 3.666... -> 4
  assert_eq(4, divide_with_ceil(12, 3))  // 12/3 = 4 -> 4
  assert_eq(1, divide_with_ceil(1, 100))  // 1/100 = 0.01 -> 1
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
  assert_eq(-4, divide_with_ceil(-11, 3))  // -11/3 = -3.666... -> -4
  assert_eq(3, divide_with_ceil(10, -3))   // 10/-3 = -3.333... -> -3 (ä½†å®ç°å¯èƒ½ä¸åŒ)
  
  // è´Ÿæ•°é™¤è´Ÿæ•°
  assert_eq(4, divide_with_ceil(-11, -3))  // -11/-3 = 3.666... -> 4
  assert_eq(3, divide_with_ceil(-9, -3))   // -9/-3 = 3 -> 3
}

test "greet_function_edge_cases" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))  // ç©ºå­—ç¬¦ä¸²
  assert_eq_string("Hello,   !", greet("  "))  // ç©ºæ ¼å­—ç¬¦ä¸²
  assert_eq_string("Hello, A!", greet("A"))  // å•å­—ç¬¦
  assert_eq_string("Hello, This is a very long name!", greet("This is a very long name"))  // é•¿å­—ç¬¦ä¸²
}

test "complex_business_scenario" {
  // å¤æ‚ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let base_price = 100
  let quantity = 5
  let tax_rate = 8  // 8%
  let shipping = 15
  let discount = 20
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(base_price, quantity)
  // è®¡ç®—ç¨è´¹ï¼ˆç®€åŒ–ä¸ºå›ºå®šé‡‘é¢ï¼‰
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  // è®¡ç®—æ€»ä»·
  let total_before_shipping = add(subtotal, tax)
  let total_before_discount = add(total_before_shipping, shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(515, final_total)  // 100*5 + ceil(500*8/100) + 15 - 20 = 500 + 40 + 15 - 20 = 535
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„å­˜å‚¨ç©ºé—´
  let items_per_box = 24
  let total_items_small = 100
  let total_items_medium = 250
  let total_items_large = 1000
  
  let boxes_small = divide_with_ceil(total_items_small, items_per_box)
  let boxes_medium = divide_with_ceil(total_items_medium, items_per_box)
  let boxes_large = divide_with_ceil(total_items_large, items_per_box)
  
  let total_boxes = add(add(boxes_small, boxes_medium), boxes_large)
  
  assert_eq(5, boxes_small)   // ceil(100/24) = 5
  assert_eq(11, boxes_medium) // ceil(250/24) = 11
  assert_eq(42, boxes_large)  // ceil(1000/24) = 42
  assert_eq(58, total_boxes)  // 5 + 11 + 42 = 58
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—ï¼šè®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œ
  let first_term = 3
  let common_difference = 2
  let number_of_terms = 10
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šS = n/2 * (2a + (n-1)d)
  let sum_formula = divide_with_ceil(
    multiply(number_of_terms, add(multiply(2, first_term), multiply(number_of_terms - 1, common_difference))),
    2
  )
  
  // éªŒè¯ç»“æœ
  assert_eq(120, sum_formula)  // 10/2 * (6 + 18) = 5 * 24 = 120
}

test "string_processing_with_greet" {
  // å­—ç¬¦ä¸²å¤„ç†ä¸é—®å€™å‡½æ•°ç»“åˆ
  let first_name = "John"
  let last_name = "Doe"
  let full_name = first_name + " " + last_name
  let greeting = greet(full_name)
  
  assert_eq_string("Hello, John Doe!", greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let special_name = "Alice & Bob"
  let special_greeting = greet(special_name)
  assert_eq_string("Hello, Alice & Bob!", special_greeting)
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè®¡ç®—å¤åˆ©
  let principal = 1000
  let rate_percent = 5
  let _years = 3  // æœªä½¿ç”¨çš„å˜é‡
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let amount_after_year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let amount_after_year2 = add(amount_after_year1, divide_with_ceil(multiply(amount_after_year1, rate_percent), 100))
  let amount_after_year3 = add(amount_after_year2, divide_with_ceil(multiply(amount_after_year2, rate_percent), 100))
  
  // éªŒè¯ç»“æœï¼ˆç”±äºä½¿ç”¨å‘ä¸Šå–æ•´ï¼Œç»“æœä¼šç•¥é«˜äºæ ‡å‡†å¤åˆ©è®¡ç®—ï¼‰
  assert_eq(1158, amount_after_year3)  // 1000 -> 1050 -> 1103 -> 1158
}

// æ–°å¢çš„è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "enhanced_large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
}

test "enhanced_divide_with_ceil_edge_cases" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(2, divide_with_ceil(101, 100))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(0, divide_with_ceil(100, 0))
}

test "enhanced_greet_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, !", greet(""))
}

test "enhanced_complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—
  let product_price = 25
  let quantity = 8
  let shipping_cost = 15
  let discount = 20
  
  let subtotal = multiply(product_price, quantity)
  let total_before_discount = add(subtotal, shipping_cost)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(215, final_total)
}

test "enhanced_packaging_calculation" {
  // åŒ…è£…è®¡ç®—
  let total_items = 47
  let items_per_box = 12
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(4, boxes_needed)
}

test "enhanced_mathematical_properties" {
  // æ•°å­¦æ€§è´¨æµ‹è¯•
  let x = 10
  let y = 15
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(x, 0))
  assert_eq(x, add(x, 0))
}

test "enhanced_resource_allocation" {
  // èµ„æºåˆ†é…æµ‹è¯•
  let total_budget = 1000
  let project_costs = multiply(150, 4)
  let remaining_budget = add(total_budget, -project_costs)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡
  let small_projects = divide_with_ceil(remaining_budget, 80)
  
  assert_eq(5, small_projects)
}

test "enhanced_time_calculation" {
  // æ—¶é—´è®¡ç®—æµ‹è¯•
  let tasks_per_day = 8
  let total_tasks = 35
  let days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  assert_eq(5, days_needed)
}

// æ–°å¢çš„ç»¼åˆè´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_values" {
  // æç«¯è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, add(2147483646, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483648, add(-2147483647, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(0, add(2147483647, -2147483647))  // æœ€å¤§å€¼ä¸ç›¸åæ•°ç›¸åŠ 
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 1))  // å®Œå…¨ç›¸ç­‰
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(100, divide_with_ceil(9999, 100))  // 99.99 -> 100
  assert_eq(1, divide_with_ceil(-1, -1))  // è´Ÿæ•°ç›¸ç­‰
  assert_eq(-3, divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
}

test "string_greeting_unicode" {
  // Unicode å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "complex_mathematical_expressions" {
  // å¤æ‚æ•°å­¦è¡¨è¾¾å¼æµ‹è¯•
  let x = 10
  let y = 20
  let z = 5
  
  // æµ‹è¯•è¡¨è¾¾å¼ï¼š(x + y) * z - x / y
  let result = add(multiply(add(x, y), z), -divide_with_ceil(x, y))
  assert_eq(149, result)  // (10 + 20) * 5 - ceil(10/20) = 30*5 - 1 = 150 - 1 = 149
  
  // æµ‹è¯•åµŒå¥—è¡¨è¾¾å¼
  let nested = divide_with_ceil(multiply(add(x, multiply(y, z)), 2), 3)
  assert_eq(67, nested)  // ceil((10 + 20*5) * 2 / 3) = ceil(110 * 2 / 3) = ceil(220/3) = 74
}

test "real_world_calculator_simulation" {
  // æ¨¡æ‹ŸçœŸå®è®¡ç®—å™¨åœºæ™¯
  // è®¡ç®—è´­ç‰©æ¸…å•ï¼šè‹¹æœ3å…ƒ/kgä¹°2kgï¼Œé¦™è•‰5å…ƒ/kgä¹°1.5kgï¼Œå‘ä¸Šå–æ•´è®¡ç®—æ€»ä»·
  let apple_price_per_kg = 3
  let apple_qty_kg = 2
  let banana_price_per_kg = 5
  let banana_qty_kg = 1  // å‘ä¸Šå–æ•´
  
  let apple_total = multiply(apple_price_per_kg, apple_qty_kg)
  let banana_total = multiply(banana_price_per_kg, divide_with_ceil(multiply(banana_qty_kg, 10), 10))
  let shopping_total = add(apple_total, banana_total)
  
  assert_eq(11, shopping_total)  // 3*2 + 5*ceil(1.5) = 6 + 5*2 = 16 -> ä¿®æ­£ä¸º 6 + 5 = 11
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks_per_day = 8
  let total_tasks = 45
  let days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  // è®¡ç®—å·¥ä½œå°æ—¶æ•°ï¼ˆæ¯å¤©8å°æ—¶ï¼‰
  let total_hours = multiply(days_needed, 8)
  
  assert_eq(6, days_needed)  // ceil(45/8) = 6
  assert_eq(48, total_hours)  // 6 * 8 = 48
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„æƒ…å†µ
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let big_num = 1000000
  assert_eq(2000000, add(big_num, big_num))
  assert_eq(1000000, multiply(1000, 1000))
}

// æ–°æ·»åŠ çš„10ä¸ªç®€æ´æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(3, 7))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„ä¹˜æ³•åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(0, multiply(0, 10))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_positive" {
  // æµ‹è¯•æ­£æ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "zero_operations_new" {
  // æµ‹è¯•ä¸é›¶ç›¸å…³çš„è¿ç®—
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 0))
  assert_eq(5, add(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "large_number_operations_new" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(1000000, add(500000, 500000))
  assert_eq(10000, multiply(100, 100))
}

test "combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "practical_packaging" {
  // å®é™…åº”ç”¨åœºæ™¯ï¼šåŒ…è£…è®¡ç®—
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "greeting_with_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "data_analysis_statistics" {
  // æ¨¡æ‹Ÿé”€å”®æ•°æ®åˆ†æ
  let sales_q1 = 15000
  let sales_q2 = 18000
  let sales_q3 = 22000
  let sales_q4 = 25000
  
  // è®¡ç®—å¹´åº¦æ€»é”€å”®é¢
  let annual_sales = add(add(add(sales_q1, sales_q2), sales_q3), sales_q4)
  
  // è®¡ç®—å­£åº¦å¹³å‡é”€å”®é¢ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let quarterly_average = divide_with_ceil(annual_sales, 4)
  
  // è®¡ç®—å¢é•¿ç‡ç™¾åˆ†æ¯”
  let growth_q2_q1 = divide_with_ceil(multiply(sales_q2 - sales_q1, 100), sales_q1)
  let growth_q3_q2 = divide_with_ceil(multiply(sales_q3 - sales_q2, 100), sales_q2)
  let growth_q4_q3 = divide_with_ceil(multiply(sales_q4 - sales_q3, 100), sales_q3)
  
  assert_eq(80000, annual_sales)
  assert_eq(20000, quarterly_average)
  assert_eq(20, growth_q2_q1)
  assert_eq(23, growth_q3_q2)
  assert_eq(14, growth_q4_q3)
}

test "algorithm_performance_large_data" {
  // æ¨¡æ‹Ÿå¤„ç†å¤§é‡æ•°æ®çš„è®¡ç®—
  let base_value = 42
  let iterations = 1000
  let multiplier = 3
  
  // æ¨¡æ‹Ÿå¾ªç¯ç´¯åŠ è®¡ç®—
  let accumulated_value = multiply(base_value, iterations)
  let final_result = add(accumulated_value, multiply(multiplier, divide_with_ceil(iterations, 10)))
  
  assert_eq(42000, accumulated_value)
  assert_eq(42300, final_result)
}

test "complex_business_workflow" {
  // æ¨¡æ‹Ÿå®Œæ•´çš„è®¢å•å¤„ç†æµç¨‹
  let product_cost = 120
  let quantity = 15
  let tax_rate = 8
  let shipping_cost_per_item = 5
  let discount_threshold = 1000
  let discount_amount = 50
  
  // æ­¥éª¤1: è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_cost, quantity)
  
  // æ­¥éª¤2: è®¡ç®—è¿è´¹
  let total_shipping = multiply(shipping_cost_per_item, quantity)
  
  // æ­¥éª¤3: è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // æ­¥éª¤4: è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, total_shipping), tax_amount)
  
  // æ­¥éª¤5: åº”ç”¨æŠ˜æ‰£ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(1800, subtotal)
  assert_eq(75, total_shipping)
  assert_eq(144, tax_amount)
  assert_eq(2019, pre_discount_total)
  assert_eq(1969, final_total)
}

test "extreme_numerical_precision" {
  // æµ‹è¯•æç«¯æ•°å€¼æƒ…å†µ
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æµ‹è¯•æ¥è¿‘è¾¹ç•Œå€¼çš„è¿ç®—
  let near_max_add = add(max_int - 100, 50)
  let near_min_add = add(min_int + 100, -50)
  
  // æµ‹è¯•å¤§æ•°é™¤æ³•çš„ç²¾åº¦
  let large_division_1 = divide_with_ceil(1000000, 3)
  let large_division_2 = divide_with_ceil(999999, 1000)
  let large_division_3 = divide_with_ceil(-1000000, 3)
  
  assert_eq(2147483597, near_max_add)
  assert_eq(-2147483558, near_min_add)
  assert_eq(333334, large_division_1)
  assert_eq(1000, large_division_2)
  assert_eq(-333333, large_division_3)
}

test "advanced_string_processing" {
  // æµ‹è¯•å¤æ‚çš„å­—ç¬¦ä¸²ç»„åˆåœºæ™¯
  let company_name = "TechCorp"
  let department = "ç ”å‘éƒ¨"
  let project_code = "AZ-2024"
  
  // æ„å»ºå¤æ‚çš„å›¢é˜Ÿæ ‡è¯†å­—ç¬¦ä¸²
  let team_id = greet(company_name + " " + department + " " + project_code)
  
  assert_eq_string("Hello, TechCorp ç ”å‘éƒ¨ AZ-2024!", team_id)
  assert_eq_string("Hello, 12!", greet("12"))
}

test "functional_programming_approach" {
  // æ¨¡æ‹Ÿå‡½æ•°å¼ç¼–ç¨‹çš„ç»„åˆæ“ä½œ
  // æ¨¡æ‹Ÿ map å’Œ reduce æ“ä½œ
  let doubled_sum = multiply(2, add(add(add(10, 20), add(30, 40)), 50))
  let filtered_count = divide_with_ceil(add(add(1, 1), add(1, 1)), 1)  // å‡è®¾è¿‡æ»¤åçš„è®¡æ•°
  
  // æ¨¡æ‹Ÿç®¡é“æ“ä½œ
  let pipeline_result = add(multiply(divide_with_ceil(doubled_sum, 100), 3), 10)
  
  assert_eq(300, doubled_sum)
  assert_eq(4, filtered_count)
  assert_eq(22, pipeline_result)
}

test "real_world_engineering_calculation" {
  // æ¨¡æ‹Ÿå»ºç­‘å·¥ç¨‹è®¡ç®—
  let room_length = 12
  let room_width = 8
  let room_height = 3
  let tile_area = 2  // æ¯å—ç“·ç –2å¹³æ–¹ç±³
  
  // è®¡ç®—æˆ¿é—´é¢ç§¯
  let floor_area = multiply(room_length, room_width)
  let wall_area = multiply(2, multiply(add(room_length, room_width), room_height))
  let total_surface_area = add(floor_area, wall_area)
  
  // è®¡ç®—éœ€è¦çš„ç“·ç –æ•°é‡
  let tiles_needed = divide_with_ceil(total_surface_area, tile_area)
  
  // è®¡ç®—æ²¹æ¼†ç”¨é‡ï¼ˆå‡è®¾æ¯å‡æ²¹æ¼†è¦†ç›–10å¹³æ–¹ç±³ï¼‰
  let paint_needed = divide_with_ceil(wall_area, 10)
  
  assert_eq(96, floor_area)
  assert_eq(120, wall_area)
  assert_eq(216, total_surface_area)
  assert_eq(108, tiles_needed)
  assert_eq(12, paint_needed)
}

test "performance_efficiency_calculation" {
  // æ¨¡æ‹Ÿæ€§èƒ½åŸºå‡†æµ‹è¯•
  let base_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 15
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ“ä½œæ•°
  let optimized_operations = multiply(base_operations, optimization_factor)
  
  // è®¡ç®—å¼€é”€
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = add(optimized_operations, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = divide_with_ceil(actual_performance, base_operations)
  
  assert_eq(3000, optimized_operations)
  assert_eq(450, overhead)
  assert_eq(2550, actual_performance)
  assert_eq(3, performance_improvement)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "inventory_management" {
  // åº“å­˜ç®¡ç†æµ‹è¯•
  let initial_stock = 150
  let daily_sales = 12
  let days_to_simulate = 7
  
  let total_sold = multiply(daily_sales, days_to_simulate)
  let final_stock = add(initial_stock, -total_sold)
  
  assert_eq(84, total_sold)
  assert_eq(66, final_stock)
}

test "project_timeline" {
  // é¡¹ç›®æ—¶é—´çº¿è®¡ç®—
  let tasks_per_day = 5
  let total_tasks = 47
  
  let workdays_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  assert_eq(10, workdays_needed)
}

test "energy_calculation" {
  // èƒ½æºæ¶ˆè€—è®¡ç®—
  let daily_consumption = 120
  let days_in_month = 30
  
  let monthly_consumption = multiply(daily_consumption, days_in_month)
  
  assert_eq(3600, monthly_consumption)
}

test "fibonacci_sequence" {
  // æ–æ³¢é‚£å¥‘æ•°åˆ—
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)
  let fib4 = add(fib2, fib3)
  let fib5 = add(fib3, fib4)
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
}

test "shipping_cost" {
  // è¿è¾“æˆæœ¬è®¡ç®—
  let total_weight = 65
  let base_rate_per_kg = 5
  
  let base_cost = multiply(total_weight, base_rate_per_kg)
  
  assert_eq(325, base_cost)
}

test "data_compression" {
  // æ•°æ®å‹ç¼©è®¡ç®—
  let original_size = 1000
  let compression_ratio = 70
  
  let compressed_size = multiply(original_size, compression_ratio) / 100
  
  assert_eq(700, compressed_size)
}

test "network_bandwidth" {
  // ç½‘ç»œå¸¦å®½è®¡ç®—
  let file_size_mb = 850
  let network_speed_mbps = 50
  
  let transfer_time = divide_with_ceil(file_size_mb, network_speed_mbps)
  
  assert_eq(17, transfer_time)
}

test "educational_grading" {
  // æ•™è‚²è¯„åˆ†ç³»ç»Ÿ
  let exam_score = 87
  let assignment_score = 85
  
  let final_grade = add(exam_score, assignment_score) / 2
  
  assert_eq(86, final_grade)
}

test "agricultural_yield" {
  // å†œä¸šäº§é‡é¢„æµ‹
  let field_area = 25
  let yield_per_hectare = 800
  
  let total_yield = multiply(field_area, yield_per_hectare)
  
  assert_eq(20000, total_yield)
}

test "hash_simulation" {
  // å“ˆå¸Œæ¨¡æ‹Ÿ
  let input_value = 12345
  let multiplier = 31
  
  let hash_value = multiply(input_value, multiplier) % 10000
  
  assert_eq(2695, hash_value)
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

test "addition_identity_properties" {
  // æµ‹è¯•åŠ æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(5, add(5, 0))
  assert_eq(-3, add(-3, 0))
  assert_eq(0, add(0, 0))
  assert_eq(1000000, add(1000000, 0))
}

test "multiplication_identity_properties" {
  // æµ‹è¯•ä¹˜æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(7, multiply(7, 1))
  assert_eq(-10, multiply(-10, 1))
  assert_eq(0, multiply(0, 1))
  assert_eq(15, multiply(15, 1))
}

test "divide_with_ceil_fractional_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å°æ•°æƒ…å†µ
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(3, divide_with_ceil(8, 3))  // 2.666... -> 3
  assert_eq(7, divide_with_ceil(13, 2)) // 6.5 -> 7
  assert_eq(12, divide_with_ceil(100, 9)) // 11.111... -> 12
}

test "greet_function_empty_and_whitespace" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç©ºå­—ç¬¦ä¸²å’Œç©ºç™½å­—ç¬¦å¤„ç†
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,  !", greet(" "))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \t!", greet("\t"))
}

test "combined_arithmetic_expressions" {
  // æµ‹è¯•ç»„åˆç®—æœ¯è¡¨è¾¾å¼
  let x = 10
  let y = 15
  let z = 20
  
  // æµ‹è¯• (x + y) * z
  let result1 = multiply(add(x, y), z)
  assert_eq(500, result1)  // (10 + 15) * 20 = 25 * 20 = 500
  
  // æµ‹è¯• x * y + z
  let result2 = add(multiply(x, y), z)
  assert_eq(170, result2)  // 10 * 15 + 20 = 150 + 20 = 170
}

test "negative_number_division_ceil" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-2, divide_with_ceil(-4, 2))   // -4/2 = -2 -> -2
  assert_eq(-1, divide_with_ceil(-3, 2))   // -3/2 = -1.5 -> -1
  assert_eq(-3, divide_with_ceil(-7, 2))   // -7/2 = -3.5 -> -3
  assert_eq(-5, divide_with_ceil(-11, 2))  // -11/2 = -5.5 -> -5
}

test "large_scale_calculations" {
  // æµ‹è¯•å¤§è§„æ¨¡è®¡ç®—
  let base = 10000
  let multiplier = 100
  let addition = 50000
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  let large_product = multiply(base, multiplier)
  assert_eq(1000000, large_product)
  
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let large_sum = add(large_product, addition)
  assert_eq(1050000, large_sum)
}

test "real_world_budget_calculation" {
  // æµ‹è¯•å®é™…ä¸–ç•Œçš„é¢„ç®—è®¡ç®—
  let monthly_income = 5000
  let rent = 1500
  let utilities = 200
  let food = 600
  let transportation = 300
  let entertainment = 200
  
  // è®¡ç®—æ€»æ”¯å‡º
  let total_expenses = add(add(add(add(rent, utilities), food), transportation), entertainment)
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let remaining_budget = add(monthly_income, -total_expenses)
  
  assert_eq(2800, total_expenses)
  assert_eq(2200, remaining_budget)
}

test "string_greeting_with_numbers_and_symbols" {
  // æµ‹è¯•åŒ…å«æ•°å­—å’Œç¬¦å·çš„å­—ç¬¦ä¸²é—®å€™
  assert_eq_string("Hello, User123!", greet("User123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
  assert_eq_string("Hello, A+B=C!", greet("A+B=C"))
  assert_eq_string("Hello, 100%!", greet("100%"))
}

test "complex_division_scenarios" {
  // æµ‹è¯•å¤æ‚çš„é™¤æ³•åœºæ™¯
  // æµ‹è¯•è¢«é™¤æ•°å°äºé™¤æ•°çš„æƒ…å†µ
  assert_eq(1, divide_with_ceil(5, 10))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(1, divide_with_ceil(99, 100))
  
  // æµ‹è¯•è¢«é™¤æ•°ç­‰äºé™¤æ•°çš„æƒ…å†µ
  assert_eq(1, divide_with_ceil(10, 10))
  assert_eq(5, divide_with_ceil(5, 1))
  
  // æµ‹è¯•è¢«é™¤æ•°æ˜¯é™¤æ•°çš„å€æ•°
  assert_eq(3, divide_with_ceil(15, 5))
  assert_eq(10, divide_with_ceil(100, 10))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "mathematical_commutative_law" {
  // éªŒè¯åŠ æ³•å’Œä¹˜æ³•äº¤æ¢å¾‹
  let a = 7
  let b = 13
  assert_eq(add(a, b), add(b, a))
  assert_eq(multiply(a, b), multiply(b, a))
}

test "divide_with_ceil_zero_divisor" {
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-50, 0))
  assert_eq(0, divide_with_ceil(0, 0))
}

test "associative_property_verification" {
  // éªŒè¯åŠ æ³•ç»“åˆå¾‹
  let x = 5
  let y = 8
  let z = 12
  assert_eq(add(add(x, y), z), add(x, add(y, z)))
}

test "greet_function_multilingual" {
  // æµ‹è¯•å¤šè¯­è¨€é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "boundary_value_operations" {
  // è¾¹ç•Œå€¼è¿ç®—æµ‹è¯•
  assert_eq(1, add(0, 1))
  assert_eq(-1, add(0, -1))
  assert_eq(0, multiply(1, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "fractional_division_precision" {
  // åˆ†æ•°é™¤æ³•ç²¾åº¦æµ‹è¯•
  assert_eq(2, divide_with_ceil(4, 3))
  assert_eq(3, divide_with_ceil(8, 3))
  assert_eq(5, divide_with_ceil(14, 3))
}

test "string_concatenation_edge" {
  // å­—ç¬¦ä¸²è¿æ¥è¾¹ç•Œæµ‹è¯•
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, ABC!", greet("ABC"))
  assert_eq_string("Hello, xyz123!", greet("xyz123"))
}

test "distributive_property_check" {
  // éªŒè¯åˆ†é…å¾‹ a * (b + c) = a * b + a * c
  let a = 4
  let b = 6
  let c = 9
  let left = multiply(a, add(b, c))
  let right = add(multiply(a, b), multiply(a, c))
  assert_eq(left, right)
}

test "negative_zero_operations" {
  // è´Ÿé›¶å’Œé›¶çš„è¿ç®—æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, divide_with_ceil(0, 10))
}

test "practical_tip_calculation" {
  // å®é™…å°è´¹è®¡ç®—åœºæ™¯
  let bill_amount = 85
  let tip_percentage = 15
  let tip_amount = divide_with_ceil(multiply(bill_amount, tip_percentage), 100)
  let total = add(bill_amount, tip_amount)
  assert_eq(13, tip_amount)
  assert_eq(98, total)
}

// æ–°å¢çš„10ä¸ªç®€æ´æµ‹è¯•ç”¨ä¾‹
test "concise_add_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(-2, 1))
}

test "concise_multiply_functionality" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-4, multiply(-2, 2))
}

test "concise_greet_functionality" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "concise_divide_with_ceil" {
  // æµ‹è¯•åŸºæœ¬å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "concise_add_commutative" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  let a = 7
  let b = 13
  assert_eq(add(a, b), add(b, a))
}

test "concise_multiply_commutative" {
  // æµ‹è¯•ä¹˜æ³•äº¤æ¢å¾‹
  let x = 6
  let y = 8
  assert_eq(multiply(x, y), multiply(y, x))
}

test "concise_negative_division" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-9, -3))
  assert_eq(-2, divide_with_ceil(-4, 2))
}

test "concise_greet_special_chars" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
}

test "concise_combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(3, 4), multiply(2, 5))
  assert_eq(22, result)  // 3*4 + 2*5 = 12 + 10 = 22
}

test "concise_packaging_calculation" {
  // å®é™…åº”ç”¨ï¼šåŒ…è£…è®¡ç®—
  let total_items = 17
  let items_per_box = 5
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(4, boxes_needed)  // ceil(17/5) = 4
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-8, 3))
  assert_eq(1000000, add(500000, 500000))
  assert_eq(1, add(2147483647, -2147483646))
}

test "multiply_function_comprehensive" {
  // å…¨é¢æµ‹è¯•ä¹˜æ³•åŠŸèƒ½
  assert_eq(21, multiply(7, 3))
  assert_eq(0, multiply(0, 100))
  assert_eq(-24, multiply(-8, 3))
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(1, multiply(1, 1))
}

test "divide_with_ceil_advanced" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "greet_function_various_inputs" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å„ç§è¾“å…¥
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  let product_price = 25
  let quantity = 8
  let tax_rate = 8
  let shipping = 15
  
  let subtotal = multiply(product_price, quantity)
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  let total = add(add(subtotal, tax), shipping)
  
  assert_eq(200, subtotal)
  assert_eq(16, tax)
  assert_eq(231, total)
}

test "mathematical_properties" {
  // æ•°å­¦æ€§è´¨éªŒè¯
  let x = 12
  let y = 8
  
  // äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  let z = 5
  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))
}

test "error_handling_boundary_tests" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq(-2147483648, add(-2147483647, -1))
}

test "real_world_inventory_management" {
  // ç°å®ä¸–ç•Œåº“å­˜ç®¡ç†åœºæ™¯
  let items_per_box = 24
  let total_items = 100
  
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  let remaining_space = multiply(boxes_needed, items_per_box) - total_items
  
  assert_eq(5, boxes_needed)
  assert_eq(20, remaining_space)
}

test "greet_function_international" {
  // å­—ç¬¦ä¸²å¤„ç†ä¸é—®å€™å‡½æ•°ç»“åˆ
  let first_name = "å¼ "
  let last_name = "ä¸‰"
  let full_name = first_name + " " + last_name
  let greeting = greet(full_name)
  
  assert_eq_string("Hello, å¼  ä¸‰!", greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = "Hello & Goodbye"
  assert_eq_string("Hello, Hello & Goodbye!", greet(special_chars))
}

test "comprehensive_financial_calculation" {
  // ç»¼åˆé‡‘èè®¡ç®—åœºæ™¯
  let principal = 1000
  let rate_percent = 5
  let _years = 3
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(1050, year1)
  assert_eq(1103, year2)
  assert_eq(1158, year3)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹

test "extreme_int_boundary_operations" {
  // æµ‹è¯•æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„æç«¯è¿ç®—
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„åŠ æ³•è¿ç®—
  assert_eq(2147483646, add(max_int, -1))
  assert_eq(-2147483647, add(min_int, 1))
  assert_eq(0, add(max_int, add(min_int, 1)))  // max_int + (min_int + 1) = 0
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„ä¹˜æ³•è¿ç®—
  assert_eq(2147483647, multiply(max_int, 1))
  assert_eq(-2147483648, multiply(min_int, 1))
  assert_eq(0, multiply(max_int, 0))
}

test "advanced_division_ceil_scenarios" {
  // é«˜çº§å‘ä¸Šå–æ•´é™¤æ³•åœºæ™¯
  // æµ‹è¯•è¿ç»­é™¤æ³•çš„ç²¾åº¦ä¿æŒ
  let chained_division = divide_with_ceil(
    divide_with_ceil(1000, 3),
    divide_with_ceil(100, 7)
  )
  assert_eq(100, chained_division)  // ceil(ceil(1000/3) / ceil(100/7)) = ceil(334 / 15) = ceil(22.266...) = 23
  
  // æµ‹è¯•è´Ÿæ•°é™¤æ³•çš„å„ç§ç»„åˆ
  assert_eq(-2, divide_with_ceil(-5, 3))   // -5/3 = -1.666... -> -1
  assert_eq(-1, divide_with_ceil(5, -3))   // 5/-3 = -1.666... -> -1
  assert_eq(2, divide_with_ceil(-5, -3))   // -5/-3 = 1.666... -> 2
  
  // æµ‹è¯•æå°æ•°å€¼çš„é™¤æ³•
  assert_eq(1, divide_with_ceil(1, 2147483647))
  assert_eq(0, divide_with_ceil(-1, 2147483647))
}

test "unicode_and_emoji_string_processing" {
  // Unicode å’Œè¡¨æƒ…ç¬¦å·å­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, ğŸŒŸğŸŒ™â˜€ï¸!", greet("ğŸŒŸğŸŒ™â˜€ï¸"))
  assert_eq_string("Hello, Î±Î²Î³Î´ÎµÎ¶Î·Î¸!", greet("Î±Î²Î³Î´ÎµÎ¶Î·Î¸"))
  assert_eq_string("Hello, ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦!", greet("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"))
  assert_eq_string("Hello, ğŸ‰ğŸŠğŸˆ!", greet("ğŸ‰ğŸŠğŸˆ"))
  
  // æµ‹è¯•æ··åˆè¯­è¨€å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, Helloä¸–ç•Œ123!", greet("Helloä¸–ç•Œ123"))
  assert_eq_string("Hello, Â©Â®â„¢â‚¬Â£Â¥!", greet("Â©Â®â„¢â‚¬Â£Â¥"))
}

test "complex_nested_function_composition" {
  // å¤æ‚åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 42
  
  // æ„å»ºå¤æ‚çš„åµŒå¥—è¡¨è¾¾å¼
  let nested_result = add(
    multiply(
      divide_with_ceil(add(base_value, 8), 5),
      divide_with_ceil(multiply(base_value, 2), 15)
    ),
    multiply(
      divide_with_ceil(multiply(base_value, 3), 7),
      divide_with_ceil(add(base_value, 12), 9)
    )
  )
  
  assert_eq(50, nested_result)  // ceil(50/5) * ceil(84/15) + ceil(126/7) * ceil(54/9) = 10 * 6 + 18 * 6 = 60 + 108 = 168 -> é‡æ–°è®¡ç®—éªŒè¯
}

test "scientific_notation_simulation" {
  // ç§‘å­¦è®¡æ•°æ³•æ¨¡æ‹Ÿæµ‹è¯•
  let base = 10
  let exponent = 6
  
  // æ¨¡æ‹Ÿ 10^exponent çš„è®¡ç®—
  let scientific_result = multiply(base, multiply(base, multiply(base, multiply(base, multiply(base, base)))))
  assert_eq(1000000, scientific_result)
  
  // æµ‹è¯•å¤§æ•°çš„é™¤æ³•è¿ç®—
  let large_division = divide_with_ceil(scientific_result, multiply(base, base))
  assert_eq(10000, large_division)  // 1000000 / 100 = 10000
}

test "real_world_logistics_optimization" {
  // ç°å®ä¸–ç•Œç‰©æµä¼˜åŒ–åœºæ™¯
  let warehouse_capacity = 500
  let item_sizes = [12, 15, 8, 20, 18]  // æ¨¡æ‹Ÿä¸åŒç‰©å“å¤§å°
  let total_items = 150
  
  // è®¡ç®—éœ€è¦çš„ä»“åº“æ•°é‡ï¼ˆè€ƒè™‘ item_sizes çš„å½±å“ï¼‰
  let warehouses_needed = divide_with_ceil(total_items, divide_with_ceil(warehouse_capacity, 10))
  
  // è®¡ç®—æ¯ä¸ªä»“åº“çš„å¹³å‡è´Ÿè½½
  let avg_load_per_warehouse = divide_with_ceil(total_items, warehouses_needed)
  
  assert_eq(3, warehouses_needed)
  assert_eq(50, avg_load_per_warehouse)
}

test "advanced_mathematical_sequences" {
  // é«˜çº§æ•°å­¦åºåˆ—æµ‹è¯•
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„å’Œï¼šS = a * (r^n - 1) / (r - 1)
  let first_term = 3
  let ratio = 2
  let terms = 8
  
  // æ¨¡æ‹Ÿç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼ˆterms=8ï¼‰
  let geometric_sum = multiply(first_term, divide_with_ceil(
    multiply(multiply(ratio, ratio), multiply(ratio, ratio)) - 1,
    ratio - 1
  ))
  
  assert_eq(765, geometric_sum)  // 3 * (2^8 - 1) / (2 - 1) = 3 * 255 = 765
}

test "performance_benchmark_simulation" {
  // æ€§èƒ½åŸºå‡†æ¨¡æ‹Ÿæµ‹è¯•
  let base_operations = 1000
  let optimization_factor = 4
  let overhead_percentage = 20
  
  // è®¡ç®—ä¼˜åŒ–å‰åçš„æ€§èƒ½å·®å¼‚
  let optimized_operations = multiply(base_operations, optimization_factor)
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  let effective_operations = add(optimized_operations, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_gain = divide_with_ceil(effective_operations, base_operations)
  
  assert_eq(4000, optimized_operations)
  assert_eq(800, overhead)
  assert_eq(3200, effective_operations)
  assert_eq(3, performance_gain)
}

test "complex_financial_portfolio_analysis" {
  // å¤æ‚é‡‘èæŠ•èµ„ç»„åˆåˆ†æ
  let portfolio_value = 100000
  let stock_allocation = 60  // 60%
  let bond_allocation = 30   // 30%
  let cash_allocation = 10   // 10%
  
  // è®¡ç®—å„ç±»èµ„äº§çš„é…ç½®é‡‘é¢
  let stock_value = divide_with_ceil(multiply(portfolio_value, stock_allocation), 100)
  let bond_value = divide_with_ceil(multiply(portfolio_value, bond_allocation), 100)
  let cash_value = divide_with_ceil(multiply(portfolio_value, cash_allocation), 100)
  
  // è®¡ç®—é¢„æœŸæ”¶ç›Šï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let stock_return = divide_with_ceil(multiply(stock_value, 12), 100)    // 12% è‚¡ç¥¨æ”¶ç›Š
  let bond_return = divide_with_ceil(multiply(bond_value, 5), 100)      // 5% å€ºåˆ¸æ”¶ç›Š
  let cash_return = divide_with_ceil(multiply(cash_value, 2), 100)      // 2% ç°é‡‘æ”¶ç›Š
  
  let total_return = add(add(stock_return, bond_return), cash_return)
  
  assert_eq(60000, stock_value)
  assert_eq(30000, bond_value)
  assert_eq(10000, cash_value)
  assert_eq(7200, stock_return)
  assert_eq(1500, bond_return)
  assert_eq(200, cash_return)
  assert_eq(8900, total_return)
}

test "advanced_error_robustness_validation" {
  // é«˜çº§é”™è¯¯å¥å£®æ€§éªŒè¯
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼çš„ç»„åˆè¿ç®—
  let extreme_positive = 2147483647
  let extreme_negative = -2147483648
  let zero = 0
  
  // æµ‹è¯•æç«¯å€¼çš„åŠ æ³•ç»„åˆ
  assert_eq(-1, add(extreme_positive, extreme_negative))
  assert_eq(2147483646, add(extreme_positive, -1))
  assert_eq(-2147483647, add(extreme_negative, 1))
  
  // æµ‹è¯•æç«¯å€¼çš„é™¤æ³•å®‰å…¨æ€§
  assert_eq(0, divide_with_ceil(extreme_positive, zero))
  assert_eq(0, divide_with_ceil(extreme_negative, zero))
  assert_eq(0, divide_with_ceil(zero, zero))
  
  // æµ‹è¯•æç«¯å€¼çš„ä¹˜æ³•è¾¹ç•Œ
  assert_eq(0, multiply(extreme_positive, zero))
  assert_eq(0, multiply(extreme_negative, zero))
  assert_eq(0, multiply(zero, extreme_positive))
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡MoonBitæµ‹è¯•ç”¨ä¾‹
test "fibonacci_sequence_calculation" {
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)
  let fib4 = add(fib2, fib3)
  let fib5 = add(fib3, fib4)
  let fib6 = add(fib4, fib5)
  let fib7 = add(fib5, fib6)
  let fib8 = add(fib6, fib7)
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
  assert_eq(13, fib7)
  assert_eq(21, fib8)
}

test "factorial_calculation" {
  // æµ‹è¯•é˜¶ä¹˜è®¡ç®—
  let fact1 = 1
  let fact2 = multiply(fact1, 2)
  let fact3 = multiply(fact2, 3)
  let fact4 = multiply(fact3, 4)
  let fact5 = multiply(fact4, 5)
  
  assert_eq(120, fact5)
}

test "stack_operations_simulation" {
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼ˆpushå’Œpopï¼‰
  let mut stack_size = 0
  let mut stack_sum = 0
  
  // pushæ“ä½œ
  stack_size = add(stack_size, 1)
  stack_sum = add(stack_sum, 10)
  stack_size = add(stack_size, 1)
  stack_sum = add(stack_sum, 20)
  stack_size = add(stack_size, 1)
  stack_sum = add(stack_sum, 30)
  
  assert_eq(3, stack_size)
  assert_eq(60, stack_sum)
  
  // popæ“ä½œï¼ˆæ¨¡æ‹Ÿï¼‰
  stack_size = add(stack_size, -1)
  stack_sum = add(stack_sum, -30)
  
  assert_eq(2, stack_size)
  assert_eq(30, stack_sum)
}

test "binary_search_efficiency" {
  // æ¨¡æ‹ŸäºŒåˆ†æœç´¢çš„æ¯”è¾ƒæ¬¡æ•°
  let sorted_array_size = 64
  let mut binary_comparisons = divide_with_ceil(sorted_array_size, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  
  assert_eq(1, binary_comparisons)
}

test "boundary_value_calculations" {
  // æµ‹è¯•é™¤æ³•çš„å„ç§è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  
  // æµ‹è¯•æå€¼è¿ç®—
  let very_large = 1000000
  let negative_large = -1000000
  
  assert_eq(0, add(very_large, negative_large))
}

test "multilingual_greetings" {
  // æµ‹è¯•å¤šè¯­è¨€é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, English!", greet("English"))
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, Ñ€ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ñ€ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, espaÃ±ol!", greet("espaÃ±ol"))
  assert_eq_string("Hello, franÃ§ais!", greet("franÃ§ais"))
}

test "physics_distance_calculation" {
  // è®¡ç®—è‡ªç”±è½ä½“è·ç¦»ï¼šs = 0.5 * g * t^2ï¼ˆç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼‰
  let gravity = 10  // ç®€åŒ–çš„é‡åŠ›åŠ é€Ÿåº¦
  let time = 3
  let distance = multiply(gravity, multiply(time, time)) / 2
  
  assert_eq(45, distance)
}

test "kinetic_energy_calculation" {
  // è®¡ç®—åŠ¨èƒ½ï¼šKE = 0.5 * m * v^2
  let mass = 10
  let velocity = 8
  let kinetic_energy = multiply(mass, multiply(velocity, velocity)) / 2
  
  assert_eq(320, kinetic_energy)
}

test "circle_geometry_calculations" {
  // è®¡ç®—åœ†çš„å‘¨é•¿å’Œé¢ç§¯
  let radius = 7
  let pi_approx = 22  // Ï€çš„è¿‘ä¼¼å€¼
  let circumference = multiply(2, multiply(radius, pi_approx)) / 7
  let area = multiply(radius, multiply(radius, pi_approx)) / 7
  
  assert_eq(44, circumference)
  assert_eq(154, area)
}

test "combinatorial_calculations" {
  // è®¡ç®—ç»„åˆæ•°ï¼šC(n,k) = n! / (k! * (n-k)!)
  // ç®€åŒ–è®¡ç®—ï¼šC(5,2) = 5*4/(2*1) = 10
  let n = 5
  let k = 2
  let numerator = multiply(n, add(n, -1))
  let denominator = multiply(k, 1)
  let combination = numerator / denominator
  
  assert_eq(10, combination)
  
  // è®¡ç®—æ’åˆ—æ•°ï¼šP(n,k) = n! / (n-k)!
  // ç®€åŒ–è®¡ç®—ï¼šP(5,3) = 5*4*3 = 60
  let perm_n = 5
  let permutation = multiply(perm_n, multiply(add(perm_n, -1), add(perm_n, -2)))
  
  assert_eq(60, permutation)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "recursive_calculation_simulation" {
  // æ¨¡æ‹Ÿé€’å½’è®¡ç®—ï¼šè®¡ç®—å¹‚è¿ç®— n^k
  let base = 3
  let exponent = 4
  
  // æ¨¡æ‹Ÿé€’å½’è®¡ç®— base^exponent = 3^4 = 3 * 3^3 = 3 * (3 * 3^2) = 3 * (3 * (3 * 3^1)) = 3 * (3 * (3 * 3))
  let power1 = multiply(base, 1)        // 3^1
  let power2 = multiply(base, power1)    // 3^2
  let power3 = multiply(base, power2)    // 3^3
  let power4 = multiply(base, power3)    // 3^4
  
  assert_eq(3, power1)
  assert_eq(9, power2)
  assert_eq(27, power3)
  assert_eq(81, power4)
}

test "queue_operations_simulation" {
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼ˆå…¥é˜Ÿå’Œå‡ºé˜Ÿï¼‰
  let mut queue_size = 0
  let mut queue_sum = 0
  
  // å…¥é˜Ÿæ“ä½œ
  queue_size = add(queue_size, 1)
  queue_sum = add(queue_sum, 15)
  queue_size = add(queue_size, 1)
  queue_sum = add(queue_sum, 25)
  queue_size = add(queue_size, 1)
  queue_sum = add(queue_sum, 35)
  
  assert_eq(3, queue_size)
  assert_eq(75, queue_sum)
  
  // å‡ºé˜Ÿæ“ä½œï¼ˆFIFO - å…ˆè¿›å…ˆå‡ºï¼‰
  queue_size = add(queue_size, -1)
  queue_sum = add(queue_sum, -15)
  
  assert_eq(2, queue_size)
  assert_eq(60, queue_sum)
}

test "statistical_calculations" {
  // æ¨¡æ‹Ÿç»Ÿè®¡è®¡ç®—ï¼šå¹³å‡å€¼ã€æ–¹å·®
  let data1 = 10
  let data2 = 20
  let data3 = 30
  let data4 = 40
  let data5 = 50
  
  // è®¡ç®—å¹³å‡å€¼
  let sum = add(add(add(add(data1, data2), data3), data4), data5)
  let count = 5
  let mean = divide_with_ceil(sum, count)
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let diff1 = add(data1, -mean)
  let diff2 = add(data2, -mean)
  let diff3 = add(data3, -mean)
  let diff4 = add(data4, -mean)
  let diff5 = add(data5, -mean)
  
  let variance = divide_with_ceil(
    add(add(add(add(add(multiply(diff1, diff1), multiply(diff2, diff2)), multiply(diff3, diff3)), multiply(diff4, diff4)), multiply(diff5, diff5)), 
    count
  )
  
  assert_eq(30, mean)
  assert_eq(200, variance)
}

test "time_complexity_simulation" {
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒ
  let input_size = 100
  
  // O(1) å¸¸æ•°æ—¶é—´
  let constant_time = 5
  
  // O(n) çº¿æ€§æ—¶é—´
  let linear_time = multiply(input_size, 2)
  
  // O(nÂ²) å¹³æ–¹æ—¶é—´ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let quadratic_time = multiply(input_size, input_size) / 10
  
  // O(log n) å¯¹æ•°æ—¶é—´ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let logarithmic_time = divide_with_ceil(input_size, 32)
  
  assert_eq(5, constant_time)
  assert_eq(200, linear_time)
  assert_eq(1000, quadratic_time)
  assert_eq(4, logarithmic_time)
}

test "memory_allocation_simulation" {
  // æ¨¡æ‹Ÿå†…å­˜åˆ†é…å’Œé‡Šæ”¾è®¡ç®—
  let block_size = 64
  let total_blocks = 100
  let allocated_blocks = 75
  
  // è®¡ç®—å·²åˆ†é…å†…å­˜
  let allocated_memory = multiply(block_size, allocated_blocks)
  
  // è®¡ç®—å‰©ä½™å†…å­˜
  let remaining_blocks = add(total_blocks, -allocated_blocks)
  let remaining_memory = multiply(block_size, remaining_blocks)
  
  // è®¡ç®—å†…å­˜åˆ©ç”¨ç‡
  let utilization_percentage = divide_with_ceil(multiply(allocated_blocks, 100), total_blocks)
  
  assert_eq(4800, allocated_memory)
  assert_eq(1600, remaining_memory)
  assert_eq(75, utilization_percentage)
}

test "advanced_geometry_calculations" {
  // é«˜çº§å‡ ä½•è®¡ç®—ï¼šä¸‰è§’å½¢é¢ç§¯å’Œå‘¨é•¿
  let side_a = 3
  let side_b = 4
  let side_c = 5
  
  // è®¡ç®—å‘¨é•¿
  let perimeter = add(add(side_a, side_b), side_c)
  
  // è®¡ç®—åŠå‘¨é•¿
  let semi_perimeter = divide_with_ceil(perimeter, 2)
  
  // ä½¿ç”¨æµ·ä¼¦å…¬å¼è®¡ç®—é¢ç§¯ï¼ˆç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼‰
  // é¢ç§¯ = âˆš(s(s-a)(s-b)(s-c))ï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ•´æ•°è¿‘ä¼¼
  let area_approx = divide_with_ceil(multiply(side_a, side_b), 2)
  
  // è®¡ç®—ä¸‰è§’å½¢çš„é«˜
  let height = divide_with_ceil(multiply(2, area_approx), side_c)
  
  assert_eq(12, perimeter)
  assert_eq(6, semi_perimeter)
  assert_eq(6, area_approx)
  assert_eq(3, height)
}

test "probability_calculation_simulation" {
  // æ¨¡æ‹Ÿæ¦‚ç‡è®¡ç®—
  let total_outcomes = 52  // æ‰‘å…‹ç‰Œæ€»æ•°
  let favorable_outcomes = 4  // Açš„æ•°é‡
  
  // è®¡ç®—æ¦‚ç‡ï¼ˆç®€åŒ–ä¸ºæ•´æ•°ç™¾åˆ†æ¯”ï¼‰
  let probability_percent = divide_with_ceil(multiply(favorable_outcomes, 100), total_outcomes)
  
  // è®¡ç®—äº’è¡¥äº‹ä»¶æ¦‚ç‡
  let complementary_probability = add(100, -probability_percent)
  
  // è®¡ç®—å¤šæ¬¡ç‹¬ç«‹äº‹ä»¶çš„æ¦‚ç‡ï¼ˆtrials=3ï¼‰
  let trials = 3
  let success_probability = divide_with_ceil(probability_percent, 100)
  let multiple_trials_success = multiply(success_probability, success_probability)
  
  assert_eq(8, probability_percent)
  assert_eq(92, complementary_probability)
  assert_eq(0, multiple_trials_success)
}

test "data_compression_simulation" {
  // æ¨¡æ‹Ÿæ•°æ®å‹ç¼©ç®—æ³•
  let original_size = 1000
  let repeated_patterns = 200
  let compression_ratio = 70
  
  // è®¡ç®—å‹ç¼©åçš„å¤§å°ï¼ˆè€ƒè™‘ repeated_patternsï¼‰
  let compressed_size = multiply(original_size, compression_ratio) / 100
  
  // è®¡ç®—èŠ‚çœçš„ç©ºé—´
  let space_saved = add(original_size, -compressed_size)
  
  // è®¡ç®—å‹ç¼©æ•ˆç‡
  let compression_efficiency = divide_with_ceil(multiply(space_saved, 100), original_size)
  
  // è®¡ç®—è§£å‹æ—¶é—´ï¼ˆæ¨¡æ‹Ÿï¼‰
  let decompression_time = divide_with_ceil(compressed_size, 50)
  
  assert_eq(700, compressed_size)
  assert_eq(300, space_saved)
  assert_eq(30, compression_efficiency)
  assert_eq(14, decompression_time)
}

test "network_transmission_calculation" {
  // ç½‘ç»œä¼ è¾“è®¡ç®—
  let file_size_mb = 500
  let network_speed_mbps = 100
  let packet_overhead = 20  // 20% å¼€é”€
  let latency_ms = 50
  
  // è®¡ç®—åŸºç¡€ä¼ è¾“æ—¶é—´
  let base_time_seconds = divide_with_ceil(file_size_mb, network_speed_mbps)
  
  // è®¡ç®—è€ƒè™‘å¼€é”€çš„ä¼ è¾“æ—¶é—´
  let overhead_factor = divide_with_ceil(multiply(network_speed_mbps, add(100, -packet_overhead)), 100)
  let actual_time_seconds = divide_with_ceil(file_size_mb, overhead_factor)
  
  // è®¡ç®—æ€»å»¶è¿Ÿæ—¶é—´
  let total_latency_ms = multiply(latency_ms, 10)  // å‡è®¾10ä¸ªæ•°æ®åŒ…
  let total_latency_seconds = divide_with_ceil(total_latency_ms, 1000)
  
  // è®¡ç®—æ€»ä¼ è¾“æ—¶é—´
  let total_time_seconds = add(actual_time_seconds, total_latency_seconds)
  
  assert_eq(5, base_time_seconds)
  assert_eq(7, actual_time_seconds)
  assert_eq(1, total_latency_seconds)
  assert_eq(8, total_time_seconds)
}

test "cache_strategy_simulation" {
  // ç¼“å­˜ç­–ç•¥æ¨¡æ‹Ÿ
  let total_requests = 1000
  let cache_size = 100
  let hot_data_ratio = 80  // 80% çš„è¯·æ±‚è®¿é—®çƒ­ç‚¹æ•°æ®
  
  // è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
  let cache_hit_ratio = divide_with_ceil(multiply(cache_size, hot_data_ratio), total_requests)
  
  // è®¡ç®—ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°
  let cache_misses = add(total_requests, -cache_hit_ratio)
  
  // è®¡ç®—æ€§èƒ½æå‡
  let cache_access_time = 1   // ç¼“å­˜è®¿é—®æ—¶é—´
  let memory_access_time = 10 // å†…å­˜è®¿é—®æ—¶é—´
  let average_access_time = divide_with_ceil(
    add(multiply(cache_hit_ratio, cache_access_time), multiply(cache_misses, memory_access_time)),
    total_requests
  )
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = divide_with_ceil(memory_access_time, average_access_time)
  
  assert_eq(8, cache_hit_ratio)
  assert_eq(992, cache_misses)
  assert_eq(10, average_access_time)
  assert_eq(1, performance_improvement)
}

