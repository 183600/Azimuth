// 基础库文件
pub fn add(a : Int, b : Int) -> Int {
  // 特殊情况处理：如果有一个是0，直接返回另一个
  if a == 0 { return b }
  if b == 0 { return a }
  
  // 正数相加溢出检查
  if a > 0 && b > 0 {
    // 如果 a > 2147483647 - b，则 a + b 会溢出
    if a > 2147483647 - b { return 2147483647 }
  }
  
  // 负数相加溢出检查
  if a < 0 && b < 0 {
    // 如果任一参数是最小值，结果必然是最小值
    if a == -2147483648 || b == -2147483648 { return -2147483648 }
    
    // 对于其他负数，使用更安全的检查方法
    // 由于 a 和 b 都是负数且不是最小值，我们可以安全地使用绝对值
    let abs_a = -a  // 此时a是负数且不是最小值，所以 -a 不会溢出
    let abs_b = -b  // 此时b是负数且不是最小值，所以 -b 不会溢出
    
    // 检查 abs_a + abs_b 是否会超过 2147483648（即绝对值之和超过最小值的绝对值）
    // 使用减法来避免加法溢出
    
    // 如果 abs_a >= 2147483647 或 abs_b >= 2147483647，则肯定会溢出
    // 因为另一个数至少是1，所以绝对值之和至少是 2147483648
    if abs_a >= 2147483647 || abs_b >= 2147483647 { return -2147483648 }
    
    // 对于一般情况，检查 abs_a + abs_b > 2147483648
    // 由于 abs_a 和 abs_b 都小于 2147483647，我们可以安全地进行检查
    // 如果 abs_a > 2147483647 - abs_b + 1，则会溢出
    if abs_a > 2147483647 - abs_b + 1 { return -2147483648 }
    
    // 特殊情况：当 abs_a == 2147483647 - abs_b + 1 时
    // 这意味着 abs_a + abs_b == 2147483648，正好是最小值的绝对值
    // 所以结果应该是最小值
    if abs_a == 2147483647 - abs_b + 1 { return -2147483648 }
  }
  
  // 正负数混合相加的情况
  if (a > 0 && b < 0) || (a < 0 && b > 0) {
    // 处理特殊情况：最大值 + 最小值
    if (a == 2147483647 && b == -2147483648) || (a == -2147483648 && b == 2147483647) {
      return -1
    }
    
    // 对于其他正负数混合情况，由于符号相反，不会溢出
    // 除非其中一个是边界值
    // 但这些情况已经在正数和负数的单独处理中覆盖了
  }
  
  // 安全地进行加法运算
  return a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  // 处理0的情况
  if a == 0 || b == 0 { return 0 }
  
  // 处理1的情况
  if a == 1 { return b }
  if b == 1 { return a }
  
  // 处理-1的情况
  if a == -1 { 
    if b == -2147483648 { return -2147483648 }  // -1乘以最小值返回最小值（溢出）
    return -b 
  }
  if b == -1 { 
    if a == -2147483648 { return -2147483648 }  // 最小值乘-1返回最小值（溢出）
    return -a 
  }
  
  // 特殊处理最小值 -2147483648
  if a == -2147483648 {
    if b == 1 { return -2147483648 }      // 最小值乘1
    if b == -1 { return -2147483648 }     // 最小值乘-1返回最小值（溢出）
    if b == 0 { return 0 }               // 最小值乘0
    if b > 1 { return -2147483648 }      // 最小值乘以任何大于1的正数都会溢出
    if b < -1 { return -2147483648 }     // 最小值乘以小于-1的负数也会溢出，返回最小值
  }
  if b == -2147483648 {
    if a == 1 { return -2147483648 }      // 1乘最小值
    if a == -1 { return -2147483648 }     // -1乘最小值返回最小值（溢出）
    if a == 0 { return 0 }               // 0乘最小值
    if a > 1 { return -2147483648 }      // 任何大于1的正数乘最小值都会溢出
    if a < -1 { return -2147483648 }     // 小于-1的负数乘最小值也会溢出，返回最小值
  }
  
  // 检查正负号
  let sign = if (a > 0 && b > 0) || (a < 0 && b < 0) { 1 } else { -1 }
  
  // 安全地计算绝对值，避免 -2147483648 的溢出问题
  // 注意：此时 a 和 b 都不是 -2147483648，因为已经在上面处理了
  let abs_a = if a < 0 { -a } else { a }
  let abs_b = if b < 0 { -b } else { b }
  
  // 溢出检查：使用更安全的方法
  // 如果 abs_b > 0，进行溢出检查
  if abs_b > 0 {
    let max_div = 2147483647 / abs_b
    if abs_a > max_div {
      return if sign > 0 { 2147483647 } else { -2147483648 }
    }
    // 检查边界情况：当 abs_a == max_div 时，需要检查余数
    // 如果 abs_a * abs_b > 2147483647，则会溢出
    if abs_a == max_div {
      let remainder = 2147483647 % abs_b
      // 如果 abs_a * abs_b > max_div * abs_b + remainder = 2147483647，则会溢出
      // 所以我们需要检查 abs_a * abs_b 是否等于 2147483647
      // 由于 abs_a == max_div，我们只需要检查是否正好等于最大值
      // 如果不是正好等于最大值，则会溢出
      // 但由于我们已经知道 abs_a == max_div，所以 abs_a * abs_b <= 2147483647
      // 因此这种情况不会溢出
    }
  } else if abs_b == 0 {
    // 理论上不会执行到这里，因为开头已经处理了 b == 0 的情况
    // 但为了安全起见，返回 0
    return 0
  }
  
  // 安全地进行乘法运算
  return a * b
}

pub fn greet(name : String) -> String {
  // 字符串拼接：空字符串会自动处理
  "Hello, " + name + "!"
}