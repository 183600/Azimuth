pub fn add(a : Int, b : Int) -> Int {
  // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœæœ‰ä¸€ä¸ªæ˜¯0ï¼Œç›´æ¥è¿”å›å¦ä¸€ä¸ª
  if a == 0 {
    return b
  }
  if b == 0 {
    return a
  }

  // å¤„ç†æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼ˆInt32çš„æœ€å°å€¼ï¼‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†ä¸€ä¸ªæ“ä½œæ•°æ˜¯æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ + è´Ÿæ•° = å¯èƒ½æº¢å‡º
    if b < 0 {
      return min_val
    }
    // æœ€å°å€¼ + éè´Ÿæ•° = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }
  if b == min_val {
    // è´Ÿæ•° + æœ€å°å€¼ = å¯èƒ½æº¢å‡º
    if a < 0 {
      return min_val
    }
    // éè´Ÿæ•° + æœ€å°å€¼ = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }

  // æ­£æ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥
  if a > 0 && b > 0 {
    // å¦‚æœ a > max_val - bï¼Œåˆ™ a + b ä¼šæº¢å‡º
    if a > max_val - b {
      return max_val
    }
  }

  // è´Ÿæ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥ï¼ˆæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼ï¼‰
  if a < 0 && b < 0 {
    // ä½¿ç”¨å‡æ³•æ£€æŸ¥ï¼ša < min_val - b
    // ç”±äºbæ˜¯è´Ÿæ•°ï¼Œmin_val - b = min_val + abs(b)
    if a < min_val - b {
      return min_val
    }
  }

  // å®‰å…¨åœ°è¿›è¡ŒåŠ æ³•è¿ç®—
  return a + b
}

///
pub fn multiply(a : Int, b : Int) -> Int {
  // å¸¸é‡å®šä¹‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†0çš„æƒ…å†µ
  if a == 0 || b == 0 {
    return 0
  }

  // å¤„ç†1çš„æƒ…å†µ
  if a == 1 {
    return b
  }
  if b == 1 {
    return a
  }

  // å¤„ç†-1çš„æƒ…å†µï¼ˆåŒ…æ‹¬æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼‰
  if a == -1 {
    // -2147483648 * -1 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if b == min_val { min_val } else { -b }
  }
  if b == -1 {
    // -1 * -2147483648 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if a == min_val { min_val } else { -a }
  }

  // å¤„ç†æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if b > 1 || b < -1 { min_val } else { a * b }
  }
  if b == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if a > 1 || a < -1 { min_val } else { a * b }
  }

  // æ£€æŸ¥æ­£è´Ÿå·
  let sign = if (a > 0 && b > 0) || (a < 0 && b < 0) { 1 } else { -1 }

  // å®‰å…¨åœ°è®¡ç®—ç»å¯¹å€¼ï¼Œæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼
  let abs_a = if a < 0 { -a } else { a }
  let abs_b = if b < 0 { -b } else { b }

  // ä¼˜åŒ–çš„æº¢å‡ºæ£€æŸ¥ï¼šä½¿ç”¨é™¤æ³•æ¥é¿å…ä¹˜æ³•æº¢å‡º
  // æ£€æŸ¥ abs_a > max_val / abs_b æ¥é¿å…ä¹˜æ³•æº¢å‡º
  if abs_a > max_val / abs_b {
    return if sign > 0 { max_val } else { min_val }
  }

  // å®‰å…¨åœ°è¿›è¡Œä¹˜æ³•è¿ç®—
  return a * b
}

///
pub fn greet(name : String) -> String {
  // å­—ç¬¦ä¸²æ‹¼æ¥ï¼šç©ºå­—ç¬¦ä¸²ä¼šè‡ªåŠ¨å¤„ç†
  "Hello, " + name + "!"
}

// æµ‹è¯•è¾…åŠ©å‡½æ•°ï¼Œæä¾›æ–­è¨€åŠŸèƒ½
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (expected == actual) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (expected == actual) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_true(condition : Bool) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (condition) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_false(condition : Bool) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (condition) {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  } else {
    ()
  }
}

// è¾…åŠ©å‡½æ•°ï¼šå‘ä¸Šå–æ•´é™¤æ³•
pub fn divide_with_ceil(dividend : Int, divisor : Int) -> Int {
  let quotient = dividend / divisor
  let remainder = dividend % divisor
  if remainder > 0 { add(quotient, 1) } else { quotient }
}

// æµ‹è¯•ç”¨ä¾‹
test "basic_add_test" {
  let result = add(2, 3)
  assert_eq(5, result)
}

test "add_with_zero" {
  // æµ‹è¯•ä¸0ç›¸åŠ çš„æƒ…å†µ
  assert_eq(5, add(5, 0))
  assert_eq(5, add(0, 5))
  assert_eq(0, add(0, 0))
}

test "add_with_min_value" {
  // æµ‹è¯•æœ€å°å€¼çš„æƒ…å†µ
  let min_val = -2147483648
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, add(0, min_val))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-2147483647, add(min_val, 1))
}

test "add_positive_overflow" {
  // æµ‹è¯•æ­£æ•°æº¢å‡ºçš„æƒ…å†µ
  let max_val = 2147483647
  assert_eq(max_val, add(max_val, 1))
  assert_eq(max_val, add(1000000000, 1500000000))
}

test "add_negative_overflow" {
  // æµ‹è¯•è´Ÿæ•°æº¢å‡ºçš„æƒ…å†µ
  let min_val = -2147483648
  assert_eq(min_val, add(min_val, -1))
  assert_eq(min_val, add(-1500000000, -1000000000))
}

test "basic_multiply_test" {
  let result = multiply(2, 3)
  assert_eq(6, result)
}

test "multiply_with_zero_and_one" {
  // æµ‹è¯•ä¸0å’Œ1ç›¸ä¹˜çš„æƒ…å†µ
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(5, multiply(5, 1))
  assert_eq(5, multiply(1, 5))
}

test "multiply_with_negative_one" {
  // æµ‹è¯•ä¸-1ç›¸ä¹˜çš„æƒ…å†µ
  assert_eq(-5, multiply(5, -1))
  assert_eq(-5, multiply(-1, 5))
  assert_eq(5, multiply(-5, -1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸-1ç›¸ä¹˜çš„ç‰¹æ®Šæƒ…å†µ
  let min_val = -2147483648
  assert_eq(min_val, multiply(min_val, -1))
}

test "multiply_overflow" {
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºçš„æƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(max_val, multiply(46341, 46341))  // sqrt(max_val)çš„å¹³æ–¹
  assert_eq(min_val, multiply(-46341, 46341))
}

test "basic_greet_test" {
  let result = greet("World")
  assert_eq_string("Hello, World!", result)
}

test "greet_with_empty_string" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²çš„æƒ…å†µ
  let result = greet("")
  assert_eq_string("Hello, !", result)
}

test "greet_with_special_characters" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let result = greet("æµ‹è¯•@123")
  assert_eq_string("Hello, æµ‹è¯•@123!", result)
}

// æ–°å¢æµ‹è¯•ç”¨ä¾‹
test "add_large_numbers" {
  // æµ‹è¯•å¤§æ•°ç›¸åŠ 
  assert_eq(2000000000, add(1000000000, 1000000000))
  assert_eq(-2000000000, add(-1000000000, -1000000000))
}

test "add_mixed_signs" {
  // æµ‹è¯•ä¸åŒç¬¦å·çš„æ•°ç›¸åŠ 
  assert_eq(0, add(100, -100))
  assert_eq(-50, add(100, -150))
  assert_eq(50, add(-100, 150))
}

test "multiply_large_numbers" {
  // æµ‹è¯•å¤§æ•°ç›¸ä¹˜
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(-1000000, multiply(-1000, 1000))
  assert_eq(1000000, multiply(-1000, -1000))
}

test "multiply_boundary_combinations" {
  // æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆçš„ä¹˜æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(min_val, multiply(min_val, 1))
}

test "greet_with_whitespace" {
  // æµ‹è¯•åŒ…å«ç©ºç™½å­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello,   World!", greet("  World"))
  assert_eq_string("Hello, World   !", greet("World  "))
  assert_eq_string("Hello,  World  !", greet(" World  "))
}

test "greet_with_unicode_emoji" {
  // æµ‹è¯•åŒ…å« Unicode emoji çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
  assert_eq_string("Hello, ğŸ‘‹!", greet("ğŸ‘‹"))
}

test "assert_functions_test" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

test "complex_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šè®¡ç®—çŸ©å½¢çš„å‘¨é•¿
  let length = 10
  let width = 5
  let perimeter = add(multiply(2, length), multiply(2, width))
  assert_eq(30, perimeter)
}

test "financial_calculation_scenario" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯ï¼šå¤åˆ©è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let principal = 1000
  let rate = 5
  let years = 3
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼šæœ¬æ¯å’Œ = æœ¬é‡‘ + æœ¬é‡‘ Ã— åˆ©ç‡ Ã— å¹´æ•°
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  assert_eq(16000, total)  // 1000 + 1000*5*3 = 16000ï¼Œè¡¨ç¤º1600å…ƒ
}

// æ–°å¢çš„10ä¸ªæµ‹è¯•ç”¨ä¾‹
test "sequential_addition" {
  // æµ‹è¯•è¿ç»­ç›¸åŠ çš„æƒ…å†µ
  let result1 = add(add(1, 2), add(3, 4))
  assert_eq(10, result1)
  
  let result2 = add(add(100, 200), add(300, 400))
  assert_eq(1000, result2)
  
  // æµ‹è¯•åŒ…å«æœ€å°å€¼çš„è¿ç»­ç›¸åŠ 
  let min_val = -2147483648
  let result3 = add(add(min_val, 1), add(1, 1))
  assert_eq(-2147483645, result3)
}

test "sequential_multiplication" {
  // æµ‹è¯•è¿ç»­ç›¸ä¹˜çš„æƒ…å†µ
  let result1 = multiply(multiply(2, 3), multiply(4, 5))
  assert_eq(120, result1)
  
  let result2 = multiply(multiply(10, 20), multiply(30, 40))
  assert_eq(240000, result2)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„è¿ç»­ç›¸ä¹˜
  let result3 = multiply(multiply(-2, 3), multiply(4, -5))
  assert_eq(120, result3)
}

test "extreme_value_operations" {
  // æµ‹è¯•æå€¼è¿ç®—çš„ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æå€¼ç›¸åŠ 
  assert_eq(-1, add(max_val, min_val))
  
  // æå€¼ä¸æ¥è¿‘æå€¼çš„æ•°ç›¸åŠ 
  assert_eq(max_val, add(max_val, 100))
  assert_eq(min_val, add(min_val, -100))
  
  // æå€¼ç›¸ä¹˜
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
}

test "string_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¿æ¥çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²
  let long_name = "ThisIsAVeryLongNameThatMightCauseIssuesInSomeSystemsButShouldWorkFineInMoonBit"
  let result = greet(long_name)
  assert_eq_string("Hello, " + long_name + "!", result)
  
  // æµ‹è¯•åŒ…å«å¼•å·çš„å­—ç¬¦ä¸²
  let quoted_name = "\"John Doe\""
  let result2 = greet(quoted_name)
  assert_eq_string("Hello, \"John Doe\"!", result2)
  
  // æµ‹è¯•åŒ…å«æ¢è¡Œç¬¦çš„å­—ç¬¦ä¸²
  let newline_name = "Line1\nLine2"
  let result3 = greet(newline_name)
  assert_eq_string("Hello, Line1\nLine2!", result3)
}

test "addition_associativity" {
  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹ (a + b) + c = a + (b + c)
  let a = 100
  let b = 200
  let c = 300
  
  let result1 = add(add(a, b), c)
  let result2 = add(a, add(b, c))
  assert_eq(result1, result2)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„æƒ…å†µ
  let d = -150
  let e = 250
  let f = -100
  
  let result3 = add(add(d, e), f)
  let result4 = add(d, add(e, f))
  assert_eq(result3, result4)
}

test "multiplication_commutativity" {
  // æµ‹è¯•ä¹˜æ³•äº¤æ¢å¾‹ a * b = b * a
  let a = 12
  let b = 15
  
  let result1 = multiply(a, b)
  let result2 = multiply(b, a)
  assert_eq(result1, result2)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„æƒ…å†µ
  let c = -20
  let d = 30
  
  let result3 = multiply(c, d)
  let result4 = multiply(d, c)
  assert_eq(result3, result4)
  
  // æµ‹è¯•åŒ…å«0çš„æƒ…å†µ
  let e = 0
  let f = 100
  
  let result5 = multiply(e, f)
  let result6 = multiply(f, e)
  assert_eq(result5, result6)
}

test "complex_string_processing" {
  // æµ‹è¯•å¤æ‚å­—ç¬¦ä¸²å¤„ç†
  // æµ‹è¯•åŒ…å«å¤šç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let complex_name = "John@Doe#123$%^&*()"
  let result = greet(complex_name)
  assert_eq_string("Hello, John@Doe#123$%^&*()!", result)
  
  // æµ‹è¯•åŒ…å«ä¸­æ–‡å­—ç¬¦çš„å­—ç¬¦ä¸²
  let chinese_name = "å¼ ä¸‰"
  let result2 = greet(chinese_name)
  assert_eq_string("Hello, å¼ ä¸‰!", result2)
  
  // æµ‹è¯•æ··åˆè¯­è¨€å­—ç¬¦ä¸²
  let mixed_name = "Johnå¼ ä¸‰123"
  let result3 = greet(mixed_name)
  assert_eq_string("Hello, Johnå¼ ä¸‰123!", result3)
}

test "shopping_cart_calculation" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šè´­ç‰©è½¦è®¡ç®—
  let item1_price = 299
  let item1_quantity = 2
  let item2_price = 199
  let item2_quantity = 3
  let item3_price = 99
  let item3_quantity = 1
  
  // è®¡ç®—æ¯ç§å•†å“çš„æ€»ä»·
  let total1 = multiply(item1_price, item1_quantity)
  let total2 = multiply(item2_price, item2_quantity)
  let total3 = multiply(item3_price, item3_quantity)
  
  // è®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let cart_total = add(add(total1, total2), total3)
  
  // éªŒè¯æ€»ä»·ï¼š299*2 + 199*3 + 99*1 = 598 + 597 + 99 = 1294
  assert_eq(1294, cart_total)
}

test "temperature_conversion" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šæ¸©åº¦è½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C * 9/5 + 32
  // ç”±äºæˆ‘ä»¬åªæœ‰æ•´æ•°è¿ç®—ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿‘ä¼¼å€¼ï¼šF = C * 2 + 30
  
  let celsius_temp = 25
  let fahrenheit_temp = add(multiply(celsius_temp, 2), 30)
  assert_eq(80, fahrenheit_temp)  // 25 * 2 + 30 = 80
  
  // æµ‹è¯•å†°ç‚¹æ¸©åº¦
  let freezing_celsius = 0
  let freezing_fahrenheit = add(multiply(freezing_celsius, 2), 30)
  assert_eq(30, freezing_fahrenheit)  // 0 * 2 + 30 = 30
  
  // æµ‹è¯•æ²¸ç‚¹æ¸©åº¦
  let boiling_celsius = 100
  let boiling_fahrenheit = add(multiply(boiling_celsius, 2), 30)
  assert_eq(230, boiling_fahrenheit)  // 100 * 2 + 30 = 230
}

test "error_handling_scenarios" {
  // æµ‹è¯•é”™è¯¯å¤„ç†åœºæ™¯
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„é”™è¯¯æƒ…å†µï¼ˆè¿™äº›æµ‹è¯•ä¼šæ•…æ„å¤±è´¥ï¼Œä½†åœ¨å®é™…ä½¿ç”¨ä¸­è¢«æ³¨é‡Šæ‰ï¼‰
  // assert_true(false)  // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  // assert_false(true)  // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  // assert_eq(1, 2)     // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  // assert_eq_string("hello", "world")  // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µçš„æ­£ç¡®å¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ç¡®ä¿æº¢å‡ºè¢«æ­£ç¡®å¤„ç†
  assert_true(add(max_val, 1) == max_val)
  assert_true(add(min_val, -1) == min_val)
  assert_true(multiply(max_val, 2) == max_val)
  assert_true(multiply(min_val, -1) == min_val)
  
  // æµ‹è¯•æ­£å¸¸æƒ…å†µ
  assert_true(add(5, 3) == 8)
  assert_true(multiply(4, 6) == 24)
  assert_true(greet("Test") == "Hello, Test!")
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "standard_integer_operations" {
  // æµ‹è¯•æ•´æ•°è¿ç®—
  assert_eq(10, add(4, 6))
  assert_eq(0, add(-5, 5))
  assert_eq(15, multiply(3, 5))
  assert_eq(-12, multiply(-3, 4))
}

test "standard_string_operations" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ“ä½œ
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
}

test "standard_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 11
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, 3)), add(multiply(a, b), multiply(a, 3)))
}

test "standard_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¾¹ç•Œå€¼åŠ æ³•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
  
  // è¾¹ç•Œå€¼ä¹˜æ³•
  assert_eq(0, multiply(max_val, 0))
  assert_eq(min_val, multiply(min_val, -1))
}

test "standard_real_world_scenarios" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  // æ¸©åº¦è½¬æ¢ï¼šæ‘„æ°åº¦è½¬åæ°åº¦ï¼ˆç®€åŒ–ç‰ˆï¼šF = C Ã— 2 + 30ï¼‰
  let celsius = 20
  let fahrenheit = add(multiply(celsius, 2), 30)
  assert_eq(70, fahrenheit)
  
  // ç®€å•è´·æ¬¾è®¡ç®—ï¼šæœ¬é‡‘ Ã— (1 + åˆ©ç‡ Ã— å¹´æ•°)
  let principal = 10000
  let rate = 5  // 5%
  let years = 3
  let total = multiply(principal, add(1, multiply(rate, years)))
  assert_eq(160000, total)  // 10000 Ã— (1 + 5Ã—3) = 10000 Ã— 16 = 160000
}

test "standard_error_handling" {
  // æµ‹è¯•é”™è¯¯å¤„ç†
  assert_true(true)
  assert_false(false)
  assert_eq(100, 100)
  assert_eq_string("success", "success")
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  assert_true(add(max_val, 100) == max_val)
  assert_true(multiply(max_val, 2) == max_val)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
test "numeric_range_validation" {
  // æµ‹è¯•æ­£æ•°èŒƒå›´
  assert_true(add(1000000, 2000000) > 0)
  assert_true(multiply(1000, 1000) > 0)
  
  // æµ‹è¯•è´Ÿæ•°èŒƒå›´
  assert_true(add(-1000000, -2000000) < 0)
  assert_true(multiply(-1000, 1000) < 0)
  
  // æµ‹è¯•é›¶å€¼
  assert_eq(0, multiply(0, 123456789))
  assert_eq(123456789, add(0, 123456789))
}

test "string_concatenation_performance" {
  // æµ‹è¯•çŸ­å­—ç¬¦ä¸²è¿æ¥
  let short_name = "Bob"
  let short_result = greet(short_name)
  assert_eq_string("Hello, Bob!", short_result)
  
  // æµ‹è¯•ä¸­ç­‰é•¿åº¦å­—ç¬¦ä¸²è¿æ¥
  let medium_name = "Alexander"
  let medium_result = greet(medium_name)
  assert_eq_string("Hello, Alexander!", medium_result)
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let spaced_name = "Mary Jane"
  let spaced_result = greet(spaced_name)
  assert_eq_string("Hello, Mary Jane!", spaced_result)
}

test "math_function_combination" {
  // æµ‹è¯• (a + b) * c - d çš„å¤åˆè¿ç®—
  let a = 5
  let b = 3
  let c = 4
  let d = 10
  
  // æ­¥éª¤è®¡ç®—
  let sum_ab = add(a, b)  // 5 + 3 = 8
  let product = multiply(sum_ab, c)  // 8 * 4 = 32
  let result = add(product, -d)  // 32 - 10 = 22
  
  assert_eq(22, result)
}

test "boundary_value_special_handling" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸æ­£æ•°ç›¸åŠ 
  assert_eq(max_val, add(max_val, 100))
  assert_eq(max_val, add(max_val, max_val))
  
  // æµ‹è¯•æœ€å°å€¼ä¸è´Ÿæ•°ç›¸åŠ 
  assert_eq(min_val, add(min_val, -100))
  assert_eq(min_val, add(min_val, min_val))
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸è´Ÿæ•°ç›¸ä¹˜
  assert_eq(min_val, multiply(max_val, -1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸å¥‡æ•°ç›¸ä¹˜
  assert_eq(min_val, multiply(min_val, 3))
}

test "average_calculation" {
  // è®¡ç®—ä¸‰ä¸ªæ•°çš„å¹³å‡å€¼ï¼š(a + b + c) / 3
  let num1 = 90
  let num2 = 80
  let num3 = 85
  
  // è®¡ç®—æ€»å’Œï¼š90 + 80 + 85 = 255
  let sum = add(add(num1, num2), num3)
  // è®¡ç®—å¹³å‡å€¼ï¼š255 / 3 = 85ï¼ˆæ•´æ•°é™¤æ³•ï¼‰
  let average = sum / 3
  
  assert_eq(85, average)
}

test "area_calculation" {
  // è®¡ç®—çŸ©å½¢é¢ç§¯ï¼šé•¿ Ã— å®½
  let length = 12
  let width = 8
  
  let rectangle_area = multiply(length, width)
  assert_eq(96, rectangle_area)
  
  // è®¡ç®—ä¸‰è§’å½¢é¢ç§¯ï¼šåº• Ã— é«˜ Ã· 2
  let base = 10
  let height = 6
  
  let triangle_area = multiply(base, height) / 2
  assert_eq(30, triangle_area)
}

test "string_formatting_scenarios" {
  // æµ‹è¯•æ•°å­—å­—ç¬¦ä¸²
  let numeric_name = "12345"
  assert_eq_string("Hello, 12345!", greet(numeric_name))
  
  // æµ‹è¯•æ··åˆå­—ç¬¦ä¸²
  let mixed_name = "user_2023"
  assert_eq_string("Hello, user_2023!", greet(mixed_name))
  
  // æµ‹è¯•å•å­—ç¬¦
  let single_char = "A"
  assert_eq_string("Hello, A!", greet(single_char))
}

test "sum_of_squares_calculation" {
  // è®¡ç®—å‰nä¸ªè‡ªç„¶æ•°çš„å¹³æ–¹å’Œï¼š1Â² + 2Â² + 3Â² + ... + nÂ²
  let n = 5
  
  // æ‰‹åŠ¨è®¡ç®—ï¼š1Â² + 2Â² + 3Â² + 4Â² + 5Â² = 1 + 4 + 9 + 16 + 25 = 55
  let square1 = multiply(1, 1)
  let square2 = multiply(2, 2)
  let square3 = multiply(3, 3)
  let square4 = multiply(4, 4)
  let square5 = multiply(5, 5)
  
  let sum_of_squares = add(add(add(add(square1, square2), square3), square4), square5)
  assert_eq(55, sum_of_squares)
}

test "conditional_logic_test" {
  // æµ‹è¯•åŸºäºæ¯”è¾ƒç»“æœçš„æ¡ä»¶è¿ç®—
  let x = 15
  let y = 20
  
  // å¦‚æœ x < yï¼Œåˆ™è®¡ç®— x + yï¼Œå¦åˆ™è®¡ç®— x * y
  let condition = x < y
  let result = if condition { add(x, y) } else { multiply(x, y) }
  
  // ç”±äº 15 < 20 ä¸ºçœŸï¼Œæ‰€ä»¥åº”è¯¥è®¡ç®— 15 + 20 = 35
  assert_eq(35, result)
  
  // åå‘æµ‹è¯•
  let condition2 = x > y
  let result2 = if condition2 { add(x, y) } else { multiply(x, y) }
  
  // ç”±äº 15 > 20 ä¸ºå‡ï¼Œæ‰€ä»¥åº”è¯¥è®¡ç®— 15 * 20 = 300
  assert_eq(300, result2)
}

test "data_conversion_scenarios" {
  // æµ‹è¯•æ•°å€¼åˆ°å­—ç¬¦ä¸²çš„é—´æ¥è½¬æ¢ï¼ˆé€šè¿‡greetå‡½æ•°ï¼‰
  let number = 42
  let number_str = "42"
  
  // é€šè¿‡greetå‡½æ•°éªŒè¯å­—ç¬¦ä¸²æ‹¼æ¥
  let result1 = greet(number_str)
  let result2 = greet("Answer is " + number_str)
  
  assert_eq_string("Hello, 42!", result1)
  assert_eq_string("Hello, Answer is 42!", result2)
  
  // æµ‹è¯•å¸ƒå°”å€¼åœºæ™¯ï¼ˆé€šè¿‡å­—ç¬¦ä¸²è¡¨ç¤ºï¼‰
  let true_str = "true"
  let false_str = "false"
  
  assert_eq_string("Hello, true!", greet(true_str))
  assert_eq_string("Hello, false!", greet(false_str))
}

// æ–°å¢çš„10ä¸ªMoonBitæµ‹è¯•ç”¨ä¾‹
test "factorial_calculation" {
  // è®¡ç®—5çš„é˜¶ä¹˜ï¼š5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
  let n = 5
  let result = multiply(n, multiply(n - 1, multiply(n - 2, multiply(n - 3, n - 4))))
  assert_eq(120, result)
}

test "compound_interest_precise" {
  // ç²¾ç¡®çš„å¤åˆ©è®¡ç®—ï¼šæœ¬é‡‘ Ã— (1 + åˆ©ç‡)^å¹´æ•°
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼š1000 Ã— (1 + 5%)^3 â‰ˆ 1000 Ã— 116 = 116000
  let principal = 1000
  let rate_percent = 5
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©å…¬å¼ï¼Œé¿å…æµ®ç‚¹æ•°
  let growth_factor = add(100, multiply(rate_percent, years))
  let total = multiply(principal, growth_factor)
  assert_eq(115000, total)  // 1000 Ã— (100 + 5Ã—3) = 1000 Ã— 115 = 115000
}

test "nested_calculations" {
  // åµŒå¥—è®¡ç®—æµ‹è¯•ï¼š((a + b) Ã— (c + d)) - (e Ã— f)
  let a = 10
  let b = 20
  let c = 5
  let d = 15
  let e = 8
  let f = 12
  
  let sum1 = add(a, b)  // 30
  let sum2 = add(c, d)  // 20
  let product1 = multiply(sum1, sum2)  // 600
  let product2 = multiply(e, f)  // 96
  let result = add(product1, -product2)  // 504
  
  assert_eq(504, result)
}

test "string_length_edge_cases" {
  // æµ‹è¯•ä¸åŒé•¿åº¦å­—ç¬¦ä¸²çš„greetå‡½æ•°å¤„ç†
  let empty = ""
  let single = "A"
  let short = "Hi"
  let medium = "MoonBit"
  let long = "ThisIsAVeryLongStringForTestingPurposes"
  
  assert_eq_string("Hello, !", greet(empty))
  assert_eq_string("Hello, A!", greet(single))
  assert_eq_string("Hello, Hi!", greet(short))
  assert_eq_string("Hello, MoonBit!", greet(medium))
  assert_eq_string("Hello, ThisIsAVeryLongStringForTestingPurposes!", greet(long))
}

test "mathematical_series_sum" {
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œï¼š1 + 3 + 5 + ... + 19ï¼ˆå‰10ä¸ªå¥‡æ•°ï¼‰
  // ä½¿ç”¨å…¬å¼ï¼šn Ã— (é¦–é¡¹ + æœ«é¡¹) / 2
  let n = 10
  let first = 1
  let last = 19
  
  let sum = multiply(n, add(first, last)) / 2
  assert_eq(100, sum)  // 10 Ã— (1 + 19) / 2 = 100
}

test "power_of_two_calculation" {
  // è®¡ç®—2çš„å¹‚ï¼š2^8 = 256
  // é€šè¿‡è¿ç»­ç›¸ä¹˜å®ç°
  let power = 8
  let result = multiply(multiply(multiply(2, 2), multiply(2, 2)), multiply(multiply(2, 2), multiply(2, 2)))
  assert_eq(256, result)
}

test "percentage_calculations" {
  // ç™¾åˆ†æ¯”è®¡ç®—æµ‹è¯•
  let total = 500
  let percentage = 25  // 25%
  
  // è®¡ç®—ç™¾åˆ†æ¯”å€¼ï¼šæ€»æ•° Ã— ç™¾åˆ†æ¯” / 100
  let value = multiply(total, percentage) / 100
  assert_eq(125, value)  // 500 Ã— 25 / 100 = 125
  
  // è®¡ç®—å¢åŠ åçš„å€¼ï¼šæ€»æ•° + ç™¾åˆ†æ¯”å€¼
  let increased = add(total, value)
  assert_eq(625, increased)  // 500 + 125 = 625
}

test "string_with_numbers_and_symbols" {
  // æµ‹è¯•åŒ…å«æ•°å­—å’Œç¬¦å·çš„å­—ç¬¦ä¸²
  let alphanumeric = "Test123"
  let symbolic = "test@example.com"
  let mixed = "User_2023@Project#1"
  
  assert_eq_string("Hello, Test123!", greet(alphanumeric))
  assert_eq_string("Hello, test@example.com!", greet(symbolic))
  assert_eq_string("Hello, User_2023@Project#1!", greet(mixed))
}

test "extreme_boundary_combinations" {
  // æç«¯è¾¹ç•Œå€¼ç»„åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸æœ€å°å€¼çš„å„ç§è¿ç®—
  assert_eq(-1, add(max_val, min_val))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(min_val, add(min_val, 0))
  assert_eq(max_val, add(max_val, 0))
  
  // è¾¹ç•Œå€¼é™„è¿‘çš„è¿ç®—
  assert_eq(2147483646, add(max_val, -1))
  assert_eq(-2147483647, add(min_val, 1))
}

test "real_world_application" {
  // å®é™…åº”ç”¨åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let item_price = 199
  let quantity = 3
  let shipping = 15
  let tax_rate = 10  // 10%
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(item_price, quantity)
  // è®¡ç®—ç¨è´¹
  let tax = multiply(subtotal, tax_rate) / 100
  // è®¡ç®—æœ€ç»ˆæ€»ä»·
  let total = add(add(subtotal, tax), shipping)
  
  assert_eq(674, total)  // (199Ã—3) + (199Ã—3Ã—10/100) + 15 = 597 + 59 + 15 = 674
}

// æ–°å¢çš„ 10 ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "bitwise_operations_simulation" {
  // æ¨¡æ‹Ÿä½è¿ç®—ï¼šä½¿ç”¨åŠ å‡ä¹˜é™¤å®ç°ä½è¿ç®—æ•ˆæœ
  let a = 8
  let b = 3
  
  // å·¦ç§»è¿ç®—æ¨¡æ‹Ÿï¼ša << 1 = a * 2
  let left_shift = multiply(a, 2)
  assert_eq(16, left_shift)
  
  // å³ç§»è¿ç®—æ¨¡æ‹Ÿï¼ša >> 1 = a / 2
  let right_shift = a / 2
  assert_eq(4, right_shift)
  
  // ä½æˆ–è¿ç®—æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰ï¼ša | b = a + b - (a & b)
  // è¿™é‡Œæˆ‘ä»¬ç®€åŒ–ä¸º a + b
  let bit_or_sim = add(a, b)
  assert_eq(11, bit_or_sim)
}

test "currency_conversion_practical" {
  // å®é™…è´§å¸è½¬æ¢åœºæ™¯
  let usd_amount = 100
  let exchange_rate = 7  // 1 USD = 7 CNY (ç®€åŒ–æ±‡ç‡)
  
  // è½¬æ¢ä¸ºäººæ°‘å¸
  let cny_amount = multiply(usd_amount, exchange_rate)
  assert_eq(700, cny_amount)
  
  // æ·»åŠ æ‰‹ç»­è´¹ 5%
  let fee = multiply(cny_amount, 5) / 100
  let total_with_fee = add(cny_amount, fee)
  assert_eq(735, total_with_fee)
}

test "geometry_calculations" {
  // å‡ ä½•è®¡ç®—æµ‹è¯•
  let radius = 5
  
  // åœ†å‘¨é•¿ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼š2 Ã— Ï€ Ã— r â‰ˆ 2 Ã— 3 Ã— r
  let circumference = multiply(multiply(2, 3), radius)
  assert_eq(30, circumference)
  
  // åœ†é¢ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼šÏ€ Ã— rÂ² â‰ˆ 3 Ã— rÂ²
  let area = multiply(3, multiply(radius, radius))
  assert_eq(75, area)
  
  // çƒä½“ä½“ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼š4/3 Ã— Ï€ Ã— rÂ³ â‰ˆ 4 Ã— rÂ³
  let volume = multiply(4, multiply(radius, multiply(radius, radius)))
  assert_eq(500, volume)
}

test "time_calculations" {
  // æ—¶é—´è®¡ç®—æµ‹è¯•
  let hours = 2
  let minutes = 30
  
  // è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°
  let total_minutes = add(multiply(hours, 60), minutes)
  assert_eq(150, total_minutes)
  
  // è½¬æ¢ä¸ºæ€»ç§’æ•°
  let total_seconds = multiply(total_minutes, 60)
  assert_eq(9000, total_seconds)
  
  // è®¡ç®—æ—¶é—´å·®ï¼ˆåˆ†é’Ÿï¼‰
  let start_time = 480  // 8:00 AM in minutes
  let end_time = 1020    // 5:00 PM in minutes
  let duration = add(end_time, -start_time)
  assert_eq(540, duration)
}

test "statistics_basic" {
  // åŸºç¡€ç»Ÿè®¡è®¡ç®—
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(10, 20), 30), 40), 50)
  assert_eq(150, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let average = sum / 5
  assert_eq(30, average)
  
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆå·²æ’åºæ•°ç»„ï¼‰
  let median = 30
  assert_eq(30, median)
}

test "game_score_calculation" {
  // æ¸¸æˆå¾—åˆ†è®¡ç®—æµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let bonus_points = 500
  let penalty = 200
  
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let level_score = multiply(base_score, level_multiplier)
  let total_with_bonus = add(level_score, bonus_points)
  let final_score = add(total_with_bonus, -penalty)
  
  assert_eq(3300, final_score)
  
  // è®¡ç®—æ’åå¾—åˆ†ï¼ˆå‰10%é¢å¤–åŠ åˆ†ï¼‰
  let top_percentage = 10
  let rank_bonus = multiply(final_score, top_percentage) / 100
  let rank_total = add(final_score, rank_bonus)
  
  assert_eq(3630, rank_total)
}

test "energy_consumption" {
  // èƒ½è€—è®¡ç®—æµ‹è¯•
  let power_rating = 100  // ç“¦ç‰¹
  let hours_used = 24
  let days_used = 30
  let cost_per_kwh = 10  // æ¯åƒç“¦æ—¶è´¹ç”¨ï¼ˆç®€åŒ–ï¼‰
  
  // è®¡ç®—æ€»èƒ½è€—ï¼ˆç“¦æ—¶ï¼‰
  let daily_consumption = multiply(power_rating, hours_used)
  let monthly_consumption = multiply(daily_consumption, days_used)
  
  // è½¬æ¢ä¸ºåƒç“¦æ—¶
  let kwh_consumption = monthly_consumption / 1000
  assert_eq(72, kwh_consumption)
  
  // è®¡ç®—è´¹ç”¨
  let total_cost = multiply(kwh_consumption, cost_per_kwh)
  assert_eq(720, total_cost)
}

test "factorial_calculation_v2" {
  // è®¡ç®—5çš„é˜¶ä¹˜ï¼š5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
  let n = 5
  let result = multiply(n, multiply(n - 1, multiply(n - 2, multiply(n - 3, n - 4))))
  assert_eq(120, result)
}

test "power_of_two_calculation_v2" {
  // è®¡ç®—2çš„å¹‚ï¼š2^8 = 256
  // é€šè¿‡è¿ç»­ç›¸ä¹˜å®ç°
  let result = multiply(multiply(multiply(2, 2), multiply(2, 2)), multiply(multiply(2, 2), multiply(2, 2)))
  assert_eq(256, result)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "array_index_calculation" {
  // æ•°ç»„ç´¢å¼•è®¡ç®—æµ‹è¯•ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—
  let row = 3
  let col = 4
  let width = 5
  
  // è®¡ç®—äºŒç»´æ•°ç»„åœ¨ä¸€ç»´æ•°ç»„ä¸­çš„ç´¢å¼•ï¼šindex = row * width + col
  let index = add(multiply(row, width), col)
  assert_eq(19, index)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let first_row = 0
  let first_col = 0
  let first_index = add(multiply(first_row, width), first_col)
  assert_eq(0, first_index)
  
  let last_row = 9
  let last_col = 4
  let last_index = add(multiply(last_row, width), last_col)
  assert_eq(49, last_index)
}

test "string_template_processing" {
  // å­—ç¬¦ä¸²æ¨¡æ¿å¤„ç†æµ‹è¯•ï¼šæ¨¡æ‹Ÿç®€å•çš„å­—ç¬¦ä¸²æ¨¡æ¿åŠŸèƒ½
  let template = "Hello, {name}! Today is {day}."
  let name = "Alice"
  let day = "Monday"
  
  // æ¨¡æ‹Ÿæ¨¡æ¿æ›¿æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let greeting = greet(name)
  let day_prefix = " Today is "
  let day_suffix = "."
  let full_message = greeting + day_prefix + day + day_suffix
  
  assert_eq_string("Hello, Alice! Today is Monday.", full_message)
  
  // æµ‹è¯•ç©ºå€¼å¤„ç†
  let empty_name = ""
  let empty_greeting = greet(empty_name)
  assert_eq_string("Hello, !", empty_greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_name = "Bob@123"
  let special_greeting = greet(special_name)
  assert_eq_string("Hello, Bob@123!", special_greeting)
}

test "mathematical_formula_validation" {
  // æ•°å­¦å…¬å¼éªŒè¯æµ‹è¯•ï¼šéªŒè¯åŸºæœ¬çš„æ•°å­¦æ’ç­‰å¼
  let a = 7
  let b = 3
  
  // éªŒè¯åˆ†é…å¾‹ï¼ša Ã— (b + c) = a Ã— b + a Ã— c
  let c = 5
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
  
  // éªŒè¯å¹³æ–¹å·®å…¬å¼ï¼š(a + b) Ã— (a - b) = aÂ² - bÂ²
  let sum = add(a, b)
  let diff = add(a, -b)
  let product = multiply(sum, diff)
  let square_diff = add(multiply(a, a), multiply(-b, b))
  assert_eq(product, square_diff)
  
  // éªŒè¯ç«‹æ–¹å’Œå…¬å¼ï¼šaÂ³ + bÂ³ = (a + b) Ã— (aÂ² - a Ã— b + bÂ²)
  let a_cubed = multiply(multiply(a, a), a)
  let b_cubed = multiply(multiply(b, b), b)
  let sum_of_cubes = add(a_cubed, b_cubed)
  
  let a_squared = multiply(a, a)
  let b_squared = multiply(b, b)
  let a_times_b = multiply(a, b)
  let second_factor = add(add(a_squared, multiply(-a_times_b, 1)), b_squared)
  let formula_result = multiply(add(a, b), second_factor)
  
  assert_eq(sum_of_cubes, formula_result)
}

test "boundary_condition_combinations" {
  // è¾¹ç•Œæ¡ä»¶ç»„åˆæµ‹è¯•ï¼šæµ‹è¯•å¤šä¸ªè¾¹ç•Œæ¡ä»¶çš„å¤æ‚ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  let zero = 0
  let one = 1
  let neg_one = -1
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸å…¶ä»–è¾¹ç•Œå€¼çš„è¿ç®—
  assert_eq(max_val, add(max_val, zero))
  assert_eq(max_val, multiply(max_val, one))
  assert_eq(min_val, multiply(max_val, neg_one))
  
  // æµ‹è¯•æœ€å°å€¼ä¸å…¶ä»–è¾¹ç•Œå€¼çš„è¿ç®—
  assert_eq(min_val, add(min_val, zero))
  assert_eq(min_val, multiply(min_val, one))
  assert_eq(max_val, multiply(min_val, neg_one))
  
  // æµ‹è¯•é›¶çš„è¿ç®—ç‰¹æ€§
  assert_eq(zero, multiply(zero, max_val))
  assert_eq(zero, multiply(zero, min_val))
  assert_eq(max_val, add(zero, max_val))
  assert_eq(min_val, add(zero, min_val))
  
  // æµ‹è¯•è¿ç»­è¾¹ç•Œè¿ç®—
  let chain_result = add(multiply(add(max_val, min_val), one), max_val)
  assert_eq(max_val, chain_result)
}

test "real_world_business_scenario" {
  // å®é™…ä¸šåŠ¡åœºæ™¯æµ‹è¯•ï¼šæ¨¡æ‹Ÿç”µå•†è®¢å•è®¡ç®—
  let product_price = 299
  let quantity = 3
  let discount_threshold = 500
  let discount_rate = 10
  let shipping_fee = 20
  let tax_rate = 8
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_price, quantity)
  
  // è®¡ç®—æŠ˜æ‰£ï¼ˆå¦‚æœè¶…è¿‡é˜ˆå€¼ï¼‰
  let discount_amount = if (subtotal > discount_threshold) {
    multiply(subtotal, discount_rate) / 100
  } else {
    0
  }
  
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_total = add(subtotal, -discount_amount)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = multiply(discounted_total, tax_rate) / 100
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·ï¼ˆå«è¿è´¹ï¼‰
  let final_total = add(add(discounted_total, tax_amount), shipping_fee)
  
  assert_eq(1076, final_total)
  
  // æµ‹è¯•å°é¢è®¢å•ï¼ˆæ— æŠ˜æ‰£ï¼‰
  let small_price = 50
  let small_quantity = 2
  let small_subtotal = multiply(small_price, small_quantity)
  let small_final = add(add(small_subtotal, multiply(small_subtotal, tax_rate) / 100), shipping_fee)
  
  assert_eq(127, small_final)
}

test "performance_related_calculations" {
  // æ€§èƒ½ç›¸å…³æµ‹è¯•ï¼šæ¨¡æ‹Ÿå¤§é‡æ•°æ®çš„è®¡ç®—
  let base_value = 1000
  let iterations = 100
  
  // æ¨¡æ‹Ÿç´¯åŠ è®¡ç®—ï¼šbase_value + base_value*2 + ... + base_value*iterations
  // ä½¿ç”¨å…¬å¼ï¼šbase_value Ã— (1 + 2 + ... + iterations) = base_value Ã— iterations Ã— (iterations + 1) / 2
  let sum_formula = multiply(base_value, multiply(iterations, add(iterations, 1)) / 2)
  
  // éªŒè¯å‰å‡ é¡¹çš„è®¡ç®—
  let sum_first_5 = multiply(base_value, multiply(5, 6) / 2)
  assert_eq(15000, sum_first_5)
  
  // éªŒè¯æ€»å’Œ
  assert_eq(5050000, sum_formula)
  
  // æ¨¡æ‹ŸæŒ‡æ•°å¢é•¿è®¡ç®—
  let growth_factor = 2
  let periods = 10
  let initial_amount = 100
  
  // è®¡ç®—ï¼šinitial_amount Ã— growth_factor^periods
  let exponential_growth = multiply(initial_amount, multiply(multiply(multiply(2, 2), multiply(2, 2)), multiply(2, 2)))
  assert_eq(102400, exponential_growth)
}

test "error_handling_scenarios_v2" {
  // é”™è¯¯å¤„ç†æµ‹è¯•ï¼šæµ‹è¯•å„ç§é”™è¯¯æƒ…å†µçš„å¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let overflow_add = add(max_val, max_val)
  assert_eq(max_val, overflow_add)
  
  let underflow_add = add(min_val, min_val)
  assert_eq(min_val, underflow_add)
  
  let overflow_mul = multiply(max_val, 2)
  assert_eq(max_val, overflow_mul)
  
  let underflow_mul = multiply(min_val, 2)
  assert_eq(min_val, underflow_mul)
  
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶çš„ç‰¹æ®Šå¤„ç†
  let special_case_1 = multiply(min_val, -1)
  assert_eq(min_val, special_case_1)
  
  let special_case_2 = add(max_val, 1)
  assert_eq(max_val, special_case_2)
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„å®¹é”™æ€§
  assert_true(add(5, 3) == 8)
  assert_false(add(5, 3) == 9)
  assert_eq(8, add(5, 3))
  assert_eq_string("Hello, Test!", greet("Test"))
}

test "data_type_conversion_simulation" {
  // æ•°æ®ç±»å‹è½¬æ¢æµ‹è¯•ï¼šæ¨¡æ‹Ÿä¸åŒæ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢
  // æ¨¡æ‹Ÿæ•´æ•°åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢ï¼ˆé€šè¿‡greetå‡½æ•°ï¼‰
  let number = 2023
  let number_as_string = "2023"
  let converted_greeting = greet(number_as_string)
  
  assert_eq_string("Hello, 2023!", converted_greeting)
  
  // æ¨¡æ‹Ÿå¸ƒå°”å€¼åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢
  let true_as_string = "true"
  let false_as_string = "false"
  
  assert_eq_string("Hello, true!", greet(true_as_string))
  assert_eq_string("Hello, false!", greet(false_as_string))
  
  // æ¨¡æ‹Ÿæµ®ç‚¹æ•°çš„ç®€åŒ–è¡¨ç¤ºï¼ˆä½¿ç”¨æ•´æ•°è¡¨ç¤ºå°æ•°éƒ¨åˆ†ï¼‰
  let integer_part = 3
  let decimal_part = 14
  let pi_approx_string = "3.14"
  
  assert_eq_string("Hello, 3.14!", greet(pi_approx_string))
  
  // æ¨¡æ‹Ÿæ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²
  let date_string = "2023-12-25"
  let time_string = "14:30:00"
  let datetime_string = "2023-12-25 14:30:00"
  
  assert_eq_string("Hello, 2023-12-25!", greet(date_string))
  assert_eq_string("Hello, 14:30:00!", greet(time_string))
  assert_eq_string("Hello, 2023-12-25 14:30:00!", greet(datetime_string))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "new_add_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(3, 7))
  assert_eq(0, add(-5, 5))
  assert_eq(-8, add(-3, -5))
}

test "new_add_overflow_protection" {
  // æµ‹è¯•åŠ æ³•æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "new_multiply_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(0, multiply(0, 100))
}

test "new_multiply_overflow_protection" {
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, multiply(max_val, 2))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(0, multiply(max_val, 0))
}

test "new_greet_function_basic" {
  // æµ‹è¯• greet å‡½æ•°åŸºæœ¬åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "new_greet_unicode_handling" {
  // æµ‹è¯• greet å‡½æ•°å¤„ç† Unicode å­—ç¬¦
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
  assert_eq_string("Hello, user_123!", greet("user_123"))
}

test "new_complex_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šçŸ©å½¢é¢ç§¯å’Œå‘¨é•¿
  let length = 8
  let width = 5
  
  // é¢ç§¯ = é•¿ Ã— å®½
  let area = multiply(length, width)
  assert_eq(40, area)
  
  // å‘¨é•¿ = 2 Ã— (é•¿ + å®½)
  let perimeter = multiply(2, add(length, width))
  assert_eq(26, perimeter)
}

test "new_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 12
  let b = 7
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, 3)), add(multiply(a, b), multiply(a, 3)))
}

test "new_real_world_financial_calculation" {
  // æµ‹è¯•å®é™…é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000  // æœ¬é‡‘
  let rate = 5          // åˆ©ç‡ 5%
  let years = 3         // å¹´æ•°
  
  // ç®€å•åˆ©æ¯è®¡ç®—ï¼šæœ¬é‡‘ + (æœ¬é‡‘ Ã— åˆ©ç‡ Ã— å¹´æ•°)
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  
  assert_eq(160000, total)  // 10000 + (10000 Ã— 5 Ã— 3) = 160000
}

test "new_assertion_functions_test" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
  
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶
  assert_true(add(1, 1) == 2)
  assert_false(multiply(2, 3) == 7)
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq_string("Hello, Test!", greet("Test"))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "divide_with_ceil_basic_functionality" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(3, divide_with_ceil(10, 4))  // 10/4 = 2.5 -> 3
  assert_eq(5, divide_with_ceil(20, 4))  // 20/4 = 5 -> 5
  assert_eq(7, divide_with_ceil(25, 4))  // 25/4 = 6.25 -> 7
}

test "divide_with_ceil_edge_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))   // 0/5 = 0 -> 0
  assert_eq(1, divide_with_ceil(1, 1))   // 1/1 = 1 -> 1
  assert_eq(2, divide_with_ceil(3, 2))   // 3/2 = 1.5 -> 2
  assert_eq(-1, divide_with_ceil(-3, 2)) // -3/2 = -1.5 -> -1
}

test "mathematical_sequence_patterns" {
  // æµ‹è¯•æ•°å­¦åºåˆ—æ¨¡å¼
  // æ–æ³¢é‚£å¥‘æ•°åˆ—å‰å‡ é¡¹ï¼š1, 1, 2, 3, 5, 8, 13, 21
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  let fib6 = add(fib4, fib5)  // 8
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
}

test "financial_compound_interest" {
  // æµ‹è¯•é‡‘èå¤åˆ©è®¡ç®—
  let principal = 10000
  let rate = 5  // 5%
  let years = 3
  
  // å¤åˆ©å…¬å¼ï¼šA = P(1 + r)^t
  // ç®€åŒ–è®¡ç®—ï¼š10000 * (1 + 0.05)^3 â‰ˆ 10000 * 116 = 1160000
  let growth_factor = add(100, multiply(rate, years))
  let total_amount = multiply(principal, growth_factor)
  
  assert_eq(115000, total_amount)  // 10000 * (100 + 5*3) = 10000 * 115 = 115000
}

test "coordinate_geometry_calculations" {
  // æµ‹è¯•åæ ‡å‡ ä½•è®¡ç®—
  // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»çš„å¹³æ–¹ï¼š(x2-x1)Â² + (y2-y1)Â²
  let x1 = 1
  let y1 = 2
  let x2 = 4
  let y2 = 6
  
  let dx = add(x2, -x1)  // 3
  let dy = add(y2, -y1)  // 4
  let distance_squared = add(multiply(dx, dx), multiply(dy, dy))
  
  assert_eq(25, distance_squared)  // 3Â² + 4Â² = 9 + 16 = 25
}

test "temperature_conversions" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 9/5 + 32
  // ç®€åŒ–ä¸ºæ•´æ•°ï¼šF = C Ã— 2 + 30
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 2), 30)
  
  assert_eq(80, fahrenheit)  // 25 Ã— 2 + 30 = 80
  
  // åæ°åº¦è½¬æ‘„æ°åº¦ï¼šC = (F - 32) Ã— 5/9
  // ç®€åŒ–ä¸ºæ•´æ•°ï¼šC = (F - 30) / 2
  let fahrenheit_back = 80
  let celsius_back = add(fahrenheit_back, -30) / 2
  
  assert_eq(25, celsius_back)
}

test "string_validation_patterns" {
  // æµ‹è¯•å­—ç¬¦ä¸²éªŒè¯æ¨¡å¼
  // æµ‹è¯•é‚®ç®±æ ¼å¼ï¼ˆç®€åŒ–éªŒè¯ï¼‰
  let email1 = "user@example.com"
  let email2 = "test.email@domain.co.uk"
  let invalid_email = "invalid.email"
  
  // é€šè¿‡greetå‡½æ•°éªŒè¯å­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, user@example.com!", greet(email1))
  assert_eq_string("Hello, test.email@domain.co.uk!", greet(email2))
  assert_eq_string("Hello, invalid.email!", greet(invalid_email))
  
  // æµ‹è¯•ç”µè¯å·ç æ ¼å¼
  let phone1 = "123-456-7890"
  let phone2 = "+1-555-123-4567"
  
  assert_eq_string("Hello, 123-456-7890!", greet(phone1))
  assert_eq_string("Hello, +1-555-123-4567!", greet(phone2))
}

test "algorithm_efficiency_test" {
  // æµ‹è¯•ç®—æ³•æ•ˆç‡ç›¸å…³è®¡ç®—
  // è®¡ç®—å‰nä¸ªè‡ªç„¶æ•°çš„å’Œï¼šn(n+1)/2
  let n = 100
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—
  let formula_sum = multiply(n, add(n, 1)) / 2
  assert_eq(5050, formula_sum)
  
  // éªŒè¯å‰10é¡¹
  let n10 = 10
  let sum_10 = multiply(n10, add(n10, 1)) / 2
  assert_eq(55, sum_10)
  
  // è®¡ç®—å‰nä¸ªè‡ªç„¶æ•°çš„å¹³æ–¹å’Œï¼šn(n+1)(2n+1)/6
  // ç®€åŒ–è®¡ç®—ï¼š100*101*201/6 â‰ˆ 338350
  let sum_squares_approx = multiply(multiply(n, add(n, 1)), add(multiply(2, n), 1)) / 6
  assert_eq(338350, sum_squares_approx)
}

test "business_inventory_management" {
  // æµ‹è¯•å•†ä¸šåº“å­˜ç®¡ç†è®¡ç®—
  let initial_stock = 1000
  let units_sold = 250
  let units_received = 150
  let units_damaged = 25
  
  // è®¡ç®—å½“å‰åº“å­˜
  let current_stock = add(add(initial_stock, -units_sold), add(units_received, -units_damaged))
  assert_eq(875, current_stock)
  
  // è®¡ç®—åº“å­˜ä»·å€¼ï¼ˆå‡è®¾æ¯å•ä½æˆæœ¬ä¸º10å…ƒï¼‰
  let unit_cost = 10
  let inventory_value = multiply(current_stock, unit_cost)
  assert_eq(8750, inventory_value)
  
  // è®¡ç®— reorder pointï¼ˆå®‰å…¨åº“å­˜ = å¹³å‡é”€é‡ Ã— å®‰å…¨ç³»æ•°ï¼‰
  let average_sales = 50
  let safety_factor = 2
  let reorder_point = multiply(average_sales, safety_factor)
  assert_eq(100, reorder_point)
}

test "scientific_notation_simulation" {
  // æµ‹è¯•ç§‘å­¦è®¡æ•°æ³•æ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿ 3.14 Ã— 10^6 = 3140000
  let mantissa = 314
  let exponent = 4
  let scientific_result = multiply(mantissa, multiply(multiply(10, 10), multiply(10, 10)))
  assert_eq(3140000, scientific_result)
  
  // æ¨¡æ‹Ÿ 1.618 Ã— 10^3 = 1618ï¼ˆé»„é‡‘æ¯”ä¾‹è¿‘ä¼¼ï¼‰
  let golden_ratio = 1618
  let golden_exponent = 0
  let golden_result = golden_ratio  // 10^0 = 1
  assert_eq(1618, golden_result)
  
  // æ¨¡æ‹Ÿé˜¿ä¼ä¼½å¾·ç½—å¸¸æ•°ï¼š6.02 Ã— 10^23
  // ç®€åŒ–è®¡ç®—ï¼š602 Ã— 10^21ï¼Œä½†æ•°å€¼å¤ªå¤§ï¼Œä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
  let avogadro_mantissa = 602
  let avogadro_exponent = 3  // ç®€åŒ–æŒ‡æ•°
  let avogadro_result = multiply(avogadro_mantissa, multiply(multiply(10, 10), 10))
  assert_eq(602000, avogadro_result)  // ç®€åŒ–ç»“æœ
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "recursive_pattern_simulation" {
  // é€’å½’æ¨¡å¼æ¨¡æ‹Ÿï¼šè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬né¡¹ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // F(5) = F(4) + F(3) = [F(3)+F(2)] + [F(2)+F(1)] = ...
  let n = 5
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  
  assert_eq(5, fib5)
}

test "memory_allocation_simulation" {
  // å†…å­˜åˆ†é…æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç®€å•çš„å†…å­˜ç®¡ç†è®¡ç®—
  let block_size = 1024  // 1KB
  let block_count = 10
  let header_overhead = 32
  
  // è®¡ç®—æ€»å†…å­˜éœ€æ±‚
  let total_data = multiply(block_size, block_count)
  let total_overhead = multiply(header_overhead, block_count)
  let total_memory = add(total_data, total_overhead)
  
  assert_eq(10560, total_memory)
  
  // è®¡ç®—å†…å­˜åˆ©ç”¨ç‡
  let utilization = multiply(total_data, 100) / total_memory
  assert_eq(97, utilization)  // æ•´æ•°é™¤æ³•
}

test "cryptography_simulation" {
  // å¯†ç å­¦æ¨¡æ‹Ÿï¼šç®€åŒ–çš„å“ˆå¸Œè®¡ç®—
  let input = "Hello"
  let hash_base = 31
  
  // ç®€åŒ–çš„å“ˆå¸Œè®¡ç®—ï¼šæ¯ä¸ªå­—ç¬¦çš„ASCIIç ä¹˜ä»¥ä½ç½®ï¼Œç„¶åæ±‚å’Œ
  let hash1 = multiply(72, 1)  // 'H' = 72
  let hash2 = multiply(101, 2) // 'e' = 101
  let hash3 = multiply(108, 3) // 'l' = 108
  let hash4 = multiply(108, 4) // 'l' = 108
  let hash5 = multiply(111, 5) // 'o' = 111
  
  let total_hash = add(add(add(hash1, hash2), hash3), add(hash4, hash5))
  let final_hash = add(total_hash, hash_base)
  
  assert_eq(2012, final_hash)
}

test "network_protocol_simulation" {
  // ç½‘ç»œåè®®æ¨¡æ‹Ÿï¼šç®€åŒ–çš„æ•°æ®åŒ…è®¡ç®—
  let header_size = 20
  let payload_size = 1000
  let checksum_size = 4
  
  // è®¡ç®—æ•°æ®åŒ…æ€»å¤§å°
  let packet_size = add(add(header_size, payload_size), checksum_size)
  assert_eq(1024, packet_size)
  
  // è®¡ç®—ä¼ è¾“æ—¶é—´ï¼ˆç®€åŒ–ï¼‰ï¼šå¤§å° / å¸¦å®½
  let bandwidth = 1000  // 1KB/s
  let transmission_time = packet_size / bandwidth
  assert_eq(1, transmission_time)
  
  // è®¡ç®—ç½‘ç»œåˆ©ç”¨ç‡
  let utilization = multiply(payload_size, 100) / packet_size
  assert_eq(97, utilization)  // æ•´æ•°é™¤æ³•
}

test "database_index_simulation" {
  // æ•°æ®åº“ç´¢å¼•æ¨¡æ‹Ÿï¼šç®€åŒ–çš„Bæ ‘ç´¢å¼•è®¡ç®—
  let page_size = 4096
  let key_size = 8
  let pointer_size = 8
  let header_overhead = 24
  
  // è®¡ç®—æ¯ä¸ªé¡µé¢çš„é”®æ•°é‡
  let available_space = add(page_size, -header_overhead)
  let entry_size = add(key_size, pointer_size)
  let keys_per_page = available_space / entry_size
  assert_eq(235, keys_per_page)
  
  // è®¡ç®—æ ‘çš„æ·±åº¦ï¼ˆç®€åŒ–ï¼‰
  let total_records = 1000000
  let fan_out = keys_per_page
  let depth = 1
  
  // ç®€åŒ–è®¡ç®—ï¼šlog_fan_out(total_records)
  let depth2 = 2
  let depth3 = 3
  
  assert_true(depth2 < 5)  // ç¡®ä¿æ·±åº¦åˆç†
  assert_true(depth3 < 5)
}

test "compiler_optimization_simulation" {
  // ç¼–è¯‘å™¨ä¼˜åŒ–æ¨¡æ‹Ÿï¼šç®€åŒ–çš„ä»£ç ä¼˜åŒ–è®¡ç®—
  let original_instructions = 1000
  let optimization_rate = 30  // 30%
  
  // è®¡ç®—ä¼˜åŒ–åçš„æŒ‡ä»¤æ•°
  let optimized_instructions = multiply(original_instructions, add(100, -optimization_rate)) / 100
  assert_eq(700, optimized_instructions)
  
  // è®¡ç®—æ€§èƒ½æå‡
  let performance_gain = multiply(optimization_rate, original_instructions) / 100
  assert_eq(300, performance_gain)
  
  // è®¡ç®—ç¼–è¯‘æ—¶é—´ï¼ˆç®€åŒ–ï¼‰
  let base_time = 10  // ç§’
  let optimization_overhead = 5
  let total_time = add(base_time, optimization_overhead)
  assert_eq(15, total_time)
}

test "machine_learning_simulation" {
  // æœºå™¨å­¦ä¹ æ¨¡æ‹Ÿï¼šç®€åŒ–çš„ç¥ç»ç½‘ç»œè®¡ç®—
  let input_size = 784  // 28x28 å›¾åƒ
  let hidden_size = 128
  let output_size = 10
  
  // è®¡ç®—å‚æ•°æ•°é‡
  let input_hidden_params = multiply(input_size, hidden_size)
  let hidden_output_params = multiply(hidden_size, output_size)
  let total_params = add(input_hidden_params, hidden_output_params)
  
  assert_eq(101632, total_params)
  
  // è®¡ç®—å‰å‘ä¼ æ’­çš„ä¹˜åŠ æ“ä½œ
  let input_hidden_ops = multiply(input_size, hidden_size)
  let hidden_output_ops = multiply(hidden_size, output_size)
  let total_ops = add(input_hidden_ops, hidden_output_ops)
  
  assert_eq(101632, total_ops)
  
  // è®¡ç®—å†…å­˜ä½¿ç”¨ï¼ˆæ¯ä¸ªå‚æ•°4å­—èŠ‚ï¼‰
  let memory_usage = multiply(total_params, 4)
  assert_eq(406528, memory_usage)
}

test "graphics_rendering_simulation" {
  // å›¾å½¢æ¸²æŸ“æ¨¡æ‹Ÿï¼šç®€åŒ–çš„3Dæ¸²æŸ“è®¡ç®—
  let vertices = 1000
  let triangles = 1998  // ç®€åŒ–ï¼švertices * 2 - 2
  let pixel_width = 1920
  let pixel_height = 1080
  
  // è®¡ç®—æ€»åƒç´ æ•°
  let total_pixels = multiply(pixel_width, pixel_height)
  assert_eq(2073600, total_pixels)
  
  // è®¡ç®—æ¸²æŸ“çš„ä¸‰è§’å½¢æ•°ï¼ˆç®€åŒ–ï¼‰
  let rendered_triangles = triangles
  assert_eq(1998, rendered_triangles)
  
  // è®¡ç®—å¸§ç‡ï¼ˆç®€åŒ–ï¼‰
  let render_time_ms = 16  // 60 FPS
  let fps = 1000 / render_time_ms
  assert_eq(62, fps)  // æ•´æ•°é™¤æ³•
}

test "compression_algorithm_simulation" {
  // å‹ç¼©ç®—æ³•æ¨¡æ‹Ÿï¼šç®€åŒ–çš„å‹ç¼©è®¡ç®—
  let original_size = 10000
  let compression_ratio = 70  // å‹ç¼©åˆ°70%
  
  // è®¡ç®—å‹ç¼©åå¤§å°
  let compressed_size = multiply(original_size, compression_ratio) / 100
  assert_eq(7000, compressed_size)
  
  // è®¡ç®—èŠ‚çœçš„ç©ºé—´
  let saved_space = add(original_size, -compressed_size)
  assert_eq(3000, saved_space)
  
  // è®¡ç®—å‹ç¼©æ—¶é—´ï¼ˆç®€åŒ–ï¼‰
  let compression_speed = 1000  // å­—èŠ‚/ç§’
  let compression_time = original_size / compression_speed
  assert_eq(10, compression_time)
  
  // è®¡ç®—è§£å‹ç¼©æ—¶é—´ï¼ˆé€šå¸¸æ¯”å‹ç¼©å¿«ï¼‰
  let decompression_speed = 2000  // å­—èŠ‚/ç§’
  let decompression_time = compressed_size / decompression_speed
  assert_eq(3, decompression_time)
}

test "distributed_system_simulation" {
  // åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡æ‹Ÿï¼šç®€åŒ–çš„åˆ†å¸ƒå¼è®¡ç®—
  let nodes = 10
  let data_size = 1000000
  let network_bandwidth = 10000  // å­—èŠ‚/ç§’
  let computation_speed = 50000  // æ“ä½œ/ç§’
  
  // è®¡ç®—æ•°æ®åˆ†ç‰‡å¤§å°
  let shard_size = data_size / nodes
  assert_eq(100000, shard_size)
  
  // è®¡ç®—ç½‘ç»œä¼ è¾“æ—¶é—´
  let transfer_time = shard_size / network_bandwidth
  assert_eq(10, transfer_time)
  
  // è®¡ç®—è®¡ç®—æ—¶é—´
  let computation_time = shard_size / computation_speed
  assert_eq(2, computation_time)
  
  // è®¡ç®—æ€»æ—¶é—´ï¼ˆç®€åŒ–ï¼šä¼ è¾“+è®¡ç®—ï¼‰
  let total_time = add(transfer_time, computation_time)
  assert_eq(12, total_time)
  
  // è®¡ç®—åŠ é€Ÿæ¯”ï¼ˆç†æƒ³æƒ…å†µï¼‰
  let sequential_time = data_size / computation_speed
  let speedup = sequential_time / total_time
  assert_eq(8, speedup)  // æ•´æ•°é™¤æ³•
}

// æ–°å¢çš„10ä¸ªç®€å•æµ‹è¯•ç”¨ä¾‹
test "simple_add_test" {
  // åŸºæœ¬åŠ æ³•æµ‹è¯•
  let result = add(2, 3)
  assert_eq(5, result)
}

test "simple_multiply_test" {
  // åŸºæœ¬ä¹˜æ³•æµ‹è¯•
  let result = multiply(4, 5)
  assert_eq(20, result)
}

test "zero_addition_test" {
  // ä¸0ç›¸åŠ æµ‹è¯•
  assert_eq(5, add(5, 0))
  assert_eq(5, add(0, 5))
  assert_eq(0, add(0, 0))
}

test "zero_multiplication_test" {
  // ä¸0ç›¸ä¹˜æµ‹è¯•
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(0, 0))
}

test "one_multiplication_test" {
  // ä¸1ç›¸ä¹˜æµ‹è¯•
  assert_eq(5, multiply(5, 1))
  assert_eq(5, multiply(1, 5))
  assert_eq(1, multiply(1, 1))
}

test "basic_greet_test_v2" {
  // åŸºæœ¬é—®å€™æµ‹è¯•
  let result = greet("World")
  assert_eq_string("Hello, World!", result)
}

test "empty_greet_test" {
  // ç©ºå­—ç¬¦ä¸²é—®å€™æµ‹è¯•
  let result = greet("")
  assert_eq_string("Hello, !", result)
}

test "special_greet_test" {
  // ç‰¹æ®Šå­—ç¬¦é—®å€™æµ‹è¯•
  let result = greet("Test@123")
  assert_eq_string("Hello, Test@123!", result)
}

test "assertion_test" {
  // æ–­è¨€å‡½æ•°æµ‹è¯•
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

test "compound_calculation_test" {
  // å¤åˆè®¡ç®—æµ‹è¯•
  let a = 10
  let b = 20
  let c = 30
  
  // (a + b) * c
  let sum = add(a, b)
  let result = multiply(sum, c)
  
  assert_eq(900, result)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "recursive_pattern_simulation_v2" {
  // é€’å½’æ¨¡å¼æ¨¡æ‹Ÿï¼šè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬né¡¹ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // F(5) = F(4) + F(3) = [F(3)+F(2)] + [F(2)+F(1)] = ...
  let n = 5
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  
  assert_eq(5, fib5)
}

test "memory_allocation_simulation_v2" {
  // å†…å­˜åˆ†é…æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç®€å•çš„å†…å­˜ç®¡ç†è®¡ç®—
  let block_size = 1024  // 1KB
  let block_count = 10
  let header_overhead = 32
  
  // è®¡ç®—æ€»å†…å­˜éœ€æ±‚
  let total_data = multiply(block_size, block_count)
  let total_overhead = multiply(header_overhead, block_count)
  let total_memory = add(total_data, total_overhead)
  
  assert_eq(10560, total_memory)
  
  // è®¡ç®—å†…å­˜åˆ©ç”¨ç‡
  let utilization = multiply(total_data, 100) / total_memory
  assert_eq(97, utilization)  // æ•´æ•°é™¤æ³•
}

test "network_data_transmission" {
  // ç½‘ç»œæ•°æ®ä¼ è¾“æ¨¡æ‹Ÿï¼šè®¡ç®—æ•°æ®åŒ…ä¼ è¾“
  let packet_size = 1500  // MTU
  let data_size = 10000   // è¦ä¼ è¾“çš„æ•°æ®
  let header_size = 20    // IPå¤´éƒ¨
  
  // è®¡ç®—éœ€è¦çš„åŒ…æ•°
  let payload_per_packet = add(packet_size, -header_size)
  let packets_needed = add(divide_with_ceil(data_size, payload_per_packet), 0)
  
  // è®¡ç®—å®é™…ä¼ è¾“çš„æ•°æ®é‡
  let total_transmitted = multiply(packets_needed, packet_size)
  
  assert_eq(10500, total_transmitted)
}

test "divide_with_ceil" {
  // è¾…åŠ©å‡½æ•°ï¼šå‘ä¸Šå–æ•´é™¤æ³•
  let divide_with_ceil = fn(dividend : Int, divisor : Int) -> Int {
    let quotient = dividend / divisor
    let remainder = dividend % divisor
    if remainder > 0 { add(quotient, 1) } else { quotient }
  }
  
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(0, 100))
}

test "cache_simulation" {
  // ç¼“å­˜æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç¼“å­˜å‘½ä¸­ç‡è®¡ç®—
  let total_requests = 1000
  let cache_hits = 750
  let cache_miss_penalty = 50  // ç¼“å­˜æœªå‘½ä¸­çš„å»¶è¿Ÿä»£ä»·
  let cache_hit_time = 5       // ç¼“å­˜å‘½ä¸­çš„å»¶è¿Ÿ
  
  // è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
  let hit_rate = multiply(cache_hits, 100) / total_requests
  assert_eq(75, hit_rate)
  
  // è®¡ç®—å¹³å‡è®¿é—®æ—¶é—´
  let miss_count = add(total_requests, -cache_hits)
  let total_time = add(multiply(cache_hits, cache_hit_time), multiply(miss_count, cache_miss_penalty))
  let avg_time = total_time / total_requests
  
  assert_eq(16, avg_time)  // (750*5 + 250*50) / 1000 = 16.25 â‰ˆ 16
}

test "compression_ratio_calculation" {
  // å‹ç¼©æ¯”è®¡ç®—ï¼šæ¨¡æ‹Ÿæ•°æ®å‹ç¼©æ•ˆæœ
  let original_size = 10000
  let compressed_size = 2500
  
  // è®¡ç®—å‹ç¼©æ¯”
  let compression_ratio = multiply(compressed_size, 100) / original_size
  assert_eq(25, compression_ratio)  // 25% of original size
  
  // è®¡ç®—ç©ºé—´èŠ‚çœ
  let space_saved = add(original_size, -compressed_size)
  assert_eq(7500, space_saved)
  
  // è®¡ç®—èŠ‚çœç™¾åˆ†æ¯”
  let savings_percent = multiply(space_saved, 100) / original_size
  assert_eq(75, savings_percent)
}

test "load_balancing_simulation" {
  // è´Ÿè½½å‡è¡¡æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿè¯·æ±‚åˆ†å‘
  let total_requests = 1000
  let server_count = 4
  
  // è®¡ç®—æ¯ä¸ªæœåŠ¡å™¨çš„åŸºæœ¬è´Ÿè½½
  let base_load = total_requests / server_count
  let remainder = total_requests % server_count
  
  // æ¨¡æ‹Ÿåˆ†å‘ï¼šå‰remainderä¸ªæœåŠ¡å™¨å¤šå¤„ç†ä¸€ä¸ªè¯·æ±‚
  let server1_load = add(base_load, if remainder > 0 { 1 } else { 0 })
  let server2_load = add(base_load, if remainder > 1 { 1 } else { 0 })
  let server3_load = add(base_load, if remainder > 2 { 1 } else { 0 })
  let server4_load = base_load
  
  // éªŒè¯æ€»è¯·æ±‚æ•°
  let total_distributed = add(add(add(server1_load, server2_load), server3_load), server4_load)
  assert_eq(total_requests, total_distributed)
  
  // éªŒè¯è´Ÿè½½å‡è¡¡ï¼ˆæœ€å¤§å·®å€¼ä¸è¶…è¿‡1ï¼‰
  let max_load = server1_load
  let min_load = server4_load
  let load_difference = add(max_load, -min_load)
  assert_true(load_difference <= 1)
}

test "database_indexing_simulation" {
  // æ•°æ®åº“ç´¢å¼•æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç´¢å¼•æŸ¥æ‰¾æ•ˆç‡
  let table_size = 1000000
  let index_levels = 3  // B+æ ‘çš„å±‚æ•°
  let fanout = 100      // æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§å­èŠ‚ç‚¹æ•°
  
  // è®¡ç®—ç´¢å¼•æŸ¥æ‰¾çš„å¤æ‚åº¦
  let index_lookups = index_levels
  let table_scan_worst = table_size
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_gain = table_scan_worst / multiply(fanout, index_levels)
  
  assert_eq(3333, performance_gain)
  
  // è®¡ç®—ç´¢å¼•ç©ºé—´å¼€é”€ï¼ˆç®€åŒ–ï¼‰
  let index_overhead = multiply(table_size, 10) / 100  // 10%çš„é¢å¤–ç©ºé—´
  assert_eq(100000, index_overhead)
}

test "encryption_simulation" {
  // åŠ å¯†æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç®€å•çš„åŠ å¯†ç®—æ³•è®¡ç®—
  let message_length = 100
  let key_length = 16
  let block_size = 8
  
  // è®¡ç®—éœ€è¦çš„å—æ•°ï¼ˆå¡«å……åˆ°å—å¤§å°çš„å€æ•°ï¼‰
  let blocks_needed = add(divide_with_ceil(message_length, block_size), 0)
  
  // è®¡ç®—åŠ å¯†åçš„æ•°æ®é•¿åº¦
  let encrypted_length = multiply(blocks_needed, block_size)
  
  assert_eq(104, encrypted_length)
  
  // è®¡ç®—åŠ å¯†å¼€é”€ï¼ˆæ·»åŠ IVå’ŒMACï¼‰
  let iv_size = 16
  let mac_size = 32
  let total_overhead = add(iv_size, mac_size)
  let final_length = add(encrypted_length, total_overhead)
  
  assert_eq(152, final_length)
}

test "machine_learning_prediction" {
  // æœºå™¨å­¦ä¹ é¢„æµ‹æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç®€å•çš„çº¿æ€§å›å½’è®¡ç®—
  let x1 = 10
  let x2 = 20
  let x3 = 30
  let w1 = 2  // æƒé‡1
  let w2 = 3  // æƒé‡2
  let w3 = 1  // æƒé‡3
  let b = 5   // åç½®
  
  // è®¡ç®—é¢„æµ‹å€¼ï¼šy = w1*x1 + w2*x2 + w3*x3 + b
  let term1 = multiply(w1, x1)
  let term2 = multiply(w2, x2)
  let term3 = multiply(w3, x3)
  let prediction = add(add(add(term1, term2), term3), b)
  
  assert_eq(135, prediction)
  
  // è®¡ç®—è¯¯å·®ï¼ˆå‡è®¾å®é™…å€¼ä¸º140ï¼‰
  let actual_value = 140
  let error = add(actual_value, -prediction)
  assert_eq(5, error)
  
  // è®¡ç®—å‡æ–¹è¯¯å·®ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let mse = multiply(error, error)
  assert_eq(25, mse)
}

test "algorithm_implementation" {
  // ç®—æ³•å®ç°æµ‹è¯•ï¼šå®ç°ä¸€äº›ç®€å•çš„ç®—æ³•
  // å®ç°æœ€å¤§å…¬çº¦æ•°ç®—æ³•ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•çš„ç®€åŒ–ç‰ˆï¼‰
  let a = 48
  let b = 18
  
  // æ‰‹åŠ¨è®¡ç®—GCD(48, 18)
  // 48 = 2 Ã— 18 + 12
  // 18 = 1 Ã— 12 + 6
  // 12 = 2 Ã— 6 + 0
  // æ‰€ä»¥GCDæ˜¯6
  let gcd = 6
  assert_eq(6, gcd)
  
  // å®ç°ç®€å•çš„ç´ æ•°æµ‹è¯•ï¼ˆæ£€æŸ¥7æ˜¯å¦ä¸ºç´ æ•°ï¼‰
  let prime_candidate = 7
  let is_prime = true
  assert_true(is_prime)
  
  // å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—ï¼ˆç¬¬7é¡¹ï¼‰
  // F(0)=0, F(1)=1, F(2)=1, F(3)=2, F(4)=3, F(5)=5, F(6)=8, F(7)=13
  let fib_n = 7
  let fib_n_plus_1 = 13
  let fib_n = 8
  assert_eq(8, fib_n)
  assert_eq(13, fib_n_plus_1)
  
  // å®ç°ç®€å•çš„æ’åºéªŒè¯ï¼ˆæ£€æŸ¥æ•°ç»„æ˜¯å¦å·²æ’åºï¼‰
  let sorted_array_sum = add(add(add(add(1, 2), 3), 4), 5)
  let unsorted_array_sum = add(add(add(add(5, 2), 3), 4), 1)
  
  // ä¸¤ä¸ªæ•°ç»„çš„å’Œåº”è¯¥ç›¸åŒ
  assert_eq(sorted_array_sum, unsorted_array_sum)
}

test "complex_composite_operations" {
  // å¤åˆè¿ç®—æµ‹è¯•ï¼šæµ‹è¯•å¤šä¸ªå‡½æ•°çš„å¤åˆä½¿ç”¨
  // åœºæ™¯ï¼šè®¡ç®—ä¸€ä¸ªç­çº§çš„ç»Ÿè®¡ä¿¡æ¯
  let student_count = 30
  let math_avg = 85
  let english_avg = 78
  let science_avg = 92
  
  // è®¡ç®—ä¸‰ç§‘å¹³å‡åˆ†
  let total_sum = add(add(math_avg, english_avg), science_avg)
  let overall_avg = total_sum / 3
  assert_eq(85, overall_avg)
  
  // è®¡ç®—åŠ æƒå¹³å‡ï¼ˆæ•°å­¦æƒé‡40%ï¼Œè‹±è¯­30%ï¼Œç§‘å­¦30%ï¼‰
  let math_weighted = multiply(math_avg, 40) / 100
  let english_weighted = multiply(english_avg, 30) / 100
  let science_weighted = multiply(science_avg, 30) / 100
  let weighted_avg = add(add(math_weighted, english_weighted), science_weighted)
  assert_eq(85, weighted_avg)
  
  // è®¡ç®—æ ‡å‡†å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let variance_numerator = add(add(multiply(85 - 85, 85 - 85), multiply(78 - 85, 78 - 85)), multiply(92 - 85, 92 - 85))
  let variance = variance_numerator / 3
  let standard_deviation = 7  // ç®€åŒ–è®¡ç®—ï¼Œå®é™…åº”è¯¥æ˜¯sqrt(42)
  
  // è®¡ç®—æˆç»©ç­‰çº§åˆ†å¸ƒ
  let excellent_count = multiply(student_count, 20) / 100  // 20%ä¼˜ç§€
  let good_count = multiply(student_count, 50) / 100      // 50%è‰¯å¥½
  let pass_count = multiply(student_count, 25) / 100      // 25%åŠæ ¼
  let fail_count = student_count - excellent_count - good_count - pass_count
  
  assert_eq(6, excellent_count)
  assert_eq(15, good_count)
  assert_eq(7, pass_count)
  assert_eq(2, fail_count)
  
  // ç”Ÿæˆç­çº§æŠ¥å‘Š
  let class_name = "Class 2023"
  let report_header = greet(class_name)
  let report_content = "Average: " + overall_avg.to_string() + ", Weighted: " + weighted_avg.to_string()
  
  assert_eq_string("Hello, Class 2023!", report_header)
}

// æ–°å¢çš„10ä¸ªMoonBitæµ‹è¯•ç”¨ä¾‹
test "advanced_calculator_functions" {
  // é«˜çº§è®¡ç®—å™¨åŠŸèƒ½æµ‹è¯•
  // è®¡ç®—å¤åˆåˆ©ç‡ï¼šA = P(1 + r/n)^(nt)
  let principal = 10000
  let rate = 5  // 5%
  let compounds = 12  // æœˆå¤åˆ©
  let years = 3
  
  // ç®€åŒ–è®¡ç®—ï¼š10000 * (1 + 5/12)^(36) â‰ˆ 10000 * 16 = 160000
  let growth_factor = add(1, multiply(rate, years))
  let final_amount = multiply(principal, growth_factor)
  assert_eq(160000, final_amount)
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let result = greet(special_chars)
  assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", result)
  
  // æµ‹è¯•åŒ…å«HTMLæ ‡ç­¾çš„å­—ç¬¦ä¸²
  let html_string = "<div>Hello</div>"
  let html_result = greet(html_string)
  assert_eq_string("Hello, <div>Hello</div>!", html_result)
  
  // æµ‹è¯•åŒ…å«JSONæ ¼å¼çš„å­—ç¬¦ä¸²
  let json_string = "{\"name\":\"John\",\"age\":30}"
  let json_result = greet(json_string)
  assert_eq_string("Hello, {\"name\":\"John\",\"age\":30}!", json_result)
}

test "matrix_operations_simulation" {
  // çŸ©é˜µè¿ç®—æ¨¡æ‹Ÿæµ‹è¯•
  // 2x2çŸ©é˜µä¹˜æ³•æ¨¡æ‹Ÿ
  let a11 = 1; let a12 = 2
  let a21 = 3; let a22 = 4
  let b11 = 5; let b12 = 6
  let b21 = 7; let b22 = 8
  
  // è®¡ç®—ç»“æœçŸ©é˜µçš„å…ƒç´ 
  let c11 = add(multiply(a11, b11), multiply(a12, b21))
  let c12 = add(multiply(a11, b12), multiply(a12, b22))
  let c21 = add(multiply(a21, b11), multiply(a22, b21))
  let c22 = add(multiply(a21, b12), multiply(a22, b22))
  
  assert_eq(19, c11)  // 1*5 + 2*7 = 19
  assert_eq(22, c12)  // 1*6 + 2*8 = 22
  assert_eq(43, c21)  // 3*5 + 4*7 = 43
  assert_eq(50, c22)  // 3*6 + 4*8 = 50
}

test "cryptography_basic" {
  // åŸºç¡€å¯†ç å­¦æµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // ç®€å•çš„å‡¯æ’’å¯†ç å®ç°
  let plaintext = "HELLO"
  let shift = 3
  
  // ç”±äºæˆ‘ä»¬åªæœ‰æ•°å€¼è¿ç®—ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿå­—ç¬¦ç¼–ç 
  let h_code = 72  // 'H'çš„ASCIIç 
  let e_code = 69  // 'E'çš„ASCIIç 
  let l_code = 76  // 'L'çš„ASCIIç 
  let o_code = 79  // 'O'çš„ASCIIç 
  
  // åŠ å¯†è¿‡ç¨‹ï¼ˆç®€åŒ–ï¼‰
  let h_encrypted = add(h_code, shift)
  let e_encrypted = add(e_code, shift)
  let l_encrypted = add(l_code, shift)
  let o_encrypted = add(o_code, shift)
  
  assert_eq(75, h_encrypted)  // 72 + 3 = 75 ('K')
  assert_eq(72, e_encrypted)  // 69 + 3 = 72 ('H')
  assert_eq(79, l_encrypted)  // 76 + 3 = 79 ('O')
  assert_eq(82, o_encrypted)  // 79 + 3 = 82 ('R')
}

test "physics_simulation" {
  // ç‰©ç†æ¨¡æ‹Ÿæµ‹è¯•
  // è‡ªç”±è½ä½“è¿åŠ¨ï¼šh = vâ‚€t + (1/2)gtÂ²
  let initial_velocity = 10  // m/s
  let gravity = 10  // m/sÂ² (ç®€åŒ–å€¼)
  let time = 5  // seconds
  
  // è®¡ç®—ä½ç§»ï¼šh = 10*5 + (1/2)*10*5Â² = 50 + 125 = 175
  let velocity_component = multiply(initial_velocity, time)
  let gravity_component = multiply(gravity, multiply(time, time)) / 2
  let displacement = add(velocity_component, gravity_component)
  
  assert_eq(175, displacement)
  
  // è®¡ç®—æœ€ç»ˆé€Ÿåº¦ï¼šv = vâ‚€ + gt = 10 + 10*5 = 60
  let final_velocity = add(initial_velocity, multiply(gravity, time))
  assert_eq(60, final_velocity)
}

test "data_compression_simulation" {
  // æ•°æ®å‹ç¼©æ¨¡æ‹Ÿæµ‹è¯•
  // ç®€å•çš„è¡Œç¨‹é•¿åº¦ç¼–ç æ¨¡æ‹Ÿ
  let original_data = 1111000  // æ¨¡æ‹Ÿæ•°æ®ï¼š4ä¸ª1ï¼Œ3ä¸ª0
  let run_length_1 = 4
  let run_length_0 = 3
  
  // å‹ç¼©åçš„æ•°æ®è¡¨ç¤º
  let compressed_size = add(run_length_1, run_length_0)
  let compression_ratio = multiply(100, compressed_size) / 7  // åŸå§‹é•¿åº¦ä¸º7
  
  assert_eq(7, compressed_size)
  assert_eq(100, compression_ratio)  // åœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰å‹ç¼©
}

test "network_protocol_simulation_v2" {
  // ç½‘ç»œåè®®æ¨¡æ‹Ÿæµ‹è¯•
  // ç®€å•çš„TCPæ ¡éªŒå’Œè®¡ç®—
  let packet1 = 1000
  let packet2 = 2000
  let packet3 = 3000
  let packet4 = 4000
  
  // è®¡ç®—æ ¡éªŒå’Œ
  let sum = add(add(add(packet1, packet2), packet3), packet4)
  let checksum = sum / 65535  // ç®€åŒ–çš„æ ¡éªŒå’Œè®¡ç®—
  
  assert_eq(10000, sum)
  assert_eq(0, checksum)  // ç®€åŒ–ç»“æœ
}

test "machine_learning_basic" {
  // æœºå™¨å­¦ä¹ åŸºç¡€æµ‹è¯•
  // ç®€å•çš„çº¿æ€§å›å½’ï¼šy = mx + b
  let x1 = 1; let y1 = 3
  let x2 = 2; let y2 = 5
  let x3 = 3; let y3 = 7
  
  // è®¡ç®—æ–œç‡m = (y2-y1)/(x2-x1) = (5-3)/(2-1) = 2
  let slope = add(y2, -y1) / add(x2, -x1)
  
  // è®¡ç®—æˆªè·b = y1 - mx1 = 3 - 2*1 = 1
  let intercept = add(y1, multiply(-slope, x1))
  
  // é¢„æµ‹x=4æ—¶çš„å€¼ï¼šy = 2*4 + 1 = 9
  let x4 = 4
  let y4_predicted = add(multiply(slope, x4), intercept)
  
  assert_eq(2, slope)
  assert_eq(1, intercept)
  assert_eq(9, y4_predicted)
}

test "database_operations" {
  // æ•°æ®åº“æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // ç®€å•çš„SQLèšåˆå‡½æ•°æ¨¡æ‹Ÿ
  let table_values = add(add(add(add(10, 20), 30), 40), 50)
  let count = 5
  
  // è®¡ç®—å¹³å‡å€¼
  let average = table_values / count
  
  // è®¡ç®—æ€»å’Œ
  let sum = table_values
  
  // è®¡ç®—æœ€å¤§å€¼ï¼ˆç®€åŒ–ï¼‰
  let max_value = 50
  
  // è®¡ç®—æœ€å°å€¼ï¼ˆç®€åŒ–ï¼‰
  let min_value = 10
  
  assert_eq(30, average)
  assert_eq(150, sum)
  assert_eq(50, max_value)
  assert_eq(10, min_value)
}

test "game_development_calculations" {
  // æ¸¸æˆå¼€å‘è®¡ç®—æµ‹è¯•
  // 2Dæ¸¸æˆä¸­çš„ç¢°æ’æ£€æµ‹
  let rect1_x = 10; let rect1_y = 10; let rect1_width = 20; let rect1_height = 20
  let rect2_x = 25; let rect2_y = 25; let rect2_width = 30; let rect2_height = 30
  
  // è®¡ç®—çŸ©å½¢è¾¹ç•Œ
  let rect1_right = add(rect1_x, rect1_width)
  let rect1_bottom = add(rect1_y, rect1_height)
  let rect2_right = add(rect2_x, rect2_width)
  let rect2_bottom = add(rect2_y, rect2_height)
  
  // ç¢°æ’æ£€æµ‹ï¼ˆç®€åŒ–ï¼‰
  let collision_x = rect1_right > rect2_x && rect1_x < rect2_right
  let collision_y = rect1_bottom > rect2_y && rect1_y < rect2_bottom
  let collision = collision_x && collision_y
  
  assert_true(collision)
  
  // è®¡ç®—è·ç¦»
  let dx = add(rect2_x, -rect1_x)
  let dy = add(rect2_y, -rect1_y)
  let distance_squared = add(multiply(dx, dx), multiply(dy, dy))
  
  assert_eq(225, distance_squared)  // 15Â² + 15Â² = 225
}

// æ–°å¢çš„8ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "binary_operations_simulation" {
  // äºŒè¿›åˆ¶è¿ç®—æ¨¡æ‹Ÿæµ‹è¯•
  let a = 12  // äºŒè¿›åˆ¶ 1100
  let b = 10  // äºŒè¿›åˆ¶ 1010
  
  // æ¨¡æ‹ŸæŒ‰ä½ä¸è¿ç®—ï¼š1100 & 1010 = 1000 (8)
  let bitwise_and = 8
  assert_eq(8, bitwise_and)
  
  // æ¨¡æ‹ŸæŒ‰ä½æˆ–è¿ç®—ï¼š1100 | 1010 = 1110 (14)
  let bitwise_or = 14
  assert_eq(14, bitwise_or)
  
  // æ¨¡æ‹ŸæŒ‰ä½å¼‚æˆ–è¿ç®—ï¼š1100 ^ 1010 = 0110 (6)
  let bitwise_xor = 6
  assert_eq(6, bitwise_xor)
  
  // æ¨¡æ‹Ÿå·¦ç§»è¿ç®—ï¼š1100 << 2 = 110000 (48)
  let left_shift = multiply(a, 4)
  assert_eq(48, left_shift)
  
  // æ¨¡æ‹Ÿå³ç§»è¿ç®—ï¼š1100 >> 2 = 11 (3)
  let right_shift = a / 4
  assert_eq(3, right_shift)
}

test "error_correction_codes" {
  // é”™è¯¯çº æ­£ç æ¨¡æ‹Ÿæµ‹è¯•
  let data_bits = 4
  let parity_bits = 3
  let total_bits = add(data_bits, parity_bits)
  
  // è®¡ç®—æ±‰æ˜ç çš„æ€»ä½æ•°
  assert_eq(7, total_bits)
  
  // æ¨¡æ‹Ÿé”™è¯¯æ£€æµ‹å’Œçº æ­£
  let received_data = 85  // äºŒè¿›åˆ¶ 1010101
  let error_position = 3
  let corrected_data = add(received_data, multiply(4, error_position))
  
  // éªŒè¯é”™è¯¯çº æ­£åçš„æ•°æ®
  assert_eq(97, corrected_data)
  
  // è®¡ç®—å†—ä½™åº¦
  let redundancy = multiply(parity_bits, 100) / total_bits
  assert_eq(42, redundancy)  // 3/7 â‰ˆ 42.86% â‰ˆ 42%
}

test "signal_processing" {
  // ä¿¡å·å¤„ç†æ¨¡æ‹Ÿæµ‹è¯•
  let sampling_rate = 44100  // Hz
  let duration = 5  // seconds
  let bit_depth = 16  // bits
  
  // è®¡ç®—éŸ³é¢‘æ•°æ®å¤§å°
  let total_samples = multiply(sampling_rate, duration)
  let bytes_per_sample = bit_depth / 8
  let total_bytes = multiply(total_samples, bytes_per_sample)
  
  assert_eq(220500, total_samples)
  assert_eq(2, bytes_per_sample)
  assert_eq(441000, total_bytes)
  
  // è®¡ç®—æ•°æ®ä¼ è¾“é€Ÿç‡
  let bitrate = multiply(sampling_rate, bit_depth)
  assert_eq(705600, bitrate)
  
  // è®¡ç®—å‹ç¼©åçš„æ•°æ®å¤§å°ï¼ˆå‡è®¾å‹ç¼©æ¯”ä¸º10:1ï¼‰
  let compressed_size = total_bytes / 10
  assert_eq(44100, compressed_size)
}

test "queue_simulation" {
  // é˜Ÿåˆ—æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let queue_capacity = 10
  let initial_size = 0
  let enqueue_count = 7
  let dequeue_count = 3
  
  // æ¨¡æ‹Ÿå…¥é˜Ÿæ“ä½œ
  let after_enqueue = add(initial_size, enqueue_count)
  assert_eq(7, after_enqueue)
  
  // æ¨¡æ‹Ÿå‡ºé˜Ÿæ“ä½œ
  let after_dequeue = add(after_enqueue, -dequeue_count)
  assert_eq(4, after_dequeue)
  
  // æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
  let is_empty = after_dequeue == 0
  let is_full = after_dequeue == queue_capacity
  
  assert_false(is_empty)
  assert_false(is_full)
  
  // è®¡ç®—é˜Ÿåˆ—åˆ©ç”¨ç‡
  let utilization = multiply(after_dequeue, 100) / queue_capacity
  assert_eq(40, utilization)
}

test "stack_operations" {
  // æ ˆæ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let stack_capacity = 8
  let push_operations = 5
  let pop_operations = 2
  
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let current_size = add(push_operations, -pop_operations)
  assert_eq(3, current_size)
  
  // æ£€æŸ¥æ ˆçŠ¶æ€
  let is_empty = current_size == 0
  let is_full = current_size == stack_capacity
  let can_push = add(current_size, 1) <= stack_capacity
  let can_pop = current_size > 0
  
  assert_false(is_empty)
  assert_false(is_full)
  assert_true(can_push)
  assert_true(can_pop)
  
  // è®¡ç®—æ ˆçš„ä½¿ç”¨ç‡
  let usage_percentage = multiply(current_size, 100) / stack_capacity
  assert_eq(37, usage_percentage)  // 3/8 â‰ˆ 37.5% â‰ˆ 37%
}

test "hash_table_simulation" {
  // å“ˆå¸Œè¡¨æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let table_size = 16
  let elements_count = 10
  let collision_resolution_steps = 3
  
  // è®¡ç®—è´Ÿè½½å› å­
  let load_factor = multiply(elements_count, 100) / table_size
  assert_eq(62, load_factor)  // 10/16 â‰ˆ 62.5% â‰ˆ 62%
  
  // æ¨¡æ‹Ÿå“ˆå¸Œå†²çªå¤„ç†
  let hash_value = 7
  let collision_count = 2
  let final_index = add(hash_value, collision_count)
  
  assert_eq(9, final_index)
  
  // è®¡ç®—å¹³å‡æŸ¥æ‰¾é•¿åº¦
  let avg_lookup_length = add(1, multiply(load_factor, collision_resolution_steps) / 100)
  assert_eq(2, avg_lookup_length)  // ç®€åŒ–è®¡ç®—
}

test "graph_algorithms" {
  // å›¾ç®—æ³•æ¨¡æ‹Ÿæµ‹è¯•
  let vertex_count = 6
  let edge_count = 9
  let start_vertex = 0
  let end_vertex = 5
  
  // è®¡ç®—å›¾çš„å¯†åº¦
  let max_edges = multiply(vertex_count, add(vertex_count, -1)) / 2
  let density = multiply(edge_count, 100) / max_edges
  assert_eq(60, density)  // 9/15 = 0.6 = 60%
  
  // æ¨¡æ‹Ÿæœ€çŸ­è·¯å¾„è®¡ç®—ï¼ˆDijkstraç®—æ³•ç®€åŒ–ç‰ˆï¼‰
  let path_length = 14
  let intermediate_vertices = 3
  
  assert_eq(14, path_length)
  assert_eq(3, intermediate_vertices)
  
  // è®¡ç®—å›¾çš„è¿é€šæ€§ï¼ˆç®€åŒ–ï¼‰
  let connected_components = 1
  let is_connected = connected_components == 1
  assert_true(is_connected)
}

test "tree_operations" {
  // æ ‘æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let tree_height = 4
  let branching_factor = 3
  
  // è®¡ç®—å®Œå…¨æ ‘çš„æœ€å¤§èŠ‚ç‚¹æ•°
  let max_nodes = 1
  let level1_nodes = multiply(1, branching_factor)
  let level2_nodes = multiply(level1_nodes, branching_factor)
  let level3_nodes = multiply(level2_nodes, branching_factor)
  let total_nodes = add(add(add(add(1, level1_nodes), level2_nodes), level3_nodes), 1)
  
  assert_eq(40, total_nodes)  // 1 + 3 + 9 + 27 = 40
  
  // è®¡ç®—å¶å­èŠ‚ç‚¹æ•°
  let leaf_nodes = multiply(3, multiply(3, 3))
  assert_eq(27, leaf_nodes)
  
  // è®¡ç®—å†…éƒ¨èŠ‚ç‚¹æ•°
  let internal_nodes = add(total_nodes, -leaf_nodes)
  assert_eq(13, internal_nodes)
  
  // è®¡ç®—æ ‘çš„å¹³è¡¡å› å­ï¼ˆç®€åŒ–ï¼‰
  let is_balanced = true
  assert_true(is_balanced)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
test "divide_with_ceil_basic" {
  // æµ‹è¯•åŸºæœ¬çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(5, divide_with_ceil(11, 2))
}

test "divide_with_ceil_edge_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(100, divide_with_ceil(100, 1))
  assert_eq(1, divide_with_ceil(99, 100))
  assert_eq(2, divide_with_ceil(101, 100))
  assert_eq(10, divide_with_ceil(91, 10))
}

test "divide_with_ceil_negative" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-3, divide_with_ceil(-9, 3))
  assert_eq(0, divide_with_ceil(-1, 100))
  assert_eq(-1, divide_with_ceil(-100, 100))
  assert_eq(-5, divide_with_ceil(-11, 2))
}

test "resource_allocation" {
  // æµ‹è¯•èµ„æºåˆ†é…åœºæ™¯
  let total_resources = 17
  let team_size = 5
  
  // è®¡ç®—æ¯ä¸ªå›¢é˜Ÿéœ€è¦çš„èµ„æºæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let resources_per_team = divide_with_ceil(total_resources, team_size)
  assert_eq(4, resources_per_team)
  
  // è®¡ç®—æ€»åˆ†é…èµ„æº
  let total_allocated = multiply(resources_per_team, team_size)
  assert_eq(20, total_allocated)
  
  // è®¡ç®—å‰©ä½™èµ„æº
  let remaining = add(total_allocated, -total_resources)
  assert_eq(3, remaining)
}

test "page_pagination" {
  // æµ‹è¯•åˆ†é¡µåœºæ™¯
  let total_items = 23
  let items_per_page = 10
  
  // è®¡ç®—éœ€è¦çš„é¡µæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let total_pages = divide_with_ceil(total_items, items_per_page)
  assert_eq(3, total_pages)
  
  // æœ€åä¸€é¡µçš„é¡¹ç›®æ•°
  let last_page_items = total_items % items_per_page
  assert_eq(3, last_page_items)
}

test "time_slot_scheduling" {
  // æµ‹è¯•æ—¶é—´æ®µè°ƒåº¦åœºæ™¯
  let total_duration = 65  // åˆ†é’Ÿ
  let slot_duration = 15   // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„æ—¶é—´æ®µæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let required_slots = divide_with_ceil(total_duration, slot_duration)
  assert_eq(5, required_slots)
  
  // è®¡ç®—æ€»åˆ†é…æ—¶é—´
  let total_allocated_time = multiply(required_slots, slot_duration)
  assert_eq(75, total_allocated_time)
  
  // è®¡ç®—ç©ºé—²æ—¶é—´
  let idle_time = add(total_allocated_time, -total_duration)
  assert_eq(10, idle_time)
}

test "container_packing" {
  // æµ‹è¯•å®¹å™¨è£…ç®±åœºæ™¯
  let total_items = 37
  let container_capacity = 12
  
  // è®¡ç®—éœ€è¦çš„å®¹å™¨æ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let required_containers = divide_with_ceil(total_items, container_capacity)
  assert_eq(4, required_containers)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(required_containers, container_capacity)
  assert_eq(48, total_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let remaining_capacity = add(total_capacity, -total_items)
  assert_eq(11, remaining_capacity)
}

test "bandwidth_allocation" {
  // æµ‹è¯•å¸¦å®½åˆ†é…åœºæ™¯
  let total_bandwidth = 1000  // Mbps
  let min_bandwidth_per_user = 150  // Mbps
  
  // è®¡ç®—å¯æ”¯æŒçš„æœ€å¤§ç”¨æˆ·æ•°ï¼ˆå‘ä¸‹å–æ•´ï¼‰
  let max_users = total_bandwidth / min_bandwidth_per_user
  assert_eq(6, max_users)
  
  // è®¡ç®—å®é™…ä½¿ç”¨çš„å¸¦å®½
  let used_bandwidth = multiply(max_users, min_bandwidth_per_user)
  assert_eq(900, used_bandwidth)
  
  // è®¡ç®—å‰©ä½™å¸¦å®½
  let remaining_bandwidth = add(total_bandwidth, -used_bandwidth)
  assert_eq(100, remaining_bandwidth)
}

test "storage_planning" {
  // æµ‹è¯•å­˜å‚¨è§„åˆ’åœºæ™¯
  let data_size = 2500  // GB
  let disk_capacity = 1000  // GB
  
  // è®¡ç®—éœ€è¦çš„ç£ç›˜æ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let required_disks = divide_with_ceil(data_size, disk_capacity)
  assert_eq(3, required_disks)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_storage = multiply(required_disks, disk_capacity)
  assert_eq(3000, total_storage)
  
  // è®¡ç®—å­˜å‚¨åˆ©ç”¨ç‡
  let utilization = multiply(data_size, 100) / total_storage
  assert_eq(83, utilization)  // 2500/3000 â‰ˆ 83.33% â‰ˆ 83%
}

test "task_distribution" {
  // æµ‹è¯•ä»»åŠ¡åˆ†é…åœºæ™¯
  let total_tasks = 47
  let worker_count = 8
  
  // è®¡ç®—æ¯ä¸ªå·¥äººçš„åŸºæœ¬ä»»åŠ¡æ•°
  let base_tasks = total_tasks / worker_count
  assert_eq(5, base_tasks)
  
  // è®¡ç®—éœ€è¦é¢å¤–å¤„ç†ä»»åŠ¡çš„å·¥äººæ•°
  let extra_tasks = total_tasks % worker_count
  assert_eq(7, extra_tasks)
  
  // è®¡ç®—æœ€å¤§ä»»åŠ¡è´Ÿè½½
  let max_load = add(base_tasks, if extra_tasks > 0 { 1 } else { 0 })
  assert_eq(6, max_load)
  
  // è®¡ç®—æœ€å°ä»»åŠ¡è´Ÿè½½
  let min_load = base_tasks
  assert_eq(5, min_load)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "string_length_validation" {
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦éªŒè¯
  let short_string = "Hi"
  let medium_string = "MoonBit"
  let long_string = "This is a very long string for testing purposes"
  
  // éªŒè¯ä¸åŒé•¿åº¦å­—ç¬¦ä¸²çš„greetå‡½æ•°å¤„ç†
  assert_eq_string("Hello, Hi!", greet(short_string))
  assert_eq_string("Hello, MoonBit!", greet(medium_string))
  assert_eq_string("Hello, This is a very long string for testing purposes!", greet(long_string))
}

test "mathematical_series" {
  // æµ‹è¯•æ•°å­¦çº§æ•°è®¡ç®—
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œï¼ša + ar + arÂ² + ... + ar^(n-1)
  let a = 2      // é¦–é¡¹
  let r = 3      // å…¬æ¯”
  let n = 4      // é¡¹æ•°
  
  // æ‰‹åŠ¨è®¡ç®—ï¼š2 + 6 + 18 + 54 = 80
  let term1 = a
  let term2 = multiply(a, r)
  let term3 = multiply(term2, r)
  let term4 = multiply(term3, r)
  let sum = add(add(add(term1, term2), term3), term4)
  
  assert_eq(80, sum)
}

test "number_system_conversion" {
  // æµ‹è¯•æ•°å­—ç³»ç»Ÿè½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // åè¿›åˆ¶è½¬äºŒè¿›åˆ¶æ¨¡æ‹Ÿ
  let decimal_num = 13
  
  // æ¨¡æ‹Ÿ13çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼š1101 = 1*2Â³ + 1*2Â² + 0*2Â¹ + 1*2â° = 8 + 4 + 0 + 1 = 13
  let bit0 = 1
  let bit1 = 0
  let bit2 = 1
  let bit3 = 1
  
  let reconstructed = add(add(add(multiply(bit3, 8), multiply(bit2, 4)), multiply(bit1, 2)), bit0)
  assert_eq(decimal_num, reconstructed)
}

test "temperature_conversion_precise" {
  // æµ‹è¯•ç²¾ç¡®çš„æ¸©åº¦è½¬æ¢
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 9/5 + 32
  // ä½¿ç”¨æ•´æ•°è¿‘ä¼¼ï¼šF = C Ã— 2 - C Ã— 0.2 + 32 â‰ˆ C Ã— 2 + 32 - C/5
  
  let celsius = 25
  let fahrenheit_approx = add(add(multiply(celsius, 2), 32), multiply(-1, celsius / 5))
  assert_eq(77, fahrenheit_approx)  // 25 Ã— 2 + 32 - 5 = 77
  
  // æµ‹è¯•è´Ÿæ¸©åº¦
  let neg_celsius = -10
  let neg_fahrenheit = add(add(multiply(neg_celsius, 2), 32), multiply(-1, neg_celsius / 5))
  assert_eq(14, neg_fahrenheit)  // -10 Ã— 2 + 32 - (-2) = 14
}

test "financial_compound_interest" {
  // æµ‹è¯•é‡‘èå¤åˆ©è®¡ç®—
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  let compounds_per_year = 12  // æœˆå¤åˆ©
  
  // ç®€åŒ–å¤åˆ©å…¬å¼ï¼šA = P(1 + r/n)^(nt)
  // è¿‘ä¼¼è®¡ç®—ï¼šA = P(1 + rÃ—t)
  let growth_factor = add(1, multiply(annual_rate, years))
  let final_amount = multiply(principal, growth_factor)
  
  assert_eq(160000, final_amount)  // 10000 Ã— (1 + 5Ã—3) = 10000 Ã— 16 = 160000
}

test "statistical_variance" {
  // æµ‹è¯•ç»Ÿè®¡æ–¹å·®è®¡ç®—
  // æ•°æ®é›†ï¼š[5, 8, 12, 15, 20]
  let values = [5, 8, 12, 15, 20]
  let count = 5
  
  // è®¡ç®—å¹³å‡å€¼ï¼š(5 + 8 + 12 + 15 + 20) / 5 = 60 / 5 = 12
  let sum = add(add(add(add(5, 8), 12), 15), 20)
  let mean = sum / count
  assert_eq(12, mean)
  
  // è®¡ç®—æ–¹å·®ï¼šÎ£(x - mean)Â² / n
  let diff1 = add(5, -12)  // -7
  let diff2 = add(8, -12)  // -4
  let diff3 = add(12, -12) // 0
  let diff4 = add(15, -12) // 3
  let diff5 = add(20, -12) // 8
  
  let variance_sum = add(add(add(add(multiply(diff1, diff1), multiply(diff2, diff2)), 
                                multiply(diff3, diff3)), multiply(diff4, diff4)), multiply(diff5, diff5))
  let variance = variance_sum / count
  
  assert_eq(26, variance)  // (49 + 16 + 0 + 9 + 64) / 5 = 138 / 5 = 27.6 â‰ˆ 26 (æ•´æ•°é™¤æ³•)
}

test "geometry_circle_properties" {
  // æµ‹è¯•åœ†çš„å‡ ä½•å±æ€§
  let radius = 5
  let pi_approx = 3  // Ï€çš„è¿‘ä¼¼å€¼
  
  // è®¡ç®—ç›´å¾„
  let diameter = multiply(radius, 2)
  assert_eq(10, diameter)
  
  // è®¡ç®—å‘¨é•¿ï¼šC = Ï€ Ã— d
  let circumference = multiply(pi_approx, diameter)
  assert_eq(30, circumference)
  
  // è®¡ç®—é¢ç§¯ï¼šA = Ï€ Ã— rÂ²
  let area = multiply(pi_approx, multiply(radius, radius))
  assert_eq(75, area)
}

test "game_score_ranking" {
  // æµ‹è¯•æ¸¸æˆå¾—åˆ†æ’åç³»ç»Ÿ
  let scores = [850, 920, 780, 950, 890]
  let player_count = 5
  
  // è®¡ç®—æ€»åˆ†
  let total_score = add(add(add(add(850, 920), 780), 950), 890)
  assert_eq(4390, total_score)
  
  // è®¡ç®—å¹³å‡åˆ†
  let average_score = total_score / player_count
  assert_eq(878, average_score)  // 4390 / 5 = 878
  
  // è®¡ç®—æœ€é«˜åˆ†å’Œæœ€ä½åˆ†çš„å·®å€¼
  let max_score = 950
  let min_score = 780
  let score_range = add(max_score, -min_score)
  assert_eq(170, score_range)
}

test "network_throughput" {
  // æµ‹è¯•ç½‘ç»œååé‡è®¡ç®—
  let file_size = 1048576  // 1MB in bytes
  let bandwidth = 1048576  // 1MB/s
  let latency = 50         // 50ms
  let packet_size = 1500   // 1500 bytes
  
  // è®¡ç®—ä¼ è¾“æ—¶é—´ï¼ˆç®€åŒ–ï¼‰
  let transfer_time = file_size / bandwidth
  assert_eq(1, transfer_time)  // 1ç§’
  
  // è®¡ç®—æ•°æ®åŒ…æ•°é‡
  let packet_count = divide_with_ceil(file_size, packet_size)
  assert_eq(700, packet_count)  // 1048576 / 1500 â‰ˆ 699.05 â‰ˆ 700
  
  // è®¡ç®—æ€»å»¶è¿Ÿæ—¶é—´
  let total_latency = multiply(packet_count, latency)
  assert_eq(35000, total_latency)  // 700 Ã— 50 = 35000ms
}

test "data_structure_validation" {
  // æµ‹è¯•æ•°æ®ç»“æ„éªŒè¯
  // éªŒè¯æ•°ç»„ç´¢å¼•è®¡ç®—
  let row = 3
  let col = 2
  let cols_per_row = 5
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—
  let index_1d = add(multiply(row, cols_per_row), col)
  assert_eq(17, index_1d)  // 3 Ã— 5 + 2 = 17
  
  // éªŒè¯è¾¹ç•Œæ¡ä»¶
  let first_index = add(multiply(0, cols_per_row), 0)
  let last_index = add(multiply(9, cols_per_row), 4)  // å‡è®¾10è¡Œ5åˆ—
  
  assert_eq(0, first_index)
  assert_eq(49, last_index)
  
  // éªŒè¯ç´¢å¼•èŒƒå›´
  let is_valid_index = index_1d >= first_index && index_1d <= last_index
  assert_true(is_valid_index)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "complex_arithmetic_sequence" {
  // æµ‹è¯•å¤æ‚ç­‰å·®æ•°åˆ—è®¡ç®—
  // è®¡ç®—æ•°åˆ—ï¼š3, 7, 11, 15, 19, 23, 27, 31, 35, 39 çš„å’Œ
  // è¿™æ˜¯ä¸€ä¸ªé¦–é¡¹ä¸º3ï¼Œå…¬å·®ä¸º4çš„ç­‰å·®æ•°åˆ—
  let first_term = 3
  let common_diff = 4
  let num_terms = 10
  
  // ä½¿ç”¨å…¬å¼ï¼šå’Œ = n/2 Ã— (2a + (n-1)d)
  let sum_formula = multiply(num_terms, add(multiply(2, first_term), multiply(num_terms - 1, common_diff))) / 2
  assert_eq(210, sum_formula)  // 10/2 Ã— (6 + 36) = 5 Ã— 42 = 210
  
  // éªŒè¯ç‰¹å®šé¡¹çš„å€¼
  let term_5 = add(first_term, multiply(4, common_diff))  // ç¬¬5é¡¹
  assert_eq(19, term_5)  // 3 + 4Ã—4 = 19
  
  let term_10 = add(first_term, multiply(9, common_diff))  // ç¬¬10é¡¹
  assert_eq(39, term_10)  // 3 + 9Ã—4 = 39
}

test "string_pattern_matching" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…åœºæ™¯
  // æ¨¡æ‹Ÿç®€å•çš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
  
  // æµ‹è¯•åŒ…å«ç‰¹å®šæ¨¡å¼çš„å­—ç¬¦ä¸²
  let pattern = "test"
  let text1 = "this is a test string"
  let text2 = "no match here"
  let text3 = "test at beginning"
  let text4 = "test"
  
  // éªŒè¯å­—ç¬¦ä¸²åŒ…å«å…³ç³»ï¼ˆé€šè¿‡greetå‡½æ•°é—´æ¥æµ‹è¯•ï¼‰
  let result1 = greet(text1)
  let result2 = greet(text2)
  let result3 = greet(text3)
  let result4 = greet(text4)
  
  assert_eq_string("Hello, this is a test string!", result1)
  assert_eq_string("Hello, no match here!", result2)
  assert_eq_string("Hello, test at beginning!", result3)
  assert_eq_string("Hello, test!", result4)
  
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è®¡ç®—ï¼ˆæ¨¡æ‹Ÿï¼‰
  let len1 = 21  // "this is a test string" çš„é•¿åº¦
  let len2 = 14  // "no match here" çš„é•¿åº¦
  let len3 = 19  // "test at beginning" çš„é•¿åº¦
  let len4 = 4   // "test" çš„é•¿åº¦
  
  // éªŒè¯é•¿åº¦å…³ç³»
  assert_true(len1 > len2)
  assert_true(len3 > len4)
  assert_eq(4, len4)
}

test "memory_address_calculation" {
  // æµ‹è¯•å†…å­˜åœ°å€è®¡ç®—æ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿæ•°ç»„å…ƒç´ çš„å†…å­˜åœ°å€è®¡ç®—
  
  let base_address = 1000  // åŸºåœ°å€
  let element_size = 4     // æ¯ä¸ªå…ƒç´ 4å­—èŠ‚
  let index1 = 0
  let index2 = 5
  let index3 = 10
  
  // è®¡ç®—å…ƒç´ åœ°å€ï¼šåœ°å€ = åŸºåœ°å€ + ç´¢å¼• Ã— å…ƒç´ å¤§å°
  let addr1 = add(base_address, multiply(index1, element_size))
  let addr2 = add(base_address, multiply(index2, element_size))
  let addr3 = add(base_address, multiply(index3, element_size))
  
  assert_eq(1000, addr1)  // 1000 + 0Ã—4 = 1000
  assert_eq(1020, addr2)  // 1000 + 5Ã—4 = 1020
  assert_eq(1040, addr3)  // 1000 + 10Ã—4 = 1040
  
  // è®¡ç®—å…ƒç´ é—´çš„åç§»é‡
  let offset12 = add(addr2, -addr1)
  let offset23 = add(addr3, -addr2)
  
  assert_eq(20, offset12)  // 1020 - 1000 = 20
  assert_eq(20, offset23)  // 1040 - 1020 = 20
  
  // éªŒè¯åœ°å€å¯¹é½ï¼ˆ4å­—èŠ‚å¯¹é½ï¼‰
  let aligned1 = addr1 % element_size == 0
  let aligned2 = addr2 % element_size == 0
  let aligned3 = addr3 % element_size == 0
  
  assert_true(aligned1 && aligned2 && aligned3)
}

test "probability_calculation" {
  // æµ‹è¯•æ¦‚ç‡è®¡ç®—åœºæ™¯
  // æ¨¡æ·ä¸¤ä¸ªéª°å­çš„æ¦‚ç‡è®¡ç®—
  
  let dice_faces = 6  // å…­é¢éª°å­
  let total_outcomes = multiply(dice_faces, dice_faces)  // æ€»ç»“æœæ•° = 6Ã—6 = 36
  
  // è®¡ç®—ç‰¹å®šç‚¹æ•°çš„ç»„åˆæ•°
  let sum_7_combinations = 6  // ç‚¹æ•°å’Œä¸º7çš„ç»„åˆï¼š(1,6), (2,5), (3,4), (4,3), (5,2), (6,1)
  let sum_11_combinations = 2 // ç‚¹æ•°å’Œä¸º11çš„ç»„åˆï¼š(5,6), (6,5)
  let sum_2_combinations = 1  // ç‚¹æ•°å’Œä¸º2çš„ç»„åˆï¼š(1,1)
  let sum_12_combinations = 1 // ç‚¹æ•°å’Œä¸º12çš„ç»„åˆï¼š(6,6)
  
  // è®¡ç®—æ¦‚ç‡ï¼ˆä»¥ç™¾åˆ†æ¯”è¡¨ç¤ºï¼‰
  let prob_7 = multiply(sum_7_combinations, 100) / total_outcomes
  let prob_11 = multiply(sum_11_combinations, 100) / total_outcomes
  let prob_2 = multiply(sum_2_combinations, 100) / total_outcomes
  let prob_12 = multiply(sum_12_combinations, 100) / total_outcomes
  
  assert_eq(16, prob_7)   // 6/36 â‰ˆ 16.67% â‰ˆ 16%
  assert_eq(5, prob_11)   // 2/36 â‰ˆ 5.56% â‰ˆ 5%
  assert_eq(2, prob_2)    // 1/36 â‰ˆ 2.78% â‰ˆ 2%
  assert_eq(2, prob_12)   // 1/36 â‰ˆ 2.78% â‰ˆ 2%
  
  // è®¡ç®—æœŸæœ›å€¼ï¼ˆç®€åŒ–ï¼‰
  let expected_sum = 7  // ä¸¤ä¸ªéª°å­çš„æœŸæœ›å’Œ
  assert_eq(7, expected_sum)
}

test "circular_buffer_operations" {
  // æµ‹è¯•å¾ªç¯ç¼“å†²åŒºæ“ä½œæ¨¡æ‹Ÿ
  let buffer_size = 8
  let initial_head = 0
  let initial_tail = 0
  let initial_count = 0
  
  // æ¨¡æ‹Ÿå…¥é˜Ÿæ“ä½œ
  let enqueue_count = 5
  let new_tail = add(initial_tail, enqueue_count) % buffer_size
  let new_count = add(initial_count, enqueue_count)
  
  assert_eq(5, new_tail)  // (0 + 5) % 8 = 5
  assert_eq(5, new_count) // 0 + 5 = 5
  
  // æ¨¡æ‹Ÿå‡ºé˜Ÿæ“ä½œ
  let dequeue_count = 3
  let new_head = add(initial_head, dequeue_count) % buffer_size
  let final_count = add(new_count, -dequeue_count)
  
  assert_eq(3, new_head)  // (0 + 3) % 8 = 3
  assert_eq(2, final_count) // 5 - 3 = 2
  
  // æ£€æŸ¥ç¼“å†²åŒºçŠ¶æ€
  let is_empty = final_count == 0
  let is_full = final_count == buffer_size
  let has_space = final_count < buffer_size
  
  assert_false(is_empty)
  assert_false(is_full)
  assert_true(has_space)
  
  // è®¡ç®—ç¼“å†²åŒºåˆ©ç”¨ç‡
  let utilization = multiply(final_count, 100) / buffer_size
  assert_eq(25, utilization) // 2/8 = 25%
}

test "color_space_conversion" {
  // æµ‹è¯•é¢œè‰²ç©ºé—´è½¬æ¢æ¨¡æ‹Ÿ
  // RGBåˆ°HSVçš„ç®€åŒ–è½¬æ¢æ¨¡æ‹Ÿ
  
  let r = 255  // çº¢è‰²åˆ†é‡
  let g = 0    // ç»¿è‰²åˆ†é‡
  let b = 0    // è“è‰²åˆ†é‡
  
  // è®¡ç®—æœ€å¤§å€¼å’Œæœ€å°å€¼
  let max_val = 255
  let min_val = 0
  let delta = add(max_val, -min_val)
  
  assert_eq(255, max_val)
  assert_eq(0, min_val)
  assert_eq(255, delta)
  
  // ç®€åŒ–çš„è‰²ç›¸è®¡ç®—ï¼ˆçº¢è‰²å¯¹åº”0åº¦ï¼‰
  let hue = if max_val == r { 0 } else { 120 }  // ç®€åŒ–é€»è¾‘
  assert_eq(0, hue)
  
  // é¥±å’Œåº¦è®¡ç®—ï¼ˆç®€åŒ–ï¼‰
  let saturation = if max_val == 0 { 0 } else { multiply(delta, 100) / max_val }
  assert_eq(100, saturation)  // 255/255 Ã— 100 = 100%
  
  // æ˜åº¦è®¡ç®—
  let value = max_val
  assert_eq(255, value)
  
  // æµ‹è¯•å¦ä¸€ç§é¢œè‰²ï¼ˆç»¿è‰²ï¼‰
  let r2 = 0
  let g2 = 255
  let b2 = 0
  
  let max_val2 = 255
  let min_val2 = 0
  let delta2 = add(max_val2, -min_val2)
  
  let hue2 = if max_val2 == r2 { 0 } else { 120 }  // ç»¿è‰²å¯¹åº”120åº¦
  let saturation2 = if max_val2 == 0 { 0 } else { multiply(delta2, 100) / max_val2 }
  let value2 = max_val2
  
  assert_eq(120, hue2)
  assert_eq(100, saturation2)
  assert_eq(255, value2)
}

test "checksum_verification" {
  // æµ‹è¯•æ ¡éªŒå’ŒéªŒè¯
  // æ¨¡æ‹Ÿç®€å•çš„æ ¡éªŒå’Œç®—æ³•
  
  let data_block1 = 100
  let data_block2 = 200
  let data_block3 = 300
  let data_block4 = 400
  
  // è®¡ç®—ç®€å•æ ¡éªŒå’Œ
  let checksum = add(add(add(data_block1, data_block2), data_block3), data_block4)
  assert_eq(1000, checksum)
  
  // æ¨¡æ‹Ÿæ•°æ®ä¼ è¾“åçš„éªŒè¯
  let received_block1 = 100
  let received_block2 = 200
  let received_block3 = 300  // æ¨¡æ‹Ÿè¿™ä¸ªå—å‡ºé”™
  let received_block4 = 400
  
  let received_checksum = add(add(add(received_block1, received_block2), received_block3), received_block4)
  assert_eq(1000, received_checksum)
  
  // æ£€æµ‹é”™è¯¯ï¼ˆé€šè¿‡æ¯”è¾ƒæ ¡éªŒå’Œï¼‰
  let error_detected = checksum != received_checksum
  assert_false(error_detected)  // åœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰æ£€æµ‹åˆ°é”™è¯¯
  
  // æ¨¡æ‹Ÿæœ‰é”™è¯¯çš„æƒ…å†µ
  let corrupted_block3 = 310
  let corrupted_checksum = add(add(add(data_block1, data_block2), corrupted_block3), data_block4)
  let actual_error = checksum != corrupted_checksum
  assert_true(actual_error)  // æ£€æµ‹åˆ°é”™è¯¯
}

test "load_balancer_round_robin" {
  // æµ‹è¯•è½®è¯¢è´Ÿè½½å‡è¡¡å™¨æ¨¡æ‹Ÿ
  let server_count = 3
  let request_count = 10
  
  // æ¨¡æ‹Ÿè¯·æ±‚åˆ†å‘
  let server1_requests = 0
  let server2_requests = 0
  let server3_requests = 0
  
  // æ‰‹åŠ¨æ¨¡æ‹Ÿè½®è¯¢åˆ†é…
  // è¯·æ±‚1-10åˆ†åˆ«åˆ†é…åˆ°æœåŠ¡å™¨ï¼š1,2,3,1,2,3,1,2,3,1
  let final_server1_requests = 4  // è¯·æ±‚1,4,7,10
  let final_server2_requests = 3  // è¯·æ±‚2,5,8
  let final_server3_requests = 3  // è¯·æ±‚3,6,9
  
  assert_eq(4, final_server1_requests)
  assert_eq(3, final_server2_requests)
  assert_eq(3, final_server3_requests)
  
  // éªŒè¯æ€»è¯·æ±‚æ•°
  let total_distributed = add(add(final_server1_requests, final_server2_requests), final_server3_requests)
  assert_eq(request_count, total_distributed)
  
  // è®¡ç®—è´Ÿè½½å‡è¡¡åº¦
  let max_requests = 4
  let min_requests = 3
  let load_imbalance = add(max_requests, -min_requests)
  assert_eq(1, load_imbalance)  // æœ€å¤§å·®å€¼ä¸º1ï¼Œè¡¨ç¤ºè´Ÿè½½å‡è¡¡è¾ƒå¥½
  
  // è®¡ç®—æ¯ä¸ªæœåŠ¡å™¨çš„è´Ÿè½½ç™¾åˆ†æ¯”
  let server1_load = multiply(final_server1_requests, 100) / request_count
  let server2_load = multiply(final_server2_requests, 100) / request_count
  let server3_load = multiply(final_server3_requests, 100) / request_count
  
  assert_eq(40, server1_load)  // 4/10 = 40%
  assert_eq(30, server2_load)  // 3/10 = 30%
  assert_eq(30, server3_load)  // 3/10 = 30%
}

test "cache_replacement_policy" {
  // æµ‹è¯•ç¼“å­˜æ›¿æ¢ç­–ç•¥æ¨¡æ‹Ÿ
  // æ¨¡æ‹ŸLRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰ç¼“å­˜ç­–ç•¥
  
  let cache_size = 3
  let access_sequence = [1, 2, 3, 4, 1, 2, 5]  // è®¿é—®åºåˆ—
  
  // æ¨¡æ‹Ÿç¼“å­˜çŠ¶æ€å˜åŒ–
  // è®¿é—®1,2,3åï¼šç¼“å­˜ = [1,2,3]
  // è®¿é—®4åï¼šç¼“å­˜ = [2,3,4] (1è¢«æ›¿æ¢)
  // è®¿é—®1åï¼šç¼“å­˜ = [3,4,1] (2è¢«æ›¿æ¢)
  // è®¿é—®2åï¼šç¼“å­˜ = [4,1,2] (3è¢«æ›¿æ¢)
  // è®¿é—®5åï¼šç¼“å­˜ = [1,2,5] (4è¢«æ›¿æ¢)
  
  let final_cache = [1, 2, 5]
  let cache_hits = 2  // è®¿é—®1å’Œ2æ—¶å‘½ä¸­
  let cache_misses = 5 // å…¶ä»–è®¿é—®æœªå‘½ä¸­
  let total_accesses = 7
  
  assert_eq(2, cache_hits)
  assert_eq(5, cache_misses)
  assert_eq(7, total_accesses)
  
  // è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
  let hit_rate = multiply(cache_hits, 100) / total_accesses
  assert_eq(28, hit_rate)  // 2/7 â‰ˆ 28.57% â‰ˆ 28%
  
  // è®¡ç®—ç¼“å­˜æœªå‘½ä¸­ç‡
  let miss_rate = multiply(cache_misses, 100) / total_accesses
  assert_eq(71, miss_rate)  // 5/7 â‰ˆ 71.43% â‰ˆ 71%
  
  // éªŒè¯å‘½ä¸­ç‡ä¸æœªå‘½ä¸­ç‡ä¹‹å’Œ
  let total_rate = add(hit_rate, miss_rate)
  assert_eq(99, total_rate)  // ç”±äºæ•´æ•°é™¤æ³•ï¼Œä¸æ˜¯100%
}

test "error_detection_codes" {
  // æµ‹è¯•é”™è¯¯æ£€æµ‹ç æ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿå¥‡å¶æ ¡éªŒç 
  
  let data_byte = 10110101  // äºŒè¿›åˆ¶æ•°æ®
  let data_bits = 8
  
  // è®¡ç®—å¥‡å¶æ ¡éªŒä½ï¼ˆå¶æ ¡éªŒï¼‰
  // 1çš„ä¸ªæ•°ï¼š5ä¸ª
  let ones_count = 5
  let parity_bit = if ones_count % 2 == 0 { 0 } else { 1 }
  assert_eq(1, parity_bit)  // å¥‡æ•°ä¸ª1ï¼Œæ‰€ä»¥æ ¡éªŒä½ä¸º1
  
  // æ¨¡æ‹Ÿä¼ è¾“åçš„æ•°æ®
  let received_data = 10100101  // ç¬¬4ä½ä»1å˜ä¸º0
  let received_ones_count = 4
  let received_parity_bit = if received_ones_count % 2 == 0 { 0 } else { 1 }
  assert_eq(0, received_parity_bit)  // å¶æ•°ä¸ª1ï¼Œæ‰€ä»¥æ ¡éªŒä½ä¸º0
  
  // æ£€æµ‹é”™è¯¯
  let error_detected = parity_bit != received_parity_bit
  assert_true(error_detected)  // æ£€æµ‹åˆ°é”™è¯¯
  
  // æ¨¡æ‹ŸCRCæ ¡éªŒï¼ˆç®€åŒ–ï¼‰
  let data_block = 12345
  let divisor = 123
  let remainder = data_block % divisor
  let crc_value = remainder
  
  assert_eq(45, crc_value)  // 12345 % 123 = 45
  
  // æ¨¡æ‹Ÿæ¥æ”¶ç«¯çš„CRCè®¡ç®—
  let received_block = 12345
  let received_remainder = received_block % divisor
  let received_crc = received_remainder
  
  let crc_error = crc_value != received_crc
  assert_false(crc_error)  // æ²¡æœ‰é”™è¯¯
  
  // æ¨¡æ‹Ÿæ•°æ®æŸå
  let corrupted_block = 12350
  let corrupted_remainder = corrupted_block % divisor
  let corrupted_crc = corrupted_remainder
  
  let crc_detected = crc_value != corrupted_crc
  assert_true(crc_detected)  // æ£€æµ‹åˆ°é”™è¯¯
}

// æ–°å¢çš„10ä¸ªç®€æ´æµ‹è¯•ç”¨ä¾‹
test "simple_add_functionality" {
  assert_eq(10, add(3, 7))
  assert_eq(0, add(-5, 5))
  assert_eq(-8, add(-3, -5))
}

test "add_overflow_handling" {
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
}

test "simple_multiply_functionality" {
  assert_eq(15, multiply(3, 5))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(0, multiply(0, 100))
}

test "multiply_boundary_cases" {
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
}

test "greet_function_tests" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
}

test "math_expression_tests" {
  let result = multiply(add(2, 3), 4)
  assert_eq(20, result)
  
  let result2 = add(multiply(5, 3), 2)
  assert_eq(17, result2)
}

test "practical_calculation_tests" {
  let price = 199
  let quantity = 3
  let total = multiply(price, quantity)
  assert_eq(597, total)
}

test "string_processing_tests" {
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, VeryLongName!", greet("VeryLongName"))
}

test "complex_business_logic_tests" {
  let order_total = 1200
  let discount_rate = 10
  let discount_amount = multiply(order_total, discount_rate) / 100
  let final_total = add(order_total, -discount_amount)
  assert_eq(1080, final_total)
}

test "assertion_function_tests" {
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("MoonBit", "MoonBit")
  
  let calc_result = add(15, 27)
  assert_true(calc_result == 42)
  assert_false(calc_result != 42)
}

// æ ‡å‡† MoonBit æµ‹è¯•å¥—ä»¶ - æ·»åŠ 9ä¸ªæ ‡å‡†æµ‹è¯•ç”¨ä¾‹
test "standard_add_basic" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "standard_add_zero" {
  // æµ‹è¯•ä¸0ç›¸åŠ çš„æƒ…å†µ
  assert_eq(10, add(10, 0))
  assert_eq(10, add(0, 10))
  assert_eq(0, add(0, 0))
}

test "standard_add_negative" {
  // æµ‹è¯•è´Ÿæ•°åŠ æ³•
  assert_eq(0, add(5, -5))
  assert_eq(-8, add(-3, -5))
  assert_eq(-2, add(3, -5))
}

test "standard_multiply_basic" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(1, multiply(1, 1))
}

test "standard_multiply_negative" {
  // æµ‹è¯•è´Ÿæ•°ä¹˜æ³•
  assert_eq(-6, multiply(2, -3))
  assert_eq(6, multiply(-2, -3))
  assert_eq(0, multiply(-5, 0))
}

test "standard_greet_basic" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "standard_greet_special" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
  assert_eq_string("Hello, User123!", greet("User123"))
  assert_eq_string("Hello, @#$!", greet("@#$"))
}

test "standard_boundary_add" {
  // æµ‹è¯•è¾¹ç•Œå€¼çš„åŠ æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "standard_boundary_multiply" {
  // æµ‹è¯•è¾¹ç•Œå€¼çš„ä¹˜æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  assert_eq(min_val, multiply(min_val, -1))
}

// ç®€æ´å¿…è¦çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›– azimuth åŒ…çš„æ ¸å¿ƒåŠŸèƒ½

test "essential_add_basic" {
  // åŸºæœ¬åŠ æ³•æµ‹è¯•
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-2, add(-1, -1))
}

test "essential_add_edge_cases" {
  // åŠ æ³•è¾¹ç•Œæƒ…å†µæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æº¢å‡ºä¿æŠ¤æµ‹è¯•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "essential_multiply_basic" {
  // åŸºæœ¬ä¹˜æ³•æµ‹è¯•
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(5, multiply(5, 1))
  assert_eq(-6, multiply(2, -3))
}

test "essential_multiply_edge_cases" {
  // ä¹˜æ³•è¾¹ç•Œæƒ…å†µæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ç‰¹æ®Šå€¼æµ‹è¯•
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(0, multiply(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
}

test "essential_greet_basic" {
  // åŸºæœ¬é—®å€™è¯­æµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "essential_greet_special_chars" {
  // ç‰¹æ®Šå­—ç¬¦é—®å€™è¯­æµ‹è¯•
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, @#$!", greet("@#$"))
}

test "essential_complex_calculation" {
  // å¤åˆè®¡ç®—æµ‹è¯•ï¼šçŸ©å½¢å‘¨é•¿
  let length = 10
  let width = 5
  let perimeter = add(multiply(2, length), multiply(2, width))
  assert_eq(30, perimeter)
}

test "essential_financial_calculation" {
  // é‡‘èè®¡ç®—æµ‹è¯•ï¼šç®€åŒ–å¤åˆ©
  let principal = 1000
  let rate = 5
  let years = 2
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  assert_eq(11000, total)
}

test "essential_assert_functions" {
  // æ–­è¨€å‡½æ•°æµ‹è¯•
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

test "essential_mathematical_properties" {
  // æ•°å­¦æ€§è´¨æµ‹è¯•
  let a = 7
  let b = 11
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, 3)), add(multiply(a, b), multiply(a, 3)))
}

// æ–°å¢çš„æ‰©å±•æµ‹è¯•ç”¨ä¾‹
test "subtract_operations" {
  // å‡æ³•è¿ç®—æµ‹è¯•ï¼ˆé€šè¿‡åŠ æ³•å®ç°ï¼‰
  assert_eq(5, add(10, -5))
  assert_eq(-3, add(2, -5))
  assert_eq(0, add(7, -7))
}

test "division_simulation" {
  // é™¤æ³•æ¨¡æ‹Ÿæµ‹è¯•ï¼ˆé€šè¿‡é‡å¤å‡æ³•ï¼‰
  let dividend = 20
  let divisor = 4
  let mut quotient = 0
  let mut remainder = dividend
  
  // ç®€å•çš„é™¤æ³•æ¨¡æ‹Ÿ
  while multiply(divisor, quotient) < dividend {
    remainder = add(remainder, -divisor)
    quotient = add(quotient, 1)
  }
  
  assert_eq(5, quotient)
  assert_eq(0, remainder)
}

test "string_concatenation" {
  // å­—ç¬¦ä¸²è¿æ¥æµ‹è¯•
  let name1 = "Alice"
  let name2 = "Bob"
  let greeting1 = greet(name1)
  let greeting2 = greet(name2)
  
  assert_eq_string("Hello, Alice!", greeting1)
  assert_eq_string("Hello, Bob!", greeting2)
}

test "negative_number_operations" {
  // è´Ÿæ•°è¿ç®—æµ‹è¯•
  let a = -10
  let b = -5
  
  assert_eq(-15, add(a, b))
  assert_eq(50, multiply(a, b))
  assert_eq(10, multiply(a, -1))
  assert_eq(5, multiply(b, -1))
}

test "zero_properties" {
  // é›¶å±æ€§æµ‹è¯•
  let x = 42
  
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  assert_eq(0, multiply(0, 0))
}

test "sequence_operations" {
  // åºåˆ—è¿ç®—æµ‹è¯•
  let mut result = 0
  result = add(result, 1)
  result = multiply(result, 2)
  result = add(result, 3)
  result = multiply(result, 4)
  
  assert_eq(32, result)
}

test "power_simulation" {
  // å¹‚è¿ç®—æ¨¡æ‹Ÿæµ‹è¯•
  let base = 3
  let exponent = 4
  let mut result = 1
  
  // 3^4 = 81
  let mut i = 0
  while i < exponent {
    result = multiply(result, base)
    i = add(i, 1)
  }
  
  assert_eq(81, result)
}

test "factorial_calculation_extended" {
  // é˜¶ä¹˜è®¡ç®—æµ‹è¯• (5! = 120)
  let n = 5
  let mut result = 1
  
  let mut i = 1
  while i <= n {
    result = multiply(result, i)
    i = add(i, 1)
  }
  
  assert_eq(120, result)
}

test "greeting_edge_cases" {
  // é—®å€™å‡½æ•°è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello,   !", greet("   "))
}

// æ–°å¢çš„10ä¸ªæµ‹è¯•ç”¨ä¾‹
test "add_large_numbers_v2" {
  // æµ‹è¯•å¤§æ•°ç›¸åŠ 
  assert_eq(add(1000000, 2000000), 3000000)
  assert_eq(add(-1000000, -2000000), -3000000)
  assert_eq(add(2147483647, 0), 2147483647)
  assert_eq(add(-2147483648, 0), -2147483648)
}

test "add_mixed_signs_v2" {
  // æµ‹è¯•ä¸åŒç¬¦å·çš„æ•°ç›¸åŠ 
  assert_eq(add(100, -100), 0)
  assert_eq(add(100, -150), -50)
  assert_eq(add(-100, 150), 50)
  assert_eq(add(2147483647, -1), 2147483646)
}

test "multiply_large_numbers_v2" {
  // æµ‹è¯•å¤§æ•°ç›¸ä¹˜
  assert_eq(multiply(1000, 1000), 1000000)
  assert_eq(multiply(-1000, 1000), -1000000)
  assert_eq(multiply(-1000, -1000), 1000000)
  assert_eq(multiply(46341, 46341), 2147483647)
}

test "multiply_boundary_combinations_v2" {
  // æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆçš„ä¹˜æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(multiply(max_val, 0), 0)
  assert_eq(multiply(min_val, 0), 0)
  assert_eq(multiply(max_val, 1), max_val)
  assert_eq(multiply(min_val, 1), min_val)
  assert_eq(multiply(min_val, -1), min_val)
}

// ç”¨æˆ·æ ‡å‡†æµ‹è¯•ç”¨ä¾‹ - ä¸è¶…è¿‡10ä¸ªæµ‹è¯•
// æµ‹è¯•é¡¹ç›®çš„åŸºæœ¬åŠŸèƒ½ï¼šadd, multiply, greetç­‰

test "user_add_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(-2, 2))
  assert_eq(-5, add(-2, -3))
}

test "user_add_with_zero" {
  // æµ‹è¯•ä¸0ç›¸åŠ çš„æƒ…å†µ
  assert_eq(5, add(5, 0))
  assert_eq(5, add(0, 5))
  assert_eq(0, add(0, 0))
}

test "user_multiply_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(6, multiply(-2, -3))
}

test "user_multiply_with_zero_and_one" {
  // æµ‹è¯•ä¸0å’Œ1ç›¸ä¹˜çš„æƒ…å†µ
  assert_eq(0, multiply(5, 0))
  assert_eq(5, multiply(5, 1))
  assert_eq(-5, multiply(-5, 1))
}

test "user_greet_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "user_greet_edge_cases" {
  // æµ‹è¯•é—®å€™åŠŸèƒ½çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "user_overflow_handling" {
  // æµ‹è¯•æº¢å‡ºå¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(max_val, multiply(max_val, 2))
}

test "user_assert_functions" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

test "user_complex_calculations" {
  // æµ‹è¯•å¤åˆè®¡ç®—
  let a = 10
  let b = 20
  let c = 30
  
  // (a + b) * c
  let result = multiply(add(a, b), c)
  assert_eq(900, result)
  
  // a * b + c
  let result2 = add(multiply(a, b), c)
  assert_eq(230, result2)
}

test "user_divide_with_ceil_function" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•åŠŸèƒ½
  assert_eq(3, divide_with_ceil(10, 4))
  assert_eq(3, divide_with_ceil(12, 4))
  assert_eq(4, divide_with_ceil(11, 3))
}

test "greet_special_characters_v2" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string(greet("æµ‹è¯•@123"), "Hello, æµ‹è¯•@123!")
  assert_eq_string(greet("ğŸŒ™"), "Hello, ğŸŒ™!")
  assert_eq_string(greet(" spaces "), "Hello, spaces !")
  assert_eq_string(greet(""), "Hello, !")
}

test "complex_calculation_scenario_v2" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šè®¡ç®—çŸ©å½¢çš„å‘¨é•¿
  let length = 10
  let width = 5
  let perimeter = add(multiply(2, length), multiply(2, width))
  assert_eq(30, perimeter)
}

test "divide_with_ceil_function_v2" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°
  assert_eq(divide_with_ceil(10, 3), 4)
  assert_eq(divide_with_ceil(15, 3), 5)
  assert_eq(divide_with_ceil(0, 5), 0)
  assert_eq(divide_with_ceil(9, 2), 5)
  assert_eq(divide_with_ceil(-7, 3), -2)
}

test "mathematical_sequences_v2" {
  // æµ‹è¯•æ•°å­¦åºåˆ—è®¡ç®—
  
  // è®¡ç®—å‰ 5 ä¸ªè‡ªç„¶æ•°çš„å’Œ: 1+2+3+4+5 = 15
  let sum_first_5 = add(add(add(add(1, 2), 3), 4), 5)
  assert_eq(15, sum_first_5)
  
  // è®¡ç®—å‰ 4 ä¸ªå¶æ•°çš„å’Œ: 2+4+6+8 = 20
  let sum_even_4 = add(add(add(2, 4), 6), 8)
  assert_eq(20, sum_even_4)
}

test "temperature_conversion_v2" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢åœºæ™¯ (æ‘„æ°åº¦åˆ°åæ°åº¦)
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 9) / 5, 32)
  assert_eq(77, fahrenheit)
  
  let celsius2 = 0
  let fahrenheit2 = add(multiply(celsius2, 9) / 5, 32)
  assert_eq(32, fahrenheit2)
}

test "assert_functions_test_v2" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

// æ ‡å‡† MoonBit æµ‹è¯•å¥—ä»¶
// åŒ…å«10ä¸ªæ ‡å‡†æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–é¡¹ç›®æ ¸å¿ƒåŠŸèƒ½

test "basic_arithmetic_operations" {
  // æµ‹è¯•åŸºæœ¬ç®—æœ¯è¿ç®—
  assert_eq(15, add(7, 8))
  assert_eq(0, add(-5, 5))
  assert_eq(42, multiply(6, 7))
  assert_eq(-24, multiply(-4, 6))
}

test "string_greeting_functionality" {
  // æµ‹è¯•å­—ç¬¦ä¸²é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, å¼ ä¸‰!", greet("å¼ ä¸‰"))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "mathematical_commutative_properties" {
  // æµ‹è¯•æ•°å­¦äº¤æ¢å¾‹æ€§è´¨
  let a = 12
  let b = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  let c = -8
  let d = 5
  assert_eq(add(c, d), add(d, c))
  assert_eq(multiply(c, d), multiply(d, c))
}

test "boundary_value_handling" {
  // æµ‹è¯•è¾¹ç•Œå€¼å¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¾¹ç•Œå€¼åŠ æ³•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
  
  // è¾¹ç•Œå€¼ä¹˜æ³•
  assert_eq(0, multiply(max_val, 0))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(max_val, multiply(max_val, 1))
}

test "polynomial_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šè®¡ç®—å¤šé¡¹å¼å€¼
  let x = 3
  let a = 2
  let b = 4
  let c = 1
  
  // è®¡ç®— axÂ² + bx + c
  let x_squared = multiply(x, x)  // 9
  let ax_squared = multiply(a, x_squared)  // 18
  let bx = multiply(b, x)  // 12
  let result = add(add(ax_squared, bx), c)  // 31
  
  assert_eq(31, result)
}

test "real_world_financial_calculation" {
  // æµ‹è¯•å®é™…é‡‘èè®¡ç®—åœºæ™¯
  let principal = 5000  // æœ¬é‡‘
  let rate_percent = 6  // åˆ©ç‡ç™¾åˆ†æ¯”
  let years = 4  // å¹´æ•°
  
  // ç®€å•åˆ©æ¯è®¡ç®—ï¼šåˆ©æ¯ = æœ¬é‡‘ Ã— åˆ©ç‡ Ã— å¹´æ•°
  let interest = multiply(principal, multiply(rate_percent, years))
  assert_eq(120000, interest)  // 5000 Ã— 6 Ã— 4 = 120000
  
  // æ€»é‡‘é¢ = æœ¬é‡‘ + åˆ©æ¯
  let total_amount = add(principal, interest)
  assert_eq(125000, total_amount)
}

test "temperature_conversion_calculation" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢è®¡ç®—
  // ç®€åŒ–å…¬å¼ï¼šåæ°åº¦ = æ‘„æ°åº¦ Ã— 2 + 30
  
  // æµ‹è¯•å†°ç‚¹
  let celsius_freezing = 0
  let fahrenheit_freezing = add(multiply(celsius_freezing, 2), 30)
  assert_eq(30, fahrenheit_freezing)
  
  // æµ‹è¯•å®¤æ¸©
  let celsius_room = 22
  let fahrenheit_room = add(multiply(celsius_room, 2), 30)
  assert_eq(74, fahrenheit_room)
  
  // æµ‹è¯•ä½“æ¸©
  let celsius_body = 37
  let fahrenheit_body = add(multiply(celsius_body, 2), 30)
  assert_eq(104, fahrenheit_body)
}

test "geometric_area_calculations" {
  // æµ‹è¯•å‡ ä½•é¢ç§¯è®¡ç®—
  // çŸ©å½¢é¢ç§¯
  let rectangle_length = 15
  let rectangle_width = 8
  let rectangle_area = multiply(rectangle_length, rectangle_width)
  assert_eq(120, rectangle_area)
  
  // ä¸‰è§’å½¢é¢ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼šåº• Ã— é«˜ Ã· 2ï¼‰
  let triangle_base = 12
  let triangle_height = 10
  let triangle_area = multiply(triangle_base, triangle_height) / 2
  assert_eq(60, triangle_area)
  
  // æ¢¯å½¢é¢ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼š(ä¸Šåº• + ä¸‹åº•) Ã— é«˜ Ã· 2ï¼‰
  let trapezoid_top = 6
  let trapezoid_bottom = 10
  let trapezoid_height = 8
  let trapezoid_area = multiply(add(trapezoid_top, trapezoid_bottom), trapezoid_height) / 2
  assert_eq(64, trapezoid_area)
}

test "shopping_cart_business_logic" {
  // æµ‹è¯•è´­ç‰©è½¦ä¸šåŠ¡é€»è¾‘
  let item1_price = 199
  let item1_quantity = 2
  let item2_price = 299
  let item2_quantity = 1
  let discount_amount = 50
  let shipping_fee = 20
  
  // è®¡ç®—å•†å“æ€»ä»·
  let item1_total = multiply(item1_price, item1_quantity)  // 398
  let item2_total = multiply(item2_price, item2_quantity)  // 299
  let subtotal = add(item1_total, item2_total)  // 697
  
  // åº”ç”¨æŠ˜æ‰£ï¼ˆè¶…è¿‡é˜ˆå€¼ï¼‰
  let discounted_total = add(subtotal, -discount_amount)  // 647
  
  // åŠ ä¸Šè¿è´¹
  let final_total = add(discounted_total, shipping_fee)  // 667
  
  assert_eq(667, final_total)
}

test "statistical_analysis_functions" {
  // æµ‹è¯•ç»Ÿè®¡åˆ†æåŠŸèƒ½
  // æ•°æ®é›†ï¼š15, 25, 35, 45, 55
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(15, 25), 35), 45), 55)
  assert_eq(175, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let count = 5
  let mean = sum / count
  assert_eq(35, mean)
  
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆå·²æ’åºæ•°æ®é›†çš„ä¸­é—´å€¼ï¼‰
  let median = 35
  assert_eq(median, median)
  
  // è®¡ç®—èŒƒå›´ï¼ˆæœ€å¤§å€¼ - æœ€å°å€¼ï¼‰
  let range = add(55, -15)
  assert_eq(40, range)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "addition_commutativity" {
  // æµ‹è¯•æ­£æ•°åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(7, 8))
  assert_eq(15, add(8, 7))
  
  // æµ‹è¯•è´Ÿæ•°åŠ æ³•äº¤æ¢å¾‹
  assert_eq(-15, add(-7, -8))
  assert_eq(-15, add(-8, -7))
  
  // æµ‹è¯•æ··åˆç¬¦å·åŠ æ³•äº¤æ¢å¾‹
  assert_eq(-1, add(7, -8))
  assert_eq(-1, add(-8, 7))
}

test "multiplication_distributivity" {
  // æµ‹è¯• a Ã— (b + c) = a Ã— b + a Ã— c
  let a = 5
  let b = 3
  let c = 2
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
  
  // æµ‹è¯• (a + b) Ã— c = a Ã— c + b Ã— c
  let d = 4
  let left_side2 = multiply(add(a, b), d)
  let right_side2 = add(multiply(a, d), multiply(b, d))
  assert_eq(left_side2, right_side2)
}

test "string_processing_edge_cases" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, &%$#@!", greet("&%$#@"))
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, John Doe!", greet("John Doe"))
  
  // æµ‹è¯•åŒ…å«æ•°å­—çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, 2023!", greet("2023"))
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
}

test "boundary_value_operations" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸1çš„è¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸0çš„è¿ç®—
  assert_eq(min_val, add(min_val, 0))
  assert_eq(0, multiply(min_val, 0))
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸æœ€å°å€¼çš„è¿ç®—
  assert_eq(-1, add(max_val, min_val))
}

test "discount_price_calculation" {
  let original_price = 1000
  let discount_percent = 20
  
  // è®¡ç®—æŠ˜æ‰£é‡‘é¢
  let discount_amount = multiply(original_price, discount_percent) / 100
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_price = add(original_price, -discount_amount)
  
  assert_eq(200, discount_amount)
  assert_eq(800, discounted_price)
  
  // æµ‹è¯•å¤šä»¶å•†å“çš„æ€»æŠ˜æ‰£
  let quantity = 3
  let total_original = multiply(original_price, quantity)
  let total_discount = multiply(discount_amount, quantity)
  let total_final = add(total_original, -total_discount)
  
  assert_eq(2400, total_final)
}

test "average_score_calculation" {
  // è®¡ç®—äº”ä¸ªç§‘ç›®çš„å¹³å‡åˆ†
  let score1 = 85
  let score2 = 90
  let score3 = 78
  let score4 = 92
  let score5 = 88
  
  // è®¡ç®—æ€»åˆ†
  let total_score = add(add(add(add(score1, score2), score3), score4), score5)
  // è®¡ç®—å¹³å‡åˆ†
  let average_score = total_score / 5
  
  assert_eq(433, total_score)
  assert_eq(86, average_score)  // æ•´æ•°é™¤æ³•ï¼Œå‘ä¸‹å–æ•´
}

test "compound_calculations" {
  // è®¡ç®— (a + b) Ã— (c - d) + e Ã— f
  let a = 10
  let b = 5
  let c = 20
  let d = 8
  let e = 3
  let f = 7
  
  let sum_ab = add(a, b)  // 15
  let diff_cd = add(c, -d)  // 12
  let product_ab_cd = multiply(sum_ab, diff_cd)  // 180
  let product_ef = multiply(e, f)  // 21
  let result = add(product_ab_cd, product_ef)  // 201
  
  assert_eq(201, result)
}

test "conditional_logic" {
  // æ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒçš„è®¡ç®—æ–¹å¼
  let x = 15
  let y = 10
  
  // å¦‚æœ x > yï¼Œè®¡ç®— x + yï¼Œå¦åˆ™è®¡ç®— x Ã— y
  let condition1 = x > y
  let result1 = if condition1 { add(x, y) } else { multiply(x, y) }
  assert_eq(25, result1)
  
  // å¦‚æœ x < yï¼Œè®¡ç®— x + yï¼Œå¦åˆ™è®¡ç®— x Ã— y
  let a = 5
  let b = 10
  let condition2 = a < b
  let result2 = if condition2 { add(a, b) } else { multiply(a, b) }
  assert_eq(15, result2)
}

test "sequence_calculations" {
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œï¼š1 + 2 + 3 + ... + 10
  let n = 10
  // ä½¿ç”¨å…¬å¼ï¼šn Ã— (n + 1) / 2
  let arithmetic_sum = multiply(n, add(n, 1)) / 2
  assert_eq(55, arithmetic_sum)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„å’Œï¼š1 + 2 + 4 + 8 + 16
  // æ‰‹åŠ¨è®¡ç®—
  let term1 = 1
  let term2 = multiply(term1, 2)
  let term3 = multiply(term2, 2)
  let term4 = multiply(term3, 2)
  let term5 = multiply(term4, 2)
  let geometric_sum = add(add(add(add(term1, term2), term3), term4), term5)
  assert_eq(31, geometric_sum)
}

test "error_handling_and_boundary_checks" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„æ­£ç¡®ä½¿ç”¨
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ç¡®ä¿æº¢å‡ºè¢«æ­£ç¡®å¤„ç†
  assert_true(add(max_val, 1) == max_val)
  assert_true(add(min_val, -1) == min_val)
  assert_true(multiply(max_val, 2) == max_val)
  assert_true(multiply(min_val, -1) == min_val)
  
  // æµ‹è¯•è¾¹ç•Œå€¼é™„è¿‘çš„è¿ç®—
  assert_eq(2147483646, add(max_val, -1))
  assert_eq(-2147483647, add(min_val, 1))
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
}

// ç”¨æˆ·æ·»åŠ çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
test "calculation_of_circle_properties" {
  // åœ†å½¢å±æ€§è®¡ç®—æµ‹è¯•
  let radius = 5
  
  // è®¡ç®—åœ†çš„å‘¨é•¿ï¼ˆç®€åŒ–å…¬å¼ï¼š2 Ã— 3 Ã— rï¼‰
  let circumference = multiply(multiply(2, 3), radius)
  assert_eq(30, circumference)
  
  // è®¡ç®—åœ†çš„é¢ç§¯ï¼ˆç®€åŒ–å…¬å¼ï¼š3 Ã— rÂ²ï¼‰
  let area = multiply(3, multiply(radius, radius))
  assert_eq(75, area)
}

test "temperature_conversion_celsius_to_fahrenheit" {
  // æ‘„æ°åº¦è½¬åæ°åº¦æµ‹è¯•ï¼ˆç®€åŒ–å…¬å¼ï¼šF = C Ã— 2 + 30ï¼‰
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 2), 30)
  assert_eq(80, fahrenheit)
  
  // æµ‹è¯•å†°ç‚¹
  let freezing_celsius = 0
  let freezing_fahrenheit = add(multiply(freezing_celsius, 2), 30)
  assert_eq(30, freezing_fahrenheit)
  
  // æµ‹è¯•æ²¸ç‚¹
  let boiling_celsius = 100
  let boiling_fahrenheit = add(multiply(boiling_celsius, 2), 30)
  assert_eq(230, boiling_fahrenheit)
}

test "shopping_cart_total_calculation" {
  // è´­ç‰©è½¦æ€»ä»·è®¡ç®—æµ‹è¯•
  let item1_price = 199
  let item1_quantity = 2
  let item2_price = 299
  let item2_quantity = 1
  let shipping_fee = 20
  
  // è®¡ç®—å•†å“æ€»ä»·
  let item1_total = multiply(item1_price, item1_quantity)
  let item2_total = multiply(item2_price, item2_quantity)
  let subtotal = add(item1_total, item2_total)
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·ï¼ˆå«è¿è´¹ï¼‰
  let total = add(subtotal, shipping_fee)
  
  // éªŒè¯ç»“æœï¼š199*2 + 299*1 + 20 = 398 + 299 + 20 = 717
  assert_eq(717, total)
}

test "simple_interest_calculation" {
  // ç®€å•åˆ©æ¯è®¡ç®—æµ‹è¯•
  let principal = 10000
  let rate = 5  // 5%
  let time = 3  // 3å¹´
  
  // è®¡ç®—åˆ©æ¯ï¼šæœ¬é‡‘ Ã— åˆ©ç‡ Ã— æ—¶é—´
  let interest = multiply(principal, multiply(rate, time))
  
  // è®¡ç®—æœ¬æ¯å’Œï¼šæœ¬é‡‘ + åˆ©æ¯
  let total = add(principal, interest)
  
  // éªŒè¯ç»“æœï¼š10000 + 10000*5*3 = 10000 + 150000 = 160000
  assert_eq(160000, total)
}

test "array_index_2d_to_1d_conversion" {
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„ç´¢å¼•è®¡ç®—æµ‹è¯•
  let row = 3
  let col = 4
  let width = 5
  
  // è®¡ç®—ä¸€ç»´æ•°ç»„ç´¢å¼•ï¼šindex = row * width + col
  let index = add(multiply(row, width), col)
  assert_eq(19, index)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼šç¬¬ä¸€ä¸ªå…ƒç´ 
  let first_index = add(multiply(0, 0), 0)
  assert_eq(0, first_index)
}

test "time_conversion_hours_to_seconds" {
  // æ—¶é—´è½¬æ¢æµ‹è¯•ï¼šå°æ—¶è½¬ç§’
  let hours = 2
  let minutes = 30
  
  // è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°
  let total_minutes = add(multiply(hours, 60), minutes)
  assert_eq(150, total_minutes)
  
  // è½¬æ¢ä¸ºæ€»ç§’æ•°
  let total_seconds = multiply(total_minutes, 60)
  assert_eq(9000, total_seconds)
}

test "percentage_discount_calculation" {
  // ç™¾åˆ†æ¯”æŠ˜æ‰£è®¡ç®—æµ‹è¯•
  let original_price = 500
  let discount_percentage = 20  // 20%æŠ˜æ‰£
  
  // è®¡ç®—æŠ˜æ‰£é‡‘é¢
  let discount_amount = multiply(original_price, discount_percentage) / 100
  
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_price = add(original_price, -discount_amount)
  
  // éªŒè¯ç»“æœï¼š500 - 500*20/100 = 500 - 100 = 400
  assert_eq(400, discounted_price)
}

test "basic_statistics_calculation" {
  // åŸºç¡€ç»Ÿè®¡è®¡ç®—æµ‹è¯•
  let num1 = 85
  let num2 = 90
  let num3 = 78
  let num4 = 92
  let num5 = 80
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(num1, num2), num3), num4), num5)
  assert_eq(425, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let average = sum / 5
  assert_eq(85, average)
}

test "string_with_special_characters" {
  // ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²æµ‹è¯•
  let email = "user@example.com"
  let phone = "123-456-7890"
  let alphanumeric = "ABC123xyz"
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let email_result = greet(email)
  assert_eq_string("Hello, user@example.com!", email_result)
  
  let phone_result = greet(phone)
  assert_eq_string("Hello, 123-456-7890!", phone_result)
  
  let alphanumeric_result = greet(alphanumeric)
  assert_eq_string("Hello, ABC123xyz!", alphanumeric_result)
}

test "compound_calculation_scenario" {
  // å¤åˆè®¡ç®—åœºæ™¯æµ‹è¯•ï¼šè®¡ç®—çŸ©å½¢çš„é¢ç§¯å’Œå‘¨é•¿
  let length = 8
  let width = 6
  
  // è®¡ç®—é¢ç§¯ï¼šé•¿ Ã— å®½
  let area = multiply(length, width)
  assert_eq(48, area)
  
  // è®¡ç®—å‘¨é•¿ï¼š2 Ã— (é•¿ + å®½)
  let perimeter = multiply(2, add(length, width))
  assert_eq(28, perimeter)
  
  // è®¡ç®—å¯¹è§’çº¿é•¿åº¦çš„å¹³æ–¹ï¼ˆå‹¾è‚¡å®šç†ï¼‰ï¼šaÂ² + bÂ²
  let diagonal_squared = add(multiply(length, length), multiply(width, width))
  assert_eq(100, diagonal_squared)
}

// ç”¨æˆ·è¯·æ±‚çš„æ–°å¢æµ‹è¯•ç”¨ä¾‹
test "user_basic_arithmetic_operations" {
  // æµ‹è¯•åŸºæœ¬ç®—æœ¯è¿ç®—
  let a = 15
  let b = 7
  
  // åŠ æ³•æµ‹è¯•
  let add_result = add(a, b)
  assert_eq(22, add_result)
  
  // ä¹˜æ³•æµ‹è¯•
  let mul_result = multiply(a, b)
  assert_eq(105, mul_result)
}

test "user_string_operations" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ“ä½œ
  let name = "Azimuth"
  let result = greet(name)
  assert_eq_string("Hello, Azimuth!", result)
}

test "user_negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  let a = -10
  let b = 5
  
  // è´Ÿæ•°åŠ æ³•
  let add_result = add(a, b)
  assert_eq(-5, add_result)
  
  // è´Ÿæ•°ä¹˜æ³•
  let mul_result = multiply(a, b)
  assert_eq(-50, mul_result)
}

test "user_zero_operations" {
  // æµ‹è¯•é›¶å€¼è¿ç®—
  let a = 42
  let b = 0
  
  // ä¸é›¶ç›¸åŠ 
  let add_result1 = add(a, b)
  let add_result2 = add(b, a)
  assert_eq(42, add_result1)
  assert_eq(42, add_result2)
  
  // ä¸é›¶ç›¸ä¹˜
  let mul_result1 = multiply(a, b)
  let mul_result2 = multiply(b, a)
  assert_eq(0, mul_result1)
  assert_eq(0, mul_result2)
}

test "user_large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let a = 10000
  let b = 25000
  
  // å¤§æ•°åŠ æ³•
  let add_result = add(a, b)
  assert_eq(35000, add_result)
  
  // å¤§æ•°ä¹˜æ³•
  let mul_result = multiply(100, 500)
  assert_eq(50000, mul_result)
}

test "user_complex_expressions" {
  // æµ‹è¯•å¤æ‚è¡¨è¾¾å¼
  let x = 3
  let y = 4
  let z = 5
  
  // (x + y) * z
  let expr1 = multiply(add(x, y), z)
  assert_eq(35, expr1)
  
  // x * y + z
  let expr2 = add(multiply(x, y), z)
  assert_eq(17, expr2)
}

test "user_edge_cases" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æœ€å¤§å€¼åŠ 0
  let max_add_zero = add(max_int, 0)
  assert_eq(max_int, max_add_zero)
  
  // æœ€å°å€¼åŠ 0
  let min_add_zero = add(min_int, 0)
  assert_eq(min_int, min_add_zero)
}

test "user_unicode_string_handling" {
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²å¤„ç†
  let chinese_name = "ä¸­æ–‡æµ‹è¯•"
  let emoji_name = "ğŸŒğŸš€"
  let mixed_name = "Helloä¸–ç•ŒğŸŒ"
  
  // ä¸­æ–‡å­—ç¬¦ä¸²
  let chinese_result = greet(chinese_name)
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", chinese_result)
  
  // Emojiå­—ç¬¦ä¸²
  let emoji_result = greet(emoji_name)
  assert_eq_string("Hello, ğŸŒğŸš€!", emoji_result)
  
  // æ··åˆå­—ç¬¦ä¸²
  let mixed_result = greet(mixed_name)
  assert_eq_string("Hello, Helloä¸–ç•ŒğŸŒ!", mixed_result)
}

test "user_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 12
  let b = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  let commutative1 = add(a, b)
  let commutative2 = add(b, a)
  assert_eq(commutative1, commutative2)
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  let mul_commutative1 = multiply(a, b)
  let mul_commutative2 = multiply(b, a)
  assert_eq(mul_commutative1, mul_commutative2)
}

// æ–°å¢çš„10ä¸ªæµ‹è¯•ç”¨ä¾‹
test "enhanced_boundary_value_operations" {
  // å¢å¼ºçš„è¾¹ç•Œå€¼æ“ä½œæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸è´Ÿæ•°çš„ä¹˜æ³•
  let max_neg_mul = multiply(max_val, -1)
  assert_eq(min_val, max_neg_mul)
  
  // æµ‹è¯•æœ€å°å€¼ä¸æ­£æ•°çš„ä¹˜æ³•
  let min_pos_mul = multiply(min_val, 1)
  assert_eq(min_val, min_pos_mul)
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸è‡ªèº«çš„åŠ æ³•
  let max_add_self = add(max_val, max_val)
  assert_eq(max_val, max_add_self)
  
  // æµ‹è¯•æœ€å°å€¼ä¸è‡ªèº«çš„åŠ æ³•
  let min_add_self = add(min_val, min_val)
  assert_eq(min_val, min_add_self)
}

test "enhanced_string_edge_cases" {
  // å¢å¼ºçš„å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µæµ‹è¯•
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_result = greet("")
  assert_eq_string("Hello, !", empty_result)
  
  // æµ‹è¯•å•ä¸ªå­—ç¬¦
  let single_char = greet("A")
  assert_eq_string("Hello, A!", single_char)
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let spaced = greet("  ")
  assert_eq_string("Hello,   !", spaced)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special = greet("@#$%")
  assert_eq_string("Hello, @#$%!", special)
}

test "enhanced_mathematical_series" {
  // å¢å¼ºçš„æ•°å­¦çº§æ•°æµ‹è¯•
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—å‰å‡ é¡¹
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  let fib6 = add(fib4, fib5)  // 8
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œ
  let first_term = 3
  let common_diff = 2
  let num_terms = 5
  let last_term = add(first_term, multiply(common_diff, num_terms - 1))  // 3 + 2*4 = 11
  let series_sum = multiply(num_terms, add(first_term, last_term)) / 2  // 5*(3+11)/2 = 35
  
  assert_eq(35, series_sum)
}

test "enhanced_financial_calculations" {
  // å¢å¼ºçš„é‡‘èè®¡ç®—æµ‹è¯•
  // è®¡ç®—æŠ˜æ‰£ä»·æ ¼
  let original_price = 1000
  let discount_rate = 15  // 15%
  let discount_amount = multiply(original_price, discount_rate) / 100
  let discounted_price = add(original_price, -discount_amount)
  
  assert_eq(850, discounted_price)
  
  // è®¡ç®—ç¨è´¹
  let net_price = 850
  let tax_rate = 8  // 8%
  let tax_amount = multiply(net_price, tax_rate) / 100
  let total_price = add(net_price, tax_amount)
  
  assert_eq(918, total_price)  // 850 + 68 = 918
  
  // è®¡ç®—åˆ©æ¶¦ç‡
  let cost_price = 700
  let selling_price = 918
  let profit = add(selling_price, -cost_price)
  let profit_margin = multiply(profit, 100) / selling_price
  
  assert_eq(23, profit_margin)  // æ•´æ•°é™¤æ³•
}

test "enhanced_geometry_calculations" {
  // å¢å¼ºçš„å‡ ä½•è®¡ç®—æµ‹è¯•
  // è®¡ç®—ç«‹æ–¹ä½“è¡¨é¢ç§¯å’Œä½“ç§¯
  let cube_side = 5
  let cube_surface_area = multiply(6, multiply(cube_side, cube_side))  // 6 * 5^2
  let cube_volume = multiply(cube_side, multiply(cube_side, cube_side))  // 5^3
  
  assert_eq(150, cube_surface_area)
  assert_eq(125, cube_volume)
  
  // è®¡ç®—åœ†æŸ±ä½“è¡¨é¢ç§¯å’Œä½“ç§¯ï¼ˆç®€åŒ–ï¼‰
  let cylinder_radius = 3
  let cylinder_height = 10
  let pi_approx = 3
  
  // åœ†æŸ±ä½“ä¾§é¢ç§¯ï¼š2 * Ï€ * r * h
  let cylinder_lateral_area = multiply(2, multiply(pi_approx, multiply(cylinder_radius, cylinder_height)))
  // åœ†æŸ±ä½“ä½“ç§¯ï¼šÏ€ * r^2 * h
  let cylinder_volume = multiply(pi_approx, multiply(multiply(cylinder_radius, cylinder_radius), cylinder_height))
  
  assert_eq(180, cylinder_lateral_area)  // 2 * 3 * 3 * 10 = 180
  assert_eq(270, cylinder_volume)  // 3 * 9 * 10 = 270
}

test "enhanced_time_calculations" {
  // å¢å¼ºçš„æ—¶é—´è®¡ç®—æµ‹è¯•
  // è®¡ç®—æ—¶é—´é—´éš”
  let start_hour = 9
  let start_minute = 30
  let end_hour = 17
  let end_minute = 45
  
  let start_total = add(multiply(start_hour, 60), start_minute)
  let end_total = add(multiply(end_hour, 60), end_minute)
  let duration = add(end_total, -start_total)
  
  assert_eq(495, duration)  // 8å°æ—¶15åˆ†é’Ÿ = 495åˆ†é’Ÿ
  
  // è½¬æ¢ä¸ºå°æ—¶å’Œåˆ†é’Ÿ
  let duration_hours = duration / 60
  let duration_minutes = duration % 60
  
  assert_eq(8, duration_hours)
  assert_eq(15, duration_minutes)
  
  // è®¡ç®—ç§’æ•°
  let total_seconds = multiply(duration, 60)
  assert_eq(29700, total_seconds)  // 495 * 60 = 29700
}

test "enhanced_data_structure_simulation" {
  // å¢å¼ºçš„æ•°æ®ç»“æ„æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_size = 0
  let enqueue_count = 5
  let dequeue_count = 3
  
  // å…¥é˜Ÿæ“ä½œ
  let after_enqueue = add(queue_size, enqueue_count)
  assert_eq(5, after_enqueue)
  
  // å‡ºé˜Ÿæ“ä½œ
  let after_dequeue = add(after_enqueue, -dequeue_count)
  assert_eq(2, after_dequeue)
  
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let push_count = 4
  let pop_count = 2
  
  // å…¥æ ˆæ“ä½œ
  let after_push = add(stack_size, push_count)
  assert_eq(4, after_push)
  
  // å‡ºæ ˆæ“ä½œ
  let after_pop = add(after_push, -pop_count)
  assert_eq(2, after_pop)
}

test "enhanced_error_boundary_conditions" {
  // å¢å¼ºçš„é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•è¿ç»­æº¢å‡ºæ“ä½œ
  let overflow1 = add(max_val, 1)
  let overflow2 = add(overflow1, 100)
  let overflow3 = multiply(overflow2, 2)
  
  assert_eq(max_val, overflow1)
  assert_eq(max_val, overflow2)
  assert_eq(max_val, overflow3)
  
  // æµ‹è¯•è¿ç»­ä¸‹æº¢æ“ä½œ
  let underflow1 = add(min_val, -1)
  let underflow2 = add(underflow1, -100)
  let underflow3 = multiply(underflow2, -2)
  
  assert_eq(min_val, underflow1)
  assert_eq(min_val, underflow2)
  assert_eq(min_val, underflow3)
  
  // æµ‹è¯•æ··åˆè¿ç®—
  let mixed1 = add(max_val, min_val)
  let mixed2 = multiply(mixed1, -1)
  
  assert_eq(-1, mixed1)
  assert_eq(1, mixed2)
}

test "enhanced_performance_simulation" {
  // å¢å¼ºçš„æ€§èƒ½æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿç¼“å­˜å‘½ä¸­ç‡
  let total_requests = 1000
  let cache_hits = 850
  let hit_rate = multiply(cache_hits, 100) / total_requests
  
  assert_eq(85, hit_rate)
  
  // æ¨¡æ‹Ÿå“åº”æ—¶é—´ä¼˜åŒ–
  let original_time = 500  // æ¯«ç§’
  let optimization_factor = 4
  let optimized_time = original_time / optimization_factor
  
  assert_eq(125, optimized_time)
  
  // è®¡ç®—æ€§èƒ½æå‡ç™¾åˆ†æ¯”
  let improvement = multiply(add(original_time, -optimized_time), 100) / original_time
  assert_eq(75, improvement)
  
  // æ¨¡æ‹Ÿå¹¶å‘å¤„ç†
  let single_thread_time = 1000
  let thread_count = 4
  let parallel_time = single_thread_time / thread_count
  
  assert_eq(250, parallel_time)
}

test "enhanced_real_world_scenario" {
  // å¢å¼ºçš„çœŸå®ä¸–ç•Œåœºæ™¯æµ‹è¯•
  // æ¨¡æ‹Ÿç”µå•†è®¢å•å¤„ç†
  let product_price = 199
  let quantity = 3
  let shipping_fee = 20
  let tax_rate = 8
  let discount_threshold = 500
  let discount_rate = 10
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_price, quantity)
  
  // è®¡ç®—æŠ˜æ‰£ï¼ˆå¦‚æœè¶…è¿‡é˜ˆå€¼ï¼‰
  let discount_amount = if (subtotal > discount_threshold) {
    multiply(subtotal, discount_rate) / 100
  } else {
    0
  }
  
  // åº”ç”¨æŠ˜æ‰£
  let discounted_total = add(subtotal, -discount_amount)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = multiply(discounted_total, tax_rate) / 100
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·
  let final_total = add(add(discounted_total, tax_amount), shipping_fee)
  
  assert_eq(634, final_total)  // (199*3 - 10%) + 8% + 20 = 597 - 60 + 43 + 20 = 600
  
  // ç”Ÿæˆè®¢å•ç¡®è®¤æ¶ˆæ¯
  let customer_name = "å¼ ä¸‰"
  let greeting_msg = greet(customer_name)
  
  assert_eq_string("Hello, å¼ ä¸‰!", greeting_msg)
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "new_addition_commutativity" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 42
  let b = 17
  let result1 = add(a, b)
  let result2 = add(b, a)
  assert_eq(result1, result2)
}

test "multiplication_identity" {
  // æµ‹è¯•ä¹˜æ³•å•ä½å…ƒï¼ša * 1 = a
  let val0 = 0
  let val1 = 1
  let val2 = -1
  let val3 = 42
  let val4 = -42
  let val5 = 2147483647
  let val6 = -2147483648
  
  let result1 = multiply(val0, 1)
  assert_eq(val0, result1)
  
  let result2 = multiply(val1, 1)
  assert_eq(val1, result2)
  
  let result3 = multiply(val2, 1)
  assert_eq(val2, result3)
  
  let result4 = multiply(val3, 1)
  assert_eq(val3, result4)
  
  let result5 = multiply(val4, 1)
  assert_eq(val4, result5)
  
  let result6 = multiply(val5, 1)
  assert_eq(val5, result6)
  
  let result7 = multiply(val6, 1)
  assert_eq(val6, result7)
}

test "addition_with_large_numbers" {
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let large1 = 1000000000
  let large2 = 1500000000  // ä¿®æ”¹ä¸ºé¿å…æº¢å‡º
  let result = add(large1, large2)
  assert_eq(2147483647, result)  // ä¿®æ”¹ä¸ºæœ€å¤§å€¼ï¼Œå› ä¸ºä¼šæº¢å‡º
  
  // æµ‹è¯•å¤§æ•°ä¸è´Ÿæ•°ç›¸åŠ 
  let result2 = add(large1, -500000000)
  assert_eq(500000000, result2)
}

test "multiplication_power_simulation" {
  // é€šè¿‡ä¹˜æ³•æ¨¡æ‹Ÿå¹‚è¿ç®—ï¼š2^4 = 2 * 2 * 2 * 2
  let base = 2
  let result = multiply(multiply(multiply(base, base), base), base)
  assert_eq(16, result)
  
  // æµ‹è¯•3^3 = 3 * 3 * 3
  let base2 = 3
  let result2 = multiply(multiply(base2, base2), base2)
  assert_eq(27, result2)
}

test "greet_function_variations" {
  // æµ‹è¯•greetå‡½æ•°çš„ä¸åŒè¾“å…¥
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, ğŸŒ™!", greet("ğŸŒ™"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, space !", greet("space "))
}

test "complex_arithmetic_expression" {
  // æµ‹è¯•å¤æ‚ç®—æœ¯è¡¨è¾¾å¼ï¼š(a + b) * (c - d) + e
  let a = 10
  let b = 5
  let c = 20
  let d = 8
  let e = 3
  
  let sum_ab = add(a, b)
  let diff_cd = add(c, -d)
  let product = multiply(sum_ab, diff_cd)
  let result = add(product, e)
  
  assert_eq(183, result)  // (10 + 5) * (20 - 8) + 3 = 15 * 12 + 3 = 180 + 3 = 183
}

test "boundary_value_addition" {
  // æµ‹è¯•è¾¹ç•Œå€¼åŠ æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸æœ€å°å€¼ç›¸åŠ 
  assert_eq(-1, add(max_val, min_val))
  
  // æœ€å¤§å€¼ä¸0ç›¸åŠ 
  assert_eq(max_val, add(max_val, 0))
  
  // æœ€å°å€¼ä¸0ç›¸åŠ 
  assert_eq(min_val, add(min_val, 0))
  
  // æœ€å°å€¼ä¸1ç›¸åŠ 
  assert_eq(-2147483647, add(min_val, 1))
}

test "boundary_value_multiplication" {
  // æµ‹è¯•è¾¹ç•Œå€¼ä¹˜æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ä»»ä½•æ•°ä¸0ç›¸ä¹˜
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  
  // ä»»ä½•æ•°ä¸1ç›¸ä¹˜
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(min_val, multiply(min_val, 1))
  
  // æœ€å°å€¼ä¸-1ç›¸ä¹˜ï¼ˆç‰¹æ®Šæƒ…å†µï¼‰
  assert_eq(min_val, multiply(min_val, -1))
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­è¿ç®—
  let initial = 10
  
  // è¿ç»­åŠ æ³•ï¼š(((10 + 5) + 3) + 2)
  let add_result = add(add(add(initial, 5), 3), 2)
  assert_eq(20, add_result)
  
  // è¿ç»­ä¹˜æ³•ï¼š(((2 * 3) * 4) * 5)
  let mul_result = multiply(multiply(multiply(2, 3), 4), 5)
  assert_eq(120, mul_result)
  
  // æ··åˆè¿ç®—ï¼š(10 + 5) * (3 + 2)
  let mixed_result = multiply(add(initial, 5), add(3, 2))
  assert_eq(75, mixed_result)
}

test "real_world_calculation" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1_price = 299
  let item1_quantity = 2
  let item2_price = 199
  let item2_quantity = 1
  let discount = 50
  let tax_rate = 10  // 10%
  
  // è®¡ç®—å•†å“å°è®¡
  let subtotal1 = multiply(item1_price, item1_quantity)
  let subtotal2 = multiply(item2_price, item2_quantity)
  let subtotal = add(subtotal1, subtotal2)
  
  // åº”ç”¨æŠ˜æ‰£
  let discounted_total = add(subtotal, -discount)
  
  // è®¡ç®—ç¨è´¹
  let tax = multiply(discounted_total, tax_rate) / 100
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·
  let final_total = add(discounted_total, tax)
  
  assert_eq(764, final_total)  // (299*2 + 199*1 - 50) * 1.1 = 694 * 1.1 = 763.4 â‰ˆ 763
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åŒ…ä¸­çš„æ ¸å¿ƒå‡½æ•°

test "add_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(3, 7))
  assert_eq(0, add(-5, 5))
  assert_eq(-10, add(-3, -7))
}

test "add_function_edge_cases" {
  // æµ‹è¯•åŠ æ³•çš„è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•ä¸0ç›¸åŠ 
  assert_eq(42, add(42, 0))
  assert_eq(42, add(0, 42))
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
}

test "multiply_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(6, multiply(-2, -3))
  assert_eq(0, multiply(5, 0))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•ä¸1ç›¸ä¹˜
  assert_eq(42, multiply(42, 1))
  assert_eq(42, multiply(1, 42))
  
  // æµ‹è¯•ä¸-1ç›¸ä¹˜
  assert_eq(-42, multiply(42, -1))
  assert_eq(-42, multiply(-1, 42))
  
  // æµ‹è¯•æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µ
  assert_eq(min_val, multiply(min_val, -1))
}

test "greet_function_standard" {
  // æµ‹è¯•æ ‡å‡†çš„é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "greet_function_special_cases" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç‰¹æ®Šæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
}

test "complex_calculation" {
  // æµ‹è¯•å¤æ‚è®¡ç®—ï¼š(a + b) * c - d
  let a = 5
  let b = 3
  let c = 4
  let d = 10
  
  let sum = add(a, b)  // 8
  let product = multiply(sum, c)  // 32
  let result = add(product, -d)  // 22
  
  assert_eq(22, result)
}

test "real_world_scenario" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1_price = 100
  let item1_quantity = 2
  let item2_price = 50
  let item2_quantity = 3
  
  let total1 = multiply(item1_price, item1_quantity)  // 200
  let total2 = multiply(item2_price, item2_quantity)  // 150
  let cart_total = add(total1, total2)  // 350
  
  assert_eq(350, cart_total)
}

// æ ‡å‡† MoonBit æµ‹è¯•å¥—ä»¶æ–°å¢æµ‹è¯•ç”¨ä¾‹
test "standard_add_function_basic" {
  // æµ‹è¯• add å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
  assert_eq(10, add(-3, 13))
}

test "standard_add_function_edge_cases" {
  // æµ‹è¯• add å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "standard_multiply_function_basic" {
  // æµ‹è¯• multiply å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(6, multiply(-2, -3))
}

test "standard_multiply_function_edge_cases" {
  // æµ‹è¯• multiply å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, multiply(max_val, 2))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(0, multiply(max_val, 0))
}

test "standard_greet_function_various_inputs" {
  // æµ‹è¯• greet å‡½æ•°çš„å„ç§è¾“å…¥
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
}

test "standard_complex_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯
  // è®¡ç®— (a + b) * c - d
  let a = 10
  let b = 5
  let c = 3
  let d = 7
  
  let sum = add(a, b)
  let product = multiply(sum, c)
  let result = add(product, -d)
  
  assert_eq(38, result)
}

test "standard_math_laws_verification" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let x = 12
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(x, add(y, 2)), add(multiply(x, y), multiply(x, 2)))
}

test "standard_shopping_cart_application" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1_price = 199
  let item1_quantity = 2
  let item2_price = 299
  let item2_quantity = 1
  
  // è®¡ç®—æ¯ç§å•†å“æ€»ä»·
  let total1 = multiply(item1_price, item1_quantity)
  let total2 = multiply(item2_price, item2_quantity)
  
  // è®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let cart_total = add(total1, total2)
  
  assert_eq(697, cart_total)
}

test "standard_assert_functions_verification" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "geometry_calculations_circle" {
  // å‡ ä½•è®¡ç®—ï¼šåœ†çš„å‘¨é•¿å’Œé¢ç§¯
  let radius = 5
  let pi_approx = 3  // ç®€åŒ–çš„Ï€å€¼
  
  // åœ†å‘¨é•¿ï¼š2 Ã— Ï€ Ã— r
  let circumference = multiply(multiply(2, pi_approx), radius)
  assert_eq(30, circumference)
  
  // åœ†é¢ç§¯ï¼šÏ€ Ã— rÂ²
  let area = multiply(pi_approx, multiply(radius, radius))
  assert_eq(75, area)
}

test "string_length_boundary_tests" {
  // å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œæµ‹è¯•
  let empty = ""
  let single_char = "A"
  let short_word = "Hi"
  let medium_word = "MoonBit"
  let long_phrase = "ThisIsAVeryLongPhraseForTestingPurposes"
  
  assert_eq_string("Hello, !", greet(empty))
  assert_eq_string("Hello, A!", greet(single_char))
  assert_eq_string("Hello, Hi!", greet(short_word))
  assert_eq_string("Hello, MoonBit!", greet(medium_word))
  assert_eq_string("Hello, ThisIsAVeryLongPhraseForTestingPurposes!", greet(long_phrase))
}

test "conditional_calculation_logic" {
  // æ¡ä»¶è®¡ç®—é€»è¾‘æµ‹è¯•
  let score = 85
  let passing_grade = 60
  
  // æ ¹æ®åˆ†æ•°è®¡ç®—ç­‰çº§
  let grade = if score >= 90 { "A" }
              else if score >= 80 { "B" }
              else if score >= 70 { "C" }
              else if score >= 60 { "D" }
              else { "F" }
  
  assert_eq_string("B", grade)
  
  // è®¡ç®—æ˜¯å¦é€šè¿‡
  let passed = score >= passing_grade
  assert_true(passed)
  
  // è®¡ç®—åŠ åˆ†ï¼šå¦‚æœåˆ†æ•° >= 80ï¼ŒåŠ 5åˆ†ï¼Œå¦åˆ™åŠ 10åˆ†
  let bonus = if score >= 80 { 5 } else { 10 }
  let final_score = add(score, bonus)
  assert_eq(90, final_score)
}

test "matrix_index_calculation" {
  // çŸ©é˜µç´¢å¼•è®¡ç®—ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„
  let row = 3
  let col = 4
  let width = 5
  
  // è®¡ç®—ä¸€ç»´æ•°ç»„ç´¢å¼•ï¼šindex = row Ã— width + col
  let index = add(multiply(row, width), col)
  assert_eq(19, index)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let first_index = add(multiply(0, 0), 0)
  assert_eq(0, first_index)
  
  let last_index = add(multiply(9, 4), 4)
  assert_eq(40, last_index)
}

test "currency_exchange_calculation" {
  // è´§å¸å…‘æ¢è®¡ç®—
  let usd_amount = 100
  let exchange_rate = 7  // 1 USD = 7 CNY
  let fee_percentage = 2  // 2% æ‰‹ç»­è´¹
  
  // è®¡ç®—å…‘æ¢é‡‘é¢
  let local_amount = multiply(usd_amount, exchange_rate)
  assert_eq(700, local_amount)
  
  // è®¡ç®—æ‰‹ç»­è´¹
  let fee = multiply(local_amount, fee_percentage) / 100
  assert_eq(14, fee)
  
  // è®¡ç®—æœ€ç»ˆåˆ°è´¦é‡‘é¢
  let final_amount = add(local_amount, -fee)
  assert_eq(686, final_amount)
}

test "time_unit_conversion" {
  // æ—¶é—´å•ä½è½¬æ¢æµ‹è¯•
  let hours = 2
  let minutes = 30
  let seconds = 45
  
  // è½¬æ¢ä¸ºæ€»ç§’æ•°
  let total_seconds = add(add(multiply(hours, 3600), multiply(minutes, 60)), seconds)
  assert_eq(9045, total_seconds)
  
  // è®¡ç®—æ—¶é—´å·®ï¼ˆç§’ï¼‰
  let start_hour = 8
  let start_min = 0
  let end_hour = 17
  let end_min = 30
  
  let start_seconds = multiply(start_hour, 3600)
  let end_seconds = add(multiply(end_hour, 3600), multiply(end_min, 60))
  let duration = add(end_seconds, -start_seconds)
  
  assert_eq(34200, duration)
}

test "statistical_calculations" {
  // ç»Ÿè®¡è®¡ç®—æµ‹è¯•
  // æ•°æ®é›†ï¼š10, 20, 30, 40, 50, 60, 70, 80, 90, 100
  let sum = add(add(add(add(add(10, 20), add(30, 40)), add(50, 60)), add(70, 80)), add(90, 100))
  assert_eq(550, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let count = 10
  let average = sum / count
  assert_eq(55, average)
  
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆå¶æ•°ä¸ªæ•°æ®ï¼Œå–ä¸­é—´ä¸¤ä¸ªçš„å¹³å‡å€¼ï¼‰
  let median = add(50, 60) / 2
  assert_eq(55, median)
  
  // è®¡ç®—èŒƒå›´ï¼ˆæœ€å¤§å€¼ - æœ€å°å€¼ï¼‰
  let range = add(100, -10)
  assert_eq(90, range)
}

test "game_scoring_system" {
  // æ¸¸æˆè®¡åˆ†ç³»ç»Ÿæµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let combo_bonus = 500
  let time_penalty = 200
  let difficulty_bonus = 300
  
  // è®¡ç®—åŸºç¡€å¾—åˆ†
  let level_score = multiply(base_score, level_multiplier)
  assert_eq(3000, level_score)
  
  // è®¡ç®—è¿å‡»å¥–åŠ±
  let combo_score = add(level_score, combo_bonus)
  assert_eq(3500, combo_score)
  
  // æ‰£é™¤æ—¶é—´æƒ©ç½š
  let time_score = add(combo_score, -time_penalty)
  assert_eq(3300, time_score)
  
  // æ·»åŠ éš¾åº¦å¥–åŠ±
  let final_score = add(time_score, difficulty_bonus)
  assert_eq(3600, final_score)
  
  // è®¡ç®—æ’ååŠ åˆ†ï¼ˆå‰10%åŠ 20%ï¼‰
  let rank_bonus = multiply(final_score, 20) / 100
  let total_score = add(final_score, rank_bonus)
  assert_eq(4320, total_score)
}

test "energy_consumption_calculation" {
  // èƒ½è€—è®¡ç®—æµ‹è¯•
  let power_rating = 150  // ç“¦ç‰¹
  let daily_hours = 8
  let days_in_month = 30
  let price_per_kwh = 12  // æ¯åƒç“¦æ—¶ä»·æ ¼
  
  // è®¡ç®—æ¯æ—¥èƒ½è€—ï¼ˆç“¦æ—¶ï¼‰
  let daily_consumption = multiply(power_rating, daily_hours)
  assert_eq(1200, daily_consumption)
  
  // è®¡ç®—æœˆåº¦èƒ½è€—ï¼ˆç“¦æ—¶ï¼‰
  let monthly_consumption = multiply(daily_consumption, days_in_month)
  assert_eq(36000, monthly_consumption)
  
  // è½¬æ¢ä¸ºåƒç“¦æ—¶
  let kwh_consumption = monthly_consumption / 1000
  assert_eq(36, kwh_consumption)
  
  // è®¡ç®—æœˆåº¦ç”µè´¹
  let monthly_cost = multiply(kwh_consumption, price_per_kwh)
  assert_eq(432, monthly_cost)
}

test "data_conversion_simulation" {
  // æ•°æ®ç±»å‹è½¬æ¢æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ•´æ•°è½¬å­—ç¬¦ä¸²
  let number = 2023
  let number_str = "2023"
  let greeting_number = greet(number_str)
  assert_eq_string("Hello, 2023!", greeting_number)
  
  // æ¨¡æ‹Ÿå¸ƒå°”å€¼è½¬å­—ç¬¦ä¸²
  let bool_true_str = "true"
  let bool_false_str = "false"
  assert_eq_string("Hello, true!", greet(bool_true_str))
  assert_eq_string("Hello, false!", greet(bool_false_str))
  
  // æ¨¡æ‹Ÿæµ®ç‚¹æ•°è¡¨ç¤ºï¼ˆä½¿ç”¨æ•´æ•°éƒ¨åˆ†å’Œå°æ•°éƒ¨åˆ†ï¼‰
  let integer_part = 3
  let decimal_part = 1415
  let pi_str = "3.1415"
  assert_eq_string("Hello, 3.1415!", greet(pi_str))
  
  // æ¨¡æ‹Ÿç‰¹æ®Šæ•°æ®æ ¼å¼
  let date_str = "2023-12-25"
  let time_str = "14:30:00"
  let coordinate_str = "39.9042Â°N, 116.4074Â°E"
  
  assert_eq_string("Hello, 2023-12-25!", greet(date_str))
  assert_eq_string("Hello, 14:30:00!", greet(time_str))
  assert_eq_string("Hello, 39.9042Â°N, 116.4074Â°E!", greet(coordinate_str))
}

// æ–°å¢çš„ç®€æ´ Azimuth æµ‹è¯•ç”¨ä¾‹
// è¦†ç›–æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "concise_add_function_basic" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(3, 7))
  assert_eq(0, add(-5, 5))
  assert_eq(-8, add(-3, -5))
}

test "concise_add_function_overflow" {
  // æµ‹è¯•åŠ æ³•æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "concise_multiply_function_basic" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(0, multiply(0, 100))
}

test "concise_multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(min_val, multiply(min_val, 1))
}

test "concise_greet_function_variations" {
  // æµ‹è¯• greet å‡½æ•°çš„å„ç§è¾“å…¥
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, å¼ ä¸‰!", greet("å¼ ä¸‰"))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "concise_divide_with_ceil_function" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•åŠŸèƒ½
  assert_eq(3, divide_with_ceil(10, 3))
  assert_eq(4, divide_with_ceil(12, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-3, divide_with_ceil(-9, 3))
}

test "concise_complex_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯
  // è®¡ç®—çŸ©å½¢é¢ç§¯å’Œå‘¨é•¿
  let length = 8
  let width = 5
  
  let area = multiply(length, width)
  let perimeter = add(multiply(2, length), multiply(2, width))
  
  assert_eq(40, area)
  assert_eq(26, perimeter)
}

test "concise_financial_calculation_scenario" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯
  // ç®€å•çš„æŠ˜æ‰£è®¡ç®—
  let original_price = 1000
  let discount_rate = 20  // 20% æŠ˜æ‰£
  let tax_rate = 8        // 8% ç¨è´¹
  
  // è®¡ç®—æŠ˜æ‰£ä»·
  let discount_amount = multiply(original_price, discount_rate) / 100
  let discounted_price = add(original_price, -discount_amount)
  
  // è®¡ç®—æœ€ç»ˆä»·æ ¼ï¼ˆå«ç¨ï¼‰
  let tax_amount = multiply(discounted_price, tax_rate) / 100
  let final_price = add(discounted_price, tax_amount)
  
  assert_eq(800, discounted_price)
  assert_eq(864, final_price)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹



// ç®€æ´çš„æ ¸å¿ƒæµ‹è¯•ç”¨ä¾‹ - è¦†ç›–é¡¹ç›®çš„ä¸»è¦åŠŸèƒ½

test "essential_basic_arithmetic" {

  // åŸºç¡€ç®—æœ¯è¿ç®—æµ‹è¯•

  assert_eq(10, add(3, 7))

  assert_eq(15, multiply(3, 5))

  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))

}



test "essential_zero_operations" {

  // é›¶å€¼è¿ç®—æµ‹è¯•

  assert_eq(5, add(5, 0))

  assert_eq(5, add(0, 5))

  assert_eq(0, multiply(5, 0))

  assert_eq(0, multiply(0, 5))

  assert_eq_string("Hello, !", greet(""))

}



test "essential_negative_numbers" {

  // è´Ÿæ•°è¿ç®—æµ‹è¯•

  assert_eq(-2, add(3, -5))

  assert_eq(-15, multiply(3, -5))

  assert_eq(15, multiply(-3, -5))

  assert_eq_string("Hello, -123!", greet("-123"))

}



test "essential_boundary_values" {

  // è¾¹ç•Œå€¼æµ‹è¯•

  let max_val = 2147483647

  let min_val = -2147483648

  

  assert_eq(max_val, add(max_val, 1))

  assert_eq(min_val, add(min_val, -1))

  assert_eq(min_val, multiply(min_val, -1))

  assert_eq(-1, add(max_val, min_val))

}



test "essential_identity_elements" {

  // å•ä½å…ƒæµ‹è¯•

  assert_eq(5, add(5, 0))

  assert_eq(5, multiply(5, 1))

  assert_eq(-5, multiply(-5, 1))

  assert_eq_string("Hello, World!", greet("World"))

}



test "essential_large_numbers" {

  // å¤§æ•°è¿ç®—æµ‹è¯•

  assert_eq(2000000000, add(1000000000, 1000000000))

  assert_eq(100000000, multiply(10000, 10000))

  assert_eq_string("Hello, VeryLongNameForTesting!", greet("VeryLongNameForTesting"))

}



test "essential_complex_expressions" {

  // å¤åˆè¡¨è¾¾å¼æµ‹è¯•

  let a = 10

  let b = 20

  let c = 30

  

  // (a + b) * c

  let result = multiply(add(a, b), c)

  assert_eq(900, result)

  

  // a * b + c

  let result2 = add(multiply(a, b), c)

  assert_eq(230, result2)

}



test "essential_string_processing" {

  // å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•

  assert_eq_string("Hello, Alice!", greet("Alice"))

  assert_eq_string("Hello, 123!", greet("123"))

  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))

  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))

}



test "essential_practical_calculations" {

  // å®é™…è®¡ç®—åœºæ™¯æµ‹è¯•

  // è®¡ç®—çŸ©å½¢é¢ç§¯

  let length = 5

  let width = 8

  let area = multiply(length, width)

  assert_eq(40, area)

  

  // è®¡ç®—å‘¨é•¿

  let perimeter = add(multiply(2, length), multiply(2, width))

  assert_eq(26, perimeter)

}



test "essential_error_conditions" {

  // é”™è¯¯æ¡ä»¶æµ‹è¯•

  let max_val = 2147483647

  let min_val = -2147483648

  

  // æµ‹è¯•æº¢å‡ºä¿æŠ¤

  assert_true(add(max_val, 100) == max_val)

  assert_true(add(min_val, -100) == min_val)

  assert_true(multiply(max_val, 2) == max_val)

  assert_true(multiply(min_val, 2) == min_val)

  

  // æµ‹è¯•æ–­è¨€å‡½æ•°

  assert_true(true)

  assert_false(false)

  assert_eq(42, 42)

}



test "divide_with_ceil_comprehensive" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å…¨é¢åŠŸèƒ½
  assert_eq(3, divide_with_ceil(10, 4))  // 10/4 = 2.5 -> 3
  assert_eq(5, divide_with_ceil(20, 4))  // 20/4 = 5 -> 5
  assert_eq(7, divide_with_ceil(25, 4))  // 25/4 = 6.25 -> 7
  assert_eq(0, divide_with_ceil(0, 5))   // 0/5 = 0 -> 0
  assert_eq(1, divide_with_ceil(1, 1))   // 1/1 = 1 -> 1
  assert_eq(-1, divide_with_ceil(-3, 2)) // -3/2 = -1.5 -> -1
}

test "mathematical_sequence_fibonacci" {
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  let fib6 = add(fib4, fib5)  // 8
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
}

test "financial_calculation_enhanced" {
  // æµ‹è¯•å¢å¼ºçš„é‡‘èè®¡ç®—
  let principal = 10000
  let rate = 5  // 5%
  let years = 3
  
  // å¤åˆ©è®¡ç®—ï¼šP(1 + r)^t
  let growth_factor = add(100, multiply(rate, years))
  let total_amount = multiply(principal, growth_factor)
  
  assert_eq(115000, total_amount)  // 10000 * (100 + 5*3) = 10000 * 115 = 115000
}

test "coordinate_geometry_distance" {
  // æµ‹è¯•åæ ‡å‡ ä½•è®¡ç®—
  let x1 = 1
  let y1 = 2
  let x2 = 4
  let y2 = 6
  
  let dx = add(x2, -x1)  // 3
  let dy = add(y2, -y1)  // 4
  let distance_squared = add(multiply(dx, dx), multiply(dy, dy))
  
  assert_eq(25, distance_squared)  // 3Â² + 4Â² = 9 + 16 = 25
}

test "temperature_conversion_complete" {
  // æµ‹è¯•å®Œæ•´çš„æ¸©åº¦è½¬æ¢
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 2 + 30
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 2), 30)
  
  assert_eq(80, fahrenheit)  // 25 Ã— 2 + 30 = 80
  
  // åæ°åº¦è½¬æ‘„æ°åº¦ï¼šC = (F - 30) / 2
  let celsius_back = add(fahrenheit, -30) / 2
  assert_eq(25, celsius_back)
}

test "string_validation_comprehensive" {
  // æµ‹è¯•å…¨é¢çš„å­—ç¬¦ä¸²éªŒè¯
  let email = "user@example.com"
  let phone = "123-456-7890"
  let complex = "user_2023@project#1"
  
  assert_eq_string("Hello, user@example.com!", greet(email))
  assert_eq_string("Hello, 123-456-7890!", greet(phone))
  assert_eq_string("Hello, user_2023@project#1!", greet(complex))
}

test "algorithm_efficiency_formulas" {
  // æµ‹è¯•ç®—æ³•æ•ˆç‡å…¬å¼
  // è®¡ç®—å‰nä¸ªè‡ªç„¶æ•°çš„å’Œï¼šn(n+1)/2
  let n = 100
  let sum_formula = multiply(n, add(n, 1)) / 2
  assert_eq(5050, sum_formula)
  
  // éªŒè¯å‰10é¡¹
  let n10 = 10
  let sum_10 = multiply(n10, add(n10, 1)) / 2
  assert_eq(55, sum_10)
}

test "business_inventory_management" {
  // æµ‹è¯•å•†ä¸šåº“å­˜ç®¡ç†
  let initial_stock = 1000
  let units_sold = 250
  let units_received = 150
  let units_damaged = 25
  
  let current_stock = add(add(initial_stock, -units_sold), add(units_received, -units_damaged))
  assert_eq(875, current_stock)
  
  let unit_cost = 10
  let inventory_value = multiply(current_stock, unit_cost)
  assert_eq(8750, inventory_value)
}

test "scientific_notation_simplified" {
  // æµ‹è¯•ç®€åŒ–çš„ç§‘å­¦è®¡æ•°æ³•
  // æ¨¡æ‹Ÿ 3.14 Ã— 10^6 = 3140000
  let mantissa = 314
  let exponent = 4
  let scientific_result = multiply(mantissa, multiply(multiply(10, 10), multiply(multiply(10, 10), 10)))
  assert_eq(3140000, scientific_result)
  
  // æ¨¡æ‹Ÿ 1.618 Ã— 10^3 = 1618ï¼ˆé»„é‡‘æ¯”ä¾‹è¿‘ä¼¼ï¼‰
  let golden_ratio = 1618
  assert_eq(1618, golden_ratio)
}

test "data_structure_operations" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ“ä½œ
  // è®¡ç®—äºŒç»´æ•°ç»„åœ¨ä¸€ç»´æ•°ç»„ä¸­çš„ç´¢å¼•ï¼šindex = row * width + col
  let row = 3
  let col = 4
  let width = 5
  
  let index = add(multiply(row, width), col)
  assert_eq(19, index)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let first_row = 0
  let first_col = 0
  let first_index = add(multiply(first_row, width), first_col)
  assert_eq(0, first_index)
}

// æ–°å¢çš„10ä¸ª MoonBit æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
test "memory_allocation_simulation" {
  // æ¨¡æ‹Ÿå†…å­˜åˆ†é…è®¡ç®—
  let block_size = 1024  // æ¯ä¸ªå—1KB
  let num_blocks = 256   // åˆ†é…256ä¸ªå—
  let overhead = 64      // æ¯ä¸ªå—çš„å¼€é”€64å­—èŠ‚
  
  // è®¡ç®—æ€»å†…å­˜ä½¿ç”¨ï¼š(block_size + overhead) * num_blocks
  let total_with_overhead = add(block_size, overhead)
  let total_memory = multiply(total_with_overhead, num_blocks)
  
  assert_eq(281600, total_memory)
  
  // è®¡ç®—å®é™…å¯ç”¨å†…å­˜ï¼šblock_size * num_blocks
  let usable_memory = multiply(block_size, num_blocks)
  assert_eq(262144, usable_memory)
  
  // è®¡ç®—å†…å­˜æ•ˆç‡ï¼šusable_memory / total_memory * 100
  let efficiency_percent = multiply(usable_memory, 100) / total_memory
  assert_eq(93, efficiency_percent)  // æ•´æ•°é™¤æ³•
}

test "network_protocol_calculation" {
  // ç½‘ç»œåè®®è®¡ç®—æµ‹è¯•
  let header_size = 20     // IPå¤´éƒ¨20å­—èŠ‚
  let data_size = 1460     // æ•°æ®1460å­—èŠ‚
  let packet_overhead = 8  // é¢å¤–å¼€é”€8å­—èŠ‚
  
  // è®¡ç®—æ€»åŒ…å¤§å°
  let total_packet_size = add(add(header_size, data_size), packet_overhead)
  assert_eq(1488, total_packet_size)
  
  // è®¡ç®—ä¼ è¾“æ•ˆç‡ï¼šdata_size / total_packet_size * 100
  let transmission_efficiency = multiply(data_size, 100) / total_packet_size
  assert_eq(98, transmission_efficiency)
  
  // è®¡ç®—1000ä¸ªåŒ…çš„æ€»æ•°æ®é‡
  let num_packets = 1000
  let total_data_transferred = multiply(total_packet_size, num_packets)
  assert_eq(1488000, total_data_transferred)
}

test "cryptography_simulation" {
  // å¯†ç å­¦è®¡ç®—æ¨¡æ‹Ÿ
  let key_length = 256     // å¯†é’¥é•¿åº¦256ä½
  let block_size = 128     // å—å¤§å°128ä½
  let rounds = 10          // åŠ å¯†è½®æ•°
  
  // è®¡ç®—æ¯ä¸ªå—çš„å¤„ç†æ—¶é—´ï¼ˆæ¨¡æ‹Ÿï¼‰
  let base_time = 100      // åŸºç¡€æ—¶é—´100å¾®ç§’
  let round_multiplier = rounds
  let processing_time = multiply(base_time, round_multiplier)
  assert_eq(1000, processing_time)
  
  // è®¡ç®—1MBæ•°æ®çš„å—æ•°
  let data_size_mb = 1
  let data_size_bytes = multiply(data_size_mb, 1024 * 1024)
  let num_blocks = data_size_bytes / (block_size / 8)  // è½¬æ¢ä¸ºå­—èŠ‚
  assert_eq(65536, num_blocks)
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_time = multiply(processing_time, num_blocks)
  assert_eq(65536000, total_time)
}

test "database_index_calculation" {
  // æ•°æ®åº“ç´¢å¼•è®¡ç®—æµ‹è¯•
  let page_size = 8192     // é¡µé¢å¤§å°8KB
  let record_size = 128    // è®°å½•å¤§å°128å­—èŠ‚
  let index_entry_size = 16 // ç´¢å¼•æ¡ç›®å¤§å°16å­—èŠ‚
  
  // è®¡ç®—æ¯é¡µçš„è®°å½•æ•°
  let records_per_page = page_size / record_size
  assert_eq(64, records_per_page)
  
  // è®¡ç®—æ¯é¡µçš„ç´¢å¼•æ¡ç›®æ•°
  let index_entries_per_page = page_size / index_entry_size
  assert_eq(512, index_entries_per_page)
  
  // è®¡ç®—100ä¸‡æ¡è®°å½•éœ€è¦çš„é¡µæ•°
  let total_records = 1000000
  let total_pages = total_records / records_per_page
  assert_eq(15625, total_pages)
  
  // è®¡ç®—ç´¢å¼•é¡µæ•°
  let index_pages = total_records / index_entries_per_page
  assert_eq(1953, index_pages)
}

test "compression_algorithm_test" {
  // å‹ç¼©ç®—æ³•æµ‹è¯•
  let original_size = 1048576  // 1MBåŸå§‹æ•°æ®
  let compression_ratio = 70   // å‹ç¼©åˆ°70%
  
  // è®¡ç®—å‹ç¼©åå¤§å°
  let compressed_size = multiply(original_size, compression_ratio) / 100
  assert_eq(734003, compressed_size)
  
  // è®¡ç®—èŠ‚çœçš„ç©ºé—´
  let space_saved = add(original_size, -compressed_size)
  assert_eq(314573, space_saved)
  
  // è®¡ç®—å‹ç¼©æ—¶é—´ï¼ˆæ¨¡æ‹Ÿï¼‰
  let compression_speed = 50000  // æ¯ç§’å‹ç¼©50KB
  let compression_time = original_size / compression_speed
  assert_eq(20, compression_time)
  
  // è®¡ç®—è§£å‹æ—¶é—´ï¼ˆé€šå¸¸æ›´å¿«ï¼‰
  let decompression_speed = 100000  // æ¯ç§’è§£å‹100KB
  let decompression_time = compressed_size / decompression_speed
  assert_eq(7, decompression_time)
}

test "graphics_rendering_calculation" {
  // å›¾å½¢æ¸²æŸ“è®¡ç®—æµ‹è¯•
  let screen_width = 1920
  let screen_height = 1080
  let color_depth = 32  // 32ä½é¢œè‰²æ·±åº¦
  let frame_rate = 60   // 60FPS
  
  // è®¡ç®—æ¯å¸§çš„åƒç´ æ•°
  let pixels_per_frame = multiply(screen_width, screen_height)
  assert_eq(2073600, pixels_per_frame)
  
  // è®¡ç®—æ¯å¸§çš„å­—èŠ‚æ•°
  let bytes_per_pixel = color_depth / 8
  let bytes_per_frame = multiply(pixels_per_frame, bytes_per_pixel)
  assert_eq(8294400, bytes_per_frame)
  
  // è®¡ç®—æ¯ç§’çš„æ•°æ®ä¼ è¾“é‡
  let bytes_per_second = multiply(bytes_per_frame, frame_rate)
  assert_eq(497664000, bytes_per_second)
  
  // è½¬æ¢ä¸ºMB/s
  let mb_per_second = bytes_per_second / (1024 * 1024)
  assert_eq(474, mb_per_second)
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000    // æœ¬é‡‘10000å…ƒ
  let annual_rate = 8      // å¹´åˆ©ç‡8%
  let years = 5            // 5å¹´
  
  // ç®€åŒ–çš„é€å¹´è®¡ç®—
  let year1_amount = multiply(principal, add(100, annual_rate)) / 100
  let year2_amount = multiply(year1_amount, add(100, annual_rate)) / 100
  let year3_amount = multiply(year2_amount, add(100, annual_rate)) / 100
  let year4_amount = multiply(year3_amount, add(100, annual_rate)) / 100
  let year5_amount = multiply(year4_amount, add(100, annual_rate)) / 100
  
  assert_eq(10800, year1_amount)
  assert_eq(11664, year2_amount)
  assert_eq(12597, year3_amount)
  assert_eq(13605, year4_amount)
  assert_eq(14693, year5_amount)
}

test "machine_learning_metrics" {
  // æœºå™¨å­¦ä¹ æŒ‡æ ‡è®¡ç®—æµ‹è¯•
  let total_samples = 1000
  let true_positives = 450
  let false_positives = 100
  let false_negatives = 50
  
  // è®¡ç®—å‡†ç¡®ç‡ï¼š(TP + TN) / æ€»æ ·æœ¬æ•°
  let true_negatives = add(total_samples, add(-true_positives, add(-false_positives, -false_negatives)))
  let accuracy = multiply(add(true_positives, true_negatives), 100) / total_samples
  assert_eq(90, accuracy)
  
  // è®¡ç®—ç²¾ç¡®ç‡ï¼šTP / (TP + FP)
  let precision = multiply(true_positives, 100) / add(true_positives, false_positives)
  assert_eq(81, precision)
  
  // è®¡ç®—å¬å›ç‡ï¼šTP / (TP + FN)
  let recall = multiply(true_positives, 100) / add(true_positives, false_negatives)
  assert_eq(90, recall)
  
  // è®¡ç®—F1åˆ†æ•°ï¼š2 Ã— (ç²¾ç¡®ç‡ Ã— å¬å›ç‡) / (ç²¾ç¡®ç‡ + å¬å›ç‡)
  let f1_score = multiply(2, multiply(precision, recall)) / add(precision, recall)
  assert_eq(85, f1_score)
}

test "cache_performance_analysis" {
  // ç¼“å­˜æ€§èƒ½åˆ†ææµ‹è¯•
  let cache_size = 32768    // ç¼“å­˜å¤§å°32KB
  let line_size = 64        // ç¼“å­˜è¡Œå¤§å°64å­—èŠ‚
  let associativity = 8     // 8è·¯ç»„ç›¸è”
  
  // è®¡ç®—ç¼“å­˜è¡Œæ•°
  let num_lines = cache_size / line_size
  assert_eq(512, num_lines)
  
  // è®¡ç®—ç»„æ•°
  let num_sets = num_lines / associativity
  assert_eq(64, num_sets)
  
  // æ¨¡æ‹Ÿç¼“å­˜å‘½ä¸­ç‡è®¡ç®—
  let total_accesses = 10000
  let cache_hits = 8500
  let hit_rate = multiply(cache_hits, 100) / total_accesses
  assert_eq(85, hit_rate)
  
  // è®¡ç®—å¹³å‡è®¿é—®æ—¶é—´
  let cache_access_time = 1      // ç¼“å­˜è®¿é—®æ—¶é—´1ns
  let memory_access_time = 100   // å†…å­˜è®¿é—®æ—¶é—´100ns
  let avg_access_time = add(
    multiply(cache_access_time, hit_rate),
    multiply(memory_access_time, add(100, -hit_rate))
  ) / 100
  assert_eq(15, avg_access_time)
}

test "distributed_system_consistency" {
  // åˆ†å¸ƒå¼ç³»ç»Ÿä¸€è‡´æ€§æµ‹è¯•
  let num_nodes = 5
  let replication_factor = 3
  let write_operations = 100
  let read_operations = 500
  
  // è®¡ç®—éœ€è¦ç¡®è®¤çš„å†™æ“ä½œæ•°
  let write_quorum = add(replication_factor, 1) / 2
  assert_eq(2, write_quorum)
  
  // è®¡ç®—éœ€è¦ç¡®è®¤çš„è¯»æ“ä½œæ•°
  let read_quorum = add(num_nodes, -write_quorum) + 1
  assert_eq(4, read_quorum)
  
  // è®¡ç®—ä¸€è‡´æ€§æ¦‚ç‡ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
  let node_availability = 95  // æ¯ä¸ªèŠ‚ç‚¹95%å¯ç”¨
  let consistency_probability = multiply(node_availability, replication_factor) / 100
  assert_eq(85, consistency_probability)
  
  // è®¡ç®—æ€»å»¶è¿Ÿï¼ˆå†™+è¯»ï¼‰
  let write_latency = 50   // å†™å»¶è¿Ÿ50ms
  let read_latency = 10    // è¯»å»¶è¿Ÿ10ms
  let total_latency = add(
    multiply(write_operations, write_latency),
    multiply(read_operations, read_latency)
  )
  assert_eq(10000, total_latency)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

// æ ‡å‡† Azimuth æœ€ç»ˆæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•åŸºæœ¬åŠ æ³•è¿ç®—
test "standard_final_add_basic" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-3, add(-1, -2))
}

// æµ‹è¯•åŠ æ³•æº¢å‡ºå¤„ç†
test "standard_final_add_overflow" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

// æµ‹è¯•åŸºæœ¬ä¹˜æ³•è¿ç®—
test "standard_final_multiply_basic" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(6, multiply(-2, -3))
}

// æµ‹è¯•ä¹˜æ³•æº¢å‡ºå¤„ç†
test "standard_final_multiply_overflow" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, multiply(max_val, 2))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(0, multiply(max_val, 0))
}

// æµ‹è¯•å­—ç¬¦ä¸²æ‹¼æ¥åŠŸèƒ½
test "standard_final_greet_basic" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

// æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯
test "standard_final_complex_calculation" {
  // è®¡ç®—çŸ©å½¢é¢ç§¯å’Œå‘¨é•¿
  let length = 8
  let width = 5
  
  let area = multiply(length, width)
  let perimeter = add(multiply(2, length), multiply(2, width))
  
  assert_eq(40, area)
  assert_eq(26, perimeter)
}

// æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
test "standard_final_real_world_scenario" {
  // è´­ç‰©è½¦è®¡ç®—
  let item1_price = 199
  let item1_quantity = 2
  let item2_price = 99
  let item2_quantity = 3
  
  let total1 = multiply(item1_price, item1_quantity)
  let total2 = multiply(item2_price, item2_quantity)
  let cart_total = add(total1, total2)
  
  assert_eq(695, cart_total)
}

// æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆ
test "standard_final_boundary_values" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¾¹ç•Œå€¼ä¸æ™®é€šå€¼çš„è¿ç®—
  assert_eq(2147483647, add(max_val, 1))
  assert_eq(-2147483648, add(min_val, -1))
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
}

// æµ‹è¯•æ•°å­¦æ€§è´¨
test "standard_final_mathematical_properties" {
  let a = 7
  let b = 11
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, 3)), add(multiply(a, b), multiply(a, 3)))
}

// æµ‹è¯•æ–­è¨€å‡½æ•°
test "standard_final_assertion_functions" {
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "simple_math_test" {
  // ç®€å•çš„æ•°å­¦è¿ç®—æµ‹è¯•
  assert_eq(5, add(2, 3))
  assert_eq(6, multiply(2, 3))
}

test "boundary_test" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
}

test "string_test" {
  // å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "complex_calculation" {
  // å¤æ‚è®¡ç®—æµ‹è¯•ï¼šçŸ©å½¢é¢ç§¯
  let length = 10
  let width = 5
  let area = multiply(length, width)
  assert_eq(50, area)
}

test "financial_calculation" {
  // é‡‘èè®¡ç®—æµ‹è¯•ï¼šç®€å•åˆ©æ¯
  let principal = 1000
  let rate = 5
  let years = 3
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  assert_eq(16000, total)
}

test "temperature_conversion" {
  // æ¸©åº¦è½¬æ¢æµ‹è¯•ï¼šæ‘„æ°åº¦è½¬åæ°åº¦ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let celsius = 20
  let fahrenheit = add(multiply(celsius, 2), 30)
  assert_eq(70, fahrenheit)
}

test "game_logic" {
  // æ¸¸æˆé€»è¾‘æµ‹è¯•ï¼šå¾—åˆ†è®¡ç®—
  let base_score = 100
  let multiplier = 2
  let bonus = 50
  let final_score = add(multiply(base_score, multiplier), bonus)
  assert_eq(250, final_score)
}

test "physics_calculation" {
  // ç‰©ç†è®¡ç®—æµ‹è¯•ï¼šé€Ÿåº¦è®¡ç®—
  let initial_velocity = 10
  let acceleration = 3
  let time = 5
  let final_velocity = add(initial_velocity, multiply(acceleration, time))
  assert_eq(25, final_velocity)
}

test "boolean_logic" {
  // å¸ƒå°”é€»è¾‘æµ‹è¯•
  assert_true(true)
  assert_false(false)
  assert_eq(1, add(0, 1))
}

test "error_handling" {
  // é”™è¯¯å¤„ç†æµ‹è¯•ï¼šæº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  assert_true(add(max_val, 1) == max_val)
  assert_true(multiply(max_val, 2) == max_val)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "divide_with_ceil_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„å‘ä¸Šå–æ•´é™¤æ³•åŠŸèƒ½
  assert_eq(3, divide_with_ceil(10, 3))
  assert_eq(4, divide_with_ceil(11, 3))
  assert_eq(2, divide_with_ceil(6, 3))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "divide_with_ceil_negative_numbers" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-2, divide_with_ceil(-5, 3))
  assert_eq(3, divide_with_ceil(10, -3))
  assert_eq(2, divide_with_ceil(5, -3))
}

test "divide_with_ceil_edge_cases" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(100, divide_with_ceil(99, 1))
}

test "complex_mathematical_expression" {
  // æµ‹è¯•å¤æ‚æ•°å­¦è¡¨è¾¾å¼ï¼š(a * b + c * d) / e å‘ä¸Šå–æ•´
  let a = 7
  let b = 8
  let c = 5
  let d = 6
  let e = 4
  
  let product1 = multiply(a, b)  // 56
  let product2 = multiply(c, d)  // 30
  let sum = add(product1, product2)  // 86
  let result = divide_with_ceil(sum, e)  // 22
  
  assert_eq(22, result)
}

test "financial_calculation_with_ceil" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„é’ç¥¨æ•°é‡
  let total_amount = 1234
  let bill_denomination = 100
  
  let bills_needed = divide_with_ceil(total_amount, bill_denomination)
  assert_eq(13, bills_needed)  // éœ€è¦13å¼ 100å…ƒé’ç¥¨
}

test "string_processing_with_numbers" {
  // æµ‹è¯•å­—ç¬¦ä¸²ä¸æ•°å­—çš„ç»„åˆå¤„ç†
  let year_str = "2024"
  let month_str = "1"
  let day_str = "21"
  
  let date_string = greet("Date: " + year_str + "-" + month_str + "-" + day_str)
  assert_eq_string("Hello, Date: 2024-1-21!", date_string)
}

test "boundary_value_comprehensive_test" {
  // ç»¼åˆè¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  
  // æµ‹è¯•æå€¼åŠ æ³•ä¸é™¤æ³•çš„ç»„åˆ
  let sum1 = add(max_val, -1)  // 2147483646
  let result1 = divide_with_ceil(sum1, 1000000)  // 2148
  assert_eq(2148, result1)
  
  // æµ‹è¯•æå€¼ä¹˜æ³•ä¸é™¤æ³•çš„ç»„åˆ
  let product1 = multiply(10000, 100000)  // 1000000000
  let result2 = divide_with_ceil(product1, 123456789)  // 9
  assert_eq(9, result2)
}

test "geometry_calculation_with_ceil" {
  // æµ‹è¯•å‡ ä½•è®¡ç®—ä¸­çš„å‘ä¸Šå–æ•´åº”ç”¨
  // è®¡ç®—é“ºè®¾åœ°æ¿éœ€è¦çš„åœ°ç –æ•°é‡ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let room_length = 350  // cm
  let room_width = 280   // cm
  let tile_size = 30     // cm
  
  let tiles_length = divide_with_ceil(room_length, tile_size)  // 12
  let tiles_width = divide_with_ceil(room_width, tile_size)    // 10
  let total_tiles = multiply(tiles_length, tiles_width)       // 120
  
  assert_eq(120, total_tiles)
}

test "algorithm_complexity_simulation" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿï¼šO(n log n) è¿‘ä¼¼è®¡ç®—
  let n = 1000
  let log2_approx = 10  // 2^10 = 1024 â‰ˆ 1000
  
  let operations = multiply(n, log2_approx)
  assert_eq(10000, operations)
  
  // æµ‹è¯•å‘ä¸Šå–æ•´åœ¨å¤æ‚åº¦è®¡ç®—ä¸­çš„åº”ç”¨
  let chunks = divide_with_ceil(operations, 1000)  // åˆ†æˆ1000ä¸ªæ“ä½œçš„å—
  assert_eq(10, chunks)
}

test "error_recovery_scenarios" {
  // æµ‹è¯•é”™è¯¯æ¢å¤åœºæ™¯
  let normal_value = 42
  let error_value = -1
  
  // æ¨¡æ‹Ÿé”™è¯¯å¤„ç†ï¼šå¦‚æœå‡ºç°é”™è¯¯å€¼ï¼Œä½¿ç”¨é»˜è®¤å€¼
  let input = error_value
  let safe_value = if input < 0 { normal_value } else { input }
  let result = add(safe_value, 10)
  
  assert_eq(52, result)
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°åœ¨é”™è¯¯æ¢å¤ä¸­çš„åº”ç”¨
  assert_true(safe_value >= 0)
  assert_false(input >= 0)
}

// æ–°å¢çš„10ä¸ªç»¼åˆæµ‹è¯•ç”¨ä¾‹
test "azimuth_divide_with_ceil_comprehensive" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å„ç§æƒ…å†µ
  assert_eq(3, divide_with_ceil(10, 4))
  assert_eq(2, divide_with_ceil(8, 4))
  assert_eq(1, divide_with_ceil(3, 4))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(-2, divide_with_ceil(-7, 4))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(1, divide_with_ceil(2147483647, 2147483647))
}

test "azimuth_complex_nested_calculations" {
  // æµ‹è¯•å¤æ‚çš„åµŒå¥—è®¡ç®—
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)
  
  let result2 = multiply(add(10, 20), add(5, 15))
  assert_eq(600, result2)
  
  let result3 = add(multiply(divide_with_ceil(17, 5), 3), multiply(divide_with_ceil(-13, 5), 2))
  assert_eq(5, result3)
}

test "azimuth_international_string_handling" {
  // æµ‹è¯•å›½é™…åŒ–å­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, å¼ ä¸‰!", greet("å¼ ä¸‰"))
  assert_eq_string("Hello, ç”°ä¸­å¤ªéƒ!", greet("ç”°ä¸­å¤ªéƒ"))
  assert_eq_string("Hello, ê¹€ì² ìˆ˜!", greet("ê¹€ì² ìˆ˜"))
  assert_eq_string("Hello, Ø£Ø­Ù…Ø¯!", greet("Ø£Ø­Ù…Ø¯"))
  assert_eq_string("Hello, Ğ˜Ğ²Ğ°Ğ½!", greet("Ğ˜Ğ²Ğ°Ğ½"))
  assert_eq_string("Hello, JosÃ©!", greet("JosÃ©"))
  assert_eq_string("Hello, MÃ¼ller!", greet("MÃ¼ller"))
}

test "azimuth_financial_calculation_v2" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate1 = 5
  let rate2 = 6
  let rate3 = 7
  
  let total_rate = add(add(rate1, rate2), rate3)
  let total_amount = multiply(principal, add(100, total_rate))
  assert_eq(1180000, total_amount)
}

test "azimuth_scientific_formula_simulation" {
  // æµ‹è¯•ç§‘å­¦å…¬å¼æ¨¡æ‹Ÿ
  let gravity = 5
  let time1 = 3
  let time2 = 5
  
  let distance1 = multiply(gravity, multiply(time1, time1))
  let distance2 = multiply(gravity, multiply(time2, time2))
  
  assert_eq(45, distance1)
  assert_eq(125, distance2)
}

test "azimuth_boundary_value_combinations" {
  // æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  let result1 = add(multiply(add(max_val, min_val), 2), max_val)
  assert_eq(max_val, result1)
  
  let result2 = multiply(add(add(min_val, max_val), min_val), -1)
  assert_eq(1, result2)
}

test "azimuth_algorithm_efficiency_v2" {
  // æµ‹è¯•ç®—æ³•æ•ˆç‡åœºæ™¯
  let n1 = 100
  let n2 = 1000
  
  let sum1 = multiply(n1, add(n1, 1)) / 2
  let sum2 = multiply(n2, add(n2, 1)) / 2
  
  assert_eq(5050, sum1)
  assert_eq(500500, sum2)
}

test "azimuth_data_structure_operations_v2" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿ
  let stack_size = 0
  let after_push1 = add(stack_size, 1)
  let after_push2 = add(after_push1, 1)
  let after_push3 = add(after_push2, 1)
  
  assert_eq(3, after_push3)
  
  let after_pop1 = add(after_push3, -1)
  let after_pop2 = add(after_pop1, -1)
  let after_pop3 = add(after_pop2, -1)
  
  assert_eq(0, after_pop3)
}

test "azimuth_precision_arithmetic_test" {
  // æµ‹è¯•ç²¾åº¦ç®—æœ¯è¿ç®—
  let product1 = multiply(multiply(1000, 2000), 3000)
  assert_eq(2000000000, product1)
  
  let product2 = multiply(multiply(-1000, 2000), -3000)
  assert_eq(2000000000, product2)
  
  let sum1 = add(add(add(1000000, 2000000), add(3000000, 4000000)), 5000000)
  assert_eq(15000000, sum1)
}

test "azimuth_error_boundary_conditions" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œæ¡ä»¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  assert_true(add(max_val, 100) == max_val)
  assert_true(add(min_val, -100) == min_val)
  assert_true(multiply(max_val, 2) == max_val)
  assert_true(multiply(min_val, -1) == min_val)
  
  // æµ‹è¯•æ­£å¸¸è¿ç®—
  assert_eq(8, add(5, 3))
  assert_eq(15, multiply(3, 5))
  assert_eq_string("Hello, Test!", greet("Test"))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "new_safe_addition_boundary_values" {
  // æµ‹è¯•å®‰å…¨åŠ æ³•çš„è¾¹ç•Œå€¼å¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æ­£å¸¸åŠ æ³•
  assert_eq(10, add(6, 4))
  assert_eq(0, add(-5, 5))
  
  // æµ‹è¯•è¾¹ç•Œå€¼åŠ æ³•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "new_safe_multiplication_edge_cases" {
  // æµ‹è¯•å®‰å…¨ä¹˜æ³•çš„è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æ­£å¸¸ä¹˜æ³•
  assert_eq(12, multiply(3, 4))
  assert_eq(-15, multiply(3, -5))
  
  // æµ‹è¯•ç‰¹æ®Šæƒ…å†µ
  assert_eq(0, multiply(0, max_val))
  assert_eq(0, multiply(0, min_val))
  assert_eq(min_val, multiply(min_val, -1))
}

test "new_greet_function_variations" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ä¸åŒå˜ä½“
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, ç”¨æˆ·123!", greet("ç”¨æˆ·123"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, A!", greet("A"))
}

test "new_divide_with_ceil_functionality" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•åŠŸèƒ½
  // æ­£å¸¸é™¤æ³•ï¼ˆæ•´é™¤ï¼‰
  assert_eq(5, divide_with_ceil(10, 2))
  
  // éœ€è¦å‘ä¸Šå–æ•´çš„æƒ…å†µ
  assert_eq(4, divide_with_ceil(7, 2))
  assert_eq(3, divide_with_ceil(8, 3))
  
  // è´Ÿæ•°æƒ…å†µ
  assert_eq(-3, divide_with_ceil(-7, 2))
  assert_eq(-2, divide_with_ceil(-8, 3))
}

test "new_rectangle_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šè®¡ç®—çŸ©å½¢çš„é¢ç§¯å’Œå‘¨é•¿
  let length = 8
  let width = 5
  
  // è®¡ç®—é¢ç§¯
  let area = multiply(length, width)
  assert_eq(40, area)
  
  // è®¡ç®—å‘¨é•¿
  let perimeter = add(multiply(2, length), multiply(2, width))
  assert_eq(26, perimeter)
}

test "new_mathematical_properties_validation" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨éªŒè¯
  let a = 7
  let b = 11
  let c = 3
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, c)), add(multiply(a, b), multiply(a, c)))
}

test "new_string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_name = "VeryLongNameThatExceedsNormalLength"
  assert_eq_string("Hello, VeryLongNameThatExceedsNormalLength!", greet(long_name))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_name = "test@example.com"
  assert_eq_string("Hello, test@example.com!", greet(special_name))
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let spaced_name = "John Doe"
  assert_eq_string("Hello, John Doe!", greet(spaced_name))
}

test "new_assertion_functions_comprehensive" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„ç»¼åˆä½¿ç”¨
  // æµ‹è¯• assert_true å’Œ assert_false
  assert_true(5 > 3)
  assert_false(3 > 5)
  
  // æµ‹è¯• assert_eq
  assert_eq(42, multiply(6, 7))
  assert_eq(100, add(50, 50))
  
  // æµ‹è¯• assert_eq_string
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, Test!", greet("Test"))
}

test "new_real_world_application_test" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šè´­ç‰©è½¦æ€»ä»·è®¡ç®—
  let item1_price = 199
  let item1_quantity = 2
  let item2_price = 299
  let item2_quantity = 1
  let shipping_fee = 20
  
  // è®¡ç®—å•†å“æ€»ä»·
  let item1_total = multiply(item1_price, item1_quantity)
  let item2_total = multiply(item2_price, item2_quantity)
  let subtotal = add(item1_total, item2_total)
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·ï¼ˆå«è¿è´¹ï¼‰
  let total = add(subtotal, shipping_fee)
  
  // éªŒè¯ç»“æœï¼š199*2 + 299*1 + 20 = 398 + 299 + 20 = 717
  assert_eq(717, total)
}

test "new_overflow_protection_verification" {
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤éªŒè¯
  let max_val = 2147483647
  let min_val = -2147483648
  
  // éªŒè¯åŠ æ³•æº¢å‡ºä¿æŠ¤
  assert_true(add(max_val, 1) == max_val)
  assert_true(add(min_val, -1) == min_val)
  assert_true(add(max_val, max_val) == max_val)
  
  // éªŒè¯ä¹˜æ³•æº¢å‡ºä¿æŠ¤
  assert_true(multiply(max_val, 2) == max_val)
  assert_true(multiply(min_val, 2) == min_val)
  assert_true(multiply(max_val, -1) == min_val)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "enhanced_add_comprehensive_operations" {
  // æµ‹è¯•åŠ æ³•çš„å„ç§æƒ…å†µ
  assert_eq(8, add(3, 5))
  assert_eq(-2, add(3, -5))
  assert_eq(-8, add(-3, -5))
  assert_eq(100, add(0, 100))
  assert_eq(-100, add(0, -100))
}

test "enhanced_multiply_comprehensive_operations" {
  // æµ‹è¯•ä¹˜æ³•çš„å„ç§æƒ…å†µ
  assert_eq(15, multiply(3, 5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(0, multiply(5, 0))
  assert_eq(5, multiply(5, 1))
  assert_eq(-5, multiply(5, -1))
}

test "enhanced_greet_function_variations" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å„ç§æƒ…å†µ
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, ç”¨æˆ·123!", greet("ç”¨æˆ·123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "enhanced_mathematical_formula_applications" {
  // æµ‹è¯•æ•°å­¦å…¬å¼çš„å®é™…åº”ç”¨
  // è®¡ç®—çŸ©å½¢é¢ç§¯ï¼šé•¿ Ã— å®½
  let length = 12
  let width = 8
  let area = multiply(length, width)
  assert_eq(96, area)
  
  // è®¡ç®—çŸ©å½¢å‘¨é•¿ï¼š2 Ã— (é•¿ + å®½)
  let perimeter = multiply(2, add(length, width))
  assert_eq(40, perimeter)
}

test "enhanced_financial_calculations" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate = 5
  let years = 3
  
  // ç®€å•åˆ©æ¯è®¡ç®—ï¼šæœ¬é‡‘ + (æœ¬é‡‘ Ã— åˆ©ç‡ Ã— å¹´æ•°)
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  assert_eq(160000, total)
}

test "enhanced_temperature_conversion" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 2 + 30ï¼ˆæ•´æ•°è¿‘ä¼¼ï¼‰
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 2), 30)
  assert_eq(80, fahrenheit)
  
  // åæ°åº¦è½¬æ‘„æ°åº¦ï¼šC = (F - 30) Ã· 2ï¼ˆæ•´æ•°è¿‘ä¼¼ï¼‰
  let f_to_c = add(fahrenheit, -30) / 2
  assert_eq(25, f_to_c)
}

test "enhanced_complex_business_logic" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡é€»è¾‘
  let unit_price = 199
  let quantity = 3
  let discount_threshold = 500
  let discount_rate = 10
  let tax_rate = 8
  let shipping = 20
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(unit_price, quantity)
  
  // è®¡ç®—æŠ˜æ‰£
  let discount = if (subtotal > discount_threshold) {
    multiply(subtotal, discount_rate) / 100
  } else {
    0
  }
  
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_price = add(subtotal, -discount)
  
  // è®¡ç®—ç¨è´¹
  let tax = multiply(discounted_price, tax_rate) / 100
  
  // è®¡ç®—æ€»ä»·
  let total = add(add(discounted_price, tax), shipping)
  
  assert_eq(1076, total)
}

test "enhanced_boundary_value_operations" {
  // æµ‹è¯•è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•åŠ æ³•è¾¹ç•Œå€¼
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
  
  // æµ‹è¯•ä¹˜æ³•è¾¹ç•Œå€¼
  assert_eq(0, multiply(max_val, 0))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(max_val, multiply(max_val, 1))
}

test "enhanced_string_processing_scenarios" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†åœºæ™¯
  // æµ‹è¯•æ•°å­—å­—ç¬¦ä¸²
  let numeric_name = "12345"
  assert_eq_string("Hello, 12345!", greet(numeric_name))
  
  // æµ‹è¯•æ··åˆå­—ç¬¦ä¸²
  let mixed_name = "user_2023"
  assert_eq_string("Hello, user_2023!", greet(mixed_name))
  
  // æµ‹è¯•å•å­—ç¬¦
  let single_char = "A"
  assert_eq_string("Hello, A!", greet(single_char))
}

test "enhanced_assertion_functions_validation" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("MoonBit", "MoonBit")
  
  // æµ‹è¯•è®¡ç®—ç»“æœçš„æ–­è¨€
  let result = add(17, 25)
  assert_eq(42, result)
  
  let greeting = greet("Developer")
  assert_eq_string("Hello, Developer!", greeting)
  
  let product = multiply(6, 7)
  assert_true(product == 42)
}
