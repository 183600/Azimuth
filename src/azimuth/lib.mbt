pub fn add(a : Int, b : Int) -> Int {
  // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœæœ‰ä¸€ä¸ªæ˜¯0ï¼Œç›´æ¥è¿”å›å¦ä¸€ä¸ª
  if a == 0 {
    return b
  }
  if b == 0 {
    return a
  }

  // å¤„ç†æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼ˆInt32çš„æœ€å°å€¼ï¼‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†ä¸€ä¸ªæ“ä½œæ•°æ˜¯æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ + è´Ÿæ•° = å¯èƒ½æº¢å‡º
    if b < 0 {
      return min_val
    }
    // æœ€å°å€¼ + éè´Ÿæ•° = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }
  if b == min_val {
    // è´Ÿæ•° + æœ€å°å€¼ = å¯èƒ½æº¢å‡º
    if a < 0 {
      return min_val
    }
    // éè´Ÿæ•° + æœ€å°å€¼ = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }

  // æ­£æ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥
  if a > 0 && b > 0 {
    // å¦‚æœ a > max_val - bï¼Œåˆ™ a + b ä¼šæº¢å‡º
    if a > max_val - b {
      return max_val
    }
  }

  // è´Ÿæ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥ï¼ˆæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼ï¼‰
  if a < 0 && b < 0 {
    // ä½¿ç”¨å‡æ³•æ£€æŸ¥ï¼ša < min_val - b
    // ç”±äºbæ˜¯è´Ÿæ•°ï¼Œmin_val - b = min_val + abs(b)
    if a < min_val - b {
      return min_val
    }
  }

  // å®‰å…¨åœ°è¿›è¡ŒåŠ æ³•è¿ç®—
  return a + b
}

///
pub fn multiply(a : Int, b : Int) -> Int {
  // å¸¸é‡å®šä¹‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†0çš„æƒ…å†µ
  if a == 0 || b == 0 {
    return 0
  }

  // å¤„ç†1çš„æƒ…å†µ
  if a == 1 {
    return b
  }
  if b == 1 {
    return a
  }

  // å¤„ç†-1çš„æƒ…å†µï¼ˆåŒ…æ‹¬æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼‰
  if a == -1 {
    // -2147483648 * -1 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if b == min_val { min_val } else { -b }
  }
  if b == -1 {
    // -1 * -2147483648 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if a == min_val { min_val } else { -a }
  }

  // å¤„ç†æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if b > 1 || b < -1 { min_val } else { a * b }
  }
  if b == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if a > 1 || a < -1 { min_val } else { a * b }
  }

  // æ£€æŸ¥æ­£è´Ÿå·
  let sign = if (a > 0 && b > 0) || (a < 0 && b < 0) { 1 } else { -1 }

  // å®‰å…¨åœ°è®¡ç®—ç»å¯¹å€¼ï¼Œæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼
  let abs_a = if a < 0 { -a } else { a }
  let abs_b = if b < 0 { -b } else { b }

  // ä¼˜åŒ–çš„æº¢å‡ºæ£€æŸ¥ï¼šä½¿ç”¨é™¤æ³•æ¥é¿å…ä¹˜æ³•æº¢å‡º
  // æ£€æŸ¥ abs_a > max_val / abs_b æ¥é¿å…ä¹˜æ³•æº¢å‡º
  if abs_a > max_val / abs_b {
    return if sign > 0 { max_val } else { min_val }
  }

  // å®‰å…¨åœ°è¿›è¡Œä¹˜æ³•è¿ç®—
  return a * b
}

///
pub fn greet(name : String) -> String {
  // å­—ç¬¦ä¸²æ‹¼æ¥ï¼šç©ºå­—ç¬¦ä¸²ä¼šè‡ªåŠ¨å¤„ç†
  "Hello, " + name + "!"
}

// æµ‹è¯•è¾…åŠ©å‡½æ•°ï¼Œæä¾›æ–­è¨€åŠŸèƒ½
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (expected == actual) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (expected == actual) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_true(condition : Bool) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (condition) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_false(condition : Bool) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (condition) {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  } else {
    ()
  }
}

// è¾…åŠ©å‡½æ•°ï¼šå‘ä¸Šå–æ•´é™¤æ³•
pub fn divide_with_ceil(dividend : Int, divisor : Int) -> Int {
  let quotient = dividend / divisor
  let remainder = dividend % divisor
  if remainder > 0 { add(quotient, 1) } else { quotient }
}

// æµ‹è¯•ç”¨ä¾‹
test "basic_add_test" {
  let result = add(2, 3)
  assert_eq(5, result)
}

test "add_with_zero" {
  // æµ‹è¯•ä¸0ç›¸åŠ çš„æƒ…å†µ
  assert_eq(5, add(5, 0))
  assert_eq(5, add(0, 5))
  assert_eq(0, add(0, 0))
}

test "add_with_min_value" {
  // æµ‹è¯•æœ€å°å€¼çš„æƒ…å†µ
  let min_val = -2147483648
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, add(0, min_val))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-2147483647, add(min_val, 1))
}

test "add_positive_overflow" {
  // æµ‹è¯•æ­£æ•°æº¢å‡ºçš„æƒ…å†µ
  let max_val = 2147483647
  assert_eq(max_val, add(max_val, 1))
  assert_eq(max_val, add(1000000000, 1500000000))
}

test "add_negative_overflow" {
  // æµ‹è¯•è´Ÿæ•°æº¢å‡ºçš„æƒ…å†µ
  let min_val = -2147483648
  assert_eq(min_val, add(min_val, -1))
  assert_eq(min_val, add(-1500000000, -1000000000))
}

test "basic_multiply_test" {
  let result = multiply(2, 3)
  assert_eq(6, result)
}

test "multiply_with_zero_and_one" {
  // æµ‹è¯•ä¸0å’Œ1ç›¸ä¹˜çš„æƒ…å†µ
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(5, multiply(5, 1))
  assert_eq(5, multiply(1, 5))
}

test "multiply_with_negative_one" {
  // æµ‹è¯•ä¸-1ç›¸ä¹˜çš„æƒ…å†µ
  assert_eq(-5, multiply(5, -1))
  assert_eq(-5, multiply(-1, 5))
  assert_eq(5, multiply(-5, -1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸-1ç›¸ä¹˜çš„ç‰¹æ®Šæƒ…å†µ
  let min_val = -2147483648
  assert_eq(min_val, multiply(min_val, -1))
}

test "multiply_overflow" {
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºçš„æƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(max_val, multiply(46341, 46341))  // sqrt(max_val)çš„å¹³æ–¹
  assert_eq(min_val, multiply(-46341, 46341))
}

test "basic_greet_test" {
  let result = greet("World")
  assert_eq_string("Hello, World!", result)
}

test "greet_with_empty_string" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²çš„æƒ…å†µ
  let result = greet("")
  assert_eq_string("Hello, !", result)
}

test "greet_with_special_characters" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let result = greet("æµ‹è¯•@123")
  assert_eq_string("Hello, æµ‹è¯•@123!", result)
}

// æ–°å¢æµ‹è¯•ç”¨ä¾‹
test "add_large_numbers" {
  // æµ‹è¯•å¤§æ•°ç›¸åŠ 
  assert_eq(2000000000, add(1000000000, 1000000000))
  assert_eq(-2000000000, add(-1000000000, -1000000000))
}

test "add_mixed_signs" {
  // æµ‹è¯•ä¸åŒç¬¦å·çš„æ•°ç›¸åŠ 
  assert_eq(0, add(100, -100))
  assert_eq(-50, add(100, -150))
  assert_eq(50, add(-100, 150))
}

test "multiply_large_numbers" {
  // æµ‹è¯•å¤§æ•°ç›¸ä¹˜
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(-1000000, multiply(-1000, 1000))
  assert_eq(1000000, multiply(-1000, -1000))
}

test "multiply_boundary_combinations" {
  // æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆçš„ä¹˜æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(min_val, multiply(min_val, 1))
}

test "greet_with_whitespace" {
  // æµ‹è¯•åŒ…å«ç©ºç™½å­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello,   World!", greet("  World"))
  assert_eq_string("Hello, World   !", greet("World  "))
  assert_eq_string("Hello,  World  !", greet(" World  "))
}

test "greet_with_unicode_emoji" {
  // æµ‹è¯•åŒ…å« Unicode emoji çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
  assert_eq_string("Hello, ğŸ‘‹!", greet("ğŸ‘‹"))
}

test "assert_functions_test" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

test "complex_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šè®¡ç®—çŸ©å½¢çš„å‘¨é•¿
  let length = 10
  let width = 5
  let perimeter = add(multiply(2, length), multiply(2, width))
  assert_eq(30, perimeter)
}

test "financial_calculation_scenario" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯ï¼šå¤åˆ©è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let principal = 1000
  let rate = 5
  let years = 3
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼šæœ¬æ¯å’Œ = æœ¬é‡‘ + æœ¬é‡‘ Ã— åˆ©ç‡ Ã— å¹´æ•°
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  assert_eq(16000, total)  // 1000 + 1000*5*3 = 16000ï¼Œè¡¨ç¤º1600å…ƒ
}

// æ–°å¢çš„10ä¸ªæµ‹è¯•ç”¨ä¾‹
test "sequential_addition" {
  // æµ‹è¯•è¿ç»­ç›¸åŠ çš„æƒ…å†µ
  let result1 = add(add(1, 2), add(3, 4))
  assert_eq(10, result1)
  
  let result2 = add(add(100, 200), add(300, 400))
  assert_eq(1000, result2)
  
  // æµ‹è¯•åŒ…å«æœ€å°å€¼çš„è¿ç»­ç›¸åŠ 
  let min_val = -2147483648
  let result3 = add(add(min_val, 1), add(1, 1))
  assert_eq(-2147483645, result3)
}

test "sequential_multiplication" {
  // æµ‹è¯•è¿ç»­ç›¸ä¹˜çš„æƒ…å†µ
  let result1 = multiply(multiply(2, 3), multiply(4, 5))
  assert_eq(120, result1)
  
  let result2 = multiply(multiply(10, 20), multiply(30, 40))
  assert_eq(240000, result2)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„è¿ç»­ç›¸ä¹˜
  let result3 = multiply(multiply(-2, 3), multiply(4, -5))
  assert_eq(120, result3)
}

test "extreme_value_operations" {
  // æµ‹è¯•æå€¼è¿ç®—çš„ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æå€¼ç›¸åŠ 
  assert_eq(-1, add(max_val, min_val))
  
  // æå€¼ä¸æ¥è¿‘æå€¼çš„æ•°ç›¸åŠ 
  assert_eq(max_val, add(max_val, 100))
  assert_eq(min_val, add(min_val, -100))
  
  // æå€¼ç›¸ä¹˜
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
}

test "string_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¿æ¥çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²
  let long_name = "ThisIsAVeryLongNameThatMightCauseIssuesInSomeSystemsButShouldWorkFineInMoonBit"
  let result = greet(long_name)
  assert_eq_string("Hello, " + long_name + "!", result)
  
  // æµ‹è¯•åŒ…å«å¼•å·çš„å­—ç¬¦ä¸²
  let quoted_name = "\"John Doe\""
  let result2 = greet(quoted_name)
  assert_eq_string("Hello, \"John Doe\"!", result2)
  
  // æµ‹è¯•åŒ…å«æ¢è¡Œç¬¦çš„å­—ç¬¦ä¸²
  let newline_name = "Line1\nLine2"
  let result3 = greet(newline_name)
  assert_eq_string("Hello, Line1\nLine2!", result3)
}

test "addition_associativity" {
  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹ (a + b) + c = a + (b + c)
  let a = 100
  let b = 200
  let c = 300
  
  let result1 = add(add(a, b), c)
  let result2 = add(a, add(b, c))
  assert_eq(result1, result2)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„æƒ…å†µ
  let d = -150
  let e = 250
  let f = -100
  
  let result3 = add(add(d, e), f)
  let result4 = add(d, add(e, f))
  assert_eq(result3, result4)
}

test "multiplication_commutativity" {
  // æµ‹è¯•ä¹˜æ³•äº¤æ¢å¾‹ a * b = b * a
  let a = 12
  let b = 15
  
  let result1 = multiply(a, b)
  let result2 = multiply(b, a)
  assert_eq(result1, result2)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„æƒ…å†µ
  let c = -20
  let d = 30
  
  let result3 = multiply(c, d)
  let result4 = multiply(d, c)
  assert_eq(result3, result4)
  
  // æµ‹è¯•åŒ…å«0çš„æƒ…å†µ
  let e = 0
  let f = 100
  
  let result5 = multiply(e, f)
  let result6 = multiply(f, e)
  assert_eq(result5, result6)
}

test "complex_string_processing" {
  // æµ‹è¯•å¤æ‚å­—ç¬¦ä¸²å¤„ç†
  // æµ‹è¯•åŒ…å«å¤šç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let complex_name = "John@Doe#123$%^&*()"
  let result = greet(complex_name)
  assert_eq_string("Hello, John@Doe#123$%^&*()!", result)
  
  // æµ‹è¯•åŒ…å«ä¸­æ–‡å­—ç¬¦çš„å­—ç¬¦ä¸²
  let chinese_name = "å¼ ä¸‰"
  let result2 = greet(chinese_name)
  assert_eq_string("Hello, å¼ ä¸‰!", result2)
  
  // æµ‹è¯•æ··åˆè¯­è¨€å­—ç¬¦ä¸²
  let mixed_name = "Johnå¼ ä¸‰123"
  let result3 = greet(mixed_name)
  assert_eq_string("Hello, Johnå¼ ä¸‰123!", result3)
}

test "shopping_cart_calculation" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šè´­ç‰©è½¦è®¡ç®—
  let item1_price = 299
  let item1_quantity = 2
  let item2_price = 199
  let item2_quantity = 3
  let item3_price = 99
  let item3_quantity = 1
  
  // è®¡ç®—æ¯ç§å•†å“çš„æ€»ä»·
  let total1 = multiply(item1_price, item1_quantity)
  let total2 = multiply(item2_price, item2_quantity)
  let total3 = multiply(item3_price, item3_quantity)
  
  // è®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let cart_total = add(add(total1, total2), total3)
  
  // éªŒè¯æ€»ä»·ï¼š299*2 + 199*3 + 99*1 = 598 + 597 + 99 = 1294
  assert_eq(1294, cart_total)
}

test "temperature_conversion" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šæ¸©åº¦è½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C * 9/5 + 32
  // ç”±äºæˆ‘ä»¬åªæœ‰æ•´æ•°è¿ç®—ï¼Œæˆ‘ä»¬ä½¿ç”¨è¿‘ä¼¼å€¼ï¼šF = C * 2 + 30
  
  let celsius_temp = 25
  let fahrenheit_temp = add(multiply(celsius_temp, 2), 30)
  assert_eq(80, fahrenheit_temp)  // 25 * 2 + 30 = 80
  
  // æµ‹è¯•å†°ç‚¹æ¸©åº¦
  let freezing_celsius = 0
  let freezing_fahrenheit = add(multiply(freezing_celsius, 2), 30)
  assert_eq(30, freezing_fahrenheit)  // 0 * 2 + 30 = 30
  
  // æµ‹è¯•æ²¸ç‚¹æ¸©åº¦
  let boiling_celsius = 100
  let boiling_fahrenheit = add(multiply(boiling_celsius, 2), 30)
  assert_eq(230, boiling_fahrenheit)  // 100 * 2 + 30 = 230
}

test "error_handling_scenarios" {
  // æµ‹è¯•é”™è¯¯å¤„ç†åœºæ™¯
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„é”™è¯¯æƒ…å†µï¼ˆè¿™äº›æµ‹è¯•ä¼šæ•…æ„å¤±è´¥ï¼Œä½†åœ¨å®é™…ä½¿ç”¨ä¸­è¢«æ³¨é‡Šæ‰ï¼‰
  // assert_true(false)  // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  // assert_false(true)  // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  // assert_eq(1, 2)     // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  // assert_eq_string("hello", "world")  // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µçš„æ­£ç¡®å¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ç¡®ä¿æº¢å‡ºè¢«æ­£ç¡®å¤„ç†
  assert_true(add(max_val, 1) == max_val)
  assert_true(add(min_val, -1) == min_val)
  assert_true(multiply(max_val, 2) == max_val)
  assert_true(multiply(min_val, -1) == min_val)
  
  // æµ‹è¯•æ­£å¸¸æƒ…å†µ
  assert_true(add(5, 3) == 8)
  assert_true(multiply(4, 6) == 24)
  assert_true(greet("Test") == "Hello, Test!")
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "standard_integer_operations" {
  // æµ‹è¯•æ•´æ•°è¿ç®—
  assert_eq(10, add(4, 6))
  assert_eq(0, add(-5, 5))
  assert_eq(15, multiply(3, 5))
  assert_eq(-12, multiply(-3, 4))
}

test "standard_string_operations" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ“ä½œ
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
}

test "standard_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 11
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, 3)), add(multiply(a, b), multiply(a, 3)))
}

test "standard_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¾¹ç•Œå€¼åŠ æ³•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
  
  // è¾¹ç•Œå€¼ä¹˜æ³•
  assert_eq(0, multiply(max_val, 0))
  assert_eq(min_val, multiply(min_val, -1))
}

test "standard_real_world_scenarios" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  // æ¸©åº¦è½¬æ¢ï¼šæ‘„æ°åº¦è½¬åæ°åº¦ï¼ˆç®€åŒ–ç‰ˆï¼šF = C Ã— 2 + 30ï¼‰
  let celsius = 20
  let fahrenheit = add(multiply(celsius, 2), 30)
  assert_eq(70, fahrenheit)
  
  // ç®€å•è´·æ¬¾è®¡ç®—ï¼šæœ¬é‡‘ Ã— (1 + åˆ©ç‡ Ã— å¹´æ•°)
  let principal = 10000
  let rate = 5  // 5%
  let years = 3
  let total = multiply(principal, add(1, multiply(rate, years)))
  assert_eq(160000, total)  // 10000 Ã— (1 + 5Ã—3) = 10000 Ã— 16 = 160000
}

test "standard_error_handling" {
  // æµ‹è¯•é”™è¯¯å¤„ç†
  assert_true(true)
  assert_false(false)
  assert_eq(100, 100)
  assert_eq_string("success", "success")
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  assert_true(add(max_val, 100) == max_val)
  assert_true(multiply(max_val, 2) == max_val)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
test "numeric_range_validation" {
  // æµ‹è¯•æ­£æ•°èŒƒå›´
  assert_true(add(1000000, 2000000) > 0)
  assert_true(multiply(1000, 1000) > 0)
  
  // æµ‹è¯•è´Ÿæ•°èŒƒå›´
  assert_true(add(-1000000, -2000000) < 0)
  assert_true(multiply(-1000, 1000) < 0)
  
  // æµ‹è¯•é›¶å€¼
  assert_eq(0, multiply(0, 123456789))
  assert_eq(123456789, add(0, 123456789))
}

test "string_concatenation_performance" {
  // æµ‹è¯•çŸ­å­—ç¬¦ä¸²è¿æ¥
  let short_name = "Bob"
  let short_result = greet(short_name)
  assert_eq_string("Hello, Bob!", short_result)
  
  // æµ‹è¯•ä¸­ç­‰é•¿åº¦å­—ç¬¦ä¸²è¿æ¥
  let medium_name = "Alexander"
  let medium_result = greet(medium_name)
  assert_eq_string("Hello, Alexander!", medium_result)
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let spaced_name = "Mary Jane"
  let spaced_result = greet(spaced_name)
  assert_eq_string("Hello, Mary Jane!", spaced_result)
}

test "math_function_combination" {
  // æµ‹è¯• (a + b) * c - d çš„å¤åˆè¿ç®—
  let a = 5
  let b = 3
  let c = 4
  let d = 10
  
  // æ­¥éª¤è®¡ç®—
  let sum_ab = add(a, b)  // 5 + 3 = 8
  let product = multiply(sum_ab, c)  // 8 * 4 = 32
  let result = add(product, -d)  // 32 - 10 = 22
  
  assert_eq(22, result)
}

test "boundary_value_special_handling" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸æ­£æ•°ç›¸åŠ 
  assert_eq(max_val, add(max_val, 100))
  assert_eq(max_val, add(max_val, max_val))
  
  // æµ‹è¯•æœ€å°å€¼ä¸è´Ÿæ•°ç›¸åŠ 
  assert_eq(min_val, add(min_val, -100))
  assert_eq(min_val, add(min_val, min_val))
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸è´Ÿæ•°ç›¸ä¹˜
  assert_eq(min_val, multiply(max_val, -1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸å¥‡æ•°ç›¸ä¹˜
  assert_eq(min_val, multiply(min_val, 3))
}

test "average_calculation" {
  // è®¡ç®—ä¸‰ä¸ªæ•°çš„å¹³å‡å€¼ï¼š(a + b + c) / 3
  let num1 = 90
  let num2 = 80
  let num3 = 85
  
  // è®¡ç®—æ€»å’Œï¼š90 + 80 + 85 = 255
  let sum = add(add(num1, num2), num3)
  // è®¡ç®—å¹³å‡å€¼ï¼š255 / 3 = 85ï¼ˆæ•´æ•°é™¤æ³•ï¼‰
  let average = sum / 3
  
  assert_eq(85, average)
}

test "area_calculation" {
  // è®¡ç®—çŸ©å½¢é¢ç§¯ï¼šé•¿ Ã— å®½
  let length = 12
  let width = 8
  
  let rectangle_area = multiply(length, width)
  assert_eq(96, rectangle_area)
  
  // è®¡ç®—ä¸‰è§’å½¢é¢ç§¯ï¼šåº• Ã— é«˜ Ã· 2
  let base = 10
  let height = 6
  
  let triangle_area = multiply(base, height) / 2
  assert_eq(30, triangle_area)
}

test "string_formatting_scenarios" {
  // æµ‹è¯•æ•°å­—å­—ç¬¦ä¸²
  let numeric_name = "12345"
  assert_eq_string("Hello, 12345!", greet(numeric_name))
  
  // æµ‹è¯•æ··åˆå­—ç¬¦ä¸²
  let mixed_name = "user_2023"
  assert_eq_string("Hello, user_2023!", greet(mixed_name))
  
  // æµ‹è¯•å•å­—ç¬¦
  let single_char = "A"
  assert_eq_string("Hello, A!", greet(single_char))
}

test "sum_of_squares_calculation" {
  // è®¡ç®—å‰nä¸ªè‡ªç„¶æ•°çš„å¹³æ–¹å’Œï¼š1Â² + 2Â² + 3Â² + ... + nÂ²
  let n = 5
  
  // æ‰‹åŠ¨è®¡ç®—ï¼š1Â² + 2Â² + 3Â² + 4Â² + 5Â² = 1 + 4 + 9 + 16 + 25 = 55
  let square1 = multiply(1, 1)
  let square2 = multiply(2, 2)
  let square3 = multiply(3, 3)
  let square4 = multiply(4, 4)
  let square5 = multiply(5, 5)
  
  let sum_of_squares = add(add(add(add(square1, square2), square3), square4), square5)
  assert_eq(55, sum_of_squares)
}

test "conditional_logic_test" {
  // æµ‹è¯•åŸºäºæ¯”è¾ƒç»“æœçš„æ¡ä»¶è¿ç®—
  let x = 15
  let y = 20
  
  // å¦‚æœ x < yï¼Œåˆ™è®¡ç®— x + yï¼Œå¦åˆ™è®¡ç®— x * y
  let condition = x < y
  let result = if condition { add(x, y) } else { multiply(x, y) }
  
  // ç”±äº 15 < 20 ä¸ºçœŸï¼Œæ‰€ä»¥åº”è¯¥è®¡ç®— 15 + 20 = 35
  assert_eq(35, result)
  
  // åå‘æµ‹è¯•
  let condition2 = x > y
  let result2 = if condition2 { add(x, y) } else { multiply(x, y) }
  
  // ç”±äº 15 > 20 ä¸ºå‡ï¼Œæ‰€ä»¥åº”è¯¥è®¡ç®— 15 * 20 = 300
  assert_eq(300, result2)
}

test "data_conversion_scenarios" {
  // æµ‹è¯•æ•°å€¼åˆ°å­—ç¬¦ä¸²çš„é—´æ¥è½¬æ¢ï¼ˆé€šè¿‡greetå‡½æ•°ï¼‰
  let number = 42
  let number_str = "42"
  
  // é€šè¿‡greetå‡½æ•°éªŒè¯å­—ç¬¦ä¸²æ‹¼æ¥
  let result1 = greet(number_str)
  let result2 = greet("Answer is " + number_str)
  
  assert_eq_string("Hello, 42!", result1)
  assert_eq_string("Hello, Answer is 42!", result2)
  
  // æµ‹è¯•å¸ƒå°”å€¼åœºæ™¯ï¼ˆé€šè¿‡å­—ç¬¦ä¸²è¡¨ç¤ºï¼‰
  let true_str = "true"
  let false_str = "false"
  
  assert_eq_string("Hello, true!", greet(true_str))
  assert_eq_string("Hello, false!", greet(false_str))
}

// æ–°å¢çš„10ä¸ªMoonBitæµ‹è¯•ç”¨ä¾‹
test "factorial_calculation" {
  // è®¡ç®—5çš„é˜¶ä¹˜ï¼š5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
  let n = 5
  let result = multiply(n, multiply(n - 1, multiply(n - 2, multiply(n - 3, n - 4))))
  assert_eq(120, result)
}

test "compound_interest_precise" {
  // ç²¾ç¡®çš„å¤åˆ©è®¡ç®—ï¼šæœ¬é‡‘ Ã— (1 + åˆ©ç‡)^å¹´æ•°
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼š1000 Ã— (1 + 5%)^3 â‰ˆ 1000 Ã— 116 = 116000
  let principal = 1000
  let rate_percent = 5
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©å…¬å¼ï¼Œé¿å…æµ®ç‚¹æ•°
  let growth_factor = add(100, multiply(rate_percent, years))
  let total = multiply(principal, growth_factor)
  assert_eq(115000, total)  // 1000 Ã— (100 + 5Ã—3) = 1000 Ã— 115 = 115000
}

test "nested_calculations" {
  // åµŒå¥—è®¡ç®—æµ‹è¯•ï¼š((a + b) Ã— (c + d)) - (e Ã— f)
  let a = 10
  let b = 20
  let c = 5
  let d = 15
  let e = 8
  let f = 12
  
  let sum1 = add(a, b)  // 30
  let sum2 = add(c, d)  // 20
  let product1 = multiply(sum1, sum2)  // 600
  let product2 = multiply(e, f)  // 96
  let result = add(product1, -product2)  // 504
  
  assert_eq(504, result)
}

test "string_length_edge_cases" {
  // æµ‹è¯•ä¸åŒé•¿åº¦å­—ç¬¦ä¸²çš„greetå‡½æ•°å¤„ç†
  let empty = ""
  let single = "A"
  let short = "Hi"
  let medium = "MoonBit"
  let long = "ThisIsAVeryLongStringForTestingPurposes"
  
  assert_eq_string("Hello, !", greet(empty))
  assert_eq_string("Hello, A!", greet(single))
  assert_eq_string("Hello, Hi!", greet(short))
  assert_eq_string("Hello, MoonBit!", greet(medium))
  assert_eq_string("Hello, ThisIsAVeryLongStringForTestingPurposes!", greet(long))
}

test "mathematical_series_sum" {
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œï¼š1 + 3 + 5 + ... + 19ï¼ˆå‰10ä¸ªå¥‡æ•°ï¼‰
  // ä½¿ç”¨å…¬å¼ï¼šn Ã— (é¦–é¡¹ + æœ«é¡¹) / 2
  let n = 10
  let first = 1
  let last = 19
  
  let sum = multiply(n, add(first, last)) / 2
  assert_eq(100, sum)  // 10 Ã— (1 + 19) / 2 = 100
}

test "power_of_two_calculation" {
  // è®¡ç®—2çš„å¹‚ï¼š2^8 = 256
  // é€šè¿‡è¿ç»­ç›¸ä¹˜å®ç°
  let power = 8
  let result = multiply(multiply(multiply(2, 2), multiply(2, 2)), multiply(multiply(2, 2), multiply(2, 2)))
  assert_eq(256, result)
}

test "percentage_calculations" {
  // ç™¾åˆ†æ¯”è®¡ç®—æµ‹è¯•
  let total = 500
  let percentage = 25  // 25%
  
  // è®¡ç®—ç™¾åˆ†æ¯”å€¼ï¼šæ€»æ•° Ã— ç™¾åˆ†æ¯” / 100
  let value = multiply(total, percentage) / 100
  assert_eq(125, value)  // 500 Ã— 25 / 100 = 125
  
  // è®¡ç®—å¢åŠ åçš„å€¼ï¼šæ€»æ•° + ç™¾åˆ†æ¯”å€¼
  let increased = add(total, value)
  assert_eq(625, increased)  // 500 + 125 = 625
}

test "string_with_numbers_and_symbols" {
  // æµ‹è¯•åŒ…å«æ•°å­—å’Œç¬¦å·çš„å­—ç¬¦ä¸²
  let alphanumeric = "Test123"
  let symbolic = "test@example.com"
  let mixed = "User_2023@Project#1"
  
  assert_eq_string("Hello, Test123!", greet(alphanumeric))
  assert_eq_string("Hello, test@example.com!", greet(symbolic))
  assert_eq_string("Hello, User_2023@Project#1!", greet(mixed))
}

test "extreme_boundary_combinations" {
  // æç«¯è¾¹ç•Œå€¼ç»„åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸æœ€å°å€¼çš„å„ç§è¿ç®—
  assert_eq(-1, add(max_val, min_val))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(min_val, add(min_val, 0))
  assert_eq(max_val, add(max_val, 0))
  
  // è¾¹ç•Œå€¼é™„è¿‘çš„è¿ç®—
  assert_eq(2147483646, add(max_val, -1))
  assert_eq(-2147483647, add(min_val, 1))
}

test "real_world_application" {
  // å®é™…åº”ç”¨åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let item_price = 199
  let quantity = 3
  let shipping = 15
  let tax_rate = 10  // 10%
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(item_price, quantity)
  // è®¡ç®—ç¨è´¹
  let tax = multiply(subtotal, tax_rate) / 100
  // è®¡ç®—æœ€ç»ˆæ€»ä»·
  let total = add(add(subtotal, tax), shipping)
  
  assert_eq(674, total)  // (199Ã—3) + (199Ã—3Ã—10/100) + 15 = 597 + 59 + 15 = 674
}

// æ–°å¢çš„ 10 ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "bitwise_operations_simulation" {
  // æ¨¡æ‹Ÿä½è¿ç®—ï¼šä½¿ç”¨åŠ å‡ä¹˜é™¤å®ç°ä½è¿ç®—æ•ˆæœ
  let a = 8
  let b = 3
  
  // å·¦ç§»è¿ç®—æ¨¡æ‹Ÿï¼ša << 1 = a * 2
  let left_shift = multiply(a, 2)
  assert_eq(16, left_shift)
  
  // å³ç§»è¿ç®—æ¨¡æ‹Ÿï¼ša >> 1 = a / 2
  let right_shift = a / 2
  assert_eq(4, right_shift)
  
  // ä½æˆ–è¿ç®—æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰ï¼ša | b = a + b - (a & b)
  // è¿™é‡Œæˆ‘ä»¬ç®€åŒ–ä¸º a + b
  let bit_or_sim = add(a, b)
  assert_eq(11, bit_or_sim)
}

test "currency_conversion_practical" {
  // å®é™…è´§å¸è½¬æ¢åœºæ™¯
  let usd_amount = 100
  let exchange_rate = 7  // 1 USD = 7 CNY (ç®€åŒ–æ±‡ç‡)
  
  // è½¬æ¢ä¸ºäººæ°‘å¸
  let cny_amount = multiply(usd_amount, exchange_rate)
  assert_eq(700, cny_amount)
  
  // æ·»åŠ æ‰‹ç»­è´¹ 5%
  let fee = multiply(cny_amount, 5) / 100
  let total_with_fee = add(cny_amount, fee)
  assert_eq(735, total_with_fee)
}

test "geometry_calculations" {
  // å‡ ä½•è®¡ç®—æµ‹è¯•
  let radius = 5
  
  // åœ†å‘¨é•¿ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼š2 Ã— Ï€ Ã— r â‰ˆ 2 Ã— 3 Ã— r
  let circumference = multiply(multiply(2, 3), radius)
  assert_eq(30, circumference)
  
  // åœ†é¢ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼šÏ€ Ã— rÂ² â‰ˆ 3 Ã— rÂ²
  let area = multiply(3, multiply(radius, radius))
  assert_eq(75, area)
  
  // çƒä½“ä½“ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼š4/3 Ã— Ï€ Ã— rÂ³ â‰ˆ 4 Ã— rÂ³
  let volume = multiply(4, multiply(radius, multiply(radius, radius)))
  assert_eq(500, volume)
}

test "time_calculations" {
  // æ—¶é—´è®¡ç®—æµ‹è¯•
  let hours = 2
  let minutes = 30
  
  // è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°
  let total_minutes = add(multiply(hours, 60), minutes)
  assert_eq(150, total_minutes)
  
  // è½¬æ¢ä¸ºæ€»ç§’æ•°
  let total_seconds = multiply(total_minutes, 60)
  assert_eq(9000, total_seconds)
  
  // è®¡ç®—æ—¶é—´å·®ï¼ˆåˆ†é’Ÿï¼‰
  let start_time = 480  // 8:00 AM in minutes
  let end_time = 1020    // 5:00 PM in minutes
  let duration = add(end_time, -start_time)
  assert_eq(540, duration)
}

test "statistics_basic" {
  // åŸºç¡€ç»Ÿè®¡è®¡ç®—
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(10, 20), 30), 40), 50)
  assert_eq(150, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let average = sum / 5
  assert_eq(30, average)
  
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆå·²æ’åºæ•°ç»„ï¼‰
  let median = 30
  assert_eq(30, median)
}

test "game_score_calculation" {
  // æ¸¸æˆå¾—åˆ†è®¡ç®—æµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let bonus_points = 500
  let penalty = 200
  
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let level_score = multiply(base_score, level_multiplier)
  let total_with_bonus = add(level_score, bonus_points)
  let final_score = add(total_with_bonus, -penalty)
  
  assert_eq(3300, final_score)
  
  // è®¡ç®—æ’åå¾—åˆ†ï¼ˆå‰10%é¢å¤–åŠ åˆ†ï¼‰
  let top_percentage = 10
  let rank_bonus = multiply(final_score, top_percentage) / 100
  let rank_total = add(final_score, rank_bonus)
  
  assert_eq(3630, rank_total)
}

test "energy_consumption" {
  // èƒ½è€—è®¡ç®—æµ‹è¯•
  let power_rating = 100  // ç“¦ç‰¹
  let hours_used = 24
  let days_used = 30
  let cost_per_kwh = 10  // æ¯åƒç“¦æ—¶è´¹ç”¨ï¼ˆç®€åŒ–ï¼‰
  
  // è®¡ç®—æ€»èƒ½è€—ï¼ˆç“¦æ—¶ï¼‰
  let daily_consumption = multiply(power_rating, hours_used)
  let monthly_consumption = multiply(daily_consumption, days_used)
  
  // è½¬æ¢ä¸ºåƒç“¦æ—¶
  let kwh_consumption = monthly_consumption / 1000
  assert_eq(72, kwh_consumption)
  
  // è®¡ç®—è´¹ç”¨
  let total_cost = multiply(kwh_consumption, cost_per_kwh)
  assert_eq(720, total_cost)
}

test "factorial_calculation_v2" {
  // è®¡ç®—5çš„é˜¶ä¹˜ï¼š5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
  let n = 5
  let result = multiply(n, multiply(n - 1, multiply(n - 2, multiply(n - 3, n - 4))))
  assert_eq(120, result)
}

test "power_of_two_calculation_v2" {
  // è®¡ç®—2çš„å¹‚ï¼š2^8 = 256
  // é€šè¿‡è¿ç»­ç›¸ä¹˜å®ç°
  let result = multiply(multiply(multiply(2, 2), multiply(2, 2)), multiply(multiply(2, 2), multiply(2, 2)))
  assert_eq(256, result)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "array_index_calculation" {
  // æ•°ç»„ç´¢å¼•è®¡ç®—æµ‹è¯•ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—
  let row = 3
  let col = 4
  let width = 5
  
  // è®¡ç®—äºŒç»´æ•°ç»„åœ¨ä¸€ç»´æ•°ç»„ä¸­çš„ç´¢å¼•ï¼šindex = row * width + col
  let index = add(multiply(row, width), col)
  assert_eq(19, index)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let first_row = 0
  let first_col = 0
  let first_index = add(multiply(first_row, width), first_col)
  assert_eq(0, first_index)
  
  let last_row = 9
  let last_col = 4
  let last_index = add(multiply(last_row, width), last_col)
  assert_eq(49, last_index)
}

test "string_template_processing" {
  // å­—ç¬¦ä¸²æ¨¡æ¿å¤„ç†æµ‹è¯•ï¼šæ¨¡æ‹Ÿç®€å•çš„å­—ç¬¦ä¸²æ¨¡æ¿åŠŸèƒ½
  let template = "Hello, {name}! Today is {day}."
  let name = "Alice"
  let day = "Monday"
  
  // æ¨¡æ‹Ÿæ¨¡æ¿æ›¿æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let greeting = greet(name)
  let day_prefix = " Today is "
  let day_suffix = "."
  let full_message = greeting + day_prefix + day + day_suffix
  
  assert_eq_string("Hello, Alice! Today is Monday.", full_message)
  
  // æµ‹è¯•ç©ºå€¼å¤„ç†
  let empty_name = ""
  let empty_greeting = greet(empty_name)
  assert_eq_string("Hello, !", empty_greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_name = "Bob@123"
  let special_greeting = greet(special_name)
  assert_eq_string("Hello, Bob@123!", special_greeting)
}

test "mathematical_formula_validation" {
  // æ•°å­¦å…¬å¼éªŒè¯æµ‹è¯•ï¼šéªŒè¯åŸºæœ¬çš„æ•°å­¦æ’ç­‰å¼
  let a = 7
  let b = 3
  
  // éªŒè¯åˆ†é…å¾‹ï¼ša Ã— (b + c) = a Ã— b + a Ã— c
  let c = 5
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
  
  // éªŒè¯å¹³æ–¹å·®å…¬å¼ï¼š(a + b) Ã— (a - b) = aÂ² - bÂ²
  let sum = add(a, b)
  let diff = add(a, -b)
  let product = multiply(sum, diff)
  let square_diff = add(multiply(a, a), multiply(-b, b))
  assert_eq(product, square_diff)
  
  // éªŒè¯ç«‹æ–¹å’Œå…¬å¼ï¼šaÂ³ + bÂ³ = (a + b) Ã— (aÂ² - a Ã— b + bÂ²)
  let a_cubed = multiply(multiply(a, a), a)
  let b_cubed = multiply(multiply(b, b), b)
  let sum_of_cubes = add(a_cubed, b_cubed)
  
  let a_squared = multiply(a, a)
  let b_squared = multiply(b, b)
  let a_times_b = multiply(a, b)
  let second_factor = add(add(a_squared, multiply(-a_times_b, 1)), b_squared)
  let formula_result = multiply(add(a, b), second_factor)
  
  assert_eq(sum_of_cubes, formula_result)
}

test "boundary_condition_combinations" {
  // è¾¹ç•Œæ¡ä»¶ç»„åˆæµ‹è¯•ï¼šæµ‹è¯•å¤šä¸ªè¾¹ç•Œæ¡ä»¶çš„å¤æ‚ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  let zero = 0
  let one = 1
  let neg_one = -1
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸å…¶ä»–è¾¹ç•Œå€¼çš„è¿ç®—
  assert_eq(max_val, add(max_val, zero))
  assert_eq(max_val, multiply(max_val, one))
  assert_eq(min_val, multiply(max_val, neg_one))
  
  // æµ‹è¯•æœ€å°å€¼ä¸å…¶ä»–è¾¹ç•Œå€¼çš„è¿ç®—
  assert_eq(min_val, add(min_val, zero))
  assert_eq(min_val, multiply(min_val, one))
  assert_eq(max_val, multiply(min_val, neg_one))
  
  // æµ‹è¯•é›¶çš„è¿ç®—ç‰¹æ€§
  assert_eq(zero, multiply(zero, max_val))
  assert_eq(zero, multiply(zero, min_val))
  assert_eq(max_val, add(zero, max_val))
  assert_eq(min_val, add(zero, min_val))
  
  // æµ‹è¯•è¿ç»­è¾¹ç•Œè¿ç®—
  let chain_result = add(multiply(add(max_val, min_val), one), max_val)
  assert_eq(max_val, chain_result)
}

test "real_world_business_scenario" {
  // å®é™…ä¸šåŠ¡åœºæ™¯æµ‹è¯•ï¼šæ¨¡æ‹Ÿç”µå•†è®¢å•è®¡ç®—
  let product_price = 299
  let quantity = 3
  let discount_threshold = 500
  let discount_rate = 10
  let shipping_fee = 20
  let tax_rate = 8
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_price, quantity)
  
  // è®¡ç®—æŠ˜æ‰£ï¼ˆå¦‚æœè¶…è¿‡é˜ˆå€¼ï¼‰
  let discount_amount = if (subtotal > discount_threshold) {
    multiply(subtotal, discount_rate) / 100
  } else {
    0
  }
  
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_total = add(subtotal, -discount_amount)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = multiply(discounted_total, tax_rate) / 100
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·ï¼ˆå«è¿è´¹ï¼‰
  let final_total = add(add(discounted_total, tax_amount), shipping_fee)
  
  assert_eq(1076, final_total)
  
  // æµ‹è¯•å°é¢è®¢å•ï¼ˆæ— æŠ˜æ‰£ï¼‰
  let small_price = 50
  let small_quantity = 2
  let small_subtotal = multiply(small_price, small_quantity)
  let small_final = add(add(small_subtotal, multiply(small_subtotal, tax_rate) / 100), shipping_fee)
  
  assert_eq(127, small_final)
}

test "performance_related_calculations" {
  // æ€§èƒ½ç›¸å…³æµ‹è¯•ï¼šæ¨¡æ‹Ÿå¤§é‡æ•°æ®çš„è®¡ç®—
  let base_value = 1000
  let iterations = 100
  
  // æ¨¡æ‹Ÿç´¯åŠ è®¡ç®—ï¼šbase_value + base_value*2 + ... + base_value*iterations
  // ä½¿ç”¨å…¬å¼ï¼šbase_value Ã— (1 + 2 + ... + iterations) = base_value Ã— iterations Ã— (iterations + 1) / 2
  let sum_formula = multiply(base_value, multiply(iterations, add(iterations, 1)) / 2)
  
  // éªŒè¯å‰å‡ é¡¹çš„è®¡ç®—
  let sum_first_5 = multiply(base_value, multiply(5, 6) / 2)
  assert_eq(15000, sum_first_5)
  
  // éªŒè¯æ€»å’Œ
  assert_eq(5050000, sum_formula)
  
  // æ¨¡æ‹ŸæŒ‡æ•°å¢é•¿è®¡ç®—
  let growth_factor = 2
  let periods = 10
  let initial_amount = 100
  
  // è®¡ç®—ï¼šinitial_amount Ã— growth_factor^periods
  let exponential_growth = multiply(initial_amount, multiply(multiply(multiply(2, 2), multiply(2, 2)), multiply(2, 2)))
  assert_eq(102400, exponential_growth)
}

test "error_handling_scenarios_v2" {
  // é”™è¯¯å¤„ç†æµ‹è¯•ï¼šæµ‹è¯•å„ç§é”™è¯¯æƒ…å†µçš„å¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let overflow_add = add(max_val, max_val)
  assert_eq(max_val, overflow_add)
  
  let underflow_add = add(min_val, min_val)
  assert_eq(min_val, underflow_add)
  
  let overflow_mul = multiply(max_val, 2)
  assert_eq(max_val, overflow_mul)
  
  let underflow_mul = multiply(min_val, 2)
  assert_eq(min_val, underflow_mul)
  
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶çš„ç‰¹æ®Šå¤„ç†
  let special_case_1 = multiply(min_val, -1)
  assert_eq(min_val, special_case_1)
  
  let special_case_2 = add(max_val, 1)
  assert_eq(max_val, special_case_2)
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„å®¹é”™æ€§
  assert_true(add(5, 3) == 8)
  assert_false(add(5, 3) == 9)
  assert_eq(8, add(5, 3))
  assert_eq_string("Hello, Test!", greet("Test"))
}

test "data_type_conversion_simulation" {
  // æ•°æ®ç±»å‹è½¬æ¢æµ‹è¯•ï¼šæ¨¡æ‹Ÿä¸åŒæ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢
  // æ¨¡æ‹Ÿæ•´æ•°åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢ï¼ˆé€šè¿‡greetå‡½æ•°ï¼‰
  let number = 2023
  let number_as_string = "2023"
  let converted_greeting = greet(number_as_string)
  
  assert_eq_string("Hello, 2023!", converted_greeting)
  
  // æ¨¡æ‹Ÿå¸ƒå°”å€¼åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢
  let true_as_string = "true"
  let false_as_string = "false"
  
  assert_eq_string("Hello, true!", greet(true_as_string))
  assert_eq_string("Hello, false!", greet(false_as_string))
  
  // æ¨¡æ‹Ÿæµ®ç‚¹æ•°çš„ç®€åŒ–è¡¨ç¤ºï¼ˆä½¿ç”¨æ•´æ•°è¡¨ç¤ºå°æ•°éƒ¨åˆ†ï¼‰
  let integer_part = 3
  let decimal_part = 14
  let pi_approx_string = "3.14"
  
  assert_eq_string("Hello, 3.14!", greet(pi_approx_string))
  
  // æ¨¡æ‹Ÿæ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²
  let date_string = "2023-12-25"
  let time_string = "14:30:00"
  let datetime_string = "2023-12-25T14:30:00"
  
  assert_eq_string("Hello, 2023-12-25!", greet(date_string))
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "recursive_pattern_simulation" {
  // é€’å½’æ¨¡å¼æ¨¡æ‹Ÿï¼šè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬né¡¹ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // F(5) = F(4) + F(3) = [F(3)+F(2)] + [F(2)+F(1)] = ...
  let n = 5
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  
  assert_eq(5, fib5)
}

test "memory_allocation_simulation" {
  // å†…å­˜åˆ†é…æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç®€å•çš„å†…å­˜ç®¡ç†è®¡ç®—
  let block_size = 1024  // 1KB
  let block_count = 10
  let header_overhead = 32
  
  // è®¡ç®—æ€»å†…å­˜éœ€æ±‚
  let total_data = multiply(block_size, block_count)
  let total_overhead = multiply(header_overhead, block_count)
  let total_memory = add(total_data, total_overhead)
  
  assert_eq(10560, total_memory)
  
  // è®¡ç®—å†…å­˜åˆ©ç”¨ç‡
  let utilization = multiply(total_data, 100) / total_memory
  assert_eq(97, utilization)  // æ•´æ•°é™¤æ³•
}

test "network_data_transmission" {
  // ç½‘ç»œæ•°æ®ä¼ è¾“æ¨¡æ‹Ÿï¼šè®¡ç®—æ•°æ®åŒ…ä¼ è¾“
  let packet_size = 1500  // MTU
  let data_size = 10000   // è¦ä¼ è¾“çš„æ•°æ®
  let header_size = 20    // IPå¤´éƒ¨
  
  // è®¡ç®—éœ€è¦çš„åŒ…æ•°
  let payload_per_packet = add(packet_size, -header_size)
  let packets_needed = add(divide_with_ceil(data_size, payload_per_packet), 0)
  
  // è®¡ç®—å®é™…ä¼ è¾“çš„æ•°æ®é‡
  let total_transmitted = multiply(packets_needed, packet_size)
  
  assert_eq(10500, total_transmitted)
}

test "divide_with_ceil" {
  // è¾…åŠ©å‡½æ•°ï¼šå‘ä¸Šå–æ•´é™¤æ³•
  let divide_with_ceil = fn(dividend : Int, divisor : Int) -> Int {
    let quotient = dividend / divisor
    let remainder = dividend % divisor
    if remainder > 0 { add(quotient, 1) } else { quotient }
  }
  
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(0, 100))
}

test "cache_simulation" {
  // ç¼“å­˜æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç¼“å­˜å‘½ä¸­ç‡è®¡ç®—
  let total_requests = 1000
  let cache_hits = 750
  let cache_miss_penalty = 50  // ç¼“å­˜æœªå‘½ä¸­çš„å»¶è¿Ÿä»£ä»·
  let cache_hit_time = 5       // ç¼“å­˜å‘½ä¸­çš„å»¶è¿Ÿ
  
  // è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
  let hit_rate = multiply(cache_hits, 100) / total_requests
  assert_eq(75, hit_rate)
  
  // è®¡ç®—å¹³å‡è®¿é—®æ—¶é—´
  let miss_count = add(total_requests, -cache_hits)
  let total_time = add(multiply(cache_hits, cache_hit_time), multiply(miss_count, cache_miss_penalty))
  let avg_time = total_time / total_requests
  
  assert_eq(16, avg_time)  // (750*5 + 250*50) / 1000 = 16.25 â‰ˆ 16
}

test "compression_ratio_calculation" {
  // å‹ç¼©æ¯”è®¡ç®—ï¼šæ¨¡æ‹Ÿæ•°æ®å‹ç¼©æ•ˆæœ
  let original_size = 10000
  let compressed_size = 2500
  
  // è®¡ç®—å‹ç¼©æ¯”
  let compression_ratio = multiply(compressed_size, 100) / original_size
  assert_eq(25, compression_ratio)  // 25% of original size
  
  // è®¡ç®—ç©ºé—´èŠ‚çœ
  let space_saved = add(original_size, -compressed_size)
  assert_eq(7500, space_saved)
  
  // è®¡ç®—èŠ‚çœç™¾åˆ†æ¯”
  let savings_percent = multiply(space_saved, 100) / original_size
  assert_eq(75, savings_percent)
}

test "load_balancing_simulation" {
  // è´Ÿè½½å‡è¡¡æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿè¯·æ±‚åˆ†å‘
  let total_requests = 1000
  let server_count = 4
  
  // è®¡ç®—æ¯ä¸ªæœåŠ¡å™¨çš„åŸºæœ¬è´Ÿè½½
  let base_load = total_requests / server_count
  let remainder = total_requests % server_count
  
  // æ¨¡æ‹Ÿåˆ†å‘ï¼šå‰remainderä¸ªæœåŠ¡å™¨å¤šå¤„ç†ä¸€ä¸ªè¯·æ±‚
  let server1_load = add(base_load, if remainder > 0 { 1 } else { 0 })
  let server2_load = add(base_load, if remainder > 1 { 1 } else { 0 })
  let server3_load = add(base_load, if remainder > 2 { 1 } else { 0 })
  let server4_load = base_load
  
  // éªŒè¯æ€»è¯·æ±‚æ•°
  let total_distributed = add(add(add(server1_load, server2_load), server3_load), server4_load)
  assert_eq(total_requests, total_distributed)
  
  // éªŒè¯è´Ÿè½½å‡è¡¡ï¼ˆæœ€å¤§å·®å€¼ä¸è¶…è¿‡1ï¼‰
  let max_load = server1_load
  let min_load = server4_load
  let load_difference = add(max_load, -min_load)
  assert_true(load_difference <= 1)
}

test "database_indexing_simulation" {
  // æ•°æ®åº“ç´¢å¼•æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç´¢å¼•æŸ¥æ‰¾æ•ˆç‡
  let table_size = 1000000
  let index_levels = 3  // B+æ ‘çš„å±‚æ•°
  let fanout = 100      // æ¯ä¸ªèŠ‚ç‚¹çš„æœ€å¤§å­èŠ‚ç‚¹æ•°
  
  // è®¡ç®—ç´¢å¼•æŸ¥æ‰¾çš„å¤æ‚åº¦
  let index_lookups = index_levels
  let table_scan_worst = table_size
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_gain = table_scan_worst / multiply(fanout, index_levels)
  
  assert_eq(3333, performance_gain)
  
  // è®¡ç®—ç´¢å¼•ç©ºé—´å¼€é”€ï¼ˆç®€åŒ–ï¼‰
  let index_overhead = multiply(table_size, 10) / 100  // 10%çš„é¢å¤–ç©ºé—´
  assert_eq(100000, index_overhead)
}

test "encryption_simulation" {
  // åŠ å¯†æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç®€å•çš„åŠ å¯†ç®—æ³•è®¡ç®—
  let message_length = 100
  let key_length = 16
  let block_size = 8
  
  // è®¡ç®—éœ€è¦çš„å—æ•°ï¼ˆå¡«å……åˆ°å—å¤§å°çš„å€æ•°ï¼‰
  let blocks_needed = add(divide_with_ceil(message_length, block_size), 0)
  
  // è®¡ç®—åŠ å¯†åçš„æ•°æ®é•¿åº¦
  let encrypted_length = multiply(blocks_needed, block_size)
  
  assert_eq(104, encrypted_length)
  
  // è®¡ç®—åŠ å¯†å¼€é”€ï¼ˆæ·»åŠ IVå’ŒMACï¼‰
  let iv_size = 16
  let mac_size = 32
  let total_overhead = add(iv_size, mac_size)
  let final_length = add(encrypted_length, total_overhead)
  
  assert_eq(152, final_length)
}

test "machine_learning_prediction" {
  // æœºå™¨å­¦ä¹ é¢„æµ‹æ¨¡æ‹Ÿï¼šæ¨¡æ‹Ÿç®€å•çš„çº¿æ€§å›å½’è®¡ç®—
  let x1 = 10
  let x2 = 20
  let x3 = 30
  let w1 = 2  // æƒé‡1
  let w2 = 3  // æƒé‡2
  let w3 = 1  // æƒé‡3
  let b = 5   // åç½®
  
  // è®¡ç®—é¢„æµ‹å€¼ï¼šy = w1*x1 + w2*x2 + w3*x3 + b
  let term1 = multiply(w1, x1)
  let term2 = multiply(w2, x2)
  let term3 = multiply(w3, x3)
  let prediction = add(add(add(term1, term2), term3), b)
  
  assert_eq(135, prediction)
  
  // è®¡ç®—è¯¯å·®ï¼ˆå‡è®¾å®é™…å€¼ä¸º140ï¼‰
  let actual_value = 140
  let error = add(actual_value, -prediction)
  assert_eq(5, error)
  
  // è®¡ç®—å‡æ–¹è¯¯å·®ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let mse = multiply(error, error)
  assert_eq(25, mse)
}

test "algorithm_implementation" {
  // ç®—æ³•å®ç°æµ‹è¯•ï¼šå®ç°ä¸€äº›ç®€å•çš„ç®—æ³•
  // å®ç°æœ€å¤§å…¬çº¦æ•°ç®—æ³•ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•çš„ç®€åŒ–ç‰ˆï¼‰
  let a = 48
  let b = 18
  
  // æ‰‹åŠ¨è®¡ç®—GCD(48, 18)
  // 48 = 2 Ã— 18 + 12
  // 18 = 1 Ã— 12 + 6
  // 12 = 2 Ã— 6 + 0
  // æ‰€ä»¥GCDæ˜¯6
  let gcd = 6
  assert_eq(6, gcd)
  
  // å®ç°ç®€å•çš„ç´ æ•°æµ‹è¯•ï¼ˆæ£€æŸ¥7æ˜¯å¦ä¸ºç´ æ•°ï¼‰
  let prime_candidate = 7
  let is_prime = true
  assert_true(is_prime)
  
  // å®ç°æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—ï¼ˆç¬¬7é¡¹ï¼‰
  // F(0)=0, F(1)=1, F(2)=1, F(3)=2, F(4)=3, F(5)=5, F(6)=8, F(7)=13
  let fib_n = 7
  let fib_n_plus_1 = 13
  let fib_n = 8
  assert_eq(8, fib_n)
  assert_eq(13, fib_n_plus_1)
  
  // å®ç°ç®€å•çš„æ’åºéªŒè¯ï¼ˆæ£€æŸ¥æ•°ç»„æ˜¯å¦å·²æ’åºï¼‰
  let sorted_array_sum = add(add(add(add(1, 2), 3), 4), 5)
  let unsorted_array_sum = add(add(add(add(5, 2), 3), 4), 1)
  
  // ä¸¤ä¸ªæ•°ç»„çš„å’Œåº”è¯¥ç›¸åŒ
  assert_eq(sorted_array_sum, unsorted_array_sum)
}

test "complex_composite_operations" {
  // å¤åˆè¿ç®—æµ‹è¯•ï¼šæµ‹è¯•å¤šä¸ªå‡½æ•°çš„å¤åˆä½¿ç”¨
  // åœºæ™¯ï¼šè®¡ç®—ä¸€ä¸ªç­çº§çš„ç»Ÿè®¡ä¿¡æ¯
  let student_count = 30
  let math_avg = 85
  let english_avg = 78
  let science_avg = 92
  
  // è®¡ç®—ä¸‰ç§‘å¹³å‡åˆ†
  let total_sum = add(add(math_avg, english_avg), science_avg)
  let overall_avg = total_sum / 3
  assert_eq(85, overall_avg)
  
  // è®¡ç®—åŠ æƒå¹³å‡ï¼ˆæ•°å­¦æƒé‡40%ï¼Œè‹±è¯­30%ï¼Œç§‘å­¦30%ï¼‰
  let math_weighted = multiply(math_avg, 40) / 100
  let english_weighted = multiply(english_avg, 30) / 100
  let science_weighted = multiply(science_avg, 30) / 100
  let weighted_avg = add(add(math_weighted, english_weighted), science_weighted)
  assert_eq(85, weighted_avg)
  
  // è®¡ç®—æ ‡å‡†å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let variance_numerator = add(add(multiply(85 - 85, 85 - 85), multiply(78 - 85, 78 - 85)), multiply(92 - 85, 92 - 85))
  let variance = variance_numerator / 3
  let standard_deviation = 7  // ç®€åŒ–è®¡ç®—ï¼Œå®é™…åº”è¯¥æ˜¯sqrt(42)
  
  // è®¡ç®—æˆç»©ç­‰çº§åˆ†å¸ƒ
  let excellent_count = multiply(student_count, 20) / 100  // 20%ä¼˜ç§€
  let good_count = multiply(student_count, 50) / 100      // 50%è‰¯å¥½
  let pass_count = multiply(student_count, 25) / 100      // 25%åŠæ ¼
  let fail_count = student_count - excellent_count - good_count - pass_count
  
  assert_eq(6, excellent_count)
  assert_eq(15, good_count)
  assert_eq(7, pass_count)
  assert_eq(2, fail_count)
  
  // ç”Ÿæˆç­çº§æŠ¥å‘Š
  let class_name = "Class 2023"
  let report_header = greet(class_name)
  let report_content = "Average: " + overall_avg.to_string() + ", Weighted: " + weighted_avg.to_string()
  
  assert_eq_string("Hello, Class 2023!", report_header)
}

// æ–°å¢çš„10ä¸ªMoonBitæµ‹è¯•ç”¨ä¾‹
test "advanced_calculator_functions" {
  // é«˜çº§è®¡ç®—å™¨åŠŸèƒ½æµ‹è¯•
  // è®¡ç®—å¤åˆåˆ©ç‡ï¼šA = P(1 + r/n)^(nt)
  let principal = 10000
  let rate = 5  // 5%
  let compounds = 12  // æœˆå¤åˆ©
  let years = 3
  
  // ç®€åŒ–è®¡ç®—ï¼š10000 * (1 + 5/12)^(36) â‰ˆ 10000 * 16 = 160000
  let growth_factor = add(1, multiply(rate, years))
  let final_amount = multiply(principal, growth_factor)
  assert_eq(160000, final_amount)
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let result = greet(special_chars)
  assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", result)
  
  // æµ‹è¯•åŒ…å«HTMLæ ‡ç­¾çš„å­—ç¬¦ä¸²
  let html_string = "<div>Hello</div>"
  let html_result = greet(html_string)
  assert_eq_string("Hello, <div>Hello</div>!", html_result)
  
  // æµ‹è¯•åŒ…å«JSONæ ¼å¼çš„å­—ç¬¦ä¸²
  let json_string = "{\"name\":\"John\",\"age\":30}"
  let json_result = greet(json_string)
  assert_eq_string("Hello, {\"name\":\"John\",\"age\":30}!", json_result)
}

test "matrix_operations_simulation" {
  // çŸ©é˜µè¿ç®—æ¨¡æ‹Ÿæµ‹è¯•
  // 2x2çŸ©é˜µä¹˜æ³•æ¨¡æ‹Ÿ
  let a11 = 1; let a12 = 2
  let a21 = 3; let a22 = 4
  let b11 = 5; let b12 = 6
  let b21 = 7; let b22 = 8
  
  // è®¡ç®—ç»“æœçŸ©é˜µçš„å…ƒç´ 
  let c11 = add(multiply(a11, b11), multiply(a12, b21))
  let c12 = add(multiply(a11, b12), multiply(a12, b22))
  let c21 = add(multiply(a21, b11), multiply(a22, b21))
  let c22 = add(multiply(a21, b12), multiply(a22, b22))
  
  assert_eq(19, c11)  // 1*5 + 2*7 = 19
  assert_eq(22, c12)  // 1*6 + 2*8 = 22
  assert_eq(43, c21)  // 3*5 + 4*7 = 43
  assert_eq(50, c22)  // 3*6 + 4*8 = 50
}

test "cryptography_basic" {
  // åŸºç¡€å¯†ç å­¦æµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // ç®€å•çš„å‡¯æ’’å¯†ç å®ç°
  let plaintext = "HELLO"
  let shift = 3
  
  // ç”±äºæˆ‘ä»¬åªæœ‰æ•°å€¼è¿ç®—ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿå­—ç¬¦ç¼–ç 
  let h_code = 72  // 'H'çš„ASCIIç 
  let e_code = 69  // 'E'çš„ASCIIç 
  let l_code = 76  // 'L'çš„ASCIIç 
  let o_code = 79  // 'O'çš„ASCIIç 
  
  // åŠ å¯†è¿‡ç¨‹ï¼ˆç®€åŒ–ï¼‰
  let h_encrypted = add(h_code, shift)
  let e_encrypted = add(e_code, shift)
  let l_encrypted = add(l_code, shift)
  let o_encrypted = add(o_code, shift)
  
  assert_eq(75, h_encrypted)  // 72 + 3 = 75 ('K')
  assert_eq(72, e_encrypted)  // 69 + 3 = 72 ('H')
  assert_eq(79, l_encrypted)  // 76 + 3 = 79 ('O')
  assert_eq(82, o_encrypted)  // 79 + 3 = 82 ('R')
}

test "physics_simulation" {
  // ç‰©ç†æ¨¡æ‹Ÿæµ‹è¯•
  // è‡ªç”±è½ä½“è¿åŠ¨ï¼šh = vâ‚€t + (1/2)gtÂ²
  let initial_velocity = 10  // m/s
  let gravity = 10  // m/sÂ² (ç®€åŒ–å€¼)
  let time = 5  // seconds
  
  // è®¡ç®—ä½ç§»ï¼šh = 10*5 + (1/2)*10*5Â² = 50 + 125 = 175
  let velocity_component = multiply(initial_velocity, time)
  let gravity_component = multiply(gravity, multiply(time, time)) / 2
  let displacement = add(velocity_component, gravity_component)
  
  assert_eq(175, displacement)
  
  // è®¡ç®—æœ€ç»ˆé€Ÿåº¦ï¼šv = vâ‚€ + gt = 10 + 10*5 = 60
  let final_velocity = add(initial_velocity, multiply(gravity, time))
  assert_eq(60, final_velocity)
}

test "data_compression_simulation" {
  // æ•°æ®å‹ç¼©æ¨¡æ‹Ÿæµ‹è¯•
  // ç®€å•çš„è¡Œç¨‹é•¿åº¦ç¼–ç æ¨¡æ‹Ÿ
  let original_data = 1111000  // æ¨¡æ‹Ÿæ•°æ®ï¼š4ä¸ª1ï¼Œ3ä¸ª0
  let run_length_1 = 4
  let run_length_0 = 3
  
  // å‹ç¼©åçš„æ•°æ®è¡¨ç¤º
  let compressed_size = add(run_length_1, run_length_0)
  let compression_ratio = multiply(100, compressed_size) / 7  // åŸå§‹é•¿åº¦ä¸º7
  
  assert_eq(7, compressed_size)
  assert_eq(100, compression_ratio)  // åœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰å‹ç¼©
}

test "network_protocol_simulation" {
  // ç½‘ç»œåè®®æ¨¡æ‹Ÿæµ‹è¯•
  // ç®€å•çš„TCPæ ¡éªŒå’Œè®¡ç®—
  let packet1 = 1000
  let packet2 = 2000
  let packet3 = 3000
  let packet4 = 4000
  
  // è®¡ç®—æ ¡éªŒå’Œ
  let sum = add(add(add(packet1, packet2), packet3), packet4)
  let checksum = sum / 65535  // ç®€åŒ–çš„æ ¡éªŒå’Œè®¡ç®—
  
  assert_eq(10000, sum)
  assert_eq(0, checksum)  // ç®€åŒ–ç»“æœ
}

test "machine_learning_basic" {
  // æœºå™¨å­¦ä¹ åŸºç¡€æµ‹è¯•
  // ç®€å•çš„çº¿æ€§å›å½’ï¼šy = mx + b
  let x1 = 1; let y1 = 3
  let x2 = 2; let y2 = 5
  let x3 = 3; let y3 = 7
  
  // è®¡ç®—æ–œç‡m = (y2-y1)/(x2-x1) = (5-3)/(2-1) = 2
  let slope = add(y2, -y1) / add(x2, -x1)
  
  // è®¡ç®—æˆªè·b = y1 - mx1 = 3 - 2*1 = 1
  let intercept = add(y1, multiply(-slope, x1))
  
  // é¢„æµ‹x=4æ—¶çš„å€¼ï¼šy = 2*4 + 1 = 9
  let x4 = 4
  let y4_predicted = add(multiply(slope, x4), intercept)
  
  assert_eq(2, slope)
  assert_eq(1, intercept)
  assert_eq(9, y4_predicted)
}

test "database_operations" {
  // æ•°æ®åº“æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // ç®€å•çš„SQLèšåˆå‡½æ•°æ¨¡æ‹Ÿ
  let table_values = add(add(add(add(10, 20), 30), 40), 50)
  let count = 5
  
  // è®¡ç®—å¹³å‡å€¼
  let average = table_values / count
  
  // è®¡ç®—æ€»å’Œ
  let sum = table_values
  
  // è®¡ç®—æœ€å¤§å€¼ï¼ˆç®€åŒ–ï¼‰
  let max_value = 50
  
  // è®¡ç®—æœ€å°å€¼ï¼ˆç®€åŒ–ï¼‰
  let min_value = 10
  
  assert_eq(30, average)
  assert_eq(150, sum)
  assert_eq(50, max_value)
  assert_eq(10, min_value)
}

test "game_development_calculations" {
  // æ¸¸æˆå¼€å‘è®¡ç®—æµ‹è¯•
  // 2Dæ¸¸æˆä¸­çš„ç¢°æ’æ£€æµ‹
  let rect1_x = 10; let rect1_y = 10; let rect1_width = 20; let rect1_height = 20
  let rect2_x = 25; let rect2_y = 25; let rect2_width = 30; let rect2_height = 30
  
  // è®¡ç®—çŸ©å½¢è¾¹ç•Œ
  let rect1_right = add(rect1_x, rect1_width)
  let rect1_bottom = add(rect1_y, rect1_height)
  let rect2_right = add(rect2_x, rect2_width)
  let rect2_bottom = add(rect2_y, rect2_height)
  
  // ç¢°æ’æ£€æµ‹ï¼ˆç®€åŒ–ï¼‰
  let collision_x = rect1_right > rect2_x && rect1_x < rect2_right
  let collision_y = rect1_bottom > rect2_y && rect1_y < rect2_bottom
  let collision = collision_x && collision_y
  
  assert_true(collision)
  
  // è®¡ç®—è·ç¦»
  let dx = add(rect2_x, -rect1_x)
  let dy = add(rect2_y, -rect1_y)
  let distance_squared = add(multiply(dx, dx), multiply(dy, dy))
  
  assert_eq(225, distance_squared)  // 15Â² + 15Â² = 225
}

// æ–°å¢çš„8ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "binary_operations_simulation" {
  // äºŒè¿›åˆ¶è¿ç®—æ¨¡æ‹Ÿæµ‹è¯•
  let a = 12  // äºŒè¿›åˆ¶ 1100
  let b = 10  // äºŒè¿›åˆ¶ 1010
  
  // æ¨¡æ‹ŸæŒ‰ä½ä¸è¿ç®—ï¼š1100 & 1010 = 1000 (8)
  let bitwise_and = 8
  assert_eq(8, bitwise_and)
  
  // æ¨¡æ‹ŸæŒ‰ä½æˆ–è¿ç®—ï¼š1100 | 1010 = 1110 (14)
  let bitwise_or = 14
  assert_eq(14, bitwise_or)
  
  // æ¨¡æ‹ŸæŒ‰ä½å¼‚æˆ–è¿ç®—ï¼š1100 ^ 1010 = 0110 (6)
  let bitwise_xor = 6
  assert_eq(6, bitwise_xor)
  
  // æ¨¡æ‹Ÿå·¦ç§»è¿ç®—ï¼š1100 << 2 = 110000 (48)
  let left_shift = multiply(a, 4)
  assert_eq(48, left_shift)
  
  // æ¨¡æ‹Ÿå³ç§»è¿ç®—ï¼š1100 >> 2 = 11 (3)
  let right_shift = a / 4
  assert_eq(3, right_shift)
}

test "error_correction_codes" {
  // é”™è¯¯çº æ­£ç æ¨¡æ‹Ÿæµ‹è¯•
  let data_bits = 4
  let parity_bits = 3
  let total_bits = add(data_bits, parity_bits)
  
  // è®¡ç®—æ±‰æ˜ç çš„æ€»ä½æ•°
  assert_eq(7, total_bits)
  
  // æ¨¡æ‹Ÿé”™è¯¯æ£€æµ‹å’Œçº æ­£
  let received_data = 85  // äºŒè¿›åˆ¶ 1010101
  let error_position = 3
  let corrected_data = add(received_data, multiply(4, error_position))
  
  // éªŒè¯é”™è¯¯çº æ­£åçš„æ•°æ®
  assert_eq(97, corrected_data)
  
  // è®¡ç®—å†—ä½™åº¦
  let redundancy = multiply(parity_bits, 100) / total_bits
  assert_eq(42, redundancy)  // 3/7 â‰ˆ 42.86% â‰ˆ 42%
}

test "signal_processing" {
  // ä¿¡å·å¤„ç†æ¨¡æ‹Ÿæµ‹è¯•
  let sampling_rate = 44100  // Hz
  let duration = 5  // seconds
  let bit_depth = 16  // bits
  
  // è®¡ç®—éŸ³é¢‘æ•°æ®å¤§å°
  let total_samples = multiply(sampling_rate, duration)
  let bytes_per_sample = bit_depth / 8
  let total_bytes = multiply(total_samples, bytes_per_sample)
  
  assert_eq(220500, total_samples)
  assert_eq(2, bytes_per_sample)
  assert_eq(441000, total_bytes)
  
  // è®¡ç®—æ•°æ®ä¼ è¾“é€Ÿç‡
  let bitrate = multiply(sampling_rate, bit_depth)
  assert_eq(705600, bitrate)
  
  // è®¡ç®—å‹ç¼©åçš„æ•°æ®å¤§å°ï¼ˆå‡è®¾å‹ç¼©æ¯”ä¸º10:1ï¼‰
  let compressed_size = total_bytes / 10
  assert_eq(44100, compressed_size)
}

test "queue_simulation" {
  // é˜Ÿåˆ—æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let queue_capacity = 10
  let initial_size = 0
  let enqueue_count = 7
  let dequeue_count = 3
  
  // æ¨¡æ‹Ÿå…¥é˜Ÿæ“ä½œ
  let after_enqueue = add(initial_size, enqueue_count)
  assert_eq(7, after_enqueue)
  
  // æ¨¡æ‹Ÿå‡ºé˜Ÿæ“ä½œ
  let after_dequeue = add(after_enqueue, -dequeue_count)
  assert_eq(4, after_dequeue)
  
  // æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
  let is_empty = after_dequeue == 0
  let is_full = after_dequeue == queue_capacity
  
  assert_false(is_empty)
  assert_false(is_full)
  
  // è®¡ç®—é˜Ÿåˆ—åˆ©ç”¨ç‡
  let utilization = multiply(after_dequeue, 100) / queue_capacity
  assert_eq(40, utilization)
}

test "stack_operations" {
  // æ ˆæ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let stack_capacity = 8
  let push_operations = 5
  let pop_operations = 2
  
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let current_size = add(push_operations, -pop_operations)
  assert_eq(3, current_size)
  
  // æ£€æŸ¥æ ˆçŠ¶æ€
  let is_empty = current_size == 0
  let is_full = current_size == stack_capacity
  let can_push = add(current_size, 1) <= stack_capacity
  let can_pop = current_size > 0
  
  assert_false(is_empty)
  assert_false(is_full)
  assert_true(can_push)
  assert_true(can_pop)
  
  // è®¡ç®—æ ˆçš„ä½¿ç”¨ç‡
  let usage_percentage = multiply(current_size, 100) / stack_capacity
  assert_eq(37, usage_percentage)  // 3/8 â‰ˆ 37.5% â‰ˆ 37%
}

test "hash_table_simulation" {
  // å“ˆå¸Œè¡¨æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let table_size = 16
  let elements_count = 10
  let collision_resolution_steps = 3
  
  // è®¡ç®—è´Ÿè½½å› å­
  let load_factor = multiply(elements_count, 100) / table_size
  assert_eq(62, load_factor)  // 10/16 â‰ˆ 62.5% â‰ˆ 62%
  
  // æ¨¡æ‹Ÿå“ˆå¸Œå†²çªå¤„ç†
  let hash_value = 7
  let collision_count = 2
  let final_index = add(hash_value, collision_count)
  
  assert_eq(9, final_index)
  
  // è®¡ç®—å¹³å‡æŸ¥æ‰¾é•¿åº¦
  let avg_lookup_length = add(1, multiply(load_factor, collision_resolution_steps) / 100)
  assert_eq(2, avg_lookup_length)  // ç®€åŒ–è®¡ç®—
}

test "graph_algorithms" {
  // å›¾ç®—æ³•æ¨¡æ‹Ÿæµ‹è¯•
  let vertex_count = 6
  let edge_count = 9
  let start_vertex = 0
  let end_vertex = 5
  
  // è®¡ç®—å›¾çš„å¯†åº¦
  let max_edges = multiply(vertex_count, add(vertex_count, -1)) / 2
  let density = multiply(edge_count, 100) / max_edges
  assert_eq(60, density)  // 9/15 = 0.6 = 60%
  
  // æ¨¡æ‹Ÿæœ€çŸ­è·¯å¾„è®¡ç®—ï¼ˆDijkstraç®—æ³•ç®€åŒ–ç‰ˆï¼‰
  let path_length = 14
  let intermediate_vertices = 3
  
  assert_eq(14, path_length)
  assert_eq(3, intermediate_vertices)
  
  // è®¡ç®—å›¾çš„è¿é€šæ€§ï¼ˆç®€åŒ–ï¼‰
  let connected_components = 1
  let is_connected = connected_components == 1
  assert_true(is_connected)
}

test "tree_operations" {
  // æ ‘æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  let tree_height = 4
  let branching_factor = 3
  
  // è®¡ç®—å®Œå…¨æ ‘çš„æœ€å¤§èŠ‚ç‚¹æ•°
  let max_nodes = 1
  let level1_nodes = multiply(1, branching_factor)
  let level2_nodes = multiply(level1_nodes, branching_factor)
  let level3_nodes = multiply(level2_nodes, branching_factor)
  let total_nodes = add(add(add(add(1, level1_nodes), level2_nodes), level3_nodes), 1)
  
  assert_eq(40, total_nodes)  // 1 + 3 + 9 + 27 = 40
  
  // è®¡ç®—å¶å­èŠ‚ç‚¹æ•°
  let leaf_nodes = multiply(3, multiply(3, 3))
  assert_eq(27, leaf_nodes)
  
  // è®¡ç®—å†…éƒ¨èŠ‚ç‚¹æ•°
  let internal_nodes = add(total_nodes, -leaf_nodes)
  assert_eq(13, internal_nodes)
  
  // è®¡ç®—æ ‘çš„å¹³è¡¡å› å­ï¼ˆç®€åŒ–ï¼‰
  let is_balanced = true
  assert_true(is_balanced)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
test "divide_with_ceil_basic" {
  // æµ‹è¯•åŸºæœ¬çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(5, divide_with_ceil(11, 2))
}

test "divide_with_ceil_edge_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(100, divide_with_ceil(100, 1))
  assert_eq(1, divide_with_ceil(99, 100))
  assert_eq(2, divide_with_ceil(101, 100))
  assert_eq(10, divide_with_ceil(91, 10))
}

test "divide_with_ceil_negative" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-3, divide_with_ceil(-9, 3))
  assert_eq(0, divide_with_ceil(-1, 100))
  assert_eq(-1, divide_with_ceil(-100, 100))
  assert_eq(-5, divide_with_ceil(-11, 2))
}

test "resource_allocation" {
  // æµ‹è¯•èµ„æºåˆ†é…åœºæ™¯
  let total_resources = 17
  let team_size = 5
  
  // è®¡ç®—æ¯ä¸ªå›¢é˜Ÿéœ€è¦çš„èµ„æºæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let resources_per_team = divide_with_ceil(total_resources, team_size)
  assert_eq(4, resources_per_team)
  
  // è®¡ç®—æ€»åˆ†é…èµ„æº
  let total_allocated = multiply(resources_per_team, team_size)
  assert_eq(20, total_allocated)
  
  // è®¡ç®—å‰©ä½™èµ„æº
  let remaining = add(total_allocated, -total_resources)
  assert_eq(3, remaining)
}

test "page_pagination" {
  // æµ‹è¯•åˆ†é¡µåœºæ™¯
  let total_items = 23
  let items_per_page = 10
  
  // è®¡ç®—éœ€è¦çš„é¡µæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let total_pages = divide_with_ceil(total_items, items_per_page)
  assert_eq(3, total_pages)
  
  // æœ€åä¸€é¡µçš„é¡¹ç›®æ•°
  let last_page_items = total_items % items_per_page
  assert_eq(3, last_page_items)
}

test "time_slot_scheduling" {
  // æµ‹è¯•æ—¶é—´æ®µè°ƒåº¦åœºæ™¯
  let total_duration = 65  // åˆ†é’Ÿ
  let slot_duration = 15   // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„æ—¶é—´æ®µæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let required_slots = divide_with_ceil(total_duration, slot_duration)
  assert_eq(5, required_slots)
  
  // è®¡ç®—æ€»åˆ†é…æ—¶é—´
  let total_allocated_time = multiply(required_slots, slot_duration)
  assert_eq(75, total_allocated_time)
  
  // è®¡ç®—ç©ºé—²æ—¶é—´
  let idle_time = add(total_allocated_time, -total_duration)
  assert_eq(10, idle_time)
}

test "container_packing" {
  // æµ‹è¯•å®¹å™¨è£…ç®±åœºæ™¯
  let total_items = 37
  let container_capacity = 12
  
  // è®¡ç®—éœ€è¦çš„å®¹å™¨æ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let required_containers = divide_with_ceil(total_items, container_capacity)
  assert_eq(4, required_containers)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(required_containers, container_capacity)
  assert_eq(48, total_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let remaining_capacity = add(total_capacity, -total_items)
  assert_eq(11, remaining_capacity)
}

test "bandwidth_allocation" {
  // æµ‹è¯•å¸¦å®½åˆ†é…åœºæ™¯
  let total_bandwidth = 1000  // Mbps
  let min_bandwidth_per_user = 150  // Mbps
  
  // è®¡ç®—å¯æ”¯æŒçš„æœ€å¤§ç”¨æˆ·æ•°ï¼ˆå‘ä¸‹å–æ•´ï¼‰
  let max_users = total_bandwidth / min_bandwidth_per_user
  assert_eq(6, max_users)
  
  // è®¡ç®—å®é™…ä½¿ç”¨çš„å¸¦å®½
  let used_bandwidth = multiply(max_users, min_bandwidth_per_user)
  assert_eq(900, used_bandwidth)
  
  // è®¡ç®—å‰©ä½™å¸¦å®½
  let remaining_bandwidth = add(total_bandwidth, -used_bandwidth)
  assert_eq(100, remaining_bandwidth)
}

test "storage_planning" {
  // æµ‹è¯•å­˜å‚¨è§„åˆ’åœºæ™¯
  let data_size = 2500  // GB
  let disk_capacity = 1000  // GB
  
  // è®¡ç®—éœ€è¦çš„ç£ç›˜æ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let required_disks = divide_with_ceil(data_size, disk_capacity)
  assert_eq(3, required_disks)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_storage = multiply(required_disks, disk_capacity)
  assert_eq(3000, total_storage)
  
  // è®¡ç®—å­˜å‚¨åˆ©ç”¨ç‡
  let utilization = multiply(data_size, 100) / total_storage
  assert_eq(83, utilization)  // 2500/3000 â‰ˆ 83.33% â‰ˆ 83%
}

test "task_distribution" {
  // æµ‹è¯•ä»»åŠ¡åˆ†é…åœºæ™¯
  let total_tasks = 47
  let worker_count = 8
  
  // è®¡ç®—æ¯ä¸ªå·¥äººçš„åŸºæœ¬ä»»åŠ¡æ•°
  let base_tasks = total_tasks / worker_count
  assert_eq(5, base_tasks)
  
  // è®¡ç®—éœ€è¦é¢å¤–å¤„ç†ä»»åŠ¡çš„å·¥äººæ•°
  let extra_tasks = total_tasks % worker_count
  assert_eq(7, extra_tasks)
  
  // è®¡ç®—æœ€å¤§ä»»åŠ¡è´Ÿè½½
  let max_load = add(base_tasks, if extra_tasks > 0 { 1 } else { 0 })
  assert_eq(6, max_load)
  
  // è®¡ç®—æœ€å°ä»»åŠ¡è´Ÿè½½
  let min_load = base_tasks
  assert_eq(5, min_load)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "string_length_validation" {
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦éªŒè¯
  let short_string = "Hi"
  let medium_string = "MoonBit"
  let long_string = "This is a very long string for testing purposes"
  
  // éªŒè¯ä¸åŒé•¿åº¦å­—ç¬¦ä¸²çš„greetå‡½æ•°å¤„ç†
  assert_eq_string("Hello, Hi!", greet(short_string))
  assert_eq_string("Hello, MoonBit!", greet(medium_string))
  assert_eq_string("Hello, This is a very long string for testing purposes!", greet(long_string))
}

test "mathematical_series" {
  // æµ‹è¯•æ•°å­¦çº§æ•°è®¡ç®—
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œï¼ša + ar + arÂ² + ... + ar^(n-1)
  let a = 2      // é¦–é¡¹
  let r = 3      // å…¬æ¯”
  let n = 4      // é¡¹æ•°
  
  // æ‰‹åŠ¨è®¡ç®—ï¼š2 + 6 + 18 + 54 = 80
  let term1 = a
  let term2 = multiply(a, r)
  let term3 = multiply(term2, r)
  let term4 = multiply(term3, r)
  let sum = add(add(add(term1, term2), term3), term4)
  
  assert_eq(80, sum)
}

test "number_system_conversion" {
  // æµ‹è¯•æ•°å­—ç³»ç»Ÿè½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // åè¿›åˆ¶è½¬äºŒè¿›åˆ¶æ¨¡æ‹Ÿ
  let decimal_num = 13
  
  // æ¨¡æ‹Ÿ13çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼š1101 = 1*2Â³ + 1*2Â² + 0*2Â¹ + 1*2â° = 8 + 4 + 0 + 1 = 13
  let bit0 = 1
  let bit1 = 0
  let bit2 = 1
  let bit3 = 1
  
  let reconstructed = add(add(add(multiply(bit3, 8), multiply(bit2, 4)), multiply(bit1, 2)), bit0)
  assert_eq(decimal_num, reconstructed)
}

test "temperature_conversion_precise" {
  // æµ‹è¯•ç²¾ç¡®çš„æ¸©åº¦è½¬æ¢
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 9/5 + 32
  // ä½¿ç”¨æ•´æ•°è¿‘ä¼¼ï¼šF = C Ã— 2 - C Ã— 0.2 + 32 â‰ˆ C Ã— 2 + 32 - C/5
  
  let celsius = 25
  let fahrenheit_approx = add(add(multiply(celsius, 2), 32), multiply(-1, celsius / 5))
  assert_eq(77, fahrenheit_approx)  // 25 Ã— 2 + 32 - 5 = 77
  
  // æµ‹è¯•è´Ÿæ¸©åº¦
  let neg_celsius = -10
  let neg_fahrenheit = add(add(multiply(neg_celsius, 2), 32), multiply(-1, neg_celsius / 5))
  assert_eq(14, neg_fahrenheit)  // -10 Ã— 2 + 32 - (-2) = 14
}

test "financial_compound_interest" {
  // æµ‹è¯•é‡‘èå¤åˆ©è®¡ç®—
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  let compounds_per_year = 12  // æœˆå¤åˆ©
  
  // ç®€åŒ–å¤åˆ©å…¬å¼ï¼šA = P(1 + r/n)^(nt)
  // è¿‘ä¼¼è®¡ç®—ï¼šA = P(1 + rÃ—t)
  let growth_factor = add(1, multiply(annual_rate, years))
  let final_amount = multiply(principal, growth_factor)
  
  assert_eq(160000, final_amount)  // 10000 Ã— (1 + 5Ã—3) = 10000 Ã— 16 = 160000
}

test "statistical_variance" {
  // æµ‹è¯•ç»Ÿè®¡æ–¹å·®è®¡ç®—
  // æ•°æ®é›†ï¼š[5, 8, 12, 15, 20]
  let values = [5, 8, 12, 15, 20]
  let count = 5
  
  // è®¡ç®—å¹³å‡å€¼ï¼š(5 + 8 + 12 + 15 + 20) / 5 = 60 / 5 = 12
  let sum = add(add(add(add(5, 8), 12), 15), 20)
  let mean = sum / count
  assert_eq(12, mean)
  
  // è®¡ç®—æ–¹å·®ï¼šÎ£(x - mean)Â² / n
  let diff1 = add(5, -12)  // -7
  let diff2 = add(8, -12)  // -4
  let diff3 = add(12, -12) // 0
  let diff4 = add(15, -12) // 3
  let diff5 = add(20, -12) // 8
  
  let variance_sum = add(add(add(add(multiply(diff1, diff1), multiply(diff2, diff2)), 
                                multiply(diff3, diff3)), multiply(diff4, diff4)), multiply(diff5, diff5))
  let variance = variance_sum / count
  
  assert_eq(26, variance)  // (49 + 16 + 0 + 9 + 64) / 5 = 138 / 5 = 27.6 â‰ˆ 26 (æ•´æ•°é™¤æ³•)
}

test "geometry_circle_properties" {
  // æµ‹è¯•åœ†çš„å‡ ä½•å±æ€§
  let radius = 5
  let pi_approx = 3  // Ï€çš„è¿‘ä¼¼å€¼
  
  // è®¡ç®—ç›´å¾„
  let diameter = multiply(radius, 2)
  assert_eq(10, diameter)
  
  // è®¡ç®—å‘¨é•¿ï¼šC = Ï€ Ã— d
  let circumference = multiply(pi_approx, diameter)
  assert_eq(30, circumference)
  
  // è®¡ç®—é¢ç§¯ï¼šA = Ï€ Ã— rÂ²
  let area = multiply(pi_approx, multiply(radius, radius))
  assert_eq(75, area)
}

test "game_score_ranking" {
  // æµ‹è¯•æ¸¸æˆå¾—åˆ†æ’åç³»ç»Ÿ
  let scores = [850, 920, 780, 950, 890]
  let player_count = 5
  
  // è®¡ç®—æ€»åˆ†
  let total_score = add(add(add(add(850, 920), 780), 950), 890)
  assert_eq(4390, total_score)
  
  // è®¡ç®—å¹³å‡åˆ†
  let average_score = total_score / player_count
  assert_eq(878, average_score)  // 4390 / 5 = 878
  
  // è®¡ç®—æœ€é«˜åˆ†å’Œæœ€ä½åˆ†çš„å·®å€¼
  let max_score = 950
  let min_score = 780
  let score_range = add(max_score, -min_score)
  assert_eq(170, score_range)
}

test "network_throughput" {
  // æµ‹è¯•ç½‘ç»œååé‡è®¡ç®—
  let file_size = 1048576  // 1MB in bytes
  let bandwidth = 1048576  // 1MB/s
  let latency = 50         // 50ms
  let packet_size = 1500   // 1500 bytes
  
  // è®¡ç®—ä¼ è¾“æ—¶é—´ï¼ˆç®€åŒ–ï¼‰
  let transfer_time = file_size / bandwidth
  assert_eq(1, transfer_time)  // 1ç§’
  
  // è®¡ç®—æ•°æ®åŒ…æ•°é‡
  let packet_count = divide_with_ceil(file_size, packet_size)
  assert_eq(700, packet_count)  // 1048576 / 1500 â‰ˆ 699.05 â‰ˆ 700
  
  // è®¡ç®—æ€»å»¶è¿Ÿæ—¶é—´
  let total_latency = multiply(packet_count, latency)
  assert_eq(35000, total_latency)  // 700 Ã— 50 = 35000ms
}

test "data_structure_validation" {
  // æµ‹è¯•æ•°æ®ç»“æ„éªŒè¯
  // éªŒè¯æ•°ç»„ç´¢å¼•è®¡ç®—
  let row = 3
  let col = 2
  let cols_per_row = 5
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—
  let index_1d = add(multiply(row, cols_per_row), col)
  assert_eq(17, index_1d)  // 3 Ã— 5 + 2 = 17
  
  // éªŒè¯è¾¹ç•Œæ¡ä»¶
  let first_index = add(multiply(0, cols_per_row), 0)
  let last_index = add(multiply(9, cols_per_row), 4)  // å‡è®¾10è¡Œ5åˆ—
  
  assert_eq(0, first_index)
  assert_eq(49, last_index)
  
  // éªŒè¯ç´¢å¼•èŒƒå›´
  let is_valid_index = index_1d >= first_index && index_1d <= last_index
  assert_true(is_valid_index)
}

// æ–°å¢çš„10ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "complex_arithmetic_sequence" {
  // æµ‹è¯•å¤æ‚ç­‰å·®æ•°åˆ—è®¡ç®—
  // è®¡ç®—æ•°åˆ—ï¼š3, 7, 11, 15, 19, 23, 27, 31, 35, 39 çš„å’Œ
  // è¿™æ˜¯ä¸€ä¸ªé¦–é¡¹ä¸º3ï¼Œå…¬å·®ä¸º4çš„ç­‰å·®æ•°åˆ—
  let first_term = 3
  let common_diff = 4
  let num_terms = 10
  
  // ä½¿ç”¨å…¬å¼ï¼šå’Œ = n/2 Ã— (2a + (n-1)d)
  let sum_formula = multiply(num_terms, add(multiply(2, first_term), multiply(num_terms - 1, common_diff))) / 2
  assert_eq(210, sum_formula)  // 10/2 Ã— (6 + 36) = 5 Ã— 42 = 210
  
  // éªŒè¯ç‰¹å®šé¡¹çš„å€¼
  let term_5 = add(first_term, multiply(4, common_diff))  // ç¬¬5é¡¹
  assert_eq(19, term_5)  // 3 + 4Ã—4 = 19
  
  let term_10 = add(first_term, multiply(9, common_diff))  // ç¬¬10é¡¹
  assert_eq(39, term_10)  // 3 + 9Ã—4 = 39
}

test "string_pattern_matching" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…åœºæ™¯
  // æ¨¡æ‹Ÿç®€å•çš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
  
  // æµ‹è¯•åŒ…å«ç‰¹å®šæ¨¡å¼çš„å­—ç¬¦ä¸²
  let pattern = "test"
  let text1 = "this is a test string"
  let text2 = "no match here"
  let text3 = "test at beginning"
  let text4 = "test"
  
  // éªŒè¯å­—ç¬¦ä¸²åŒ…å«å…³ç³»ï¼ˆé€šè¿‡greetå‡½æ•°é—´æ¥æµ‹è¯•ï¼‰
  let result1 = greet(text1)
  let result2 = greet(text2)
  let result3 = greet(text3)
  let result4 = greet(text4)
  
  assert_eq_string("Hello, this is a test string!", result1)
  assert_eq_string("Hello, no match here!", result2)
  assert_eq_string("Hello, test at beginning!", result3)
  assert_eq_string("Hello, test!", result4)
  
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è®¡ç®—ï¼ˆæ¨¡æ‹Ÿï¼‰
  let len1 = 21  // "this is a test string" çš„é•¿åº¦
  let len2 = 14  // "no match here" çš„é•¿åº¦
  let len3 = 19  // "test at beginning" çš„é•¿åº¦
  let len4 = 4   // "test" çš„é•¿åº¦
  
  // éªŒè¯é•¿åº¦å…³ç³»
  assert_true(len1 > len2)
  assert_true(len3 > len4)
  assert_eq(4, len4)
}

test "memory_address_calculation" {
  // æµ‹è¯•å†…å­˜åœ°å€è®¡ç®—æ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿæ•°ç»„å…ƒç´ çš„å†…å­˜åœ°å€è®¡ç®—
  
  let base_address = 1000  // åŸºåœ°å€
  let element_size = 4     // æ¯ä¸ªå…ƒç´ 4å­—èŠ‚
  let index1 = 0
  let index2 = 5
  let index3 = 10
  
  // è®¡ç®—å…ƒç´ åœ°å€ï¼šåœ°å€ = åŸºåœ°å€ + ç´¢å¼• Ã— å…ƒç´ å¤§å°
  let addr1 = add(base_address, multiply(index1, element_size))
  let addr2 = add(base_address, multiply(index2, element_size))
  let addr3 = add(base_address, multiply(index3, element_size))
  
  assert_eq(1000, addr1)  // 1000 + 0Ã—4 = 1000
  assert_eq(1020, addr2)  // 1000 + 5Ã—4 = 1020
  assert_eq(1040, addr3)  // 1000 + 10Ã—4 = 1040
  
  // è®¡ç®—å…ƒç´ é—´çš„åç§»é‡
  let offset12 = add(addr2, -addr1)
  let offset23 = add(addr3, -addr2)
  
  assert_eq(20, offset12)  // 1020 - 1000 = 20
  assert_eq(20, offset23)  // 1040 - 1020 = 20
  
  // éªŒè¯åœ°å€å¯¹é½ï¼ˆ4å­—èŠ‚å¯¹é½ï¼‰
  let aligned1 = addr1 % element_size == 0
  let aligned2 = addr2 % element_size == 0
  let aligned3 = addr3 % element_size == 0
  
  assert_true(aligned1 && aligned2 && aligned3)
}

test "probability_calculation" {
  // æµ‹è¯•æ¦‚ç‡è®¡ç®—åœºæ™¯
  // æ¨¡æ·ä¸¤ä¸ªéª°å­çš„æ¦‚ç‡è®¡ç®—
  
  let dice_faces = 6  // å…­é¢éª°å­
  let total_outcomes = multiply(dice_faces, dice_faces)  // æ€»ç»“æœæ•° = 6Ã—6 = 36
  
  // è®¡ç®—ç‰¹å®šç‚¹æ•°çš„ç»„åˆæ•°
  let sum_7_combinations = 6  // ç‚¹æ•°å’Œä¸º7çš„ç»„åˆï¼š(1,6), (2,5), (3,4), (4,3), (5,2), (6,1)
  let sum_11_combinations = 2 // ç‚¹æ•°å’Œä¸º11çš„ç»„åˆï¼š(5,6), (6,5)
  let sum_2_combinations = 1  // ç‚¹æ•°å’Œä¸º2çš„ç»„åˆï¼š(1,1)
  let sum_12_combinations = 1 // ç‚¹æ•°å’Œä¸º12çš„ç»„åˆï¼š(6,6)
  
  // è®¡ç®—æ¦‚ç‡ï¼ˆä»¥ç™¾åˆ†æ¯”è¡¨ç¤ºï¼‰
  let prob_7 = multiply(sum_7_combinations, 100) / total_outcomes
  let prob_11 = multiply(sum_11_combinations, 100) / total_outcomes
  let prob_2 = multiply(sum_2_combinations, 100) / total_outcomes
  let prob_12 = multiply(sum_12_combinations, 100) / total_outcomes
  
  assert_eq(16, prob_7)   // 6/36 â‰ˆ 16.67% â‰ˆ 16%
  assert_eq(5, prob_11)   // 2/36 â‰ˆ 5.56% â‰ˆ 5%
  assert_eq(2, prob_2)    // 1/36 â‰ˆ 2.78% â‰ˆ 2%
  assert_eq(2, prob_12)   // 1/36 â‰ˆ 2.78% â‰ˆ 2%
  
  // è®¡ç®—æœŸæœ›å€¼ï¼ˆç®€åŒ–ï¼‰
  let expected_sum = 7  // ä¸¤ä¸ªéª°å­çš„æœŸæœ›å’Œ
  assert_eq(7, expected_sum)
}

test "circular_buffer_operations" {
  // æµ‹è¯•å¾ªç¯ç¼“å†²åŒºæ“ä½œæ¨¡æ‹Ÿ
  let buffer_size = 8
  let initial_head = 0
  let initial_tail = 0
  let initial_count = 0
  
  // æ¨¡æ‹Ÿå…¥é˜Ÿæ“ä½œ
  let enqueue_count = 5
  let new_tail = add(initial_tail, enqueue_count) % buffer_size
  let new_count = add(initial_count, enqueue_count)
  
  assert_eq(5, new_tail)  // (0 + 5) % 8 = 5
  assert_eq(5, new_count) // 0 + 5 = 5
  
  // æ¨¡æ‹Ÿå‡ºé˜Ÿæ“ä½œ
  let dequeue_count = 3
  let new_head = add(initial_head, dequeue_count) % buffer_size
  let final_count = add(new_count, -dequeue_count)
  
  assert_eq(3, new_head)  // (0 + 3) % 8 = 3
  assert_eq(2, final_count) // 5 - 3 = 2
  
  // æ£€æŸ¥ç¼“å†²åŒºçŠ¶æ€
  let is_empty = final_count == 0
  let is_full = final_count == buffer_size
  let has_space = final_count < buffer_size
  
  assert_false(is_empty)
  assert_false(is_full)
  assert_true(has_space)
  
  // è®¡ç®—ç¼“å†²åŒºåˆ©ç”¨ç‡
  let utilization = multiply(final_count, 100) / buffer_size
  assert_eq(25, utilization) // 2/8 = 25%
}

test "color_space_conversion" {
  // æµ‹è¯•é¢œè‰²ç©ºé—´è½¬æ¢æ¨¡æ‹Ÿ
  // RGBåˆ°HSVçš„ç®€åŒ–è½¬æ¢æ¨¡æ‹Ÿ
  
  let r = 255  // çº¢è‰²åˆ†é‡
  let g = 0    // ç»¿è‰²åˆ†é‡
  let b = 0    // è“è‰²åˆ†é‡
  
  // è®¡ç®—æœ€å¤§å€¼å’Œæœ€å°å€¼
  let max_val = 255
  let min_val = 0
  let delta = add(max_val, -min_val)
  
  assert_eq(255, max_val)
  assert_eq(0, min_val)
  assert_eq(255, delta)
  
  // ç®€åŒ–çš„è‰²ç›¸è®¡ç®—ï¼ˆçº¢è‰²å¯¹åº”0åº¦ï¼‰
  let hue = if max_val == r { 0 } else { 120 }  // ç®€åŒ–é€»è¾‘
  assert_eq(0, hue)
  
  // é¥±å’Œåº¦è®¡ç®—ï¼ˆç®€åŒ–ï¼‰
  let saturation = if max_val == 0 { 0 } else { multiply(delta, 100) / max_val }
  assert_eq(100, saturation)  // 255/255 Ã— 100 = 100%
  
  // æ˜åº¦è®¡ç®—
  let value = max_val
  assert_eq(255, value)
  
  // æµ‹è¯•å¦ä¸€ç§é¢œè‰²ï¼ˆç»¿è‰²ï¼‰
  let r2 = 0
  let g2 = 255
  let b2 = 0
  
  let max_val2 = 255
  let min_val2 = 0
  let delta2 = add(max_val2, -min_val2)
  
  let hue2 = if max_val2 == r2 { 0 } else { 120 }  // ç»¿è‰²å¯¹åº”120åº¦
  let saturation2 = if max_val2 == 0 { 0 } else { multiply(delta2, 100) / max_val2 }
  let value2 = max_val2
  
  assert_eq(120, hue2)
  assert_eq(100, saturation2)
  assert_eq(255, value2)
}

test "checksum_verification" {
  // æµ‹è¯•æ ¡éªŒå’ŒéªŒè¯
  // æ¨¡æ‹Ÿç®€å•çš„æ ¡éªŒå’Œç®—æ³•
  
  let data_block1 = 100
  let data_block2 = 200
  let data_block3 = 300
  let data_block4 = 400
  
  // è®¡ç®—ç®€å•æ ¡éªŒå’Œ
  let checksum = add(add(add(data_block1, data_block2), data_block3), data_block4)
  assert_eq(1000, checksum)
  
  // æ¨¡æ‹Ÿæ•°æ®ä¼ è¾“åçš„éªŒè¯
  let received_block1 = 100
  let received_block2 = 200
  let received_block3 = 300  // æ¨¡æ‹Ÿè¿™ä¸ªå—å‡ºé”™
  let received_block4 = 400
  
  let received_checksum = add(add(add(received_block1, received_block2), received_block3), received_block4)
  assert_eq(1000, received_checksum)
  
  // æ£€æµ‹é”™è¯¯ï¼ˆé€šè¿‡æ¯”è¾ƒæ ¡éªŒå’Œï¼‰
  let error_detected = checksum != received_checksum
  assert_false(error_detected)  // åœ¨è¿™ç§æƒ…å†µä¸‹æ²¡æœ‰æ£€æµ‹åˆ°é”™è¯¯
  
  // æ¨¡æ‹Ÿæœ‰é”™è¯¯çš„æƒ…å†µ
  let corrupted_block3 = 310
  let corrupted_checksum = add(add(add(data_block1, data_block2), corrupted_block3), data_block4)
  let actual_error = checksum != corrupted_checksum
  assert_true(actual_error)  // æ£€æµ‹åˆ°é”™è¯¯
}

test "load_balancer_round_robin" {
  // æµ‹è¯•è½®è¯¢è´Ÿè½½å‡è¡¡å™¨æ¨¡æ‹Ÿ
  let server_count = 3
  let request_count = 10
  
  // æ¨¡æ‹Ÿè¯·æ±‚åˆ†å‘
  let server1_requests = 0
  let server2_requests = 0
  let server3_requests = 0
  
  // æ‰‹åŠ¨æ¨¡æ‹Ÿè½®è¯¢åˆ†é…
  // è¯·æ±‚1-10åˆ†åˆ«åˆ†é…åˆ°æœåŠ¡å™¨ï¼š1,2,3,1,2,3,1,2,3,1
  let final_server1_requests = 4  // è¯·æ±‚1,4,7,10
  let final_server2_requests = 3  // è¯·æ±‚2,5,8
  let final_server3_requests = 3  // è¯·æ±‚3,6,9
  
  assert_eq(4, final_server1_requests)
  assert_eq(3, final_server2_requests)
  assert_eq(3, final_server3_requests)
  
  // éªŒè¯æ€»è¯·æ±‚æ•°
  let total_distributed = add(add(final_server1_requests, final_server2_requests), final_server3_requests)
  assert_eq(request_count, total_distributed)
  
  // è®¡ç®—è´Ÿè½½å‡è¡¡åº¦
  let max_requests = 4
  let min_requests = 3
  let load_imbalance = add(max_requests, -min_requests)
  assert_eq(1, load_imbalance)  // æœ€å¤§å·®å€¼ä¸º1ï¼Œè¡¨ç¤ºè´Ÿè½½å‡è¡¡è¾ƒå¥½
  
  // è®¡ç®—æ¯ä¸ªæœåŠ¡å™¨çš„è´Ÿè½½ç™¾åˆ†æ¯”
  let server1_load = multiply(final_server1_requests, 100) / request_count
  let server2_load = multiply(final_server2_requests, 100) / request_count
  let server3_load = multiply(final_server3_requests, 100) / request_count
  
  assert_eq(40, server1_load)  // 4/10 = 40%
  assert_eq(30, server2_load)  // 3/10 = 30%
  assert_eq(30, server3_load)  // 3/10 = 30%
}

test "cache_replacement_policy" {
  // æµ‹è¯•ç¼“å­˜æ›¿æ¢ç­–ç•¥æ¨¡æ‹Ÿ
  // æ¨¡æ‹ŸLRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰ç¼“å­˜ç­–ç•¥
  
  let cache_size = 3
  let access_sequence = [1, 2, 3, 4, 1, 2, 5]  // è®¿é—®åºåˆ—
  
  // æ¨¡æ‹Ÿç¼“å­˜çŠ¶æ€å˜åŒ–
  // è®¿é—®1,2,3åï¼šç¼“å­˜ = [1,2,3]
  // è®¿é—®4åï¼šç¼“å­˜ = [2,3,4] (1è¢«æ›¿æ¢)
  // è®¿é—®1åï¼šç¼“å­˜ = [3,4,1] (2è¢«æ›¿æ¢)
  // è®¿é—®2åï¼šç¼“å­˜ = [4,1,2] (3è¢«æ›¿æ¢)
  // è®¿é—®5åï¼šç¼“å­˜ = [1,2,5] (4è¢«æ›¿æ¢)
  
  let final_cache = [1, 2, 5]
  let cache_hits = 2  // è®¿é—®1å’Œ2æ—¶å‘½ä¸­
  let cache_misses = 5 // å…¶ä»–è®¿é—®æœªå‘½ä¸­
  let total_accesses = 7
  
  assert_eq(2, cache_hits)
  assert_eq(5, cache_misses)
  assert_eq(7, total_accesses)
  
  // è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
  let hit_rate = multiply(cache_hits, 100) / total_accesses
  assert_eq(28, hit_rate)  // 2/7 â‰ˆ 28.57% â‰ˆ 28%
  
  // è®¡ç®—ç¼“å­˜æœªå‘½ä¸­ç‡
  let miss_rate = multiply(cache_misses, 100) / total_accesses
  assert_eq(71, miss_rate)  // 5/7 â‰ˆ 71.43% â‰ˆ 71%
  
  // éªŒè¯å‘½ä¸­ç‡ä¸æœªå‘½ä¸­ç‡ä¹‹å’Œ
  let total_rate = add(hit_rate, miss_rate)
  assert_eq(99, total_rate)  // ç”±äºæ•´æ•°é™¤æ³•ï¼Œä¸æ˜¯100%
}

test "error_detection_codes" {
  // æµ‹è¯•é”™è¯¯æ£€æµ‹ç æ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿå¥‡å¶æ ¡éªŒç 
  
  let data_byte = 10110101  // äºŒè¿›åˆ¶æ•°æ®
  let data_bits = 8
  
  // è®¡ç®—å¥‡å¶æ ¡éªŒä½ï¼ˆå¶æ ¡éªŒï¼‰
  // 1çš„ä¸ªæ•°ï¼š5ä¸ª
  let ones_count = 5
  let parity_bit = if ones_count % 2 == 0 { 0 } else { 1 }
  assert_eq(1, parity_bit)  // å¥‡æ•°ä¸ª1ï¼Œæ‰€ä»¥æ ¡éªŒä½ä¸º1
  
  // æ¨¡æ‹Ÿä¼ è¾“åçš„æ•°æ®
  let received_data = 10100101  // ç¬¬4ä½ä»1å˜ä¸º0
  let received_ones_count = 4
  let received_parity_bit = if received_ones_count % 2 == 0 { 0 } else { 1 }
  assert_eq(0, received_parity_bit)  // å¶æ•°ä¸ª1ï¼Œæ‰€ä»¥æ ¡éªŒä½ä¸º0
  
  // æ£€æµ‹é”™è¯¯
  let error_detected = parity_bit != received_parity_bit
  assert_true(error_detected)  // æ£€æµ‹åˆ°é”™è¯¯
  
  // æ¨¡æ‹ŸCRCæ ¡éªŒï¼ˆç®€åŒ–ï¼‰
  let data_block = 12345
  let divisor = 123
  let remainder = data_block % divisor
  let crc_value = remainder
  
  assert_eq(45, crc_value)  // 12345 % 123 = 45
  
  // æ¨¡æ‹Ÿæ¥æ”¶ç«¯çš„CRCè®¡ç®—
  let received_block = 12345
  let received_remainder = received_block % divisor
  let received_crc = received_remainder
  
  let crc_error = crc_value != received_crc
  assert_false(crc_error)  // æ²¡æœ‰é”™è¯¯
  
  // æ¨¡æ‹Ÿæ•°æ®æŸå
  let corrupted_block = 12350
  let corrupted_remainder = corrupted_block % divisor
  let corrupted_crc = corrupted_remainder
  
  let crc_detected = crc_value != corrupted_crc
  assert_true(crc_detected)  // æ£€æµ‹åˆ°é”™è¯¯
}

// æ–°å¢çš„10ä¸ªç®€æ´æµ‹è¯•ç”¨ä¾‹
test "simple_add_functionality" {
  assert_eq(10, add(3, 7))
  assert_eq(0, add(-5, 5))
  assert_eq(-8, add(-3, -5))
}

test "add_overflow_handling" {
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
}

test "simple_multiply_functionality" {
  assert_eq(15, multiply(3, 5))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(0, multiply(0, 100))
}

test "multiply_boundary_cases" {
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
}

test "greet_function_tests" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
}

test "math_expression_tests" {
  let result = multiply(add(2, 3), 4)
  assert_eq(20, result)
  
  let result2 = add(multiply(5, 3), 2)
  assert_eq(17, result2)
}

test "practical_calculation_tests" {
  let price = 199
  let quantity = 3
  let total = multiply(price, quantity)
  assert_eq(597, total)
}

test "string_processing_tests" {
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, VeryLongName!", greet("VeryLongName"))
}

test "complex_business_logic_tests" {
  let order_total = 1200
  let discount_rate = 10
  let discount_amount = multiply(order_total, discount_rate) / 100
  let final_total = add(order_total, -discount_amount)
  assert_eq(1080, final_total)
}

test "assertion_function_tests" {
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("MoonBit", "MoonBit")
  
  let calc_result = add(15, 27)
  assert_true(calc_result == 42)
  assert_false(calc_result != 42)
}

// æ ‡å‡† MoonBit æµ‹è¯•å¥—ä»¶ - æ·»åŠ 9ä¸ªæ ‡å‡†æµ‹è¯•ç”¨ä¾‹
test "standard_add_basic" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "standard_add_zero" {
  // æµ‹è¯•ä¸0ç›¸åŠ çš„æƒ…å†µ
  assert_eq(10, add(10, 0))
  assert_eq(10, add(0, 10))
  assert_eq(0, add(0, 0))
}

test "standard_add_negative" {
  // æµ‹è¯•è´Ÿæ•°åŠ æ³•
  assert_eq(0, add(5, -5))
  assert_eq(-8, add(-3, -5))
  assert_eq(-2, add(3, -5))
}

test "standard_multiply_basic" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(1, multiply(1, 1))
}

test "standard_multiply_negative" {
  // æµ‹è¯•è´Ÿæ•°ä¹˜æ³•
  assert_eq(-6, multiply(2, -3))
  assert_eq(6, multiply(-2, -3))
  assert_eq(0, multiply(-5, 0))
}

test "standard_greet_basic" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "standard_greet_special" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
  assert_eq_string("Hello, User123!", greet("User123"))
  assert_eq_string("Hello, @#$!", greet("@#$"))
}

test "standard_boundary_add" {
  // æµ‹è¯•è¾¹ç•Œå€¼çš„åŠ æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "standard_boundary_multiply" {
  // æµ‹è¯•è¾¹ç•Œå€¼çš„ä¹˜æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  assert_eq(min_val, multiply(min_val, -1))
}

// ç®€æ´å¿…è¦çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›– azimuth åŒ…çš„æ ¸å¿ƒåŠŸèƒ½

test "essential_add_basic" {
  // åŸºæœ¬åŠ æ³•æµ‹è¯•
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-2, add(-1, -1))
}

test "essential_add_edge_cases" {
  // åŠ æ³•è¾¹ç•Œæƒ…å†µæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æº¢å‡ºä¿æŠ¤æµ‹è¯•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(-1, add(max_val, min_val))
}

test "essential_multiply_basic" {
  // åŸºæœ¬ä¹˜æ³•æµ‹è¯•
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(5, multiply(5, 1))
  assert_eq(-6, multiply(2, -3))
}

test "essential_multiply_edge_cases" {
  // ä¹˜æ³•è¾¹ç•Œæƒ…å†µæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ç‰¹æ®Šå€¼æµ‹è¯•
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(0, multiply(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
}

test "essential_greet_basic" {
  // åŸºæœ¬é—®å€™è¯­æµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "essential_greet_special_chars" {
  // ç‰¹æ®Šå­—ç¬¦é—®å€™è¯­æµ‹è¯•
  assert_eq_string("Hello, æµ‹è¯•!", greet("æµ‹è¯•"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, @#$!", greet("@#$"))
}

test "essential_complex_calculation" {
  // å¤åˆè®¡ç®—æµ‹è¯•ï¼šçŸ©å½¢å‘¨é•¿
  let length = 10
  let width = 5
  let perimeter = add(multiply(2, length), multiply(2, width))
  assert_eq(30, perimeter)
}

test "essential_financial_calculation" {
  // é‡‘èè®¡ç®—æµ‹è¯•ï¼šç®€åŒ–å¤åˆ©
  let principal = 1000
  let rate = 5
  let years = 2
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  assert_eq(11000, total)
}

test "essential_assert_functions" {
  // æ–­è¨€å‡½æ•°æµ‹è¯•
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}

test "essential_mathematical_properties" {
  // æ•°å­¦æ€§è´¨æµ‹è¯•
  let a = 7
  let b = 11
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, 3)), add(multiply(a, b), multiply(a, 3)))
}

// æ–°å¢çš„æ‰©å±•æµ‹è¯•ç”¨ä¾‹
test "subtract_operations" {
  // å‡æ³•è¿ç®—æµ‹è¯•ï¼ˆé€šè¿‡åŠ æ³•å®ç°ï¼‰
  assert_eq(5, add(10, -5))
  assert_eq(-3, add(2, -5))
  assert_eq(0, add(7, -7))
}

test "division_simulation" {
  // é™¤æ³•æ¨¡æ‹Ÿæµ‹è¯•ï¼ˆé€šè¿‡é‡å¤å‡æ³•ï¼‰
  let dividend = 20
  let divisor = 4
  let mut quotient = 0
  let mut remainder = dividend
  
  // ç®€å•çš„é™¤æ³•æ¨¡æ‹Ÿ
  while multiply(divisor, quotient) < dividend {
    remainder = add(remainder, -divisor)
    quotient = add(quotient, 1)
  }
  
  assert_eq(5, quotient)
  assert_eq(0, remainder)
}

test "string_concatenation" {
  // å­—ç¬¦ä¸²è¿æ¥æµ‹è¯•
  let name1 = "Alice"
  let name2 = "Bob"
  let greeting1 = greet(name1)
  let greeting2 = greet(name2)
  
  assert_eq_string("Hello, Alice!", greeting1)
  assert_eq_string("Hello, Bob!", greeting2)
}

test "negative_number_operations" {
  // è´Ÿæ•°è¿ç®—æµ‹è¯•
  let a = -10
  let b = -5
  
  assert_eq(-15, add(a, b))
  assert_eq(50, multiply(a, b))
  assert_eq(10, multiply(a, -1))
  assert_eq(5, multiply(b, -1))
}

test "zero_properties" {
  // é›¶å±æ€§æµ‹è¯•
  let x = 42
  
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  assert_eq(0, multiply(0, 0))
}

test "sequence_operations" {
  // åºåˆ—è¿ç®—æµ‹è¯•
  let mut result = 0
  result = add(result, 1)
  result = multiply(result, 2)
  result = add(result, 3)
  result = multiply(result, 4)
  
  assert_eq(32, result)
}

test "power_simulation" {
  // å¹‚è¿ç®—æ¨¡æ‹Ÿæµ‹è¯•
  let base = 3
  let exponent = 4
  let mut result = 1
  
  // 3^4 = 81
  let mut i = 0
  while i < exponent {
    result = multiply(result, base)
    i = add(i, 1)
  }
  
  assert_eq(81, result)
}

test "factorial_calculation_extended" {
  // é˜¶ä¹˜è®¡ç®—æµ‹è¯• (5! = 120)
  let n = 5
  let mut result = 1
  
  let mut i = 1
  while i <= n {
    result = multiply(result, i)
    i = add(i, 1)
  }
  
  assert_eq(120, result)
}

test "greeting_edge_cases" {
  // é—®å€™å‡½æ•°è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello,   !", greet("   "))
}

// æ–°å¢çš„10ä¸ªæµ‹è¯•ç”¨ä¾‹
test "add_large_numbers_v2" {
  // æµ‹è¯•å¤§æ•°ç›¸åŠ 
  assert_eq(add(1000000, 2000000), 3000000)
  assert_eq(add(-1000000, -2000000), -3000000)
  assert_eq(add(2147483647, 0), 2147483647)
  assert_eq(add(-2147483648, 0), -2147483648)
}

test "add_mixed_signs_v2" {
  // æµ‹è¯•ä¸åŒç¬¦å·çš„æ•°ç›¸åŠ 
  assert_eq(add(100, -100), 0)
  assert_eq(add(100, -150), -50)
  assert_eq(add(-100, 150), 50)
  assert_eq(add(2147483647, -1), 2147483646)
}

test "multiply_large_numbers_v2" {
  // æµ‹è¯•å¤§æ•°ç›¸ä¹˜
  assert_eq(multiply(1000, 1000), 1000000)
  assert_eq(multiply(-1000, 1000), -1000000)
  assert_eq(multiply(-1000, -1000), 1000000)
  assert_eq(multiply(46341, 46341), 2147483647)
}

test "multiply_boundary_combinations_v2" {
  // æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆçš„ä¹˜æ³•
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(multiply(max_val, 0), 0)
  assert_eq(multiply(min_val, 0), 0)
  assert_eq(multiply(max_val, 1), max_val)
  assert_eq(multiply(min_val, 1), min_val)
  assert_eq(multiply(min_val, -1), min_val)
}

test "greet_special_characters_v2" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string(greet("æµ‹è¯•@123"), "Hello, æµ‹è¯•@123!")
  assert_eq_string(greet("ğŸŒ™"), "Hello, ğŸŒ™!")
  assert_eq_string(greet(" spaces "), "Hello, spaces !")
  assert_eq_string(greet(""), "Hello, !")
}

test "complex_calculation_scenario_v2" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šè®¡ç®—çŸ©å½¢çš„å‘¨é•¿
  let length = 10
  let width = 5
  let perimeter = add(multiply(2, length), multiply(2, width))
  assert_eq(30, perimeter)
}

test "divide_with_ceil_function_v2" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°
  assert_eq(divide_with_ceil(10, 3), 4)
  assert_eq(divide_with_ceil(15, 3), 5)
  assert_eq(divide_with_ceil(0, 5), 0)
  assert_eq(divide_with_ceil(9, 2), 5)
  assert_eq(divide_with_ceil(-7, 3), -2)
}

test "mathematical_sequences_v2" {
  // æµ‹è¯•æ•°å­¦åºåˆ—è®¡ç®—
  
  // è®¡ç®—å‰ 5 ä¸ªè‡ªç„¶æ•°çš„å’Œ: 1+2+3+4+5 = 15
  let sum_first_5 = add(add(add(add(1, 2), 3), 4), 5)
  assert_eq(15, sum_first_5)
  
  // è®¡ç®—å‰ 4 ä¸ªå¶æ•°çš„å’Œ: 2+4+6+8 = 20
  let sum_even_4 = add(add(add(2, 4), 6), 8)
  assert_eq(20, sum_even_4)
}

test "temperature_conversion_v2" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢åœºæ™¯ (æ‘„æ°åº¦åˆ°åæ°åº¦)
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 9) / 5, 32)
  assert_eq(77, fahrenheit)
  
  let celsius2 = 0
  let fahrenheit2 = add(multiply(celsius2, 9) / 5, 32)
  assert_eq(32, fahrenheit2)
}

test "assert_functions_test_v2" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}


