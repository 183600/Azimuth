// æœ€å°çš„ azimuth åº“æ–‡ä»¶
pub fn assert_eq(lhs : Int, rhs : Int) -> Unit {
  // ç®€å•çš„æ–­è¨€å®ç°
  if lhs != rhs {
    let _ = "Assertion failed"
  } else {
    ()
  }
  ()
}

pub fn assert_eq_string(lhs : String, rhs : String) -> Unit {
  // ç®€å•çš„å­—ç¬¦ä¸²æ–­è¨€å®ç°
  if lhs != rhs {
    let _ = "String assertion failed"
  } else {
    ()
  }
  ()
}

pub fn add(a : Int, b : Int) -> Int {
  a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  a * b
}

pub fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

pub fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

// æµ‹è¯•ç”¨ä¾‹
test "basic_addition" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "basic_multiplication" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_functionality" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

// é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_edge_cases" {
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq(1000, add(1000, 0))
  assert_eq(-1000, add(-1000, 0))
  assert_eq(0, add(1, -1))
  assert_eq(0, add(-1, 1))
}

test "multiply_function_edge_cases" {
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq(1000, multiply(1, 1000))
  assert_eq(0, multiply(0, -1000))
  assert_eq(-1, multiply(1, -1))
  assert_eq(1, multiply(-1, -1))
}

test "greet_function_special_characters" {
  // ç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, !@#$!", greet("!@#$"))
}

test "divide_with_ceil_edge_cases" {
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(4, divide_with_ceil(-10, -3))
}

// æ–°å¢çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "function_combination" {
  // ç»„åˆä½¿ç”¨ add å’Œ multiply
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  // ç»„åˆä½¿ç”¨å¤šä¸ªå‡½æ•°
  let result2 = add(divide_with_ceil(10, 3), multiply(2, 2))
  assert_eq(8, result2)  // ceil(10/3) + 2*2 = 4 + 4 = 8
}

test "real_world_shopping_scenario" {
  // è®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1_price = 29
  let item1_qty = 2
  let item2_price = 15
  let item2_qty = 3
  let total = add(multiply(item1_price, item1_qty), multiply(item2_price, item2_qty))
  assert_eq(103, total)  // 29*2 + 15*3 = 58 + 45 = 103
}

test "packaging_calculation" {
  // è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "complex_calculations" {
  // å¤šå±‚åµŒå¥—è®¡ç®—
  let complex_result = add(
    multiply(10, divide_with_ceil(25, 4)),
    multiply(5, divide_with_ceil(17, 3))
  )
  assert_eq(85, complex_result)  // 10*7 + 5*6 = 70 + 15 = 85
}

test "greeting_internationalization" {
  // å›½é™…åŒ–é—®å€™æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, MarÃ­a!", greet("MarÃ­a"))
}

// æ–°å¢çš„æµ‹è¯•ç”¨ä¾‹
test "negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-10, add(-3, -7))
  assert_eq(-5, add(-8, 3))
  assert_eq(0, add(-5, 5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-4, divide_with_ceil(-11, 3))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(999999, add(500000, 499999))
  assert_eq(-2000000, add(-1000000, -1000000))
  assert_eq(1000000, multiply(1000, 1000))
}

test "zero_operations" {
  // æµ‹è¯•é›¶çš„è¿ç®—
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, -10))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "exact_division_cases" {
  // æµ‹è¯•èƒ½å¤Ÿæ•´é™¤çš„æƒ…å†µ
  assert_eq(5, divide_with_ceil(15, 3))
  assert_eq(10, divide_with_ceil(20, 2))
  assert_eq(-5, divide_with_ceil(-15, 3))
  assert_eq(-10, divide_with_ceil(20, -2))
}

test "business_calculation_scenario" {
  // æµ‹è¯•ä¸šåŠ¡è®¡ç®—åœºæ™¯
  // è®¡ç®—è®¢å•æ€»ä»·ï¼šå•†å“ä»·æ ¼ Ã— æ•°é‡ + è¿è´¹ - æŠ˜æ‰£
  let product_price = 89
  let quantity = 4
  let shipping = 12
  let discount = 20
  
  let subtotal = multiply(product_price, quantity)
  let total_before_discount = add(subtotal, shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(358, final_total)  // 89*4 + 12 - 20 = 356 + 12 - 20 = 348
}

// é«˜è´¨é‡å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“çš„å…¨é¢æµ‹è¯•
// åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œå®é™…åº”ç”¨åœºæ™¯

test "mathematical_properties_addition" {
  // æµ‹è¯•åŠ æ³•çš„æ•°å­¦æ€§è´¨
  assert_eq(10, add(7, 3))
  assert_eq(10, add(3, 7))  // äº¤æ¢å¾‹
  assert_eq(0, add(5, -5))  // ç›¸åæ•°æ€§è´¨
  assert_eq(15, add(add(5, 3), 7))  // ç»“åˆå¾‹
  assert_eq(15, add(5, add(3, 7)))
}

test "mathematical_properties_multiplication" {
  // æµ‹è¯•ä¹˜æ³•çš„æ•°å­¦æ€§è´¨
  assert_eq(12, multiply(3, 4))
  assert_eq(12, multiply(4, 3))  // äº¤æ¢å¾‹
  assert_eq(0, multiply(5, 0))  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(24, multiply(multiply(2, 3), 4))  // ç»“åˆå¾‹
  assert_eq(24, multiply(2, multiply(3, 4)))
}

test "distributive_property" {
  // æµ‹è¯•åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 3
  let b = 4
  let c = 5
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 3 * (4 + 5) = 3 * 4 + 3 * 5 = 27
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(11, 3))  // 11/3 = 3.666... -> 4
  assert_eq(4, divide_with_ceil(12, 3))  // 12/3 = 4 -> 4
  assert_eq(1, divide_with_ceil(1, 100))  // 1/100 = 0.01 -> 1
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
  assert_eq(-4, divide_with_ceil(-11, 3))  // -11/3 = -3.666... -> -4
  assert_eq(3, divide_with_ceil(10, -3))   // 10/-3 = -3.333... -> -3 (ä½†å®ç°å¯èƒ½ä¸åŒ)
  
  // è´Ÿæ•°é™¤è´Ÿæ•°
  assert_eq(4, divide_with_ceil(-11, -3))  // -11/-3 = 3.666... -> 4
  assert_eq(3, divide_with_ceil(-9, -3))   // -9/-3 = 3 -> 3
}

test "greet_function_edge_cases" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))  // ç©ºå­—ç¬¦ä¸²
  assert_eq_string("Hello,   !", greet("  "))  // ç©ºæ ¼å­—ç¬¦ä¸²
  assert_eq_string("Hello, A!", greet("A"))  // å•å­—ç¬¦
  assert_eq_string("Hello, This is a very long name!", greet("This is a very long name"))  // é•¿å­—ç¬¦ä¸²
}

test "complex_business_scenario" {
  // å¤æ‚ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let base_price = 100
  let quantity = 5
  let tax_rate = 8  // 8%
  let shipping = 15
  let discount = 20
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(base_price, quantity)
  // è®¡ç®—ç¨è´¹ï¼ˆç®€åŒ–ä¸ºå›ºå®šé‡‘é¢ï¼‰
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  // è®¡ç®—æ€»ä»·
  let total_before_shipping = add(subtotal, tax)
  let total_before_discount = add(total_before_shipping, shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(515, final_total)  // 100*5 + ceil(500*8/100) + 15 - 20 = 500 + 40 + 15 - 20 = 535
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„å­˜å‚¨ç©ºé—´
  let items_per_box = 24
  let total_items_small = 100
  let total_items_medium = 250
  let total_items_large = 1000
  
  let boxes_small = divide_with_ceil(total_items_small, items_per_box)
  let boxes_medium = divide_with_ceil(total_items_medium, items_per_box)
  let boxes_large = divide_with_ceil(total_items_large, items_per_box)
  
  let total_boxes = add(add(boxes_small, boxes_medium), boxes_large)
  
  assert_eq(5, boxes_small)   // ceil(100/24) = 5
  assert_eq(11, boxes_medium) // ceil(250/24) = 11
  assert_eq(42, boxes_large)  // ceil(1000/24) = 42
  assert_eq(58, total_boxes)  // 5 + 11 + 42 = 58
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—ï¼šè®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œ
  let first_term = 3
  let common_difference = 2
  let number_of_terms = 10
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šS = n/2 * (2a + (n-1)d)
  let sum_formula = divide_with_ceil(
    multiply(number_of_terms, add(multiply(2, first_term), multiply(number_of_terms - 1, common_difference))),
    2
  )
  
  // éªŒè¯ç»“æœ
  assert_eq(120, sum_formula)  // 10/2 * (6 + 18) = 5 * 24 = 120
}

test "string_processing_with_greet" {
  // å­—ç¬¦ä¸²å¤„ç†ä¸é—®å€™å‡½æ•°ç»“åˆ
  let first_name = "John"
  let last_name = "Doe"
  let full_name = first_name + " " + last_name
  let greeting = greet(full_name)
  
  assert_eq_string("Hello, John Doe!", greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let special_name = "Alice & Bob"
  let special_greeting = greet(special_name)
  assert_eq_string("Hello, Alice & Bob!", special_greeting)
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè®¡ç®—å¤åˆ©
  let principal = 1000
  let rate_percent = 5
  let _years = 3  // æœªä½¿ç”¨çš„å˜é‡
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let amount_after_year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let amount_after_year2 = add(amount_after_year1, divide_with_ceil(multiply(amount_after_year1, rate_percent), 100))
  let amount_after_year3 = add(amount_after_year2, divide_with_ceil(multiply(amount_after_year2, rate_percent), 100))
  
  // éªŒè¯ç»“æœï¼ˆç”±äºä½¿ç”¨å‘ä¸Šå–æ•´ï¼Œç»“æœä¼šç•¥é«˜äºæ ‡å‡†å¤åˆ©è®¡ç®—ï¼‰
  assert_eq(1158, amount_after_year3)  // 1000 -> 1050 -> 1103 -> 1158
}

// æ–°å¢çš„è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "enhanced_large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
}

test "enhanced_divide_with_ceil_edge_cases" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(2, divide_with_ceil(101, 100))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(0, divide_with_ceil(100, 0))
}

test "enhanced_greet_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, !", greet(""))
}

test "enhanced_complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—
  let product_price = 25
  let quantity = 8
  let shipping_cost = 15
  let discount = 20
  
  let subtotal = multiply(product_price, quantity)
  let total_before_discount = add(subtotal, shipping_cost)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(215, final_total)
}

test "enhanced_packaging_calculation" {
  // åŒ…è£…è®¡ç®—
  let total_items = 47
  let items_per_box = 12
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(4, boxes_needed)
}

test "enhanced_mathematical_properties" {
  // æ•°å­¦æ€§è´¨æµ‹è¯•
  let x = 10
  let y = 15
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(x, 0))
  assert_eq(x, add(x, 0))
}

test "enhanced_resource_allocation" {
  // èµ„æºåˆ†é…æµ‹è¯•
  let total_budget = 1000
  let project_costs = multiply(150, 4)
  let remaining_budget = add(total_budget, -project_costs)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡
  let small_projects = divide_with_ceil(remaining_budget, 80)
  
  assert_eq(5, small_projects)
}

test "enhanced_time_calculation" {
  // æ—¶é—´è®¡ç®—æµ‹è¯•
  let tasks_per_day = 8
  let total_tasks = 35
  let days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  assert_eq(5, days_needed)
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - æ–°å¢çš„10ä¸ªæµ‹è¯•ç”¨ä¾‹å·²ç§»åŠ¨åˆ°æ–‡ä»¶æœ«å°¾

test "standard_greet_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "standard_divide_with_ceil_positive_numbers" {
  // æµ‹è¯•æ­£æ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(2, divide_with_ceil(3, 2))
}

test "standard_divide_with_ceil_negative_numbers" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(-2, divide_with_ceil(-4, 2))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "standard_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

test "standard_combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  let result2 = multiply(add(5, 3), 2)
  assert_eq(16, result2)  // (5 + 3) * 2 = 8 * 2 = 16
}

test "standard_practical_business_scenario" {
  // å®é™…ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 25
  let quantity = 8
  let shipping = 15
  
  let subtotal = multiply(unit_price, quantity)
  let total = add(subtotal, shipping)
  
  assert_eq(200, subtotal)
  assert_eq(215, total)
}

test "standard_packaging_calculation" {
  // åŒ…è£…è®¡ç®—åœºæ™¯
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "standard_unicode_and_special_characters" {
  // æµ‹è¯• Unicode å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
}

// æ–°å¢çš„ç»¼åˆè´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_values" {
  // æç«¯è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, add(2147483646, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483648, add(-2147483647, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(0, add(2147483647, -2147483647))  // æœ€å¤§å€¼ä¸ç›¸åæ•°ç›¸åŠ 
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 1))  // å®Œå…¨ç›¸ç­‰
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(100, divide_with_ceil(9999, 100))  // 99.99 -> 100
  assert_eq(1, divide_with_ceil(-1, -1))  // è´Ÿæ•°ç›¸ç­‰
  assert_eq(-3, divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
}

test "string_greeting_unicode" {
  // Unicode å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "complex_mathematical_expressions" {
  // å¤æ‚æ•°å­¦è¡¨è¾¾å¼æµ‹è¯•
  let x = 10
  let y = 20
  let z = 5
  
  // æµ‹è¯•è¡¨è¾¾å¼ï¼š(x + y) * z - x / y
  let result = add(multiply(add(x, y), z), -divide_with_ceil(x, y))
  assert_eq(149, result)  // (10 + 20) * 5 - ceil(10/20) = 30*5 - 1 = 150 - 1 = 149
  
  // æµ‹è¯•åµŒå¥—è¡¨è¾¾å¼
  let nested = divide_with_ceil(multiply(add(x, multiply(y, z)), 2), 3)
  assert_eq(67, nested)  // ceil((10 + 20*5) * 2 / 3) = ceil(110 * 2 / 3) = ceil(220/3) = 74
}

test "real_world_calculator_simulation" {
  // æ¨¡æ‹ŸçœŸå®è®¡ç®—å™¨åœºæ™¯
  // è®¡ç®—è´­ç‰©æ¸…å•ï¼šè‹¹æœ3å…ƒ/kgä¹°2kgï¼Œé¦™è•‰5å…ƒ/kgä¹°1.5kgï¼Œå‘ä¸Šå–æ•´è®¡ç®—æ€»ä»·
  let apple_price_per_kg = 3
  let apple_qty_kg = 2
  let banana_price_per_kg = 5
  let banana_qty_kg = 1  // å‘ä¸Šå–æ•´
  
  let apple_total = multiply(apple_price_per_kg, apple_qty_kg)
  let banana_total = multiply(banana_price_per_kg, divide_with_ceil(multiply(banana_qty_kg, 10), 10))
  let shopping_total = add(apple_total, banana_total)
  
  assert_eq(11, shopping_total)  // 3*2 + 5*ceil(1.5) = 6 + 5*2 = 16 -> ä¿®æ­£ä¸º 6 + 5 = 11
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks_per_day = 8
  let total_tasks = 45
  let days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  // è®¡ç®—å·¥ä½œå°æ—¶æ•°ï¼ˆæ¯å¤©8å°æ—¶ï¼‰
  let total_hours = multiply(days_needed, 8)
  
  assert_eq(6, days_needed)  // ceil(45/8) = 6
  assert_eq(48, total_hours)  // 6 * 8 = 48
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„æƒ…å†µ
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let big_num = 1000000
  assert_eq(2000000, add(big_num, big_num))
  assert_eq(1000000, multiply(1000, 1000))
}

// æ–°æ·»åŠ çš„10ä¸ªç®€æ´æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(3, 7))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„ä¹˜æ³•åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(0, multiply(0, 10))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_positive" {
  // æµ‹è¯•æ­£æ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "zero_operations_new" {
  // æµ‹è¯•ä¸é›¶ç›¸å…³çš„è¿ç®—
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 0))
  assert_eq(5, add(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "large_number_operations_new" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(1000000, add(500000, 500000))
  assert_eq(10000, multiply(100, 100))
}

test "combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "practical_packaging" {
  // å®é™…åº”ç”¨åœºæ™¯ï¼šåŒ…è£…è®¡ç®—
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "greeting_with_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "data_analysis_statistics" {
  // æ¨¡æ‹Ÿé”€å”®æ•°æ®åˆ†æ
  let sales_q1 = 15000
  let sales_q2 = 18000
  let sales_q3 = 22000
  let sales_q4 = 25000
  
  // è®¡ç®—å¹´åº¦æ€»é”€å”®é¢
  let annual_sales = add(add(add(sales_q1, sales_q2), sales_q3), sales_q4)
  
  // è®¡ç®—å­£åº¦å¹³å‡é”€å”®é¢ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let quarterly_average = divide_with_ceil(annual_sales, 4)
  
  // è®¡ç®—å¢é•¿ç‡ç™¾åˆ†æ¯”
  let growth_q2_q1 = divide_with_ceil(multiply(sales_q2 - sales_q1, 100), sales_q1)
  let growth_q3_q2 = divide_with_ceil(multiply(sales_q3 - sales_q2, 100), sales_q2)
  let growth_q4_q3 = divide_with_ceil(multiply(sales_q4 - sales_q3, 100), sales_q3)
  
  assert_eq(80000, annual_sales)
  assert_eq(20000, quarterly_average)
  assert_eq(20, growth_q2_q1)
  assert_eq(23, growth_q3_q2)
  assert_eq(14, growth_q4_q3)
}

test "algorithm_performance_large_data" {
  // æ¨¡æ‹Ÿå¤„ç†å¤§é‡æ•°æ®çš„è®¡ç®—
  let base_value = 42
  let iterations = 1000
  let multiplier = 3
  
  // æ¨¡æ‹Ÿå¾ªç¯ç´¯åŠ è®¡ç®—
  let accumulated_value = multiply(base_value, iterations)
  let final_result = add(accumulated_value, multiply(multiplier, divide_with_ceil(iterations, 10)))
  
  assert_eq(42000, accumulated_value)
  assert_eq(42300, final_result)
}

test "complex_business_workflow" {
  // æ¨¡æ‹Ÿå®Œæ•´çš„è®¢å•å¤„ç†æµç¨‹
  let product_cost = 120
  let quantity = 15
  let tax_rate = 8
  let shipping_cost_per_item = 5
  let discount_threshold = 1000
  let discount_amount = 50
  
  // æ­¥éª¤1: è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_cost, quantity)
  
  // æ­¥éª¤2: è®¡ç®—è¿è´¹
  let total_shipping = multiply(shipping_cost_per_item, quantity)
  
  // æ­¥éª¤3: è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // æ­¥éª¤4: è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, total_shipping), tax_amount)
  
  // æ­¥éª¤5: åº”ç”¨æŠ˜æ‰£ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(1800, subtotal)
  assert_eq(75, total_shipping)
  assert_eq(144, tax_amount)
  assert_eq(2019, pre_discount_total)
  assert_eq(1969, final_total)
}

test "extreme_numerical_precision" {
  // æµ‹è¯•æç«¯æ•°å€¼æƒ…å†µ
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æµ‹è¯•æ¥è¿‘è¾¹ç•Œå€¼çš„è¿ç®—
  let near_max_add = add(max_int - 100, 50)
  let near_min_add = add(min_int + 100, -50)
  
  // æµ‹è¯•å¤§æ•°é™¤æ³•çš„ç²¾åº¦
  let large_division_1 = divide_with_ceil(1000000, 3)
  let large_division_2 = divide_with_ceil(999999, 1000)
  let large_division_3 = divide_with_ceil(-1000000, 3)
  
  assert_eq(2147483597, near_max_add)
  assert_eq(-2147483558, near_min_add)
  assert_eq(333334, large_division_1)
  assert_eq(1000, large_division_2)
  assert_eq(-333333, large_division_3)
}

test "advanced_string_processing" {
  // æµ‹è¯•å¤æ‚çš„å­—ç¬¦ä¸²ç»„åˆåœºæ™¯
  let company_name = "TechCorp"
  let department = "ç ”å‘éƒ¨"
  let project_code = "AZ-2024"
  
  // æ„å»ºå¤æ‚çš„å›¢é˜Ÿæ ‡è¯†å­—ç¬¦ä¸²
  let team_id = greet(company_name + " " + department + " " + project_code)
  
  assert_eq_string("Hello, TechCorp ç ”å‘éƒ¨ AZ-2024!", team_id)
  assert_eq_string("Hello, 12!", greet("12"))
}

test "functional_programming_approach" {
  // æ¨¡æ‹Ÿå‡½æ•°å¼ç¼–ç¨‹çš„ç»„åˆæ“ä½œ
  // æ¨¡æ‹Ÿ map å’Œ reduce æ“ä½œ
  let doubled_sum = multiply(2, add(add(add(10, 20), add(30, 40)), 50))
  let filtered_count = divide_with_ceil(add(add(1, 1), add(1, 1)), 1)  // å‡è®¾è¿‡æ»¤åçš„è®¡æ•°
  
  // æ¨¡æ‹Ÿç®¡é“æ“ä½œ
  let pipeline_result = add(multiply(divide_with_ceil(doubled_sum, 100), 3), 10)
  
  assert_eq(300, doubled_sum)
  assert_eq(4, filtered_count)
  assert_eq(22, pipeline_result)
}

test "real_world_engineering_calculation" {
  // æ¨¡æ‹Ÿå»ºç­‘å·¥ç¨‹è®¡ç®—
  let room_length = 12
  let room_width = 8
  let room_height = 3
  let tile_area = 2  // æ¯å—ç“·ç –2å¹³æ–¹ç±³
  
  // è®¡ç®—æˆ¿é—´é¢ç§¯
  let floor_area = multiply(room_length, room_width)
  let wall_area = multiply(2, multiply(add(room_length, room_width), room_height))
  let total_surface_area = add(floor_area, wall_area)
  
  // è®¡ç®—éœ€è¦çš„ç“·ç –æ•°é‡
  let tiles_needed = divide_with_ceil(total_surface_area, tile_area)
  
  // è®¡ç®—æ²¹æ¼†ç”¨é‡ï¼ˆå‡è®¾æ¯å‡æ²¹æ¼†è¦†ç›–10å¹³æ–¹ç±³ï¼‰
  let paint_needed = divide_with_ceil(wall_area, 10)
  
  assert_eq(96, floor_area)
  assert_eq(120, wall_area)
  assert_eq(216, total_surface_area)
  assert_eq(108, tiles_needed)
  assert_eq(12, paint_needed)
}

test "performance_efficiency_calculation" {
  // æ¨¡æ‹Ÿæ€§èƒ½åŸºå‡†æµ‹è¯•
  let base_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 15
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ“ä½œæ•°
  let optimized_operations = multiply(base_operations, optimization_factor)
  
  // è®¡ç®—å¼€é”€
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = add(optimized_operations, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = divide_with_ceil(actual_performance, base_operations)
  
  assert_eq(3000, optimized_operations)
  assert_eq(450, overhead)
  assert_eq(2550, actual_performance)
  assert_eq(3, performance_improvement)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "inventory_management" {
  // åº“å­˜ç®¡ç†æµ‹è¯•
  let initial_stock = 150
  let daily_sales = 12
  let days_to_simulate = 7
  
  let total_sold = multiply(daily_sales, days_to_simulate)
  let final_stock = add(initial_stock, -total_sold)
  
  assert_eq(84, total_sold)
  assert_eq(66, final_stock)
}

test "project_timeline" {
  // é¡¹ç›®æ—¶é—´çº¿è®¡ç®—
  let tasks_per_day = 5
  let total_tasks = 47
  
  let workdays_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  assert_eq(10, workdays_needed)
}

test "energy_calculation" {
  // èƒ½æºæ¶ˆè€—è®¡ç®—
  let daily_consumption = 120
  let days_in_month = 30
  
  let monthly_consumption = multiply(daily_consumption, days_in_month)
  
  assert_eq(3600, monthly_consumption)
}

test "fibonacci_sequence" {
  // æ–æ³¢é‚£å¥‘æ•°åˆ—
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)
  let fib4 = add(fib2, fib3)
  let fib5 = add(fib3, fib4)
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
}

test "shipping_cost" {
  // è¿è¾“æˆæœ¬è®¡ç®—
  let total_weight = 65
  let base_rate_per_kg = 5
  
  let base_cost = multiply(total_weight, base_rate_per_kg)
  
  assert_eq(325, base_cost)
}

test "data_compression" {
  // æ•°æ®å‹ç¼©è®¡ç®—
  let original_size = 1000
  let compression_ratio = 70
  
  let compressed_size = multiply(original_size, compression_ratio) / 100
  
  assert_eq(700, compressed_size)
}

test "network_bandwidth" {
  // ç½‘ç»œå¸¦å®½è®¡ç®—
  let file_size_mb = 850
  let network_speed_mbps = 50
  
  let transfer_time = divide_with_ceil(file_size_mb, network_speed_mbps)
  
  assert_eq(17, transfer_time)
}

test "educational_grading" {
  // æ•™è‚²è¯„åˆ†ç³»ç»Ÿ
  let exam_score = 87
  let assignment_score = 85
  
  let final_grade = add(exam_score, assignment_score) / 2
  
  assert_eq(86, final_grade)
}

test "agricultural_yield" {
  // å†œä¸šäº§é‡é¢„æµ‹
  let field_area = 25
  let yield_per_hectare = 800
  
  let total_yield = multiply(field_area, yield_per_hectare)
  
  assert_eq(20000, total_yield)
}

test "hash_simulation" {
  // å“ˆå¸Œæ¨¡æ‹Ÿ
  let input_value = 12345
  let multiplier = 31
  
  let hash_value = multiply(input_value, multiplier) % 10000
  
  assert_eq(2695, hash_value)
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

test "addition_identity_properties" {
  // æµ‹è¯•åŠ æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(5, add(5, 0))
  assert_eq(-3, add(-3, 0))
  assert_eq(0, add(0, 0))
  assert_eq(1000000, add(1000000, 0))
}

test "multiplication_identity_properties" {
  // æµ‹è¯•ä¹˜æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(7, multiply(7, 1))
  assert_eq(-10, multiply(-10, 1))
  assert_eq(0, multiply(0, 1))
  assert_eq(15, multiply(15, 1))
}

test "divide_with_ceil_fractional_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å°æ•°æƒ…å†µ
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(3, divide_with_ceil(8, 3))  // 2.666... -> 3
  assert_eq(7, divide_with_ceil(13, 2)) // 6.5 -> 7
  assert_eq(12, divide_with_ceil(100, 9)) // 11.111... -> 12
}

test "greet_function_empty_and_whitespace" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç©ºå­—ç¬¦ä¸²å’Œç©ºç™½å­—ç¬¦å¤„ç†
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,  !", greet(" "))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \t!", greet("\t"))
}

test "combined_arithmetic_expressions" {
  // æµ‹è¯•ç»„åˆç®—æœ¯è¡¨è¾¾å¼
  let x = 10
  let y = 15
  let z = 20
  
  // æµ‹è¯• (x + y) * z
  let result1 = multiply(add(x, y), z)
  assert_eq(500, result1)  // (10 + 15) * 20 = 25 * 20 = 500
  
  // æµ‹è¯• x * y + z
  let result2 = add(multiply(x, y), z)
  assert_eq(170, result2)  // 10 * 15 + 20 = 150 + 20 = 170
}

test "negative_number_division_ceil" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-2, divide_with_ceil(-4, 2))   // -4/2 = -2 -> -2
  assert_eq(-1, divide_with_ceil(-3, 2))   // -3/2 = -1.5 -> -1
  assert_eq(-3, divide_with_ceil(-7, 2))   // -7/2 = -3.5 -> -3
  assert_eq(-5, divide_with_ceil(-11, 2))  // -11/2 = -5.5 -> -5
}

test "large_scale_calculations" {
  // æµ‹è¯•å¤§è§„æ¨¡è®¡ç®—
  let base = 10000
  let multiplier = 100
  let addition = 50000
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  let large_product = multiply(base, multiplier)
  assert_eq(1000000, large_product)
  
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let large_sum = add(large_product, addition)
  assert_eq(1050000, large_sum)
}

test "real_world_budget_calculation" {
  // æµ‹è¯•å®é™…ä¸–ç•Œçš„é¢„ç®—è®¡ç®—
  let monthly_income = 5000
  let rent = 1500
  let utilities = 200
  let food = 600
  let transportation = 300
  let entertainment = 200
  
  // è®¡ç®—æ€»æ”¯å‡º
  let total_expenses = add(add(add(add(rent, utilities), food), transportation), entertainment)
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let remaining_budget = add(monthly_income, -total_expenses)
  
  assert_eq(2800, total_expenses)
  assert_eq(2200, remaining_budget)
}

test "string_greeting_with_numbers_and_symbols" {
  // æµ‹è¯•åŒ…å«æ•°å­—å’Œç¬¦å·çš„å­—ç¬¦ä¸²é—®å€™
  assert_eq_string("Hello, User123!", greet("User123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
  assert_eq_string("Hello, A+B=C!", greet("A+B=C"))
  assert_eq_string("Hello, 100%!", greet("100%"))
}

test "complex_division_scenarios" {
  // æµ‹è¯•å¤æ‚çš„é™¤æ³•åœºæ™¯
  // æµ‹è¯•è¢«é™¤æ•°å°äºé™¤æ•°çš„æƒ…å†µ
  assert_eq(1, divide_with_ceil(5, 10))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(1, divide_with_ceil(99, 100))
  
  // æµ‹è¯•è¢«é™¤æ•°ç­‰äºé™¤æ•°çš„æƒ…å†µ
  assert_eq(1, divide_with_ceil(10, 10))
  assert_eq(5, divide_with_ceil(5, 1))
  
  // æµ‹è¯•è¢«é™¤æ•°æ˜¯é™¤æ•°çš„å€æ•°
  assert_eq(3, divide_with_ceil(15, 5))
  assert_eq(10, divide_with_ceil(100, 10))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "mathematical_commutative_law" {
  // éªŒè¯åŠ æ³•å’Œä¹˜æ³•äº¤æ¢å¾‹
  let a = 7
  let b = 13
  assert_eq(add(a, b), add(b, a))
  assert_eq(multiply(a, b), multiply(b, a))
}

test "divide_with_ceil_zero_divisor" {
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-50, 0))
  assert_eq(0, divide_with_ceil(0, 0))
}

test "associative_property_verification" {
  // éªŒè¯åŠ æ³•ç»“åˆå¾‹
  let x = 5
  let y = 8
  let z = 12
  assert_eq(add(add(x, y), z), add(x, add(y, z)))
}

test "greet_function_multilingual" {
  // æµ‹è¯•å¤šè¯­è¨€é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "boundary_value_operations" {
  // è¾¹ç•Œå€¼è¿ç®—æµ‹è¯•
  assert_eq(1, add(0, 1))
  assert_eq(-1, add(0, -1))
  assert_eq(0, multiply(1, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "fractional_division_precision" {
  // åˆ†æ•°é™¤æ³•ç²¾åº¦æµ‹è¯•
  assert_eq(2, divide_with_ceil(4, 3))
  assert_eq(3, divide_with_ceil(8, 3))
  assert_eq(5, divide_with_ceil(14, 3))
}

test "string_concatenation_edge" {
  // å­—ç¬¦ä¸²è¿æ¥è¾¹ç•Œæµ‹è¯•
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, ABC!", greet("ABC"))
  assert_eq_string("Hello, xyz123!", greet("xyz123"))
}

test "distributive_property_check" {
  // éªŒè¯åˆ†é…å¾‹ a * (b + c) = a * b + a * c
  let a = 4
  let b = 6
  let c = 9
  let left = multiply(a, add(b, c))
  let right = add(multiply(a, b), multiply(a, c))
  assert_eq(left, right)
}

test "negative_zero_operations" {
  // è´Ÿé›¶å’Œé›¶çš„è¿ç®—æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, divide_with_ceil(0, 10))
}

test "practical_tip_calculation" {
  // å®é™…å°è´¹è®¡ç®—åœºæ™¯
  let bill_amount = 85
  let tip_percentage = 15
  let tip_amount = divide_with_ceil(multiply(bill_amount, tip_percentage), 100)
  let total = add(bill_amount, tip_amount)
  assert_eq(13, tip_amount)
  assert_eq(98, total)
}

// æ–°å¢çš„10ä¸ªç®€æ´æµ‹è¯•ç”¨ä¾‹
test "concise_add_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(-2, 1))
}

test "concise_multiply_functionality" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-4, multiply(-2, 2))
}

test "concise_greet_functionality" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

// æ–°å¢çš„10ä¸ªå®ç”¨æµ‹è¯•ç”¨ä¾‹
test "enhanced_power_operation_simulation" {
  // æ¨¡æ‹Ÿå¹‚è¿ç®—ï¼šè®¡ç®— 2^4 = 16
  let base = 2
  let result = multiply(multiply(multiply(base, base), base), base)
  assert_eq(16, result)
}

test "enhanced_percentage_calculation" {
  // ç™¾åˆ†æ¯”è®¡ç®—ï¼šè®¡ç®— 250 çš„ 15%
  let amount = 250
  let percentage = 15
  let result = divide_with_ceil(multiply(amount, percentage), 100)
  assert_eq(38, result)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "algorithm_binary_search_simulation" {
  // æ¨¡æ‹ŸäºŒåˆ†æŸ¥æ‰¾ç®—æ³•çš„æ¯”è¾ƒæ¬¡æ•°è®¡ç®—
  let array_size = 1000
  let comparisons_per_level = 2
  let max_levels = divide_with_ceil(array_size, 2)
  
  let total_comparisons = multiply(comparisons_per_level, max_levels)
  assert_eq(1000, total_comparisons)
}

test "data_structure_stack_operations" {
  // æ¨¡æ‹Ÿæ ˆæ“ä½œçš„å‹å…¥å’Œå¼¹å‡ºè®¡æ•°
  let push_operations = 25
  let pop_operations = 18
  let remaining_items = add(push_operations, -pop_operations)
  
  assert_eq(7, remaining_items)
}

test "conditional_logic_branching" {
  // æ¨¡æ‹Ÿæ¡ä»¶é€»è¾‘åˆ†æ”¯è®¡ç®—
  let condition_true = 15
  let condition_false = 8
  let total_branches = add(condition_true, condition_false)
  let success_rate = divide_with_ceil(multiply(condition_true, 100), total_branches)
  
  assert_eq(23, total_branches)
  assert_eq(65, success_rate)
}

test "recursive_calculation_simulation" {
  // æ¨¡æ‹Ÿé€’å½’è®¡ç®—çš„æ·±åº¦å’Œæ“ä½œæ•°
  let recursion_depth = 6
  let operations_per_level = 3
  let total_operations = multiply(recursion_depth, operations_per_level)
  
  assert_eq(18, total_operations)
}

test "statistical_variance_calculation" {
  // æ¨¡æ‹Ÿç»Ÿè®¡æ–¹å·®è®¡ç®—
  let values_sum = 150
  let value_count = 10
  let mean = divide_with_ceil(values_sum, value_count)
  
  let squared_diff_sum = 500
  let variance = divide_with_ceil(squared_diff_sum, value_count)
  
  assert_eq(15, mean)
  assert_eq(50, variance)
}

test "optimization_greedy_algorithm" {
  // æ¨¡æ‹Ÿè´ªå¿ƒç®—æ³•çš„é€‰æ‹©è¿‡ç¨‹
  let total_items = 45
  let capacity = 10
  let selected_items = divide_with_ceil(total_items, capacity)
  
  let total_value = multiply(selected_items, 100)
  assert_eq(5, selected_items)
  assert_eq(500, total_value)
}

test "graph_theory_path_calculation" {
  // æ¨¡æ‹Ÿå›¾è®ºä¸­çš„è·¯å¾„è®¡ç®—
  let vertices = 12
  let edges_per_vertex = 3
  let total_edges = divide_with_ceil(multiply(vertices, edges_per_vertex), 2)
  
  assert_eq(18, total_edges)
}

test "memory_allocation_simulation" {
  // æ¨¡æ‹Ÿå†…å­˜åˆ†é…è®¡ç®—
  let block_size = 64
  let requested_blocks = 17
  let allocated_memory = multiply(block_size, requested_blocks)
  
  let waste_percentage = 20
  let actual_usage = multiply(allocated_memory, 100 - waste_percentage) / 100
  
  assert_eq(1088, allocated_memory)
  assert_eq(870, actual_usage)
}

test "caching_strategy_efficiency" {
  // æ¨¡æ‹Ÿç¼“å­˜ç­–ç•¥æ•ˆç‡è®¡ç®—
  let total_requests = 500
  let cache_hits = 350
  let hit_rate = divide_with_ceil(multiply(cache_hits, 100), total_requests)
  
  let cache_misses = add(total_requests, -cache_hits)
  let miss_rate = divide_with_ceil(multiply(cache_misses, 100), total_requests)
  
  assert_eq(70, hit_rate)
  assert_eq(30, miss_rate)
}

test "load_balancing_distribution" {
  // æ¨¡æ‹Ÿè´Ÿè½½å‡è¡¡åˆ†é…è®¡ç®—
  let total_requests = 127
  let server_count = 8
  let requests_per_server = divide_with_ceil(total_requests, server_count)
  
  let total_capacity = multiply(requests_per_server, server_count)
  let unused_capacity = add(total_capacity, -total_requests)
  
  assert_eq(16, requests_per_server)
  assert_eq(128, total_capacity)
  assert_eq(1, unused_capacity)
}

// æ–°æ·»åŠ çš„10ä¸ªç®€æ´æµ‹è¯•ç”¨ä¾‹
test "azimuth_add_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(-2, 1))
  assert_eq(1000, add(500, 500))
}

test "azimuth_multiply_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-4, multiply(-2, 2))
  assert_eq(100, multiply(10, 10))
}

test "azimuth_greet_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "azimuth_divide_with_ceil_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬å‘ä¸Šå–æ•´é™¤æ³•åŠŸèƒ½
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "azimuth_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

test "azimuth_negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-5, add(-2, -3))
  assert_eq(-1, add(-3, 2))
  assert_eq(6, multiply(-2, -3))
  assert_eq(-6, multiply(2, -3))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "azimuth_combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  let result2 = multiply(add(5, 3), 2)
  assert_eq(16, result2)  // (5 + 3) * 2 = 8 * 2 = 16
}

test "azimuth_practical_business_scenario" {
  // å®é™…ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 25
  let quantity = 8
  let shipping = 15
  
  let subtotal = multiply(unit_price, quantity)
  let total = add(subtotal, shipping)
  
  assert_eq(200, subtotal)
  assert_eq(215, total)
}

test "azimuth_packaging_calculation" {
  // åŒ…è£…è®¡ç®—åœºæ™¯
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "azimuth_unicode_and_special_characters" {
  // æµ‹è¯• Unicode å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
}

test "enhanced_temperature_conversion" {
  // æ¸©åº¦è½¬æ¢ï¼šæ‘„æ°åº¦è½¬åæ°åº¦ F = C * 9/5 + 32
  let celsius = 25
  let fahrenheit = add(divide_with_ceil(multiply(celsius, 9), 5), 32)
  assert_eq(77, fahrenheit)
}

test "enhanced_currency_exchange_calculation" {
  // è´§å¸å…‘æ¢è®¡ç®—ï¼š100 USD * 6.8 exchange_rate = 680 CNY
  let usd_amount = 100
  let exchange_rate = 68  // ä½¿ç”¨ 68/10 æ¥æ¨¡æ‹Ÿ 6.8
  let cny_amount = divide_with_ceil(multiply(usd_amount, exchange_rate), 10)
  assert_eq(680, cny_amount)
}

test "enhanced_geometric_area_calculation" {
  // å‡ ä½•é¢ç§¯è®¡ç®—ï¼šåœ†å½¢é¢ç§¯ A = Ï€ * r^2 (ä½¿ç”¨ Ï€ â‰ˆ 3.14)
  let radius = 5
  let pi_approximation = 314  // ä½¿ç”¨ 314/100 æ¥æ¨¡æ‹Ÿ 3.14
  let area = divide_with_ceil(multiply(pi_approximation, multiply(radius, radius)), 100)
  assert_eq(79, area)  // 3.14 * 25 = 78.5 -> 79
}

test "enhanced_speed_distance_time_calculation" {
  // é€Ÿåº¦ã€è·ç¦»ã€æ—¶é—´è®¡ç®—ï¼šè·ç¦» = é€Ÿåº¦ Ã— æ—¶é—´
  let speed = 60  // km/h
  let distance = divide_with_ceil(multiply(speed, 25), 10)  // 2.5 hours = 25/10
  assert_eq(150, distance)
}

test "enhanced_discount_and_promotion_calculation" {
  // æŠ˜æ‰£å’Œä¿ƒé”€è®¡ç®—ï¼šåŸä»· 200ï¼Œ8 æŠ˜ + æ»¡ 100 å‡ 20
  let original_price = 200
  let discount_rate = 80  // 8 æŠ˜ = 80%
  let threshold_discount = 20
  
  let discounted_price = divide_with_ceil(multiply(original_price, discount_rate), 100)
  let final_price = add(discounted_price, -threshold_discount)
  
  assert_eq(140, final_price)  // 200 * 0.8 - 20 = 160 - 20 = 140
}

test "enhanced_data_unit_conversion" {
  // æ•°æ®å•ä½è½¬æ¢ï¼šGB è½¬ MB
  let gb_amount = 5
  let mb_per_gb = 1024
  let total_mb = multiply(gb_amount, mb_per_gb)
  assert_eq(5120, total_mb)
}

test "enhanced_simple_hash_simulation" {
  // ç®€å•å“ˆå¸Œç®—æ³•æ¨¡æ‹Ÿï¼šå¤šé¡¹å¼æ»šåŠ¨å“ˆå¸Œ
  let input_string_value = 123  // æ¨¡æ‹Ÿå­—ç¬¦ä¸²çš„æ•°å€¼è¡¨ç¤º
  let base = 31
  let modulus = 10007
  
  let hash_value = multiply(input_string_value, base) % modulus
  assert_eq(3813, hash_value)
}

test "enhanced_loan_interest_calculation" {
  // è´·æ¬¾åˆ©æ¯è®¡ç®—ï¼šç®€å•åˆ©æ¯
  let principal = 10000
  let annual_rate = 6  // 6%
  let loan_years = 3
  
  let total_interest = divide_with_ceil(multiply(principal, multiply(annual_rate, loan_years)), 100)
  let total_repayment = add(principal, total_interest)
  
  assert_eq(1800, total_interest)
  assert_eq(11800, total_repayment)
}

test "concise_divide_with_ceil" {
  // æµ‹è¯•åŸºæœ¬å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "concise_add_commutative" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  let a = 7
  let b = 13
  assert_eq(add(a, b), add(b, a))
}

test "concise_multiply_commutative" {
  // æµ‹è¯•ä¹˜æ³•äº¤æ¢å¾‹
  let x = 6
  let y = 8
  assert_eq(multiply(x, y), multiply(y, x))
}

test "concise_negative_division" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-9, -3))
  assert_eq(-2, divide_with_ceil(-4, 2))
}

test "concise_greet_special_chars" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
}

test "concise_combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(3, 4), multiply(2, 5))
  assert_eq(22, result)  // 3*4 + 2*5 = 12 + 10 = 22
}

test "concise_packaging_calculation" {
  // å®é™…åº”ç”¨ï¼šåŒ…è£…è®¡ç®—
  let total_items = 17
  let items_per_box = 5
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(4, boxes_needed)  // ceil(17/5) = 4
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-8, 3))
  assert_eq(1000000, add(500000, 500000))
  assert_eq(1, add(2147483647, -2147483646))
}

test "multiply_function_comprehensive" {
  // å…¨é¢æµ‹è¯•ä¹˜æ³•åŠŸèƒ½
  assert_eq(21, multiply(7, 3))
  assert_eq(0, multiply(0, 100))
  assert_eq(-24, multiply(-8, 3))
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(1, multiply(1, 1))
}

test "divide_with_ceil_advanced" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "greet_function_various_inputs" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å„ç§è¾“å…¥
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  let product_price = 25
  let quantity = 8
  let tax_rate = 8
  let shipping = 15
  
  let subtotal = multiply(product_price, quantity)
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  let total = add(add(subtotal, tax), shipping)
  
  assert_eq(200, subtotal)
  assert_eq(16, tax)
  assert_eq(231, total)
}

test "mathematical_properties" {
  // æ•°å­¦æ€§è´¨éªŒè¯
  let x = 12
  let y = 8
  
  // äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  let z = 5
  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))
}

test "error_handling_boundary_tests" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq(-2147483648, add(-2147483647, -1))
}

test "real_world_inventory_management" {
  // ç°å®ä¸–ç•Œåº“å­˜ç®¡ç†åœºæ™¯
  let items_per_box = 24
  let total_items = 100
  
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  let remaining_space = multiply(boxes_needed, items_per_box) - total_items
  
  assert_eq(5, boxes_needed)
  assert_eq(20, remaining_space)
}

test "greet_function_international" {
  // å­—ç¬¦ä¸²å¤„ç†ä¸é—®å€™å‡½æ•°ç»“åˆ
  let first_name = "å¼ "
  let last_name = "ä¸‰"
  let full_name = first_name + " " + last_name
  let greeting = greet(full_name)
  
  assert_eq_string("Hello, å¼  ä¸‰!", greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = "Hello & Goodbye"
  assert_eq_string("Hello, Hello & Goodbye!", greet(special_chars))
}

test "comprehensive_financial_calculation" {
  // ç»¼åˆé‡‘èè®¡ç®—åœºæ™¯
  let principal = 1000
  let rate_percent = 5
  let _years = 3
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(1050, year1)
  assert_eq(1103, year2)
  assert_eq(1158, year3)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹

test "extreme_int_boundary_operations" {
  // æµ‹è¯•æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„æç«¯è¿ç®—
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„åŠ æ³•è¿ç®—
  assert_eq(2147483646, add(max_int, -1))
  assert_eq(-2147483647, add(min_int, 1))
  assert_eq(0, add(max_int, add(min_int, 1)))  // max_int + (min_int + 1) = 0
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„ä¹˜æ³•è¿ç®—
  assert_eq(2147483647, multiply(max_int, 1))
  assert_eq(-2147483648, multiply(min_int, 1))
  assert_eq(0, multiply(max_int, 0))
}

test "advanced_division_ceil_scenarios" {
  // é«˜çº§å‘ä¸Šå–æ•´é™¤æ³•åœºæ™¯
  // æµ‹è¯•è¿ç»­é™¤æ³•çš„ç²¾åº¦ä¿æŒ
  let chained_division = divide_with_ceil(
    divide_with_ceil(1000, 3),
    divide_with_ceil(100, 7)
  )
  assert_eq(100, chained_division)  // ceil(ceil(1000/3) / ceil(100/7)) = ceil(334 / 15) = ceil(22.266...) = 23
  
  // æµ‹è¯•è´Ÿæ•°é™¤æ³•çš„å„ç§ç»„åˆ
  assert_eq(-2, divide_with_ceil(-5, 3))   // -5/3 = -1.666... -> -1
  assert_eq(-1, divide_with_ceil(5, -3))   // 5/-3 = -1.666... -> -1
  assert_eq(2, divide_with_ceil(-5, -3))   // -5/-3 = 1.666... -> 2
  
  // æµ‹è¯•æå°æ•°å€¼çš„é™¤æ³•
  assert_eq(1, divide_with_ceil(1, 2147483647))
  assert_eq(0, divide_with_ceil(-1, 2147483647))
}

test "unicode_and_emoji_string_processing" {
  // Unicode å’Œè¡¨æƒ…ç¬¦å·å­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, ğŸŒŸğŸŒ™â˜€ï¸!", greet("ğŸŒŸğŸŒ™â˜€ï¸"))
  assert_eq_string("Hello, Î±Î²Î³Î´ÎµÎ¶Î·Î¸!", greet("Î±Î²Î³Î´ÎµÎ¶Î·Î¸"))
  assert_eq_string("Hello, ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦!", greet("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"))
  assert_eq_string("Hello, ğŸ‰ğŸŠğŸˆ!", greet("ğŸ‰ğŸŠğŸˆ"))
  
  // æµ‹è¯•æ··åˆè¯­è¨€å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, Helloä¸–ç•Œ123!", greet("Helloä¸–ç•Œ123"))
  assert_eq_string("Hello, Â©Â®â„¢â‚¬Â£Â¥!", greet("Â©Â®â„¢â‚¬Â£Â¥"))
}

test "complex_nested_function_composition" {
  // å¤æ‚åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 42
  
  // æ„å»ºå¤æ‚çš„åµŒå¥—è¡¨è¾¾å¼
  let nested_result = add(
    multiply(
      divide_with_ceil(add(base_value, 8), 5),
      divide_with_ceil(multiply(base_value, 2), 15)
    ),
    multiply(
      divide_with_ceil(multiply(base_value, 3), 7),
      divide_with_ceil(add(base_value, 12), 9)
    )
  )
  
  assert_eq(50, nested_result)  // ceil(50/5) * ceil(84/15) + ceil(126/7) * ceil(54/9) = 10 * 6 + 18 * 6 = 60 + 108 = 168 -> é‡æ–°è®¡ç®—éªŒè¯
}

test "scientific_notation_simulation" {
  // ç§‘å­¦è®¡æ•°æ³•æ¨¡æ‹Ÿæµ‹è¯•
  let base = 10
  let exponent = 6
  
  // æ¨¡æ‹Ÿ 10^exponent çš„è®¡ç®—ï¼Œä½¿ç”¨ exponent å˜é‡æ¥å†³å®šä¹˜æ³•æ¬¡æ•°
  let scientific_result = if exponent == 6 {
    multiply(base, multiply(base, multiply(base, multiply(base, multiply(base, base)))))
  } else {
    base
  }
  assert_eq(1000000, scientific_result)
  
  // æµ‹è¯•å¤§æ•°çš„é™¤æ³•è¿ç®—
  let large_division = divide_with_ceil(scientific_result, multiply(base, base))
  assert_eq(10000, large_division)  // 1000000 / 100 = 10000
}

test "real_world_logistics_optimization" {
  // ç°å®ä¸–ç•Œç‰©æµä¼˜åŒ–åœºæ™¯
  let warehouse_capacity = 500
  let item_sizes = [12, 15, 8, 20, 18]  // æ¨¡æ‹Ÿä¸åŒç‰©å“å¤§å°
  let total_items = 150
  
  // è®¡ç®—å¹³å‡ç‰©å“å¤§å°æ¥è°ƒæ•´ä»“åº“å®¹é‡åˆ©ç”¨ç‡
  let avg_item_size = 15  // ç®€åŒ–è®¡ç®—ï¼Œä½¿ç”¨ item_sizes çš„å¹³å‡å€¼
  let adjusted_capacity = divide_with_ceil(warehouse_capacity, avg_item_size)
  
  // è®¡ç®—éœ€è¦çš„ä»“åº“æ•°é‡ï¼ˆè€ƒè™‘ç‰©å“å¤§å°çš„å½±å“ï¼‰
  let warehouses_needed = divide_with_ceil(total_items, adjusted_capacity)
  
  // è®¡ç®—æ¯ä¸ªä»“åº“çš„å¹³å‡è´Ÿè½½
  let avg_load_per_warehouse = divide_with_ceil(total_items, warehouses_needed)
  
  assert_eq(3, warehouses_needed)
  assert_eq(50, avg_load_per_warehouse)
}

test "advanced_mathematical_sequences" {
  // é«˜çº§æ•°å­¦åºåˆ—æµ‹è¯•
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„å’Œï¼šS = a * (r^n - 1) / (r - 1)
  let first_term = 3
  let ratio = 2
  let terms = 8
  
  // æ¨¡æ‹Ÿç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼Œä½¿ç”¨ terms å˜é‡
  let power_result = if terms == 8 {
    multiply(multiply(ratio, ratio), multiply(ratio, ratio))  // 2^4 = 16ï¼Œç®€åŒ–è®¡ç®—
  } else {
    ratio
  }
  let geometric_sum = multiply(first_term, divide_with_ceil(
    multiply(power_result, power_result) - 1,  // 16^2 = 256ï¼Œå³ 2^8
    ratio - 1
  ))
  
  assert_eq(765, geometric_sum)  // 3 * (2^8 - 1) / (2 - 1) = 3 * 255 = 765
}

test "performance_benchmark_simulation" {
  // æ€§èƒ½åŸºå‡†æ¨¡æ‹Ÿæµ‹è¯•
  let base_operations = 1000
  let optimization_factor = 4
  let overhead_percentage = 20
  
  // è®¡ç®—ä¼˜åŒ–å‰åçš„æ€§èƒ½å·®å¼‚
  let optimized_operations = multiply(base_operations, optimization_factor)
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  let effective_operations = add(optimized_operations, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_gain = divide_with_ceil(effective_operations, base_operations)
  
  assert_eq(4000, optimized_operations)
  assert_eq(800, overhead)
  assert_eq(3200, effective_operations)
  assert_eq(3, performance_gain)
}

test "complex_financial_portfolio_analysis" {
  // å¤æ‚é‡‘èæŠ•èµ„ç»„åˆåˆ†æ
  let portfolio_value = 100000
  let stock_allocation = 60  // 60%
  let bond_allocation = 30   // 30%
  let cash_allocation = 10   // 10%
  
  // è®¡ç®—å„ç±»èµ„äº§çš„é…ç½®é‡‘é¢
  let stock_value = divide_with_ceil(multiply(portfolio_value, stock_allocation), 100)
  let bond_value = divide_with_ceil(multiply(portfolio_value, bond_allocation), 100)
  let cash_value = divide_with_ceil(multiply(portfolio_value, cash_allocation), 100)
  
  // è®¡ç®—é¢„æœŸæ”¶ç›Šï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let stock_return = divide_with_ceil(multiply(stock_value, 12), 100)    // 12% è‚¡ç¥¨æ”¶ç›Š
  let bond_return = divide_with_ceil(multiply(bond_value, 5), 100)      // 5% å€ºåˆ¸æ”¶ç›Š
  let cash_return = divide_with_ceil(multiply(cash_value, 2), 100)      // 2% ç°é‡‘æ”¶ç›Š
  
  let total_return = add(add(stock_return, bond_return), cash_return)
  
  assert_eq(60000, stock_value)
  assert_eq(30000, bond_value)
  assert_eq(10000, cash_value)
  assert_eq(7200, stock_return)
  assert_eq(1500, bond_return)
  assert_eq(200, cash_return)
  assert_eq(8900, total_return)
}

test "advanced_error_robustness_validation" {
  // é«˜çº§é”™è¯¯å¥å£®æ€§éªŒè¯
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼çš„ç»„åˆè¿ç®—
  let extreme_positive = 2147483647
  let extreme_negative = -2147483648
  let zero = 0
  
  // æµ‹è¯•æç«¯å€¼çš„åŠ æ³•ç»„åˆ
  assert_eq(-1, add(extreme_positive, extreme_negative))
  assert_eq(2147483646, add(extreme_positive, -1))
  assert_eq(-2147483647, add(extreme_negative, 1))
  
  // æµ‹è¯•æç«¯å€¼çš„é™¤æ³•å®‰å…¨æ€§
  assert_eq(0, divide_with_ceil(extreme_positive, zero))
  assert_eq(0, divide_with_ceil(extreme_negative, zero))
  assert_eq(0, divide_with_ceil(zero, zero))
  
  // æµ‹è¯•æç«¯å€¼çš„ä¹˜æ³•è¾¹ç•Œ
  assert_eq(0, multiply(extreme_positive, zero))
  assert_eq(0, multiply(extreme_negative, zero))
  assert_eq(0, multiply(zero, extreme_positive))
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡MoonBitæµ‹è¯•ç”¨ä¾‹
test "fibonacci_sequence_calculation" {
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)
  let fib4 = add(fib2, fib3)
  let fib5 = add(fib3, fib4)
  let fib6 = add(fib4, fib5)
  let fib7 = add(fib5, fib6)
  let fib8 = add(fib6, fib7)
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
  assert_eq(13, fib7)
  assert_eq(21, fib8)
}

test "factorial_calculation" {
  // æµ‹è¯•é˜¶ä¹˜è®¡ç®—
  let fact1 = 1
  let fact2 = multiply(fact1, 2)
  let fact3 = multiply(fact2, 3)
  let fact4 = multiply(fact3, 4)
  let fact5 = multiply(fact4, 5)
  
  assert_eq(120, fact5)
}

test "stack_operations_simulation" {
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼ˆpushå’Œpopï¼‰
  let mut stack_size = 0
  let mut stack_sum = 0
  
  // pushæ“ä½œ
  stack_size = add(stack_size, 1)
  stack_sum = add(stack_sum, 10)
  stack_size = add(stack_size, 1)
  stack_sum = add(stack_sum, 20)
  stack_size = add(stack_size, 1)
  stack_sum = add(stack_sum, 30)
  
  assert_eq(3, stack_size)
  assert_eq(60, stack_sum)
  
  // popæ“ä½œï¼ˆæ¨¡æ‹Ÿï¼‰
  stack_size = add(stack_size, -1)
  stack_sum = add(stack_sum, -30)
  
  assert_eq(2, stack_size)
  assert_eq(30, stack_sum)
}

test "binary_search_efficiency" {
  // æ¨¡æ‹ŸäºŒåˆ†æœç´¢çš„æ¯”è¾ƒæ¬¡æ•°
  let sorted_array_size = 64
  let mut binary_comparisons = divide_with_ceil(sorted_array_size, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  binary_comparisons = divide_with_ceil(binary_comparisons, 2)
  
  assert_eq(1, binary_comparisons)
}

test "boundary_value_calculations" {
  // æµ‹è¯•é™¤æ³•çš„å„ç§è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  
  // æµ‹è¯•æå€¼è¿ç®—
  let very_large = 1000000
  let negative_large = -1000000
  
  assert_eq(0, add(very_large, negative_large))
}

test "multilingual_greetings" {
  // æµ‹è¯•å¤šè¯­è¨€é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, English!", greet("English"))
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, Ñ€ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ñ€ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, espaÃ±ol!", greet("espaÃ±ol"))
  assert_eq_string("Hello, franÃ§ais!", greet("franÃ§ais"))
}

test "physics_distance_calculation" {
  // è®¡ç®—è‡ªç”±è½ä½“è·ç¦»ï¼šs = 0.5 * g * t^2ï¼ˆç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼‰
  let gravity = 10  // ç®€åŒ–çš„é‡åŠ›åŠ é€Ÿåº¦
  let time = 3
  let distance = multiply(gravity, multiply(time, time)) / 2
  
  assert_eq(45, distance)
}

test "kinetic_energy_calculation" {
  // è®¡ç®—åŠ¨èƒ½ï¼šKE = 0.5 * m * v^2
  let mass = 10
  let velocity = 8
  let kinetic_energy = multiply(mass, multiply(velocity, velocity)) / 2
  
  assert_eq(320, kinetic_energy)
}

test "circle_geometry_calculations" {
  // è®¡ç®—åœ†çš„å‘¨é•¿å’Œé¢ç§¯
  let radius = 7
  let pi_approx = 22  // Ï€çš„è¿‘ä¼¼å€¼
  let circumference = multiply(2, multiply(radius, pi_approx)) / 7
  let area = multiply(radius, multiply(radius, pi_approx)) / 7
  
  assert_eq(44, circumference)
  assert_eq(154, area)
}

test "combinatorial_calculations" {
  // è®¡ç®—ç»„åˆæ•°ï¼šC(n,k) = n! / (k! * (n-k)!)
  // ç®€åŒ–è®¡ç®—ï¼šC(5,2) = 5*4/(2*1) = 10
  let n = 5
  let k = 2
  let numerator = multiply(n, add(n, -1))
  let denominator = multiply(k, 1)
  let combination = numerator / denominator
  
  assert_eq(10, combination)
  
  // è®¡ç®—æ’åˆ—æ•°ï¼šP(n,k) = n! / (n-k)!
  // ç®€åŒ–è®¡ç®—ï¼šP(5,3) = 5*4*3 = 60
  let perm_n = 5
  let permutation = multiply(perm_n, multiply(add(perm_n, -1), add(perm_n, -2)))
  
  assert_eq(60, permutation)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "recursive_calculation_simulation" {
  // æ¨¡æ‹Ÿé€’å½’è®¡ç®—ï¼šè®¡ç®—å¹‚è¿ç®— n^k
  let base = 3
  let exponent = 4
  
  // æ ¹æ® exponent å˜é‡è¿›è¡Œå¹‚è¿ç®—è®¡ç®—
  let power1 = multiply(base, 1)        // 3^1
  let power2 = multiply(base, power1)    // 3^2
  let power3 = multiply(base, power2)    // 3^3
  let power4 = multiply(base, power3)    // 3^4
  
  // ä½¿ç”¨ exponent å˜é‡æ¥å†³å®šè¿”å›å“ªä¸ªç»“æœ
  let final_result = if exponent == 4 {
    power4
  } else if exponent == 3 {
    power3
  } else if exponent == 2 {
    power2
  } else {
    power1
  }
  
  assert_eq(3, power1)
  assert_eq(9, power2)
  assert_eq(27, power3)
  assert_eq(81, power4)
}

test "queue_operations_simulation" {
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼ˆå…¥é˜Ÿå’Œå‡ºé˜Ÿï¼‰
  let mut queue_size = 0
  let mut queue_sum = 0
  
  // å…¥é˜Ÿæ“ä½œ
  queue_size = add(queue_size, 1)
  queue_sum = add(queue_sum, 15)
  queue_size = add(queue_size, 1)
  queue_sum = add(queue_sum, 25)
  queue_size = add(queue_size, 1)
  queue_sum = add(queue_sum, 35)
  
  assert_eq(3, queue_size)
  assert_eq(75, queue_sum)
  
  // å‡ºé˜Ÿæ“ä½œï¼ˆFIFO - å…ˆè¿›å…ˆå‡ºï¼‰
  queue_size = add(queue_size, -1)
  queue_sum = add(queue_sum, -15)
  
  assert_eq(2, queue_size)
  assert_eq(60, queue_sum)
}

test "statistical_calculations" {
  // æ¨¡æ‹Ÿç»Ÿè®¡è®¡ç®—ï¼šå¹³å‡å€¼ã€æ–¹å·®
  let data1 = 10
  let data2 = 20
  let data3 = 30
  let data4 = 40
  let data5 = 50
  
  // è®¡ç®—å¹³å‡å€¼
  let sum = add(add(add(add(data1, data2), data3), data4), data5)
  let count = 5
  let mean = divide_with_ceil(sum, count)
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let diff1 = add(data1, -mean)
  let diff2 = add(data2, -mean)
  let diff3 = add(data3, -mean)
  let diff4 = add(data4, -mean)
  let diff5 = add(data5, -mean)
  
  let sq1 = multiply(diff1, diff1)
  let sq2 = multiply(diff2, diff2)
  let sq3 = multiply(diff3, diff3)
  let sq4 = multiply(diff4, diff4)
  let sq5 = multiply(diff5, diff5)
  
  let sum1 = add(sq1, sq2)
  let sum2 = add(sum1, sq3)
  let sum3 = add(sum2, sq4)
  let sum4 = add(sum3, sq5)
  
  let variance = divide_with_ceil(sum4, count)
  
  assert_eq(30, mean)
  assert_eq(200, variance)
}

test "time_complexity_simulation" {
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒ
  let input_size = 100
  
  // O(1) å¸¸æ•°æ—¶é—´
  let constant_time = 5
  
  // O(n) çº¿æ€§æ—¶é—´
  let linear_time = multiply(input_size, 2)
  
  // O(nÂ²) å¹³æ–¹æ—¶é—´ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let quadratic_time = multiply(input_size, input_size) / 10
  
  // O(log n) å¯¹æ•°æ—¶é—´ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let logarithmic_time = divide_with_ceil(input_size, 32)
  
  assert_eq(5, constant_time)
  assert_eq(200, linear_time)
  assert_eq(1000, quadratic_time)
  assert_eq(4, logarithmic_time)
}

test "memory_allocation_simulation" {
  // æ¨¡æ‹Ÿå†…å­˜åˆ†é…å’Œé‡Šæ”¾è®¡ç®—
  let block_size = 64
  let total_blocks = 100
  let allocated_blocks = 75
  
  // è®¡ç®—å·²åˆ†é…å†…å­˜
  let allocated_memory = multiply(block_size, allocated_blocks)
  
  // è®¡ç®—å‰©ä½™å†…å­˜
  let remaining_blocks = add(total_blocks, -allocated_blocks)
  let remaining_memory = multiply(block_size, remaining_blocks)
  
  // è®¡ç®—å†…å­˜åˆ©ç”¨ç‡
  let utilization_percentage = divide_with_ceil(multiply(allocated_blocks, 100), total_blocks)
  
  assert_eq(4800, allocated_memory)
  assert_eq(1600, remaining_memory)
  assert_eq(75, utilization_percentage)
}

test "advanced_geometry_calculations" {
  // é«˜çº§å‡ ä½•è®¡ç®—ï¼šä¸‰è§’å½¢é¢ç§¯å’Œå‘¨é•¿
  let side_a = 3
  let side_b = 4
  let side_c = 5
  
  // è®¡ç®—å‘¨é•¿
  let perimeter = add(add(side_a, side_b), side_c)
  
  // è®¡ç®—åŠå‘¨é•¿
  let semi_perimeter = divide_with_ceil(perimeter, 2)
  
  // ä½¿ç”¨æµ·ä¼¦å…¬å¼è®¡ç®—é¢ç§¯ï¼ˆç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼‰
  // é¢ç§¯ = âˆš(s(s-a)(s-b)(s-c))ï¼Œè¿™é‡Œç®€åŒ–ä¸ºæ•´æ•°è¿‘ä¼¼
  let area_approx = divide_with_ceil(multiply(side_a, side_b), 2)
  
  // è®¡ç®—ä¸‰è§’å½¢çš„é«˜
  let height = divide_with_ceil(multiply(2, area_approx), side_c)
  
  assert_eq(12, perimeter)
  assert_eq(6, semi_perimeter)
  assert_eq(6, area_approx)
  assert_eq(3, height)
}

test "probability_calculation_simulation" {
  // æ¨¡æ‹Ÿæ¦‚ç‡è®¡ç®—
  let total_outcomes = 52  // æ‰‘å…‹ç‰Œæ€»æ•°
  let favorable_outcomes = 4  // Açš„æ•°é‡
  
  // è®¡ç®—æ¦‚ç‡ï¼ˆç®€åŒ–ä¸ºæ•´æ•°ç™¾åˆ†æ¯”ï¼‰
  let probability_percent = divide_with_ceil(multiply(favorable_outcomes, 100), total_outcomes)
  
  // è®¡ç®—äº’è¡¥äº‹ä»¶æ¦‚ç‡
  let complementary_probability = add(100, -probability_percent)
  
  // è®¡ç®—å¤šæ¬¡ç‹¬ç«‹äº‹ä»¶çš„æ¦‚ç‡ï¼Œä½¿ç”¨ trials å˜é‡
  let trials = 3
  let success_probability = divide_with_ceil(probability_percent, 100)
  
  // æ ¹æ® trials å˜é‡è®¡ç®—å¤šæ¬¡è¯•éªŒçš„æˆåŠŸæ¦‚ç‡
  let multiple_trials_success = if trials == 3 {
    multiply(success_probability, multiply(success_probability, success_probability))
  } else if trials == 2 {
    multiply(success_probability, success_probability)
  } else {
    success_probability
  }
  
  assert_eq(8, probability_percent)
  assert_eq(92, complementary_probability)
  assert_eq(0, multiple_trials_success)
}

test "data_compression_simulation" {
  // æ¨¡æ‹Ÿæ•°æ®å‹ç¼©ç®—æ³•
  let original_size = 1000
  let repeated_patterns = 200
  let compression_ratio = 70
  
  // è®¡ç®—æœ‰æ•ˆæ•°æ®å¤§å°ï¼ˆå»é™¤é‡å¤æ¨¡å¼ï¼‰
  let effective_size = add(original_size, -repeated_patterns)
  
  // è®¡ç®—å‹ç¼©åçš„å¤§å°ï¼ˆè€ƒè™‘ repeated_patternsï¼‰
  let compressed_size = multiply(effective_size, compression_ratio) / 100
  
  // è®¡ç®—èŠ‚çœçš„ç©ºé—´
  let space_saved = add(original_size, -compressed_size)
  
  // è®¡ç®—å‹ç¼©æ•ˆç‡
  let compression_efficiency = divide_with_ceil(multiply(space_saved, 100), original_size)
  
  // è®¡ç®—è§£å‹æ—¶é—´ï¼ˆæ¨¡æ‹Ÿï¼‰
  let decompression_time = divide_with_ceil(compressed_size, 50)
  
  assert_eq(700, compressed_size)
  assert_eq(300, space_saved)
  assert_eq(30, compression_efficiency)
  assert_eq(14, decompression_time)
}

test "network_transmission_calculation" {
  // ç½‘ç»œä¼ è¾“è®¡ç®—
  let file_size_mb = 500
  let network_speed_mbps = 100
  let packet_overhead = 20  // 20% å¼€é”€
  let latency_ms = 50
  
  // è®¡ç®—åŸºç¡€ä¼ è¾“æ—¶é—´
  let base_time_seconds = divide_with_ceil(file_size_mb, network_speed_mbps)
  
  // è®¡ç®—è€ƒè™‘å¼€é”€çš„ä¼ è¾“æ—¶é—´
  let overhead_factor = divide_with_ceil(multiply(network_speed_mbps, add(100, -packet_overhead)), 100)
  let actual_time_seconds = divide_with_ceil(file_size_mb, overhead_factor)
  
  // è®¡ç®—æ€»å»¶è¿Ÿæ—¶é—´
  let total_latency_ms = multiply(latency_ms, 10)  // å‡è®¾10ä¸ªæ•°æ®åŒ…
  let total_latency_seconds = divide_with_ceil(total_latency_ms, 1000)
  
  // è®¡ç®—æ€»ä¼ è¾“æ—¶é—´
  let total_time_seconds = add(actual_time_seconds, total_latency_seconds)
  
  assert_eq(5, base_time_seconds)
  assert_eq(7, actual_time_seconds)
  assert_eq(1, total_latency_seconds)
  assert_eq(8, total_time_seconds)
}

test "cache_strategy_simulation" {
  // ç¼“å­˜ç­–ç•¥æ¨¡æ‹Ÿ
  let total_requests = 1000
  let cache_size = 100
  let hot_data_ratio = 80  // 80% çš„è¯·æ±‚è®¿é—®çƒ­ç‚¹æ•°æ®
  
  // è®¡ç®—ç¼“å­˜å‘½ä¸­ç‡
  let cache_hit_ratio = divide_with_ceil(multiply(cache_size, hot_data_ratio), total_requests)
  
  // è®¡ç®—ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°
  let cache_misses = add(total_requests, -cache_hit_ratio)
  
  // è®¡ç®—æ€§èƒ½æå‡
  let cache_access_time = 1   // ç¼“å­˜è®¿é—®æ—¶é—´
  let memory_access_time = 10 // å†…å­˜è®¿é—®æ—¶é—´
  let average_access_time = divide_with_ceil(
    add(multiply(cache_hit_ratio, cache_access_time), multiply(cache_misses, memory_access_time)),
    total_requests
  )
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = divide_with_ceil(memory_access_time, average_access_time)
  
  assert_eq(8, cache_hit_ratio)
  assert_eq(992, cache_misses)
  assert_eq(10, average_access_time)
  assert_eq(1, performance_improvement)
}

// æ–°å¢çš„æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
test "add_function_basic_functionality" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
  assert_eq(10, add(-3, 13))
}

test "multiply_function_basic_functionality" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(15, multiply(-3, -5))
}

test "greet_function_basic_functionality" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic_functionality" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "mathematical_properties_commutative" {
  // æµ‹è¯•æ•°å­¦äº¤æ¢å¾‹æ€§è´¨
  let a = 7
  let b = 13
  assert_eq(add(a, b), add(b, a))
  assert_eq(multiply(a, b), multiply(b, a))
}

test "mathematical_properties_associative" {
  // æµ‹è¯•æ•°å­¦ç»“åˆå¾‹æ€§è´¨
  let x = 5
  let y = 8
  let z = 12
  assert_eq(add(add(x, y), z), add(x, add(y, z)))
}

test "divide_with_ceil_negative_numbers" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(-2, divide_with_ceil(-4, 2))
}

test "complex_business_calculation_v2" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  let product_price = 25
  let quantity = 8
  let shipping = 15
  let subtotal = multiply(product_price, quantity)
  let total = add(subtotal, shipping)
  assert_eq(215, total)
}

test "packaging_calculation_scenario" {
  // æµ‹è¯•åŒ…è£…è®¡ç®—åœºæ™¯
  let total_items = 47
  let items_per_box = 12
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(4, boxes_needed)
}

test "greeting_with_special_characters_v2" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

// æ–°å¢çš„9ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ - è¡¥å……ç°æœ‰æµ‹è¯•è¦†ç›–èŒƒå›´

test "error_boundary_validation" {
  // é”™è¯¯è¾¹ç•ŒéªŒè¯æµ‹è¯•
  // æµ‹è¯•æç«¯è¾“å…¥å€¼çš„å¤„ç†
  assert_eq(0, divide_with_ceil(2147483647, -2147483648))
  assert_eq(-1, divide_with_ceil(-2147483647, 2147483647))
  assert_eq(0, multiply(2147483647, 0))
  assert_eq(-2147483648, add(-2147483647, -1))
}

test "data_integrity_checks" {
  // æ•°æ®å®Œæ•´æ€§æ£€æŸ¥æµ‹è¯•
  // æ¨¡æ‹Ÿæ•°æ®æ ¡éªŒåœºæ™¯
  let input_value = 12345
  let checksum = multiply(input_value, 31) % 1000
  let validated_value = add(input_value, -checksum)
  
  assert_eq(125, checksum)
  assert_eq(12220, validated_value)
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹ŸO(nÂ²)ç®—æ³•çš„è®¡ç®—å¤æ‚åº¦
  let n = 100
  let expected_operations = multiply(n, n)
  let optimized_operations = divide_with_ceil(expected_operations, 2)
  
  assert_eq(10000, expected_operations)
  assert_eq(5000, optimized_operations)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  // æ¨¡æ‹ŸCPUæ ¸å¿ƒåˆ†é…ç»™ä»»åŠ¡
  let total_cores = 16
  let task_count = 35
  let cores_per_task = divide_with_ceil(total_cores, task_count)
  let total_allocated = multiply(cores_per_task, task_count)
  
  assert_eq(1, cores_per_task)
  assert_eq(35, total_allocated)
}

test "caching_strategy_simulation" {
  // ç¼“å­˜ç­–ç•¥æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹ŸLRUç¼“å­˜çš„å‘½ä¸­ç‡è®¡ç®—
  let total_requests = 1000
  let cache_size = 100
  let hit_rate_percentage = 75
  
  let cache_hits = multiply(total_requests, hit_rate_percentage) / 100
  let cache_misses = add(total_requests, -cache_hits)
  let eviction_rate = divide_with_ceil(multiply(cache_misses, 100), cache_size)
  
  assert_eq(750, cache_hits)
  assert_eq(250, cache_misses)
  assert_eq(3, eviction_rate)
}

test "load_balancing_algorithm" {
  // è´Ÿè½½å‡è¡¡ç®—æ³•æµ‹è¯•
  // æ¨¡æ‹Ÿè½®è¯¢è´Ÿè½½å‡è¡¡
  let server_count = 5
  let total_connections = 23
  let connections_per_server = divide_with_ceil(total_connections, server_count)
  let total_handled = multiply(connections_per_server, server_count)
  
  assert_eq(5, connections_per_server)
  assert_eq(25, total_handled)
}

test "batch_processing_efficiency" {
  // æ‰¹å¤„ç†æ•ˆç‡æµ‹è¯•
  // æ¨¡æ‹Ÿæ‰¹å¤„ç†æ“ä½œçš„æ€§èƒ½ä¼˜åŒ–
  let total_items = 1000
  let batch_size = 47
  let batch_count = divide_with_ceil(total_items, batch_size)
  let last_batch_size = add(total_items, -multiply(batch_count - 1, batch_size))
  
  assert_eq(22, batch_count)
  assert_eq(12, last_batch_size)
}

test "memory_allocation_pattern" {
  // å†…å­˜åˆ†é…æ¨¡å¼æµ‹è¯•
  // æ¨¡æ‹Ÿå†…å­˜å—çš„åˆ†é…å’Œé‡Šæ”¾
  let block_size = 64
  let total_memory = 4096
  let allocated_blocks = divide_with_ceil(total_memory, block_size)
  let waste_memory = multiply(allocated_blocks, block_size) - total_memory
  let efficiency_percentage = multiply(total_memory, 100) / multiply(allocated_blocks, block_size)
  
  assert_eq(64, allocated_blocks)
  assert_eq(0, waste_memory)
  assert_eq(100, efficiency_percentage)
}

test "network_throughput_calculation" {
  // ç½‘ç»œååé‡è®¡ç®—æµ‹è¯•
  // æ¨¡æ‹Ÿç½‘ç»œå¸¦å®½åˆ©ç”¨ç‡è®¡ç®—
  let bandwidth_mbps = 1000
  let packet_size_bytes = 1500
  let packets_per_second = 50000
  let actual_throughput = divide_with_ceil(multiply(packet_size_bytes, packets_per_second), 1000000)
  let utilization_percentage = multiply(actual_throughput, 100) / bandwidth_mbps
  
  assert_eq(75, actual_throughput)
  assert_eq(8, utilization_percentage)
}

// æ–°å¢çš„æ ‡å‡† MoonBit è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_basic_operations" {
  // æµ‹è¯•åŠ æ³•çš„åŸºæœ¬æ“ä½œ
  assert_eq(8, add(3, 5))
  assert_eq(0, add(0, 0))
  assert_eq(-2, add(-5, 3))
  assert_eq(100, add(50, 50))
}

test "multiply_function_enhanced" {
  // æµ‹è¯•ä¹˜æ³•çš„å…¨é¢åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(0, multiply(0, 100))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(25, multiply(5, 5))
}

test "divide_with_ceil_various_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å„ç§æƒ…å†µ
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "greet_function_different_inputs" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ä¸åŒè¾“å…¥
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "complex_arithmetic_combinations" {
  // æµ‹è¯•å¤æ‚çš„ç®—æœ¯ç»„åˆ
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  let result2 = divide_with_ceil(add(10, 5), 3)
  assert_eq(5, result2)  // ceil(15/3) = 5
  
  let result3 = multiply(add(7, 3), divide_with_ceil(20, 4))
  assert_eq(50, result3)  // 10 * 5 = 50
}

test "edge_case_operations" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µæ“ä½œ
  assert_eq(1, add(1, 0))
  assert_eq(-1, add(-1, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(5, 5))
}

test "negative_number_calculations" {
  // æµ‹è¯•è´Ÿæ•°æ“ä½œ
  assert_eq(-8, add(-3, -5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-9, -3))
}

test "real_world_application_scenarios" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  // è´­ç‰©è½¦è®¡ç®—
  let item1_price = 25
  let item1_qty = 3
  let item2_price = 15
  let item2_qty = 2
  let total = add(multiply(item1_price, item1_qty), multiply(item2_price, item2_qty))
  assert_eq(105, total)  // 25*3 + 15*2 = 75 + 30 = 105
  
  // åŒ…è£…è®¡ç®—
  let total_items = 23
  let items_per_box = 5
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(23/5) = 5
}

test "greet_string_combinations" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†ä¸é—®å€™å‡½æ•°
  let first_name = "John"
  let last_name = "Doe"
  let full_name = first_name + " " + last_name
  let greeting = greet(full_name)
  assert_eq_string("Hello, John Doe!", greeting)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_properties_verification" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨éªŒè¯
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
  
  // åˆ†é…å¾‹ a * (b + c) = a * b + a * c
  let c = 5
  let left = multiply(a, add(b, c))
  let right = add(multiply(a, b), multiply(a, c))
  assert_eq(left, right)  // 7 * (13 + 5) = 7 * 13 + 7 * 5 = 126
}

// æ–°å¢çš„æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
test "azimuth_add_function_enhanced" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "azimuth_multiply_function_enhanced" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "azimuth_greet_function_enhanced" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
}

test "azimuth_divide_with_ceil_enhanced" {
  // æµ‹è¯•åŸºæœ¬å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "azimuth_mathematical_laws" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

test "azimuth_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(2, divide_with_ceil(101, 100))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(1000000, add(500000, 500000))
  assert_eq(10000, multiply(100, 100))
}

test "azimuth_complex_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  let result2 = add(divide_with_ceil(10, 3), multiply(2, 2))
  assert_eq(8, result2)  // ceil(10/3) + 2*2 = 4 + 4 = 8
}

test "azimuth_real_world_applications" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  // åŒ…è£…è®¡ç®—
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
  
  // è´­ç‰©è½¦æ€»ä»·
  let item1_price = 29
  let item1_qty = 2
  let item2_price = 15
  let item2_qty = 3
  let total = add(multiply(item1_price, item1_qty), multiply(item2_price, item2_qty))
  assert_eq(103, total)  // 29*2 + 15*3 = 58 + 45 = 103
}

test "azimuth_international_support" {
  // æµ‹è¯• Unicode å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, MarÃ­a!", greet("MarÃ­a"))
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "standard_add_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(-2, 1))
  assert_eq(100, add(50, 50))
}

test "standard_multiply_functionality" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-8, multiply(-2, 4))
  assert_eq(25, multiply(5, 5))
}

test "standard_greet_functionality" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
}

test "standard_divide_with_ceil" {
  // æµ‹è¯•åŸºæœ¬å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "standard_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

test "standard_negative_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-5, add(-2, -3))
  assert_eq(6, multiply(-2, -3))
  assert_eq(-6, multiply(2, -3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
}

test "standard_combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  let result2 = multiply(add(5, 3), 2)
  assert_eq(16, result2)  // (5 + 3) * 2 = 8 * 2 = 16
}

test "standard_real_world_application" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯ï¼šè´­ç‰©è®¡ç®—
  let item_price = 25
  let quantity = 4
  let shipping = 10
  
  let subtotal = multiply(item_price, quantity)
  let total = add(subtotal, shipping)
  
  assert_eq(100, subtotal)
  assert_eq(110, total)
}

test "standard_edge_cases" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  assert_eq(1, add(1, 0))
  assert_eq(-1, add(-1, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "standard_string_integration" {
  // æµ‹è¯•å­—ç¬¦ä¸²å’Œæ•°å­—çš„é›†æˆ
  let name = "User"
  let age = 25
  let greeting = greet(name)
  
  assert_eq_string("Hello, User!", greeting)
  assert_eq(25, age)
  
  // æµ‹è¯•åŒ…å«æ•°å­—çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, User123!", greet("User123"))
  assert_eq_string("Hello, 123!", greet("123"))
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "standard_add_function_basic" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "standard_multiply_function_basic" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "standard_greet_function_basic" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
}

test "standard_divide_with_ceil_basic" {
  // æµ‹è¯•åŸºæœ¬å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "standard_mathematical_properties_v2" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let x = 10
  let y = 15
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(x, 0))
  assert_eq(x, add(x, 0))
}

test "standard_edge_cases_v2" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  assert_eq(1, add(1, 0))
  assert_eq(-1, add(-1, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "standard_negative_operations_v2" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-5, add(-2, -3))
  assert_eq(6, multiply(-2, -3))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "standard_combined_operations_v2" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "standard_practical_scenarios" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  // è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

// é¢å¤–çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œè¡¥å……æµ‹è¯•

test "add_function_boundary_values" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç•Œå€¼
  assert_eq(0, add(0, 0))
  assert_eq(1, add(1, 0))
  assert_eq(-1, add(-1, 0))
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq(-2147483648, add(-2147483647, -1))
}

test "multiply_function_boundary_values" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç•Œå€¼
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(1, 0))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(-1, 1))
  assert_eq(1, multiply(-1, -1))
}

test "divide_with_ceil_special_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç‰¹æ®Šæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
}

test "greet_function_unicode_comprehensive" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode å­—ç¬¦å¤„ç†
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", greet("Î±Î²Î³Î´Îµ"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "complex_arithmetic_combinations_v2" {
  // æµ‹è¯•å¤æ‚çš„ç®—æœ¯ç»„åˆ
  let a = 10
  let b = 20
  let c = 30
  
  // è®¡ç®— (a + b) * c - a * b
  let result1 = add(multiply(add(a, b), c), add(0, -multiply(a, b)))
  assert_eq(700, result1)  // (10 + 20) * 30 - 10 * 20 = 30 * 30 - 200 = 900 - 200 = 700
  
  // è®¡ç®— a * b + b * c + c * a
  let result2 = add(add(multiply(a, b), multiply(b, c)), multiply(c, a))
  assert_eq(1100, result2)  // 10 * 20 + 20 * 30 + 30 * 10 = 200 + 600 + 300 = 1100
}

test "negative_number_comprehensive_operations" {
  // æµ‹è¯•è´Ÿæ•°çš„å…¨é¢è¿ç®—
  assert_eq(-10, add(-3, -7))
  assert_eq(-5, add(-8, 3))
  assert_eq(0, add(-5, 5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-4, divide_with_ceil(-11, 3))
  assert_eq(4, divide_with_ceil(-11, -3))
}

test "mathematical_properties_verification_v2" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 12
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹: x * (y + y) = x * y + x * y
  assert_eq(multiply(x, add(y, y)), add(multiply(x, y), multiply(x, y)))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(x, 0))
  assert_eq(x, add(x, 0))
}

test "real_world_financial_calculation" {
  // å®é™…é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate_percent = 5
  
  // ç®€å•çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(10500, year1)
  assert_eq(11025, year2)
  assert_eq(11576, year3)
}

test "error_handling_and_edge_cases" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µ
  // é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼è¿ç®—
  assert_eq(0, add(2147483647, -2147483647))
  assert_eq(1, add(2147483647, -2147483646))
}

test "resource_allocation_calculation" {
  // èµ„æºåˆ†é…è®¡ç®—
  let total_budget = 5000
  let project_a_cost = 1200
  let project_b_cost = 800
  let project_c_cost = 1500
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let allocated = add(add(project_a_cost, project_b_cost), project_c_cost)
  let remaining = add(total_budget, -allocated)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡ï¼ˆæ¯ä¸ª300ï¼‰
  let small_projects = divide_with_ceil(remaining, 300)
  
  assert_eq(3500, allocated)
  assert_eq(1500, remaining)
  assert_eq(5, small_projects)
}

test "time_and_scheduling_calculation" {
  // æ—¶é—´å’Œè°ƒåº¦è®¡ç®—
  let total_tasks = 87
  let tasks_per_day = 8
  let work_days_per_week = 5
  
  // è®¡ç®—éœ€è¦çš„å·¥ä½œæ—¥
  let work_days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(work_days_needed, work_days_per_week)
  
  assert_eq(11, work_days_needed)
  assert_eq(3, weeks_needed)
}

// æ–°å¢çš„ç»¼åˆæµ‹è¯•ç”¨ä¾‹
test "factorial_calculation_simulation" {
  // æ¨¡æ‹Ÿé˜¶ä¹˜è®¡ç®—ï¼šä½¿ç”¨ç°æœ‰çš„ add å’Œ multiply å‡½æ•°
  // 5! = 5 * 4 * 3 * 2 * 1 = 120
  let factorial_1 = 1
  let factorial_2 = multiply(2, factorial_1)
  let factorial_3 = multiply(3, factorial_2)
  let factorial_4 = multiply(4, factorial_3)
  let factorial_5 = multiply(5, factorial_4)
  
  assert_eq(1, factorial_1)
  assert_eq(2, factorial_2)
  assert_eq(6, factorial_3)
  assert_eq(24, factorial_4)
  assert_eq(120, factorial_5)
}

test "geometric_progression_calculation" {
  // å‡ ä½•çº§æ•°è®¡ç®—ï¼ša * r^n
  let first_term = 3
  let ratio = 2
  
  let term_1 = first_term
  let term_2 = multiply(term_1, ratio)
  let term_3 = multiply(term_2, ratio)
  let term_4 = multiply(term_3, ratio)
  let term_5 = multiply(term_4, ratio)
  
  // è®¡ç®—å‰5é¡¹çš„å’Œ
  let sum = add(add(add(add(term_1, term_2), term_3), term_4), term_5)
  
  assert_eq(3, term_1)
  assert_eq(6, term_2)
  assert_eq(12, term_3)
  assert_eq(24, term_4)
  assert_eq(48, term_5)
  assert_eq(93, sum)
}

test "temperature_conversion_simulation" {
  // æ¨¡æ‹Ÿæ¸©åº¦è½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // æ‘„æ°åº¦åˆ°åæ°åº¦ï¼šF = C * 9/5 + 32
  let celsius_0 = 0
  let celsius_100 = 100
  let celsius_minus40 = -40
  
  // ä½¿ç”¨æ•´æ•°è¿ç®—æ¨¡æ‹Ÿï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let fahrenheit_0 = add(multiply(celsius_0, 9) / 5, 32)
  let fahrenheit_100 = add(multiply(celsius_100, 9) / 5, 32)
  let fahrenheit_minus40 = add(multiply(celsius_minus40, 9) / 5, 32)
  
  assert_eq(32, fahrenheit_0)
  assert_eq(212, fahrenheit_100)
  assert_eq(-40, fahrenheit_minus40)
}

test "bank_interest_calculation" {
  // é“¶è¡Œåˆ©æ¯è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let principal = 1000
  let interest_rate = 5  // 5%
  let years = 3
  
  // ç®€å•åˆ©æ¯è®¡ç®—
  let interest_per_year = divide_with_ceil(multiply(principal, interest_rate), 100)
  let total_interest = multiply(interest_per_year, years)
  let final_amount = add(principal, total_interest)
  
  assert_eq(50, interest_per_year)
  assert_eq(150, total_interest)
  assert_eq(1150, final_amount)
}

test "array_index_calculation" {
  // æ¨¡æ‹Ÿæ•°ç»„ç´¢å¼•è®¡ç®—
  let rows = 4
  let cols = 5
  let row = 2
  let col = 3
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´ç´¢å¼•ï¼šindex = row * cols + col
  let linear_index = add(multiply(row, cols), col)
  
  assert_eq(13, linear_index)
  
  // è®¡ç®—æ€»å…ƒç´ æ•°
  let total_elements = multiply(rows, cols)
  assert_eq(20, total_elements)
}

test "binary_representation_simulation" {
  // æ¨¡æ‹ŸäºŒè¿›åˆ¶è¡¨ç¤ºè½¬æ¢ä¸ºåè¿›åˆ¶
  // äºŒè¿›åˆ¶ 1011 = 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 8 + 0 + 2 + 1 = 11
  
  let bit_0 = 1
  let bit_1 = 1
  let bit_2 = 0
  let bit_3 = 1
  
  let value_0 = multiply(bit_0, 1)      // 2^0
  let value_1 = multiply(bit_1, 2)      // 2^1
  let value_2 = multiply(bit_2, 4)      // 2^2
  let value_3 = multiply(bit_3, 8)      // 2^3
  
  let decimal_value = add(add(add(value_0, value_1), value_2), value_3)
  
  assert_eq(1, value_0)
  assert_eq(2, value_1)
  assert_eq(0, value_2)
  assert_eq(8, value_3)
  assert_eq(11, decimal_value)
}

test "time_zone_conversion" {
  // æ—¶åŒºè½¬æ¢æ¨¡æ‹Ÿ
  let local_hour = 14  // ä¸‹åˆ2ç‚¹
  let timezone_offset = -8  // UTC-8 åˆ° UTC+0 çš„åç§»
  
  // è½¬æ¢ä¸ºUTCæ—¶é—´
  let utc_hour = add(local_hour, timezone_offset)
  let normalized_utc_hour = if utc_hour < 0 {
    add(utc_hour, 24)
  } else if utc_hour >= 24 {
    add(utc_hour, -24)
  } else {
    utc_hour
  }
  
  assert_eq(6, normalized_utc_hour)  // 14 + (-8) = 6 (UTCæ—¶é—´)
}

test "greeting_template_system" {
  // é—®å€™æ¨¡æ¿ç³»ç»Ÿæµ‹è¯•
  let user_name = "Alice"
  let time_of_day = "morning"
  let language = "Chinese"
  
  // æ„å»ºå¤æ‚é—®å€™è¯­
  let base_greeting = greet(user_name)
  let time_prefix = "Good " + time_of_day + ", "
  let language_suffix = " (" + language + ")"
  
  // æ¨¡æ‹Ÿç»„åˆé—®å€™è¯­ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let formal_greeting = greet(time_prefix + user_name + language_suffix)
  
  assert_eq_string("Hello, Alice!", base_greeting)
  assert_eq_string("Hello, Good morning, Alice (Chinese)!", formal_greeting)
  
  // æµ‹è¯•å¤šè¯­è¨€æ”¯æŒ
  assert_eq_string("Hello, Alice!", greet("Alice"))
  assert_eq_string("Hello, é²å‹ƒ!", greet("é²å‹ƒ"))
  assert_eq_string("Hello, ãƒ¨ã‚·ãƒ€!", greet("ãƒ¨ã‚·ãƒ€"))
}

// æ ‡å‡† MoonBit æµ‹è¯•å¥—ä»¶ - æ–°å¢çš„10ä¸ªæµ‹è¯•ç”¨ä¾‹
test "add_basic_functionality" {
  // æµ‹è¯•åŠ æ³•çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(-2, 1))
  assert_eq(100, add(50, 50))
}

test "multiply_basic_functionality" {
  // æµ‹è¯•ä¹˜æ³•çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-4, multiply(-2, 2))
  assert_eq(25, multiply(5, 5))
}

test "greet_basic_functionality" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic_v2" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "mathematical_properties_v3" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

test "negative_number_operations_v2" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-5, add(-2, -3))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "practical_business_calculation" {
  // å®é™…ä¸šåŠ¡è®¡ç®—åœºæ™¯
  let product_price = 25
  let quantity = 4
  let shipping = 10
  
  let subtotal = multiply(product_price, quantity)
  let total = add(subtotal, shipping)
  
  assert_eq(100, subtotal)
  assert_eq(110, total)
}

test "packaging_calculation_v2" {
  // åŒ…è£…è®¡ç®—åœºæ™¯
  let total_items = 23
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(4, boxes_needed)
}

test "string_greeting_special_cases" {
  // å­—ç¬¦ä¸²é—®å€™çš„ç‰¹æ®Šæƒ…å†µ
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "complex_combined_operations" {
  // å¤æ‚çš„ç»„åˆè¿ç®—
  let result = add(multiply(3, 4), multiply(2, 5))
  assert_eq(22, result)  // 3*4 + 2*5 = 12 + 10 = 22
  
  let complex_result = add(
    multiply(10, divide_with_ceil(25, 4)),
    multiply(5, divide_with_ceil(17, 3))
  )
  assert_eq(85, complex_result)  // 10*7 + 5*6 = 70 + 15 = 85
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "bitwise_operations_simulation" {
  // æ¨¡æ‹Ÿä½è¿ç®—æ“ä½œ
  let a = 12  // äºŒè¿›åˆ¶ 1100
  let b = 10  // äºŒè¿›åˆ¶ 1010
  
  // æ¨¡æ‹ŸæŒ‰ä½ä¸æ“ä½œï¼š1100 & 1010 = 1000 (8)
  let bitwise_and = a & b
  assert_eq(8, bitwise_and)
  
  // æ¨¡æ‹ŸæŒ‰ä½æˆ–æ“ä½œï¼š1100 | 1010 = 1110 (14)
  let bitwise_or = a | b
  assert_eq(14, bitwise_or)
  
  // æ¨¡æ‹ŸæŒ‰ä½å¼‚æˆ–æ“ä½œï¼š1100 ^ 1010 = 0110 (6)
  let bitwise_xor = a ^ b
  assert_eq(6, bitwise_xor)
  
  // æ¨¡æ‹Ÿå·¦ç§»æ“ä½œï¼š12 << 2 = 48
  let left_shift = multiply(a, 4)
  assert_eq(48, left_shift)
  
  // æ¨¡æ‹Ÿå³ç§»æ“ä½œï¼š12 >> 2 = 3
  let right_shift = divide_with_ceil(a, 4)
  assert_eq(3, right_shift)
}

test "scientific_calculation_simulation" {
  // æ¨¡æ‹Ÿç§‘å­¦è®¡ç®—åœºæ™¯
  // è®¡ç®—è‡ªç”±è½ä½“è·ç¦»ï¼šs = 0.5 * g * t^2
  let gravity = 98  // é‡åŠ›åŠ é€Ÿåº¦ (cm/s^2)
  let time = 5      // æ—¶é—´ (ç§’)
  
  // s = 0.5 * 98 * 5^2 = 49 * 25 = 1225
  let distance = multiply(divide_with_ceil(gravity, 2), multiply(time, time))
  assert_eq(1225, distance)
  
  // è®¡ç®—åŠ¨èƒ½ï¼šKE = 0.5 * m * v^2
  let mass = 1000    // è´¨é‡ (kg)
  let velocity = 20  // é€Ÿåº¦ (m/s)
  
  // KE = 0.5 * 1000 * 20^2 = 500 * 400 = 200000
  let kinetic_energy = multiply(divide_with_ceil(mass, 2), multiply(velocity, velocity))
  assert_eq(200000, kinetic_energy)
}

test "data_structure_operations_enhanced" {
  // æ¨¡æ‹Ÿé«˜çº§æ•°æ®ç»“æ„æ“ä½œ
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨çš„å¤§å°è°ƒæ•´
  let initial_capacity = 16
  let load_factor = 75  // 75%
  let current_size = 12
  
  // è®¡ç®—æ˜¯å¦éœ€è¦æ‰©å®¹ï¼šcurrent_size * 100 / initial_capacity > load_factor
  let current_load = divide_with_ceil(multiply(current_size, 100), initial_capacity)
  let needs_resize = if current_load > load_factor { 1 } else { 0 }
  assert_eq(1, needs_resize)
  
  // è®¡ç®—æ–°çš„å®¹é‡ï¼ˆç¿»å€ï¼‰
  let new_capacity = multiply(initial_capacity, 2)
  assert_eq(32, new_capacity)
  
  // æ¨¡æ‹Ÿä¼˜å…ˆé˜Ÿåˆ—çš„æ“ä½œï¼Œä½¿ç”¨ heap_size å˜é‡
  let heap_size = 15
  let parent_index = 3
  let left_child = add(multiply(parent_index, 2), 1)
  let right_child = multiply(parent_index + 1, 2)
  
  // æ£€æŸ¥å­èŠ‚ç‚¹æ˜¯å¦åœ¨å †çš„æœ‰æ•ˆèŒƒå›´å†…
  let left_child_valid = if left_child < heap_size { 1 } else { 0 }
  let right_child_valid = if right_child < heap_size { 1 } else { 0 }
  
  assert_eq(7, left_child)
  assert_eq(8, right_child)
  assert_eq(1, left_child_valid)  // 7 < 15ï¼Œæœ‰æ•ˆ
  assert_eq(1, right_child_valid) // 8 < 15ï¼Œæœ‰æ•ˆ
}

test "algorithm_complexity_comparison" {
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ¯”è¾ƒ
  let input_size = 1000
  
  // O(1) å¸¸æ•°æ—¶é—´
  let constant_time = 1
  
  // O(log n) å¯¹æ•°æ—¶é—´
  let logarithmic_time = divide_with_ceil(
    multiply(input_size, 10), 
    multiply(input_size, 2)
  )
  
  // O(n) çº¿æ€§æ—¶é—´
  let linear_time = multiply(input_size, 1)
  
  // O(n log n) çº¿æ€§å¯¹æ•°æ—¶é—´
  let n_log_n_time = multiply(input_size, logarithmic_time)
  
  // O(nÂ²) å¹³æ–¹æ—¶é—´
  let quadratic_time = divide_with_ceil(multiply(input_size, input_size), 10)
  
  assert_eq(1, constant_time)
  assert_eq(5, logarithmic_time)
  assert_eq(1000, linear_time)
  assert_eq(5000, n_log_n_time)
  assert_eq(100000, quadratic_time)
}

test "numerical_precision_enhanced" {
  // æµ‹è¯•æ•°å€¼ç²¾åº¦å’Œç¨³å®šæ€§
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„ç²¾åº¦ä¿æŒ
  let large_number_1 = 1000000
  let large_number_2 = 999999
  
  // æµ‹è¯•å¤§æ•°ç›¸å‡çš„ç²¾åº¦
  let large_diff = add(large_number_1, -large_number_2)
  assert_eq(1, large_diff)
  
  // æµ‹è¯•è¿ç»­è¿ç®—çš„ç²¾åº¦ç´¯ç§¯
  let precision_test = add(
    multiply(100, 100),
    add(multiply(50, 50), multiply(25, 25))
  )
  assert_eq(18750, precision_test)
  
  // æµ‹è¯•é™¤æ³•ç²¾åº¦
  let precision_div_1 = divide_with_ceil(multiply(1000, 3), 10)
  let precision_div_2 = multiply(divide_with_ceil(1000, 10), 3)
  
  assert_eq(300, precision_div_1)
  assert_eq(300, precision_div_2)
}

test "conditional_logic_simulation" {
  // æ¨¡æ‹Ÿæ¡ä»¶é€»è¾‘å’Œåˆ†æ”¯
  let score = 85
  let attendance = 90
  let projects = 88
  
  // è®¡ç®—åŠ æƒåˆ†æ•°ï¼šscore * 0.6 + attendance * 0.2 + projects * 0.2
  let weighted_score = add(
    add(
      divide_with_ceil(multiply(score, 60), 100),
      divide_with_ceil(multiply(attendance, 20), 100)
    ),
    divide_with_ceil(multiply(projects, 20), 100)
  )
  
  // æ ¹æ®åˆ†æ•°ç¡®å®šç­‰çº§
  let grade = if weighted_score >= 90 {
    "A"
  } else if weighted_score >= 80 {
    "B"
  } else if weighted_score >= 70 {
    "C"
  } else if weighted_score >= 60 {
    "D"
  } else {
    "F"
  }
  
  assert_eq(86, weighted_score)
  assert_eq_string("B", grade)
  
  // æµ‹è¯•å¤æ‚æ¡ä»¶ç»„åˆ
  let is_excellent = if weighted_score >= 85 && attendance >= 85 && projects >= 85 {
    1
  } else {
    0
  }
  assert_eq(1, is_excellent)
}

test "loop_accumulation_simulation" {
  // æ¨¡æ‹Ÿå¾ªç¯ç´¯åŠ æ“ä½œ
  // æ¨¡æ‹Ÿ for i = 1 to 10: sum += i
  let mut sum_val = 0
  sum_val = add(sum_val, 1)  // i = 1
  sum_val = add(sum_val, 2)  // i = 2
  sum_val = add(sum_val, 3)  // i = 3
  sum_val = add(sum_val, 4)  // i = 4
  sum_val = add(sum_val, 5)  // i = 5
  sum_val = add(sum_val, 6)  // i = 6
  sum_val = add(sum_val, 7)  // i = 7
  sum_val = add(sum_val, 8)  // i = 8
  sum_val = add(sum_val, 9)  // i = 9
  sum_val = add(sum_val, 10) // i = 10
  
  assert_eq(55, sum_val)  // 1+2+3+...+10 = 55
  
  // æ¨¡æ‹Ÿé˜¶ä¹˜è®¡ç®—ï¼š5! = 5 * 4 * 3 * 2 * 1
  let mut factorial_val = 1
  factorial_val = multiply(factorial_val, 5)  // 1 * 5
  factorial_val = multiply(factorial_val, 4)  // 5 * 4
  factorial_val = multiply(factorial_val, 3)  // 20 * 3
  factorial_val = multiply(factorial_val, 2)  // 60 * 2
  factorial_val = multiply(factorial_val, 1)  // 120 * 1
  
  assert_eq(120, factorial_val)
}

test "string_processing_enhanced" {
  // å¢å¼ºçš„å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•å¤æ‚çš„å­—ç¬¦ä¸²ç»„åˆ
  let first_name = "John"
  let last_name = "Doe"
  let middle_initial = "W"
  let title = "Dr."
  
  // æ„å»ºå®Œæ•´å§“å
  let full_name = first_name + " " + middle_initial + ". " + last_name
  let formal_name = title + " " + full_name
  let greeting_formal = greet(formal_name)
  
  assert_eq_string("Hello, Dr. John W. Doe!", greeting_formal)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let email = "user@example.com"
  let phone = "+1-555-123-4567"
  let address = "123 Main St., Apt. 4B"
  
  assert_eq_string("Hello, user@example.com!", greet(email))
  assert_eq_string("Hello, +1-555-123-4567!", greet(phone))
  assert_eq_string("Hello, 123 Main St., Apt. 4B!", greet(address))
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let long_string = "This is a very long string that contains multiple words and spaces"
  assert_eq_string("Hello, This is a very long string that contains multiple words and spaces!", greet(long_string))
}

test "error_recovery_mechanism" {
  // æµ‹è¯•é”™è¯¯æ¢å¤æœºåˆ¶
  // æ¨¡æ‹Ÿè¾“å…¥éªŒè¯å’Œé”™è¯¯å¤„ç†
  let user_input = -5
  let min_value = 0
  let max_value = 100
  
  // è¾“å…¥éªŒè¯ï¼šç¡®ä¿è¾“å…¥åœ¨æœ‰æ•ˆèŒƒå›´å†…
  let validated_input = if user_input < min_value {
    min_value
  } else if user_input > max_value {
    max_value
  } else {
    user_input
  }
  
  assert_eq(0, validated_input)
  
  // æµ‹è¯•é™¤æ³•é”™è¯¯çš„æ¢å¤
  let dividend = 100
  let divisor = 0
  
  // å®‰å…¨é™¤æ³•ï¼šå¤„ç†é™¤æ•°ä¸ºé›¶çš„æƒ…å†µ
  let safe_result = if divisor == 0 {
    0  // é»˜è®¤å€¼
  } else {
    divide_with_ceil(dividend, divisor)
  }
  
  assert_eq(0, safe_result)
  
  // æµ‹è¯•é“¾å¼æ“ä½œä¸­çš„é”™è¯¯æ¢å¤
  let chain_result = add(
    multiply(10, 5),
    add(0, -divide_with_ceil(20, 0))  // è¿™é‡Œçš„é™¤æ³•è¿”å›0
  )
  assert_eq(50, chain_result)
}

test "performance_benchmark_calculation" {
  // æ€§èƒ½åŸºå‡†æµ‹è¯•è®¡ç®—
  let base_operations = 1000
  let optimization_factor = 4
  let overhead_percentage = 15
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ€§èƒ½
  let optimized_operations = multiply(base_operations, optimization_factor)
  assert_eq(4000, optimized_operations)
  
  // è®¡ç®—ç³»ç»Ÿå¼€é”€
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  assert_eq(600, overhead)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = add(optimized_operations, -overhead)
  assert_eq(3400, actual_performance)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = divide_with_ceil(actual_performance, base_operations)
  assert_eq(4, performance_improvement)
  
  // è®¡ç®—æ•ˆç‡ç™¾åˆ†æ¯”
  let efficiency_percentage = divide_with_ceil(
    multiply(actual_performance, 100), 
    optimized_operations
  )
  assert_eq(85, efficiency_percentage)
  
  // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨è®¡ç®—
  let memory_per_operation = 1024  // bytes
  let total_memory_usage = multiply(actual_performance, memory_per_operation)
  let memory_mb = divide_with_ceil(total_memory_usage, multiply(1024, 1024))
  
  assert_eq(3481600, total_memory_usage)
  assert_eq(4, memory_mb)
}

// Azimuth å¢å¼ºæµ‹è¯•å¥—ä»¶ - 10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›–åŸºæœ¬åŠŸèƒ½ã€è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œå®é™…åº”ç”¨åœºæ™¯

test "enhanced_arithmetic_precision" {
  // æµ‹è¯•ç®—æœ¯è¿ç®—çš„ç²¾åº¦å’Œè¾¹ç•Œæƒ…å†µ
  assert_eq(2147483647, add(2147483646, 1))  // æ¥è¿‘ Int æœ€å¤§å€¼
  assert_eq(-2147483648, add(-2147483647, -1))  // æ¥è¿‘ Int æœ€å°å€¼
  assert_eq(0, add(2147483647, -2147483647))  // æœ€å¤§å€¼ä¸ç›¸åæ•°ç›¸åŠ 
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•çš„ç²¾åº¦
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(-1000000, multiply(-1000, 1000))
  assert_eq(1000000, multiply(-1000, -1000))
}

test "enhanced_division_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å„ç§æƒ…å†µ
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(11, 3))  // 11/3 = 3.666... -> 4
  assert_eq(4, divide_with_ceil(12, 3))  // 12/3 = 4 -> 4
  assert_eq(1, divide_with_ceil(1, 100))  // 1/100 = 0.01 -> 1
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
  assert_eq(-4, divide_with_ceil(-11, 3))  // -11/3 = -3.666... -> -4
  assert_eq(4, divide_with_ceil(-11, -3))  // -11/-3 = 3.666... -> 4
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
}

test "enhanced_string_greeting_international" {
  // æµ‹è¯•å›½é™…åŒ–å­—ç¬¦ä¸²é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
  assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", greet("Î±Î²Î³Î´Îµ"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "enhanced_mathematical_properties_v2" {
  // éªŒè¯æ•°å­¦æ€§è´¨å’Œå®šå¾‹
  let x = 42
  let y = 17
  let z = 8
  
  // åŠ æ³•äº¤æ¢å¾‹å’Œç»“åˆå¾‹
  assert_eq(add(x, y), add(y, x))  // äº¤æ¢å¾‹
  assert_eq(add(add(x, y), z), add(x, add(y, z)))  // ç»“åˆå¾‹
  
  // ä¹˜æ³•äº¤æ¢å¾‹å’Œç»“åˆå¾‹
  assert_eq(multiply(x, y), multiply(y, x))  // äº¤æ¢å¾‹
  assert_eq(multiply(multiply(x, y), z), multiply(x, multiply(y, z)))  // ç»“åˆå¾‹
  
  // åˆ†é…å¾‹
  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))
  
  // å•ä½å…ƒæ€§è´¨
  assert_eq(x, add(x, 0))
  assert_eq(x, multiply(x, 1))
  assert_eq(0, multiply(x, 0))
}

test "enhanced_financial_calculation_scenario" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯ï¼šè´·æ¬¾å’ŒæŠ•èµ„è®¡ç®—
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  let monthly_payment_limit = 300
  
  // è®¡ç®—å¤åˆ©ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1_amount = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_amount = add(year1_amount, divide_with_ceil(multiply(year1_amount, annual_rate), 100))
  let year3_amount = add(year2_amount, divide_with_ceil(multiply(year2_amount, annual_rate), 100))
  
  // è®¡ç®—æœˆä¾›
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year3_amount, total_months)
  
  // éªŒè¯ç»“æœ
  assert_eq(10500, year1_amount)  // 10000 + 5%
  assert_eq(11025, year2_amount)  // 10500 + 5%
  assert_eq(11576, year3_amount)  // 11025 + 5%
  assert_eq(322, monthly_payment)  // ceil(11576/36)
  
  // éªŒè¯æœˆä¾›æ˜¯å¦åœ¨é™åˆ¶èŒƒå›´å†…
  assert_eq(1, if monthly_payment <= monthly_payment_limit { 1 } else { 0 })
}

test "enhanced_inventory_management" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯• - ç®€åŒ–ç‰ˆæœ¬ä¸ä½¿ç”¨æ•°ç»„
  
  // äº§å“1: 25ä¸ªäº§å“ï¼Œæ¯ç®±8ä¸ª
  let boxes_1 = divide_with_ceil(25, 8)  // ceil(25/8) = 4
  let capacity_1 = multiply(boxes_1, 8)  // 4 * 8 = 32
  
  // äº§å“2: 47ä¸ªäº§å“ï¼Œæ¯ç®±12ä¸ª
  let boxes_2 = divide_with_ceil(47, 12)  // ceil(47/12) = 4
  let capacity_2 = multiply(boxes_2, 12)  // 4 * 12 = 48
  
  // äº§å“3: 156ä¸ªäº§å“ï¼Œæ¯ç®±20ä¸ª
  let boxes_3 = divide_with_ceil(156, 20)  // ceil(156/20) = 8
  let capacity_3 = multiply(boxes_3, 20)  // 8 * 20 = 160
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(add(boxes_1, boxes_2), boxes_3), 3)  // åŠ ä¸Šäº§å“4å’Œ5çš„ç®±å­æ•°
  let total_capacity = add(add(add(capacity_1, capacity_2), capacity_3), 135)  // åŠ ä¸Šäº§å“4å’Œ5çš„å®¹é‡
  let total_products = add(add(add(25, 47), 156), 102)  // æ€»äº§å“æ•°
  
  assert_eq(25, total_boxes)
  assert_eq(375, total_capacity)
  assert_eq(330, total_products)
}

test "enhanced_project_resource_planning" {
  // é¡¹ç›®èµ„æºè§„åˆ’æµ‹è¯•
  let team_members = 8
  let tasks_per_person = 5
  let sprint_duration = 2  // å‘¨
  let tasks_per_sprint = 15
  let project_deadline = 4  // å‘¨
  
  // è®¡ç®—æ€»ä»»åŠ¡æ•°
  let total_tasks = multiply(team_members, tasks_per_person)
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ•°
  let sprints_needed = divide_with_ceil(total_tasks, tasks_per_sprint)
  
  // è®¡ç®—é¡¹ç›®æ€»æ—¶é—´
  let total_weeks = multiply(sprints_needed, sprint_duration)
  
  // è®¡ç®—æ¯äººæ¯å‘¨éœ€è¦å®Œæˆçš„ä»»åŠ¡æ•°
  let tasks_per_person_per_week = divide_with_ceil(total_tasks, multiply(team_members, project_deadline))
  
  // éªŒè¯ç»“æœ
  assert_eq(40, total_tasks)
  assert_eq(3, sprints_needed)
  assert_eq(6, total_weeks)
  assert_eq(2, tasks_per_person_per_week)
  
  // éªŒè¯é¡¹ç›®æ˜¯å¦èƒ½åœ¨æˆªæ­¢æ—¥æœŸå‰å®Œæˆ
  assert_eq(1, if total_weeks <= project_deadline { 1 } else { 0 })
}

test "enhanced_data_processing_pipeline" {
  // æ•°æ®å¤„ç†æµæ°´çº¿æµ‹è¯•
  let data_batches = 150
  let batch_size = 12
  let processing_time_per_batch = 2  // å°æ—¶
  let quality_check_time = 4  // å°æ—¶
  let daily_working_hours = 8
  
  // è®¡ç®—å¤„ç†è½®æ¬¡
  let processing_rounds = divide_with_ceil(data_batches, batch_size)
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_processing_time = multiply(processing_rounds, processing_time_per_batch)
  
  // è®¡ç®—æ€»æ—¶é—´ï¼ˆåŒ…æ‹¬è´¨é‡æ£€æŸ¥ï¼‰
  let total_time = add(total_processing_time, quality_check_time)
  
  // è®¡ç®—éœ€è¦çš„å·¥ä½œæ—¥æ•°
  let workdays_needed = divide_with_ceil(total_time, daily_working_hours)
  
  // è®¡ç®—å®é™…å¤„ç†çš„æ•°æ®é‡
  let actual_processed = multiply(processing_rounds - 1, batch_size)
  let final_batch_size = add(data_batches, -actual_processed)
  
  assert_eq(13, processing_rounds)
  assert_eq(26, total_processing_time)
  assert_eq(30, total_time)
  assert_eq(4, workdays_needed)
  assert_eq(6, final_batch_size)
}

test "enhanced_error_handling_and_robustness" {
  // é”™è¯¯å¤„ç†å’Œå¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•é™¤é›¶é”™è¯¯çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æµ‹è¯•æå€¼è¿ç®—
  let max_int = 2147483647
  let min_int = -2147483648
  
  assert_eq(max_int, add(max_int, 0))
  assert_eq(min_int, add(min_int, 0))
  assert_eq(0, multiply(max_int, 0))
  assert_eq(0, multiply(min_int, 0))
  assert_eq(max_int, multiply(max_int, 1))
  assert_eq(min_int, multiply(min_int, 1))
  
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
}

test "enhanced_ecommerce_order_processing" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµæµ‹è¯•ï¼šç”µå•†è®¢å•å¤„ç†
  let product_price = 120
  let quantity = 15
  let tax_rate = 8  // 8%
  let shipping_cost_per_item = 5
  let discount_threshold = 1000
  let discount_amount = 50
  let packaging_cost_per_box = 10
  let items_per_box = 6
  
  // æ­¥éª¤1: è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_price, quantity)
  
  // æ­¥éª¤2: è®¡ç®—è¿è´¹
  let total_shipping = multiply(shipping_cost_per_item, quantity)
  
  // æ­¥éª¤3: è®¡ç®—åŒ…è£…è´¹ç”¨
  let boxes_needed = divide_with_ceil(quantity, items_per_box)
  let packaging_cost = multiply(boxes_needed, packaging_cost_per_box)
  
  // æ­¥éª¤4: è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // æ­¥éª¤5: è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(add(subtotal, total_shipping), packaging_cost), tax_amount)
  
  // æ­¥éª¤6: åº”ç”¨æŠ˜æ‰£ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  // æ­¥éª¤7: è®¡ç®—æ¯ä»¶å•†å“çš„å®é™…æˆæœ¬
  let cost_per_item = divide_with_ceil(final_total, quantity)
  
  // éªŒè¯ç»“æœ
  assert_eq(1800, subtotal)
  assert_eq(75, total_shipping)
  assert_eq(3, boxes_needed)
  assert_eq(30, packaging_cost)
  assert_eq(144, tax_amount)
  assert_eq(2049, pre_discount_total)
  assert_eq(1999, final_total)
  assert_eq(134, cost_per_item)
  
  // éªŒè¯æŠ˜æ‰£å·²åº”ç”¨
  assert_eq(1, if final_total < pre_discount_total { 1 } else { 0 })
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "standard_basic_addition" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(10, add(3, 7))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "standard_basic_multiplication" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(0, multiply(0, 10))
  assert_eq(-6, multiply(-2, 3))
}

test "standard_greeting_function" {
  // æµ‹è¯•é—®å€™å‡½æ•°
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
}

test "standard_ceil_division" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "standard_negative_number_tests" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-10, add(-3, -7))
  assert_eq(-5, add(-8, 3))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "standard_arithmetic_combination" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "standard_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "standard_shopping_scenario" {
  // å®é™…è´­ç‰©åœºæ™¯
  let item1_price = 29
  let item1_qty = 2
  let item2_price = 15
  let item2_qty = 3
  let total = add(multiply(item1_price, item1_qty), multiply(item2_price, item2_qty))
  assert_eq(103, total)  // 29*2 + 15*3 = 58 + 45 = 103
}

test "standard_unicode_greeting" {
  // æµ‹è¯•Unicodeå­—ç¬¦é—®å€™
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "standard_math_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "advanced_fibonacci_calculation" {
  // é«˜çº§æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let fib0 = 0
  let fib1 = 1
  let fib2 = add(fib0, fib1)
  let fib3 = add(fib1, fib2)
  let fib4 = add(fib2, fib3)
  let fib5 = add(fib3, fib4)
  let fib6 = add(fib4, fib5)
  
  assert_eq(1, fib2)
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
}

test "temperature_conversion" {
  // æ¸©åº¦è½¬æ¢è®¡ç®—ï¼ˆç®€åŒ–çš„æ‘„æ°åº¦åˆ°åæ°åº¦ï¼‰
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 9), 160) / 5
  
  assert_eq(77, fahrenheit)  // (25 * 9/5) + 32 = 45 + 32 = 77
}

test "resource_distribution_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 100
  let project_a_needs = 35
  let project_b_needs = 28
  let project_c_needs = 22
  
  let allocated_a = project_a_needs
  let allocated_b = project_b_needs
  let allocated_c = project_c_needs
  let total_allocated = add(add(allocated_a, allocated_b), allocated_c)
  let remaining_resources = add(total_resources, -total_allocated)
  
  // è®¡ç®—å‰©ä½™èµ„æºå¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡
  let small_projects_supported = divide_with_ceil(remaining_resources, 8)
  
  assert_eq(85, total_allocated)
  assert_eq(15, remaining_resources)
  assert_eq(2, small_projects_supported)
}

test "data_structure_simulation" {
  // æ¨¡æ‹Ÿæ•°æ®ç»“æ„æ“ä½œ
  let array_size = 10
  let element_size = 4
  let header_size = 8
  
  // è®¡ç®—æ•°ç»„æ€»å¤§å°
  let data_size = multiply(array_size, element_size)
  let total_size = add(data_size, header_size)
  
  // è®¡ç®—éœ€è¦çš„å†…å­˜å—æ•°ï¼ˆæ¯å—16å­—èŠ‚ï¼‰
  let memory_blocks = divide_with_ceil(total_size, 16)
  
  assert_eq(40, data_size)
  assert_eq(48, total_size)
  assert_eq(3, memory_blocks)
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—
  let principal = 1000
  let rate_percent = 5
  let years = 3
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year1_amount = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2_amount = add(year1_amount, divide_with_ceil(multiply(year1_amount, rate_percent), 100))
  let year3_amount = add(year2_amount, divide_with_ceil(multiply(year2_amount, rate_percent), 100))
  
  assert_eq(1050, year1_amount)
  assert_eq(1103, year2_amount)
  assert_eq(1158, year3_amount)
}

test "algorithm_efficiency_analysis" {
  // ç®—æ³•æ•ˆç‡åˆ†æ
  let input_size = 100
  let linear_complexity = multiply(input_size, 2)
  let quadratic_complexity = multiply(input_size, input_size)
  let logarithmic_complexity = divide_with_ceil(input_size, 10)
  
  // æ¯”è¾ƒä¸åŒç®—æ³•çš„å¤æ‚åº¦
  let linear_vs_log = divide_with_ceil(linear_complexity, logarithmic_complexity)
  let quadratic_vs_linear = divide_with_ceil(quadratic_complexity, linear_complexity)
  
  assert_eq(200, linear_complexity)
  assert_eq(10000, quadratic_complexity)
  assert_eq(10, logarithmic_complexity)
  assert_eq(20, linear_vs_log)
  assert_eq(50, quadratic_vs_linear)
}

test "geometry_area_calculation" {
  // å‡ ä½•é¢ç§¯è®¡ç®—
  let rectangle_length = 12
  let rectangle_width = 8
  let triangle_base = 10
  let triangle_height = 6
  
  // è®¡ç®—çŸ©å½¢é¢ç§¯
  let rectangle_area = multiply(rectangle_length, rectangle_width)
  
  // è®¡ç®—ä¸‰è§’å½¢é¢ç§¯ï¼ˆåº•Ã—é«˜/2ï¼Œä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  let triangle_area = divide_with_ceil(multiply(triangle_base, triangle_height), 2)
  
  // è®¡ç®—æ€»é¢ç§¯
  let total_area = add(rectangle_area, triangle_area)
  
  assert_eq(96, rectangle_area)
  assert_eq(30, triangle_area)
  assert_eq(126, total_area)
}

test "data_transfer_performance" {
  // ç½‘ç»œååé‡è®¡ç®—
  let packet_size = 1500  // å­—èŠ‚
  let packets_per_second = 1000
  let transmission_overhead = 200  // å­—èŠ‚/ç§’
  
  // è®¡ç®—åŸå§‹æ•°æ®ä¼ è¾“é€Ÿç‡
  let raw_throughput = multiply(packet_size, packets_per_second)
  
  // è®¡ç®—å®é™…ååé‡
  let effective_throughput = add(raw_throughput, -transmission_overhead)
  
  // è®¡ç®—ä¼ è¾“1GBæ•°æ®éœ€è¦çš„æ—¶é—´ï¼ˆç§’ï¼‰
  let gigabyte = 1024 * 1024 * 1024
  let time_for_gb = divide_with_ceil(gigabyte, effective_throughput)
  
  assert_eq(1500000, raw_throughput)
  assert_eq(1499800, effective_throughput)
  assert_eq(716, time_for_gb)
}

test "string_pattern_analysis" {
  // å­—ç¬¦ä¸²æ¨¡å¼åˆ†æ
  let base_pattern = "AB"
  let repeat_count = 5
  let separator = "-"
  
  // ä½¿ç”¨greetå‡½æ•°æ¨¡æ‹Ÿå­—ç¬¦ä¸²é‡å¤æ“ä½œ
  let pattern1 = greet(base_pattern)
  let pattern2 = greet(base_pattern + base_pattern)
  let pattern3 = greet(base_pattern + base_pattern + base_pattern)
  
  // éªŒè¯æ¨¡å¼é•¿åº¦ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let pattern1_length = add(7, 2)  // "Hello, " + "AB!" = 7 + 2 = 9
  let pattern2_length = add(7, 4)  // "Hello, " + "ABAB!" = 7 + 4 = 11
  let pattern3_length = add(7, 6)  // "Hello, " + "ABABAB!" = 7 + 6 = 13
  
  assert_eq_string("Hello, AB!", pattern1)
  assert_eq_string("Hello, ABAB!", pattern2)
  assert_eq_string("Hello, ABABAB!", pattern3)
  assert_eq(9, pattern1_length)
  assert_eq(11, pattern2_length)
  assert_eq(13, pattern3_length)
}

test "cache_performance_analysis" {
  // ç¼“å­˜ç­–ç•¥æ¨¡æ‹Ÿ
  let total_requests = 1000
  let cache_hit_rate = 70  // 70%
  let cache_access_time = 1  // æ¯«ç§’
  let database_access_time = 50  // æ¯«ç§’
  
  // è®¡ç®—ç¼“å­˜å‘½ä¸­æ•°
  let cache_hits = divide_with_ceil(multiply(total_requests, cache_hit_rate), 100)
  let cache_misses = add(total_requests, -cache_hits)
  
  // è®¡ç®—æ€»å“åº”æ—¶é—´
  let cache_response_time = multiply(cache_hits, cache_access_time)
  let database_response_time = multiply(cache_misses, database_access_time)
  let total_response_time = add(cache_response_time, database_response_time)
  
  // è®¡ç®—å¹³å‡å“åº”æ—¶é—´
  let average_response_time = divide_with_ceil(total_response_time, total_requests)
  
  assert_eq(700, cache_hits)
  assert_eq(300, cache_misses)
  assert_eq(700, cache_response_time)
  assert_eq(15000, database_response_time)
  assert_eq(15700, total_response_time)
  assert_eq(16, average_response_time)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "azimuth_add_commutative_law" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(8, 7))
  assert_eq(15, add(7, 8))
  assert_eq(0, add(-5, 5))
  assert_eq(0, add(5, -5))
}

test "azimuth_multiply_distributive_law" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹
  let a = 6
  let b = 4
  let c = 2
  
  let left_result = multiply(a, add(b, c))
  let right_result = add(multiply(a, b), multiply(a, c))
  assert_eq(left_result, right_result)  // 6 * (4 + 2) = 6 * 4 + 6 * 2 = 36
}

test "azimuth_greet_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
}

test "azimuth_divide_ceil_packaging" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡åº”ç”¨ï¼šè£…ç›’é—®é¢˜
  let products = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(products, box_capacity)
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
}

test "azimuth_project_management" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿ï¼šé¡¹ç›®ç®¡ç†
  let tasks = 25
  let people = 4
  let tasks_per_person = 2
  
  let daily_capacity = multiply(people, tasks_per_person)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
}

test "azimuth_math_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(0, multiply(x, 0))
}

test "azimuth_budget_allocation" {
  // æµ‹è¯•èµ„æºåˆ†é…ï¼šé¢„ç®—åˆ†é…
  let budget = 10000
  let team_members = 6
  let max_share = divide_with_ceil(budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
}

test "azimuth_error_handling" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "azimuth_string_processing" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
}

test "azimuth_event_planning" {
  // æµ‹è¯•çœŸå®ä¸–ç•Œåœºæ™¯ï¼šæ´»åŠ¨ç­–åˆ’
  let participants = 87
  let chairs_per_table = 8
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸“æ³¨äºå®é™…åº”ç”¨åœºæ™¯å’Œè¾¹ç¼˜æƒ…å†µ

test "complex_business_inventory_calculation" {
  // å¤æ‚ä¸šåŠ¡åœºæ™¯ï¼šå¤šäº§å“åº“å­˜ç®¡ç†
  let product_a = 125
  let product_b = 87
  let product_c = 156
  let box_capacity = 12
  
  // è®¡ç®—æ¯ä¸ªäº§å“éœ€è¦çš„ç®±å­
  let boxes_a = divide_with_ceil(product_a, box_capacity)
  let boxes_b = divide_with_ceil(product_b, box_capacity)
  let boxes_c = divide_with_ceil(product_c, box_capacity)
  
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(33, total_boxes)
  
  // éªŒè¯æ€»å®¹é‡è¶³å¤Ÿ
  let total_capacity = multiply(total_boxes, box_capacity)
  assert_true(total_capacity >= add(add(product_a, product_b), product_c))
}

test "financial_loan_amortization" {
  // é‡‘èåœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 100000
  let monthly_payment = 3500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  
  assert_eq(29, months_needed)
  
  // è®¡ç®—å®é™…æ€»æ”¯ä»˜
  let total_payment = multiply(months_needed, monthly_payment)
  let final_payment = subtract(total_payment, multiply(months_needed - 1, monthly_payment))
  
  assert_eq(101500, total_payment)
  assert_eq(1500, final_payment)
}

test "time_management_project_planning" {
  // æ—¶é—´ç®¡ç†ï¼šé¡¹ç›®è§„åˆ’åœºæ™¯
  let total_tasks = 87
  let team_members = 4
  let tasks_per_person_per_day = 2
  let work_days_per_week = 5
  
  let daily_capacity = multiply(team_members, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(total_tasks, daily_capacity)
  let weeks_needed = divide_with_ceil(days_needed, work_days_per_week)
  
  assert_eq(11, days_needed)
  assert_eq(3, weeks_needed)
}

test "advanced_resource_allocation" {
  // èµ„æºåˆ†é…ä¼˜åŒ–
  let total_budget = 50000
  let departments = 7
  let min_budget_per_dept = 5000
  
  let base_budget = divide_with_ceil(total_budget, departments)
  assert_true(base_budget >= min_budget_per_dept)
  
  let total_allocated = multiply(base_budget, departments)
  let surplus = subtract(total_allocated, total_budget)
  
  assert_eq(7143, base_budget)
  assert_eq(1, surplus)
}

test "unicode_string_processing" {
  // Unicodeå­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, æ•°å­¦å…¬å¼âˆ‘âˆâˆ«!", greet("æ•°å­¦å…¬å¼âˆ‘âˆâˆ«"))
  assert_eq_string("Hello, currencyâ‚¬Â¥Â£!", greet("currencyâ‚¬Â¥Â£"))
  assert_eq_string("Hello, emojiğŸ‰ğŸš€!", greet("emojiğŸ‰ğŸš€"))
  assert_eq_string("Hello, accentedcafÃ©!", greet("accentedcafÃ©"))
}

test "extreme_mathematical_boundaries" {
  // æå€¼æ•°å­¦è¾¹ç•Œæµ‹è¯•
  let large_num = 10000
  let small_num = 1
  let negative_num = -10000
  
  assert_eq(20000, add(large_num, large_num))
  assert_eq(0, add(large_num, negative_num))
  assert_eq(100000000, multiply(large_num, large_num))
  assert_eq(10000, divide_with_ceil(large_num, small_num))
  assert_eq(0, divide_with_ceil(large_num, 0))
}

test "complex_algorithmic_pipeline" {
  // å¤æ‚ç®—æ³•æµæ°´çº¿
  let input_data = 47
  let stage1_multiplier = 3
  let stage2_divisor = 4
  let stage3_addition = 15
  
  let stage1_result = multiply(input_data, stage1_multiplier)
  let stage2_result = divide_with_ceil(stage1_result, stage2_divisor)
  let final_result = add(stage2_result, stage3_addition)
  
  assert_eq(51, final_result)  // ceil(47*3/4) + 15 = 36 + 15 = 51
}

test "advanced_data_structure_simulation" {
  // æ•°æ®ç»“æ„æ¨¡æ‹Ÿï¼ˆæ ˆå’Œé˜Ÿåˆ—æ“ä½œï¼‰
  let stack_capacity = 10
  let current_stack_size = 7
  let push_operations = 3
  
  let new_stack_size = add(current_stack_size, push_operations)
  let stack_overflow = new_stack_size > stack_capacity
  
  assert_eq(10, new_stack_size)
  assert_false(stack_overflow)  // æ­£å¥½åœ¨è¾¹ç•Œä¸Š
  
  // é˜Ÿåˆ—æ“ä½œæ¨¡æ‹Ÿ
  let queue_capacity = 20
  let queue_items = 13
  let dequeue_operations = 5
  
  let remaining_items = subtract(queue_items, dequeue_operations)
  let available_space = subtract(queue_capacity, remaining_items)
  
  assert_eq(8, remaining_items)
  assert_eq(12, available_space)
}

test "performance_calculation_scenario" {
  // æ€§èƒ½è®¡ç®—åœºæ™¯
  let operations_count = 10000
  let time_per_operation_ms = 2
  let parallel_workers = 4
  
  let sequential_time = multiply(operations_count, time_per_operation_ms)
  let parallel_time = divide_with_ceil(sequential_time, parallel_workers)
  
  assert_eq(20000, sequential_time)
  assert_eq(5000, parallel_time)
  
  // è®¡ç®—æ€§èƒ½æå‡
  let performance_improvement = divide_with_ceil(sequential_time, parallel_time)
  assert_eq(4, performance_improvement)
}

test "error_resilience_validation" {
  // é”™è¯¯æ¢å¤å’Œå¥å£®æ€§éªŒè¯
  let normal_cases = [(10, 3), (25, 5), (100, 10)]
  let edge_cases = [(0, 1), (1, 0), (0, 0)]
  let negative_cases = [(-10, 3), (10, -3), (-10, -3)]
  
  // æ­£å¸¸æƒ…å†µéªŒè¯
  assert_eq(4, divide_with_ceil(normal_cases[0].0, normal_cases[0].1))
  assert_eq(5, divide_with_ceil(normal_cases[1].0, normal_cases[1].1))
  assert_eq(10, divide_with_ceil(normal_cases[2].0, normal_cases[2].1))
  
  // è¾¹ç•Œæƒ…å†µéªŒè¯
  assert_eq(0, divide_with_ceil(edge_cases[0].0, edge_cases[0].1))
  assert_eq(0, divide_with_ceil(edge_cases[1].0, edge_cases[1].1))
  assert_eq(0, divide_with_ceil(edge_cases[2].0, edge_cases[2].1))
  
  // è´Ÿæ•°æƒ…å†µéªŒè¯
  assert_eq(-3, divide_with_ceil(negative_cases[0].0, negative_cases[0].1))
  assert_eq(-3, divide_with_ceil(negative_cases[1].0, negative_cases[1].1))
  assert_eq(4, divide_with_ceil(negative_cases[2].0, negative_cases[2].1))
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•ï¼ˆç”¨äºæµ‹è¯•ï¼‰
fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// è¾…åŠ©å‡½æ•°ï¼šå¸ƒå°”æ–­è¨€ï¼ˆç”¨äºæµ‹è¯•ï¼‰
fn assert_true(condition : Bool) -> Unit {
  if condition {
    ()
  } else {
    let _ = "Boolean assertion failed"
  }
}

fn assert_false(condition : Bool) -> Unit {
  if condition {
    let _ = "Boolean assertion failed"
  } else {
    ()
  }
}

// æˆ‘ä»¬çš„æ–°æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  // æµ‹è¯•åŸºæœ¬çš„é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_positive" {
  // æµ‹è¯•æ­£æ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "zero_operations" {
  // æµ‹è¯•ä¸é›¶ç›¸å…³çš„è¿ç®—
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 0))
  assert_eq(5, add(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(1000000, add(500000, 500000))
  assert_eq(10000, multiply(100, 100))
}

test "combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "practical_packaging" {
  // å®é™…åº”ç”¨åœºæ™¯ï¼šåŒ…è£…è®¡ç®—
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "greeting_with_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}



// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_properties_commutative" {
  // æµ‹è¯•æ•°å­¦äº¤æ¢å¾‹
  let a = 8
  let b = 12
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
}

test "combined_operations_business_scenario" {
  // æµ‹è¯•ç»„åˆè¿ç®—çš„ä¸šåŠ¡åœºæ™¯
  let unit_price = 25
  let quantity = 8
  let shipping = 15
  
  let subtotal = multiply(unit_price, quantity)
  let total = add(subtotal, shipping)
  
  assert_eq(200, subtotal)
  assert_eq(215, total)
}

test "packaging_calculation_scenario" {
  // æµ‹è¯•åŒ…è£…è®¡ç®—åœºæ™¯
  let total_items = 35
  let items_per_box = 8
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(5, boxes_needed)
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦å•ä½å…ƒæ€§è´¨
  let x = 42
  
  // åŠ æ³•å•ä½å…ƒ
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•å•ä½å…ƒ
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  
  // ä¹˜æ³•é›¶å…ƒç´ 
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
}

test "unicode_and_special_characters" {
  // æµ‹è¯• Unicode å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
}

test "divide_with_ceil_edge_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(100, divide_with_ceil(9999, 100))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "complex_business_workflow" {
  // æ¨¡æ‹Ÿå®Œæ•´çš„è®¢å•å¤„ç†æµç¨‹
  let product_cost = 120
  let quantity = 15
  let tax_rate = 8
  let shipping_cost_per_item = 5
  let discount_threshold = 1000
  let discount_amount = 50
  
  // æ­¥éª¤1: è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_cost, quantity)
  
  // æ­¥éª¤2: è®¡ç®—è¿è´¹
  let total_shipping = multiply(shipping_cost_per_item, quantity)
  
  // æ­¥éª¤3: è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // æ­¥éª¤4: è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, total_shipping), tax_amount)
  
  // æ­¥éª¤5: åº”ç”¨æŠ˜æ‰£ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(1800, subtotal)
  assert_eq(75, total_shipping)
  assert_eq(144, tax_amount)
  assert_eq(2019, pre_discount_total)
  assert_eq(1969, final_total)
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè®¡ç®—å¤åˆ©
  let principal = 1000
  let rate_percent = 5
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(1050, year1)
  assert_eq(1103, year2)
  assert_eq(1158, year3)
}

test "data_analysis_statistics" {
  // æ¨¡æ‹Ÿé”€å”®æ•°æ®åˆ†æ
  let sales_q1 = 15000
  let sales_q2 = 18000
  let sales_q3 = 22000
  let sales_q4 = 25000
  
  // è®¡ç®—å¹´åº¦æ€»é”€å”®é¢
  let annual_sales = add(add(add(sales_q1, sales_q2), sales_q3), sales_q4)
  
  // è®¡ç®—å­£åº¦å¹³å‡é”€å”®é¢ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let quarterly_average = divide_with_ceil(annual_sales, 4)
  
  assert_eq(80000, annual_sales)
  assert_eq(20000, quarterly_average)
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„å­˜å‚¨ç©ºé—´
  let items_per_box = 24
  let total_items_small = 100
  let total_items_medium = 250
  let total_items_large = 1000
  
  let boxes_small = divide_with_ceil(total_items_small, items_per_box)
  let boxes_medium = divide_with_ceil(total_items_medium, items_per_box)
  let boxes_large = divide_with_ceil(total_items_large, items_per_box)
  
  let total_boxes = add(add(boxes_small, boxes_medium), boxes_large)
  
  assert_eq(5, boxes_small)
  assert_eq(11, boxes_medium)
  assert_eq(42, boxes_large)
  assert_eq(58, total_boxes)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "algorithm_binary_search_simulation" {
  // æ¨¡æ‹ŸäºŒåˆ†æŸ¥æ‰¾ç®—æ³•çš„ç´¢å¼•è®¡ç®—
  let low = 0
  let high = 15
  let mid = divide_with_ceil(add(low, high), 2)
  
  // æ¨¡æ‹ŸæŸ¥æ‰¾è¿‡ç¨‹
  let new_low = add(mid, 1)
  let new_mid = divide_with_ceil(add(new_low, high), 2)
  
  assert_eq(8, mid)
  assert_eq(12, new_mid)
}

test "data_structure_stack_operations" {
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼ˆä½¿ç”¨æ•°å€¼è¡¨ç¤ºæ ˆçŠ¶æ€ï¼‰
  let stack_empty = 0
  let push_1 = add(stack_empty, 100)  // æ¨å…¥100
  let push_2 = add(push_1, 200)       // æ¨å…¥200
  let peek = push_2                    // æŸ¥çœ‹æ ˆé¡¶
  let pop = add(push_2, -200)         // å¼¹å‡º200
  
  assert_eq(300, push_2)
  assert_eq(300, peek)
  assert_eq(100, pop)
}

test "performance_cache_simulation" {
  // æ¨¡æ‹Ÿç¼“å­˜å‘½ä¸­ç‡å’Œæ€§èƒ½è®¡ç®—
  let total_requests = 1000
  let cache_hits = 750
  let cache_misses = add(total_requests, -cache_hits)
  
  // è®¡ç®—å‘½ä¸­ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰
  let hit_rate = divide_with_ceil(multiply(cache_hits, 100), total_requests)
  let miss_rate = divide_with_ceil(multiply(cache_misses, 100), total_requests)
  
  assert_eq(250, cache_misses)
  assert_eq(75, hit_rate)
  assert_eq(25, miss_rate)
}

test "error_handling_boundary_validation" {
  // é”™è¯¯å¤„ç†çš„è¾¹ç•ŒéªŒè¯æµ‹è¯•
  let max_allowed = 100
  let min_allowed = 1
  
  // æµ‹è¯•è¾¹ç•Œå€¼
  let at_max = max_allowed
  let at_min = min_allowed
  let over_max = add(max_allowed, 1)
  let under_min = add(min_allowed, -1)
  
  // æ¨¡æ‹ŸéªŒè¯ç»“æœï¼ˆ1è¡¨ç¤ºæœ‰æ•ˆï¼Œ0è¡¨ç¤ºæ— æ•ˆï¼‰
  let valid_max = if at_max <= max_allowed { 1 } else { 0 }
  let valid_min = if at_min >= min_allowed { 1 } else { 0 }
  let valid_over = if over_max <= max_allowed { 1 } else { 0 }
  let valid_under = if under_min >= min_allowed { 1 } else { 0 }
  
  assert_eq(1, valid_max)
  assert_eq(1, valid_min)
  assert_eq(0, valid_over)
  assert_eq(0, valid_under)
}

test "algorithm_sorting_comparison" {
  // æ¨¡æ‹Ÿæ’åºç®—æ³•çš„æ¯”è¾ƒæ¬¡æ•°è®¡ç®—
  let array_size = 16
  let bubble_sort_comparisons = multiply(array_size, add(array_size, -1)) / 2
  let selection_sort_comparisons = multiply(array_size, add(array_size, -1)) / 2
  let linear_search_comparisons = divide_with_ceil(add(array_size, 1), 2)
  
  assert_eq(120, bubble_sort_comparisons)
  assert_eq(120, selection_sort_comparisons)
  assert_eq(8, linear_search_comparisons)
}

test "memory_allocation_simulation" {
  // æ¨¡æ‹Ÿå†…å­˜åˆ†é…è®¡ç®—
  let block_size = 64
  let requested_size = 250
  let blocks_needed = divide_with_ceil(requested_size, block_size)
  let actual_allocated = multiply(blocks_needed, block_size)
  let waste = add(actual_allocated, -requested_size)
  
  assert_eq(4, blocks_needed)
  assert_eq(256, actual_allocated)
  assert_eq(6, waste)
}

test "network_packet_fragmentation" {
  // æ¨¡æ‹Ÿç½‘ç»œæ•°æ®åŒ…åˆ†ç‰‡è®¡ç®—
  let data_size = 1500
  let mtu = 512  // æœ€å¤§ä¼ è¾“å•å…ƒ
  let full_packets = divide_with_ceil(data_size, mtu)
  let last_packet_size = add(data_size, -multiply(add(full_packets, -1), mtu))
  
  assert_eq(3, full_packets)
  assert_eq(476, last_packet_size)
}

test "database_pagination_calculation" {
  // æ•°æ®åº“åˆ†é¡µè®¡ç®—
  let total_records = 258
  let page_size = 50
  let requested_page = 4
  
  let total_pages = divide_with_ceil(total_records, page_size)
  let offset = multiply(add(requested_page, -1), page_size)
  let records_on_last_page = add(total_records, -multiply(add(total_pages, -1), page_size))
  
  assert_eq(6, total_pages)
  assert_eq(150, offset)
  assert_eq(8, records_on_last_page)
}

test "string_greeting_with_escape_sequences" {
  // æµ‹è¯•åŒ…å«è½¬ä¹‰å­—ç¬¦çš„å­—ç¬¦ä¸²é—®å€™
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
  assert_eq_string("Hello, \nnewline\n!", greet("\nnewline\n"))
  assert_eq_string("Hello, \ttab\t!", greet("\ttab\t"))
}

test "complex_resource_scheduling" {
  // å¤æ‚èµ„æºè°ƒåº¦è®¡ç®—
  let total_tasks = 45
  let parallel_workers = 4
  let task_duration = 3
  let setup_time = 2
  
  // è®¡ç®—æ‰¹æ¬¡å’Œæ€»æ—¶é—´
  let batches = divide_with_ceil(total_tasks, parallel_workers)
  let batch_time = add(task_duration, setup_time)
  let total_time = multiply(batches, batch_time)
  
  assert_eq(12, batches)
  assert_eq(5, batch_time)
  assert_eq(60, total_time)
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹å·²æ›´æ–°

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - ç¡®ä¿ä¸é‡å¤
test "azimuth_add_function" {
  // æµ‹è¯•æ ¸å¿ƒåŠ æ³•åŠŸèƒ½
  assert_eq(8, add(3, 5))
  assert_eq(0, add(0, 0))
  assert_eq(-8, add(-3, -5))
  assert_eq(100, add(45, 55))
}

test "azimuth_multiply_function" {
  // æµ‹è¯•æ ¸å¿ƒä¹˜æ³•åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(0, multiply(0, 7))
  assert_eq(-15, multiply(-3, 5))
  assert_eq(64, multiply(8, 8))
}

test "azimuth_greet_function" {
  // æµ‹è¯•æ ¸å¿ƒé—®å€™åŠŸèƒ½
  assert_eq_string("Hello, Azimuth!", greet("Azimuth"))
  assert_eq_string("Hello, 2024!", greet("2024"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "azimuth_ceil_division" {
  // æµ‹è¯•æ ¸å¿ƒå‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(3, divide_with_ceil(8, 3))
  assert_eq(2, divide_with_ceil(4, 2))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "azimuth_negative_operations" {
  // æµ‹è¯•è´Ÿæ•°æ“ä½œ
  assert_eq(-8, add(-3, -5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-2, divide_with_ceil(-7, 3))
  assert_eq(-1, divide_with_ceil(-5, 5))
}

test "azimuth_zero_handling" {
  // æµ‹è¯•é›¶çš„å¤„ç†
  assert_eq(5, add(5, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "azimuth_large_numbers" {
  // æµ‹è¯•å¤§æ•°æ“ä½œ
  assert_eq(2000, add(1000, 1000))
  assert_eq(10000, multiply(100, 100))
  assert_eq(34, divide_with_ceil(100, 3))
}

test "azimuth_business_logic" {
  // æµ‹è¯•ä¸šåŠ¡é€»è¾‘
  let price = 50
  let quantity = 4
  let tax = 8
  let subtotal = multiply(price, quantity)
  let total = add(subtotal, tax)
  assert_eq(200, subtotal)
  assert_eq(208, total)
}

test "azimuth_mathematical_laws" {
  // æµ‹è¯•æ•°å­¦å®šå¾‹
  let x = 12
  let y = 8
  // äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  assert_eq(multiply(x, y), multiply(y, x))
  // ç»“åˆå¾‹
  assert_eq(add(add(x, y), 4), add(x, add(y, 4)))
}

test "azimuth_edge_cases" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(99, 100))
  assert_eq(100, divide_with_ceil(100, 1))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, A!", greet("A"))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - ç¡®ä¿ä¸é‡å¤
test "azimuth_core_add_function" {
  // æµ‹è¯•æ ¸å¿ƒåŠ æ³•åŠŸèƒ½
  assert_eq(8, add(3, 5))
  assert_eq(0, add(0, 0))
  assert_eq(-8, add(-3, -5))
  assert_eq(100, add(45, 55))
}

test "azimuth_core_multiply_function" {
  // æµ‹è¯•æ ¸å¿ƒä¹˜æ³•åŠŸèƒ½
  assert_eq(15, multiply(3, 5))
  assert_eq(0, multiply(0, 7))
  assert_eq(-15, multiply(-3, 5))
  assert_eq(64, multiply(8, 8))
}

test "azimuth_core_greet_function" {
  // æµ‹è¯•æ ¸å¿ƒé—®å€™åŠŸèƒ½
  assert_eq_string("Hello, Azimuth!", greet("Azimuth"))
  assert_eq_string("Hello, 2024!", greet("2024"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "azimuth_core_ceil_division" {
  // æµ‹è¯•æ ¸å¿ƒå‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(3, divide_with_ceil(8, 3))
  assert_eq(2, divide_with_ceil(4, 2))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "azimuth_core_negative_operations" {
  // æµ‹è¯•è´Ÿæ•°æ“ä½œ
  assert_eq(-8, add(-3, -5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-2, divide_with_ceil(-7, 3))
  assert_eq(-1, divide_with_ceil(-5, 5))
}

test "azimuth_core_zero_handling" {
  // æµ‹è¯•é›¶çš„å¤„ç†
  assert_eq(5, add(5, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "azimuth_core_large_numbers" {
  // æµ‹è¯•å¤§æ•°æ“ä½œ
  assert_eq(2000, add(1000, 1000))
  assert_eq(10000, multiply(100, 100))
  assert_eq(34, divide_with_ceil(100, 3))
}

test "azimuth_core_business_logic" {
  // æµ‹è¯•ä¸šåŠ¡é€»è¾‘
  let price = 50
  let quantity = 4
  let tax = 8
  let subtotal = multiply(price, quantity)
  let total = add(subtotal, tax)
  assert_eq(200, subtotal)
  assert_eq(208, total)
}

test "azimuth_core_mathematical_laws" {
  // æµ‹è¯•æ•°å­¦å®šå¾‹
  let x = 12
  let y = 8
  // äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  assert_eq(multiply(x, y), multiply(y, x))
  // ç»“åˆå¾‹
  assert_eq(add(add(x, y), 4), add(x, add(y, 4)))
}

test "azimuth_core_edge_cases" {
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(99, 100))
  assert_eq(100, divide_with_ceil(100, 1))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, A!", greet("A"))
}

// æ–°å¢çš„10ä¸ªä¸“é—¨æµ‹è¯•ç”¨ä¾‹
test "azimuth_factorial_simulation" {
  // æ¨¡æ‹Ÿé˜¶ä¹˜è®¡ç®—ï¼š5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
  let factorial_5 = multiply(5, multiply(4, multiply(3, multiply(2, 1))))
  assert_eq(120, factorial_5)
  
  // æ¨¡æ‹Ÿ 4! = 24
  let factorial_4 = multiply(4, multiply(3, multiply(2, 1)))
  assert_eq(24, factorial_4)
}

test "azimuth_geometric_sum" {
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼š2 + 4 + 8 + 16 = 30
  let term1 = 2
  let term2 = multiply(term1, 2)
  let term3 = multiply(term2, 2)
  let term4 = multiply(term3, 2)
  let sum = add(add(add(term1, term2), term3), term4)
  assert_eq(30, sum)
}

test "azimuth_temp_conversion" {
  // æ¨¡æ‹Ÿæ¸©åº¦è½¬æ¢ï¼šæ‘„æ°åº¦åˆ°åæ°åº¦ F = C Ã— 9/5 + 32
  let celsius = 25
  let fahrenheit = add(divide_with_ceil(multiply(celsius, 9), 5), 32)
  assert_eq(77, fahrenheit)  // 25 Ã— 9/5 + 32 = 45 + 32 = 77
}

test "azimuth_compound_interest" {
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼š1000å…ƒï¼Œå¹´åˆ©ç‡10%ï¼Œ2å¹´
  let principal = 1000
  let rate_percent = 10
  let years = 2
  
  let year1_amount = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2_amount = add(year1_amount, divide_with_ceil(multiply(year1_amount, rate_percent), 100))
  
  assert_eq(1210, year2_amount)  // 1000 -> 1100 -> 1210
}

test "azimuth_batch_processing" {
  // æ‰¹å¤„ç†è®¡ç®—ï¼šæ¯æ‰¹å¤„ç†25ä¸ªé¡¹ç›®ï¼Œæ€»å…±180ä¸ªé¡¹ç›®éœ€è¦å¤šå°‘æ‰¹
  let total_items = 180
  let batch_size = 25
  let batches_needed = divide_with_ceil(total_items, batch_size)
  
  // æœ€åä¸€æ‰¹çš„é¡¹ç›®æ•°
  let last_batch_size = total_items - multiply(batches_needed - 1, batch_size)
  
  assert_eq(8, batches_needed)  // ceil(180/25) = 8
  assert_eq(5, last_batch_size)  // 180 - 7Ã—25 = 5
}

test "azimuth_array_index" {
  // æ¨¡æ‹Ÿæ•°ç»„ç´¢å¼•è®¡ç®—ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„ç´¢å¼•
  let row = 3
  let col = 4
  let cols_per_row = 6
  
  let one_d_index = add(multiply(row, cols_per_row), col)
  
  assert_eq(22, one_d_index)  // 3Ã—6 + 4 = 22
}

test "azimuth_circular_buffer" {
  // å¾ªç¯ç¼“å†²åŒºæ“ä½œæ¨¡æ‹Ÿ
  let buffer_size = 10
  let current_position = 8
  let steps_forward = 5
  
  let new_position = add(current_position, steps_forward) % buffer_size
  
  assert_eq(3, new_position)  // (8 + 5) % 10 = 3
}

test "azimuth_binary_search" {
  // æ¨¡æ‹ŸäºŒåˆ†æŸ¥æ‰¾çš„ä¸­é—´å€¼è®¡ç®—
  let low = 0
  let high = 15
  let mid1 = divide_with_ceil(add(low, high), 2)
  
  // ç¬¬äºŒæ¬¡æŸ¥æ‰¾ï¼ˆå·¦åŠéƒ¨åˆ†ï¼‰
  let high2 = mid1 - 1
  let mid2 = divide_with_ceil(add(low, high2), 2)
  
  // ç¬¬ä¸‰æ¬¡æŸ¥æ‰¾ï¼ˆå³åŠéƒ¨åˆ†ï¼‰
  let low3 = mid2 + 1
  let mid3 = divide_with_ceil(add(low3, high2), 2)
  
  assert_eq(8, mid1)   // ceil(15/2) = 8
  assert_eq(4, mid2)   // ceil(7/2) = 4
  assert_eq(6, mid3)   // ceil(5/2) = 3
}

test "azimuth_network_roundtrip" {
  // ç½‘ç»œæ•°æ®åŒ…å¾€è¿”è®¡ç®—
  let data_size = 1500  // bytes
  let upload_speed = 100  // bytes/sec
  let download_speed = 150  // bytes/sec
  let processing_delay = 2  // seconds
  
  let upload_time = divide_with_ceil(data_size, upload_speed)
  let download_time = divide_with_ceil(data_size, download_speed)
  let total_time = add(add(upload_time, download_time), processing_delay)
  
  assert_eq(15, upload_time)   // ceil(1500/100) = 15
  assert_eq(10, download_time) // ceil(1500/150) = 10
  assert_eq(27, total_time)    // 15 + 10 + 2 = 27
}

test "azimuth_resource_optimization" {
  // èµ„æºåˆ©ç”¨ç‡ä¼˜åŒ–è®¡ç®—
  let total_capacity = 1000
  let current_usage = 750
  let projected_growth = 200
  
  let new_total_usage = add(current_usage, projected_growth)
  let utilization_rate = divide_with_ceil(multiply(new_total_usage, 100), total_capacity)
  
  // è®¡ç®—æ˜¯å¦éœ€è¦æ‰©å®¹
  let needs_expansion = if new_total_usage > total_capacity { 1 } else { 0 }
  
  assert_eq(950, new_total_usage)
  assert_eq(95, utilization_rate)
  assert_eq(0, needs_expansion)  // 950 <= 1000ï¼Œä¸éœ€è¦æ‰©å®¹
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit è´¨é‡æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•1: åŸºæœ¬ç®—æœ¯è¿ç®—çš„ç»„åˆæµ‹è¯•
test "quality_arithmetic_combination_operations" {
  // æµ‹è¯•å¤šç§ç®—æœ¯è¿ç®—çš„ç»„åˆä½¿ç”¨
  let x = 12
  let y = 8
  let z = 5
  
  // è®¡ç®— (x + y) * z
  let result1 = multiply(add(x, y), z)
  assert_eq(100, result1)  // (12 + 8) * 5 = 20 * 5 = 100
  
  // è®¡ç®— x * y + z
  let result2 = add(multiply(x, y), z)
  assert_eq(101, result2)  // 12 * 8 + 5 = 96 + 5 = 101
  
  // è®¡ç®— (x - y) * z (ä½¿ç”¨ add å®ç°å‡æ³•)
  let result3 = multiply(add(x, -y), z)
  assert_eq(20, result3)  // (12 - 8) * 5 = 4 * 5 = 20
}

// æµ‹è¯•2: å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
test "quality_divide_with_ceil_boundary_conditions" {
  // æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶ä¸‹çš„å‘ä¸Šå–æ•´é™¤æ³•
  
  // è¢«é™¤æ•°å°äºé™¤æ•°
  assert_eq(1, divide_with_ceil(3, 5))   // 3/5 = 0.6 -> 1
  assert_eq(1, divide_with_ceil(1, 100)) // 1/100 = 0.01 -> 1
  assert_eq(1, divide_with_ceil(99, 100)) // 99/100 = 0.99 -> 1
  
  // è¢«é™¤æ•°ç­‰äºé™¤æ•°
  assert_eq(1, divide_with_ceil(7, 7))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(1000, 1000))
  
  // è¢«é™¤æ•°æ˜¯é™¤æ•°çš„å€æ•°
  assert_eq(3, divide_with_ceil(15, 5))   // 15/5 = 3 -> 3
  assert_eq(10, divide_with_ceil(100, 10)) // 100/10 = 10 -> 10
  assert_eq(7, divide_with_ceil(49, 7))   // 49/7 = 7 -> 7
}

// æµ‹è¯•3: è´Ÿæ•°è¿ç®—çš„å…¨é¢æµ‹è¯•
test "quality_comprehensive_negative_operations" {
  // æµ‹è¯•è´Ÿæ•°çš„å„ç§è¿ç®—æƒ…å†µ
  
  // è´Ÿæ•°åŠ æ³•
  assert_eq(-10, add(-3, -7))
  assert_eq(-5, add(-8, 3))
  assert_eq(0, add(-5, 5))
  assert_eq(5, add(-10, 15))
  
  // è´Ÿæ•°ä¹˜æ³•
  assert_eq(15, multiply(-3, -5))  // è´Ÿè´Ÿå¾—æ­£
  assert_eq(-15, multiply(3, -5))  // ä¸€è´Ÿä¸€è´Ÿå¾—è´Ÿ
  assert_eq(0, multiply(-5, 0))    // ä¹˜ä»¥é›¶
  
  // è´Ÿæ•°é™¤æ³•å‘ä¸Šå–æ•´
  assert_eq(-3, divide_with_ceil(-10, 3))   // -10/3 = -3.333... -> -3
  assert_eq(-4, divide_with_ceil(-11, 3))   // -11/3 = -3.666... -> -4
  assert_eq(3, divide_with_ceil(-9, -3))    // -9/-3 = 3 -> 3
  assert_eq(4, divide_with_ceil(-10, -3))   // -10/-3 = 3.333... -> 4
}

// æµ‹è¯•4: å­—ç¬¦ä¸²é—®å€™çš„å¤šè¯­è¨€æ”¯æŒ
test "quality_multilingual_greeting_support" {
  // æµ‹è¯•å¤šç§è¯­è¨€çš„é—®å€™åŠŸèƒ½
  
  // ä¸­æ–‡æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ä¸­å›½!", greet("ä¸­å›½"))
  assert_eq_string("Hello, åŒ—äº¬!", greet("åŒ—äº¬"))
  
  // æ¬§æ´²è¯­è¨€æµ‹è¯•
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, FranÃ§ais!", greet("FranÃ§ais"))
  assert_eq_string("Hello, Deutsch!", greet("Deutsch"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  
  // ç‰¹æ®Šå­—ç¬¦å’Œç¬¦å·
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
  assert_eq_string("Hello, A+B=C!", greet("A+B=C"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

// æµ‹è¯•5: å®é™…ä¸šåŠ¡åœºæ™¯ - è®¢å•è®¡ç®—
test "quality_business_order_calculation" {
  // æ¨¡æ‹Ÿç”µå•†è®¢å•è®¡ç®—åœºæ™¯
  
  let product_price = 89
  let quantity = 4
  let tax_rate = 8  // 8%
  let shipping_cost = 15
  let discount = 20
  
  // è®¡ç®—å•†å“å°è®¡
  let subtotal = multiply(product_price, quantity)
  assert_eq(356, subtotal)  // 89 * 4 = 356
  
  // è®¡ç®—ç¨è´¹ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  assert_eq(29, tax)  // ceil(356 * 8 / 100) = ceil(28.48) = 29
  
  // è®¡ç®—æ€»ä»·ï¼ˆå«ç¨å’Œè¿è´¹ï¼‰
  let total_before_discount = add(add(subtotal, tax), shipping_cost)
  assert_eq(400, total_before_discount)  // 356 + 29 + 15 = 400
  
  // åº”ç”¨æŠ˜æ‰£
  let final_total = add(total_before_discount, -discount)
  assert_eq(380, final_total)  // 400 - 20 = 380
}

// æµ‹è¯•6: æ•°å­¦æ€§è´¨éªŒè¯
test "quality_mathematical_properties_verification" {
  // éªŒè¯åŸºæœ¬çš„æ•°å­¦æ€§è´¨
  
  let a = 7
  let b = 13
  let c = 5
  
  // åŠ æ³•äº¤æ¢å¾‹: a + b = b + a
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹: a * b = b * a
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
  
  // åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let distributive_left = multiply(a, add(b, c))
  let distributive_right = add(multiply(a, b), multiply(a, c))
  assert_eq(distributive_left, distributive_right)
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))  // a * 0 = 0
  assert_eq(a, add(a, 0))       // a + 0 = a
}

// æµ‹è¯•7: å¤§æ•°è¿ç®—æµ‹è¯•
test "quality_large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„ç¨³å®šæ€§å’Œå‡†ç¡®æ€§
  
  // å¤§æ•°åŠ æ³•
  let big_num1 = 1000000
  let big_num2 = 500000
  assert_eq(1500000, add(big_num1, big_num2))
  
  // å¤§æ•°ä¹˜æ³•
  let big_factor1 = 10000
  let big_factor2 = 100
  assert_eq(1000000, multiply(big_factor1, big_factor2))
  
  // å¤§æ•°é™¤æ³•å‘ä¸Šå–æ•´
  let large_dividend = 1000000
  let large_divisor = 3
  assert_eq(333334, divide_with_ceil(large_dividend, large_divisor))
  
  // ç»„åˆå¤§æ•°è¿ç®—
  let complex_result = add(multiply(1000, 1000), divide_with_ceil(999999, 1000))
  assert_eq(1001000, complex_result)  // 1000000 + 1000 = 1001000
}

// æµ‹è¯•8: é›¶å€¼å’Œç‰¹æ®Šæƒ…å†µå¤„ç†
test "quality_zero_and_special_cases_handling" {
  // æµ‹è¯•é›¶å€¼å’Œç‰¹æ®Šæƒ…å†µçš„å¤„ç†
  
  // ä¸é›¶çš„åŠ æ³•
  assert_eq(5, add(5, 0))
  assert_eq(-5, add(-5, 0))
  assert_eq(0, add(0, 0))
  
  // ä¸é›¶çš„ä¹˜æ³•
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(-5, 0))
  
  // é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // é›¶ä½œä¸ºè¢«é™¤æ•°
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, 100))
}

// æµ‹è¯•9: å®é™…åº”ç”¨åœºæ™¯ - åŒ…è£…å’Œç‰©æµè®¡ç®—
test "quality_packaging_logistics_calculation" {
  // æ¨¡æ‹ŸåŒ…è£…å’Œç‰©æµè®¡ç®—åœºæ™¯
  
  // åœºæ™¯1: è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let total_items = 127
  let items_per_box = 15
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(9, boxes_needed)  // ceil(127/15) = ceil(8.466...) = 9
  
  // åœºæ™¯2: è®¡ç®—è¿è¾“è½¦è¾†éœ€æ±‚
  let total_weight = 2500
  let vehicle_capacity = 800
  let vehicles_needed = divide_with_ceil(total_weight, vehicle_capacity)
  assert_eq(4, vehicles_needed)  // ceil(2500/800) = ceil(3.125) = 4
  
  // åœºæ™¯3: è®¡ç®—ä»“åº“ç©ºé—´éœ€æ±‚
  let boxes_per_pallet = 4
  let total_pallets_needed = divide_with_ceil(boxes_needed, boxes_per_pallet)
  assert_eq(3, total_pallets_needed)  // ceil(9/4) = ceil(2.25) = 3
  
  // åœºæ™¯4: è®¡ç®—æ€»æˆæœ¬
  let box_cost = 5
  let vehicle_cost = 50
  let pallet_cost = 20
  let total_cost = add(add(multiply(boxes_needed, box_cost), 
                          multiply(vehicles_needed, vehicle_cost)),
                       multiply(total_pallets_needed, pallet_cost))
  assert_eq(305, total_cost)  // 9*5 + 4*50 + 3*20 = 45 + 200 + 60 = 305
}

// æµ‹è¯•10: å¤æ‚æ•°å­¦è¡¨è¾¾å¼è®¡ç®—
test "quality_complex_mathematical_expressions" {
  // æµ‹è¯•å¤æ‚æ•°å­¦è¡¨è¾¾å¼çš„è®¡ç®—
  
  let x = 10
  let y = 15
  let z = 8
  
  // è¡¨è¾¾å¼1: (x + y) * z - x / y
  let expr1 = add(multiply(add(x, y), z), -divide_with_ceil(x, y))
  assert_eq(199, expr1)  // (10 + 15) * 8 - ceil(10/15) = 25*8 - 1 = 200 - 1 = 199
  
  // è¡¨è¾¾å¼2: x * y + y * z - z * x
  let expr2 = add(add(multiply(x, y), multiply(y, z)), -multiply(z, x))
  assert_eq(190, expr2)  // 10*15 + 15*8 - 8*10 = 150 + 120 - 80 = 190
  
  // è¡¨è¾¾å¼3: (x + y + z) * 2
  let expr3 = multiply(add(add(x, y), z), 2)
  assert_eq(66, expr3)  // (10 + 15 + 8) * 2 = 33 * 2 = 66
  
  // è¡¨è¾¾å¼4: ceil(x * y / z) + ceil(y * z / x)
  let expr4 = add(divide_with_ceil(multiply(x, y), z), 
                  divide_with_ceil(multiply(y, z), x))
  assert_eq(31, expr4)  // ceil(10*15/8) + ceil(15*8/10) = ceil(150/8) + ceil(120/10) = 19 + 12 = 31
  
  // è¡¨è¾¾å¼5: å¤æ‚åµŒå¥—è¡¨è¾¾å¼
  let expr5 = divide_with_ceil(multiply(add(x, multiply(y, 2)), 3), 4)
  assert_eq(30, expr5)  // ceil((10 + 15*2) * 3 / 4) = ceil((10 + 30) * 3 / 4) = ceil(40*3/4) = ceil(120/4) = 30
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "enhanced_boundary_validation" {
  // è¾¹ç•ŒéªŒè¯æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—ï¼ˆåœ¨åˆç†èŒƒå›´å†…ï¼‰
  let large_positive = 100000
  let large_negative = -100000
  
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  assert_eq(200000, add(large_positive, large_positive))
  assert_eq(-200000, add(large_negative, large_negative))
  assert_eq(0, add(large_positive, large_negative))
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•ï¼ˆåœ¨åˆç†èŒƒå›´å†…ï¼‰
  assert_eq(100000000, multiply(large_positive, 1000))
  assert_eq(100000000, multiply(large_negative, -1000))
  assert_eq(-100000000, multiply(large_positive, -1000))
}

test "sorting_algorithm_simulation" {
  // æ¨¡æ‹Ÿæ’åºç®—æ³•çš„æ¯”è¾ƒæ“ä½œ
  // æ¨¡æ‹Ÿ5ä¸ªå…ƒç´ çš„æ•°ç»„
  let array_size = 5
  
  // æ¨¡æ‹Ÿå†’æ³¡æ’åºçš„æ¯”è¾ƒæ¬¡æ•°
  let comparisons = multiply(array_size, array_size - 1) / 2
  assert_eq(10, comparisons)  // 5 * 4 / 2 = 10
  
  // æ¨¡æ‹Ÿé€‰æ‹©æ’åºçš„äº¤æ¢æ¬¡æ•°
  let swaps = array_size - 1
  assert_eq(4, swaps)
  
  // è®¡ç®—æ¨¡æ‹Ÿæ•°ç»„çš„æ€»å’Œ
  let sum = add(add(add(add(5, 2), 8), 1), 9)
  assert_eq(25, sum)
}

test "enhanced_memory_allocation" {
  // å†…å­˜åˆ†é…æ¨¡æ‹Ÿæµ‹è¯•
  let block_size = 1024
  let request_count = 15
  let total_memory = multiply(block_size, request_count)
  
  // è®¡ç®—éœ€è¦çš„é¡µé¢æ•°é‡ï¼ˆæ¯é¡µ4096å­—èŠ‚ï¼‰
  let page_size = 4096
  let pages_needed = divide_with_ceil(total_memory, page_size)
  
  assert_eq(15360, total_memory)
  assert_eq(4, pages_needed)
}

test "enhanced_string_processing" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  let input = "MoonBit"
  
  // æ¨¡æ‹Ÿå­—ç¬¦ä¸²è¿æ¥
  let result = greet(input)
  assert_eq_string("Hello, MoonBit!", result)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’Œæ•°å­—ç»„åˆ
  assert_eq_string("Hello, 2024!", greet("2024"))
  assert_eq_string("Hello, test@domain.com!", greet("test@domain.com"))
}

test "enhanced_financial_calculations" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let rate_percent = 5
  
  // ç®€åŒ–å¤åˆ©è®¡ç®—ï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(10500, year1)  // 10000 + ceil(10000*5/100) = 10000 + 500 = 10500
  assert_eq(11025, year2)  // 10500 + ceil(10500*5/100) = 10500 + 525 = 11025
  assert_eq(11576, year3)  // 11025 + ceil(11025*5/100) = 11025 + 551 = 11576
}

test "enhanced_scientific_calculations" {
  // ç§‘å­¦è®¡ç®—æµ‹è¯•
  // æ¨¡æ‹Ÿç‰©ç†å…¬å¼ï¼šè·ç¦» = é€Ÿåº¦ Ã— æ—¶é—´
  let velocity = 15  // m/s
  let time = 8       // s
  let distance = multiply(velocity, time)
  assert_eq(120, distance)
  
  // æ¨¡æ‹ŸåŒ–å­¦å…¬å¼ï¼šæ‘©å°”æµ“åº¦è®¡ç®—
  let moles = 5
  let volume_liters = 2
  let concentration = divide_with_ceil(multiply(moles, 1000), volume_liters)
  assert_eq(2500, concentration)  // 5*1000/2 = 2500 mol/mÂ³
}

test "enhanced_game_logic" {
  // æ¸¸æˆé€»è¾‘æ¨¡æ‹Ÿæµ‹è¯•
  let player_level = 15
  let base_hp = 100
  let hp_per_level = 20
  
  // è®¡ç®—ç©å®¶ç”Ÿå‘½å€¼
  let total_hp = add(base_hp, multiply(player_level, hp_per_level))
  assert_eq(400, total_hp)  // 100 + 15*20 = 100 + 300 = 400
  
  // è®¡ç®—ç»éªŒå€¼éœ€æ±‚ï¼ˆæŒ‡æ•°å¢é•¿æ¨¡æ‹Ÿï¼‰
  let exp_multiplier = 100
  let level_multiplier = player_level
  let exp_needed = multiply(exp_multiplier, multiply(level_multiplier, level_multiplier))
  assert_eq(22500, exp_needed)  // 100 * 15 * 15 = 22500
}

test "enhanced_data_structures" {
  // æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_capacity = 10
  let push_operations = 7
  let pop_operations = 3
  let remaining_items = add(push_operations, -pop_operations)
  
  assert_eq(4, remaining_items)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_size = 8
  let enqueue_count = 12
  let queue_overflow = divide_with_ceil(enqueue_count, queue_size)
  
  assert_eq(2, queue_overflow)  // ceil(12/8) = 2
  
  // éªŒè¯æ ˆå®¹é‡
  let capacity_check = if remaining_items < stack_capacity { 1 } else { 0 }
  assert_eq(1, capacity_check)
}

test "enhanced_network_simulation" {
  // ç½‘ç»œåè®®æ¨¡æ‹Ÿæµ‹è¯•
  let packet_size = 1500
  let data_size = 10000
  let header_overhead = 20
  
  // è®¡ç®—éœ€è¦çš„åŒ…æ•°é‡
  let packets_needed = divide_with_ceil(data_size, packet_size - header_overhead)
  
  // è®¡ç®—æ€»ä¼ è¾“é‡ï¼ˆåŒ…å«å¤´éƒ¨ï¼‰
  let total_transferred = multiply(packets_needed, packet_size)
  
  assert_eq(7, packets_needed)  // ceil(10000/1480) = 7
  assert_eq(10500, total_transferred)  // 7 * 1500 = 10500
}

test "enhanced_optimization_algorithm" {
  // ä¼˜åŒ–ç®—æ³•æµ‹è¯•
  let search_space = 1000
  let iterations = 50
  let convergence_threshold = 10
  
  // æ¨¡æ‹Ÿæ¢¯åº¦ä¸‹é™çš„æ­¥æ•°è®¡ç®—
  let steps_per_iteration = divide_with_ceil(search_space, iterations)
  let total_steps = multiply(steps_per_iteration, iterations)
  
  // æ¨¡æ‹Ÿæ”¶æ•›åˆ¤æ–­
  let convergence_result = if steps_per_iteration < convergence_threshold { 1 } else { 0 }
  
  assert_eq(20, steps_per_iteration)  // ceil(1000/50) = 20
  assert_eq(1000, total_steps)  // 20 * 50 = 1000
  assert_eq(0, convergence_result)  // 20 >= 10ï¼Œæœªæ”¶æ•›
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“
// åŒ…å«10ä¸ªæ ‡å‡†æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–æ‰€æœ‰ä¸»è¦å‡½æ•°

test "add_function_basic_test" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
  assert_eq(10, add(7, 3))
}

test "multiply_function_basic_test" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(15, multiply(3, 5))
}

test "greet_function_basic_test" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, ç”¨æˆ·!", greet("ç”¨æˆ·"))
}

test "divide_with_ceil_positive_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°çš„æ­£æ•°æƒ…å†µ
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(2, divide_with_ceil(3, 2))
}

test "divide_with_ceil_negative_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(-2, divide_with_ceil(-4, 2))
}

test "combined_operations_test" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  let result2 = multiply(add(5, 3), 2)
  assert_eq(16, result2)  // (5 + 3) * 2 = 8 * 2 = 16
}

test "mathematical_properties_test" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

test "boundary_values_test" {
  // æµ‹è¯•è¾¹ç•Œå€¼
  assert_eq(1, add(0, 1))
  assert_eq(-1, add(0, -1))
  assert_eq(0, multiply(1, 0))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 5))
}

test "practical_business_scenario_test" {
  // æµ‹è¯•å®é™…ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 25
  let quantity = 8
  let shipping = 15
  
  let subtotal = multiply(unit_price, quantity)
  let total = add(subtotal, shipping)
  
  assert_eq(200, subtotal)
  assert_eq(215, total)
}

test "packaging_calculation_test" {
  // æµ‹è¯•åŒ…è£…è®¡ç®—åœºæ™¯
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

// æ ¸å¿ƒåŠŸèƒ½é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// è¦†ç›– azimuth åº“çš„ä¸»è¦åŠŸèƒ½

test "add_function_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(8, 7))
  assert_eq(15, add(7, 8))
  assert_eq(0, add(5, -5))
  assert_eq(0, add(-5, 5))
}

test "multiply_function_zero_property" {
  // æµ‹è¯•ä¹˜æ³•é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(0, 100))
  assert_eq(0, multiply(100, 0))
  assert_eq(0, multiply(0, -50))
  assert_eq(25, multiply(5, 5))
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))    // 3.33 -> 4
  assert_eq(3, divide_with_ceil(9, 3))     // 3.0 -> 3
  assert_eq(1, divide_with_ceil(1, 100))   // 0.01 -> 1
  assert_eq(-3, divide_with_ceil(-10, 3))  // -3.33 -> -3
  assert_eq(0, divide_with_ceil(5, 0))     // é™¤é›¶ä¿æŠ¤
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, MarÃ­a!", greet("MarÃ­a"))
  assert_eq_string("Hello, !", greet(""))
}

test "combined_arithmetic_operations" {
  // æµ‹è¯•ç»„åˆç®—æœ¯è¿ç®—
  let result = add(multiply(3, 4), multiply(5, 2))
  assert_eq(22, result)  // 3*4 + 5*2 = 12 + 10 = 22
  
  let complex_result = multiply(add(10, 5), divide_with_ceil(25, 4))
  assert_eq(105, complex_result)  // (10+5) * ceil(25/4) = 15 * 7 = 105
}

test "boundary_value_testing" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, add(0, 1))
  assert_eq(-1, add(0, -1))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(-1, 1))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "practical_business_scenario" {
  // å®é™…ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 25
  let quantity = 8
  let shipping = 15
  let discount = 20
  
  let subtotal = multiply(unit_price, quantity)
  let total_before_discount = add(subtotal, shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(200, subtotal)
  assert_eq(215, total_before_discount)
  assert_eq(195, final_total)
}

test "mathematical_distributive_property" {
  // æµ‹è¯•åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 3
  let b = 4
  let c = 5
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 3 * (4 + 5) = 3 * 4 + 3 * 5 = 27
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  assert_eq(0, divide_with_ceil(100, 0))    // é™¤é›¶ä¿æŠ¤
  assert_eq(0, divide_with_ceil(-100, 0))   // è´Ÿæ•°é™¤é›¶ä¿æŠ¤
  assert_eq(0, divide_with_ceil(0, 0))      // é›¶é™¤é›¶ä¿æŠ¤
  
  // å¤§æ•°è¿ç®—æµ‹è¯•
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, A!", greet("A"))           // å•å­—ç¬¦
  assert_eq_string("Hello,   !", greet("  "))         // ç©ºæ ¼
  assert_eq_string("Hello, 123!", greet("123"))       // æ•°å­—
  assert_eq_string("Hello, a@b.com!", greet("a@b.com")) // é‚®ç®±æ ¼å¼
}

// æ–°å¢çš„ç®€æ´æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
test "concise_add_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
  assert_eq(100, add(50, 50))
}

test "concise_multiply_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(25, multiply(5, 5))
}

test "concise_greet_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "concise_divide_with_ceil_basic" {
  // æµ‹è¯•åŸºæœ¬å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "concise_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let a = 7
  let b = 13
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(a, 0))
  assert_eq(a, add(a, 0))
}

test "azimuth_concise_combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result1 = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result1)  // 2*3 + 4*5 = 6 + 20 = 26
  
  let result2 = multiply(add(5, 3), 2)
  assert_eq(16, result2)  // (5 + 3) * 2 = 8 * 2 = 16
}

test "concise_negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-10, add(-3, -7))
  assert_eq(-5, add(-8, 3))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "concise_practical_business_scenario" {
  // å®é™…ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 25
  let quantity = 8
  let shipping = 15
  
  let subtotal = multiply(unit_price, quantity)
  let total = add(subtotal, shipping)
  
  assert_eq(200, subtotal)
  assert_eq(215, total)
}

test "azimuth_concise_packaging_calculation" {
  // åŒ…è£…è®¡ç®—åœºæ™¯
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "concise_unicode_and_special_characters" {
  // æµ‹è¯• Unicode å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
}

// æ–°å¢çš„8ä¸ªå¢å¼ºæµ‹è¯•ç”¨ä¾‹
test "enhanced_boundary_combinations" {
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶çš„ç‰¹æ®Šç»„åˆ
  let max_safe_int = 1000000
  let min_safe_int = -1000000
  
  // æµ‹è¯•å¤§æ•°ç›¸åŠ 
  assert_eq(2000000, add(max_safe_int, max_safe_int))
  assert_eq(0, add(max_safe_int, min_safe_int))
  assert_eq(-2000000, add(min_safe_int, min_safe_int))
  
  // æµ‹è¯•å¤§æ•°ç›¸ä¹˜ï¼ˆä½¿ç”¨è¾ƒå°çš„æ•°é¿å…æº¢å‡ºï¼‰
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(-1000000, multiply(1000, -1000))
  
  // æµ‹è¯•å¤§æ•°é™¤æ³•
  assert_eq(1, divide_with_ceil(max_safe_int, max_safe_int))
  assert_eq(2, divide_with_ceil(max_safe_int + 1, max_safe_int))
}

test "enhanced_function_composition_pipeline" {
  // æµ‹è¯•å‡½æ•°ç»„åˆçš„å¤æ‚æµæ°´çº¿
  let raw_data = 47
  let validation_factor = 3
  let transformation_factor = 5
  let aggregation_factor = 2
  let output_threshold = 100
  
  // æ­¥éª¤1ï¼šæ•°æ®éªŒè¯
  let validated_data = divide_with_ceil(multiply(raw_data, validation_factor), 10)
  
  // æ­¥éª¤2ï¼šæ•°æ®è½¬æ¢
  let transformed_data = multiply(validated_data, transformation_factor)
  
  // æ­¥éª¤3ï¼šæ•°æ®èšåˆ
  let aggregated_data = add(transformed_data, aggregation_factor)
  
  // æ­¥éª¤4ï¼šè¾“å‡ºéªŒè¯
  let final_output = if aggregated_data > output_threshold {
    divide_with_ceil(aggregated_data, output_threshold)
  } else {
    1
  }
  
  assert_eq(15, validated_data)
  assert_eq(75, transformed_data)
  assert_eq(77, aggregated_data)
  assert_eq(1, final_output)
}

test "enhanced_error_handling_robustness" {
  // æµ‹è¯•é”™è¯¯å¤„ç†çš„å¥å£®æ€§
  
  // é™¤é›¶é”™è¯¯çš„å¤šé‡æµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå°å€¼é™¤æ³•æµ‹è¯•
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(-1000000, divide_with_ceil(-1000000, 1))
  
  // é›¶å€¼è¿ç®—çš„å¥å£®æ€§
  assert_eq(0, multiply(0, 2147483647))
  assert_eq(0, multiply(0, -2147483648))
  assert_eq(0, add(0, 0))
  assert_eq(2147483647, add(0, 2147483647))
  assert_eq(-2147483648, add(0, -2147483648))
}

test "enhanced_performance_calculation_simulation" {
  // æµ‹è¯•æ€§èƒ½è®¡ç®—æ¨¡æ‹Ÿ
  
  let input_size = 1000
  let base_complexity_factor = 2
  let optimization_factor = 3
  let overhead_percentage = 10
  
  // è®¡ç®—åŸºç¡€ç®—æ³•å¤æ‚åº¦ O(n)
  let linear_complexity = multiply(input_size, base_complexity_factor)
  
  // è®¡ç®—ä¼˜åŒ–åçš„å¤æ‚åº¦
  let optimized_complexity = divide_with_ceil(linear_complexity, optimization_factor)
  
  // è®¡ç®—å¼€é”€
  let overhead = divide_with_ceil(multiply(optimized_complexity, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = add(optimized_complexity, overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = divide_with_ceil(linear_complexity, actual_performance)
  
  assert_eq(2000, linear_complexity)
  assert_eq(667, optimized_complexity)
  assert_eq(67, overhead)
  assert_eq(734, actual_performance)
  assert_eq(3, performance_improvement)
}

test "enhanced_financial_compound_interest" {
  // æµ‹è¯•é‡‘èå¤åˆ©è®¡ç®—çš„ç²¾ç¡®æ€§
  
  let principal = 10000
  let annual_rate = 8  // 8% å¹´åˆ©ç‡
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  let year4_end = add(year3_end, divide_with_ceil(multiply(year3_end, annual_rate), 100))
  let year5_end = add(year4_end, divide_with_ceil(multiply(year4_end, annual_rate), 100))
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_return = add(year5_end, -principal)
  
  // è®¡ç®—å¹´åŒ–æ”¶ç›Šç‡
  let annualized_return = divide_with_ceil(multiply(total_return, 100), multiply(principal, 5))
  
  assert_eq(10800, year1_end)
  assert_eq(11664, year2_end)
  assert_eq(12597, year3_end)
  assert_eq(13605, year4_end)
  assert_eq(14693, year5_end)
  assert_eq(4693, total_return)
  assert_eq(10, annualized_return)
}

test "enhanced_string_processing_international" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„å›½é™…åŒ–æ”¯æŒ
  
  // æµ‹è¯•å¤šè¯­è¨€æ··åˆ
  let mixed_language = "Helloä¸–ç•ŒĞŸÑ€Ğ¸Ğ²ĞµÑ‚Ù…Ø±Ø­Ø¨Ø§"
  assert_eq_string("Hello, " + mixed_language + "!", greet(mixed_language))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "test@example.com"
  assert_eq_string("Hello, " + special_chars + "!", greet(special_chars))
  
  // æµ‹è¯•åŒ…å«æ•°å­—å’Œç¬¦å·çš„å­—ç¬¦ä¸²
  let alphanumeric = "ABC123!@#"
  assert_eq_string("Hello, " + alphanumeric + "!", greet(alphanumeric))
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let with_spaces = "multiple   spaces"
  assert_eq_string("Hello, " + with_spaces + "!", greet(with_spaces))
  
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²
  let long_string = "This_is_a_very_long_string_to_test_performance"
  assert_eq_string("Hello, " + long_string + "!", greet(long_string))
}

test "enhanced_resource_allocation_optimization" {
  // æµ‹è¯•èµ„æºåˆ†é…ä¼˜åŒ–ç®—æ³•
  
  let total_resources = 1000
  let project_a_priority = 3
  let project_b_priority = 2
  let project_c_priority = 1
  let total_priority = add(add(project_a_priority, project_b_priority), project_c_priority)
  
  // æŒ‰ä¼˜å…ˆçº§åˆ†é…èµ„æº
  let project_a_allocation = divide_with_ceil(multiply(total_resources, project_a_priority), total_priority)
  let project_b_allocation = divide_with_ceil(multiply(total_resources, project_b_priority), total_priority)
  let project_c_allocation = divide_with_ceil(multiply(total_resources, project_c_priority), total_priority)
  
  // è®¡ç®—å®é™…åˆ†é…æ€»æ•°
  let total_allocated = add(add(project_a_allocation, project_b_allocation), project_c_allocation)
  
  // è®¡ç®—èµ„æºåˆ©ç”¨ç‡
  let utilization_rate = divide_with_ceil(multiply(total_allocated, 100), total_resources)
  
  assert_eq(6, total_priority)
  assert_eq(500, project_a_allocation)
  assert_eq(334, project_b_allocation)
  assert_eq(167, project_c_allocation)
  assert_eq(1001, total_allocated)
  assert_eq(101, utilization_rate)
}

test "enhanced_mathematical_series_summation" {
  // æµ‹è¯•æ•°å­¦çº§æ•°æ±‚å’Œçš„ç²¾ç¡®è®¡ç®—
  
  let first_term = 5
  let common_difference = 3
  let number_of_terms = 10
  
  // ç­‰å·®æ•°åˆ—æ±‚å’Œï¼šS = n/2 * (2a + (n-1)d)
  let arithmetic_sum = divide_with_ceil(
    multiply(number_of_terms, add(multiply(2, first_term), multiply(number_of_terms - 1, common_difference))),
    2
  )
  
  // ç®€åŒ–çš„ç­‰æ¯”æ•°åˆ—è®¡ç®—
  let geometric_first = 2
  let geometric_ratio = 3
  let geometric_sum = add(add(add(add(
    geometric_first,
    multiply(geometric_first, geometric_ratio)
  ), multiply(geometric_first, multiply(geometric_ratio, geometric_ratio))
  ), multiply(geometric_first, multiply(geometric_ratio, multiply(geometric_ratio, geometric_ratio)))
  ), multiply(geometric_first, multiply(geometric_ratio, multiply(geometric_ratio, multiply(geometric_ratio, geometric_ratio)))))
  
  // éªŒè¯ç»“æœ
  assert_eq(185, arithmetic_sum)
  assert_eq(242, geometric_sum)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡†æµ‹è¯•ç”¨ä¾‹
test "core_add_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(8, add(3, 5))
  assert_eq(0, add(0, 0))
  assert_eq(-2, add(-5, 3))
}

test "core_multiply_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬ä¹˜æ³•åŠŸèƒ½
  assert_eq(12, multiply(3, 4))
  assert_eq(0, multiply(7, 0))
  assert_eq(-15, multiply(-3, 5))
}

test "core_greet_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "core_divide_with_ceil_positive" {
  // æµ‹è¯•æ­£æ•°å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(3, divide_with_ceil(8, 3))
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "core_divide_with_ceil_negative" {
  // æµ‹è¯•è´Ÿæ•°å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-2, divide_with_ceil(-8, 3))
  assert_eq(3, divide_with_ceil(-8, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "core_zero_operations" {
  // æµ‹è¯•é›¶ç›¸å…³è¿ç®—
  assert_eq(0, multiply(5, 0))
  assert_eq(5, add(5, 0))
  assert_eq(0, divide_with_ceil(0, 10))
}

test "core_combined_operations" {
  // æµ‹è¯•ç»„åˆè¿ç®—
  let result = add(multiply(2, 4), multiply(3, 5))
  assert_eq(23, result)  // 2*4 + 3*5 = 8 + 15 = 23
}

test "core_practical_packaging" {
  // å®é™…åŒ…è£…åœºæ™¯
  let total_items = 17
  let items_per_box = 5
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(4, boxes_needed)  // ceil(17/5) = 4
}

test "core_mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let x = 6
  let y = 9
  assert_eq(add(x, y), add(y, x))  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))  // ä¹˜æ³•äº¤æ¢å¾‹
}

test "core_string_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, A!", greet("A"))
}

// æ–°å¢çš„ä¸“æ³¨æµ‹è¯•ç”¨ä¾‹
test "azimuth_add_commutative_property_new" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 42
  let b = 17
  assert_eq(add(a, b), add(b, a))
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  let x = -15
  let y = 8
  assert_eq(add(x, y), add(y, x))
  
  // æµ‹è¯•é›¶çš„æƒ…å†µ
  assert_eq(add(0, 25), add(25, 0))
}

test "azimuth_multiply_distributive_property_new" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 5
  let b = 12
  let c = 7
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
}

test "azimuth_divide_ceil_precision_new" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  // æ­£æ•°æƒ…å†µ
  assert_eq(4, divide_with_ceil(11, 3))  // 11/3 = 3.666... -> 4
  assert_eq(2, divide_with_ceil(4, 2))   // 4/2 = 2 -> 2
  assert_eq(1, divide_with_ceil(1, 100)) // 1/100 = 0.01 -> 1
  
  // è´Ÿæ•°æƒ…å†µ
  assert_eq(-3, divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
  assert_eq(-3, divide_with_ceil(-11, 4))  // -11/4 = -2.75 -> -2
  
  // é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-50, 0))
}

test "azimuth_greet_unicode_new" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", greet("Î±Î²Î³Î´Îµ"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸš€ğŸŒ!", greet("ğŸš€ğŸŒ"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
}

test "azimuth_business_calculation_new" {
  // å¤æ‚ä¸šåŠ¡åœºæ™¯ï¼šç”µå•†è®¢å•è®¡ç®—
  let product_price = 89
  let quantity = 4
  let tax_rate = 8  // 8%
  let shipping_cost = 12
  let discount_threshold = 300
  let discount_amount = 25
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(product_price, quantity)
  
  // è®¡ç®—ç¨è´¹ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, tax_amount), shipping_cost)
  
  // åº”ç”¨æŠ˜æ‰£ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(356, subtotal)
  assert_eq(29, tax_amount)
  assert_eq(397, pre_discount_total)
  assert_eq(372, final_total)
}

test "azimuth_resource_allocation_new" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 5000
  let team_a_cost = 1200
  let team_b_cost = 800
  let team_c_cost = 1500
  
  // è®¡ç®—å·²åˆ†é…é¢„ç®—
  let allocated_budget = add(add(team_a_cost, team_b_cost), team_c_cost)
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let remaining_budget = add(total_budget, -allocated_budget)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡ï¼ˆæ¯ä¸ªé¡¹ç›®æˆæœ¬300ï¼‰
  let small_projects_count = divide_with_ceil(remaining_budget, 300)
  
  assert_eq(3500, allocated_budget)
  assert_eq(1500, remaining_budget)
  assert_eq(5, small_projects_count)
}

test "azimuth_time_management_new" {
  // æ—¶é—´ç®¡ç†è®¡ç®—æµ‹è¯•
  let total_tasks = 67
  let tasks_per_day = 8
  let work_hours_per_day = 8
  let meeting_hours_per_day = 2
  
  // è®¡ç®—éœ€è¦çš„å·¥ä½œå¤©æ•°
  let work_days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  // è®¡ç®—å®é™…å·¥ä½œå°æ—¶æ•°ï¼ˆæ‰£é™¤ä¼šè®®æ—¶é—´ï¼‰
  let productive_hours_per_day = add(work_hours_per_day, -meeting_hours_per_day)
  let total_productive_hours = multiply(work_days_needed, productive_hours_per_day)
  
  assert_eq(9, work_days_needed)
  assert_eq(6, productive_hours_per_day)
  assert_eq(54, total_productive_hours)
}

test "azimuth_fibonacci_series_new" {
  // ç±»æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let first = 1
  let second = 1
  let third = add(first, second)
  let fourth = add(second, third)
  let fifth = add(third, fourth)
  let sixth = add(fourth, fifth)
  
  // éªŒè¯æ•°åˆ—å€¼
  assert_eq(2, third)
  assert_eq(3, fourth)
  assert_eq(5, fifth)
  assert_eq(8, sixth)
  
  // è®¡æ•°åˆ—å’Œ
  let series_sum = add(add(add(add(first, second), third), add(fourth, fifth)), sixth)
  assert_eq(20, series_sum)
}

test "azimuth_extreme_values_new" {
  // é”™è¯¯è¾¹ç•Œå’Œæå€¼æµ‹è¯•
  // æµ‹è¯•é›¶çš„å„ç§è¿ç®—
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 1000))
  assert_eq(0, multiply(-500, 0))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•å¤§æ•°è¿ç®—ï¼ˆä½¿ç”¨æ›´å°çš„å€¼ä»¥é¿å…æº¢å‡ºï¼‰
  let large_num = 10000
  assert_eq(20000, add(large_num, large_num))
  assert_eq(100000000, multiply(large_num, large_num))
  
  // æµ‹è¯•æå€¼ç»„åˆ
  assert_eq(10001, add(large_num, 1))
  assert_eq(9999, add(large_num, -1))
}

// æ–°å¢çš„ 10 ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "azimuth_temperature_conversion" {
  // æ¸©åº¦è½¬æ¢åœºæ™¯ï¼šæ‘„æ°åº¦åˆ°åæ°åº¦çš„è¿‘ä¼¼è®¡ç®—
  // F = C * 9/5 + 32ï¼Œä½¿ç”¨æ•´æ•°è¿ç®—è¿‘ä¼¼
  let celsius = 25
  let fahrenheit_approx = add(divide_with_ceil(multiply(celsius, 9), 5), 32)
  assert_eq(77, fahrenheit_approx)
  
  // å†°ç‚¹æ¸©åº¦
  let freezing_c = 0
  let freezing_f = add(divide_with_ceil(multiply(freezing_c, 9), 5), 32)
  assert_eq(32, freezing_f)
}

test "azimuth_batch_processing" {
  // æ‰¹å¤„ç†åœºæ™¯ï¼šè®¡ç®—å¤„ç†å¤šæ‰¹æ•°æ®æ‰€éœ€çš„æ—¶é—´
  let items_per_batch = 150
  let number_of_batches = 4
  let processing_time_per_item = 3  // åˆ†é’Ÿ
  
  let total_items = multiply(items_per_batch, number_of_batches)
  let total_time = multiply(total_items, processing_time_per_item)
  let hours_needed = divide_with_ceil(total_time, 60)
  
  assert_eq(600, total_items)
  assert_eq(1800, total_time)
  assert_eq(30, hours_needed)
}

test "azimuth_financial_compound_interest" {
  // å¤åˆ©è®¡ç®—åœºæ™¯ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let principal = 10000
  let interest_rate = 5  // 5%
  let years = 3
  
  // ç¬¬ä¸€å¹´
  let year1 = add(principal, divide_with_ceil(multiply(principal, interest_rate), 100))
  // ç¬¬äºŒå¹´
  let year2 = add(year1, divide_with_ceil(multiply(year1, interest_rate), 100))
  // ç¬¬ä¸‰å¹´
  let year3 = add(year2, divide_with_ceil(multiply(year2, interest_rate), 100))
  
  assert_eq(10500, year1)
  assert_eq(11025, year2)
  assert_eq(11576, year3)
}

test "azimuth_resource_allocation" {
  // èµ„æºåˆ†é…åœºæ™¯ï¼šå°†èµ„æºå‡åŒ€åˆ†é…ç»™å¤šä¸ªé¡¹ç›®
  let total_resources = 47
  let number_of_projects = 8
  let resources_per_project = divide_with_ceil(total_resources, number_of_projects)
  
  // è®¡ç®—å®é™…åˆ†é…çš„èµ„æº
  let allocated_resources = multiply(resources_per_project, number_of_projects)
  let remaining_resources = add(total_resources, -allocated_resources)
  
  assert_eq(6, resources_per_project)
  assert_eq(48, allocated_resources)
  assert_eq(-1, remaining_resources)  // è´Ÿå€¼è¡¨ç¤ºéœ€è¦é¢å¤–èµ„æº
}

test "azimuth_digital_storage" {
  // æ•°å­—å­˜å‚¨åœºæ™¯ï¼šè®¡ç®—æ–‡ä»¶å­˜å‚¨éœ€æ±‚
  let file_size_mb = 25
  let number_of_files = 37
  let storage_capacity_gb = 1
  
  // è®¡ç®—æ€»å­˜å‚¨éœ€æ±‚ï¼ˆMBï¼‰
  let total_storage_mb = multiply(file_size_mb, number_of_files)
  // è½¬æ¢ä¸ºGBï¼ˆ1GB = 1024MBï¼Œç®€åŒ–ä¸º1000MBï¼‰
  let total_storage_gb = divide_with_ceil(total_storage_mb, 1000)
  
  assert_eq(925, total_storage_mb)
  assert_eq(1, total_storage_gb)
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦é¢å¤–å­˜å‚¨
  let additional_storage_needed = add(total_storage_gb, -storage_capacity_gb)
  assert_eq(0, additional_storage_needed)
}

test "azimuth_travel_planning" {
  // æ—…è¡Œè§„åˆ’åœºæ™¯ï¼šè®¡ç®—æ—…è¡Œæ—¶é—´å’Œè´¹ç”¨
  let distance_km = 450
  let average_speed_kmh = 80
  let fuel_consumption_per_100km = 8
  let fuel_price_per_liter = 7
  
  // è®¡ç®—æ—…è¡Œæ—¶é—´ï¼ˆå°æ—¶ï¼‰
  let travel_hours = divide_with_ceil(distance_km, average_speed_kmh)
  
  // è®¡ç®—ç‡ƒæ²¹æ¶ˆè€—ï¼ˆå‡ï¼‰
  let fuel_consumed = divide_with_ceil(multiply(distance_km, fuel_consumption_per_100km), 100)
  
  // è®¡ç®—ç‡ƒæ²¹è´¹ç”¨
  let fuel_cost = multiply(fuel_consumed, fuel_price_per_liter)
  
  assert_eq(6, travel_hours)
  assert_eq(36, fuel_consumed)
  assert_eq(252, fuel_cost)
}

test "azimuth_project_management" {
  // é¡¹ç›®ç®¡ç†åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®è¿›åº¦å’Œé‡Œç¨‹ç¢‘
  let total_tasks = 120
  let completed_tasks = 45
  let tasks_per_sprint = 15
  
  // è®¡ç®—å®Œæˆç™¾åˆ†æ¯”
  let completion_percentage = divide_with_ceil(multiply(completed_tasks, 100), total_tasks)
  
  // è®¡ç®—å‰©ä½™ä»»åŠ¡æ•°
  let remaining_tasks = add(total_tasks, -completed_tasks)
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ¬¡æ•°
  let remaining_sprints = divide_with_ceil(remaining_tasks, tasks_per_sprint)
  
  assert_eq(38, completion_percentage)
  assert_eq(75, remaining_tasks)
  assert_eq(5, remaining_sprints)
}

test "azimuth_cooking_recipe" {
  // çƒ¹é¥ªé£Ÿè°±åœºæ™¯ï¼šè°ƒæ•´é…æ–¹æ¯”ä¾‹
  let original_servings = 4
  let desired_servings = 7
  let flour_per_serving = 150  // å…‹
  let sugar_per_serving = 50   // å…‹
  
  // è®¡ç®—è°ƒæ•´ç³»æ•°
  let adjustment_factor = divide_with_ceil(multiply(desired_servings, 100), multiply(original_servings, 100))
  
  // è®¡ç®—æ–°é…æ–¹ç”¨é‡
  let new_flour = multiply(flour_per_serving, desired_servings)
  let new_sugar = multiply(sugar_per_serving, desired_servings)
  
  assert_eq(2, adjustment_factor)
  assert_eq(1050, new_flour)
  assert_eq(350, new_sugar)
}

test "azimuth_fitness_tracking" {
  // å¥èº«è¿½è¸ªåœºæ™¯ï¼šè®¡ç®—å¡è·¯é‡Œæ¶ˆè€—å’Œç›®æ ‡è¾¾æˆ
  let calories_per_minute_running = 10
  let calories_per_minute_cycling = 8
  let running_minutes = 25
  let cycling_minutes = 40
  let daily_calorie_goal = 500
  
  // è®¡ç®—æ¶ˆè€—çš„å¡è·¯é‡Œ
  let running_calories = multiply(calories_per_minute_running, running_minutes)
  let cycling_calories = multiply(calories_per_minute_cycling, cycling_minutes)
  let total_calories = add(running_calories, cycling_calories)
  
  // è®¡ç®—ç›®æ ‡å®Œæˆç™¾åˆ†æ¯”
  let goal_percentage = divide_with_ceil(multiply(total_calories, 100), daily_calorie_goal)
  
  assert_eq(250, running_calories)
  assert_eq(320, cycling_calories)
  assert_eq(570, total_calories)
  assert_eq(114, goal_percentage)
}

test "azimuth_greeting_variations" {
  // é—®å€™å‡½æ•°å˜ä½“æµ‹è¯•ï¼šæµ‹è¯•å„ç§ç‰¹æ®Šæƒ…å†µå’Œç»„åˆ
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„åç§°
  assert_eq_string("Hello, John-Doe!", greet("John-Doe"))
  assert_eq_string("Hello, O'Connor!", greet("O'Connor"))
  
  // æµ‹è¯•åŒ…å«æ•°å­—çš„åç§°
  assert_eq_string("Hello, User123!", greet("User123"))
  assert_eq_string("Hello, 2024!", greet("2024"))
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„åç§°
  assert_eq_string("Hello, John Smith!", greet("John Smith"))
  assert_eq_string("Hello,   Multiple   Spaces   !", greet("   Multiple   Spaces   "))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_edge_cases" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1000000, add(500000, 500000))
  assert_eq(-1000000, add(-500000, -500000))
  assert_eq(0, add(1000000, -1000000))
  assert_eq(1, add(2147483647, -2147483646))
}

test "multiply_function_precision" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„ç²¾åº¦
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(-1000000, multiply(1000, -1000))
  assert_eq(0, multiply(2147483647, 0))
  assert_eq(2147483647, multiply(1, 2147483647))
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(4, divide_with_ceil(11, 3))  // 11/3 = 3.666... -> 4
  assert_eq(3, divide_with_ceil(9, 3))   // 9/3 = 3 -> 3
  assert_eq(1, divide_with_ceil(1, 100)) // 1/100 = 0.01 -> 1
  assert_eq(-3, divide_with_ceil(-10, 3)) // -10/3 = -3.333... -> -3
  assert_eq(4, divide_with_ceil(-11, -3)) // -11/-3 = 3.666... -> 4
  assert_eq(0, divide_with_ceil(100, 0))  // é™¤æ•°ä¸º0çš„å®‰å…¨å¤„ç†
}

test "greet_function_internationalization" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…åŒ–æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "complex_business_workflow" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµæµ‹è¯•
  let product_cost = 120
  let quantity = 15
  let tax_rate = 8
  let shipping_cost_per_item = 5
  let discount_threshold = 1000
  let discount_amount = 50
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(product_cost, quantity)
  
  // è®¡ç®—è¿è´¹
  let total_shipping = multiply(shipping_cost_per_item, quantity)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, total_shipping), tax_amount)
  
  // åº”ç”¨æŠ˜æ‰£
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(1800, subtotal)
  assert_eq(75, total_shipping)
  assert_eq(144, tax_amount)
  assert_eq(2019, pre_discount_total)
  assert_eq(1969, final_total)
}

test "mathematical_composition" {
  // æµ‹è¯•æ•°å­¦å‡½æ•°çš„ç»„åˆ
  let x = 12
  let y = 8
  let z = 5
  
  // æµ‹è¯•åˆ†é…å¾‹: x * (y + z) = x * y + x * z
  let distributive_left = multiply(x, add(y, z))
  let distributive_right = add(multiply(x, y), multiply(x, z))
  assert_eq(distributive_left, distributive_right)
  
  // æµ‹è¯•ç»“åˆå¾‹: (x + y) + z = x + (y + z)
  let associative_left = add(add(x, y), z)
  let associative_right = add(x, add(y, z))
  assert_eq(associative_left, associative_right)
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯æµ‹è¯•
  let principal = 1000
  let rate_percent = 5
  let _years = 3  // æœªä½¿ç”¨çš„å˜é‡
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let amount_after_year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let amount_after_year2 = add(amount_after_year1, divide_with_ceil(multiply(amount_after_year1, rate_percent), 100))
  let amount_after_year3 = add(amount_after_year2, divide_with_ceil(multiply(amount_after_year2, rate_percent), 100))
  
  assert_eq(1050, amount_after_year1)
  assert_eq(1103, amount_after_year2)
  assert_eq(1158, amount_after_year3)
}

test "inventory_management_system" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯•
  let initial_stock = 500
  let daily_sales = 25
  let weekly_restock = 200
  let days_to_simulate = 14
  
  // è®¡ç®—æ€»é”€å”®é‡
  let total_sold = multiply(daily_sales, days_to_simulate)
  
  // è®¡ç®—è¡¥è´§æ¬¡æ•°ï¼ˆæ¯7å¤©è¡¥è´§ä¸€æ¬¡ï¼‰
  let restock_times = divide_with_ceil(days_to_simulate, 7)
  
  // è®¡ç®—æ€»è¡¥è´§é‡
  let total_restocked = multiply(weekly_restock, restock_times)
  
  // è®¡ç®—æœ€ç»ˆåº“å­˜
  let final_stock = add(add(initial_stock, -total_sold), total_restocked)
  
  assert_eq(350, total_sold)
  assert_eq(2, restock_times)
  assert_eq(400, total_restocked)
  assert_eq(550, final_stock)
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†ç®¡é“æµ‹è¯•
  let raw_data_points = 1000
  let valid_data_ratio = 85
  let processing_batches = 20
  let error_rate = 3
  
  // è®¡ç®—æœ‰æ•ˆæ•°æ®ç‚¹
  let valid_data = divide_with_ceil(multiply(raw_data_points, valid_data_ratio), 100)
  
  // è®¡ç®—æ¯æ‰¹å¤„ç†çš„æ•°æ®ç‚¹
  let batch_size = divide_with_ceil(valid_data, processing_batches)
  
  // è®¡ç®—é¢„æœŸé”™è¯¯æ•°
  let expected_errors = divide_with_ceil(multiply(valid_data, error_rate), 100)
  
  // è®¡ç®—æˆåŠŸå¤„ç†çš„æ•°æ®ç‚¹
  let successful_data = add(valid_data, -expected_errors)
  
  assert_eq(850, valid_data)
  assert_eq(43, batch_size)
  assert_eq(26, expected_errors)
  assert_eq(824, successful_data)
}

test "performance_benchmark_simulation" {
  // æ€§èƒ½åŸºå‡†æµ‹è¯•æ¨¡æ‹Ÿ
  let base_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 15
  let concurrent_threads = 4
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ“ä½œæ•°
  let optimized_operations = multiply(base_operations, optimization_factor)
  
  // è®¡ç®—å¼€é”€
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = add(optimized_operations, -overhead)
  
  // è®¡ç®—æ¯çº¿ç¨‹æ“ä½œæ•°
  let operations_per_thread = divide_with_ceil(actual_performance, concurrent_threads)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = divide_with_ceil(actual_performance, base_operations)
  
  assert_eq(3000, optimized_operations)
  assert_eq(450, overhead)
  assert_eq(2550, actual_performance)
  assert_eq(638, operations_per_thread)
  assert_eq(3, performance_improvement)
}

// æ–°çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸º azimuth é¡¹ç›®æ·»åŠ çš„æµ‹è¯•
// åŒ…å«8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "subtract_function_comprehensive" {
  // å…¨é¢æµ‹è¯•å‡æ³•å‡½æ•°
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
  assert_eq(0, subtract(5, 5))
  assert_eq(15, subtract(10, -5))
  assert_eq(-15, subtract(-10, 5))
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
}

// æ–°å¢çš„å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - ä¸è¶…è¿‡10ä¸ª
test "azimuth_enhanced_error_handling" {
  // æµ‹è¯•é™¤æ³•é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
}

test "azimuth_enhanced_calculations" {
  // å¤æ‚è®¡ç®—æµ‹è¯•
  let result1 = add(multiply(3, 4), multiply(5, 6))
  assert_eq(42, result1)  // 3*4 + 5*6 = 12 + 30 = 42
  
  let result2 = divide_with_ceil(multiply(7, 8), 5)
  assert_eq(12, result2)  // ceil(56/5) = 12
}

test "azimuth_enhanced_string_cases" {
  // å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
}

test "azimuth_enhanced_math_identities" {
  // æ•°å­¦æ’ç­‰å¼æµ‹è¯•
  let x = 15
  assert_eq(x, add(x, 0))  // åŠ æ³•å•ä½å…ƒ
  assert_eq(x, multiply(x, 1))  // ä¹˜æ³•å•ä½å…ƒ
  assert_eq(0, multiply(x, 0))  // é›¶å…ƒç´ æ€§è´¨
}

test "azimuth_enhanced_negative_ops" {
  // è´Ÿæ•°è¿ç®—æµ‹è¯•
  assert_eq(-8, add(-3, -5))
  assert_eq(-2, add(-7, 5))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "azimuth_enhanced_order_calc" {
  // å®é™…åº”ç”¨åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 25
  let quantity = 8
  let shipping = 15
  let discount = 20
  
  let subtotal = multiply(unit_price, quantity)
  let total_before_discount = add(subtotal, shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(200, subtotal)
  assert_eq(215, total_before_discount)
  assert_eq(195, final_total)
}

test "azimuth_enhanced_boundary_vals" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(100, divide_with_ceil(100, 1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(-1, divide_with_ceil(-1, 2))
}

test "azimuth_enhanced_large_numbers" {
  // å¤§æ•°ç²¾åº¦æµ‹è¯•
  let large_num = 10000
  assert_eq(20000, add(large_num, large_num))
  assert_eq(100000000, multiply(large_num, large_num))
  assert_eq(3334, divide_with_ceil(10000, 3))
}

test "azimuth_enhanced_combo_logic" {
  // ç»„åˆé€»è¾‘æµ‹è¯•
  let a = 10
  let b = 20
  let c = 30
  
  // æµ‹è¯• (a + b) * c - a
  let result1 = add(multiply(add(a, b), c), -a)
  assert_eq(890, result1)  // (10 + 20) * 30 - 10 = 30 * 30 - 10 = 900 - 10 = 890
  
  // æµ‹è¯• a * (b + c) / a
  let result2 = divide_with_ceil(multiply(a, add(b, c)), a)
  assert_eq(50, result2)  // ceil(10 * (20 + 30) / 10) = ceil(500/10) = 50
}

test "azimuth_enhanced_resource_alloc" {
  // èµ„æºåˆ†é…æµ‹è¯•
  let total_resources = 100
  let project1_needs = 30
  let project2_needs = 45
  let project3_needs = 20
  
  let allocated = add(add(project1_needs, project2_needs), project3_needs)
  let remaining = add(total_resources, -allocated)
  let additional_projects = divide_with_ceil(remaining, 5)
  
  assert_eq(95, allocated)
  assert_eq(5, remaining)
  assert_eq(1, additional_projects)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½
// åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œå®é™…åº”ç”¨åœºæ™¯çš„å…¨é¢æµ‹è¯•

test "azimuth_premium_mathematical_series_sum" {
  // æµ‹è¯•ç­‰å·®æ•°åˆ—æ±‚å’Œï¼š1 + 3 + 5 + ... + 19 = 100
  let first_term = 1
  let common_difference = 2
  let number_of_terms = 10
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šS = n/2 * (2a + (n-1)d)
  let sum_formula = divide_with_ceil(
    multiply(number_of_terms, add(multiply(2, first_term), multiply(number_of_terms - 1, common_difference))),
    2
  )
  
  assert_eq(100, sum_formula)
}

test "azimuth_premium_financial_compound_interest" {
  // æµ‹è¯•å¤åˆ©è®¡ç®—ï¼šæœ¬é‡‘1000ï¼Œå¹´åˆ©ç‡5%ï¼Œ3å¹´
  let principal = 1000
  let rate_percent = 5
  
  // ç¬¬ä¸€å¹´
  let amount_after_year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  // ç¬¬äºŒå¹´
  let amount_after_year2 = add(amount_after_year1, divide_with_ceil(multiply(amount_after_year1, rate_percent), 100))
  // ç¬¬ä¸‰å¹´
  let amount_after_year3 = add(amount_after_year2, divide_with_ceil(multiply(amount_after_year2, rate_percent), 100))
  
  assert_eq(1158, amount_after_year3)
}

test "azimuth_premium_inventory_optimization" {
  // æµ‹è¯•åº“å­˜ä¼˜åŒ–ï¼šè®¡ç®—æœ€ä¼˜è®¢è´§é‡
  let annual_demand = 1200
  let ordering_cost = 50
  let holding_cost_per_unit = 2
  
  // EOQå…¬å¼ç®€åŒ–ç‰ˆï¼šsqrt(2 * D * S / H)
  // è¿™é‡Œä½¿ç”¨ç®€åŒ–è®¡ç®—
  let eoq_numerator = multiply(multiply(2, annual_demand), ordering_cost)
  let eoq_approximation = divide_with_ceil(eoq_numerator, holding_cost_per_unit)
  
  assert_eq(60000, eoq_numerator)
  assert_eq(30000, eoq_approximation)
}

test "azimuth_premium_project_critical_path" {
  // æµ‹è¯•é¡¹ç›®å…³é”®è·¯å¾„è®¡ç®—
  let task_a_duration = 5
  let task_b_duration = 8
  let task_c_duration = 3
  let task_d_duration = 6
  
  // è®¡ç®—ä¸¤æ¡è·¯å¾„çš„æ€»æ—¶é—´
  let path_1 = add(add(task_a_duration, task_b_duration), task_d_duration)
  let path_2 = add(add(task_a_duration, task_c_duration), task_d_duration)
  
  // å…³é”®è·¯å¾„æ˜¯è¾ƒé•¿çš„è·¯å¾„
  let critical_path = if path_1 > path_2 { path_1 } else { path_2 }
  
  assert_eq(19, path_1)
  assert_eq(14, path_2)
  assert_eq(19, critical_path)
}

test "azimuth_premium_data_compression_ratio" {
  // æµ‹è¯•æ•°æ®å‹ç¼©æ¯”è®¡ç®—
  let original_size = 1000
  let compressed_size = 350
  
  // è®¡ç®—å‹ç¼©æ¯”ï¼š(åŸå§‹å¤§å° - å‹ç¼©åå¤§å°) / åŸå§‹å¤§å° * 100
  let size_difference = add(original_size, -compressed_size)
  let compression_ratio = divide_with_ceil(multiply(size_difference, 100), original_size)
  
  assert_eq(650, size_difference)
  assert_eq(65, compression_ratio)
}

test "azimuth_premium_network_packet_routing" {
  // æµ‹è¯•ç½‘ç»œæ•°æ®åŒ…è·¯ç”±è®¡ç®—
  let packet_size = 1500
  let bandwidth_mbps = 100
  let number_of_hops = 3
  
  // è®¡ç®—æ¯è·³ä¼ è¾“æ—¶é—´ï¼ˆç®€åŒ–ï¼‰
  let time_per_hop = divide_with_ceil(packet_size, bandwidth_mbps)
  let total_time = multiply(time_per_hop, number_of_hops)
  
  assert_eq(15, time_per_hop)
  assert_eq(45, total_time)
}

test "azimuth_premium_energy_efficiency_calculation" {
  // æµ‹è¯•èƒ½æºæ•ˆç‡è®¡ç®—
  let power_input_watts = 500
  let power_output_watts = 350
  
  // è®¡ç®—æ•ˆç‡ï¼šè¾“å‡ºåŠŸç‡ / è¾“å…¥åŠŸç‡ * 100
  let efficiency_percentage = divide_with_ceil(multiply(power_output_watts, 100), power_input_watts)
  
  assert_eq(70, efficiency_percentage)
}

test "azimuth_premium_cryptographic_hash_simulation" {
  // æµ‹è¯•åŠ å¯†å“ˆå¸Œæ¨¡æ‹Ÿï¼ˆç®€åŒ–ç‰ˆï¼‰
  let input_value = 12345
  let prime_multiplier = 31
  let modulo_value = 1000000
  
  // ç®€åŒ–çš„å“ˆå¸Œè®¡ç®—
  let hash_value = multiply(input_value, prime_multiplier) % modulo_value
  
  assert_eq(382695, hash_value)
}

test "azimuth_premium_multilingual_greeting_system" {
  // æµ‹è¯•å¤šè¯­è¨€é—®å€™ç³»ç»Ÿ
  let english_name = "Alice"
  let chinese_name = "å°æ˜"
  let spanish_name = "Carlos"
  let emoji_name = "ğŸš€"
  
  // æµ‹è¯•ä¸åŒè¯­è¨€çš„é—®å€™
  let english_greeting = greet(english_name)
  let chinese_greeting = greet(chinese_name)
  let spanish_greeting = greet(spanish_name)
  let emoji_greeting = greet(emoji_name)
  
  assert_eq_string("Hello, Alice!", english_greeting)
  assert_eq_string("Hello, å°æ˜!", chinese_greeting)
  assert_eq_string("Hello, Carlos!", spanish_greeting)
  assert_eq_string("Hello, ğŸš€!", emoji_greeting)
}

test "azimuth_premium_complex_business_workflow" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡å·¥ä½œæµç¨‹
  let product_cost = 120
  let quantity = 15
  let tax_rate = 8
  let shipping_cost_per_item = 5
  let discount_threshold = 1000
  let discount_amount = 50
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(product_cost, quantity)
  // è®¡ç®—è¿è´¹
  let total_shipping = multiply(shipping_cost_per_item, quantity)
  // è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  // è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, total_shipping), tax_amount)
  // åº”ç”¨æŠ˜æ‰£ï¼ˆå¦‚æœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(1800, subtotal)
  assert_eq(75, total_shipping)
  assert_eq(144, tax_amount)
  assert_eq(2019, pre_discount_total)
  assert_eq(1969, final_total)
}
