// é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹é›†åˆ
// æµ‹è¯• azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½å’Œå®é™…åº”ç”¨åœºæ™¯

test "arithmetic_operations_comprehensive" {
  // ç»¼åˆæµ‹è¯•ç®—æœ¯è¿ç®—
  assert_eq(15, add(7, 8))
  assert_eq(-3, add(-10, 7))
  assert_eq(0, add(100, -100))
  
  assert_eq(42, multiply(6, 7))
  assert_eq(-24, multiply(-4, 6))
  assert_eq(0, multiply(0, 999))
}

test "divide_with_ceil_scenarios" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å„ç§åœºæ™¯
  assert_eq(3, divide_with_ceil(6, 2))    // æ•´é™¤
  assert_eq(4, divide_with_ceil(7, 2))    // éœ€è¦å‘ä¸Šå–æ•´
  assert_eq(1, divide_with_ceil(1, 100))  // åˆ†å­å°äºåˆ†æ¯
  assert_eq(0, divide_with_ceil(5, 0))    // é™¤æ•°ä¸ºé›¶çš„æƒ…å†µ
  assert_eq(-2, divide_with_ceil(-5, 3))  // è´Ÿæ•°é™¤æ³•
  assert_eq(3, divide_with_ceil(-8, -3))  // è´Ÿæ•°é™¤è´Ÿæ•°
}

test "greeting_function_variations" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å„ç§å˜ä½“
  assert_eq_string("Hello, Alice!", greet("Alice"))
  assert_eq_string("Hello, å¼ ä¸‰!", greet("å¼ ä¸‰"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, John Doe!", greet("John Doe"))
}

test "business_calculation_invoice" {
  // ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—å‘ç¥¨æ€»ä»·
  let unit_price = 85
  let quantity = 12
  let tax_rate = 8
  let shipping = 25
  
  let subtotal = multiply(unit_price, quantity)
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  let total = add(add(subtotal, tax), shipping)
  
  assert_eq(1151, total)  // 85*12 + ceil(1020*8/100) + 25 = 1020 + 82 + 25 = 1127
}

test "inventory_packaging_optimization" {
  // åº“å­˜åŒ…è£…ä¼˜åŒ–ï¼šè®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let small_items = 47
  let medium_items = 83
  let large_items = 156
  let box_capacity = 24
  
  let small_boxes = divide_with_ceil(small_items, box_capacity)
  let medium_boxes = divide_with_ceil(medium_items, box_capacity)
  let large_boxes = divide_with_ceil(large_items, box_capacity)
  let total_boxes = add(add(small_boxes, medium_boxes), large_boxes)
  
  assert_eq(2, small_boxes)   // ceil(47/24) = 2
  assert_eq(4, medium_boxes)  // ceil(83/24) = 4
  assert_eq(7, large_boxes)   // ceil(156/24) = 7
  assert_eq(13, total_boxes)  // 2 + 4 + 7 = 13
}

test "mathematical_sequence_calculation" {
  // æ•°å­¦åºåˆ—è®¡ç®—ï¼šç­‰å·®æ•°åˆ—æ±‚å’Œ
  let first_term = 5
  let common_diff = 3
  let num_terms = 8
  
  // ä½¿ç”¨å…¬å¼ S = n/2 * (2a + (n-1)d)
  let double_sum = multiply(num_terms, add(multiply(2, first_term), multiply(num_terms - 1, common_diff)))
  let sum = divide_with_ceil(double_sum, 2)
  
  assert_eq(104, sum)  // 8/2 * (10 + 21) = 4 * 31 = 124
}

test "complex_multi_step_calculation" {
  // å¤æ‚å¤šæ­¥è®¡ç®—ï¼šé¡¹ç›®é¢„ç®—è§„åˆ’
  let base_cost = 5000
  let team_size = 8
  let duration_months = 6
  let monthly_overhead = 1200
  let contingency_percent = 15
  
  // è®¡ç®—äººåŠ›æˆæœ¬
  let labor_cost = multiply(base_cost, team_size)
  // è®¡ç®—æ€»è¿è¥æˆæœ¬
  let total_overhead = multiply(monthly_overhead, duration_months)
  // è®¡ç®—åº”æ€¥èµ„é‡‘
  let contingency = divide_with_ceil(multiply(add(labor_cost, total_overhead), contingency_percent), 100)
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = add(add(labor_cost, total_overhead), contingency)
  
  assert_eq(63200, total_budget)  // 5000*8 + 1200*6 + ceil((40000+7200)*15/100) = 40000 + 7200 + 7080 = 54280
}

test "edge_cases_and_boundary_conditions" {
  // è¾¹ç•Œæ¡ä»¶å’Œç‰¹æ®Šæƒ…å†µæµ‹è¯•
  // é›¶å€¼æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(999, 0))
  assert_eq(0, divide_with_ceil(0, 10))
  
  // å•å€¼æµ‹è¯•
  assert_eq(1, add(1, 0))
  assert_eq(1, multiply(1, 1))
  assert_eq(1, divide_with_ceil(1, 1))
  
  // è´Ÿæ•°è¾¹ç•Œæµ‹è¯•
  assert_eq(-1, add(-1, 0))
  assert_eq(1, multiply(-1, -1))
  assert_eq(-1, multiply(1, -1))
  
  // å­—ç¬¦ä¸²è¾¹ç•Œæµ‹è¯•
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello,   !", greet("   "))
}