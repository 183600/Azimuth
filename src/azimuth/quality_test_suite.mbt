// é«˜è´¨é‡ MoonBit æµ‹è¯•å¥—ä»¶
// ä¸“æ³¨äºŽæ ¸å¿ƒåŠŸèƒ½çš„å…¨é¢æµ‹è¯•ï¼ŒåŒ…å«è¾¹ç•Œæƒ…å†µå’Œå®žé™…åº”ç”¨åœºæ™¯

// å¯¼å…¥å¿…è¦çš„ä¾èµ–
use "moonbitlang/core"

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼æ€§è´¨
  let x = 42
  
  // åŠ æ³•å•ä½å…ƒ
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•å•ä½å…ƒ
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  
  // ä¹˜æ³•é›¶å…ƒ
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
}

test "divide_with_ceil_comprehensive_scenarios" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å„ç§åœºæ™¯
  
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))   // 3.33... -> 4
  assert_eq(3, divide_with_ceil(9, 3))    // 3 -> 3
  assert_eq(1, divide_with_ceil(1, 100))  // 0.01 -> 1
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))  // -3.33... -> -3
  assert_eq(3, divide_with_ceil(10, -3))   // -3.33... -> -3
  assert_eq(4, divide_with_ceil(-10, -3))  // 3.33... -> 4
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))     // 0/5 = 0
  assert_eq(0, divide_with_ceil(5, 0))     // é™¤é›¶ä¿æŠ¤
  assert_eq(1, divide_with_ceil(1, 1))     // 1/1 = 1
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—ï¼šç”µå•†è®¢å•æ€»ä»·è®¡ç®—
  let product_price = 89
  let quantity = 4
  let tax_rate = 8  // 8%
  let shipping_cost = 12
  let discount_threshold = 300
  let discount_amount = 25
  
  // è®¡ç®—å•†å“å°è®¡
  let subtotal = multiply(product_price, quantity)
  
  // è®¡ç®—ç¨Žè´¹ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let tax_amount = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = add(add(subtotal, tax_amount), shipping_cost)
  
  // åº”ç”¨æŠ˜æ‰£ï¼ˆå¦‚æžœæ»¡è¶³æ¡ä»¶ï¼‰
  let final_total = if pre_discount_total > discount_threshold {
    add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  assert_eq(356, subtotal)           // 89 * 4
  assert_eq(29, tax_amount)          // ceil(356 * 8 / 100)
  assert_eq(397, pre_discount_total) // 356 + 29 + 12
  assert_eq(372, final_total)        // 397 - 25 (è¶…è¿‡é˜ˆå€¼)
}

test "string_processing_internationalization" {
  // å­—ç¬¦ä¸²å¤„ç†å›½é™…åŒ–æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ðŸŒŸ!", greet("ðŸŒŸ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ÐœÐ¾ÑÐºÐ²Ð°!", greet("ÐœÐ¾ÑÐºÐ²Ð°"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ðŸ³ï¸â€ðŸŒˆ!", greet("ðŸ³ï¸â€ðŸŒˆ"))
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  
  // O(1) å¸¸æ•°æ—¶é—´æ“ä½œ
  let constant_time = multiply(42, 2)
  
  // O(n) çº¿æ€§æ—¶é—´æ“ä½œæ¨¡æ‹Ÿ
  let input_size = 1000
  let linear_time = multiply(input_size, 3)
  
  // O(log n) å¯¹æ•°æ—¶é—´æ“ä½œæ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let log_time = divide_with_ceil(input_size, 100)
  
  // O(nÂ²) äºŒæ¬¡æ—¶é—´æ“ä½œæ¨¡æ‹Ÿ
  let quadratic_time = divide_with_ceil(multiply(input_size, input_size), 10000)
  
  assert_eq(84, constant_time)
  assert_eq(3000, linear_time)
  assert_eq(10, log_time)
  assert_eq(100, quadratic_time)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–é—®é¢˜
  
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory_mb = 16384
  let num_servers = 5
  
  // è®¡ç®—æ¯å°æœåŠ¡å™¨åˆ†é…çš„å†…å­˜ï¼ˆå‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–ï¼‰
  let memory_per_server = divide_with_ceil(total_memory_mb, num_servers)
  
  // è®¡ç®—å®žé™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, num_servers)
  
  // è®¡ç®—å†…å­˜æµªè´¹
  let memory_waste = subtract(total_allocated, total_memory_mb)
  
  // éªŒè¯åˆ†é…åˆç†æ€§
  let utilization_percent = divide_with_ceil(multiply(total_memory_mb, 100), total_allocated)
  
  assert_eq(3277, memory_per_server)    // ceil(16384 / 5)
  assert_eq(16385, total_allocated)     // 3277 * 5
  assert_eq(1, memory_waste)            // 16385 - 16384
  assert_eq(99, utilization_percent)    // floor(16384 * 100 / 16385)
}

test "financial_compound_interest" {
  // é‡‘èžå¤åˆ©è®¡ç®—æ¨¡æ‹Ÿ
  
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  
  // å¹´åº¦å¤åˆ©è®¡ç®—ï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´æ¨¡æ‹Ÿé“¶è¡Œèˆå…¥ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year3_end, total_months)
  
  assert_eq(10500, year1_end)    // 10000 + ceil(10000 * 5 / 100)
  assert_eq(11025, year2_end)    // 10500 + ceil(10500 * 5 / 100)
  assert_eq(11576, year3_end)    // 11025 + ceil(11025 * 5 / 100)
  assert_eq(322, monthly_payment) // ceil(11576 / 36)
}

test "data_structure_operations_simulation" {
  // æ•°æ®ç»“æž„æ“ä½œæ¨¡æ‹Ÿ
  
  // æ ˆæ“ä½œæ¨¡æ‹Ÿ
  let stack_initial_size = 0
  let stack_after_push = add(stack_initial_size, 5)
  let stack_after_pop = subtract(stack_after_push, 2)
  
  // é˜Ÿåˆ—æ“ä½œæ¨¡æ‹Ÿ
  let queue_capacity = 10
  let queue_items = 7
  let queue_remaining = subtract(queue_capacity, queue_items)
  let can_enqueue = queue_remaining > 0
  
  // å“ˆå¸Œè¡¨è´Ÿè½½å› å­è®¡ç®—
  let hash_table_size = 16
  let hash_elements = 11
  let load_factor = divide_with_ceil(multiply(hash_elements, 100), hash_table_size)
  
  assert_eq(5, stack_after_push)
  assert_eq(3, stack_after_pop)
  assert_eq(3, queue_remaining)
  assert_true(can_enqueue)
  assert_eq(69, load_factor)  // ceil(11 * 100 / 16)
}

test "extreme_boundary_conditions" {
  // æžç«¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  
  // å¤§æ•°è¿ç®—
  let large_num = 1000000
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(1000000000000, multiply(large_num, large_num))
  
  // æŽ¥è¿‘æ•´æ•°è¾¹ç•Œ
  let near_max = 2147483640
  let near_min = -2147483640
  assert_eq(2147483641, add(near_max, 1))
  assert_eq(-2147483641, add(near_min, -1))
  
  // æžå€¼é™¤æ³•
  assert_eq(1, divide_with_ceil(1, 1000000))
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  
  // é›¶å€¼è¿ç®—
  assert_eq(0, multiply(0, 1000000))
  assert_eq(1000000, add(0, 1000000))
  assert_eq(0, divide_with_ceil(0, 1000000))
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}