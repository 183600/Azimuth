// é«˜è´¨é‡ MoonBit æµ‹è¯•å¥—ä»¶
// åŒ…å«10ä¸ªç²¾å¿ƒè®¾è®¡çš„æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–å„ç§åœºæ™¯

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰æ€§è´¨
  let a = 42
  let b = 17
  
  // åŠ æ³•æ’ç­‰å¾‹ï¼ša + 0 = a
  assert_eq(a, add(a, 0))
  assert_eq(b, add(0, b))
  
  // ä¹˜æ³•æ’ç­‰å¾‹ï¼ša Ã— 1 = a
  assert_eq(a, multiply(a, 1))
  assert_eq(b, multiply(1, b))
  
  // ä¹˜æ³•é›¶å¾‹ï¼ša Ã— 0 = 0
  assert_eq(0, multiply(a, 0))
  assert_eq(0, multiply(0, b))
}

test "boundary_value_comprehensive" {
  // ç»¼åˆè¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼è¾¹ç•Œæµ‹è¯•
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  
  // æœ€å°å€¼è¾¹ç•Œæµ‹è¯•
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(min_val, -1))  // ç‰¹æ®Šæƒ…å†µå¤„ç†
  
  // è¾¹ç•Œå€¼ç»„åˆ
  assert_eq(-1, add(max_val, min_val))
  assert_eq(0, multiply(max_val, 0))
}

test "string_processing_internationalization" {
  // å›½é™…åŒ–å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  let english_name = "John"
  let chinese_name = "å¼ ä¸‰"
  let japanese_name = "ç”°ä¸­"
  let emoji_name = "ğŸŒŸ"
  let mixed_name = "User_2023ğŸš€"
  
  assert_eq_string("Hello, John!", greet(english_name))
  assert_eq_string("Hello, å¼ ä¸‰!", greet(chinese_name))
  assert_eq_string("Hello, ç”°ä¸­!", greet(japanese_name))
  assert_eq_string("Hello, ğŸŒŸ!", greet(emoji_name))
  assert_eq_string("Hello, User_2023ğŸš€!", greet(mixed_name))
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000  // æœ¬é‡‘
  let rate = 5           // å¹´åˆ©ç‡5%
  let years = 3          // 3å¹´
  let fee = 50           // æ‰‹ç»­è´¹
  
  // å¤åˆ©è®¡ç®—ï¼šæœ¬æ¯å’Œ = æœ¬é‡‘ Ã— (1 + åˆ©ç‡ Ã— å¹´æ•°)
  let interest_factor = add(1, multiply(rate, years))  // 1 + 5Ã—3 = 16
  let total_with_interest = multiply(principal, interest_factor)  // 10000 Ã— 16 = 160000
  
  // å‡å»æ‰‹ç»­è´¹
  let final_amount = add(total_with_interest, -fee)  // 160000 - 50 = 159950
  
  assert_eq(159950, final_amount)
}

test "algorithmic_efficiency_test" {
  // ç®—æ³•æ•ˆç‡æµ‹è¯•ï¼šéªŒè¯ä¸åŒè®¡ç®—æ–¹æ³•çš„ç»“æœä¸€è‡´æ€§
  let num1 = 10
  let num2 = 20
  let num3 = 30
  let num4 = 40
  let num5 = 50
  
  // æ–¹æ³•1ï¼šé€ä¸ªç›¸åŠ 
  let sum1 = add(add(add(add(num1, num2), num3), num4), num5)
  
  // æ–¹æ³•2ï¼šåˆ†ç»„ç›¸åŠ å†åˆå¹¶
  let group1 = add(num1, num2)  // 10 + 20 = 30
  let group2 = add(num3, num4)  // 30 + 40 = 70
  let sum2 = add(add(group1, group2), num5)  // 30 + 70 + 50 = 150
  
  // éªŒè¯ç»“æœä¸€è‡´æ€§
  assert_eq(sum1, sum2)
  assert_eq(150, sum1)
}

test "geometry_area_calculations" {
  // å‡ ä½•é¢ç§¯è®¡ç®—æµ‹è¯•
  let rectangle_length = 12
  let rectangle_width = 8
  let triangle_base = 10
  let triangle_height = 6
  let trapezoid_base1 = 8
  let trapezoid_base2 = 12
  let trapezoid_height = 5
  
  // çŸ©å½¢é¢ç§¯ = é•¿ Ã— å®½
  let rectangle_area = multiply(rectangle_length, rectangle_width)
  assert_eq(96, rectangle_area)
  
  // ä¸‰è§’å½¢é¢ç§¯ = åº• Ã— é«˜ Ã· 2
  let triangle_area = multiply(triangle_base, triangle_height) / 2
  assert_eq(30, triangle_area)
  
  // æ¢¯å½¢é¢ç§¯ = (ä¸Šåº• + ä¸‹åº•) Ã— é«˜ Ã· 2
  let trapezoid_area = multiply(add(trapezoid_base1, trapezoid_base2), trapezoid_height) / 2
  assert_eq(50, trapezoid_area)
}

test "time_zone_conversion" {
  // æ—¶åŒºè½¬æ¢è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let local_hour = 15  // æœ¬åœ°æ—¶é—´ä¸‹åˆ3ç‚¹
  let utc_offset = -8  // UTC-8æ—¶åŒº
  let meeting_offset = 9  // è¦è½¬æ¢åˆ°UTC+9æ—¶åŒº
  
  // è½¬æ¢ä¸ºUTCæ—¶é—´
  let utc_hour = add(local_hour, -utc_offset)  // 15 - (-8) = 23
  let normalized_utc = if utc_hour >= 24 { add(utc_hour, -24) } else { utc_hour }
  
  // è½¬æ¢ä¸ºç›®æ ‡æ—¶åŒº
  let target_hour = add(normalized_utc, meeting_offset)  // 23 + 9 = 32
  let final_hour = if target_hour >= 24 { add(target_hour, -24) } else { target_hour }
  
  assert_eq(8, final_hour)  // æœ€ç»ˆæ—¶é—´æ˜¯ä¸Šåˆ8ç‚¹
}

test "statistical_analysis" {
  // ç»Ÿè®¡åˆ†ææµ‹è¯•
  let data1 = 85
  let data2 = 90
  let data3 = 78
  let data4 = 92
  let data5 = 80
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(data1, data2), data3), data4), data5)
  assert_eq(425, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let average = sum / 5
  assert_eq(85, average)
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼šå¹³æ–¹å·®çš„å¹³å‡å€¼
  let diff1 = add(data1, -average)  // 85 - 85 = 0
  let diff2 = add(data2, -average)  // 90 - 85 = 5
  let diff3 = add(data3, -average)  // 78 - 85 = -7
  let diff4 = add(data4, -average)  // 92 - 85 = 7
  let diff5 = add(data5, -average)  // 80 - 85 = -5
  
  let variance = add(add(add(add(multiply(diff1, diff1), multiply(diff2, diff2)), 
                           multiply(diff3, diff3)), multiply(diff4, diff4)), multiply(diff5, diff5)) / 5
  assert_eq(28, variance)
}

test "game_mechanics_calculation" {
  // æ¸¸æˆæœºåˆ¶è®¡ç®—æµ‹è¯•
  let base_damage = 100
  let weapon_multiplier = 15  // æ­¦å™¨å€ç‡
  let critical_bonus = 2       // æš´å‡»ä¼¤å®³å€ç‡
  
  // åŸºç¡€ä¼¤å®³è®¡ç®—
  let weapon_damage = multiply(base_damage, weapon_multiplier)
  
  // æš´å‡»åˆ¤å®šï¼ˆç®€åŒ–ï¼šå‡è®¾è§¦å‘æš´å‡»ï¼‰
  let is_critical = true  // æ¨¡æ‹Ÿæš´å‡»è§¦å‘
  let final_damage = if is_critical { 
    multiply(weapon_damage, critical_bonus) 
  } else { 
    weapon_damage 
  }
  
  assert_eq(3000, final_damage)  // 100 Ã— 15 Ã— 2 = 3000
  
  // è¿å‡»ä¼¤å®³è®¡ç®—
  let combo_count = 3
  let combo_multiplier = add(1, multiply(combo_count, 10))  // 1 + 3Ã—10 = 31
  let combo_damage = multiply(final_damage, combo_multiplier) / 10
  
  assert_eq(9300, combo_damage)  // 3000 Ã— 31 Ã· 10 = 9300
}

test "data_validation_scenarios" {
  // æ•°æ®éªŒè¯åœºæ™¯æµ‹è¯•
  let input_positive = 42
  let input_negative = -17
  let input_zero = 0
  let input_max = 2147483647
  let input_min = -2147483648
  
  // éªŒè¯æ­£æ•°å¤„ç†
  assert_true(input_positive > 0)
  assert_true(add(input_positive, 1) > input_positive)
  
  // éªŒè¯è´Ÿæ•°å¤„ç†
  assert_true(input_negative < 0)
  assert_true(add(input_negative, -1) < input_negative)
  
  // éªŒè¯é›¶å€¼å¤„ç†
  assert_true(input_zero == 0)
  assert_eq(input_positive, add(input_zero, input_positive))
  assert_eq(0, multiply(input_zero, input_positive))
  
  // éªŒè¯è¾¹ç•Œå€¼å¤„ç†
  assert_true(input_max > 0)
  assert_true(input_min < 0)
  assert_eq(input_max, add(input_max, 1))  // æº¢å‡ºä¿æŠ¤
  assert_eq(input_min, add(input_min, -1))  // æº¢å‡ºä¿æŠ¤
  
  // å­—ç¬¦ä¸²éªŒè¯
  let valid_string = "ValidInput123"
  let empty_string = ""
  let special_string = "Special@#$%"
  
  assert_eq_string("Hello, ValidInput123!", greet(valid_string))
  assert_eq_string("Hello, !", greet(empty_string))
  assert_eq_string("Hello, Special@#$%!", greet(special_string))
}