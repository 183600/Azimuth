// æ–°çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œæµ‹è¯•

test "add_function_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  let a = 15
  let b = 27
  assert_eq(add(a, b), add(b, a))
  assert_eq(42, add(15, 27))
  assert_eq(42, add(27, 15))
}

test "multiply_function_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 5
  let b = 8
  let c = 12
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
}

test "divide_with_ceil_comprehensive_test" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  
  // é›¶é™¤æ•°å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  let unit_price = 45
  let quantity = 6
  let tax_rate = 8
  let shipping = 15
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(unit_price, quantity)
  
  // è®¡ç®—ç¨è´¹
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æ€»ä»·
  let total = add(add(subtotal, tax), shipping)
  
  assert_eq(270, subtotal)
  assert_eq(22, tax)
  assert_eq(307, total)
}

test "mathematical_series_sum" {
  // æ•°å­¦çº§æ•°æ±‚å’Œï¼šç­‰å·®æ•°åˆ— 1 + 3 + 5 + ... + 19
  let first_term = 1
  let common_difference = 2
  let number_of_terms = 10
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šS = n/2 * (2a + (n-1)d)
  let sum = divide_with_ceil(
    multiply(number_of_terms, add(multiply(2, first_term), multiply(number_of_terms - 1, common_difference))),
    2
  )
  
  assert_eq(100, sum)
}

test "inventory_packaging_optimization" {
  // åº“å­˜åŒ…è£…ä¼˜åŒ–è®¡ç®—
  let total_items = 127
  let box_capacity = 15
  let layers_per_box = 3
  
  // è®¡ç®—éœ€è¦çš„ç›’å­æ•°é‡
  let boxes_needed = divide_with_ceil(total_items, box_capacity)
  
  // è®¡ç®—æ€»å±‚æ•°
  let total_layers = multiply(boxes_needed, layers_per_box)
  
  // è®¡ç®—æ¯å±‚å¹³å‡ç‰©å“æ•°
  let items_per_layer = divide_with_ceil(total_items, total_layers)
  
  assert_eq(9, boxes_needed)
  assert_eq(27, total_layers)
  assert_eq(5, items_per_layer)
}

test "time_zone_conversion" {
  // æ—¶åŒºè½¬æ¢è®¡ç®—
  let local_time = 14  // ä¸‹åˆ2ç‚¹
  let time_difference = 8  // æ—¶å·®8å°æ—¶
  
  // è®¡ç®—è¿œç¨‹æ—¶é—´ï¼ˆä½¿ç”¨24å°æ—¶åˆ¶ï¼‰
  let remote_time_raw = add(local_time, time_difference)
  let remote_time = if remote_time_raw >= 24 {
    add(remote_time_raw, -24)
  } else {
    remote_time_raw
  }
  
  assert_eq(22, remote_time)
}

test "resource_allocation_algorithm" {
  // èµ„æºåˆ†é…ç®—æ³•
  let total_resources = 500
  let project_requirements = [120, 80, 150, 90]
  
  // è®¡ç®—æ€»éœ€æ±‚
  let total_required = add(add(add(project_requirements[0], project_requirements[1]), project_requirements[2]), project_requirements[3])
  
  // è®¡ç®—å‰©ä½™èµ„æº
  let remaining_resources = add(total_resources, -total_required)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡ï¼ˆæ¯ä¸ªå°é¡¹ç›®éœ€è¦20ä¸ªèµ„æºï¼‰
  let small_projects = divide_with_ceil(remaining_resources, 20)
  
  assert_eq(440, total_required)
  assert_eq(60, remaining_resources)
  assert_eq(3, small_projects)
}

test "data_structure_simulation" {
  // æ•°æ®ç»“æ„æ¨¡æ‹Ÿï¼šè®¡ç®—æ•°ç»„ç»Ÿè®¡ä¿¡æ¯
  let data = [15, 22, 8, 19, 12]
  let data_size = 5
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(data[0], data[1]), data[2]), data[3]), data[4])
  
  // è®¡ç®—å¹³å‡å€¼ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let average = divide_with_ceil(sum, data_size)
  
  // è®¡ç®—æœ€å¤§å€¼ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let max_value = add(add(add(add(data[0], 
    if data[1] > data[0] { data[1] - data[0] } else { 0 }), 
    if data[2] > data[0] { data[2] - data[0] } else { 0 }),
    if data[3] > data[0] { data[3] - data[0] } else { 0 }),
    if data[4] > data[0] { data[4] - data[0] } else { 0 })
  
  assert_eq(76, sum)
  assert_eq(16, average)
  assert_eq(22, max_value)
}