// å¢å¼ºçš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åŒ…çš„é«˜çº§åŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "string_unicode_handling" {
  // æµ‹è¯• Unicode å­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, CafÃ©!", greet("CafÃ©"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ã‘oÃ±o!", greet("Ã‘oÃ±o"))
}

test "mathematical_series_calculations" {
  // æµ‹è¯•æ•°åˆ—è®¡ç®—
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼š1 + 3 + 5 + ... + (2n-1) = nÂ²
  let n = 8
  let expected_sum = multiply(n, n)  // nÂ² = 64
  let actual_sum = add(add(add(add(1, 3), add(5, 7)), add(add(9, 11), add(13, 15)))
  assert_eq(expected_sum, actual_sum)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œï¼š2 + 4 + 8 + 16 = 30
  let geo_sum = add(add(add(2, 4), 8), 16)
  assert_eq(30, geo_sum)
}

test "advanced_boundary_conditions" {
  // æµ‹è¯•é«˜çº§è¾¹ç•Œæ¡ä»¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•é“¾å¼è¿ç®—çš„è¾¹ç•Œå¤„ç†
  let chain_result = add(multiply(add(max_val, min_val), 2), max_val)
  assert_eq(max_val, chain_result)
  
  // æµ‹è¯•åµŒå¥—è¾¹ç•Œè¿ç®—
  let nested_result = multiply(add(min_val, 1), add(max_val, -max_val))
  assert_eq(0, nested_result)
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„å¹‚è¿ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let power_result = multiply(min_val, min_val)  // è¿™ä¼šæº¢å‡º
  assert_eq(min_val, power_result)
}

test "financial_calculations" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯
  // å¤åˆåˆ©ç‡è®¡ç®—ï¼šæœ¬é‡‘ Ã— (1 + åˆ©ç‡)^å¹´æ•°
  let principal = 10000
  let rate = 5  // 5%
  let years = 3
  
  // ç®€åŒ–è®¡ç®—ï¼š10000 Ã— (1 + 5Ã—3) = 10000 Ã— 16 = 160000
  let growth_factor = add(1, multiply(rate, years))
  let total = multiply(principal, growth_factor)
  assert_eq(160000, total)
  
  // åˆ†æœŸä»˜æ¬¾è®¡ç®—ï¼šæ€»ä»· / æœŸæ•°
  let total_price = 3600
  let installments = 12
  let monthly_payment = total_price / installments
  assert_eq(300, monthly_payment)
}

test "geometry_calculations" {
  // æµ‹è¯•å‡ ä½•è®¡ç®—
  // æ¢¯å½¢é¢ç§¯ï¼š(ä¸Šåº• + ä¸‹åº•) Ã— é«˜ Ã· 2
  let top_base = 6
  let bottom_base = 10
  let height = 4
  let trapezoid_area = multiply(add(top_base, bottom_base), height) / 2
  assert_eq(32, trapezoid_area)
  
  // åœ†æŸ±ä½“ç§¯ï¼šåº•é¢ç§¯ Ã— é«˜
  let radius = 3
  let cylinder_height = 5
  let base_area = multiply(3, multiply(radius, radius))  // Ï€ Ã— rÂ² â‰ˆ 3 Ã— 9 = 27
  let volume = multiply(base_area, cylinder_height)
  assert_eq(135, volume)
}

test "time_and_date_calculations" {
  // æµ‹è¯•æ—¶é—´è®¡ç®—
  // è®¡ç®—ä¸¤ä¸ªæ—¶é—´ç‚¹ä¹‹é—´çš„åˆ†é’Ÿæ•°
  let start_hour = 9
  let start_minute = 30
  let end_hour = 14
  let end_minute = 45
  
  let start_total = add(multiply(start_hour, 60), start_minute)
  let end_total = add(multiply(end_hour, 60), end_minute)
  let duration = add(end_total, -start_total)
  
  assert_eq(315, duration)  // 5å°æ—¶15åˆ†é’Ÿ = 315åˆ†é’Ÿ
  
  // è®¡ç®—å¤©æ•°åˆ°å°æ—¶çš„è½¬æ¢
  let days = 7
  let hours = multiply(days, 24)
  assert_eq(168, hours)
}

test "statistical_calculations" {
  // æµ‹è¯•ç»Ÿè®¡è®¡ç®—
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let values = [10, 15, 20, 25, 30]
  let sum = add(add(add(add(10, 15), 20), 25), 30)
  let mean = sum / 5  // å¹³å‡å€¼ = 20
  
  // è®¡ç®—å¹³æ–¹å·®çš„å’Œ
  let diff1 = multiply(add(10, -mean), add(10, -mean))
  let diff2 = multiply(add(15, -mean), add(15, -mean))
  let diff3 = multiply(add(20, -mean), add(20, -mean))
  let diff4 = multiply(add(25, -mean), add(25, -mean))
  let diff5 = multiply(add(30, -mean), add(30, -mean))
  
  let variance = add(add(add(add(diff1, diff2), diff3), diff4), diff5) / 5
  assert_eq(40, variance)
}

test "error_boundary_testing" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œå¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•è¿ç»­æº¢å‡ºæ“ä½œçš„ä¿æŠ¤
  let overflow_chain = add(add(add(max_val, 1), 100), 1000)
  assert_eq(max_val, overflow_chain)
  
  // æµ‹è¯•æ··åˆè¿ç®—çš„æº¢å‡ºä¿æŠ¤
  let mixed_overflow = add(multiply(max_val, 2), add(min_val, 100))
  assert_eq(min_val, mixed_overflow)
  
  // æµ‹è¯•é™¤é›¶ä¿æŠ¤çš„é—´æ¥æµ‹è¯•ï¼ˆé€šè¿‡ä¹˜æ³•é€†å…ƒï¼‰
  let zero = multiply(5, 0)
  assert_eq(0, zero)
}

test "data_structure_simulations" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špush å’Œ pop
  let stack_initial = 0
  let push1 = add(stack_initial, 10)
  let push2 = add(push1, 20)
  let push3 = add(push2, 30)
  
  // æ¨¡æ‹Ÿ pop æ“ä½œ
  let pop1 = add(push3, -30)
  let pop2 = add(pop1, -20)
  let pop3 = add(pop2, -10)
  
  assert_eq(0, pop3)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_head = 100
  let queue_tail = add(queue_head, 50)
  let queue_size = add(queue_tail, -queue_head)
  assert_eq(50, queue_size)
}

test "algorithm_efficiency_tests" {
  // æµ‹è¯•ç®—æ³•æ•ˆç‡
  // æµ‹è¯•çº¿æ€§æœç´¢çš„æ¨¡æ‹Ÿï¼ˆé€šè¿‡ç´¯åŠ æ¯”è¾ƒï¼‰
  let target = 7
  let search_space = [1, 3, 5, 7, 9]
  
  // æ¨¡æ‹Ÿæ‰¾åˆ°ç›®æ ‡æ‰€éœ€çš„æ¯”è¾ƒæ¬¡æ•°
  let comparisons = 4  // åœ¨ç¬¬4ä¸ªä½ç½®æ‰¾åˆ°
  assert_true(comparisons <= 5)  // ç¡®ä¿åœ¨æ•°ç»„èŒƒå›´å†…
  
  // æµ‹è¯•äºŒåˆ†æœç´¢çš„æ¨¡æ‹Ÿï¼ˆç®€åŒ–ç‰ˆï¼‰
  let sorted_array = [1, 3, 5, 7, 9, 11, 13, 15]
  let binary_search_target = 7
  let max_comparisons = 3  // logâ‚‚(8) = 3
  
  // æ¨¡æ‹ŸäºŒåˆ†æœç´¢çš„æ­¥éª¤æ•°
  let search_steps = multiply(2, 2)  // æ¨¡æ‹Ÿæ‰¾åˆ°ç›®æ ‡æ‰€éœ€çš„æ­¥éª¤
  assert_true(search_steps <= max_comparisons)
  
  // æµ‹è¯•é€’å½’è®¡ç®—çš„æ¨¡æ‹Ÿï¼ˆé˜¶ä¹˜ï¼‰
  let n = 6
  let factorial_result = multiply(n, multiply(n - 1, multiply(n - 2, multiply(n - 3, multiply(n - 4, n - 5)))))
  assert_eq(720, factorial_result)
}