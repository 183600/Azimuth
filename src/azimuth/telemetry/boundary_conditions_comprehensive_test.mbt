// è¾¹ç•Œæ¡ä»¶æµ‹è¯• - æµ‹è¯•æç«¯å€¼å’Œå¼‚å¸¸è¾“å…¥å¤„ç†
// éªŒè¯Azimuth Telemetryåœ¨è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„ç¨³å®šæ€§

test "attribute_value_boundary_conditions" {
  // æµ‹è¯•å±æ€§å€¼çš„è¾¹ç•Œæ¡ä»¶
  
  // 1. æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œæé•¿å­—ç¬¦ä¸²
  let empty_string_attr = common::AttributeValue::string("")
  match empty_string_attr {
    common::StringValue(s) => {
      assert_eq(s.length(), 0)
      assert_eq(s, "")
    }
    _ => assert_eq(false, true, "Expected StringValue for empty string")
  }
  
  // åˆ›å»ºä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼ˆæ¨¡æ‹Ÿè¾¹ç•Œæ¡ä»¶ï¼‰
  let very_long_string = ""
  let mut i = 0
  while i < 1000 {
    very_long_string = very_long_string + "a"
    i = i + 1
  }
  
  let long_string_attr = common::AttributeValue::string(very_long_string)
  match long_string_attr {
    common::StringValue(s) => {
      assert_eq(s.length(), 1000)
      assert_eq(s.has_prefix("aaa"), true)
    }
    _ => assert_eq(false, true, "Expected StringValue for long string")
  }
  
  // 2. æµ‹è¯•æå€¼æ•´æ•°
  let max_int_attr = common::AttributeValue::int(9223372036854775807L)  // Int64æœ€å¤§å€¼
  match max_int_attr {
    common::IntValue(n) => {
      assert_eq(n, 9223372036854775807L)
      assert_eq(n > 0L, true)
    }
    _ => assert_eq(false, true, "Expected IntValue for max int")
  }
  
  let min_int_attr = common::AttributeValue::int(-9223372036854775808L)  // Int64æœ€å°å€¼
  match min_int_attr {
    common::IntValue(n) => {
      assert_eq(n, -9223372036854775808L)
      assert_eq(n < 0L, true)
    }
    _ => assert_eq(false, true, "Expected IntValue for min int")
  }
  
  let zero_int_attr = common::AttributeValue::int(0L)
  match zero_int_attr {
    common::IntValue(n) => {
      assert_eq(n, 0L)
    }
    _ => assert_eq(false, true, "Expected IntValue for zero")
  }
  
  // 3. æµ‹è¯•æå€¼æµ®ç‚¹æ•°
  let max_float_attr = common::AttributeValue::float(1.7976931348623157e+308)  // Doubleæœ€å¤§å€¼
  match max_float_attr {
    common::FloatValue(f) => {
      assert_eq(f > 1.0e+308, true)
    }
    _ => assert_eq(false, true, "Expected FloatValue for max float")
  }
  
  let min_positive_float_attr = common::AttributeValue::float(2.2250738585072014e-308)  // æœ€å°æ­£åŒç²¾åº¦
  match min_positive_float_attr {
    common::FloatValue(f) => {
      assert_eq(f > 0.0, true)
      assert_eq(f < 1.0e-307, true)
    }
    _ => assert_eq(false, true, "Expected FloatValue for min positive float")
  }
  
  let zero_float_attr = common::AttributeValue::float(0.0)
  match zero_float_attr {
    common::FloatValue(f) => {
      assert_eq(f, 0.0)
    }
    _ => assert_eq(false, true, "Expected FloatValue for zero")
  }
  
  let negative_zero_attr = common::AttributeValue::float(-0.0)
  match negative_zero_attr {
    common::FloatValue(f) => {
      assert_eq(f, -0.0)
    }
    _ => assert_eq(false, true, "Expected FloatValue for negative zero")
  }
  
  let infinity_attr = common::AttributeValue::float(1.0 / 0.0)  // æ­£æ— ç©·
  match infinity_attr {
    common::FloatValue(f) => {
      assert_eq(f > 1.0e+308, true)  // æ£€æŸ¥æ˜¯å¦ä¸ºæ— ç©·å¤§
    }
    _ => assert_eq(false, true, "Expected FloatValue for infinity")
  }
  
  let negative_infinity_attr = common::AttributeValue::float(-1.0 / 0.0)  // è´Ÿæ— ç©·
  match negative_infinity_attr {
    common::FloatValue(f) => {
      assert_eq(f < -1.0e+308, true)  // æ£€æŸ¥æ˜¯å¦ä¸ºè´Ÿæ— ç©·å¤§
    }
    _ => assert_eq(false, true, "Expected FloatValue for negative infinity")
  }
  
  // 4. æµ‹è¯•NaNå€¼
  let nan_attr = common::AttributeValue::float(0.0 / 0.0)  // NaN
  match nan_attr {
    common::FloatValue(f) => {
      // NaNä¸ç­‰äºä»»ä½•å€¼ï¼ŒåŒ…æ‹¬å®ƒè‡ªå·±
      assert_eq(f != f, true)
    }
    _ => assert_eq(false, true, "Expected FloatValue for NaN")
  }
  
  // 5. æµ‹è¯•æå°å’Œæå¤§çš„æ•°ç»„
  let empty_array_attr = common::AttributeValue::array_string([])
  match empty_array_attr {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 0)
    }
    _ => assert_eq(false, true, "Expected ArrayStringValue for empty array")
  }
  
  let single_element_array_attr = common::AttributeValue::array_int([42L])
  match single_element_array_attr {
    common::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], 42L)
    }
    _ => assert_eq(false, true, "Expected ArrayIntValue for single element array")
  }
  
  // åˆ›å»ºå¤§æ•°ç»„
  let large_int_array = [] : Array[Int64]
  let mut i = 0
  while i < 10000 {
    large_int_array.push(i.to_int64())
    i = i + 1
  }
  
  let large_array_attr = common::AttributeValue::array_int(large_int_array)
  match large_array_attr {
    common::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 10000)
      assert_eq(arr[0], 0L)
      assert_eq(arr[9999], 9999L)
    }
    _ => assert_eq(false, true, "Expected ArrayIntValue for large array")
  }
}

test "span_timestamp_boundary_conditions" {
  // æµ‹è¯•spanæ—¶é—´æˆ³çš„è¾¹ç•Œæ¡ä»¶
  
  // 1. æµ‹è¯•æœ€å°æ—¶é—´æˆ³ï¼ˆUnixçºªå…ƒï¼‰
  let min_timestamp = 0L
  let span_with_min_time = trace::Span::{
    name: "min_time_span",
    context: trace::SpanContext::{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
      trace_flags: 0_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: min_timestamp,
    end_time_unix_nanos: Some(min_timestamp + 1000L),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  assert_eq(span_with_min_time.start_time_unix_nanos, 0L)
  assert_eq(span_with_min_time.end_time_unix_nanos.unwrap(), 1000L)
  
  // 2. æµ‹è¯•æœ€å¤§åˆç†æ—¶é—´æˆ³ï¼ˆé¥è¿œçš„æœªæ¥ï¼‰
  let max_timestamp = 253402300799999999999L  // 9999-12-31 23:59:59.999999999 UTC
  let span_with_max_time = trace::Span::{
    name: "max_time_span",
    context: trace::SpanContext::{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
      trace_flags: 0_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: max_timestamp - 1000000L,
    end_time_unix_nanos: Some(max_timestamp),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  assert_eq(span_with_max_time.start_time_unix_nanos, max_timestamp - 1000000L)
  assert_eq(span_with_max_time.end_time_unix_nanos.unwrap(), max_timestamp)
  
  // 3. æµ‹è¯•è´Ÿæ—¶é—´æˆ³ï¼ˆUnixçºªå…ƒä¹‹å‰ï¼‰
  let negative_timestamp = -86400000000000L  // 1969-12-31 00:00:00 UTC
  let span_with_negative_time = trace::Span::{
    name: "negative_time_span",
    context: trace::SpanContext::{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
      trace_flags: 0_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: negative_timestamp,
    end_time_unix_nanos: Some(negative_timestamp + 1000000L),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  assert_eq(span_with_negative_time.start_time_unix_nanos, negative_timestamp)
  assert_eq(span_with_negative_time.end_time_unix_nanos.unwrap(), negative_timestamp + 1000000L)
  
  // 4. æµ‹è¯•é›¶æŒç»­æ—¶é—´span
  let zero_duration_span = trace::Span::{
    name: "zero_duration_span",
    context: trace::SpanContext::{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
      trace_flags: 0_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: 1640995200000000000L,
    end_time_unix_nanos: Some(1640995200000000000L),  // ç›¸åŒæ—¶é—´æˆ³
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  assert_eq(zero_duration_span.start_time_unix_nanos, zero_duration_span.end_time_unix_nanos.unwrap())
  
  // 5. æµ‹è¯•æé•¿æŒç»­æ—¶é—´span
  let long_duration_start = 1640995200000000000L
  let long_duration_end = 253402300799999999999L  // çº¦8000å¹´
  let long_duration_span = trace::Span::{
    name: "long_duration_span",
    context: trace::SpanContext::{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
      trace_flags: 0_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: long_duration_start,
    end_time_unix_nanos: Some(long_duration_end),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  assert_eq(long_duration_span.end_time_unix_nanos.unwrap() > long_duration_span.start_time_unix_nanos, true)
  
  // 6. æµ‹è¯•æ— æ•ˆæ—¶é—´é¡ºåºï¼ˆç»“æŸæ—¶é—´æ—©äºå¼€å§‹æ—¶é—´ï¼‰
  let invalid_time_span = trace::Span::{
    name: "invalid_time_span",
    context: trace::SpanContext::{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
      trace_flags: 0_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: 1640995200000000000L,
    end_time_unix_nanos: Some(1640995100000000000L),  // æ—©äºå¼€å§‹æ—¶é—´
    status: trace::Error,
    status_description: Some("Invalid time order"),
    attributes: [],
    events: [],
    links: []
  }
  
  assert_eq(invalid_time_span.status, trace::Error)
  assert_eq(invalid_time_span.end_time_unix_nanos.unwrap() < invalid_time_span.start_time_unix_nanos, true)
}

test "context_capacity_boundary_conditions" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡å®¹é‡çš„è¾¹ç•Œæ¡ä»¶
  
  // 1. æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_context = context::Context::empty()
  assert_eq(empty_context.values.length(), 0)
  
  let empty_baggage = context::Baggage::empty()
  assert_eq(empty_baggage.entries.length(), 0)
  
  // 2. æµ‹è¯•å•å…ƒç´ ä¸Šä¸‹æ–‡
  let single_key = context::create_key("single_key")
  let single_context = empty_context.with_value(single_key, "single_value")
  assert_eq(single_context.values.length(), 1)
  assert_eq(single_context.get(single_key).unwrap(), "single_value")
  
  let single_baggage = empty_baggage.with_entry("single_entry", "single_value")
  assert_eq(single_baggage.entries.length(), 1)
  assert_eq(single_baggage.get("single_entry").unwrap(), "single_value")
  
  // 3. æµ‹è¯•å¤§å®¹é‡ä¸Šä¸‹æ–‡
  let large_context = empty_context
  let large_baggage = empty_baggage
  
  // æ·»åŠ å¤§é‡ä¸Šä¸‹æ–‡å€¼
  let mut i = 0
  while i < 1000 {
    let key = context::create_key("key_" + i.to_string())
    large_context = large_context.with_value(key, "value_" + i.to_string())
    large_baggage = large_baggage.with_entry("entry_" + i.to_string(), "value_" + i.to_string())
    i = i + 1
  }
  
  assert_eq(large_context.values.length(), 1000)
  assert_eq(large_baggage.entries.length(), 1000)
  
  // éªŒè¯è¾¹ç•Œå€¼
  assert_eq(large_context.get(context::create_key("key_0")).unwrap(), "value_0")
  assert_eq(large_context.get(context::create_key("key_999")).unwrap(), "value_999")
  assert_eq(large_baggage.get("entry_0").unwrap(), "value_0")
  assert_eq(large_baggage.get("entry_999").unwrap(), "value_999")
  
  // 4. æµ‹è¯•æé•¿çš„é”®å’Œå€¼
  let very_long_key = ""
  let very_long_value = ""
  let mut j = 0
  while j < 100 {
    very_long_key = very_long_key + "k"
    very_long_value = very_long_value + "v"
    j = j + 1
  }
  
  let long_key_context = empty_context.with_value(context::create_key(very_long_key), very_long_value)
  assert_eq(long_key_context.values.length(), 1)
  assert_eq(long_key_context.get(context::create_key(very_long_key)).unwrap(), very_long_value)
  
  let long_key_baggage = empty_baggage.with_entry(very_long_key, very_long_value)
  assert_eq(long_key_baggage.entries.length(), 1)
  assert_eq(long_key_baggage.get(very_long_key).unwrap(), very_long_value)
  
  // 5. æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~ \t\n\r"
  let special_key_context = empty_context.with_value(context::create_key(special_chars), special_chars)
  assert_eq(special_key_context.get(context::create_key(special_chars)).unwrap(), special_chars)
  
  let special_key_baggage = empty_baggage.with_entry(special_chars, special_chars)
  assert_eq(special_key_baggage.get(special_chars).unwrap(), special_chars)
  
  // 6. æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_key = "é”®_æµ‹è¯•_ğŸ”‘"
  let unicode_value = "å€¼_æµ‹è¯•_ğŸ“Š"
  let unicode_context = empty_context.with_value(context::create_key(unicode_key), unicode_value)
  assert_eq(unicode_context.get(context::create_key(unicode_key)).unwrap(), unicode_value)
  
  let unicode_baggage = empty_baggage.with_entry(unicode_key, unicode_value)
  assert_eq(unicode_baggage.get(unicode_key).unwrap(), unicode_value)
}

test "log_record_boundary_conditions" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„è¾¹ç•Œæ¡ä»¶
  
  // 1. æµ‹è¯•ç©ºæ—¥å¿—è®°å½•
  let empty_log = logs::LogRecord::{
    timestamp_unix_nanos: 0L,
    observed_timestamp_unix_nanos: None,
    severity_number: logs::Info,
    severity_text: None,
    body: None,
    attributes: [],
    trace_id: None,
    span_id: None,
    trace_flags: None,
    resource: None,
    instrumentation_scope: None
  }
  
  assert_eq(empty_log.timestamp_unix_nanos, 0L)
  assert_eq(empty_log.observed_timestamp_unix_nanos, None)
  assert_eq(empty_log.severity_number, logs::Info)
  assert_eq(empty_log.severity_text, None)
  assert_eq(empty_log.body, None)
  assert_eq(empty_log.attributes.length(), 0)
  
  // 2. æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯
  let very_long_message = ""
  let mut i = 0
  while i < 10000 {
    very_long_message = very_long_message + "log_message_line_" + i.to_string() + "\n"
    i = i + 1
  }
  
  let long_log = logs::LogRecord::{
    timestamp_unix_nanos: 1640995200000000000L,
    observed_timestamp_unix_nanos: Some(1640995200000001000L),
    severity_number: logs::Error,
    severity_text: Some("ERROR"),
    body: Some(very_long_message),
    attributes: [
      ("message.length", common::AttributeValue::int(very_long_message.length().to_int64()))
    ],
    trace_id: Some([for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte })),
    span_id: Some([for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte })),
    trace_flags: Some(1_byte),
    resource: Some(common::Resource::default("test-service")),
    instrumentation_scope: Some(common::InstrumentationScope::{
      name: "test-logger",
      version: Some("1.0.0"),
      schema_url: None
    })
  }
  
  match long_log.body {
    Some(message) => {
      assert_eq(message.length() > 100000, true)  // éªŒè¯æ¶ˆæ¯ç¡®å®å¾ˆé•¿
      assert_eq(message.contains("log_message_line_0"), true)
      assert_eq(message.contains("log_message_line_9999"), true)
    }
    None => assert_eq(false, true, "Expected Some(String) for body")
  }
  
  // 3. æµ‹è¯•æ‰€æœ‰ä¸¥é‡æ€§çº§åˆ«
  let severity_levels = [
    (logs::Trace, "TRACE"),
    (logs::Debug, "DEBUG"),
    (logs::Info, "INFO"),
    (logs::Warn, "WARN"),
    (logs::Error, "ERROR"),
    (logs::Fatal, "FATAL")
  ]
  
  let mut i = 0
  while i < severity_levels.length() {
    let (severity_num, severity_text) = severity_levels[i]
    let severity_log = logs::LogRecord::{
      timestamp_unix_nanos: 1640995200000000000L + i.to_int64(),
      observed_timestamp_unix_nanos: None,
      severity_number: severity_num,
      severity_text: Some(severity_text),
      body: Some("Test message for " + severity_text),
      attributes: [
        ("severity.level", common::AttributeValue::string(severity_text))
      ],
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    }
    
    assert_eq(severity_log.severity_number, severity_num)
    assert_eq(severity_log.severity_text.unwrap(), severity_text)
    i = i + 1
  }
  
  // 4. æµ‹è¯•åŒ…å«å¤§é‡å±æ€§çš„æ—¥å¿—
  let many_attributes = [] : Array[(String, common::AttributeValue)]
  let mut j = 0
  while j < 1000 {
    many_attributes.push(("attr_" + j.to_string(), common::AttributeValue::string("value_" + j.to_string())))
    j = j + 1
  }
  
  let many_attrs_log = logs::LogRecord::{
    timestamp_unix_nanos: 1640995200000000000L,
    observed_timestamp_unix_nanos: None,
    severity_number: logs::Info,
    severity_text: Some("INFO"),
    body: Some("Log with many attributes"),
    attributes: many_attributes,
    trace_id: None,
    span_id: None,
    trace_flags: None,
    resource: None,
    instrumentation_scope: None
  }
  
  assert_eq(many_attrs_log.attributes.length(), 1000)
  assert_eq(many_attrs_log.attributes[0].0, "attr_0")
  assert_eq(many_attrs_log.attributes[999].0, "attr_999")
  
  // 5. æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—
  let special_chars_log = logs::LogRecord::{
    timestamp_unix_nanos: 1640995200000000000L,
    observed_timestamp_unix_nanos: None,
    severity_number: logs::Warn,
    severity_text: Some("WARN"),
    body: Some("Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?`~ \t\n\r Unicode: æµ‹è¯• ğŸš€"),
    attributes: [
      ("special.chars", common::AttributeValue::string("!@#$%^&*()")),
      ("unicode.chars", common::AttributeValue::string("æµ‹è¯• ğŸš€")),
      ("newline", common::AttributeValue::string("line1\nline2")),
      ("tab", common::AttributeValue::string("col1\tcol2"))
    ],
    trace_id: None,
    span_id: None,
    trace_flags: None,
    resource: None,
    instrumentation_scope: None
  }
  
  match special_chars_log.body {
    Some(message) => {
      assert_eq(message.contains("!@#$%^&*()"), true)
      assert_eq(message.contains("æµ‹è¯• ğŸš€"), true)
      assert_eq(message.contains("\n"), true)
      assert_eq(message.contains("\t"), true)
    }
    None => assert_eq(false, true, "Expected Some(String) for body with special chars")
  }
}

test "metrics_boundary_conditions" {
  // æµ‹è¯•æŒ‡æ ‡çš„è¾¹ç•Œæ¡ä»¶
  
  // 1. æµ‹è¯•æå€¼æŒ‡æ ‡è®¡æ•°
  let max_counter = metrics::NoopCounter::{}
  max_counter.add(9223372036854775807L)  // Int64æœ€å¤§å€¼
  
  let min_counter = metrics::NoopCounter::{}
  min_counter.add(-9223372036854775808L)  // Int64æœ€å°å€¼
  
  let zero_counter = metrics::NoopCounter::{}
  zero_counter.add(0L)
  
  // 2. æµ‹è¯•æå€¼æŒ‡æ ‡è®°å½•
  let max_histogram = metrics::NoopHistogram::{}
  max_histogram.record(1.7976931348623157e+308)  // Doubleæœ€å¤§å€¼
  
  let min_histogram = metrics::NoopHistogram::{}
  min_histogram.record(2.2250738585072014e-308)  // æœ€å°æ­£åŒç²¾åº¦
  
  let zero_histogram = metrics::NoopHistogram::{}
  zero_histogram.record(0.0)
  
  let negative_histogram = metrics::NoopHistogram::{}
  negative_histogram.record(-1.7976931348623157e+308)  // è´Ÿæœ€å¤§å€¼
  
  // 3. æµ‹è¯•æ— ç©·å¤§å’ŒNaNæŒ‡æ ‡
  let infinity_histogram = metrics::NoopHistogram::{}
  infinity_histogram.record(1.0 / 0.0)  // æ­£æ— ç©·
  
  let negative_infinity_histogram = metrics::NoopHistogram::{}
  negative_infinity_histogram.record(-1.0 / 0.0)  // è´Ÿæ— ç©·
  
  let nan_histogram = metrics::NoopHistogram::{}
  nan_histogram.record(0.0 / 0.0)  // NaN
  
  // 4. æµ‹è¯•æå¤§é‡å±æ€§
  let many_attrs_counter = metrics::NoopCounter::{}
  let many_attrs = [] : Array[(String, common::AttributeValue)]
  let mut i = 0
  while i < 1000 {
    many_attrs.push(("attr_" + i.to_string(), common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  many_attrs_counter.add(1L, many_attrs)
  
  // 5. æµ‹è¯•æé•¿å±æ€§é”®å’Œå€¼
  let very_long_key = ""
  let very_long_value = ""
  let mut j = 0
  while j < 100 {
    very_long_key = very_long_key + "k"
    very_long_value = very_long_value + "v"
    j = j + 1
  }
  
  let long_key_counter = metrics::NoopCounter::{}
  long_key_counter.add(1L, [(very_long_key, common::AttributeValue::string(very_long_value))])
  
  // 6. æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§
  let special_chars_counter = metrics::NoopCounter::{}
  special_chars_counter.add(1L, [
    ("special.chars", common::AttributeValue::string("!@#$%^&*()")),
    ("unicode.chars", common::AttributeValue::string("æµ‹è¯• ğŸš€")),
    ("empty.value", common::AttributeValue::string("")),
    ("null.like", common::AttributeValue::string("null"))
  ])
  
  // 7. æµ‹è¯•æ··åˆç±»å‹å±æ€§
  let mixed_type_histogram = metrics::NoopHistogram::{}
  mixed_type_histogram.record(42.0, [
    ("string.attr", common::AttributeValue::string("test")),
    ("int.attr", common::AttributeValue::int(42L)),
    ("float.attr", common::AttributeValue::float(3.14)),
    ("bool.attr", common::AttributeValue::bool(true)),
    ("array.string", common::AttributeValue::array_string(["a", "b", "c"])),
    ("array.int", common::AttributeValue::array_int([1L, 2L, 3L])),
    ("array.float", common::AttributeValue::array_float([1.1, 2.2, 3.3])),
    ("array.bool", common::AttributeValue::array_bool([true, false, true]))
  ])
  
  // 8. æµ‹è¯•UpDownCounterçš„æå€¼
  let up_down_counter = metrics::NoopUpDownCounter::{}
  up_down_counter.add(9223372036854775807L)  // æœ€å¤§æ­£å€¼
  up_down_counter.add(-9223372036854775808L)  // æœ€å°è´Ÿå€¼
  up_down_counter.add(0L)  // é›¶å€¼
  
  // 9. æµ‹è¯•Gaugeçš„æå€¼
  let gauge = metrics::NoopGauge::{}
  gauge.record(1.7976931348623157e+308)  // æœ€å¤§å€¼
  gauge.record(-1.7976931348623157e+308)  // æœ€å°å€¼
  gauge.record(0.0)  // é›¶å€¼
  gauge.record(1.0 / 0.0)  // æ— ç©·å¤§
  gauge.record(-1.0 / 0.0)  // è´Ÿæ— ç©·å¤§
  gauge.record(0.0 / 0.0)  // NaN
  
  // æ‰€æœ‰æ“ä½œéƒ½åº”è¯¥æˆåŠŸï¼ˆNo-opå®ç°ä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼‰
  assert_eq(true, true)
}