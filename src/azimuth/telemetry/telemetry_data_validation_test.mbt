// æ•°æ®éªŒè¯æµ‹è¯• - æµ‹è¯•æ•°æ®å®Œæ•´æ€§å’ŒéªŒè¯è§„åˆ™
test "data_validation_trace_id_format" {
  // æµ‹è¯•Trace IDæ ¼å¼éªŒè¯
  
  // æµ‹è¯•æœ‰æ•ˆçš„Trace IDï¼ˆ16å­—èŠ‚ï¼Œ32ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ï¼‰
  let valid_trace_id_1 = [for i = 0; i < 16; i = i + 1].map(fn(i) { 
    if i % 2 == 0 { 0x0a_byte } else { 0xf0_byte }
  })
  let valid_trace_id_2 = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x00_byte })
  let valid_trace_id_3 = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0xff_byte })
  
  // åˆ›å»ºæœ‰æ•ˆçš„SpanContext
  let valid_context_1 = trace::SpanContext::{
    trace_id: valid_trace_id_1,
    span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x01_byte }),
    trace_flags: 1_byte,
    trace_state: ""
  }
  
  let valid_context_2 = trace::SpanContext::{
    trace_id: valid_trace_id_2,
    span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x02_byte }),
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  let valid_context_3 = trace::SpanContext::{
    trace_id: valid_trace_id_3,
    span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x03_byte }),
    trace_flags: 1_byte,
    trace_state: "key=value"
  }
  
  // éªŒè¯æœ‰æ•ˆTrace ID
  assert_eq(valid_context_1.trace_id.length(), 16)
  assert_eq(valid_context_2.trace_id.length(), 16)
  assert_eq(valid_context_3.trace_id.length(), 16)
  
  // éªŒè¯Trace IDå†…å®¹
  assert_eq(valid_context_1.trace_id[0], 0x0a_byte)
  assert_eq(valid_context_1.trace_id[1], 0xf0_byte)
  assert_eq(valid_context_2.trace_id[0], 0x00_byte)
  assert_eq(valid_context_3.trace_id[0], 0xff_byte)
}

test "data_validation_span_id_format" {
  // æµ‹è¯•Span IDæ ¼å¼éªŒè¯
  
  // æµ‹è¯•æœ‰æ•ˆçš„Span IDï¼ˆ8å­—èŠ‚ï¼Œ16ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ï¼‰
  let valid_span_id_1 = [for i = 0; i < 8; i = i + 1].map(fn(i) { 
    if i % 2 == 0 { 0x0b_byte } else { 0xf1_byte }
  })
  let valid_span_id_2 = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x00_byte })
  let valid_span_id_3 = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0xff_byte })
  
  // åˆ›å»ºæœ‰æ•ˆçš„SpanContext
  let valid_context_1 = trace::SpanContext::{
    trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x01_byte }),
    span_id: valid_span_id_1,
    trace_flags: 1_byte,
    trace_state: ""
  }
  
  let valid_context_2 = trace::SpanContext::{
    trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x02_byte }),
    span_id: valid_span_id_2,
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  let valid_context_3 = trace::SpanContext::{
    trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x03_byte }),
    span_id: valid_span_id_3,
    trace_flags: 1_byte,
    trace_state: "key=value"
  }
  
  // éªŒè¯æœ‰æ•ˆSpan ID
  assert_eq(valid_context_1.span_id.length(), 8)
  assert_eq(valid_context_2.span_id.length(), 8)
  assert_eq(valid_context_3.span_id.length(), 8)
  
  // éªŒè¯Span IDå†…å®¹
  assert_eq(valid_context_1.span_id[0], 0x0b_byte)
  assert_eq(valid_context_1.span_id[1], 0xf1_byte)
  assert_eq(valid_context_2.span_id[0], 0x00_byte)
  assert_eq(valid_context_3.span_id[0], 0xff_byte)
}

test "data_validation_trace_flags" {
  // æµ‹è¯•Trace FlagséªŒè¯
  
  let trace_id = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x01_byte })
  let span_id = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x02_byte })
  
  // æµ‹è¯•æ‰€æœ‰å¯èƒ½çš„Trace Flagså€¼
  let flag_00 = trace::SpanContext::{ trace_id, span_id, trace_flags: 0x00_byte, trace_state: "" }
  let flag_01 = trace::SpanContext::{ trace_id, span_id, trace_flags: 0x01_byte, trace_state: "" }
  let flag_ff = trace::SpanContext::{ trace_id, span_id, trace_flags: 0xff_byte, trace_state: "" }
  
  // éªŒè¯Trace Flags
  assert_eq(flag_00.trace_flags, 0x00_byte)
  assert_eq(flag_01.trace_flags, 0x01_byte)
  assert_eq(flag_ff.trace_flags, 0xff_byte)
  
  // éªŒè¯é‡‡æ ·æ ‡å¿—ï¼ˆbit 0ï¼‰
  let sampled_flag = flag_01.trace_flags & 0x01_byte
  let not_sampled_flag = flag_00.trace_flags & 0x01_byte
  
  assert_eq(sampled_flag, 0x01_byte)  // å·²é‡‡æ ·
  assert_eq(not_sampled_flag, 0x00_byte)  // æœªé‡‡æ ·
}

test "data_validation_trace_state" {
  // æµ‹è¯•Trace StateéªŒè¯
  
  let trace_id = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x01_byte })
  let span_id = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x02_byte })
  
  // æµ‹è¯•æœ‰æ•ˆçš„Trace Stateæ ¼å¼
  let valid_trace_state_1 = ""
  let valid_trace_state_2 = "key=value"
  let valid_trace_state_3 = "key1=value1,key2=value2"
  let valid_trace_state_4 = "vendor1=value1;vendor2=value2,key3=value3"
  let valid_trace_state_5 = "key.with.dots=value.with.dots"
  let valid_trace_state_6 = "key_with_underscores=value_with_underscores"
  
  let context_1 = trace::SpanContext::{ trace_id, span_id, trace_flags: 1_byte, trace_state: valid_trace_state_1 }
  let context_2 = trace::SpanContext::{ trace_id, span_id, trace_flags: 1_byte, trace_state: valid_trace_state_2 }
  let context_3 = trace::SpanContext::{ trace_id, span_id, trace_flags: 1_byte, trace_state: valid_trace_state_3 }
  let context_4 = trace::SpanContext::{ trace_id, span_id, trace_flags: 1_byte, trace_state: valid_trace_state_4 }
  let context_5 = trace::SpanContext::{ trace_id, span_id, trace_flags: 1_byte, trace_state: valid_trace_state_5 }
  let context_6 = trace::SpanContext::{ trace_id, span_id, trace_flags: 1_byte, trace_state: valid_trace_state_6 }
  
  // éªŒè¯Trace State
  assert_eq(context_1.trace_state, "")
  assert_eq(context_2.trace_state, "key=value")
  assert_eq(context_3.trace_state, "key1=value1,key2=value2")
  assert_eq(context_4.trace_state, "vendor1=value1;vendor2=value2,key3=value3")
  assert_eq(context_5.trace_state, "key.with.dots=value.with.dots")
  assert_eq(context_6.trace_state, "key_with_underscores=value_with_underscores")
}

test "data_validation_attribute_names" {
  // æµ‹è¯•å±æ€§åç§°éªŒè¯
  
  // æµ‹è¯•æœ‰æ•ˆçš„å±æ€§åç§°
  let valid_attribute_names = [
    "service.name",
    "service.version",
    "http.method",
    "http.status_code",
    "db.system",
    "db.statement",
    "user.id",
    "session.id",
    "trace.id",
    "span.kind",
    "error.type",
    "error.message",
    "process.id",
    "process.name",
    "host.name",
    "os.type",
    "cloud.provider",
    "k8s.pod.name",
    "container.id",
    "telemetry.sdk.name"
  ]
  
  // æµ‹è¯•æ— æ•ˆçš„å±æ€§åç§°ï¼ˆåœ¨å®é™…å®ç°ä¸­åº”è¯¥è¢«æ‹’ç»ï¼‰
  let potentially_invalid_names = [
    "",  // ç©ºå­—ç¬¦ä¸²
    " ",  // åªæœ‰ç©ºæ ¼
    "key with spaces",  // åŒ…å«ç©ºæ ¼
    "key@with@symbols",  // åŒ…å«ç‰¹æ®Šç¬¦å·
    "key/with/slashes",  // åŒ…å«æ–œæ 
    "key\\with\\backslashes",  // åŒ…å«åæ–œæ 
    "a".repeat(300)  // è¶…é•¿åç§°
  ]
  
  // åˆ›å»ºæœ‰æ•ˆçš„å±æ€§
  let mut valid_attributes = []
  let mut i = 0
  while i < valid_attribute_names.length() {
    let attr_name = valid_attribute_names[i]
    valid_attributes.push((attr_name, common::AttributeValue::string("test_value")))
    i = i + 1
  }
  
  // åˆ›å»ºå¯èƒ½æ— æ•ˆçš„å±æ€§ï¼ˆåœ¨å½“å‰å®ç°ä¸­ä¼šè¢«æ¥å—ï¼‰
  let mut potentially_invalid_attributes = []
  i = 0
  while i < potentially_invalid_names.length() {
    let attr_name = potentially_invalid_names[i]
    potentially_invalid_attributes.push((attr_name, common::AttributeValue::string("test_value")))
    i = i + 1
  }
  
  // éªŒè¯å±æ€§åˆ›å»º
  assert_eq(valid_attributes.length(), 20)
  assert_eq(potentially_invalid_attributes.length(), 7)
  
  // éªŒè¯ç‰¹å®šå±æ€§åç§°
  assert_eq(valid_attributes[0].0, "service.name")
  assert_eq(valid_attributes[10].0, "error.type")
  assert_eq(valid_attributes[19].0, "telemetry.sdk.name")
}

test "data_validation_attribute_values" {
  // æµ‹è¯•å±æ€§å€¼éªŒè¯
  
  // æµ‹è¯•å­—ç¬¦ä¸²å€¼
  let valid_string_values = [
    "simple_string",
    "string.with.dots",
    "string_with_underscores",
    "string-with-dashes",
    "StringWithCamelCase",
    "string_with_numbers123",
    "unicode_string_æµ‹è¯•",
    "emoji_string_ğŸš€",
    "",  // ç©ºå­—ç¬¦ä¸²
    " ",  // åªæœ‰ç©ºæ ¼
    "a".repeat(1000)  // é•¿å­—ç¬¦ä¸²
  ]
  
  // æµ‹è¯•æ•´æ•°å€¼
  let valid_int_values = [
    0L,
    1L,
    -1L,
    9223372036854775807L,  // Max Int64
    -9223372036854775808L,  // Min Int64
    1234567890L,
    -987654321L
  ]
  
  // æµ‹è¯•æµ®ç‚¹æ•°å€¼
  let valid_float_values = [
    0.0,
    1.0,
    -1.0,
    3.14159265359,
    1.7976931348623157e+308,  // Max Double
    -1.7976931348623157e+308,  // Min Double
    1.0/0.0,  // Infinity
    -1.0/0.0,  // Negative Infinity
    0.0/0.0   // NaN
  ]
  
  // æµ‹è¯•å¸ƒå°”å€¼
  let valid_bool_values = [true, false]
  
  // åˆ›å»ºå±æ€§å¹¶éªŒè¯
  let mut string_attributes = []
  let mut i = 0
  while i < valid_string_values.length() {
    let value = valid_string_values[i]
    string_attributes.push(("string_test_" + i.to_string(), common::AttributeValue::string(value)))
    i = i + 1
  }
  
  let mut int_attributes = []
  i = 0
  while i < valid_int_values.length() {
    let value = valid_int_values[i]
    int_attributes.push(("int_test_" + i.to_string(), common::AttributeValue::int(value)))
    i = i + 1
  }
  
  let mut float_attributes = []
  i = 0
  while i < valid_float_values.length() {
    let value = valid_float_values[i]
    float_attributes.push(("float_test_" + i.to_string(), common::AttributeValue::float(value)))
    i = i + 1
  }
  
  let mut bool_attributes = []
  i = 0
  while i < valid_bool_values.length() {
    let value = valid_bool_values[i]
    bool_attributes.push(("bool_test_" + i.to_string(), common::AttributeValue::bool(value)))
    i = i + 1
  }
  
  // éªŒè¯å±æ€§åˆ›å»º
  assert_eq(string_attributes.length(), 11)
  assert_eq(int_attributes.length(), 7)
  assert_eq(float_attributes.length(), 9)
  assert_eq(bool_attributes.length(), 2)
}

test "data_validation_array_values" {
  // æµ‹è¯•æ•°ç»„å€¼éªŒè¯
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ•°ç»„
  let string_arrays = [
    [],  // ç©ºæ•°ç»„
    ["single_item"],
    ["item1", "item2", "item3"],
    ["", " ", "test"],  // åŒ…å«ç©ºå­—ç¬¦ä¸²
    ["unicode", "æµ‹è¯•", "ğŸš€"],  // Unicodeå’Œemoji
    ["a".repeat(100)]  // é•¿å­—ç¬¦ä¸²æ•°ç»„
  ]
  
  // æµ‹è¯•æ•´æ•°æ•°ç»„
  let int_arrays = [
    [],  // ç©ºæ•°ç»„
    [0L],
    [1L, 2L, 3L],
    [-1L, -2L, -3L],  // è´Ÿæ•°
    [9223372036854775807L],  // æœ€å¤§å€¼
    [-9223372036854775808L]  // æœ€å°å€¼
  ]
  
  // æµ‹è¯•æµ®ç‚¹æ•°æ•°ç»„
  let float_arrays = [
    [],  // ç©ºæ•°ç»„
    [0.0],
    [1.1, 2.2, 3.3],
    [-1.1, -2.2, -3.3],  // è´Ÿæ•°
    [1.0/0.0, -1.0/0.0, 0.0/0.0],  // Infinityå’ŒNaN
    [3.14159265359, 2.71828182846]  // æ•°å­¦å¸¸æ•°
  ]
  
  // æµ‹è¯•å¸ƒå°”æ•°ç»„
  let bool_arrays = [
    [],  // ç©ºæ•°ç»„
    [true],
    [false],
    [true, false, true, false],  // äº¤æ›¿
    [true, true, true],  // å…¨true
    [false, false, false]  // å…¨false
  ]
  
  // åˆ›å»ºæ•°ç»„å±æ€§
  let mut array_attributes = []
  let mut i = 0
  while i < string_arrays.length() {
    let array = string_arrays[i]
    array_attributes.push(("string_array_" + i.to_string(), common::AttributeValue::array_string(array)))
    i = i + 1
  }
  
  i = 0
  while i < int_arrays.length() {
    let array = int_arrays[i]
    array_attributes.push(("int_array_" + i.to_string(), common::AttributeValue::array_int(array)))
    i = i + 1
  }
  
  i = 0
  while i < float_arrays.length() {
    let array = float_arrays[i]
    array_attributes.push(("float_array_" + i.to_string(), common::AttributeValue::array_float(array)))
    i = i + 1
  }
  
  i = 0
  while i < bool_arrays.length() {
    let array = bool_arrays[i]
    array_attributes.push(("bool_array_" + i.to_string(), common::AttributeValue::array_bool(array)))
    i = i + 1
  }
  
  // éªŒè¯æ•°ç»„å±æ€§åˆ›å»º
  assert_eq(array_attributes.length(), 22)
  
  // éªŒè¯ç‰¹å®šæ•°ç»„å†…å®¹
  match array_attributes[1].1 {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], "single_item")
    }
    _ => @test.fail("Test failed")
  }
  
  match array_attributes[7].1 {
    common::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], 1L)
      assert_eq(arr[1], 2L)
      assert_eq(arr[2], 3L)
    }
    _ => @test.fail("Test failed")
  }
}

test "data_validation_span_relationships" {
  // æµ‹è¯•Spanå…³ç³»éªŒè¯
  
  let trace_id = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x01_byte })
  
  // åˆ›å»ºçˆ¶å­Spanå…³ç³»
  let parent_span_id = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x02_byte })
  let child_span_id_1 = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x03_byte })
  let child_span_id_2 = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x04_byte })
  
  // åˆ›å»ºæ ¹Spanï¼ˆæ²¡æœ‰çˆ¶Spanï¼‰
  let root_span = trace::Span::{
    name: "root_operation",
    context: trace::SpanContext::{
      trace_id: trace_id,
      span_id: parent_span_id,
      trace_flags: 1_byte,
      trace_state: ""
    },
    kind: trace::Server,
    parent_span_id: None,
    start_time_unix_nanos: 1000L,
    end_time_unix_nanos: Some(5000L),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  // åˆ›å»ºå­Span
  let child_span_1 = trace::Span::{
    name: "child_operation_1",
    context: trace::SpanContext::{
      trace_id: trace_id,
      span_id: child_span_id_1,
      trace_flags: 1_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: Some(parent_span_id),
    start_time_unix_nanos: 1500L,
    end_time_unix_nanos: Some(3000L),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  let child_span_2 = trace::Span::{
    name: "child_operation_2",
    context: trace::SpanContext::{
      trace_id: trace_id,
      span_id: child_span_id_2,
      trace_flags: 1_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: Some(parent_span_id),
    start_time_unix_nanos: 2000L,
    end_time_unix_nanos: Some(4000L),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  
  // éªŒè¯Spanå…³ç³»
  assert_eq(root_span.context.trace_id, child_span_1.context.trace_id)
  assert_eq(root_span.context.trace_id, child_span_2.context.trace_id)
  
  match root_span.parent_span_id {
    None => assert_eq(true, true)  // æ ¹Spanæ²¡æœ‰çˆ¶Span
    Some(_) => @test.fail("Test failed")
  }
  
  match child_span_1.parent_span_id {
    Some(parent_id) => {
      assert_eq(parent_id.length(), 8)
      assert_eq(parent_id[0], 0x02_byte)
    }
    None => @test.fail("Test failed")
  }
  
  match child_span_2.parent_span_id {
    Some(parent_id) => {
      assert_eq(parent_id.length(), 8)
      assert_eq(parent_id[0], 0x02_byte)
    }
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯æ—¶é—´é¡ºåº
  assert_eq(root_span.start_time_unix_nanos, 1000L)
  assert_eq(child_span_1.start_time_unix_nanos, 1500L)
  assert_eq(child_span_2.start_time_unix_nanos, 2000L)
  
  assert_eq(child_span_1.start_time_unix_nanos >= root_span.start_time_unix_nanos, true)
  assert_eq(child_span_2.start_time_unix_nanos >= root_span.start_time_unix_nanos, true)
}

test "data_validation_span_links" {
  // æµ‹è¯•Spané“¾æ¥éªŒè¯
  
  let trace_id_1 = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x01_byte })
  let trace_id_2 = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x02_byte })
  let span_id_1 = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x03_byte })
  let span_id_2 = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x04_byte })
  
  // åˆ›å»ºé“¾æ¥çš„SpanContext
  let linked_context_1 = trace::SpanContext::{
    trace_id: trace_id_1,
    span_id: span_id_1,
    trace_flags: 1_byte,
    trace_state: ""
  }
  
  let linked_context_2 = trace::SpanContext::{
    trace_id: trace_id_2,
    span_id: span_id_2,
    trace_flags: 0_byte,
    trace_state: "key=value"
  }
  
  // åˆ›å»ºSpané“¾æ¥
  let span_link_1 = trace::SpanLink::{
    context: linked_context_1,
    attributes: [
      ("link.type", common::AttributeValue::string("causality")),
      ("relationship", common::AttributeValue::string("predecessor"))
    ]
  }
  
  let span_link_2 = trace::SpanLink::{
    context: linked_context_2,
    attributes: [
      ("link.type", common::AttributeValue::string("correlation")),
      ("service", common::AttributeValue::string("related-service"))
    ]
  }
  
  // åˆ›å»ºå¸¦æœ‰é“¾æ¥çš„Span
  let span_with_links = trace::Span::{
    name: "operation_with_links",
    context: trace::SpanContext::{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x05_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x06_byte }),
      trace_flags: 1_byte,
      trace_state: ""
    },
    kind: trace::Server,
    parent_span_id: None,
    start_time_unix_nanos: 1000L,
    end_time_unix_nanos: Some(2000L),
    status: trace::Ok,
    status_description: None,
    attributes: [],
    events: [],
    links: [span_link_1, span_link_2]
  }
  
  // éªŒè¯Spané“¾æ¥
  assert_eq(span_with_links.links.length(), 2)
  
  // éªŒè¯ç¬¬ä¸€ä¸ªé“¾æ¥
  assert_eq(span_with_links.links[0].context.trace_id.length(), 16)
  assert_eq(span_with_links.links[0].context.span_id.length(), 8)
  assert_eq(span_with_links.links[0].context.trace_flags, 1_byte)
  assert_eq(span_with_links.links[0].attributes.length(), 2)
  
  match span_with_links.links[0].attributes[0].1 {
    common::StringValue(link_type) => assert_eq(link_type, "causality")
    _ => @test.fail("Test failed")
  }
  
  // éªŒè¯ç¬¬äºŒä¸ªé“¾æ¥
  assert_eq(span_with_links.links[1].context.trace_id.length(), 16)
  assert_eq(span_with_links.links[1].context.span_id.length(), 8)
  assert_eq(span_with_links.links[1].context.trace_flags, 0_byte)
  assert_eq(span_with_links.links[1].context.trace_state, "key=value")
  assert_eq(span_with_links.links[1].attributes.length(), 2)
}