// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µæµ‹è¯• - æµ‹è¯•ç³»ç»Ÿçš„å¥å£®æ€§
use azimuth.telemetry.api.common.{AttributeValue, Resource}
use azimuth.telemetry.api.context.{Context, create_key}
use azimuth.telemetry.api.logs.{LogRecord, SeverityNumber}
use azimuth.telemetry.api.metrics.{NoopMeter}
use azimuth.telemetry.api.trace.{SpanKind, StatusCode}
use azimuth.telemetry.api.propagation.{MapCarrier, W3CTraceContextPropagator}

test "error_handling_null_values" {
  // æµ‹è¯•ç©ºå€¼å’ŒNoneå€¼çš„å¤„ç†
  
  // 1. æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_string_attr = AttributeValue::string("")
  match empty_string_attr {
    StringValue(s) => assert_eq(s, "")
    _ => @test.fail("Expected StringValue with empty string")
  }
  
  // 2. æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = AttributeValue::array_string([])
  match empty_string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected ArrayStringValue with empty array")
  }
  
  // 3. æµ‹è¯•Resourceçš„ç©ºå€¼å¤„ç†
  let empty_resource = Resource::default("")
  assert_eq(empty_resource.service_name, "")
  assert_eq(empty_resource.service_version, None)
  
  // 4. æµ‹è¯•Contextçš„ç©ºå€¼å¤„ç†
  let empty_context = Context::empty()
  let non_existent_key = create_key("non.existent.key")
  match empty_context.get(non_existent_key) {
    Some(_) => @test.fail("Expected None for non-existent key")
    None => assert_eq(true, true)
  }
  
  // 5. æµ‹è¯•LogRecordçš„ç©ºå€¼å¤„ç†
  let log_record_with_none = LogRecord::builder()
    .severity(SeverityNumber::Info)
    // ä¸è®¾ç½®bodyï¼Œä¿æŒä¸ºNone
    .build()
  
  match log_record_with_none.body {
    Some(_) => @test.fail("Expected None for body")
    None => assert_eq(true, true)
  }
}

test "error_handling_extreme_values" {
  // æµ‹è¯•æå€¼å¤„ç†
  
  // 1. æµ‹è¯•æå¤§æ•´æ•°å€¼
  let max_int = AttributeValue::int(9223372036854775807L)
  match max_int {
    IntValue(v) => assert_eq(v, 9223372036854775807L)
    _ => @test.fail("Expected IntValue with max value")
  }
  
  // 2. æµ‹è¯•æå°æ•´æ•°å€¼
  let min_int = AttributeValue::int(-9223372036854775808L)
  match min_int {
    IntValue(v) => assert_eq(v, -9223372036854775808L)
    _ => @test.fail("Expected IntValue with min value")
  }
  
  // 3. æµ‹è¯•æå¤§æµ®ç‚¹æ•°å€¼
  let max_float = AttributeValue::float(1.7976931348623157e+308)
  match max_float {
    FloatValue(v) => assert_eq(v > 1.0e+308, true)
    _ => @test.fail("Expected FloatValue with max value")
  }
  
  // 4. æµ‹è¯•æå°æµ®ç‚¹æ•°å€¼
  let min_float = AttributeValue::float(-1.7976931348623157e+308)
  match min_float {
    FloatValue(v) => assert_eq(v < -1.0e+308, true)
    _ => @test.fail("Expected FloatValue with min value")
  }
  
  // 5. æµ‹è¯•æ— ç©·å¤§
  let infinity = AttributeValue::float(1.0/0.0)
  match infinity {
    FloatValue(v) => assert_eq(v > 1.0e+308, true)
    _ => @test.fail("Expected FloatValue with infinity")
  }
  
  // 6. æµ‹è¯•NaN
  let nan = AttributeValue::float(0.0/0.0)
  match nan {
    FloatValue(v) => assert_eq(v != v, true)  // NaNä¸ç­‰äºè‡ªèº«
    _ => @test.fail("Expected FloatValue with NaN")
  }
}

test "error_handling_invalid_operations" {
  // æµ‹è¯•æ— æ•ˆæ“ä½œçš„å¤„ç†
  
  // 1. æµ‹è¯•è´Ÿæ•°è®¡æ•°å™¨æ“ä½œ
  let meter = NoopMeter::{}
  let counter = meter.create_counter("test.counter", "count", "Test counter")
  
  // åœ¨å®é™…å®ç°ä¸­ï¼Œè®¡æ•°å™¨åº”è¯¥æ‹’ç»è´Ÿå€¼
  // è¿™é‡Œæˆ‘ä»¬åªæ˜¯éªŒè¯æ“ä½œä¸ä¼šå´©æºƒ
  counter.add(-1L, [("test.operation", AttributeValue::string("negative_add"))])
  
  // 2. æµ‹è¯•ç©ºå±æ€§å
  let log_record = LogRecord::builder()
    .severity(SeverityNumber::Info)
    .body("Test with empty attribute name")
    .with_attribute("", AttributeValue::string("value"))
    .build()
  
  assert_eq(log_record.attributes.length(), 1)
  
  // 3. æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let long_string = "a" * 10000
  let long_string_attr = AttributeValue::string(long_string)
  match long_string_attr {
    StringValue(s) => assert_eq(s.length(), 10000)
    _ => @test.fail("Expected StringValue with long string")
  }
  
  // 4. æµ‹è¯•è¶…é•¿å±æ€§å
  let long_attr_name = "a" * 1000
  let log_record_with_long_name = LogRecord::builder()
    .severity(SeverityNumber::Info)
    .body("Test with long attribute name")
    .with_attribute(long_attr_name, AttributeValue::string("value"))
    .build()
  
  assert_eq(log_record_with_long_name.attributes.length(), 1)
}

test "error_handling_unicode_and_special_characters" {
  // æµ‹è¯•Unicodeå’Œç‰¹æ®Šå­—ç¬¦å¤„ç†
  
  // 1. æµ‹è¯•Unicodeå­—ç¬¦ä¸²
  let unicode_string = "Unicodeæµ‹è¯•ğŸš€ğ”˜ğ”«ğ”¦ğ” ğ”¬ğ”¡ğ”¢"
  let unicode_attr = AttributeValue::string(unicode_string)
  match unicode_attr {
    StringValue(s) => assert_eq(s, unicode_string)
    _ => @test.fail("Expected StringValue with Unicode")
  }
  
  // 2. æµ‹è¯•ç‰¹æ®Šæ§åˆ¶å­—ç¬¦
  let control_chars = "\n\r\t\b\f\v"
  let control_chars_attr = AttributeValue::string(control_chars)
  match control_chars_attr {
    StringValue(s) => assert_eq(s, control_chars)
    _ => @test.fail("Expected StringValue with control characters")
  }
  
  // 3. æµ‹è¯•JSONç‰¹æ®Šå­—ç¬¦
  let json_chars = "\"\\{}[]<>|&^%$#@!~`"
  let json_chars_attr = AttributeValue::string(json_chars)
  match json_chars_attr {
    StringValue(s) => assert_eq(s, json_chars)
    _ => @test.fail("Expected StringValue with JSON special characters")
  }
  
  // 4. æµ‹è¯•é›¶å®½å­—ç¬¦
  let zero_width_chars = "\u200B\u200C\u200D\u2060\uFEFF"
  let zero_width_chars_attr = AttributeValue::string(zero_width_chars)
  match zero_width_chars_attr {
    StringValue(s) => assert_eq(s, zero_width_chars)
    _ => @test.fail("Expected StringValue with zero-width characters")
  }
  
  // 5. æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æœåŠ¡å
  let special_resource = Resource::default("service!@#$%^&*()_+-=[]{}|;':\",./<>?")
  assert_eq(special_resource.service_name, "service!@#$%^&*()_+-=[]{}|;':\",./<>?")
}

test "error_handling_memory_pressure" {
  // æµ‹è¯•å†…å­˜å‹åŠ›ä¸‹çš„è¡Œä¸º
  
  // 1. åˆ›å»ºå¤§é‡å±æ€§
  let large_attr_array = []
  let mut i = 0
  while i < 10000 {
    large_attr_array.push(("attr." + i.to_string(), AttributeValue::string("value." + i.to_string())))
    i = i + 1
  }
  
  // 2. åˆ›å»ºåŒ…å«å¤§é‡å±æ€§çš„LogRecord
  let log_record = LogRecord::builder()
    .severity(SeverityNumber::Info)
    .body("Test with many attributes")
  let mut builder = log_record
  let mut j = 0
  while j < 1000 {
    builder = builder.with_attribute("attr." + j.to_string(), AttributeValue::string("value." + j.to_string()))
    j = j + 1
  }
  let final_log_record = builder.build()
  
  assert_eq(final_log_record.attributes.length(), 1000)
  
  // 3. åˆ›å»ºå¤§é‡Contextå€¼
  let context = Context::empty()
  let mut ctx = context
  let mut k = 0
  while k < 1000 {
    let key = create_key("key." + k.to_string())
    ctx = ctx.with_value(key, "value." + k.to_string())
    k = k + 1
  }
  
  // éªŒè¯ç¬¬ä¸€ä¸ªå€¼ä»ç„¶å­˜åœ¨
  let first_key = create_key("key.0")
  match ctx.get(first_key) {
    Some(value) => assert_eq(value, "value.0")
    None => @test.fail("Expected value for key.0")
  }
}

test "error_handling_concurrent_access" {
  // æµ‹è¯•å¹¶å‘è®¿é—®çš„å®‰å…¨æ€§ï¼ˆæ¨¡æ‹Ÿï¼‰
  
  // 1. åˆ›å»ºå…±äº«èµ„æº
  let resource = Resource::default("concurrent-test-service")
  let context = Context::empty()
  
  // 2. æ¨¡æ‹Ÿå¹¶å‘åˆ›å»ºLogRecord
  let mut i = 0
  while i < 100 {
    let log_record = LogRecord::builder()
      .severity(SeverityNumber::Info)
      .body("Concurrent test " + i.to_string())
      .with_attribute("thread.id", AttributeValue::int(i.to_int64()))
      .with_attribute("resource.name", AttributeValue::string(resource.service_name))
      .build()
    
    assert_eq(log_record.attributes.length(), 2)
    i = i + 1
  }
  
  // 3. æ¨¡æ‹Ÿå¹¶å‘Contextæ“ä½œ
  let key = create_key("concurrent.key")
  let mut ctx = context
  let mut j = 0
  while j < 100 {
    ctx = ctx.with_value(key, "concurrent.value." + j.to_string())
    
    match ctx.get(key) {
      Some(value) => assert_eq(value.length() > 0, true)
      None => @test.fail("Expected value for concurrent.key")
    }
    
    j = j + 1
  }
  
  // 4. æ¨¡æ‹Ÿå¹¶å‘Metricsæ“ä½œ
  let meter = NoopMeter::{}
  let counter = meter.create_counter("concurrent.counter", "count", "Concurrent counter")
  
  let mut k = 0
  while k < 1000 {
    counter.add(1L, [("iteration", AttributeValue::int(k.to_int64()))])
    k = k + 1
  }
}

test "error_handling_recovery_scenarios" {
  // æµ‹è¯•é”™è¯¯æ¢å¤åœºæ™¯
  
  // 1. æµ‹è¯•éƒ¨åˆ†å¤±è´¥åçš„æ¢å¤
  let resource = Resource::default("recovery-test-service")
  
  // æ¨¡æ‹Ÿéƒ¨åˆ†å¤±è´¥çš„æ“ä½œ
  let log_record = LogRecord::builder()
    .severity(SeverityNumber::Error)
    .body("Partial failure occurred")
    .with_attribute("error.recovered", AttributeValue::bool(true))
    .with_attribute("retry.count", AttributeValue::int(3L))
    .build()
  
  // æ¢å¤åçš„æ­£å¸¸æ“ä½œ
  let recovery_log = LogRecord::builder()
    .severity(SeverityNumber::Info)
    .body("Operation recovered successfully")
    .with_attribute("recovery.success", AttributeValue::bool(true))
    .with_attribute("operation.duration", AttributeValue::float(150.5))
    .build()
  
  assert_eq(log_record.severity_number, SeverityNumber::Error)
  assert_eq(recovery_log.severity_number, SeverityNumber::Info)
  
  // 2. æµ‹è¯•ä¸Šä¸‹æ–‡æ¢å¤
  let context = Context::empty()
  let key = create_key("recovery.key")
  let original_context = context.with_value(key, "original.value")
  
  // æ¨¡æ‹Ÿä¸Šä¸‹æ–‡ä¸¢å¤±
  let corrupted_context = Context::empty()
  
  // æ¢å¤ä¸Šä¸‹æ–‡
  let recovered_context = corrupted_context.with_value(key, "original.value")
  
  match recovered_context.get(key) {
    Some(value) => assert_eq(value, "original.value")
    None => @test.fail("Expected recovered context value")
  }
  
  // 3. æµ‹è¯•ä¼ æ’­æ¢å¤
  let propagator = W3CTraceContextPropagator::{}
  let carrier = MapCarrier::new()
  
  // æ­£å¸¸ä¼ æ’­
  propagator.inject(original_context, carrier)
  let extracted_context = propagator.extract(Context::empty(), carrier)
  
  // éªŒè¯æ¢å¤
  match extracted_context.get(key) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Expected extracted context value")
  }
}