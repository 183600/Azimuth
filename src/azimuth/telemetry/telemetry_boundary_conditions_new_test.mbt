// Azimuth Telemetry - Boundary Conditions Test
// æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶

use azimuth.telemetry.api.common
use azimuth.telemetry.api.context
use azimuth.telemetry.api.trace
use azimuth.telemetry.api.metrics
use azimuth.telemetry.api.logs

test "trace_boundary_conditions" {
  // æµ‹è¯•Trace APIçš„è¾¹ç•Œæ¡ä»¶
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("boundary-test-tracer", "1.0.0")
  let ctx = context::Context::new()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²è¾¹ç•Œ
  let (_, empty_name_span) = tracer.start_span(ctx, "", trace::Internal, [], 0L)
  @assert(empty_name_span.name == "")
  
  // æµ‹è¯•å•å­—ç¬¦è¾¹ç•Œ
  let (_, single_char_span) = tracer.start_span(ctx, "a", trace::Internal, [], 0L)
  @assert(single_char_span.name == "a")
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²è¾¹ç•Œ
  let very_long_name = "a" * 100000
  let (_, long_name_span) = tracer.start_span(ctx, very_long_name, trace::Internal, [], 0L)
  @assert(long_name_span.name.length() == 100000)
  
  // æµ‹è¯•æ—¶é—´æˆ³è¾¹ç•Œ
  let (_, min_time_span) = tracer.start_span(ctx, "min-time", trace::Internal, [], -9223372036854775808L)
  @assert(min_time_span.start_time_unix_nanos == -9223372036854775808L)
  
  let (_, max_time_span) = tracer.start_span(ctx, "max-time", trace::Internal, [], 9223372036854775807L)
  @assert(max_time_span.start_time_unix_nanos == 9223372036854775807L)
  
  let (_, zero_time_span) = tracer.start_span(ctx, "zero-time", trace::Internal, [], 0L)
  @assert(zero_time_span.start_time_unix_nanos == 0L)
  
  // æµ‹è¯•æ‰€æœ‰SpanKind
  let (_, internal_span) = tracer.start_span(ctx, "internal", trace::Internal, [], 0L)
  let (_, server_span) = tracer.start_span(ctx, "server", trace::Server, [], 0L)
  let (_, client_span) = tracer.start_span(ctx, "client", trace::Client, [], 0L)
  let (_, producer_span) = tracer.start_span(ctx, "producer", trace::Producer, [], 0L)
  let (_, consumer_span) = tracer.start_span(ctx, "consumer", trace::Consumer, [], 0L)
  
  @assert(internal_span.kind == trace::Internal)
  @assert(server_span.kind == trace::Server)
  @assert(client_span.kind == trace::Client)
  @assert(producer_span.kind == trace::Producer)
  @assert(consumer_span.kind == trace::Consumer)
  
  // æµ‹è¯•å±æ€§æ•°é‡è¾¹ç•Œ
  let no_attrs_span = tracer.start_span(ctx, "no-attrs", trace::Internal, [], 0L).1
  @assert(no_attrs_span.attributes.length() == 0)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut many_attrs = []
  let mut i = 0
  while i < 10000 {
    many_attrs.push(("attr." + i.to_string(), common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  
  let many_attrs_span = tracer.start_span(ctx, "many-attrs", trace::Internal, many_attrs, 0L).1
  @assert(many_attrs_span.attributes.length() == 10000)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~ \t\n\r"
  let (_, special_chars_span) = tracer.start_span(ctx, special_chars, trace::Internal, [], 0L)
  @assert(special_chars_span.name == special_chars)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_name = "æµ‹è¯•ä¸­æ–‡ğŸš€emoji Ğ¸ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  let (_, unicode_span) = tracer.start_span(ctx, unicode_name, trace::Internal, [], 0L)
  @assert(unicode_span.name == unicode_name)
}

test "metrics_boundary_conditions" {
  // æµ‹è¯•Metrics APIçš„è¾¹ç•Œæ¡ä»¶
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("boundary-test-meter", "1.0.0")
  
  // æµ‹è¯•ç©ºåç§°
  let empty_counter = meter.create_counter("", "count", "")
  empty_counter.add(1L, [])
  @assert(true) // åº”è¯¥èƒ½å¤„ç†ç©ºåç§°
  
  let empty_histogram = meter.create_histogram("", "ms", "")
  empty_histogram.record(1.0, [])
  @assert(true)
  
  // æµ‹è¯•æé•¿åç§°
  let long_name = "a" * 100000
  let long_counter = meter.create_counter(long_name, "count", "Long name counter")
  long_counter.add(1L, [])
  @assert(true)
  
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œ
  let counter = meter.create_counter("boundary-counter", "count", "Boundary test counter")
  let histogram = meter.create_histogram("boundary-histogram", "ms", "Boundary test histogram")
  let up_down_counter = meter.create_up_down_counter("boundary-up-down-counter", "count", "Boundary test up-down counter")
  let gauge = meter.create_gauge("boundary-gauge", "value", "Boundary test gauge")
  
  // æµ‹è¯•æå€¼
  counter.add(-9223372036854775808L, []) // æœ€å°Int64
  counter.add(9223372036854775807L, [])  // æœ€å¤§Int64
  counter.add(0L, [])                     // é›¶
  
  up_down_counter.add(-9223372036854775808L, [])
  up_down_counter.add(9223372036854775807L, [])
  up_down_counter.add(0L, [])
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œ
  histogram.record(-1.7976931348623157e+308, []) // æœ€å°Double
  histogram.record(1.7976931348623157e+308, [])  // æœ€å¤§Double
  histogram.record(0.0, [])                       // é›¶
  histogram.record(-0.0, [])                      // è´Ÿé›¶
  histogram.record(1.0 / 0.0, [])                 // æ­£æ— ç©·
  histogram.record(-1.0 / 0.0, [])                // è´Ÿæ— ç©·
  histogram.record(0.0 / 0.0, [])                 // NaN
  
  gauge.record(-1.7976931348623157e+308, [])
  gauge.record(1.7976931348623157e+308, [])
  gauge.record(0.0, [])
  gauge.record(-0.0, [])
  gauge.record(1.0 / 0.0, [])
  gauge.record(-1.0 / 0.0, [])
  gauge.record(0.0 / 0.0, [])
  
  // æµ‹è¯•æå°å€¼
  histogram.record(1.0e-308, [])  // æ¥è¿‘é›¶çš„æœ€å°æ­£å€¼
  histogram.record(-1.0e-308, []) // æ¥è¿‘é›¶çš„æœ€å°è´Ÿå€¼
  gauge.record(1.0e-308, [])
  gauge.record(-1.0e-308, [])
  
  // æµ‹è¯•å±æ€§æ•°é‡è¾¹ç•Œ
  counter.add(1L, []) // æ— å±æ€§
  
  let mut many_attrs = []
  let mut i = 0
  while i < 10000 {
    many_attrs.push(("attr." + i.to_string(), common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  counter.add(1L, many_attrs) // å¤§é‡å±æ€§
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§é”®
  let special_attrs = [
    ("", common::AttributeValue::string("empty key")),
    ("!@#$%^&*()", common::AttributeValue::string("special chars")),
    ("ä¸­æ–‡é”®", common::AttributeValue::string("Chinese key")),
    ("ĞºĞ»ÑÑ‡", common::AttributeValue::string("Russian key")),
    ("Ù…ÙØªØ§Ø­", common::AttributeValue::string("Arabic key"))
  ]
  counter.add(1L, special_attrs)
}

test "logs_boundary_conditions" {
  // æµ‹è¯•Logs APIçš„è¾¹ç•Œæ¡ä»¶
  
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("boundary-test-logger", "1.0.0")
  
  // æµ‹è¯•ç©ºæ¶ˆæ¯
  logger.info("", [])
  logger.warn("", [])
  logger.error("", [])
  logger.debug("", [])
  logger.fatal("", [])
  
  // æµ‹è¯•æé•¿æ¶ˆæ¯
  let long_message = "a" * 1000000
  logger.info(long_message, [])
  logger.warn(long_message, [])
  logger.error(long_message, [])
  logger.debug(long_message, [])
  logger.fatal(long_message, [])
  
  // æµ‹è¯•æ—¶é—´æˆ³è¾¹ç•Œ
  let min_time_log = logs::LogRecord::builder()
    .timestamp(-9223372036854775808L)
    .severity(logs::Info)
    .body("Min time")
    .build()
  
  let max_time_log = logs::LogRecord::builder()
    .timestamp(9223372036854775807L)
    .severity(logs::Info)
    .body("Max time")
    .build()
  
  let zero_time_log = logs::LogRecord::builder()
    .timestamp(0L)
    .severity(logs::Info)
    .body("Zero time")
    .build()
  
  logger.emit(min_time_log)
  logger.emit(max_time_log)
  logger.emit(zero_time_log)
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡çº§åˆ«
  let trace_log = logs::LogRecord::builder().severity(logs::Trace).body("Trace").build()
  let debug_log = logs::LogRecord::builder().severity(logs::Debug).body("Debug").build()
  let info_log = logs::LogRecord::builder().severity(logs::Info).body("Info").build()
  let warn_log = logs::LogRecord::builder().severity(logs::Warn).body("Warn").build()
  let error_log = logs::LogRecord::builder().severity(logs::Error).body("Error").build()
  let fatal_log = logs::LogRecord::builder().severity(logs::Fatal).body("Fatal").build()
  
  logger.emit(trace_log)
  logger.emit(debug_log)
  logger.emit(info_log)
  logger.emit(warn_log)
  logger.emit(error_log)
  logger.emit(fatal_log)
  
  // æµ‹è¯•severity_textè¾¹ç•Œ
  let empty_severity_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .severity_text("")
    .body("Empty severity text")
    .build()
  
  let long_severity_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .severity_text("a" * 10000)
    .body("Long severity text")
    .build()
  
  let special_severity_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .severity_text("!@#$%^&*()ä¸­æ–‡ğŸš€")
    .body("Special severity text")
    .build()
  
  logger.emit(empty_severity_log)
  logger.emit(long_severity_log)
  logger.emit(special_severity_log)
  
  // æµ‹è¯•å±æ€§æ•°é‡è¾¹ç•Œ
  let no_attrs_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("No attributes")
    .build()
  
  logger.emit(no_attrs_log)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut many_attrs_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("Many attributes")
  
  let mut i = 0
  while i < 10000 {
    many_attrs_log = many_attrs_log.with_attribute(
      "attr." + i.to_string(),
      common::AttributeValue::int(i.to_int64())
    )
    i = i + 1
  }
  
  logger.emit(many_attrs_log.build())
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ¶ˆæ¯
  let special_message = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~ \t\n\r ä¸­æ–‡ğŸš€emoji Ğ¸ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  logger.info(special_message, [])
}

test "attribute_boundary_conditions" {
  // æµ‹è¯•å±æ€§å€¼çš„è¾¹ç•Œæ¡ä»¶
  
  // å­—ç¬¦ä¸²å±æ€§è¾¹ç•Œ
  let empty_string = common::AttributeValue::string("")
  let single_char_string = common::AttributeValue::string("a")
  let long_string = common::AttributeValue::string("a" * 1000000)
  let whitespace_string = common::AttributeValue::string(" \t\n\r ")
  let unicode_string = common::AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€emoji Ğ¸ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  let special_chars_string = common::AttributeValue::string("!@#$%^&*()_+-=[]{}|;':\",./<>?`~")
  
  @assert(match empty_string { common::StringValue(s) => s == "" _ => false })
  @assert(match single_char_string { common::StringValue(s) => s == "a" _ => false })
  @assert(match long_string { common::StringValue(s) => s.length() == 1000000 _ => false })
  @assert(match whitespace_string { common::StringValue(s) => s.length() > 0 _ => false })
  @assert(match unicode_string { common::StringValue(s) => s.length() > 0 _ => false })
  @assert(match special_chars_string { common::StringValue(s) => s.length() > 0 _ => false })
  
  // æ•´æ•°å±æ€§è¾¹ç•Œ
  let min_int = common::AttributeValue::int(-9223372036854775808L)
  let max_int = common::AttributeValue::int(9223372036854775807L)
  let zero_int = common::AttributeValue::int(0L)
  let neg_one_int = common::AttributeValue::int(-1L)
  let pos_one_int = common::AttributeValue::int(1L)
  
  @assert(match min_int { common::IntValue(v) => v == -9223372036854775808L _ => false })
  @assert(match max_int { common::IntValue(v) => v == 9223372036854775807L _ => false })
  @assert(match zero_int { common::IntValue(v) => v == 0L _ => false })
  @assert(match neg_one_int { common::IntValue(v) => v == -1L _ => false })
  @assert(match pos_one_int { common::IntValue(v) => v == 1L _ => false })
  
  // æµ®ç‚¹æ•°å±æ€§è¾¹ç•Œ
  let min_float = common::AttributeValue::float(-1.7976931348623157e+308)
  let max_float = common::AttributeValue::float(1.7976931348623157e+308)
  let zero_float = common::AttributeValue::float(0.0)
  let neg_zero_float = common::AttributeValue::float(-0.0)
  let min_positive_float = common::AttributeValue::float(1.0e-308)
  let max_negative_float = common::AttributeValue::float(-1.0e-308)
  let pos_inf_float = common::AttributeValue::float(1.0 / 0.0)
  let neg_inf_float = common::AttributeValue::float(-1.0 / 0.0)
  let nan_float = common::AttributeValue::float(0.0 / 0.0)
  
  @assert(match min_float { common::FloatValue(v) => v == -1.7976931348623157e+308 _ => false })
  @assert(match max_float { common::FloatValue(v) => v == 1.7976931348623157e+308 _ => false })
  @assert(match zero_float { common::FloatValue(v) => v == 0.0 _ => false })
  @assert(match neg_zero_float { common::FloatValue(v) => v == -0.0 _ => false })
  @assert(match min_positive_float { common::FloatValue(v) => v == 1.0e-308 _ => false })
  @assert(match max_negative_float { common::FloatValue(v) => v == -1.0e-308 _ => false })
  @assert(match pos_inf_float { common::FloatValue(v) => v == 1.0 / 0.0 _ => false })
  @assert(match neg_inf_float { common::FloatValue(v) => v == -1.0 / 0.0 _ => false })
  @assert(match nan_float { common::FloatValue(v) => (v != v) _ => false }) // NaNæ£€æŸ¥
  
  // å¸ƒå°”å±æ€§è¾¹ç•Œ
  let true_bool = common::AttributeValue::bool(true)
  let false_bool = common::AttributeValue::bool(false)
  
  @assert(match true_bool { common::BoolValue(v) => v == true _ => false })
  @assert(match false_bool { common::BoolValue(v) => v == false _ => false })
  
  // æ•°ç»„å±æ€§è¾¹ç•Œ
  let empty_string_array = common::AttributeValue::array_string([])
  let single_string_array = common::AttributeValue::array_string(["single"])
  let large_string_array = common::AttributeValue::array_string(["a" * 1000; 1000])
  
  let empty_int_array = common::AttributeValue::array_int([])
  let single_int_array = common::AttributeValue::array_int([1L])
  let large_int_array = common::AttributeValue::array_int([0L; 10000])
  
  let empty_float_array = common::AttributeValue::array_float([])
  let single_float_array = common::AttributeValue::array_float([1.0])
  let large_float_array = common::AttributeValue::array_float([0.0; 10000])
  
  let empty_bool_array = common::AttributeValue::array_bool([])
  let single_bool_array = common::AttributeValue::array_bool([true])
  let large_bool_array = common::AttributeValue::array_bool([true; 10000])
  
  @assert(match empty_string_array { common::ArrayStringValue(arr) => arr.length() == 0 _ => false })
  @assert(match single_string_array { common::ArrayStringValue(arr) => arr.length() == 1 _ => false })
  @assert(match large_string_array { common::ArrayStringValue(arr) => arr.length() == 1000 _ => false })
  
  @assert(match empty_int_array { common::ArrayIntValue(arr) => arr.length() == 0 _ => false })
  @assert(match single_int_array { common::ArrayIntValue(arr) => arr.length() == 1 _ => false })
  @assert(match large_int_array { common::ArrayIntValue(arr) => arr.length() == 10000 _ => false })
  
  @assert(match empty_float_array { common::ArrayFloatValue(arr) => arr.length() == 0 _ => false })
  @assert(match single_float_array { common::ArrayFloatValue(arr) => arr.length() == 1 _ => false })
  @assert(match large_float_array { common::ArrayFloatValue(arr) => arr.length() == 10000 _ => false })
  
  @assert(match empty_bool_array { common::ArrayBoolValue(arr) => arr.length() == 0 _ => false })
  @assert(match single_bool_array { common::ArrayBoolValue(arr) => arr.length() == 1 _ => false })
  @assert(match large_bool_array { common::ArrayBoolValue(arr) => arr.length() == 10000 _ => false })
}

test "resource_boundary_conditions" {
  // æµ‹è¯•èµ„æºçš„è¾¹ç•Œæ¡ä»¶
  
  // æœåŠ¡åç§°è¾¹ç•Œ
  let empty_service_resource = common::Resource::default("")
  let single_char_service_resource = common::Resource::default("a")
  let long_service_resource = common::Resource::default("a" * 10000)
  let unicode_service_resource = common::Resource::default("æµ‹è¯•æœåŠ¡ğŸš€")
  let special_service_resource = common::Resource::default("!@#$%^&*()")
  
  @assert(empty_service_resource.service_name == "")
  @assert(single_char_service_resource.service_name == "a")
  @assert(long_service_resource.service_name.length() == 10000)
  @assert(unicode_service_resource.service_name == "æµ‹è¯•æœåŠ¡ğŸš€")
  @assert(special_service_resource.service_name == "!@#$%^&*()")
  
  // æœåŠ¡ç‰ˆæœ¬è¾¹ç•Œ
  let empty_version_resource = common::Resource::{
    service_name: "test",
    service_version: Some(""),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: []
  }
  
  let long_version_resource = common::Resource::{
    service_name: "test",
    service_version: Some("a" * 10000),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: []
  }
  
  let unicode_version_resource = common::Resource::{
    service_name: "test",
    service_version: Some("ç‰ˆæœ¬1.0.0ğŸš€"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: []
  }
  
  @assert(empty_version_resource.service_version.unwrap_or("") == "")
  @assert(long_version_resource.service_version.unwrap_or("").length() == 10000)
  @assert(unicode_version_resource.service_version.unwrap_or("") == "ç‰ˆæœ¬1.0.0ğŸš€")
  
  // å±æ€§æ•°é‡è¾¹ç•Œ
  let no_attrs_resource = common::Resource::{
    service_name: "no-attrs",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: []
  }
  
  let mut many_attrs = []
  let mut i = 0
  while i < 10000 {
    many_attrs.push(("attr." + i.to_string(), common::AttributeValue::string("value." + i.to_string())))
    i = i + 1
  }
  
  let many_attrs_resource = common::Resource::{
    service_name: "many-attrs",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: many_attrs
  }
  
  @assert(no_attrs_resource.attributes.length() == 0)
  @assert(many_attrs_resource.attributes.length() == 10000)
  
  // ç‰¹æ®Šå±æ€§é”®
  let special_attrs_resource = common::Resource::{
    service_name: "special-attrs",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: [
      ("", common::AttributeValue::string("empty key")),
      ("!@#$%^&*()", common::AttributeValue::string("special chars")),
      ("ä¸­æ–‡å±æ€§", common::AttributeValue::string("Chinese attribute")),
      ("Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚", common::AttributeValue::string("Russian attribute")),
      ("Ø®Ø§ØµÙŠØ©", common::AttributeValue::string("Arabic attribute"))
    ]
  }
  
  @assert(special_attrs_resource.attributes.length() == 5)
}

test "context_boundary_conditions" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡çš„è¾¹ç•Œæ¡ä»¶
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("context-boundary-test-tracer", "1.0.0")
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_ctx = context::Context::new()
  let (_, empty_ctx_span) = tracer.start_span(empty_ctx, "empty-ctx-span", trace::Internal, [], 0L)
  @assert(empty_ctx_span.name == "empty-ctx-span")
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡é“¾
  let (ctx1, span1) = tracer.start_span(empty_ctx, "span1", trace::Internal, [], 0L)
  let (ctx2, span2) = tracer.start_span(ctx1, "span2", trace::Internal, [], 0L)
  let (ctx3, span3) = tracer.start_span(ctx2, "span3", trace::Internal, [], 0L)
  
  // éªŒè¯ä¸Šä¸‹æ–‡é“¾çš„åŸºæœ¬ç»“æ„
  @assert(span1.name == "span1")
  @assert(span2.name == "span2")
  @assert(span3.name == "span3")
  @assert(span1.context.trace_id.length() == 16)
  @assert(span2.context.trace_id.length() == 16)
  @assert(span3.context.trace_id.length() == 16)
  @assert(span1.context.span_id.length() == 8)
  @assert(span2.context.span_id.length() == 8)
  @assert(span3.context.span_id.length() == 8)
  
  // æµ‹è¯•æ·±åº¦åµŒå¥—ä¸Šä¸‹æ–‡
  let mut current_ctx = empty_ctx
  let mut i = 0
  while i < 1000 {
    let (next_ctx, span) = tracer.start_span(
      current_ctx,
      "deep-span-" + i.to_string(),
      trace::Internal,
      [("depth", common::AttributeValue::int(i.to_int64()))],
      0L
    )
    current_ctx = next_ctx
    
    // éªŒè¯æ¯ä¸€å±‚çš„spanéƒ½æ­£ç¡®åˆ›å»º
    @assert(span.name == "deep-span-" + i.to_string())
    @assert(span.attributes.length() == 1)
    
    i = i + 1
  }
  
  // æµ‹è¯•è¾¹ç•Œå±æ€§å€¼åœ¨ä¸Šä¸‹æ–‡ä¸­çš„ä¼ æ’­
  let boundary_attrs = [
    ("empty.string", common::AttributeValue::string("")),
    ("max.int", common::AttributeValue::int(9223372036854775807L)),
    ("min.int", common::AttributeValue::int(-9223372036854775808L)),
    ("max.float", common::AttributeValue::float(1.7976931348623157e+308)),
    ("min.float", common::AttributeValue::float(-1.7976931348623157e+308)),
    ("nan.float", common::AttributeValue::float(0.0 / 0.0)),
    ("inf.float", common::AttributeValue::float(1.0 / 0.0)),
    ("neg.inf.float", common::AttributeValue::float(-1.0 / 0.0)),
    ("true.bool", common::AttributeValue::bool(true)),
    ("false.bool", common::AttributeValue::bool(false)),
    ("empty.array", common::AttributeValue::array_string([])),
    ("large.array", common::AttributeValue::array_int([0L; 1000]))
  ]
  
  let (_, boundary_span) = tracer.start_span(
    empty_ctx,
    "boundary-attrs-span",
    trace::Internal,
    boundary_attrs,
    0L
  )
  
  @assert(boundary_span.attributes.length() == boundary_attrs.length())
}

test "numeric_precision_boundary" {
  // æµ‹è¯•æ•°å€¼ç²¾åº¦è¾¹ç•Œ
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("precision-test-meter", "1.0.0")
  let histogram = meter.create_histogram("precision-histogram", "ms", "Precision test histogram")
  let gauge = meter.create_gauge("precision-gauge", "value", "Precision test gauge")
  
  // æµ‹è¯•æµ®ç‚¹æ•°ç²¾åº¦è¾¹ç•Œ
  histogram.record(1.0e-10, [])      // å¾ˆå°çš„æ­£æ•°
  histogram.record(-1.0e-10, [])     // å¾ˆå°çš„è´Ÿæ•°
  histogram.record(1.0e+10, [])      // å¾ˆå¤§çš„æ­£æ•°
  histogram.record(-1.0e+10, [])     // å¾ˆå¤§çš„è´Ÿæ•°
  
  gauge.record(1.0e-15, [])          // æ¥è¿‘ç²¾åº¦æé™çš„å°æ•°
  gauge.record(-1.0e-15, [])         // æ¥è¿‘ç²¾åº¦æé™çš„è´Ÿå°æ•°
  gauge.record(1.0e+15, [])          // æ¥è¿‘ç²¾åº¦æé™çš„å¤§æ•°
  gauge.record(-1.0e+15, [])         // æ¥è¿‘ç²¾åº¦æé™çš„è´Ÿå¤§æ•°
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  histogram.record(0.0, [])           // æ­£é›¶
  histogram.record(-0.0, [])          // è´Ÿé›¶
  histogram.record(1.0 / 0.0, [])     // æ­£æ— ç©·
  histogram.record(-1.0 / 0.0, [])    // è´Ÿæ— ç©·
  histogram.record(0.0 / 0.0, [])     // NaN
  
  gauge.record(0.0, [])
  gauge.record(-0.0, [])
  gauge.record(1.0 / 0.0, [])
  gauge.record(-1.0 / 0.0, [])
  gauge.record(0.0 / 0.0, [])
  
  // æµ‹è¯•æ•´æ•°ç²¾åº¦è¾¹ç•Œ
  let counter = meter.create_counter("precision-counter", "count", "Precision test counter")
  let up_down_counter = meter.create_up_down_counter("precision-up-down-counter", "count", "Precision test up-down counter")
  
  counter.add(1L, [])                 // æœ€å°æ­£æ•´æ•°
  counter.add(-1L, [])                // æœ€å°è´Ÿæ•´æ•°
  counter.add(9223372036854775807L, []) // æœ€å¤§æ­£æ•´æ•°
  counter.add(-9223372036854775808L, []) // æœ€å°è´Ÿæ•´æ•°
  
  up_down_counter.add(1L, [])
  up_down_counter.add(-1L, [])
  up_down_counter.add(9223372036854775807L, [])
  up_down_counter.add(-9223372036854775808L, [])
}