// å±æ€§å€¼è½¬æ¢æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Azimuth Telemetryä¸­å±æ€§å€¼çš„ç±»å‹è½¬æ¢å’Œåºåˆ—åŒ–åŠŸèƒ½

test "attribute_value_type_conversions" {
  // æµ‹è¯•å±æ€§å€¼ç±»å‹è½¬æ¢
  
  // å­—ç¬¦ä¸²å€¼è½¬æ¢
  let string_attr = common::AttributeValue::string("test-string")
  match string_attr {
    common::StringValue(s) => {
      assert_eq(s, "test-string")
      assert_eq(s.length(), 11)
    }
    _ => assert_eq(false, true, "Expected StringValue")
  }
  
  // æ•´æ•°å€¼è½¬æ¢
  let int_attr = common::AttributeValue::int(12345L)
  match int_attr {
    common::IntValue(i) => {
      assert_eq(i, 12345L)
      assert_eq(i > 10000L, true)
    }
    _ => assert_eq(false, true, "Expected IntValue")
  }
  
  // æµ®ç‚¹å€¼è½¬æ¢
  let float_attr = common::AttributeValue::float(3.14159)
  match float_attr {
    common::FloatValue(f) => {
      assert_eq(f > 3.0 && f < 3.2, true)
      assert_eq(f.to_string().contains("3.14"), true)
    }
    _ => assert_eq(false, true, "Expected FloatValue")
  }
  
  // å¸ƒå°”å€¼è½¬æ¢
  let bool_attr = common::AttributeValue::bool(true)
  match bool_attr {
    common::BoolValue(b) => assert_eq(b, true)
    _ => assert_eq(false, true, "Expected BoolValue")
  }
  
  // å­—ç¬¦ä¸²æ•°ç»„è½¬æ¢
  let string_array = ["item1", "item2", "item3"]
  let string_array_attr = common::AttributeValue::array_string(string_array)
  match string_array_attr {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], "item1")
      assert_eq(arr[1], "item2")
      assert_eq(arr[2], "item3")
    }
    _ => assert_eq(false, true, "Expected ArrayStringValue")
  }
  
  // æ•´æ•°æ•°ç»„è½¬æ¢
  let int_array = [1L, 2L, 3L, 4L, 5L]
  let int_array_attr = common::AttributeValue::array_int(int_array)
  match int_array_attr {
    common::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 5)
      assert_eq(arr[0], 1L)
      assert_eq(arr[4], 5L)
    }
    _ => assert_eq(false, true, "Expected ArrayIntValue")
  }
  
  // æµ®ç‚¹æ•°ç»„è½¬æ¢
  let float_array = [1.1, 2.2, 3.3]
  let float_array_attr = common::AttributeValue::array_float(float_array)
  match float_array_attr {
    common::ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], 1.1)
      assert_eq(arr[1], 2.2)
      assert_eq(arr[2], 3.3)
    }
    _ => assert_eq(false, true, "Expected ArrayFloatValue")
  }
  
  // å¸ƒå°”æ•°ç»„è½¬æ¢
  let bool_array = [true, false, true]
  let bool_array_attr = common::AttributeValue::array_bool(bool_array)
  match bool_array_attr {
    common::ArrayBoolValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], true)
      assert_eq(arr[1], false)
      assert_eq(arr[2], true)
    }
    _ => assert_eq(false, true, "Expected ArrayBoolValue")
  }
}

test "attribute_value_serialization_patterns" {
  // æµ‹è¯•å±æ€§å€¼åºåˆ—åŒ–æ¨¡å¼
  
  // åˆ›å»ºå¤æ‚å±æ€§é›†åˆ
  let complex_attributes = [
    ("string.basic", common::AttributeValue::string("basic string")),
    ("string.empty", common::AttributeValue::string("")),
    ("string.special", common::AttributeValue::string("special chars: @#$%^&*()")),
    ("string.unicode", common::AttributeValue::string("Unicode: æµ‹è¯• ğŸš€ ğŸ’«")),
    ("string.long", common::AttributeValue::string("This is a very long string that tests serialization of extended text content without issues")),
    
    ("int.zero", common::AttributeValue::int(0L)),
    ("int.positive", common::AttributeValue::int(42L)),
    ("int.negative", common::AttributeValue::int(-100L)),
    ("int.max", common::AttributeValue::int(9223372036854775807L)),
    ("int.min", common::AttributeValue::int(-9223372036854775808L)),
    
    ("float.zero", common::AttributeValue::float(0.0)),
    ("float.positive", common::AttributeValue::float(3.14159)),
    ("float.negative", common::AttributeValue::float(-2.71828)),
    ("float.scientific", common::AttributeValue::float(1.23e-4)),
    ("float.large", common::AttributeValue::float(1.7976931348623157e+308)),
    
    ("bool.true", common::AttributeValue::bool(true)),
    ("bool.false", common::AttributeValue::bool(false)),
    
    ("array.string.empty", common::AttributeValue::array_string([])),
    ("array.string.single", common::AttributeValue::array_string(["single"])),
    ("array.string.multiple", common::AttributeValue::array_string(["first", "second", "third"])),
    
    ("array.int.empty", common::AttributeValue::array_int([])),
    ("array.int.sequence", common::AttributeValue::array_int([1L, 2L, 3L, 4L, 5L])),
    
    ("array.float.empty", common::AttributeValue::array_float([])),
    ("array.float.decimals", common::AttributeValue::array_float([1.1, 2.2, 3.3])),
    
    ("array.bool.empty", common::AttributeValue::array_bool([])),
    ("array.bool.mixed", common::AttributeValue::array_bool([true, false, true, false]))
  ]
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½è¢«æ­£ç¡®åˆ›å»º
  assert_eq(complex_attributes.length(), 25)
  
  // æ¨¡æ‹Ÿåºåˆ—åŒ–è¿‡ç¨‹ï¼ˆåœ¨å®é™…å®ç°ä¸­ä¼šæœ‰ä¸“é—¨çš„åºåˆ—åŒ–å‡½æ•°ï¼‰
  let mut serialized_count = 0
  let mut i = 0
  while i < complex_attributes.length() {
    let (key, value) = complex_attributes[i]
    
    // æ¨¡æ‹Ÿåºåˆ—åŒ–éªŒè¯
    match value {
      common::StringValue(s) => {
        assert_eq(key.contains("string"), true)
        serialized_count = serialized_count + 1
      }
      common::IntValue(i) => {
        assert_eq(key.contains("int"), true)
        serialized_count = serialized_count + 1
      }
      common::FloatValue(f) => {
        assert_eq(key.contains("float"), true)
        serialized_count = serialized_count + 1
      }
      common::BoolValue(b) => {
        assert_eq(key.contains("bool"), true)
        serialized_count = serialized_count + 1
      }
      common::ArrayStringValue(arr) => {
        assert_eq(key.contains("array.string"), true)
        assert_eq(arr.length() >= 0, true)
        serialized_count = serialized_count + 1
      }
      common::ArrayIntValue(arr) => {
        assert_eq(key.contains("array.int"), true)
        assert_eq(arr.length() >= 0, true)
        serialized_count = serialized_count + 1
      }
      common::ArrayFloatValue(arr) => {
        assert_eq(key.contains("array.float"), true)
        assert_eq(arr.length() >= 0, true)
        serialized_count = serialized_count + 1
      }
      common::ArrayBoolValue(arr) => {
        assert_eq(key.contains("array.bool"), true)
        assert_eq(arr.length() >= 0, true)
        serialized_count = serialized_count + 1
      }
    }
    
    i = i + 1
  }
  
  assert_eq(serialized_count, 25)
}

test "attribute_value_deserialization_validation" {
  // æµ‹è¯•å±æ€§å€¼ååºåˆ—åŒ–éªŒè¯
  
  // æ¨¡æ‹Ÿä»å­—ç¬¦ä¸²ååºåˆ—åŒ–å±æ€§å€¼
  let string_inputs = [
    ("simple", "simple"),
    ("empty", ""),
    ("spaces", "  leading and trailing  "),
    ("special", "special: @#$%^&*()"),
    ("unicode", "Unicode: æµ‹è¯• ğŸš€"),
    ("json_like", "{\"key\":\"value\",\"number\":123}"),
    ("url_like", "https://example.com/path?param=value"),
    ("csv_like", "value1,value2,value3")
  ]
  
  // éªŒè¯å­—ç¬¦ä¸²ååºåˆ—åŒ–
  let mut i = 0
  while i < string_inputs.length() {
    let (name, input) = string_inputs[i]
    let attr = common::AttributeValue::string(input)
    
    match attr {
      common::StringValue(s) => {
        assert_eq(s, input)
        assert_eq(s.length() >= 0, true)
      }
      _ => assert_eq(false, true, "Expected StringValue for " + name)
    }
    
    i = i + 1
  }
  
  // æ¨¡æ‹Ÿä»æ•°å­—å­—ç¬¦ä¸²ååºåˆ—åŒ–æ•´æ•°
  let int_string_inputs = [
    ("zero", "0"),
    ("positive", "123"),
    ("negative", "-456"),
    ("large", "9223372036854775807"),
    ("small", "-9223372036854775808")
  ]
  
  i = 0
  while i < int_string_inputs.length() {
    let (name, input) = int_string_inputs[i]
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šè§£æå­—ç¬¦ä¸²ä¸ºæ•´æ•°
    let parsed_value = input.to_int64().unwrap_or(0L)
    let attr = common::AttributeValue::int(parsed_value)
    
    match attr {
      common::IntValue(int_val) => {
        assert_eq(int_val.to_string(), input)
      }
      _ => assert_eq(false, true, "Expected IntValue for " + name)
    }
    
    i = i + 1
  }
  
  // æ¨¡æ‹Ÿä»æ•°å­—å­—ç¬¦ä¸²ååºåˆ—åŒ–æµ®ç‚¹æ•°
  let float_string_inputs = [
    ("zero", "0.0"),
    ("positive", "3.14159"),
    ("negative", "-2.71828"),
    ("scientific", "1.23e-4"),
    ("large", "1.7976931348623157e+308")
  ]
  
  i = 0
  while i < float_string_inputs.length() {
    let (name, input) = float_string_inputs[i]
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šè§£æå­—ç¬¦ä¸²ä¸ºæµ®ç‚¹æ•°
    let parsed_value = input.to_double().unwrap_or(0.0)
    let attr = common::AttributeValue::float(parsed_value)
    
    match attr {
      common::FloatValue(float_val) => {
        assert_eq(float_val > 0.0 || input.contains("-"), true)
      }
      _ => assert_eq(false, true, "Expected FloatValue for " + name)
    }
    
    i = i + 1
  }
  
  // æ¨¡æ‹Ÿä»å¸ƒå°”å­—ç¬¦ä¸²ååºåˆ—åŒ–å¸ƒå°”å€¼
  let bool_string_inputs = [
    ("true_lower", "true"),
    ("true_upper", "TRUE"),
    ("true_mixed", "True"),
    ("false_lower", "false"),
    ("false_upper", "FALSE"),
    ("false_mixed", "False"),
    ("one", "1"),
    ("zero", "0")
  ]
  
  i = 0
  while i < bool_string_inputs.length() {
    let (name, input) = bool_string_inputs[i]
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šè§£æå­—ç¬¦ä¸²ä¸ºå¸ƒå°”å€¼
    let parsed_value = input == "true" || input == "TRUE" || input == "True" || input == "1"
    let attr = common::AttributeValue::bool(parsed_value)
    
    match attr {
      common::BoolValue(bool_val) => {
        // éªŒè¯è§£æç»“æœ
        assert_eq(bool_val == true || bool_val == false, true)
      }
      _ => assert_eq(false, true, "Expected BoolValue for " + name)
    }
    
    i = i + 1
  }
}

test "attribute_value_array_serialization" {
  // æµ‹è¯•å±æ€§å€¼æ•°ç»„åºåˆ—åŒ–
  
  // å­—ç¬¦ä¸²æ•°ç»„åºåˆ—åŒ–
  let string_arrays = [
    ("empty", []),
    ("single", ["single_item"]),
    ("multiple", ["first", "second", "third"]),
    ("with_spaces", ["item with spaces", "another item"]),
    ("special_chars", ["item@#$", "item%^&", "item*()"]),
    ("unicode", ["æµ‹è¯•1", "æµ‹è¯•2", "ğŸš€ğŸŒŸğŸ’«"]),
    ("mixed_types", ["123", "456.789", "true"])
  ]
  
  let mut i = 0
  while i < string_arrays.length() {
    let (name, array) = string_arrays[i]
    let attr = common::AttributeValue::array_string(array)
    
    match attr {
      common::ArrayStringValue(arr) => {
        assert_eq(arr.length(), array.length())
        
        // éªŒè¯æ¯ä¸ªå…ƒç´ 
        let mut j = 0
        while j < arr.length() {
          assert_eq(arr[j], array[j])
          j = j + 1
        }
      }
      _ => assert_eq(false, true, "Expected ArrayStringValue for " + name)
    }
    
    i = i + 1
  }
  
  // æ•´æ•°æ•°ç»„åºåˆ—åŒ–
  let int_arrays = [
    ("empty", []),
    ("sequence", [1L, 2L, 3L, 4L, 5L]),
    ("zeros", [0L, 0L, 0L]),
    ("negatives", [-1L, -2L, -3L]),
    ("mixed", [0L, 1L, -1L, 100L, -100L]),
    ("large", [9223372036854775807L, -9223372036854775808L])
  ]
  
  i = 0
  while i < int_arrays.length() {
    let (name, array) = int_arrays[i]
    let attr = common::AttributeValue::array_int(array)
    
    match attr {
      common::ArrayIntValue(arr) => {
        assert_eq(arr.length(), array.length())
        
        let mut j = 0
        while j < arr.length() {
          assert_eq(arr[j], array[j])
          j = j + 1
        }
      }
      _ => assert_eq(false, true, "Expected ArrayIntValue for " + name)
    }
    
    i = i + 1
  }
  
  // æµ®ç‚¹æ•°ç»„åºåˆ—åŒ–
  let float_arrays = [
    ("empty", []),
    ("decimals", [1.1, 2.2, 3.3]),
    ("zeros", [0.0, 0.0, 0.0]),
    ("negatives", [-1.1, -2.2, -3.3]),
    ("mixed", [0.0, 1.5, -2.5, 100.0, -100.0]),
    ("scientific", [1.23e-4, 4.56e+7, -7.89e-3])
  ]
  
  i = 0
  while i < float_arrays.length() {
    let (name, array) = float_arrays[i]
    let attr = common::AttributeValue::array_float(array)
    
    match attr {
      common::ArrayFloatValue(arr) => {
        assert_eq(arr.length(), array.length())
        
        let mut j = 0
        while j < arr.length() {
          assert_eq(arr[j], array[j])
          j = j + 1
        }
      }
      _ => assert_eq(false, true, "Expected ArrayFloatValue for " + name)
    }
    
    i = i + 1
  }
  
  // å¸ƒå°”æ•°ç»„åºåˆ—åŒ–
  let bool_arrays = [
    ("empty", []),
    ("all_true", [true, true, true]),
    ("all_false", [false, false, false]),
    ("alternating", [true, false, true, false]),
    ("mixed", [true, true, false, false, true])
  ]
  
  i = 0
  while i < bool_arrays.length() {
    let (name, array) = bool_arrays[i]
    let attr = common::AttributeValue::array_bool(array)
    
    match attr {
      common::ArrayBoolValue(arr) => {
        assert_eq(arr.length(), array.length())
        
        let mut j = 0
        while j < arr.length() {
          assert_eq(arr[j], array[j])
          j = j + 1
        }
      }
      _ => assert_eq(false, true, "Expected ArrayBoolValue for " + name)
    }
    
    i = i + 1
  }
}

test "attribute_value_compatibility_conversions" {
  // æµ‹è¯•å±æ€§å€¼å…¼å®¹æ€§è½¬æ¢
  
  // æ•°å€¼ç±»å‹ä¹‹é—´çš„å…¼å®¹æ€§
  let int_value = common::AttributeValue::int(42L)
  let float_value = common::AttributeValue::float(42.0)
  
  // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™äº›å€¼åº”è¯¥èƒ½å¤Ÿç›¸äº’è½¬æ¢
  match int_value {
    common::IntValue(i) => {
      // æ•´æ•°å¯ä»¥è½¬æ¢ä¸ºæµ®ç‚¹æ•°
      let as_float = i.to_double()
      assert_eq(as_float, 42.0)
    }
    _ => {}
  }
  
  match float_value {
    common::FloatValue(f) => {
      // æµ®ç‚¹æ•°å¯ä»¥è½¬æ¢ä¸ºæ•´æ•°ï¼ˆå¯èƒ½æœ‰ç²¾åº¦æŸå¤±ï¼‰
      let as_int = f.to_int64()
      assert_eq(as_int, 42L)
    }
    _ => {}
  }
  
  // å¸ƒå°”å€¼ä¸æ•°å€¼çš„å…¼å®¹æ€§
  let bool_true = common::AttributeValue::bool(true)
  let bool_false = common::AttributeValue::bool(false)
  
  match bool_true {
    common::BoolValue(b) => {
      // å¸ƒå°”å€¼å¯ä»¥è½¬æ¢ä¸ºæ•´æ•°
      let as_int = if b { 1L } else { 0L }
      assert_eq(as_int, 1L)
      
      // å¸ƒå°”å€¼å¯ä»¥è½¬æ¢ä¸ºå­—ç¬¦ä¸²
      let as_string = if b { "true" } else { "false" }
      assert_eq(as_string, "true")
    }
    _ => {}
  }
  
  match bool_false {
    common::BoolValue(b) => {
      let as_int = if b { 1L } else { 0L }
      assert_eq(as_int, 0L)
      
      let as_string = if b { "true" } else { "false" }
      assert_eq(as_string, "false")
    }
    _ => {}
  }
  
  // å­—ç¬¦ä¸²ä¸å…¶ä»–ç±»å‹çš„å…¼å®¹æ€§
  let numeric_string = common::AttributeValue::string("123")
  let boolean_string = common::AttributeValue::string("true")
  let float_string = common::AttributeValue::string("3.14159")
  
  match numeric_string {
    common::StringValue(s) => {
      // æ•°å­—å­—ç¬¦ä¸²å¯ä»¥è§£æä¸ºæ•´æ•°
      let parsed_int = s.to_int64().unwrap_or(0L)
      assert_eq(parsed_int, 123L)
    }
    _ => {}
  }
  
  match boolean_string {
    common::StringValue(s) => {
      // å¸ƒå°”å­—ç¬¦ä¸²å¯ä»¥è§£æä¸ºå¸ƒå°”å€¼
      let parsed_bool = s == "true" || s == "TRUE" || s == "True"
      assert_eq(parsed_bool, true)
    }
    _ => {}
  }
  
  match float_string {
    common::StringValue(s) => {
      // æµ®ç‚¹å­—ç¬¦ä¸²å¯ä»¥è§£æä¸ºæµ®ç‚¹æ•°
      let parsed_float = s.to_double().unwrap_or(0.0)
      assert_eq(parsed_float > 3.0 && parsed_float < 3.2, true)
    }
    _ => {}
  }
  
  // æ•°ç»„ç±»å‹çš„å…¼å®¹æ€§
  let string_array = common::AttributeValue::array_string(["1", "2", "3"])
  let int_array = common::AttributeValue::array_int([1L, 2L, 3L])
  
  match string_array {
    common::ArrayStringValue(arr) => {
      // å­—ç¬¦ä¸²æ•°ç»„å¯ä»¥å°è¯•è§£æä¸ºæ•°å€¼æ•°ç»„
      let mut parsed_successfully = true
      let mut i = 0
      while i < arr.length() {
        match arr[i].to_int64() {
          Some(_) => {}
          None => parsed_successfully = false
        }
        i = i + 1
      }
      assert_eq(parsed_successfully, true)
    }
    _ => {}
  }
  
  // æµ‹è¯•ç±»å‹è½¬æ¢çš„è¾¹ç•Œæƒ…å†µ
  let edge_cases = [
    ("int_to_bool_zero", common::AttributeValue::int(0L)),
    ("int_to_bool_nonzero", common::AttributeValue::int(1L)),
    ("float_to_bool_zero", common::AttributeValue::float(0.0)),
    ("float_to_bool_nonzero", common::AttributeValue::float(1.0)),
    ("string_to_bool_true", common::AttributeValue::string("true")),
    ("string_to_bool_false", common::AttributeValue::string("false")),
    ("string_to_bool_one", common::AttributeValue::string("1")),
    ("string_to_bool_zero", common::AttributeValue::string("0"))
  ]
  
  let mut i = 0
  while i < edge_cases.length() {
    let (name, value) = edge_cases[i]
    
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™äº›è½¬æ¢åº”è¯¥æœ‰æ˜ç¡®çš„è§„åˆ™
    match value {
      common::IntValue(int_val) => {
        let as_bool = int_val != 0L
        assert_eq(as_bool == true || as_bool == false, true)
      }
      common::FloatValue(float_val) => {
        let as_bool = float_val != 0.0
        assert_eq(as_bool == true || as_bool == false, true)
      }
      common::StringValue(str_val) => {
        let as_bool = str_val == "true" || str_val == "1"
        assert_eq(as_bool == true || as_bool == false, true)
      }
      _ => {}
    }
    
    i = i + 1
  }
}

test "attribute_value_performance_and_optimization" {
  // æµ‹è¯•å±æ€§å€¼æ€§èƒ½å’Œä¼˜åŒ–
  
  // æµ‹è¯•å¤§é‡å±æ€§å€¼åˆ›å»º
  let mut attributes = []
  let mut i = 0
  
  // åˆ›å»º1000ä¸ªä¸åŒç±»å‹çš„å±æ€§å€¼
  while i < 250 {
    // å­—ç¬¦ä¸²å±æ€§
    attributes.push(("string." + i.to_string(), common::AttributeValue::string("value." + i.to_string())))
    
    // æ•´æ•°å±æ€§
    attributes.push(("int." + i.to_string(), common::AttributeValue::int(i.to_int64())))
    
    // æµ®ç‚¹å±æ€§
    attributes.push(("float." + i.to_string(), common::AttributeValue::float(i.to_double() + 0.5)))
    
    // å¸ƒå°”å±æ€§
    attributes.push(("bool." + i.to_string(), common::AttributeValue::bool(i % 2 == 0)))
    
    i = i + 1
  }
  
  assert_eq(attributes.length(), 1000)
  
  // æµ‹è¯•å±æ€§å€¼æŸ¥æ‰¾æ€§èƒ½
  let mut found_string_100 = false
  let mut found_int_150 = false
  let mut found_float_200 = false
  let mut found_bool_249 = false
  
  i = 0
  while i < attributes.length() {
    let (key, value) = attributes[i]
    
    if key == "string.100" {
      match value {
        common::StringValue(s) => {
          assert_eq(s, "value.100")
          found_string_100 = true
        }
        _ => {}
      }
    }
    
    if key == "int.150" {
      match value {
        common::IntValue(int_val) => {
          assert_eq(int_val, 150L)
          found_int_150 = true
        }
        _ => {}
      }
    }
    
    if key == "float.200" {
      match value {
        common::FloatValue(float_val) => {
          assert_eq(float_val > 200.0 && float_val < 201.0, true)
          found_float_200 = true
        }
        _ => {}
      }
    }
    
    if key == "bool.249" {
      match value {
        common::BoolValue(bool_val) => {
          assert_eq(bool_val, 249 % 2 == 0)
          found_bool_249 = true
        }
        _ => {}
      }
    }
    
    i = i + 1
  }
  
  assert_eq(found_string_100, true, "Should find string.100")
  assert_eq(found_int_150, true, "Should find int.150")
  assert_eq(found_float_200, true, "Should find float.200")
  assert_eq(found_bool_249, true, "Should find bool.249")
  
  // æµ‹è¯•å¤§å‹æ•°ç»„å±æ€§
  let large_string_array = []
  let large_int_array = []
  let large_float_array = []
  let large_bool_array = []
  
  i = 0
  while i < 1000 {
    large_string_array.push("item." + i.to_string())
    large_int_array.push(i.to_int64())
    large_float_array.push(i.to_double() + 0.1)
    large_bool_array.push(i % 2 == 0)
    i = i + 1
  }
  
  let large_string_attr = common::AttributeValue::array_string(large_string_array)
  let large_int_attr = common::AttributeValue::array_int(large_int_array)
  let large_float_attr = common::AttributeValue::array_float(large_float_array)
  let large_bool_attr = common::AttributeValue::array_bool(large_bool_array)
  
  // éªŒè¯å¤§å‹æ•°ç»„
  match large_string_attr {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1000)
      assert_eq(arr[0], "item.0")
      assert_eq(arr[999], "item.999")
    }
    _ => {}
  }
  
  match large_int_attr {
    common::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 1000)
      assert_eq(arr[0], 0L)
      assert_eq(arr[999], 999L)
    }
    _ => {}
  }
  
  match large_float_attr {
    common::ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 1000)
      assert_eq(arr[0], 0.1)
      assert_eq(arr[999], 999.1)
    }
    _ => {}
  }
  
  match large_bool_attr {
    common::ArrayBoolValue(arr) => {
      assert_eq(arr.length(), 1000)
      assert_eq(arr[0], true)  // 0 % 2 == 0
      assert_eq(arr[999], false)  // 999 % 2 == 1
    }
    _ => {}
  }
  
  // æµ‹è¯•å†…å­˜ä½¿ç”¨ä¼˜åŒ–ï¼ˆåœ¨çœŸå®å®ç°ä¸­ä¼šæœ‰å†…å­˜ä½¿ç”¨ç›‘æ§ï¼‰
  let total_attributes = attributes.length() + 4  // 1000 + 4ä¸ªå¤§å‹æ•°ç»„
  assert_eq(total_attributes, 1004)
}