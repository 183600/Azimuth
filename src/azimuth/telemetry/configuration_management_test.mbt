// é…ç½®ç®¡ç†å’ŒåŠ¨æ€æ›´æ–°æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿçš„é…ç½®ç®¡ç†å’ŒåŠ¨æ€æ›´æ–°èƒ½åŠ›

// å¯¼å…¥å¿…è¦çš„ç±»å‹
use azimuth.telemetry.api.common.{Resource, InstrumentationScope, AttributeValue, Attributes}
use azimuth.telemetry.api.context.{Context, create_key}
use azimuth.telemetry.api.logs.{LogRecord, SeverityNumber}
use azimuth.telemetry.api.trace.{Span, SpanContext, SpanKind, StatusCode, NoopTracer}
use azimuth.telemetry.api.metrics.{NoopMeterProvider}
use azimuth.telemetry.api.propagation.{W3CTraceContextPropagator, W3CBaggagePropagator, CompositePropagator, MapCarrier}
use azimuth.telemetry.api.context.{Baggage}

test "resource_configuration_management" {
  // æµ‹è¯•Resourceçš„é…ç½®ç®¡ç†
  
  // 1. åˆ›å»ºåŸºæœ¬èµ„æºé…ç½®
  let basic_resource = Resource::default("test-service")
  assert_eq(basic_resource.service_name, "test-service")
  assert_eq(basic_resource.service_version, None)
  assert_eq(basic_resource.telemetry_sdk_name, "azimuth")
  assert_eq(basic_resource.telemetry_sdk_version, "0.1.0")
  assert_eq(basic_resource.attributes.length(), 0)
  
  // 2. æµ‹è¯•èµ„æºé…ç½®çš„åŠ¨æ€æ›´æ–°
  let updated_resource = Resource::{
    service_name: "updated-service",
    service_version: Some("2.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: [
      ("service.namespace", AttributeValue::string("production")),
      ("service.instance.id", AttributeValue::string("instance-123")),
      ("deployment.environment", AttributeValue::string("prod"))
    ]
  }
  
  assert_eq(updated_resource.service_name, "updated-service")
  assert_eq(updated_resource.service_version, Some("2.0.0"))
  assert_eq(updated_resource.attributes.length(), 3)
  
  // 3. æµ‹è¯•èµ„æºé…ç½®çš„éªŒè¯
  let valid_resource = Resource::default("valid-service")
  assert_eq(valid_resource.service_name.length() > 0, true)
  
  // æµ‹è¯•ç©ºæœåŠ¡åç§°çš„å¤„ç†
  let empty_name_resource = Resource::default("")
  assert_eq(empty_name_resource.service_name, "")
  
  // 4. æµ‹è¯•èµ„æºé…ç½®çš„åˆå¹¶
  let base_attributes = [
    ("service.name", AttributeValue::string("base-service")),
    ("service.version", AttributeValue::string("1.0.0"))
  ]
  
  let additional_attributes = [
    ("service.namespace", AttributeValue::string("production")),
    ("service.instance.id", AttributeValue::string("instance-456"))
  ]
  
  // æ¨¡æ‹Ÿå±æ€§åˆå¹¶
  let merged_attributes = []
  let mut i = 0
  while i < base_attributes.length() {
    merged_attributes.push(base_attributes[i])
    i = i + 1
  }
  i = 0
  while i < additional_attributes.length() {
    merged_attributes.push(additional_attributes[i])
    i = i + 1
  }
  
  assert_eq(merged_attributes.length(), 4)
  
  // 5. æµ‹è¯•èµ„æºé…ç½®çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  let config_resource = Resource::{
    service_name: "config-service",
    service_version: Some("1.5.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: [
      ("config.source", AttributeValue::string("file")),
      ("config.version", AttributeValue::string("2023.12.01")),
      ("config.auto.reload", AttributeValue::bool(true))
    ]
  }
  
  // æ¨¡æ‹Ÿé…ç½®åºåˆ—åŒ–
  let serialized_config = config_resource.service_name + "|" +
    match config_resource.service_version {
      Some(version) => version
      None => ""
    } + "|" +
    "attributes_count:" + config_resource.attributes.length().to_string()
  
  assert_eq(serialized_config, "config-service|1.5.0|attributes_count:3")
}

test "instrumentation_scope_configuration" {
  // æµ‹è¯•InstrumentationScopeçš„é…ç½®ç®¡ç†
  
  // 1. åˆ›å»ºåŸºæœ¬instrumentation scopeé…ç½®
  let basic_scope = InstrumentationScope::{
    name: "basic-scope",
    version: Some("1.0.0"),
    schema_url: Some("https://example.com/schema")
  }
  
  assert_eq(basic_scope.name, "basic-scope")
  assert_eq(basic_scope.version, Some("1.0.0"))
  assert_eq(basic_scope.schema_url, Some("https://example.com/schema"))
  
  // 2. æµ‹è¯•instrumentation scopeé…ç½®çš„åŠ¨æ€æ›´æ–°
  let updated_scope = InstrumentationScope::{
    name: "updated-scope",
    version: Some("2.0.0"),
    schema_url: Some("https://updated.example.com/schema")
  }
  
  assert_eq(updated_scope.name, "updated-scope")
  assert_eq(updated_scope.version, Some("2.0.0"))
  assert_eq(updated_scope.schema_url, Some("https://updated.example.com/schema"))
  
  // 3. æµ‹è¯•instrumentation scopeé…ç½®çš„éªŒè¯
  let valid_scope = InstrumentationScope::{
    name: "valid-scope",
    version: Some("1.0.0"),
    schema_url: Some("https://example.com/valid-schema")
  }
  
  // éªŒè¯scopeåç§°ä¸ä¸ºç©º
  assert_eq(valid_scope.name.length() > 0, true)
  
  // æµ‹è¯•ç©ºåç§°çš„scope
  let empty_scope = InstrumentationScope::{
    name: "",
    version: None,
    schema_url: None
  }
  
  assert_eq(empty_scope.name, "")
  
  // 4. æµ‹è¯•instrumentation scopeé…ç½®çš„é»˜è®¤å€¼
  let default_scope = InstrumentationScope::{
    name: "default-scope",
    version: None,
    schema_url: None
  }
  
  assert_eq(default_scope.name, "default-scope")
  assert_eq(default_scope.version, None)
  assert_eq(default_scope.schema_url, None)
  
  // 5. æµ‹è¯•å¤šä¸ªinstrumentation scopeçš„é…ç½®ç®¡ç†
  let scopes = [
    InstrumentationScope::{
      name: "scope-1",
      version: Some("1.0.0"),
      schema_url: Some("https://example.com/schema-1")
    },
    InstrumentationScope::{
      name: "scope-2",
      version: Some("1.5.0"),
      schema_url: Some("https://example.com/schema-2")
    },
    InstrumentationScope::{
      name: "scope-3",
      version: Some("2.0.0"),
      schema_url: Some("https://example.com/schema-3")
    }
  ]
  
  assert_eq(scopes.length(), 3)
  assert_eq(scopes[0].name, "scope-1")
  assert_eq(scopes[1].version, Some("1.5.0"))
  assert_eq(scopes[2].schema_url, Some("https://example.com/schema-3"))
}

test "attribute_value_configuration" {
  // æµ‹è¯•AttributeValueçš„é…ç½®ç®¡ç†
  
  // 1. æµ‹è¯•åŸºæœ¬ç±»å‹çš„AttributeValueé…ç½®
  let string_attr = AttributeValue::string("configured-string")
  let int_attr = AttributeValue::int(42L)
  let float_attr = AttributeValue::float(3.14159)
  let bool_attr = AttributeValue::bool(true)
  
  // éªŒè¯é…ç½®å€¼
  match string_attr {
    StringValue(s) => assert_eq(s, "configured-string")
    _ => @test.fail("Test failed")
  }
  
  match int_attr {
    IntValue(i) => assert_eq(i, 42L)
    _ => @test.fail("Test failed")
  }
  
  match float_attr {
    FloatValue(f) => assert_eq(f, 3.14159)
    _ => @test.fail("Test failed")
  }
  
  match bool_attr {
    BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("Test failed")
  }
  
  // 2. æµ‹è¯•æ•°ç»„ç±»å‹çš„AttributeValueé…ç½®
  let string_array_attr = AttributeValue::array_string(["item1", "item2", "item3"])
  let int_array_attr = AttributeValue::array_int([1L, 2L, 3L, 4L])
  let float_array_attr = AttributeValue::array_float([1.1, 2.2, 3.3])
  let bool_array_attr = AttributeValue::array_bool([true, false, true])
  
  // éªŒè¯æ•°ç»„é…ç½®
  match string_array_attr {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], "item1")
      assert_eq(arr[2], "item3")
    }
    _ => @test.fail("Test failed")
  }
  
  match int_array_attr {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 4)
      assert_eq(arr[0], 1L)
      assert_eq(arr[3], 4L)
    }
    _ => @test.fail("Test failed")
  }
  
  // 3. æµ‹è¯•AttributeValueçš„åŠ¨æ€æ›´æ–°
  let mutable_attr = AttributeValue::string("initial-value")
  
  // æ¨¡æ‹ŸåŠ¨æ€æ›´æ–°
  let updated_attr = AttributeValue::string("updated-value")
  match updated_attr {
    StringValue(s) => assert_eq(s, "updated-value")
    _ => @test.fail("Test failed")
  }
  
  // 4. æµ‹è¯•AttributeValueçš„ç±»å‹è½¬æ¢é…ç½®
  let numeric_string = "123"
  let converted_int = AttributeValue::int(numeric_string.to_int64())
  match converted_int {
    IntValue(i) => assert_eq(i, 123L)
    _ => @test.fail("Test failed")
  }
  
  let float_string = "3.14"
  let converted_float = AttributeValue::float(float_string.to_double())
  match converted_float {
    FloatValue(f) => assert_eq(f, 3.14)
    _ => @test.fail("Test failed")
  }
  
  // 5. æµ‹è¯•AttributeValueçš„é…ç½®éªŒè¯
  let empty_string_attr = AttributeValue::string("")
  let zero_int_attr = AttributeValue::int(0L)
  let negative_int_attr = AttributeValue::int(-1L)
  let zero_float_attr = AttributeValue::float(0.0)
  let false_bool_attr = AttributeValue::bool(false)
  
  // éªŒè¯ç‰¹æ®Šå€¼é…ç½®
  match empty_string_attr {
    StringValue(s) => assert_eq(s, "")
    _ => @test.fail("Test failed")
  }
  
  match zero_int_attr {
    IntValue(i) => assert_eq(i, 0L)
    _ => @test.fail("Test failed")
  }
  
  match negative_int_attr {
    IntValue(i) => assert_eq(i, -1L)
    _ => @test.fail("Test failed")
  }
}

test "context_configuration_management" {
  // æµ‹è¯•Contextçš„é…ç½®ç®¡ç†
  
  // 1. åˆ›å»ºåŸºæœ¬ä¸Šä¸‹æ–‡é…ç½®
  let base_ctx = Context::empty()
  assert_eq(base_ctx.values.length(), 0)
  
  // 2. æµ‹è¯•ä¸Šä¸‹æ–‡é…ç½®çš„åŠ¨æ€æ›´æ–°
  let config_key = create_key("config.version")
  let updated_ctx = base_ctx
    .with_value(config_key, "2023.12.01")
    .with_value(create_key("config.source"), "file")
    .with_value(create_key("config.auto.reload"), "true")
  
  assert_eq(updated_ctx.values.length(), 3)
  
  // éªŒè¯é…ç½®å€¼
  match updated_ctx.get(config_key) {
    Some(version) => assert_eq(version, "2023.12.01")
    None => @test.fail("Test failed")
  }
  
  match updated_ctx.get(create_key("config.source")) {
    Some(source) => assert_eq(source, "file")
    None => @test.fail("Test failed")
  }
  
  // 3. æµ‹è¯•ä¸Šä¸‹æ–‡é…ç½®çš„è¦†ç›–
  let override_key = create_key("config.version")
  let override_ctx = updated_ctx.with_value(override_key, "2023.12.02")
  
  match override_ctx.get(override_key) {
    Some(version) => assert_eq(version, "2023.12.02")
    None => @test.fail("Test failed")
  }
  
  // 4. æµ‹è¯•ä¸Šä¸‹æ–‡é…ç½®çš„æ‰¹é‡æ›´æ–°
  let batch_keys = [
    create_key("batch.key1"),
    create_key("batch.key2"),
    create_key("batch.key3")
  ]
  
  let batch_values = ["value1", "value2", "value3"]
  
  let mut batch_ctx = base_ctx
  let mut i = 0
  while i < batch_keys.length() {
    batch_ctx = batch_ctx.with_value(batch_keys[i], batch_values[i])
    i = i + 1
  }
  
  assert_eq(batch_ctx.values.length(), 3)
  
  // éªŒè¯æ‰¹é‡é…ç½®
  i = 0
  while i < batch_keys.length() {
    match batch_ctx.get(batch_keys[i]) {
      Some(value) => assert_eq(value, batch_values[i])
      None => @test.fail("Test failed")
    }
    i = i + 1
  }
  
  // 5. æµ‹è¯•ä¸Šä¸‹æ–‡é…ç½®çš„æŒä¹…åŒ–
  let persistent_ctx = base_ctx
    .with_value(create_key("persistent.key1"), "persistent.value1")
    .with_value(create_key("persistent.key2"), "persistent.value2")
  
  // æ¨¡æ‹Ÿé…ç½®æŒä¹…åŒ–
  let serialized_config = "context:"
  let mut i = 0
  while i < persistent_ctx.values.length() {
    let (key, value) = persistent_ctx.values[i]
    serialized_config = serialized_config + key + "=" + value
    if i < persistent_ctx.values.length() - 1 {
      serialized_config = serialized_config + ","
    }
    i = i + 1
  }
  
  assert_eq(serialized_config.starts_with("context:"), true)
  assert_eq(serialized_config.contains("persistent.key1=persistent.value1"), true)
  assert_eq(serialized_config.contains("persistent.key2=persistent.value2"), true)
}

test "baggage_configuration_management" {
  // æµ‹è¯•Baggageçš„é…ç½®ç®¡ç†
  
  // 1. åˆ›å»ºåŸºæœ¬baggageé…ç½®
  let base_baggage = Baggage::empty()
  assert_eq(base_baggage.entries.length(), 0)
  
  // 2. æµ‹è¯•baggageé…ç½®çš„åŠ¨æ€æ›´æ–°
  let configured_baggage = base_baggage
    .with_entry("config.version", "2023.12.01")
    .with_entry("config.source", "environment")
    .with_entry("config.auto.reload", "false")
  
  assert_eq(configured_baggage.entries.length(), 3)
  
  // éªŒè¯é…ç½®å€¼
  match configured_baggage.get("config.version") {
    Some(version) => assert_eq(version, "2023.12.01")
    None => @test.fail("Test failed")
  }
  
  match configured_baggage.get("config.source") {
    Some(source) => assert_eq(source, "environment")
    None => @test.fail("Test failed")
  }
  
  // 3. æµ‹è¯•baggageé…ç½®çš„è¦†ç›–
  let override_baggage = configured_baggage.with_entry("config.auto.reload", "true")
  
  match override_baggage.get("config.auto.reload") {
    Some(auto_reload) => assert_eq(auto_reload, "true")
    None => @test.fail("Test failed")
  }
  
  // 4. æµ‹è¯•baggageé…ç½®çš„æ‰¹é‡æ“ä½œ
  let batch_entries = [
    ("batch.entry1", "batch.value1"),
    ("batch.entry2", "batch.value2"),
    ("batch.entry3", "batch.value3")
  ]
  
  let mut batch_baggage = base_baggage
  let mut i = 0
  while i < batch_entries.length() {
    let (key, value) = batch_entries[i]
    batch_baggage = batch_baggage.with_entry(key, value)
    i = i + 1
  }
  
  assert_eq(batch_baggage.entries.length(), 3)
  
  // éªŒè¯æ‰¹é‡é…ç½®
  i = 0
  while i < batch_entries.length() {
    let (key, expected_value) = batch_entries[i]
    match batch_baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed")
    }
    i = i + 1
  }
  
  // 5. æµ‹è¯•baggageé…ç½®çš„åºåˆ—åŒ–ï¼ˆW3Cæ ¼å¼ï¼‰
  let w3c_baggage = base_baggage
    .with_entry("config.version", "2023.12.01")
    .with_entry("config.source", "file")
    .with_entry("config.auto.reload", "true")
  
  // æ¨¡æ‹ŸW3C baggageåºåˆ—åŒ–
  let w3c_serialized = "config.version=2023.12.01,config.source=file,config.auto.reload=true"
  
  // éªŒè¯W3Cæ ¼å¼
  assert_eq(w3c_serialized.contains("config.version=2023.12.01"), true)
  assert_eq(w3c_serialized.contains("config.source=file"), true)
  assert_eq(w3c_serialized.contains("config.auto.reload=true"), true)
  
  // 6. æµ‹è¯•baggageé…ç½®çš„è§£æ
  let w3c_config = "config.version=2023.12.01,config.source=file,config.auto.reload=true"
  let config_entries = w3c_config.split(",")
  
  assert_eq(config_entries.length(), 3)
  
  // éªŒè¯è§£æç»“æœ
  let mut found_version = false
  let mut found_source = false
  let mut found_auto_reload = false
  
  let mut i = 0
  while i < config_entries.length() {
    let entry = config_entries[i]
    match entry {
      "config.version=2023.12.01" => found_version = true
      "config.source=file" => found_source = true
      "config.auto.reload=true" => found_auto_reload = true
      _ => ()
    }
    i = i + 1
  }
  
  assert_eq(found_version, true)
  assert_eq(found_source, true)
  assert_eq(found_auto_reload, true)
}

test "dynamic_configuration_updates" {
  // æµ‹è¯•åŠ¨æ€é…ç½®æ›´æ–°
  
  // 1. æ¨¡æ‹Ÿé…ç½®çƒ­é‡è½½åœºæ™¯
  let initial_resource = Resource::default("initial-service")
  
  // æ¨¡æ‹Ÿé…ç½®æ›´æ–°
  let updated_resource = Resource::{
    service_name: "updated-service",
    service_version: Some("2.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: [
      ("config.reload.timestamp", AttributeValue::string("2023-12-01T10:00:00Z")),
      ("config.reload.source", AttributeValue::string("file-watcher")),
      ("config.reload.version", AttributeValue::string("v2.0.0"))
    ]
  }
  
  // éªŒè¯é…ç½®æ›´æ–°
  assert_eq(updated_resource.service_name, "updated-service")
  assert_eq(updated_resource.service_version, Some("2.0.0"))
  assert_eq(updated_resource.attributes.length(), 3)
  
  // 2. æµ‹è¯•é…ç½®æ›´æ–°çš„ä¼ æ’­
  let ctx = Context::empty()
  let config_key = create_key("config.version")
  
  let initial_ctx = ctx.with_value(config_key, "1.0.0")
  match initial_ctx.get(config_key) {
    Some(version) => assert_eq(version, "1.0.0")
    None => @test.fail("Test failed")
  }
  
  // æ¨¡æ‹Ÿé…ç½®æ›´æ–°
  let updated_ctx = initial_ctx.with_value(config_key, "2.0.0")
  match updated_ctx.get(config_key) {
    Some(version) => assert_eq(version, "2.0.0")
    None => @test.fail("Test failed")
  }
  
  // 3. æµ‹è¯•é…ç½®æ›´æ–°çš„éªŒè¯
  let valid_configs = [
    ("1.0.0", "stable"),
    ("1.1.0", "feature"),
    ("2.0.0", "major")
  ]
  
  let mut i = 0
  while i < valid_configs.length() {
    let (version, config_type) = valid_configs[i]
    
    // éªŒè¯ç‰ˆæœ¬æ ¼å¼
    assert_eq(version.contains("."), true)
    
    // éªŒè¯é…ç½®ç±»å‹
    assert_eq(config_type.length() > 0, true)
    
    i = i + 1
  }
  
  // 4. æµ‹è¯•é…ç½®æ›´æ–°çš„å›æ»š
  let rollback_ctx = updated_ctx.with_value(config_key, "1.0.0")
  match rollback_ctx.get(config_key) {
    Some(version) => assert_eq(version, "1.0.0")
    None => @test.fail("Test failed")
  }
  
  // 5. æµ‹è¯•é…ç½®æ›´æ–°çš„æ‰¹é‡æ“ä½œ
  let batch_updates = [
    ("config.batch1", "value1"),
    ("config.batch2", "value2"),
    ("config.batch3", "value3")
  ]
  
  let mut batch_ctx = ctx
  let mut i = 0
  while i < batch_updates.length() {
    let (key, value) = batch_updates[i]
    batch_ctx = batch_ctx.with_value(create_key(key), value)
    i = i + 1
  }
  
  // éªŒè¯æ‰¹é‡æ›´æ–°
  i = 0
  while i < batch_updates.length() {
    let (key, expected_value) = batch_updates[i]
    match batch_ctx.get(create_key(key)) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed")
    }
    i = i + 1
  }
  
  // 6. æµ‹è¯•é…ç½®æ›´æ–°çš„ä¼˜å…ˆçº§
  let priority_ctx = ctx
    .with_value(create_key("config.priority"), "low")
    .with_value(create_key("config.priority"), "medium")
    .with_value(create_key("config.priority"), "high")
  
  match priority_ctx.get(create_key("config.priority")) {
    Some(priority) => assert_eq(priority, "high")  // æœ€åè®¾ç½®çš„å€¼ç”Ÿæ•ˆ
    None => @test.fail("Test failed")
  }
}

test "configuration_validation" {
  // æµ‹è¯•é…ç½®éªŒè¯
  
  // 1. æµ‹è¯•Resourceé…ç½®éªŒè¯
  let valid_resource = Resource::default("valid-service")
  assert_eq(valid_resource.service_name.length() > 0, true)
  
  let invalid_resource = Resource::default("")
  assert_eq(invalid_resource.service_name, "")
  
  // 2. æµ‹è¯•InstrumentationScopeé…ç½®éªŒè¯
  let valid_scope = InstrumentationScope::{
    name: "valid-scope",
    version: Some("1.0.0"),
    schema_url: Some("https://example.com/schema")
  }
  
  assert_eq(valid_scope.name.length() > 0, true)
  
  let invalid_scope = InstrumentationScope::{
    name: "",
    version: None,
    schema_url: None
  }
  
  assert_eq(invalid_scope.name, "")
  
  // 3. æµ‹è¯•AttributeValueé…ç½®éªŒè¯
  let valid_string_attr = AttributeValue::string("valid-value")
  let valid_int_attr = AttributeValue::int(42L)
  let valid_float_attr = AttributeValue::float(3.14)
  let valid_bool_attr = AttributeValue::bool(true)
  
  // éªŒè¯æœ‰æ•ˆå€¼
  match valid_string_attr {
    StringValue(s) => assert_eq(s, "valid-value")
    _ => @test.fail("Test failed")
  }
  
  match valid_int_attr {
    IntValue(i) => assert_eq(i, 42L)
    _ => @test.fail("Test failed")
  }
  
  // 4. æµ‹è¯•è¾¹ç•Œå€¼éªŒè¯
  let max_int_attr = AttributeValue::int(9223372036854775807L)
  let min_int_attr = AttributeValue::int(-9223372036854775808L)
  let zero_float_attr = AttributeValue::float(0.0)
  let infinity_float_attr = AttributeValue::float(1.0/0.0)
  
  match max_int_attr {
    IntValue(i) => assert_eq(i, 9223372036854775807L)
    _ => @test.fail("Test failed")
  }
  
  match min_int_attr {
    IntValue(i) => assert_eq(i, -9223372036854775808L)
    _ => @test.fail("Test failed")
  }
  
  // 5. æµ‹è¯•æ•°ç»„é…ç½®éªŒè¯
  let empty_string_array = AttributeValue::array_string([])
  let empty_int_array = AttributeValue::array_int([])
  let empty_float_array = AttributeValue::array_float([])
  let empty_bool_array = AttributeValue::array_bool([])
  
  match empty_string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  match empty_int_array {
    ArrayIntValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  // 6. æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é…ç½®éªŒè¯
  let special_chars_attr = AttributeValue::string("!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let unicode_attr = AttributeValue::string("Unicodeæµ‹è¯•ğŸš€")
  let empty_string_attr = AttributeValue::string("")
  
  match special_chars_attr {
    StringValue(s) => assert_eq(s, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
    _ => @test.fail("Test failed")
  }
  
  match unicode_attr {
    StringValue(s) => assert_eq(s, "Unicodeæµ‹è¯•ğŸš€")
    _ => @test.fail("Test failed")
  }
  
  match empty_string_attr {
    StringValue(s) => assert_eq(s, "")
    _ => @test.fail("Test failed")
  }
}