// è¾¹ç•Œæ¡ä»¶æµ‹è¯• - æµ‹è¯•æç«¯è¾“å…¥æƒ…å†µä¸‹çš„è¡Œä¸º

test "boundary conditions: empty and null string attributes" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦ä¸²å€¼
  let empty_string = AttributeValue::string("")
  let whitespace_string = AttributeValue::string("   ")
  let special_chars_string = AttributeValue::string("!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  // éªŒè¯ç©ºå­—ç¬¦ä¸²
  assert match (empty_string) {
    StringValue(s) => s == ""
    _ => false
  }
  
  // éªŒè¯ç©ºç™½å­—ç¬¦ä¸²
  assert match (whitespace_string) {
    StringValue(s) => s == "   "
    _ => false
  }
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²
  assert match (special_chars_string) {
    StringValue(s) => s == "!@#$%^&*()_+-=[]{}|;':\",./<>?"
    _ => false
  }
  
  // åˆ›å»ºåŒ…å«è¾¹ç•Œæ¡ä»¶çš„Resource
  let resource = Resource::{
    service_name: "",
    service_version: Some(""),
    telemetry_sdk_name: "   ",
    telemetry_sdk_version: "!@#$%",
    attributes: [
      ("empty", empty_string),
      ("whitespace", whitespace_string),
      ("special", special_chars_string)
    ]
  }
  
  // éªŒè¯Resourceåˆ›å»ºæˆåŠŸ
  assert resource.service_name == ""
  assert match (resource.service_version) {
    Some(v) => v == ""
    None => false
  }
  assert resource.telemetry_sdk_name == "   "
  assert resource.telemetry_sdk_version == "!@#$%"
}

test "boundary conditions: extreme numeric values" {
  // æµ‹è¯•æå€¼æ•°å€¼
  let max_int = AttributeValue::int(9223372036854775807L)  // Int64æœ€å¤§å€¼
  let min_int = AttributeValue::int(-9223372036854775808L)  // Int64æœ€å°å€¼
  let zero_int = AttributeValue::int(0L)
  
  let max_float = AttributeValue::float(1.7976931348623157e+308)  // Doubleæœ€å¤§å€¼
  let min_float = AttributeValue::float(-1.7976931348623157e+308)  // Doubleæœ€å°å€¼
  let zero_float = AttributeValue::float(0.0)
  let inf_float = AttributeValue::float(1.0/0.0)  // æ— ç©·å¤§
  let neg_inf_float = AttributeValue::float(-1.0/0.0)  // è´Ÿæ— ç©·å¤§
  let nan_float = AttributeValue::float(0.0/0.0)  // NaN
  
  // éªŒè¯æå€¼æ•´æ•°
  assert match (max_int) {
    IntValue(i) => i == 9223372036854775807L
    _ => false
  }
  
  assert match (min_int) {
    IntValue(i) => i == -9223372036854775808L
    _ => false
  }
  
  assert match (zero_int) {
    IntValue(i) => i == 0L
    _ => false
  }
  
  // éªŒè¯æå€¼æµ®ç‚¹æ•°
  assert match (max_float) {
    FloatValue(f) => f == 1.7976931348623157e+308
    _ => false
  }
  
  assert match (min_float) {
    FloatValue(f) => f == -1.7976931348623157e+308
    _ => false
  }
  
  assert match (zero_float) {
    FloatValue(f) => f == 0.0
    _ => false
  }
}

test "boundary conditions: empty and large arrays" {
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = AttributeValue::array_string([])
  let empty_int_array = AttributeValue::array_int([])
  let empty_float_array = AttributeValue::array_float([])
  let empty_bool_array = AttributeValue::array_bool([])
  
  // éªŒè¯ç©ºæ•°ç»„
  assert match (empty_string_array) {
    ArrayStringValue(arr) => arr.length == 0
    _ => false
  }
  
  assert match (empty_int_array) {
    ArrayIntValue(arr) => arr.length == 0
    _ => false
  }
  
  assert match (empty_float_array) {
    ArrayFloatValue(arr) => arr.length == 0
    _ => false
  }
  
  assert match (empty_bool_array) {
    ArrayBoolValue(arr) => arr.length == 0
    _ => false
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_string_array = AttributeValue::array_string(["single"])
  let single_int_array = AttributeValue::array_int([1L])
  let single_float_array = AttributeValue::array_float([1.0])
  let single_bool_array = AttributeValue::array_bool([true])
  
  // éªŒè¯å•å…ƒç´ æ•°ç»„
  assert match (single_string_array) {
    ArrayStringValue(arr) => arr.length == 1 && arr[0] == "single"
    _ => false
  }
  
  assert match (single_int_array) {
    ArrayIntValue(arr) => arr.length == 1 && arr[0] == 1L
    _ => false
  }
  
  assert match (single_float_array) {
    ArrayFloatValue(arr) => arr.length == 1 && arr[0] == 1.0
    _ => false
  }
  
  assert match (single_bool_array) {
    ArrayBoolValue(arr) => arr.length == 1 && arr[0] == true
    _ => false
  }
}

test "boundary conditions: context with special keys" {
  // æµ‹è¯•ç‰¹æ®Šé”®å
  let empty_key = create_key("")
  let whitespace_key = create_key("   ")
  let long_key = create_key("this_is_a_very_long_key_name_that_exceeds_normal_expectations_and_tests_boundary_conditions")
  let special_chars_key = create_key("!@#$%^&*()")
  let unicode_key = create_key("æµ‹è¯•é”®å_ğŸš€_emoji")
  
  let context = Context::empty()
  
  // ä½¿ç”¨ç‰¹æ®Šé”®åæ·»åŠ å€¼
  let context1 = context.with_value(empty_key, "empty_key_value")
  let context2 = context1.with_value(whitespace_key, "whitespace_key_value")
  let context3 = context2.with_value(long_key, "long_key_value")
  let context4 = context3.with_value(special_chars_key, "special_chars_value")
  let context5 = context4.with_value(unicode_key, "unicode_value")
  
  // éªŒè¯ç‰¹æ®Šé”®åçš„å€¼å¯ä»¥æ­£ç¡®è·å–
  assert match (context5.get(empty_key)) {
    Some(value) => value == "empty_key_value"
    None => false
  }
  
  assert match (context5.get(whitespace_key)) {
    Some(value) => value == "whitespace_key_value"
    None => false
  }
  
  assert match (context5.get(long_key)) {
    Some(value) => value == "long_key_value"
    None => false
  }
  
  assert match (context5.get(special_chars_key)) {
    Some(value) => value == "special_chars_value"
    None => false
  }
  
  assert match (context5.get(unicode_key)) {
    Some(value) => value == "unicode_value"
    None => false
  }
}

test "boundary conditions: baggage with special entries" {
  // æµ‹è¯•ç‰¹æ®Šbaggageæ¡ç›®
  let baggage = Baggage::empty()
  
  // æ·»åŠ ç‰¹æ®Šæ¡ç›®
  let baggage1 = baggage.with_entry("", "empty_key_value")
  let baggage2 = baggage1.with_entry("   ", "whitespace_key_value")
  let baggage3 = baggage2.with_entry("special!@#$%", "special_key_value")
  let baggage4 = baggage3.with_entry("æµ‹è¯•", "unicode_value")
  let baggage5 = baggage4.with_entry("empty_value", "")
  
  // éªŒè¯ç‰¹æ®Šæ¡ç›®çš„å€¼å¯ä»¥æ­£ç¡®è·å–
  assert match (baggage5.get("")) {
    Some(value) => value == "empty_key_value"
    None => false
  }
  
  assert match (baggage5.get("   ")) {
    Some(value) => value == "whitespace_key_value"
    None => false
  }
  
  assert match (baggage5.get("special!@#$%")) {
    Some(value) => value == "special_key_value"
    None => false
  }
  
  assert match (baggage5.get("æµ‹è¯•")) {
    Some(value) => value == "unicode_value"
    None => false
  }
  
  assert match (baggage5.get("empty_value")) {
    Some(value) => value == ""
    None => false
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®è¿”å›None
  assert match (baggage5.get("nonexistent_key")) {
    Some(_) => false
    None => true
  }
}

test "boundary conditions: instrumentation scope edge cases" {
  // æµ‹è¯•æç«¯çš„InstrumentationScopeé…ç½®
  let empty_scope = InstrumentationScope::{
    name: "",
    version: None,
    schema_url: None
  }
  
  let long_scope = InstrumentationScope::{
    name: "this_is_a_very_long_instrumentation_scope_name_that_tests_boundary_conditions",
    version: Some("this_is_a_very_long_version_string_that_tests_boundary_conditions_too"),
    schema_url: Some("this_is_a_very_long_schema_url_that_tests_boundary_conditions_as_well_and_should_be_handled_properly")
  }
  
  let special_scope = InstrumentationScope::{
    name: "!@#$%^&*()_+-=[]{}|;':\",./<>?",
    version: Some("!@#$%^&*()"),
    schema_url: Some("https://example.com/!@#$%^&*()")
  }
  
  let unicode_scope = InstrumentationScope::{
    name: "æµ‹è¯•èŒƒå›´_ğŸš€",
    version: Some("ç‰ˆæœ¬1.0_æµ‹è¯•"),
    schema_url: Some("https://æµ‹è¯•.example.com/æ¨¡å¼")
  }
  
  // éªŒè¯å„ç§æç«¯æƒ…å†µ
  assert empty_scope.name == ""
  assert empty_scope.version == None
  assert empty_scope.schema_url == None
  
  assert long_scope.name.length > 50
  assert match (long_scope.version) {
    Some(v) => v.length > 50
    None => false
  }
  assert match (long_scope.schema_url) {
    Some(url) => url.length > 50
    None => false
  }
  
  assert special_scope.name == "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  assert match (special_scope.version) {
    Some(v) => v == "!@#$%^&*()"
    None => false
  }
  assert match (special_scope.schema_url) {
    Some(url) => url == "https://example.com/!@#$%^&*()"
    None => false
  }
  
  assert unicode_scope.name == "æµ‹è¯•èŒƒå›´_ğŸš€"
  assert match (unicode_scope.version) {
    Some(v) => v == "ç‰ˆæœ¬1.0_æµ‹è¯•"
    None => false
  }
  assert match (unicode_scope.schema_url) {
    Some(url) => url == "https://æµ‹è¯•.example.com/æ¨¡å¼"
    None => false
  }
}

test "boundary conditions: metrics with extreme values" {
  // æµ‹è¯•æŒ‡æ ‡çš„æå€¼
  let meter_provider = NoopMeterProvider::{}
  let meter = meter_provider.get_meter("boundary_test_meter", None, None)
  
  let counter = meter.create_counter("boundary_counter", None, None)
  let histogram = meter.create_histogram("boundary_histogram", None, None)
  let up_down_counter = meter.create_up_down_counter("boundary_up_down", None, None)
  let gauge = meter.create_gauge("boundary_gauge", None, None)
  
  // æµ‹è¯•æå€¼
  counter.add(9223372036854775807L, None)  // Int64æœ€å¤§å€¼
  counter.add(-9223372036854775808L, None)  // Int64æœ€å°å€¼
  counter.add(0L, None)  // é›¶å€¼
  
  histogram.record(1.7976931348623157e+308, None)  // Doubleæœ€å¤§å€¼
  histogram.record(-1.7976931348623157e+308, None)  // Doubleæœ€å°å€¼
  histogram.record(0.0, None)  // é›¶å€¼
  histogram.record(1.0/0.0, None)  // æ— ç©·å¤§
  histogram.record(-1.0/0.0, None)  // è´Ÿæ— ç©·å¤§
  histogram.record(0.0/0.0, None)  // NaN
  
  up_down_counter.add(9223372036854775807L, None)  // Int64æœ€å¤§å€¼
  up_down_counter.add(-9223372036854775808L, None)  // Int64æœ€å°å€¼
  
  gauge.record(1.7976931348623157e+308, None)  // Doubleæœ€å¤§å€¼
  gauge.record(-1.7976931348623157e+308, None)  // Doubleæœ€å°å€¼
  
  // æµ‹è¯•å¸¦å±æ€§çš„æå€¼
  let extreme_attributes = [
    ("", AttributeValue::string("empty_key")),
    ("   ", AttributeValue::string("whitespace_key")),
    ("!@#$%", AttributeValue::string("special_key")),
    ("æµ‹è¯•", AttributeValue::string("unicode_key")),
    ("max_int", AttributeValue::int(9223372036854775807L)),
    ("max_float", AttributeValue::float(1.7976931348623157e+308)),
    ("empty_array", AttributeValue::array_string([])),
    ("single_element", AttributeValue::array_string(["single"]))
  ]
  
  counter.add(1L, Some(extreme_attributes))
  histogram.record(100.0, Some(extreme_attributes))
  up_down_counter.add(-1L, Some(extreme_attributes))
  gauge.record(50.0, Some(extreme_attributes))
}