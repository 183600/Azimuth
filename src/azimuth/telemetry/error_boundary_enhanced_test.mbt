test "Error handling and boundary conditions comprehensive test" {
  // æµ‹è¯•Commonæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  let empty_string_attr = common::AttributeValue::string("")
  match empty_string_attr {
    common::StringValue(s) => assert_eq(s, "")
    _ => @test.fail("Expected empty string value")
  }
  
  let special_chars_attr = common::AttributeValue::string("Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?")
  match special_chars_attr {
    common::StringValue(s) => assert_eq(s, "Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?")
    _ => @test.fail("Expected special chars string value")
  }
  
  let unicode_attr = common::AttributeValue::string("Unicode: ä¸­æ–‡ ğŸš€ Ã±Ã¡Ã©Ã­Ã³Ãº")
  match unicode_attr {
    common::StringValue(s) => assert_eq(s, "Unicode: ä¸­æ–‡ ğŸš€ Ã±Ã¡Ã©Ã­Ã³Ãº")
    _ => @test.fail("Expected unicode string value")
  }
  
  // æµ‹è¯•æå€¼
  let max_int_attr = common::AttributeValue::int(9223372036854775807L)  // Int64æœ€å¤§å€¼
  let min_int_attr = common::AttributeValue::int(-9223372036854775808L) // Int64æœ€å°å€¼
  let zero_int_attr = common::AttributeValue::int(0L)
  
  match max_int_attr {
    common::IntValue(i) => assert_eq(i, 9223372036854775807L)
    _ => @test.fail("Expected max int value")
  }
  
  match min_int_attr {
    common::IntValue(i) => assert_eq(i, -9223372036854775808L)
    _ => @test.fail("Expected min int value")
  }
  
  match zero_int_attr {
    common::IntValue(i) => assert_eq(i, 0L)
    _ => @test.fail("Expected zero int value")
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œ
  let max_float_attr = common::AttributeValue::float(1.7976931348623157e+308)  // Doubleæœ€å¤§å€¼
  let min_float_attr = common::AttributeValue::float(-1.7976931348623157e+308) // Doubleæœ€å°å€¼
  let inf_float_attr = common::AttributeValue::float(1.0/0.0)  // æ— ç©·å¤§
  let neg_inf_float_attr = common::AttributeValue::float(-1.0/0.0)  // è´Ÿæ— ç©·å¤§
  let nan_float_attr = common::AttributeValue::float(0.0/0.0)  // NaN
  let zero_float_attr = common::AttributeValue::float(0.0)
  
  match max_float_attr {
    common::FloatValue(f) => assert_eq(f, 1.7976931348623157e+308)
    _ => @test.fail("Expected max float value")
  }
  
  match min_float_attr {
    common::FloatValue(f) => assert_eq(f, -1.7976931348623157e+308)
    _ => @test.fail("Expected min float value")
  }
  
  match zero_float_attr {
    common::FloatValue(f) => assert_eq(f, 0.0)
    _ => @test.fail("Expected zero float value")
  }
  
  // æµ‹è¯•å¸ƒå°”å€¼
  let true_attr = common::AttributeValue::bool(true)
  let false_attr = common::AttributeValue::bool(false)
  
  match true_attr {
    common::BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("Expected true value")
  }
  
  match false_attr {
    common::BoolValue(b) => assert_eq(b, false)
    _ => @test.fail("Expected false value")
  }
  
  // æµ‹è¯•æ•°ç»„è¾¹ç•Œæ¡ä»¶
  let empty_string_array = common::AttributeValue::array_string([])
  let empty_int_array = common::AttributeValue::array_int([])
  let empty_float_array = common::AttributeValue::array_float([])
  let empty_bool_array = common::AttributeValue::array_bool([])
  
  match empty_string_array {
    common::ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty string array")
  }
  
  match empty_int_array {
    common::ArrayIntValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty int array")
  }
  
  match empty_float_array {
    common::ArrayFloatValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty float array")
  }
  
  match empty_bool_array {
    common::ArrayBoolValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty bool array")
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_string_array = common::AttributeValue::array_string(["single"])
  let single_int_array = common::AttributeValue::array_int([42L])
  let single_float_array = common::AttributeValue::array_float([3.14])
  let single_bool_array = common::AttributeValue::array_bool([true])
  
  match single_string_array {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], "single")
    }
    _ => @test.fail("Expected single string array")
  }
  
  // æµ‹è¯•å¤§æ•°ç»„
  let mut large_string_list = []
  for i = 0; i < 1000; i = i + 1 {
    large_string_list = large_string_list + ["item_" + i.to_string()]
  }
  let large_string_array = common::AttributeValue::array_string(large_string_list)
  
  match large_string_array {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1000)
      assert_eq(arr[0], "item_0")
      assert_eq(arr[999], "item_999")
    }
    _ => @test.fail("Expected large string array")
  }
  
  // æµ‹è¯•Resourceè¾¹ç•Œæ¡ä»¶
  let empty_resource = common::Resource::default("")
  assert_eq(empty_resource.service_name, "")
  assert_eq(empty_resource.attributes.length(), 0)
  
  let very_long_name_resource = common::Resource::default(
    "this-is-a-very-long-service-name-that-exceeds-normal-lengths-and-tests-boundary-conditions-for-resource-creation-with-extremely-long-names"
  )
  assert_eq(very_long_name_resource.service_name.length(), 147)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„Resource
  let mut special_chars_resource = common::Resource::default("service-with-special-chars")
  special_chars_resource.attributes = [
    ("unicode", common::AttributeValue::string("æµ‹è¯•æœåŠ¡")),
    ("emoji", common::AttributeValue::string("ğŸš€ğŸ”¥ğŸ’¯")),
    ("quotes", common::AttributeValue::string("String with 'single' and \"double\" quotes")),
    ("newlines", common::AttributeValue::string("Line 1\nLine 2\nLine 3")),
    ("tabs", common::AttributeValue::string("Col1\tCol2\tCol3"))
  ]
  
  // æµ‹è¯•InstrumentationScopeè¾¹ç•Œæ¡ä»¶
  let empty_scope = common::InstrumentationScope{
    name: "",
    version: None,
    schema_url: None
  }
  assert_eq(empty_scope.name, "")
  
  let long_scope = common::InstrumentationScope{
    name: "this-is-a-very-long-instrumentation-scope-name-that-tests-boundary-conditions",
    version: Some("version-with-many-characters-and-special-symbols-123!@#$%^&*()"),
    schema_url: Some("https://very-long-url-with-many-segments.example.com/very/deep/nested/path/to/schema/with/version/1.0.0")
  }
  assert_eq(long_scope.name.length(), 81)
  
  // æµ‹è¯•Logsæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡çº§åˆ«
  let trace_log = logs::LogRecord::builder()
    .severity(logs::Trace)
    .body("Trace message")
    .build()
  assert_eq(trace_log.severity_number, logs::Trace)
  
  let debug_log = logs::LogRecord::builder()
    .severity(logs::Debug)
    .body("Debug message")
    .build()
  assert_eq(debug_log.severity_number, logs::Debug)
  
  let info_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("Info message")
    .build()
  assert_eq(info_log.severity_number, logs::Info)
  
  let warn_log = logs::LogRecord::builder()
    .severity(logs::Warn)
    .body("Warning message")
    .build()
  assert_eq(warn_log.severity_number, logs::Warn)
  
  let error_log = logs::LogRecord::builder()
    .severity(logs::Error)
    .body("Error message")
    .build()
  assert_eq(error_log.severity_number, logs::Error)
  
  let fatal_log = logs::LogRecord::builder()
    .severity(logs::Fatal)
    .body("Fatal message")
    .build()
  assert_eq(fatal_log.severity_number, logs::Fatal)
  
  // æµ‹è¯•ç©ºå’Œæå€¼æ—¥å¿—
  let empty_log = logs::LogRecord::builder().build()
  assert_eq(empty_log.timestamp_unix_nanos, 0L)
  assert_eq(empty_log.severity_number, logs::Info)  // é»˜è®¤å€¼
  assert_eq(empty_log.body, None)
  assert_eq(empty_log.attributes.length(), 0)
  
  let max_time_log = logs::LogRecord::builder()
    .timestamp(9223372036854775807L)  // Int64æœ€å¤§å€¼
    .build()
  assert_eq(max_time_log.timestamp_unix_nanos, 9223372036854775807L)
  
  let min_time_log = logs::LogRecord::builder()
    .timestamp(-9223372036854775808L)  // Int64æœ€å°å€¼
    .build()
  assert_eq(min_time_log.timestamp_unix_nanos, -9223372036854775808L)
  
  // æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯
  let very_long_message = "This is an extremely long log message that tests the boundary conditions of the logging system. ".repeat(100)
  let long_log = logs::LogRecord::builder()
    .body(very_long_message)
    .build()
  
  match long_log.body {
    Some(body) => assert_eq(body.length(), very_long_message.length())
    None => @test.fail("Expected body to be Some for long message")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—æ¶ˆæ¯
  let special_chars_log = logs::LogRecord::builder()
    .body("Special chars: \n\t\r\"'\\!@#$%^&*(){}[]|;:<>?,./ ä¸­æ–‡ ğŸš€")
    .build()
  
  match special_chars_log.body {
    Some(body) => assert_eq(body, "Special chars: \n\t\r\"'\\!@#$%^&*(){}[]|;:<>?,./ ä¸­æ–‡ ğŸš€")
    None => @test.fail("Expected body to be Some for special chars")
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§çš„æ—¥å¿—
  let mut log_builder = logs::LogRecord::builder()
  for i = 0; i < 100; i = i + 1 {
    log_builder = log_builder.with_attribute("attr_" + i.to_string(), common::AttributeValue::int(i.to_int64()))
  }
  let many_attrs_log = log_builder.build()
  assert_eq(many_attrs_log.attributes.length(), 100)
  
  // æµ‹è¯•Traceæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æ‰€æœ‰SpanKind
  let kinds = [trace::Internal, trace::Server, trace::Client, trace::Producer, trace::Consumer]
  for i = 0; i < kinds.length(); i = i + 1 {
    let span = trace::Span{
      name: "test-span",
      context: trace::SpanContext{
        trace_id: [for j = 0; j < 16; j = j + 1].map(fn(_) { i.to_byte() }),
        span_id: [for j = 0; j < 8; j = j + 1].map(fn(_) { i.to_byte() }),
        trace_flags: 1_byte,
        trace_state: ""
      },
      kind: kinds[i],
      parent_span_id: None,
      start_time_unix_nanos: 1000000L,
      end_time_unix_nanos: None,
      status: trace::Unset,
      status_description: None,
      attributes: [],
      events: [],
      links: []
    }
    assert_eq(span.kind, kinds[i])
  }
  
  // æµ‹è¯•æ‰€æœ‰StatusCode
  let statuses = [trace::Unset, trace::Ok, trace::Error]
  for i = 0; i < statuses.length(); i = i + 1 {
    let span = trace::Span{
      name: "test-span",
      context: trace::SpanContext{
        trace_id: [for j = 0; j < 16; j = j + 1].map(fn(_) { 0_byte }),
        span_id: [for j = 0; j < 8; j = j + 1].map(fn(_) { 0_byte }),
        trace_flags: 0_byte,
        trace_state: ""
      },
      kind: trace::Internal,
      parent_span_id: None,
      start_time_unix_nanos: 1000000L,
      end_time_unix_nanos: Some(2000000L),
      status: statuses[i],
      status_description: Some("Test status"),
      attributes: [],
      events: [],
      links: []
    }
    assert_eq(span.status, statuses[i])
  }
  
  // æµ‹è¯•ç©ºå’Œæå€¼Span
  let empty_span = trace::Span{
    name: "",
    context: trace::SpanContext{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
      trace_flags: 0_byte,
      trace_state: ""
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: 0L,
    end_time_unix_nanos: Some(0L),
    status: trace::Unset,
    status_description: None,
    attributes: [],
    events: [],
    links: []
  }
  assert_eq(empty_span.name, "")
  
  let extreme_time_span = trace::Span{
    name: "extreme-time-span",
    context: trace::SpanContext{
      trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 255_byte }),
      span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 255_byte }),
      trace_flags: 255_byte,
      trace_state: "very-long-trace-state-that-tests-boundary-conditions"
    },
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: 9223372036854775807L,  // Int64æœ€å¤§å€¼
    end_time_unix_nanos: Some(9223372036854775807L),
    status: trace::Error,
    status_description: Some("Very long status description that tests boundary conditions and ensures the system can handle lengthy descriptions without any issues"),
    attributes: [],
    events: [],
    links: []
  }
  assert_eq(extreme_time_span.start_time_unix_nanos, 9223372036854775807L)
  
  // æµ‹è¯•Metricsæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æå€¼æŒ‡æ ‡
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("boundary-test-meter", None, None)
  
  let counter = meter.create_counter("", None, None)  // ç©ºåç§°
  counter.add(9223372036854775807L, [])  // æœ€å¤§å€¼
  counter.add(-9223372036854775808L, []) // æœ€å°å€¼
  counter.add(0L, [])                    // é›¶å€¼
  
  let histogram = meter.create_histogram("histogram", None, None)
  histogram.record(1.7976931348623157e+308, [])  // æœ€å¤§å€¼
  histogram.record(-1.7976931348623157e+308, []) // æœ€å°å€¼
  histogram.record(0.0, [])                       // é›¶å€¼
  histogram.record(1.0/0.0, [])                    // æ— ç©·å¤§
  histogram.record(-1.0/0.0, [])                   // è´Ÿæ— ç©·å¤§
  histogram.record(0.0/0.0, [])                    // NaN
  
  let up_down_counter = meter.create_up_down_counter("up_down", None, None)
  up_down_counter.add(9223372036854775807L, [])
  up_down_counter.add(-9223372036854775808L, [])
  
  let gauge = meter.create_gauge("gauge", None, None)
  gauge.record(1.7976931348623157e+308, [])
  gauge.record(-1.7976931348623157e+308, [])
  gauge.record(0.0, [])
  
  // æµ‹è¯•å¸¦æœ‰å¤§é‡å±æ€§çš„æŒ‡æ ‡
  let mut many_attributes = []
  for i = 0; i < 200; i = i + 1 {
    many_attributes = many_attributes + [("attr_" + i.to_string(), common::AttributeValue::int(i.to_int64()))]
  }
  
  let many_attrs_counter = meter.create_counter("many_attrs_counter", None, None)
  many_attrs_counter.add(1L, many_attributes)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„ä»ªå™¨åç§°
  let special_chars_counter = meter.create_counter(
    "counter.with-special-chars_and.numbers123",
    Some("special-unit!@#$%"),
    Some("Description with special chars: ä¸­æ–‡ ğŸš€ and symbols !@#$%^&*()")
  )
  special_chars_counter.add(1L, [])
  
  // æµ‹è¯•è·¨æ¨¡å—çš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•æ— æ•ˆçš„trace context
  let invalid_trace_context = trace::SpanContext{
    trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
    span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  // ä½¿ç”¨æ— æ•ˆcontextåˆ›å»ºspan
  let invalid_span = trace::Span{
    name: "invalid-context-span",
    context: invalid_trace_context,
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: 0L,
    end_time_unix_nanos: None,
    status: trace::Error,
    status_description: Some("Created with invalid context"),
    attributes: [],
    events: [],
    links: []
  }
  
  // æµ‹è¯•å¸¦æœ‰æ— æ•ˆå±æ€§çš„æ—¥å¿—
  let invalid_attrs_log = logs::LogRecord::builder()
    .with_attribute("", common::AttributeValue::string(""))  // ç©ºé”®å’Œå€¼
    .with_attribute("valid_key", common::AttributeValue::string(""))
    .build()
  
  // æµ‹è¯•Noopå®ç°çš„é”™è¯¯å¤„ç†
  let noop_logger = logs::NoopLogger::{}
  let noop_tracer = trace::NoopTracer::{}
  let noop_meter = metrics::NoopMeter::{}
  
  // è¿™äº›è°ƒç”¨ä¸åº”è¯¥å´©æºƒ
  noop_logger.emit(invalid_attrs_log)
  noop_logger.debug("", [])  // ç©ºæ¶ˆæ¯
  noop_logger.info("\0\0\0", [])  // ç©ºå­—ç¬¦
  
  let dummy_context = context::Context::{}
  let (_, invalid_span_result) = noop_tracer.start_span(
    dummy_context,
    "",  // ç©ºspanåç§°
    Some(trace::Internal),
    [("", common::AttributeValue::string(""))],  // ç©ºå±æ€§
    Some(-9223372036854775808L)  // æœ€å°æ—¶é—´æˆ³
  )
  
  noop_meter.create_counter("", None, None).add(0L, [("", common::AttributeValue::string(""))])
  noop_meter.create_histogram("", None, None).record(0.0/0.0, [("", common::AttributeValue::string(""))])
  
  // æµ‹è¯•å†…å­˜å’Œæ€§èƒ½è¾¹ç•Œ
  let start_time = 1640995200000000000L
  
  // åˆ›å»ºå¤§é‡å¯¹è±¡æ¥æµ‹è¯•å†…å­˜ä½¿ç”¨
  let mut many_logs = []
  for i = 0; i < 100; i = i + 1 {
    let log = logs::LogRecord::builder()
      .timestamp(start_time + i.to_int64())
      .severity(logs::Info)
      .body("Log message " + i.to_string())
      .with_attribute("index", common::AttributeValue::int(i.to_int64()))
      .build()
    many_logs = many_logs + [log]
  }
  assert_eq(many_logs.length(), 100)
  
  let mut many_spans = []
  for i = 0; i < 50; i = i + 1 {
    let span = trace::Span{
      name: "span_" + i.to_string(),
      context: trace::SpanContext{
        trace_id: [for j = 0; j < 16; j = j + 1].map(fn(_) { i.to_byte() }),
        span_id: [for j = 0; j < 8; j = j + 1].map(fn(_) { i.to_byte() }),
        trace_flags: 1_byte,
        trace_state: ""
      },
      kind: trace::Internal,
      parent_span_id: None,
      start_time_unix_nanos: start_time + i.to_int64(),
      end_time_unix_nanos: Some(start_time + i.to_int64() + 1000L),
      status: trace::Ok,
      status_description: None,
      attributes: [("index", common::AttributeValue::int(i.to_int64()))],
      events: [],
      links: []
    }
    many_spans = many_spans + [span]
  }
  assert_eq(many_spans.length(), 50)
}