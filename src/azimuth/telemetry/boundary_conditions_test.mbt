// è¾¹ç•Œæ¡ä»¶æµ‹è¯• - æµ‹è¯•æç«¯æƒ…å†µä¸‹çš„è¡Œä¸º

test "context_empty_and_full_boundary" {
  // æµ‹è¯•ç©ºContextçš„è¾¹ç•Œæ¡ä»¶
  let empty_ctx = context::Context::empty()
  let key = context::create_key("non-existent-key")
  let non_existent_value = empty_ctx.get(key)
  assert_eq(non_existent_value, None)
  
  // æµ‹è¯•å¤§é‡æ•°æ®çš„Contextè¾¹ç•Œ
  let ctx = empty_ctx
  let large_key = context::create_key("very-long-key-name-that-exceeds-normal-length-expectations-and-tests-boundary-conditions")
  let large_value = "very-long-value-that-exceeds-normal-length-expectations-and-tests-boundary-conditions-for-string-values-in-context"
  let ctx_with_large_data = ctx.with_value(large_key, large_value)
  let retrieved_large_value = ctx_with_large_data.get(large_key)
  assert_eq(retrieved_large_value, Some(large_value))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  let empty_key = context::create_key("")
  let empty_value = ""
  let ctx_with_empty = ctx.with_value(empty_key, empty_value)
  let retrieved_empty = ctx_with_empty.get(empty_key)
  assert_eq(retrieved_empty, Some(empty_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_key = context::create_key("key-with-special-chars-!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let special_value = "value-with-special-chars-!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let ctx_with_special = ctx.with_value(special_key, special_value)
  let retrieved_special = ctx_with_special.get(special_key)
  assert_eq(retrieved_special, Some(special_value))
}

test "attribute_value_boundary_conditions" {
  // æµ‹è¯•AttributeValueçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æå€¼
  let max_int = common::AttributeValue::int(9223372036854775807L) // Int64æœ€å¤§å€¼
  let min_int = common::AttributeValue::int(-9223372036854775808L) // Int64æœ€å°å€¼
  let max_float = common::AttributeValue::float(1.7976931348623157e+308) // Doubleæœ€å¤§å€¼
  let min_float = common::AttributeValue::float(-1.7976931348623157e+308) // Doubleæœ€å°å€¼
  
  // æµ‹è¯•ç©ºæ•°ç»„å’Œå•å…ƒç´ æ•°ç»„
  let empty_string_array = common::AttributeValue::array_string([])
  let single_string_array = common::AttributeValue::array_string(["single"])
  let empty_int_array = common::AttributeValue::array_int([])
  let single_int_array = common::AttributeValue::array_int([1L])
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let long_string = "a" * 10000 // 10000ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²
  let long_string_attr = common::AttributeValue::string(long_string)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•Unicodeå­—ç¬¦ğŸŒŸğŸ‰ğŸš€"
  let unicode_attr = common::AttributeValue::string(unicode_string)
  
  // éªŒè¯æ‰€æœ‰å±æ€§å€¼åˆ›å»ºæˆåŠŸ
  assert_eq(true, true)
}

test "span_boundary_conditions" {
  // æµ‹è¯•Spançš„è¾¹ç•Œæ¡ä»¶
  let ctx = context::Context::empty()
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("boundary-test")
  
  // æµ‹è¯•ç©ºåç§°å’Œè¶…é•¿åç§°
  let (_, empty_span) = tracer.start_span(ctx, "")
  assert_eq(empty_span.name, "")
  
  let long_name = "a" * 1000
  let (_, long_span) = tracer.start_span(ctx, long_name)
  assert_eq(long_span.name, long_name)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  let mut i = 0
  while i < 1000 {
    many_attrs.push(("attr-${i}", common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  let (_, span_with_many_attrs) = tracer.start_span(ctx, "test", Some(trace::SpanKind::Internal), Some(many_attrs))
  assert_eq(span_with_many_attrs.attributes.length(), 1000)
  
  // æµ‹è¯•æ‰€æœ‰SpanKind
  let kinds = [
    trace::SpanKind::Internal,
    trace::SpanKind::Server,
    trace::SpanKind::Client,
    trace::SpanKind::Producer,
    trace::SpanKind::Consumer
  ]
  
  let mut kind_index = 0
  while kind_index < kinds.length() {
    let (_, test_span) = tracer.start_span(ctx, "test", Some(kinds[kind_index]))
    assert_eq(test_span.kind, kinds[kind_index])
    kind_index = kind_index + 1
  }
}

test "log_record_boundary_conditions" {
  // æµ‹è¯•LogRecordçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•ç©ºå’Œè¶…é•¿body
  let empty_log = logs::LogRecord::builder()
    .body("")
    .build()
  assert_eq(empty_log.body, Some(""))
  
  let long_body = "a" * 10000
  let long_log = logs::LogRecord::builder()
    .body(long_body)
    .build()
  assert_eq(long_log.body, Some(long_body))
  
  // æµ‹è¯•æ‰€æœ‰SeverityNumber
  let severities = [
    logs::SeverityNumber::Trace,
    logs::SeverityNumber::Debug,
    logs::SeverityNumber::Info,
    logs::SeverityNumber::Warn,
    logs::SeverityNumber::Error,
    logs::SeverityNumber::Fatal
  ]
  
  let mut severity_index = 0
  while severity_index < severities.length() {
    let test_log = logs::LogRecord::builder()
      .severity(severities[severity_index])
      .build()
    assert_eq(test_log.severity_number, severities[severity_index])
    severity_index = severity_index + 1
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let log_with_attrs = logs::LogRecord::builder()
  let mut i = 0
  while i < 1000 {
    log_with_attrs = log_with_attrs.with_attribute("attr-${i}", common::AttributeValue::int(i.to_int64()))
    i = i + 1
  }
  let final_log = log_with_attrs.build()
  assert_eq(final_log.attributes.length(), 1000)
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let min_time_log = logs::LogRecord::builder()
    .timestamp(-9223372036854775808L)
    .build()
  assert_eq(min_time_log.timestamp_unix_nanos, -9223372036854775808L)
  
  let max_time_log = logs::LogRecord::builder()
    .timestamp(9223372036854775807L)
    .build()
  assert_eq(max_time_log.timestamp_unix_nanos, 9223372036854775807L)
}

test "metrics_boundary_conditions" {
  // æµ‹è¯•Metricsçš„è¾¹ç•Œæ¡ä»¶
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("boundary-test")
  
  // æµ‹è¯•ç©ºåç§°å’Œè¶…é•¿åç§°
  let empty_counter = meter.create_counter("", None, None)
  let long_counter = meter.create_counter("a" * 1000, None, None)
  
  // æµ‹è¯•æå€¼
  let counter = meter.create_counter("test", None, None)
  counter.add(9223372036854775807L, None) // æœ€å¤§Int64å€¼
  counter.add(-9223372036854775808L, None) // æœ€å°Int64å€¼
  
  let histogram = meter.create_histogram("test", None, None)
  histogram.record(1.7976931348623157e+308, None) // æœ€å¤§Doubleå€¼
  histogram.record(-1.7976931348623157e+308, None) // æœ€å°Doubleå€¼
  histogram.record(0.0, None)
  histogram.record(Double::infinity, None)
  histogram.record(Double::neg_infinity, None)
  histogram.record(Double::nan, None)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  let mut i = 0
  while i < 1000 {
    many_attrs.push(("attr-${i}", common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  counter.add(1L, Some(many_attrs))
  
  assert_eq(true, true)
}

test "baggage_boundary_conditions" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæ¡ä»¶
  let empty_baggage = context::Baggage::empty()
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼
  let baggage_with_empty = empty_baggage.with_entry("", "")
  let retrieved_empty = baggage_with_empty.get("")
  assert_eq(retrieved_empty, Some(""))
  
  // æµ‹è¯•è¶…é•¿é”®å’Œå€¼
  let long_key = "a" * 1000
  let long_value = "b" * 1000
  let baggage_with_long = empty_baggage.with_entry(long_key, long_value)
  let retrieved_long = baggage_with_long.get(long_key)
  assert_eq(retrieved_long, Some(long_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_key = "key-with-special-chars-!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_value = "value-with-special-chars-!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let baggage_with_special = empty_baggage.with_entry(special_key, special_value)
  let retrieved_special = baggage_with_special.get(special_key)
  assert_eq(retrieved_special, Some(special_value))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_key = "é”®-æµ‹è¯•-Unicode"
  let unicode_value = "å€¼-æµ‹è¯•-Unicode-ğŸŒŸ"
  let baggage_with_unicode = empty_baggage.with_entry(unicode_key, unicode_value)
  let retrieved_unicode = baggage_with_unicode.get(unicode_key)
  assert_eq(retrieved_unicode, Some(unicode_value))
  
  // æµ‹è¯•å¤§é‡æ¡ç›®
  let mut large_baggage = empty_baggage
  let mut i = 0
  while i < 10000 {
    large_baggage = large_baggage.with_entry("key-${i}", "value-${i}")
    i = i + 1
  }
  let test_retrieval = large_baggage.get("key-9999")
  assert_eq(test_retrieval, Some("value-9999"))
}

test "propagation_boundary_conditions" {
  // æµ‹è¯•Propagationçš„è¾¹ç•Œæ¡ä»¶
  let ctx = context::Context::empty()
  
  // æµ‹è¯•ç©ºcarrier
  let empty_carrier = propagation::MapCarrier::new()
  let trace_propagator = propagation::W3CTraceContextPropagator::{}
  let extracted_from_empty = trace_propagator.extract(ctx, empty_carrier)
  assert_eq(extracted_from_empty.values.length(), ctx.values.length())
  
  // æµ‹è¯•è¶…é•¿headerå€¼
  let long_data = [("traceparent", "a" * 1000)]
  let long_carrier = propagation::MapCarrier::from_map(long_data)
  let extracted_from_long = trace_propagator.extract(ctx, long_carrier)
  assert_eq(true, true) // éªŒè¯æ“ä½œä¸å´©æºƒ
  
  // æµ‹è¯•æ— æ•ˆheaderæ ¼å¼
  let invalid_data = [("traceparent", "invalid-format")]
  let invalid_carrier = propagation::MapCarrier::from_map(invalid_data)
  let extracted_from_invalid = trace_propagator.extract(ctx, invalid_carrier)
  assert_eq(true, true) // éªŒè¯æ“ä½œä¸å´©æºƒ
  
  // æµ‹è¯•å¤åˆä¼ æ’­å™¨çš„è¾¹ç•Œæ¡ä»¶
  let empty_propagators = [] : Array[propagation::TextMapPropagator]
  let empty_composite = propagation::CompositePropagator::new(empty_propagators)
  empty_composite.inject(ctx, empty_carrier)
  let extracted_from_empty_composite = empty_composite.extract(ctx, empty_carrier)
  assert_eq(true, true)
}

test "resource_boundary_conditions" {
  // æµ‹è¯•Resourceçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•ç©ºæœåŠ¡åç§°
  let empty_service = common::Resource::default("")
  assert_eq(empty_service.service_name, "")
  
  // æµ‹è¯•è¶…é•¿æœåŠ¡åç§°
  let long_service_name = "a" * 1000
  let long_service = common::Resource::default(long_service_name)
  assert_eq(long_service.service_name, long_service_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æœåŠ¡åç§°
  let special_service_name = "service-with-special-chars-!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_service = common::Resource::default(special_service_name)
  assert_eq(special_service.service_name, special_service_name)
  
  // æµ‹è¯•UnicodeæœåŠ¡åç§°
  let unicode_service_name = "æœåŠ¡-åç§°-æµ‹è¯•-ğŸŒŸ"
  let unicode_service = common::Resource::default(unicode_service_name)
  assert_eq(unicode_service.service_name, unicode_service_name)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  let mut i = 0
  while i < 10000 {
    many_attrs.push(("attr-${i}", common::AttributeValue::string("value-${i}")))
    i = i + 1
  }
  let resource_with_many_attrs = common::Resource::{
    service_name: "test",
    service_version: None,
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: many_attrs
  }
  assert_eq(resource_with_many_attrs.attributes.length(), 10000)
}