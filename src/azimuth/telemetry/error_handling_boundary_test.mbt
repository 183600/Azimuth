// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶ç»¼åˆæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•æ•´ä¸ªTelemetryå¥—ä»¶çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶

test "common_module_error_handling" {
  // æµ‹è¯•commonæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•AttributeValueçš„è¾¹ç•Œæ¡ä»¶
  let max_int_value = AttributeValue::int(9223372036854775807L)
  let min_int_value = AttributeValue::int(-9223372036854775808L)
  let zero_int_value = AttributeValue::int(0L)
  
  // éªŒæå€¼
  match max_int_value {
    IntValue(value) => assert_eq(value, 9223372036854775807L)
    _ => assert_eq(false, true)
  }
  
  match min_int_value {
    IntValue(value) => assert_eq(value, -9223372036854775808L)
    _ => assert_eq(false, true)
  }
  
  match zero_int_value {
    IntValue(value) => assert_eq(value, 0L)
    _ => assert_eq(false, true)
  }
  
  // æµ‹è¯•æµ®ç‚¹è¾¹ç•Œå€¼
  let max_float_value = AttributeValue::float(1.7976931348623157e+308)
  let min_float_value = AttributeValue::float(2.2250738585072014e-308)
  let negative_inf_value = AttributeValue::float(-1.0 / 0.0)  // è´Ÿæ— ç©·
  let positive_inf_value = AttributeValue::float(1.0 / 0.0)   // æ­£æ— ç©·
  let nan_value = AttributeValue::float(0.0 / 0.0)            // NaN
  
  match max_float_value {
    FloatValue(value) => assert_eq(value > 1.0e+308, true)
    _ => assert_eq(false, true)
  }
  
  match min_float_value {
    FloatValue(value) => assert_eq(value > 0.0 && value < 1.0e-307, true)
    _ => assert_eq(false, true)
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„å’Œå•å…ƒç´ æ•°ç»„
  let empty_string_array = AttributeValue::array_string([])
  let single_string_array = AttributeValue::array_string(["only"])
  let empty_int_array = AttributeValue::array_int([])
  let single_int_array = AttributeValue::array_int([42L])
  
  match empty_string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => assert_eq(false, true)
  }
  
  match single_string_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], "only")
    }
    _ => assert_eq(false, true)
  }
  
  // æµ‹è¯•Resourceçš„è¾¹ç•Œæ¡ä»¶
  let empty_name_resource = common::Resource::default("")
  let very_long_name_resource = common::Resource::default("a".repeat(10000))
  let unicode_name_resource = common::Resource::default("æœåŠ¡åç§°.ğŸŒŸ.æµ‹è¯•")
  
  assert_eq(empty_name_resource.service_name.length(), 0)
  assert_eq(very_long_name_resource.service_name.length(), 10000)
  assert_eq(unicode_name_resource.service_name.contains("æµ‹è¯•"), true)
  
  // æµ‹è¯•InstrumentationScopeçš„è¾¹ç•Œæ¡ä»¶
  let empty_scope = common::InstrumentationScope::{
    name: "",
    version: Some(""),
    schema_url: Some("")
  }
  
  assert_eq(empty_scope.name.length(), 0)
  match empty_scope.version {
    Some(version) => assert_eq(version.length(), 0)
    None => assert_eq(false, true)
  }
  match empty_scope.schema_url {
    Some(schema_url) => assert_eq(schema_url.length(), 0)
    None => assert_eq(false, true)
  }
}

test "trace_module_error_handling" {
  // æµ‹è¯•traceæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  let initial_context = context::Context::empty()
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("test-tracer")
  
  // æµ‹è¯•ç©ºåç§°çš„Span
  let (empty_name_ctx, empty_name_span) = tracer.start_span(initial_context, "")
  assert_eq(empty_name_span.name.length(), 0)
  
  // æµ‹è¯•éå¸¸é•¿åç§°çš„Span
  let long_name = "a".repeat(10000)
  let (long_name_ctx, long_name_span) = tracer.start_span(initial_context, long_name)
  assert_eq(long_name_span.name.length(), 10000)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„Spanåç§°
  let special_name = "span-with_special.chars!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let (special_name_ctx, special_name_span) = tracer.start_span(initial_context, special_name)
  assert_eq(special_name_span.name, special_name)
  
  // æµ‹è¯•Unicode Spanåç§°
  let unicode_name = "spanåç§°.ğŸŒŸ.æµ‹è¯•"
  let (unicode_name_ctx, unicode_name_span) = tracer.start_span(initial_context, unicode_name)
  assert_eq(unicode_name_span.name, unicode_name)
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´æˆ³
  let zero_time_span = tracer.start_span(initial_context, "zero-time", trace::Internal, [], Some(0L))
  assert_eq(zero_time_span.1.start_time_unix_nanos, 0L)
  
  let max_time_span = tracer.start_span(initial_context, "max-time", trace::Internal, [], Some(9223372036854775807L))
  assert_eq(max_time_span.1.start_time_unix_nanos, 9223372036854775807L)
  
  let negative_time_span = tracer.start_span(initial_context, "negative-time", trace::Internal, [], Some(-1L))
  assert_eq(negative_time_span.1.start_time_unix_nanos, -1L)
  
  // æµ‹è¯•å¤æ‚çš„Spanå±æ€§
  let complex_attributes = [
    ("empty.string", AttributeValue::string("")),
    ("long.string", AttributeValue::string("a".repeat(1000))),
    ("unicode.string", AttributeValue::string("unicode.æµ‹è¯•.ğŸŒŸ")),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("min.int", AttributeValue::int(-9223372036854775808L)),
    ("max.float", AttributeValue::float(1.7976931348623157e+308)),
    ("min.float", AttributeValue::float(2.2250738585072014e-308)),
    ("empty.array", AttributeValue::array_string([])),
    ("large.array", AttributeValue::array_int([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L]))
  ]
  
  let (complex_ctx, complex_span) = tracer.start_span(
    initial_context,
    "complex-span",
    trace::Internal,
    complex_attributes
  )
  
  assert_eq(complex_span.attributes.length(), 9)
  
  // æµ‹è¯•Spanäº‹ä»¶å’Œé“¾æ¥çš„è¾¹ç•Œæ¡ä»¶
  let empty_event = trace::SpanEvent::{
    name: "",
    timestamp_unix_nanos: 0L,
    attributes: []
  }
  
  let max_event = trace::SpanEvent::{
    name: "a".repeat(1000),
    timestamp_unix_nanos: 9223372036854775807L,
    attributes: [
      ("max.attribute", AttributeValue::string("a".repeat(1000)))
    ]
  }
  
  let events_span = trace::Span::{
    ..complex_span,
    events: [empty_event, max_event]
  }
  
  assert_eq(events_span.events.length(), 2)
  assert_eq(events_span.events[0].name.length(), 0)
  assert_eq(events_span.events[1].name.length(), 1000)
  
  // æµ‹è¯•SpanContextçš„è¾¹ç•Œæ¡ä»¶
  let zero_trace_id = Array::make(16, 0_byte)
  let max_trace_id = Array::make(16, 255_byte)
  let zero_span_id = Array::make(8, 0_byte)
  let max_span_id = Array::make(8, 255_byte)
  
  let zero_context = trace::SpanContext::{
    trace_id: zero_trace_id,
    span_id: zero_span_id,
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  let max_context = trace::SpanContext::{
    trace_id: max_trace_id,
    span_id: max_span_id,
    trace_flags: 255_byte,
    trace_state: "a".repeat(1000)
  }
  
  assert_eq(zero_context.trace_id[0], 0_byte)
  assert_eq(max_context.trace_id[0], 255_byte)
  assert_eq(zero_context.trace_flags, 0_byte)
  assert_eq(max_context.trace_flags, 255_byte)
  assert_eq(zero_context.trace_state.length(), 0)
  assert_eq(max_context.trace_state.length(), 1000)
}

test "logs_module_error_handling" {
  // æµ‹è¯•logsæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  let builder = logs::LogRecord::builder()
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´æˆ³
  let zero_timestamp_log = builder
    .timestamp(0L)
    .severity(logs::Info)
    .body("zero timestamp")
    .build()
  
  assert_eq(zero_timestamp_log.timestamp_unix_nanos, 0L)
  
  let max_timestamp_log = builder
    .timestamp(9223372036854775807L)
    .severity(logs::Info)
    .body("max timestamp")
    .build()
  
  assert_eq(max_timestamp_log.timestamp_unix_nanos, 9223372036854775807L)
  
  let negative_timestamp_log = builder
    .timestamp(-1L)
    .severity(logs::Info)
    .body("negative timestamp")
    .build()
  
  assert_eq(negative_timestamp_log.timestamp_unix_nanos, -1L)
  
  // æµ‹è¯•è¾¹ç•Œè§‚å¯Ÿæ—¶é—´æˆ³
  let log_with_observed = logs::LogRecord::{
    ..zero_timestamp_log,
    observed_timestamp_unix_nanos: Some(9223372036854775807L)
  }
  
  match log_with_observed.observed_timestamp_unix_nanos {
    Some(observed) => assert_eq(observed, 9223372036854775807L)
    None => assert_eq(false, true)
  }
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡æ€§çº§åˆ«
  let trace_log = builder.severity(logs::Trace).body("trace").build()
  let debug_log = builder.severity(logs::Debug).body("debug").build()
  let info_log = builder.severity(logs::Info).body("info").build()
  let warn_log = builder.severity(logs::Warn).body("warn").build()
  let error_log = builder.severity(logs::Error).body("error").build()
  let fatal_log = builder.severity(logs::Fatal).body("fatal").build()
  
  match trace_log.severity_number { logs::Trace => assert_eq(true, true) _ => assert_eq(false, true) }
  match debug_log.severity_number { logs::Debug => assert_eq(true, true) _ => assert_eq(false, true) }
  match info_log.severity_number { logs::Info => assert_eq(true, true) _ => assert_eq(false, true) }
  match warn_log.severity_number { logs::Warn => assert_eq(true, true) _ => assert_eq(false, true) }
  match error_log.severity_number { logs::Error => assert_eq(true, true) _ => assert_eq(false, true) }
  match fatal_log.severity_number { logs::Fatal => assert_eq(true, true) _ => assert_eq(false, true) }
  
  // æµ‹è¯•è¾¹ç•Œä¸¥é‡æ€§æ–‡æœ¬
  let log_with_empty_severity_text = logs::LogRecord::{
    ..info_log,
    severity_text: Some("")
  }
  
  let log_with_long_severity_text = logs::LogRecord::{
    ..info_log,
    severity_text: Some("a".repeat(1000))
  }
  
  let log_with_unicode_severity_text = logs::LogRecord::{
    ..info_log,
    severity_text: Some("ä¸¥é‡æ€§æ–‡æœ¬.ğŸŒŸ.æµ‹è¯•")
  }
  
  match log_with_empty_severity_text.severity_text {
    Some(text) => assert_eq(text.length(), 0)
    None => assert_eq(false, true)
  }
  
  match log_with_long_severity_text.severity_text {
    Some(text) => assert_eq(text.length(), 1000)
    None => assert_eq(false, true)
  }
  
  match log_with_unicode_severity_text.severity_text {
    Some(text) => assert_eq(text.contains("æµ‹è¯•"), true)
    None => assert_eq(false, true)
  }
  
  // æµ‹è¯•è¾¹ç•Œæ—¥å¿—å†…å®¹
  let empty_body_log = builder.body("").build()
  let long_body_log = builder.body("a".repeat(10000)).build()
  let unicode_body_log = builder.body("æ—¥å¿—å†…å®¹.ğŸŒŸ.æµ‹è¯•").build()
  let special_body_log = builder.body("special.chars!@#$%^&*()_+-=[]{}|;':\",./<>?").build()
  
  match empty_body_log.body {
    Some(body) => assert_eq(body.length(), 0)
    None => assert_eq(false, true)
  }
  
  match long_body_log.body {
    Some(body) => assert_eq(body.length(), 10000)
    None => assert_eq(false, true)
  }
  
  match unicode_body_log.body {
    Some(body) => assert_eq(body.contains("æµ‹è¯•"), true)
    None => assert_eq(false, true)
  }
  
  match special_body_log.body {
    Some(body) => assert_eq(body.contains("!@#$%^&*()"), true)
    None => assert_eq(false, true)
  }
  
  // æµ‹è¯•å¤æ‚å±æ€§ç»„åˆ
  let complex_log = builder
    .body("complex log")
    .with_attribute("empty.value", AttributeValue::string(""))
    .with_attribute("long.value", AttributeValue::string("a".repeat(1000)))
    .with_attribute("unicode.value", AttributeValue::string("unicode.æµ‹è¯•.ğŸŒŸ"))
    .with_attribute("max.int", AttributeValue::int(9223372036854775807L))
    .with_attribute("min.int", AttributeValue::int(-9223372036854775808L))
    .with_attribute("max.float", AttributeValue::float(1.7976931348623157e+308))
    .with_attribute("empty.array", AttributeValue::array_string([]))
    .with_attribute("large.array", AttributeValue::array_int([1L, 2L, 3L, 4L, 5L]))
    .build()
  
  assert_eq(complex_log.attributes.length(), 8)
  
  // æµ‹è¯•è¿½è¸ªä¸Šä¸‹æ–‡çš„è¾¹ç•Œæ¡ä»¶
  let zero_trace_id = Array::make(16, 0_byte)
  let max_trace_id = Array::make(16, 255_byte)
  let zero_span_id = Array::make(8, 0_byte)
  let max_span_id = Array::make(8, 255_byte)
  
  let log_with_zero_trace = logs::LogRecord::{
    ..complex_log,
    trace_id: Some(zero_trace_id),
    span_id: Some(zero_span_id),
    trace_flags: Some(0_byte)
  }
  
  let log_with_max_trace = logs::LogRecord::{
    ..complex_log,
    trace_id: Some(max_trace_id),
    span_id: Some(max_span_id),
    trace_flags: Some(255_byte)
  }
  
  match log_with_zero_trace.trace_id {
    Some(trace_id) => assert_eq(trace_id[0], 0_byte)
    None => assert_eq(false, true)
  }
  
  match log_with_max_trace.trace_id {
    Some(trace_id) => assert_eq(trace_id[0], 255_byte)
    None => assert_eq(false, true)
  }
}

test "metrics_module_error_handling" {
  // æµ‹è¯•metricsæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("test-meter")
  
  // æµ‹è¯•è¾¹ç•Œinstrumentåç§°
  let empty_name_counter = meter.create_counter("", Some("count"), Some("empty name counter"))
  let long_name_counter = meter.create_counter("a".repeat(1000), Some("count"), Some("long name counter"))
  let special_name_counter = meter.create_counter("special!@#$%^&*()", Some("count"), Some("special name counter"))
  let unicode_name_counter = meter.create_counter("è®¡æ•°å™¨.ğŸŒŸ.æµ‹è¯•", Some("count"), Some("unicode name counter"))
  
  // æµ‹è¯•è¾¹ç•Œå•ä½
  let empty_unit_histogram = meter.create_histogram("test-histogram", Some(""), Some("empty unit histogram"))
  let long_unit_histogram = meter.create_histogram("test-histogram", Some("a".repeat(100)), Some("long unit histogram"))
  let special_unit_histogram = meter.create_histogram("test-histogram", Some("!@#$%^&*()"), Some("special unit histogram"))
  let unicode_unit_histogram = meter.create_histogram("test-histogram", Some("å•ä½.ğŸŒŸ.æµ‹è¯•"), Some("unicode unit histogram"))
  
  // æµ‹è¯•è¾¹ç•Œæè¿°
  let empty_desc_gauge = meter.create_gauge("test-gauge", Some("count"), Some(""))
  let long_desc_gauge = meter.create_gauge("test-gauge", Some("count"), Some("a".repeat(1000)))
  let special_desc_gauge = meter.create_gauge("test-gauge", Some("count"), Some("special.desc!@#$%^&*()"))
  let unicode_desc_gauge = meter.create_gauge("test-gauge", Some("count"), Some("æè¿°.ğŸŒŸ.æµ‹è¯•"))
  
  // æµ‹è¯•è¾¹ç•ŒCounteræ“ä½œ
  empty_name_counter.add(0L)
  empty_name_counter.add(9223372036854775807L)  // æœ€å¤§Int64
  empty_name_counter.add(-9223372036854775808L) // æœ€å°Int64
  empty_name_counter.add(-1L)                    // è´Ÿå€¼
  
  // æµ‹è¯•è¾¹ç•ŒCounterå±æ€§
  empty_name_counter.add(1L, [
    ("empty.value", AttributeValue::string("")),
    ("long.value", AttributeValue::string("a".repeat(1000))),
    ("unicode.value", AttributeValue::string("unicode.æµ‹è¯•.ğŸŒŸ")),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("min.int", AttributeValue::int(-9223372036854775808L)),
    ("empty.array", AttributeValue::array_string([])),
    ("large.array", AttributeValue::array_int([1L, 2L, 3L, 4L, 5L]))
  ])
  
  // æµ‹è¯•è¾¹ç•ŒHistogramæ“ä½œ
  empty_unit_histogram.record(0.0)
  empty_unit_histogram.record(1.7976931348623157e+308)  // æœ€å¤§Double
  empty_unit_histogram.record(2.2250738585072014e-308)  // æœ€å°æ­£Double
  empty_unit_histogram.record(-1.7976931348623157e+308) // è´Ÿæœ€å¤§å€¼
  empty_unit_histogram.record(1.0 / 0.0)                 // æ­£æ— ç©·
  empty_unit_histogram.record(-1.0 / 0.0)                // è´Ÿæ— ç©·
  empty_unit_histogram.record(0.0 / 0.0)                  // NaN
  
  // æµ‹è¯•è¾¹ç•ŒHistogramå±æ€§
  empty_unit_histogram.record(1.0, [
    ("max.float", AttributeValue::float(1.7976931348623157e+308)),
    ("min.float", AttributeValue::float(2.2250738585072014e-308)),
    ("inf.float", AttributeValue::float(1.0 / 0.0)),
    ("neg.inf.float", AttributeValue::float(-1.0 / 0.0)),
    ("nan.float", AttributeValue::float(0.0 / 0.0))
  ])
  
  // æµ‹è¯•è¾¹ç•ŒUpDownCounteræ“ä½œ
  let up_down_counter = meter.create_up_down_counter("test-up-down")
  up_down_counter.add(0L)
  up_down_counter.add(9223372036854775807L)
  up_down_counter.add(-9223372036854775808L)
  up_down_counter.add(1L)
  up_down_counter.add(-1L)
  
  // æµ‹è¯•è¾¹ç•ŒGaugeæ“ä½œ
  let gauge = meter.create_gauge("test-gauge")
  gauge.record(0.0)
  gauge.record(1.7976931348623157e+308)
  gauge.record(-1.7976931348623157e+308)
  gauge.record(2.2250738585072014e-308)
  gauge.record(1.0 / 0.0)
  gauge.record(-1.0 / 0.0)
  gauge.record(0.0 / 0.0)
  
  // æµ‹è¯•Measurementè¾¹ç•Œå€¼
  let zero_measurement = metrics::Measurement::{
    value: 0.0,
    attributes: []
  }
  
  let max_measurement = metrics::Measurement::{
    value: 1.7976931348623157e+308,
    attributes: [("max.value", AttributeValue::float(1.7976931348623157e+308))]
  }
  
  let min_measurement = metrics::Measurement::{
    value: 2.2250738585072014e-308,
    attributes: [("min.value", AttributeValue::float(2.2250738585072014e-308))]
  }
  
  let negative_measurement = metrics::Measurement::{
    value: -1.7976931348623157e+308,
    attributes: [("negative.value", AttributeValue::float(-1.7976931348623157e+308))]
  }
  
  let inf_measurement = metrics::Measurement::{
    value: 1.0 / 0.0,
    attributes: [("inf.value", AttributeValue::float(1.0 / 0.0))]
  }
  
  let nan_measurement = metrics::Measurement::{
    value: 0.0 / 0.0,
    attributes: [("nan.value", AttributeValue::float(0.0 / 0.0))]
  }
  
  assert_eq(zero_measurement.value, 0.0)
  assert_eq(max_measurement.value > 1.0e+308, true)
  assert_eq(min_measurement.value > 0.0 && min_measurement.value < 1.0e-307, true)
  assert_eq(negative_measurement.value < -1.0e+308, true)
  assert_eq(inf_measurement.value > 1.0e+308, true)  // æ— ç©·å¤§æ£€æŸ¥
  
  // éªŒè¯æ‰€æœ‰measurementéƒ½èƒ½åˆ›å»º
  assert_eq(zero_measurement.attributes.length(), 0)
  assert_eq(max_measurement.attributes.length(), 1)
  assert_eq(min_measurement.attributes.length(), 1)
  assert_eq(negative_measurement.attributes.length(), 1)
  assert_eq(inf_measurement.attributes.length(), 1)
  assert_eq(nan_measurement.attributes.length(), 1)
}

test "propagation_module_error_handling" {
  // æµ‹è¯•propagationæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  let initial_context = context::Context::empty()
  let trace_propagator = propagation::W3CTraceContextPropagator::{}
  let baggage_propagator = propagation::W3CBaggagePropagator::{}
  
  // æµ‹è¯•è¾¹ç•ŒMapCarrier
  let empty_carrier = propagation::MapCarrier::new()
  let large_carrier_data = [
    ("key1", "value1"),
    ("key2", "value2"),
    ("key3", "value3"),
    ("key4", "value4"),
    ("key5", "value5"),
    ("key6", "value6"),
    ("key7", "value7"),
    ("key8", "value8"),
    ("key9", "value9"),
    ("key10", "value10")
  ]
  let large_carrier = propagation::MapCarrier::from_map(large_carrier_data)
  
  // æµ‹è¯•è¾¹ç•Œé”®å€¼
  let boundary_carrier_data = [
    ("", "empty key"),
    ("empty value", ""),
    ("long key", "a".repeat(1000)),
    ("long value", "value: " + "a".repeat(1000)),
    ("unicode key", "é”®.ğŸŒŸ"),
    ("unicode value", "å€¼.ğŸŒŸ"),
    ("special chars", "!@#$%^&*()_+-=[]{}|;':\",./<>?"),
    ("mixed", "mix of ä¸­æ–‡ and english and ğŸŒŸ symbols")
  ]
  let boundary_carrier = propagation::MapCarrier::from_map(boundary_carrier_data)
  
  // æµ‹è¯•injectæ“ä½œ
  trace_propagator.inject(initial_context, empty_carrier)
  trace_propagator.inject(initial_context, large_carrier)
  trace_propagator.inject(initial_context, boundary_carrier)
  
  baggage_propagator.inject(initial_context, empty_carrier)
  baggage_propagator.inject(initial_context, large_carrier)
  baggage_propagator.inject(initial_context, boundary_carrier)
  
  // æµ‹è¯•extractæ“ä½œ
  let empty_extract_context = trace_propagator.extract(initial_context, empty_carrier)
  let large_extract_context = trace_propagator.extract(initial_context, large_carrier)
  let boundary_extract_context = trace_propagator.extract(initial_context, boundary_carrier)
  
  let empty_baggage_context = baggage_propagator.extract(initial_context, empty_carrier)
  let large_baggage_context = baggage_propagator.extract(initial_context, large_carrier)
  let boundary_baggage_context = baggage_propagator.extract(initial_context, boundary_carrier)
  
  // éªŒè¯extractä¸ä¼šå´©æºƒ
  assert_eq(empty_extract_context.values.length(), initial_context.values.length())
  assert_eq(large_extract_context.values.length(), initial_context.values.length())
  assert_eq(boundary_extract_context.values.length(), initial_context.values.length())
  
  assert_eq(empty_baggage_context.values.length(), initial_context.values.length())
  assert_eq(large_baggage_context.values.length(), initial_context.values.length())
  assert_eq(boundary_baggage_context.values.length(), initial_context.values.length())
  
  // æµ‹è¯•è¾¹ç•Œtraceparentæ ¼å¼
  let boundary_trace_parents = [
    "",  // ç©ºå­—ç¬¦ä¸²
    "invalid-format",  // æ— æ•ˆæ ¼å¼
    "00-0af7651916cd43dd8448eb211c80319c",  // ä¸å®Œæ•´
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331",  // ç¼ºå°‘flags
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01-extra",  // é¢å¤–éƒ¨åˆ†
    "ff-ffffffffffffffffffffffffffffffff-ffffffffffffffff-ff",  // æœ€å¤§å€¼
    "00-00000000000000000000000000000000-0000000000000000-00",  // æœ€å°å€¼
    "01-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // ä¸åŒç‰ˆæœ¬
    "99-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"   // é«˜ç‰ˆæœ¬å·
  ]
  
  let mut index = 0
  while index < boundary_trace_parents.length() {
    let trace_parent = boundary_trace_parents[index]
    let test_carrier = propagation::MapCarrier::from_map([
      (propagation::TRACE_PARENT_HEADER, trace_parent)
    ])
    
    // æµ‹è¯•extractä¸ä¼šå´©æºƒ
    let _extract_context = trace_propagator.extract(initial_context, test_carrier)
    assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜æ²¡æœ‰å´©æºƒ
    
    index = index + 1
  }
  
  // æµ‹è¯•è¾¹ç•Œbaggageæ ¼å¼
  let boundary_baggages = [
    "",  // ç©ºå­—ç¬¦ä¸²
    "invalid",  // æ— æ•ˆæ ¼å¼ï¼ˆæ²¡æœ‰=ï¼‰
    "key=",  // ç©ºå€¼
    "=value",  // ç©ºé”®
    "key=value,",  // ç»“å°¾é€—å·
    ",key=value",  // å¼€å¤´é€—å·
    "key=value,,key2=value2",  // åŒé€—å·
    "key=value;prop1=val1,key2=value2;prop2=val2",  // å¤æ‚å±æ€§
    "a".repeat(1000) + "=" + "b".repeat(1000),  // é•¿é”®å€¼
    "unicode=æµ‹è¯•",  // Unicode
    "special=!@#$%^&*()_+-=[]{}|;':\",./<>?"  // ç‰¹æ®Šå­—ç¬¦
  ]
  
  let mut index2 = 0
  while index2 < boundary_baggages.length() {
    let baggage = boundary_baggages[index2]
    let test_carrier = propagation::MapCarrier::from_map([
      (propagation::BAGGAGE_HEADER, baggage)
    ])
    
    // æµ‹è¯•extractä¸ä¼šå´©æºƒ
    let _extract_context = baggage_propagator.extract(initial_context, test_carrier)
    assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜æ²¡æœ‰å´©æºƒ
    
    index2 = index2 + 1
  }
  
  // æµ‹è¯•CompositePropagatorçš„è¾¹ç•Œæ¡ä»¶
  let empty_propagators = []
  let empty_composite = propagation::CompositePropagator::new(empty_propagators)
  
  let single_propagator = [trace_propagator]
  let single_composite = propagation::CompositePropagator::new(single_propagator)
  
  let many_propagators = [
    trace_propagator,
    baggage_propagator,
    trace_propagator,  // é‡å¤
    baggage_propagator  // é‡å¤
  ]
  let many_composite = propagation::CompositePropagator::new(many_propagators)
  
  // æµ‹è¯•æ‰€æœ‰composite propagatoréƒ½èƒ½æ­£å¸¸å·¥ä½œ
  empty_composite.inject(initial_context, empty_carrier)
  single_composite.inject(initial_context, empty_carrier)
  many_composite.inject(initial_context, empty_carrier)
  
  let _empty_extract = empty_composite.extract(initial_context, empty_carrier)
  let _single_extract = single_composite.extract(initial_context, empty_carrier)
  let _many_extract = many_composite.extract(initial_context, empty_carrier)
  
  assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜æ²¡æœ‰å´©æºƒ
}

test "context_module_error_handling" {
  // æµ‹è¯•contextæ¨¡å—çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•è¾¹ç•ŒContextKey
  let empty_key = context::create_key("")
  let long_key = context::create_key("a".repeat(1000))
  let unicode_key = context::create_key("é”®.ğŸŒŸ.æµ‹è¯•")
  let special_key = context::create_key("!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  // æµ‹è¯•è¾¹ç•ŒContextå€¼
  let empty_context = context::Context::empty()
  
  let empty_value_context = empty_context.with_value(empty_key, "")
  let long_value_context = empty_context.with_value(long_key, "a".repeat(1000))
  let unicode_value_context = empty_context.with_value(unicode_key, "å€¼.ğŸŒŸ.æµ‹è¯•")
  let special_value_context = empty_context.with_value(special_key, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  // éªŒè¯è¾¹ç•Œå€¼éƒ½èƒ½æ­£ç¡®è®¾ç½®å’Œè·å–
  match empty_value_context.get(empty_key) {
    Some(value) => assert_eq(value.length(), 0)
    None => assert_eq(false, true)
  }
  
  match long_value_context.get(long_key) {
    Some(value) => assert_eq(value.length(), 1000)
    None => assert_eq(false, true)
  }
  
  match unicode_value_context.get(unicode_key) {
    Some(value) => assert_eq(value.contains("æµ‹è¯•"), true)
    None => assert_eq(false, true)
  }
  
  match special_value_context.get(special_key) {
    Some(value) => assert_eq(value.contains("!@#$%^&*()"), true)
    None => assert_eq(false, true)
  }
  
  // æµ‹è¯•å¤§è§„æ¨¡Contextæ“ä½œ
  let mut large_context = empty_context
  let mut index = 0
  while index < 100 {
    let key = context::create_key("large.key." + index.to_string())
    let value = "large.value." + index.to_string() + "a".repeat(100)
    large_context = large_context.with_value(key, value)
    index = index + 1
  }
  
  // éªŒè¯å¤§è§„æ¨¡Context
  assert_eq(large_context.values.length(), 100)
  
  // éšæœºè®¿é—®ä¸€äº›å€¼
  match large_context.get(context::create_key("large.key.0")) {
    Some(value) => assert_eq(value.contains("large.value.0"), true)
    None => assert_eq(false, true)
  }
  
  match large_context.get(context::create_key("large.key.99")) {
    Some(value) => assert_eq(value.contains("large.value.99"), true)
    None => assert_eq(false, true)
  }
  
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæ¡ä»¶
  let empty_baggage = context::Baggage::empty()
  
  let empty_key_baggage = empty_baggage.with_entry("", "empty key value")
  let empty_value_baggage = empty_baggage.with_entry("empty value", "")
  let long_key_baggage = empty_baggage.with_entry("a".repeat(1000), "long key value")
  let long_value_baggage = empty_baggage.with_entry("long value", "a".repeat(1000))
  let unicode_baggage = empty_baggage.with_entry("unicode.é”®", "unicode.å€¼.ğŸŒŸ")
  let special_baggage = empty_baggage.with_entry("!@#$%^&*()", "!@#$%^&*()")
  
  // éªŒè¯è¾¹ç•ŒBaggageæ¡ç›®
  match empty_key_baggage.get("") {
    Some(value) => assert_eq(value, "empty key value")
    None => assert_eq(false, true)
  }
  
  match empty_value_baggage.get("empty value") {
    Some(value) => assert_eq(value.length(), 0)
    None => assert_eq(false, true)
  }
  
  match long_key_baggage.get("a".repeat(1000)) {
    Some(value) => assert_eq(value, "long key value")
    None => assert_eq(false, true)
  }
  
  match long_value_baggage.get("long value") {
    Some(value) => assert_eq(value.length(), 1000)
    None => assert_eq(false, true)
  }
  
  match unicode_baggage.get("unicode.é”®") {
    Some(value) => assert_eq(value.contains("æµ‹è¯•"), true)
    None => assert_eq(false, true)
  }
  
  match special_baggage.get("!@#$%^&*()") {
    Some(value) => assert_eq(value, "!@#$%^&*()")
    None => assert_eq(false, true)
  }
  
  // æµ‹è¯•å¤§è§„æ¨¡Baggageæ“ä½œ
  let mut large_baggage = empty_baggage
  let mut index2 = 0
  while index2 < 50 {
    let key = "large.baggage.key." + index2.to_string()
    let value = "large.baggage.value." + index2.to_string() + "b".repeat(50)
    large_baggage = large_baggage.with_entry(key, value)
    index2 = index2 + 1
  }
  
  // éªŒè¯å¤§è§„æ¨¡Baggage
  assert_eq(large_baggage.entries.length(), 50)
  
  // éšæœºè®¿é—®ä¸€äº›æ¡ç›®
  match large_baggage.get("large.baggage.key.0") {
    Some(value) => assert_eq(value.contains("large.baggage.value.0"), true)
    None => assert_eq(false, true)
  }
  
  match large_baggage.get("large.baggage.key.49") {
    Some(value) => assert_eq(value.contains("large.baggage.value.49"), true)
    None => assert_eq(false, true)
  }
}