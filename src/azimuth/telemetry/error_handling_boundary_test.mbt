// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º

test "error_handling_null_and_empty_values" {
  // æµ‹è¯•ç©ºå€¼å’Œnullå€¼çš„å¤„ç†
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  
  let tracer = tracer_provider.get_tracer("error-test")
  let meter = meter_provider.get_meter("error-test")
  let logger = logger_provider.get_logger("error-test")
  
  let ctx = context::Context::empty()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²Spanåç§°
  let (_, empty_name_span) = tracer.start_span(
    ctx,
    "",
    trace::Internal,
    [("empty.name", "true")]
  )
  assert_eq(empty_name_span.name, "")
  
  // æµ‹è¯•ç©ºå±æ€§å€¼
  let (_, empty_attr_span) = tracer.start_span(
    ctx,
    "test-span",
    trace::Internal,
    [("empty.value", ""), ("another.empty", "")]
  )
  assert_eq(empty_attr_span.attributes.length(), 2)
  
  // æµ‹è¯•Counterç©ºå€¼å¤„ç†
  let counter = meter.create_counter("", "", "")
  counter.add(1, [("", ""), ("normal.key", "normal.value")])
  
  // æµ‹è¯•æ—¥å¿—ç©ºå€¼å¤„ç†
  logger.info("", [("", "")])
  logger.debug("", [])
  
  let empty_log = logs::LogRecord::builder()
    .body("")
    .with_attribute("", "")
    .build()
  logger.emit(empty_log)
  
  // éªŒè¯ç©ºå€¼å¤„ç†ä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_eq(counter is metrics::NoopCounter, true)
  assert_eq(empty_name_span is trace::Span, true)
}

test "error_handling_extreme_values" {
  // æµ‹è¯•æå€¼å¤„ç†
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  
  let tracer = tracer_provider.get_tracer("extreme-test")
  let meter = meter_provider.get_meter("extreme-test")
  let logger = logger_provider.get_logger("extreme-test")
  
  let ctx = context::Context::empty()
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²
  let very_long_string = "This is an extremely long string that could potentially cause issues in some systems. ".repeat(100)
  let (_, long_name_span) = tracer.start_span(
    ctx,
    very_long_string,
    trace::Internal,
    [("long.attribute", very_long_string)]
  )
  
  // æµ‹è¯•æå€¼æ•°å€¼
  let counter = meter.create_counter("extreme-counter", "count", "Extreme value counter")
  let histogram = meter.create_histogram("extreme-histogram", "value", "Extreme value histogram")
  let up_down_counter = meter.create_up_down_counter("extreme-up-down", "value", "Extreme up-down counter")
  let gauge = meter.create_gauge("extreme-gauge", "value", "Extreme gauge")
  
  // æµ‹è¯•æå¤§å’Œæå°å€¼
  counter.add(9223372036854775807L, [("max.int64", "true")])  // Max Int64
  counter.add(-9223372036854775808L, [("min.int64", "true")]) // Min Int64
  
  histogram.record(1.7976931348623157e+308, [("max.double", "true")])  // Max Double
  histogram.record(4.9406564584124654e-324, [("min.double", "true")])  // Min Double
  
  up_down_counter.add(9223372036854775807L, [("max.updown", "true")])
  up_down_counter.add(-9223372036854775808L, [("min.updown", "true")])
  
  gauge.record(1.7976931348623157e+308, [("max.gauge", "true")])
  gauge.record(-1.7976931348623157e+308, [("min.gauge", "true")])
  
  // æµ‹è¯•ç‰¹æ®Šæ•°å€¼
  histogram.record(0.0, [("zero.value", "true")])
  histogram.record(Double::infinity, [("infinity.value", "true")])
  histogram.record(Double::neg_infinity, [("neg.infinity.value", "true")])
  histogram.record(Double::nan, [("nan.value", "true")])
  
  // éªŒè¯æå€¼å¤„ç†ä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_eq(long_name_span is trace::Span, true)
  assert_eq(counter is metrics::NoopCounter, true)
}

test "error_handling_invalid_operations" {
  // æµ‹è¯•æ— æ•ˆæ“ä½œå¤„ç†
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  
  let meter = meter_provider.get_meter("invalid-test")
  let logger = logger_provider.get_logger("invalid-test")
  
  // æµ‹è¯•è´Ÿæ•°Counter
  let counter = meter.create_counter("negative-test", "count", "Negative counter test")
  counter.add(-1, [("negative.add", "true")])  // Counteré€šå¸¸ä¸åº”è¯¥æ¥å—è´Ÿæ•°
  
  // æµ‹è¯•è´Ÿæ•°Histogram
  let histogram = meter.create_histogram("negative-histogram", "value", "Negative histogram test")
  histogram.record(-100.0, [("negative.record", "true")])  // Histogramé€šå¸¸ä¸åº”è¯¥æ¥å—è´Ÿæ•°
  
  // æµ‹è¯•æ— æ•ˆçš„ä¸¥é‡æ€§çº§åˆ«ï¼ˆé€šè¿‡ç›´æ¥æ„é€ LogRecordï¼‰
  let invalid_log = logs::LogRecord::builder()
    .severity(logs::Info)  // ä½¿ç”¨æœ‰æ•ˆçš„ä¸¥é‡æ€§çº§åˆ«ï¼Œä½†åœ¨çœŸå®å®ç°ä¸­å¯èƒ½æµ‹è¯•æ— æ•ˆå€¼
    .body("Test with potentially invalid data")
    .with_attribute("invalid.operation", "true")
    .build()
  
  logger.emit(invalid_log)
  
  // éªŒè¯æ— æ•ˆæ“ä½œä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_eq(counter is metrics::NoopCounter, true)
  assert_eq(histogram is metrics::NoopHistogram, true)
}

test "boundary_conditions_resource_limits" {
  // æµ‹è¯•èµ„æºé™åˆ¶è¾¹ç•Œæ¡ä»¶
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  
  // æµ‹è¯•å¤§é‡èµ„æºåˆ›å»º
  let resource_count = 10000
  
  // åˆ›å»ºå¤§é‡Tracer
  let mut i = 0
  while i < resource_count {
    let tracer = tracer_provider.get_tracer("stress-tracer-" + i.to_string())
    let ctx = context::Context::empty()
    let (_, _) = tracer.start_span(ctx, "stress-span", trace::Internal, [])
    i = i + 1
  }
  
  // åˆ›å»ºå¤§é‡Meterå’ŒæŒ‡æ ‡
  i = 0
  while i < resource_count {
    let meter = meter_provider.get_meter("stress-meter-" + i.to_string())
    let counter = meter.create_counter("stress-counter-" + i.to_string(), "count", "Stress test counter")
    let histogram = meter.create_histogram("stress-histogram-" + i.to_string(), "ms", "Stress test histogram")
    
    counter.add(1, [("stress.test", "true")])
    histogram.record(100.0, [("stress.test", "true")])
    i = i + 1
  }
  
  // åˆ›å»ºå¤§é‡Logger
  i = 0
  while i < resource_count {
    let logger = logger_provider.get_logger("stress-logger-" + i.to_string())
    logger.info("Stress test log message", [("logger.index", i.to_string())])
    i = i + 1
  }
  
  // éªŒè¯èµ„æºåˆ›å»ºå®Œæˆ
  assert_eq(i, resource_count)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let tracer = tracer_provider.get_tracer("many-attrs-tracer")
  let ctx = context::Context::empty()
  
  // åˆ›å»ºå¤§é‡å±æ€§
  let mut many_attributes = []
  i = 0
  while i < 1000 {  // 1000ä¸ªå±æ€§
    many_attributes.push(("attr_" + i.to_string(), "value_" + i.to_string()))
    i = i + 1
  }
  
  let (_, many_attrs_span) = tracer.start_span(
    ctx,
    "many-attributes-span",
    trace::Internal,
    many_attributes
  )
  
  // éªŒè¯å¤§é‡å±æ€§å¤„ç†
  assert_eq(many_attrs_span.attributes.length(), 1000)
}

test "boundary_conditions_context_edge_cases" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æ·±å±‚åµŒå¥—çš„ä¸Šä¸‹æ–‡
  let base_ctx = context::Context::empty()
  let mut deep_ctx = base_ctx
  
  // åˆ›å»º100å±‚åµŒå¥—çš„ä¸Šä¸‹æ–‡
  let mut i = 0
  while i < 100 {
    let key = context::create_key("level_" + i.to_string())
    deep_ctx = deep_ctx.with_value(key, "value_at_level_" + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯æ·±å±‚åµŒå¥—çš„å€¼å¯ä»¥æ­£ç¡®è·å–
  let deep_key = context::create_key("level_99")
  assert_eq(deep_ctx.get(deep_key).unwrap_or(""), "value_at_level_99")
  
  // éªŒè¯æµ…å±‚å€¼ä»ç„¶å­˜åœ¨
  let shallow_key = context::create_key("level_0")
  assert_eq(deep_ctx.get(shallow_key).unwrap_or(""), "value_at_level_0")
  
  // æµ‹è¯•å¤§é‡Baggageæ¡ç›®
  let base_baggage = context::Baggage::empty()
  let mut large_baggage = base_baggage
  
  // æ·»åŠ å¤§é‡æ¡ç›®
  i = 0
  while i < 5000 {  // 5000ä¸ªæ¡ç›®
    large_baggage = large_baggage.with_entry(
      "baggage_key_" + i.to_string(),
      "baggage_value_" + i.to_string()
    )
    i = i + 1
  }
  
  // éªŒè¯å¤§é‡Baggageæ¡ç›®çš„æŸ¥æ‰¾
  let first_key = "baggage_key_0"
  let last_key = "baggage_key_4999"
  let middle_key = "baggage_key_2500"
  
  assert_eq(large_baggage.get(first_key).unwrap_or(""), "baggage_value_0")
  assert_eq(large_baggage.get(last_key).unwrap_or(""), "baggage_value_4999")
  assert_eq(large_baggage.get(middle_key).unwrap_or(""), "baggage_value_2500")
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  assert_eq(large_baggage.get("nonexistent_key"), None)
}

test "error_handling_concurrent_access" {
  // æµ‹è¯•å¹¶å‘è®¿é—®é”™è¯¯å¤„ç†
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  
  // æ¨¡æ‹Ÿå¹¶å‘è®¿é—®ç›¸åŒçš„èµ„æº
  let shared_tracer = tracer_provider.get_tracer("shared-tracer")
  let shared_meter = meter_provider.get_meter("shared-meter")
  let shared_logger = logger_provider.get_logger("shared-logger")
  
  let shared_counter = shared_meter.create_counter("shared-counter", "count", "Shared counter")
  
  // æ¨¡æ‹Ÿå¤šä¸ª"çº¿ç¨‹"åŒæ—¶è®¿é—®
  let thread_count = 100
  let operations_per_thread = 100
  
  let mut i = 0
  while i < thread_count {
    let ctx = context::Context::empty()
    
    // æ¯ä¸ªçº¿ç¨‹æ‰§è¡Œæ“ä½œ
    let mut j = 0
    while j < operations_per_thread {
      // å¹¶å‘åˆ›å»ºSpan
      let (_, _) = shared_tracer.start_span(
        ctx,
        "concurrent-span-" + i.to_string() + "-" + j.to_string(),
        trace::Internal,
        [("thread", i.to_string()), ("operation", j.to_string())]
      )
      
      // å¹¶å‘æ›´æ–°Counter
      shared_counter.add(1, [("thread", i.to_string()), ("operation", j.to_string())])
      
      // å¹¶å‘è®°å½•æ—¥å¿—
      shared_logger.info(
        "Concurrent log message",
        [("thread", i.to_string()), ("operation", j.to_string())]
      )
      
      j = j + 1
    }
    i = i + 1
  }
  
  // éªŒè¯å¹¶å‘æ“ä½œå®Œæˆ
  assert_eq(i, thread_count)
}

test "error_handling_malformed_data" {
  // æµ‹è¯•æ ¼å¼é”™è¯¯æ•°æ®å¤„ç†
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  
  let tracer = tracer_provider.get_tracer("malformed-test")
  let meter = meter_provider.get_meter("malformed-test")
  let logger = logger_provider.get_logger("malformed-test")
  
  let ctx = context::Context::empty()
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~\\"
  let (_, special_span) = tracer.start_span(
    ctx,
    "span-with-special-chars-" + special_chars,
    trace::Internal,
    [("special.chars", special_chars)]
  )
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_text = "æµ‹è¯•ä¸­æ–‡ğŸš€emoji Ğ¸ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  let (_, unicode_span) = tracer.start_span(
    ctx,
    unicode_text,
    trace::Internal,
    [("unicode.text", unicode_text)]
  )
  
  // æµ‹è¯•æ§åˆ¶å­—ç¬¦
  let control_chars = "\n\r\t\u{0000}\u{0001}\u{001F}"
  let control_span_name = "control-chars-span" + control_chars
  let (_, control_span) = tracer.start_span(
    ctx,
    control_span_name,
    trace::Internal,
    [("control.chars", control_chars)]
  )
  
  // æµ‹è¯•è¶…é•¿å±æ€§é”®å’Œå€¼
  let long_key = "a".repeat(1000)
  let long_value = "b".repeat(10000)
  let (_, long_span) = tracer.start_span(
    ctx,
    "long-attrs-span",
    trace::Internal,
    [(long_key, long_value)]
  )
  
  // æµ‹è¯•æ ¼å¼é”™è¯¯çš„æ—¥å¿—è®°å½•
  let malformed_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("Malformed data test: " + special_chars + " " + unicode_text + " " + control_chars)
    .with_attribute(long_key, long_value)
    .with_attribute("special.chars", special_chars)
    .with_attribute("unicode.text", unicode_text)
    .build()
  
  logger.emit(malformed_log)
  
  // æµ‹è¯•æ ¼å¼é”™è¯¯çš„æŒ‡æ ‡
  let counter = meter.create_counter("malformed-counter", "count", "Malformed counter")
  counter.add(1, [
    (long_key, long_value),
    ("special.chars", special_chars),
    ("unicode.text", unicode_text)
  ])
  
  // éªŒè¯æ ¼å¼é”™è¯¯æ•°æ®å¤„ç†ä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_eq(special_span is trace::Span, true)
  assert_eq(unicode_span is trace::Span, true)
  assert_eq(control_span is trace::Span, true)
  assert_eq(long_span is trace::Span, true)
  assert_eq(counter is metrics::NoopCounter, true)
}

test "boundary_conditions_time_and_timestamps" {
  // æµ‹è¯•æ—¶é—´å’Œæ—¶é—´æˆ³è¾¹ç•Œæ¡ä»¶
  
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("time-boundary-test")
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let timestamps = [
    0L,  // Unixçºªå…ƒ
    9223372036854775807L,  // æœ€å¤§Int64çº³ç§’
    -9223372036854775808L,  // æœ€å°Int64çº³ç§’
    1640995200000000000L,  // 2022-01-01 00:00:00 UTC
    2534023007999999999L   // 9999-12-31 23:59:59.999999999 UTC
  ]
  
  let mut i = 0
  while i < timestamps.length() {
    let timestamp = timestamps[i]
    
    let log_record = logs::LogRecord::builder()
      .timestamp(timestamp)
      .severity(logs::Info)
      .body("Timestamp test: " + timestamp.to_string())
      .with_attribute("timestamp.value", timestamp.to_string())
      .with_attribute("timestamp.index", i.to_string())
      .build()
    
    logger.emit(log_record)
    i = i + 1
  }
  
  // æµ‹è¯•ç›¸åŒæ—¶é—´æˆ³çš„å¤šä¸ªæ—¥å¿—
  let same_timestamp = 1640995200000000000L
  i = 0
  while i < 1000 {
    let log_record = logs::LogRecord::builder()
      .timestamp(same_timestamp)
      .severity(logs::Info)
      .body("Same timestamp log " + i.to_string())
      .with_attribute("order", i.to_string())
      .build()
    
    logger.emit(log_record)
    i = i + 1
  }
  
  // éªŒè¯æ—¶é—´æˆ³è¾¹ç•Œæ¡ä»¶å¤„ç†
  assert_eq(i, 1000)
}

test "error_handling_recovery_and_resilience" {
  // æµ‹è¯•é”™è¯¯æ¢å¤å’Œå¼¹æ€§
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  
  // æ¨¡æ‹Ÿéƒ¨åˆ†å¤±è´¥åœºæ™¯
  
  // 1. åœ¨æ“ä½œè¿‡ç¨‹ä¸­é‡åˆ°é”™è¯¯ï¼Œä½†ç³»ç»Ÿåº”è¯¥ç»§ç»­å·¥ä½œ
  let tracer = tracer_provider.get_tracer("resilience-test")
  let meter = meter_provider.get_meter("resilience-test")
  let logger = logger_provider.get_logger("resilience-test")
  
  let ctx = context::Context::empty()
  let counter = meter.create_counter("resilience-counter", "count", "Resilience test counter")
  
  // æ­£å¸¸æ“ä½œ
  let mut i = 0
  while i < 100 {
    let (_, _) = tracer.start_span(ctx, "normal-span-" + i.to_string(), trace::Internal, [])
    counter.add(1, [("operation.type", "normal")])
    logger.info("Normal operation " + i.to_string(), [])
    i = i + 1
  }
  
  // æ¨¡æ‹Ÿé”™è¯¯æ“ä½œï¼ˆåœ¨çœŸå®å®ç°ä¸­å¯èƒ½è§¦å‘é”™è¯¯æ¡ä»¶ï¼‰
  i = 0
  while i < 50 {
    // ä½¿ç”¨å¯èƒ½å¯¼è‡´é—®é¢˜çš„å‚æ•°
    let error_span_name = ""  // ç©ºåç§°
    let error_attributes = [("", "")]  // ç©ºé”®å€¼å¯¹
    
    let (_, _) = tracer.start_span(ctx, error_span_name, trace::Internal, error_attributes)
    counter.add(1, [("operation.type", "error")])
    logger.info("", [("error.operation", "true")])  // ç©ºæ¶ˆæ¯
    
    i = i + 1
  }
  
  // éªŒè¯é”™è¯¯åç³»ç»Ÿä»èƒ½æ­£å¸¸å·¥ä½œ
  i = 0
  while i < 100 {
    let (_, _) = tracer.start_span(ctx, "recovery-span-" + i.to_string(), trace::Internal, [])
    counter.add(1, [("operation.type", "recovery")])
    logger.info("Recovery operation " + i.to_string(), [])
    i = i + 1
  }
  
  // éªŒè¯ç³»ç»Ÿå¼¹æ€§
  let total_operations = 100 + 50 + 100
  assert_eq(i, 100)  // æœ€åä¸€ä¸ªå¾ªç¯å®Œæˆ
  
  // åœ¨çœŸå®å®ç°ä¸­ï¼Œåº”è¯¥éªŒè¯ç³»ç»Ÿåœ¨é”™è¯¯åä»èƒ½æ­£å¸¸å·¥ä½œ
  // let error_rate = error_operations / total_operations
  // assert_eq(error_rate < max_acceptable_error_rate, true)
}