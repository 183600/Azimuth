// é”™è¯¯å¤„ç†è¾¹ç•Œæµ‹è¯• - æµ‹è¯•å„ç§å¼‚å¸¸è¾“å…¥å’Œè¾¹ç•Œæƒ…å†µ

test "attribute_value_extreme_cases" {
  // æµ‹è¯•AttributeValueçš„æç«¯æƒ…å†µ
  
  // æµ‹è¯•æé•¿çš„å­—ç¬¦ä¸²
  let long_string = "a" * 10000
  let long_attr = common::AttributeValue::string(long_string)
  match long_attr {
    common::StringValue(s) => assert_eq(s.length(), 10000)
    _ => @test.fail("Expected StringValue")
  }
  
  // æµ‹è¯•æå€¼æ•´æ•°
  let max_int = common::AttributeValue::int(9223372036854775807L)  // Int64æœ€å¤§å€¼
  let min_int = common::AttributeValue::int(-9223372036854775808L) // Int64æœ€å°å€¼
  
  match max_int {
    common::IntValue(i) => assert_eq(i, 9223372036854775807L)
    _ => @test.fail("Expected IntValue")
  }
  
  match min_int {
    common::IntValue(i) => assert_eq(i, -9223372036854775808L)
    _ => @test.fail("Expected IntValue")
  }
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°
  let max_float = common::AttributeValue::float(1.7976931348623157e+308)  // Doubleæœ€å¤§å€¼
  let min_float = common::AttributeValue::float(-1.7976931348623157e+308) // Doubleæœ€å°å€¼
  let inf_float = common::AttributeValue::float(1.0/0.0)  // æ— ç©·å¤§
  let neg_inf_float = common::AttributeValue::float(-1.0/0.0)  // è´Ÿæ— ç©·å¤§
  let nan_float = common::AttributeValue::float(0.0/0.0)  // NaN
  
  match max_float {
    common::FloatValue(f) => assert_eq(f, 1.7976931348623157e+308)
    _ => @test.fail("Expected FloatValue")
  }
  
  match inf_float {
    common::FloatValue(f) => assert_eq(f, 1.0/0.0)
    _ => @test.fail("Expected FloatValue")
  }
  
  match nan_float {
    common::FloatValue(f) => assert_eq(f, 0.0/0.0)
    _ => @test.fail("Expected FloatValue")
  }
  
  // æµ‹è¯•æå¤§çš„æ•°ç»„
  let large_string_array = common::AttributeValue::array_string(Array::make(1000, "item"))
  let large_int_array = common::AttributeValue::array_int(Array::make(1000, 1L))
  let large_float_array = common::AttributeValue::array_float(Array::make(1000, 1.0))
  let large_bool_array = common::AttributeValue::array_bool(Array::make(1000, true))
  
  match large_string_array {
    common::ArrayStringValue(arr) => assert_eq(arr.length(), 1000)
    _ => @test.fail("Expected ArrayStringValue")
  }
  
  match large_int_array {
    common::ArrayIntValue(arr) => assert_eq(arr.length(), 1000)
    _ => @test.fail("Expected ArrayIntValue")
  }
  
  match large_float_array {
    common::ArrayFloatValue(arr) => assert_eq(arr.length(), 1000)
    _ => @test.fail("Expected ArrayFloatValue")
  }
  
  match large_bool_array {
    common::ArrayBoolValue(arr) => assert_eq(arr.length(), 1000)
    _ => @test.fail("Expected ArrayBoolValue")
  }
}

test "context_edge_cases" {
  // æµ‹è¯•Contextçš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºé”®
  let empty_key = context::create_key("")
  let ctx = context::Context::empty()
  let ctx_with_empty_key = ctx.with_value(empty_key, "value")
  
  match ctx_with_empty_key.get(empty_key) {
    Some(value) => assert_eq(value, "value")
    None => @test.fail("Expected value for empty key")
  }
  
  // æµ‹è¯•æé•¿çš„é”®
  let long_key_name = "k" * 1000
  let long_key = context::create_key(long_key_name)
  let ctx_with_long_key = ctx.with_value(long_key, "long-key-value")
  
  match ctx_with_long_key.get(long_key) {
    Some(value) => assert_eq(value, "long-key-value")
    None => @test.fail("Expected value for long key")
  }
  
  // æµ‹è¯•æé•¿çš„å€¼
  let long_value = "v" * 10000
  let ctx_with_long_value = ctx.with_value(context::create_key("long-value"), long_value)
  
  match ctx_with_long_value.get(context::create_key("long-value")) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Expected long value")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_chars_key = context::create_key("!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let ctx_with_special = ctx.with_value(special_chars_key, "special-value")
  
  match ctx_with_special.get(special_chars_key) {
    Some(value) => assert_eq(value, "special-value")
    None => @test.fail("Expected value for special chars key")
  }
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = context::create_key("é”®æµ‹è¯•ğŸš€")
  let unicode_value = "å€¼æµ‹è¯•ğŸŒŸ"
  let ctx_with_unicode = ctx.with_value(unicode_key, unicode_value)
  
  match ctx_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_value)
    None => @test.fail("Expected Unicode value")
  }
  
  // æµ‹è¯•ç©ºå€¼
  let empty_value_key = context::create_key("empty-value")
  let ctx_with_empty_value = ctx.with_value(empty_value_key, "")
  
  match ctx_with_empty_value.get(empty_value_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty value")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  let nonexistent_key = context::create_key("nonexistent")
  match ctx.get(nonexistent_key) {
    Some(_) => @test.fail("Expected None for nonexistent key")
    None => assert_eq(true, true)
  }
}

test "baggage_boundary_conditions" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæ¡ä»¶
  
  let baggage = context::Baggage::empty()
  
  // æµ‹è¯•ç©ºé”®
  let baggage_with_empty_key = baggage.with_entry("", "value")
  match baggage_with_empty_key.get("") {
    Some(value) => assert_eq(value, "value")
    None => @test.fail("Expected value for empty key")
  }
  
  // æµ‹è¯•ç©ºå€¼
  let baggage_with_empty_value = baggage.with_entry("empty-value", "")
  match baggage_with_empty_value.get("empty-value") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty value")
  }
  
  // æµ‹è¯•æé•¿çš„é”®å’Œå€¼
  let long_key = "k" * 1000
  let long_value = "v" * 10000
  let baggage_with_long = baggage.with_entry(long_key, long_value)
  
  match baggage_with_long.get(long_key) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Expected long baggage value")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_key = "!@#$%^&*()"
  let special_value = "\\[]{}|;':\",./<>?"
  let baggage_with_special = baggage.with_entry(special_key, special_value)
  
  match baggage_with_special.get(special_key) {
    Some(value) => assert_eq(value, special_value)
    None => @test.fail("Expected special baggage value")
  }
  
  // æµ‹è¯•Unicode
  let unicode_key = "è¡ŒæğŸ§³"
  let unicode_value = "å€¼æµ‹è¯•ğŸŒŸ"
  let baggage_with_unicode = baggage.with_entry(unicode_key, unicode_value)
  
  match baggage_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_value)
    None => @test.fail("Expected Unicode baggage value")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  match baggage.get("nonexistent") {
    Some(_) => @test.fail("Expected None for nonexistent baggage key")
    None => assert_eq(true, true)
  }
}

test "log_record_extreme_values" {
  // æµ‹è¯•LogRecordçš„æç«¯å€¼
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let max_timestamp = 9223372036854775807L  // Int64æœ€å¤§å€¼
  let min_timestamp = -9223372036854775808L // Int64æœ€å°å€¼
  
  let log_with_max_time = logs::LogRecord::builder()
    .timestamp(max_timestamp)
    .severity(logs::Info)
    .body("Max timestamp test")
    .build()
  
  let log_with_min_time = logs::LogRecord::builder()
    .timestamp(min_timestamp)
    .severity(logs::Error)
    .body("Min timestamp test")
    .build()
  
  assert_eq(log_with_max_time.timestamp_unix_nanos, max_timestamp)
  assert_eq(log_with_min_time.timestamp_unix_nanos, min_timestamp)
  
  // æµ‹è¯•æé•¿çš„æ—¥å¿—æ¶ˆæ¯
  let long_body = "x" * 100000
  let log_with_long_body = logs::LogRecord::builder()
    .timestamp(1234567890L)
    .severity(logs::Debug)
    .body(long_body)
    .build()
  
  match log_with_long_body.body {
    Some(body) => assert_eq(body.length(), 100000)
    None => @test.fail("Expected long body")
  }
  
  // æµ‹è¯•ç©ºæ—¥å¿—æ¶ˆæ¯
  let log_with_empty_body = logs::LogRecord::builder()
    .timestamp(1234567890L)
    .severity(logs::Warn)
    .body("")
    .build()
  
  match log_with_empty_body.body {
    Some(body) => assert_eq(body, "")
    None => @test.fail("Expected empty body")
  }
  
  // æµ‹è¯•æ²¡æœ‰æ¶ˆæ¯çš„æ—¥å¿—
  let log_without_body = logs::LogRecord::builder()
    .timestamp(1234567890L)
    .severity(logs::Fatal)
    .build()
  
  match log_without_body.body {
    Some(_) => @test.fail("Expected None for body")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•æå¤šçš„å±æ€§
  let mut builder = logs::LogRecord::builder()
    .timestamp(1234567890L)
    .severity(logs::Info)
    .body("Many attributes test")
  
  let mut i = 0
  while i < 1000 {
    builder = builder.with_attribute(
      "attr." + i.to_string(),
      common::AttributeValue::string("value." + i.to_string())
    )
    i = i + 1
  }
  
  let log_with_many_attrs = builder.build()
  assert_eq(log_with_many_attrs.attributes.length(), 1000)
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡çº§åˆ«
  let trace_log = logs::LogRecord::builder().severity(logs::Trace).build()
  let debug_log = logs::LogRecord::builder().severity(logs::Debug).build()
  let info_log = logs::LogRecord::builder().severity(logs::Info).build()
  let warn_log = logs::LogRecord::builder().severity(logs::Warn).build()
  let error_log = logs::LogRecord::builder().severity(logs::Error).build()
  let fatal_log = logs::LogRecord::builder().severity(logs::Fatal).build()
  
  match trace_log.severity_number { logs::Trace => assert_eq(true, true) _ => @test.fail("Expected Trace") }
  match debug_log.severity_number { logs::Debug => assert_eq(true, true) _ => @test.fail("Expected Debug") }
  match info_log.severity_number { logs::Info => assert_eq(true, true) _ => @test.fail("Expected Info") }
  match warn_log.severity_number { logs::Warn => assert_eq(true, true) _ => @test.fail("Expected Warn") }
  match error_log.severity_number { logs::Error => assert_eq(true, true) _ => @test.fail("Expected Error") }
  match fatal_log.severity_number { logs::Fatal => assert_eq(true, true) _ => @test.fail("Expected Fatal") }
}

test "span_extreme_conditions" {
  // æµ‹è¯•Spançš„æç«¯æ¡ä»¶
  
  let ctx = context::Context::empty()
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("extreme-test-tracer")
  
  // æµ‹è¯•æé•¿çš„spanåç§°
  let long_span_name = "s" * 10000
  let (ctx1, span_with_long_name) = tracer.start_span(ctx, long_span_name, trace::Internal)
  assert_eq(span_with_long_name.name.length(), 10000)
  
  // æµ‹è¯•ç©ºspanåç§°
  let (ctx2, span_with_empty_name) = tracer.start_span(ctx, "", trace::Server)
  assert_eq(span_with_empty_name.name, "")
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦spanåç§°
  let special_span_name = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let (ctx3, span_with_special_name) = tracer.start_span(ctx, special_span_name, trace::Client)
  assert_eq(span_with_special_name.name, special_span_name)
  
  // æµ‹è¯•Unicode spanåç§°
  let unicode_span_name = "Spanæµ‹è¯•ğŸš€"
  let (ctx4, span_with_unicode_name) = tracer.start_span(ctx, unicode_span_name, trace::Producer)
  assert_eq(span_with_unicode_name.name, unicode_span_name)
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let max_time = 9223372036854775807L
  let min_time = -9223372036854775808L
  
  let (ctx5, span_with_max_time) = tracer.start_span(ctx, "max-time", trace::Consumer, [], Some(max_time))
  let (ctx6, span_with_min_time) = tracer.start_span(ctx, "min-time", trace::Internal, [], Some(min_time))
  
  assert_eq(span_with_max_time.start_time_unix_nanos, max_time)
  assert_eq(span_with_min_time.start_time_unix_nanos, min_time)
  
  // æµ‹è¯•æ‰€æœ‰SpanKind
  let (ctx7, internal_span) = tracer.start_span(ctx, "internal", trace::Internal)
  let (ctx8, server_span) = tracer.start_span(ctx, "server", trace::Server)
  let (ctx9, client_span) = tracer.start_span(ctx, "client", trace::Client)
  let (ctx10, producer_span) = tracer.start_span(ctx, "producer", trace::Producer)
  let (ctx11, consumer_span) = tracer.start_span(ctx, "consumer", trace::Consumer)
  
  match internal_span.kind { trace::Internal => assert_eq(true, true) _ => @test.fail("Expected Internal") }
  match server_span.kind { trace::Server => assert_eq(true, true) _ => @test.fail("Expected Server") }
  match client_span.kind { trace::Client => assert_eq(true, true) _ => @test.fail("Expected Client") }
  match producer_span.kind { trace::Producer => assert_eq(true, true) _ => @test.fail("Expected Producer") }
  match consumer_span.kind { trace::Consumer => assert_eq(true, true) _ => @test.fail("Expected Consumer") }
  
  // æµ‹è¯•æå¤šçš„å±æ€§
  let mut extreme_attrs : Array[(String, common::AttributeValue)] = []
  let mut i = 0
  while i < 1000 {
    extreme_attrs.push(("extreme.attr." + i.to_string(), common::AttributeValue::string("value." + i.to_string())))
    i = i + 1
  }
  
  let (ctx12, span_with_extreme_attrs) = tracer.start_span(ctx, "extreme-attrs", trace::Internal, extreme_attrs)
  assert_eq(span_with_extreme_attrs.attributes.length(), 1000)
}

test "metrics_boundary_test" {
  // æµ‹è¯•Metricsçš„è¾¹ç•Œæ¡ä»¶
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("boundary-test-meter")
  
  // æµ‹è¯•æé•¿çš„ä»ªå™¨åç§°
  let long_counter_name = "c" * 1000
  let long_histogram_name = "h" * 1000
  let long_gauge_name = "g" * 1000
  let long_up_down_name = "u" * 1000
  
  let long_counter = meter.create_counter(long_counter_name, "count", "Long counter name test")
  let long_histogram = meter.create_histogram(long_histogram_name, "ms", "Long histogram name test")
  let long_gauge = meter.create_gauge(long_gauge_name, "percent", "Long gauge name test")
  let long_up_down = meter.create_up_down_counter(long_up_down_name, "count", "Long up-down counter name test")
  
  // æµ‹è¯•ç©ºä»ªå™¨åç§°
  let empty_counter = meter.create_counter("", "count", "Empty counter name test")
  let empty_histogram = meter.create_histogram("", "ms", "Empty histogram name test")
  let empty_gauge = meter.create_gauge("", "percent", "Empty gauge name test")
  let empty_up_down = meter.create_up_down_counter("", "count", "Empty up-down counter name test")
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ä»ªå™¨åç§°
  let special_counter_name = "!@#$%^&*()"
  let special_counter = meter.create_counter(special_counter_name, "count", "Special counter name test")
  
  // æµ‹è¯•Unicodeä»ªå™¨åç§°
  let unicode_counter_name = "è®¡æ•°å™¨æµ‹è¯•ğŸš€"
  let unicode_counter = meter.create_counter(unicode_counter_name, "count", "Unicode counter name test")
  
  // æµ‹è¯•æå€¼
  let max_int_value = 9223372036854775807L
  let min_int_value = -9223372036854775808L
  let max_float_value = 1.7976931348623157e+308
  let min_float_value = -1.7976931348623157e+308
  let inf_float_value = 1.0/0.0
  let nan_float_value = 0.0/0.0
  
  // æµ‹è¯•Counteræå€¼
  long_counter.add(max_int_value)
  long_counter.add(min_int_value)
  empty_counter.add(max_int_value)
  special_counter.add(min_int_value)
  unicode_counter.add(0L)
  
  // æµ‹è¯•Histogramæå€¼
  long_histogram.record(max_float_value)
  long_histogram.record(min_float_value)
  long_histogram.record(inf_float_value)
  long_histogram.record(nan_float_value)
  
  // æµ‹è¯•Gaugeæå€¼
  long_gauge.record(max_float_value)
  long_gauge.record(min_float_value)
  long_gauge.record(inf_float_value)
  
  // æµ‹è¯•UpDownCounteræå€¼
  long_up_down.add(max_int_value)
  long_up_down.add(min_int_value)
  
  // æµ‹è¯•æå¤šçš„å±æ€§
  let mut extreme_attrs : Array[(String, common::AttributeValue)] = []
  let mut i = 0
  while i < 1000 {
    extreme_attrs.push(("metric.attr." + i.to_string(), common::AttributeValue::string("value." + i.to_string())))
    i = i + 1
  }
  
  long_counter.add(1L, extreme_attrs)
  long_histogram.record(100.0, extreme_attrs)
  long_gauge.record(50.0, extreme_attrs)
  long_up_down.add(1L, extreme_attrs)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½ä¸ä¼šå¤±è´¥ï¼ˆno-opå®ç°ï¼‰
  assert_eq(true, true)
}

test "propagation_error_conditions" {
  // æµ‹è¯•ä¼ æ’­çš„é”™è¯¯æ¡ä»¶
  
  let carrier = propagation::MapCarrier::new()
  let ctx = context::Context::empty()
  
  // æµ‹è¯•ç©ºçš„carrier
  let empty_carrier = propagation::MapCarrier::new()
  let trace_propagator = propagation::W3CTraceContextPropagator::{}
  let baggage_propagator = propagation::W3CBaggagePropagator::{}
  
  // ä»ç©ºcarrieræå–åº”è¯¥è¿”å›åŸå§‹context
  let extracted_from_empty = trace_propagator.extract(ctx, empty_carrier)
  let baggage_from_empty = baggage_propagator.extract(ctx, empty_carrier)
  
  // éªŒè¯æ“ä½œä¸ä¼šå¤±è´¥
  assert_eq(true, true)
  
  // æµ‹è¯•åŒ…å«æ— æ•ˆå€¼çš„carrier
  let carrier_with_data = propagation::MapCarrier::from_map([
    (propagation::TRACE_PARENT_HEADER, "invalid-traceparent"),
    (propagation::BAGGAGE_HEADER, "invalid=baggage=value"),
    ("invalid-header", "some-value")
  ])
  
  // ä»åŒ…å«æ— æ•ˆæ•°æ®çš„carrieræå–
  let extracted_from_invalid = trace_propagator.extract(ctx, carrier_with_data)
  let baggage_from_invalid = baggage_propagator.extract(ctx, carrier_with_data)
  
  // éªŒè¯æ“ä½œä¸ä¼šå¤±è´¥
  assert_eq(true, true)
  
  // æµ‹è¯•åŒ…å«æé•¿å€¼çš„carrier
  let very_long_value = "v" * 100000
  let carrier_with_long_value = propagation::MapCarrier::from_map([
    (propagation::TRACE_PARENT_HEADER, very_long_value),
    (propagation::BAGGAGE_HEADER, very_long_value)
  ])
  
  // ä»åŒ…å«æé•¿å€¼çš„carrieræå–
  let extracted_from_long = trace_propagator.extract(ctx, carrier_with_long_value)
  let baggage_from_long = baggage_propagator.extract(ctx, carrier_with_long_value)
  
  // éªŒè¯æ“ä½œä¸ä¼šå¤±è´¥
  assert_eq(true, true)
  
  // æµ‹è¯•å¤åˆä¼ æ’­å™¨çš„é”™è¯¯å¤„ç†
  let composite = propagation::CompositePropagator::new([trace_propagator, baggage_propagator])
  
  // ä½¿ç”¨å„ç§æœ‰é—®é¢˜çš„carrier
  let extracted_composite_empty = composite.extract(ctx, empty_carrier)
  let extracted_composite_invalid = composite.extract(ctx, carrier_with_data)
  let extracted_composite_long = composite.extract(ctx, carrier_with_long_value)
  
  // éªŒè¯å¤åˆæ“ä½œä¸ä¼šå¤±è´¥
  assert_eq(true, true)
}