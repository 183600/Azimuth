// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µæµ‹è¯•ç”¨ä¾‹
test "attribute_value_extreme_values" {
  // æµ‹è¯•AttributeValueçš„æå€¼å¤„ç†
  
  // å­—ç¬¦ä¸²æå€¼
  let empty_string = AttributeValue::string("")
  let very_long_string = AttributeValue::string("a" * 10000)  // å‡è®¾æ”¯æŒå­—ç¬¦ä¸²é‡å¤
  let unicode_string = AttributeValue::string("Unicodeæµ‹è¯•ğŸš€ğŸŒŸğŸ’ğŸ¯")
  let special_chars_string = AttributeValue::string("!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  match empty_string {
    StringValue(s) => assert_eq(s, "")
    _ => @test.fail("Expected empty string")
  }
  
  match very_long_string {
    StringValue(s) => assert_eq(s.length(), 10000)
    _ => @test.fail("Expected very long string")
  }
  
  match unicode_string {
    StringValue(s) => assert_eq(s, "Unicodeæµ‹è¯•ğŸš€ğŸŒŸğŸ’ğŸ¯")
    _ => @test.fail("Expected unicode string")
  }
  
  match special_chars_string {
    StringValue(s) => assert_eq(s, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
    _ => @test.fail("Expected special characters string")
  }
  
  // æ•´æ•°æå€¼
  let zero_int = AttributeValue::int(0L)
  let max_int = AttributeValue::int(9223372036854775807L)
  let min_int = AttributeValue::int(-9223372036854775808L)
  let negative_int = AttributeValue::int(-1L)
  
  match zero_int {
    IntValue(i) => assert_eq(i, 0L)
    _ => @test.fail("Expected zero integer")
  }
  
  match max_int {
    IntValue(i) => assert_eq(i, 9223372036854775807L)
    _ => @test.fail("Expected max integer")
  }
  
  match min_int {
    IntValue(i) => assert_eq(i, -9223372036854775808L)
    _ => @test.fail("Expected min integer")
  }
  
  match negative_int {
    IntValue(i) => assert_eq(i, -1L)
    _ => @test.fail("Expected negative integer")
  }
  
  // æµ®ç‚¹æ•°æå€¼
  let zero_float = AttributeValue::float(0.0)
  let positive_inf = AttributeValue::float(1.0/0.0)
  let negative_inf = AttributeValue::float(-1.0/0.0)
  let nan_float = AttributeValue::float(0.0/0.0)
  let very_small_float = AttributeValue::float(1e-308)
  let very_large_float = AttributeValue::float(1e+308)
  
  match zero_float {
    FloatValue(f) => assert_eq(f, 0.0)
    _ => @test.fail("Expected zero float")
  }
  
  match positive_inf {
    FloatValue(f) => assert_eq(f, 1.0/0.0)  // Infinity
    _ => @test.fail("Expected positive infinity")
  }
  
  match negative_inf {
    FloatValue(f) => assert_eq(f, -1.0/0.0)  // -Infinity
    _ => @test.fail("Expected negative infinity")
  }
  
  match nan_float {
    FloatValue(f) => assert_eq(f, 0.0/0.0)  // NaN
    _ => @test.fail("Expected NaN")
  }
  
  // å¸ƒå°”å€¼
  let true_bool = AttributeValue::bool(true)
  let false_bool = AttributeValue::bool(false)
  
  match true_bool {
    BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("Expected true boolean")
  }
  
  match false_bool {
    BoolValue(b) => assert_eq(b, false)
    _ => @test.fail("Expected false boolean")
  }
}

test "array_attribute_edge_cases" {
  // æµ‹è¯•æ•°ç»„å±æ€§çš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºæ•°ç»„
  let empty_string_array = AttributeValue::array_string([])
  let empty_int_array = AttributeValue::array_int([])
  let empty_float_array = AttributeValue::array_float([])
  let empty_bool_array = AttributeValue::array_bool([])
  
  match empty_string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty string array")
  }
  
  match empty_int_array {
    ArrayIntValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty int array")
  }
  
  match empty_float_array {
    ArrayFloatValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty float array")
  }
  
  match empty_bool_array {
    ArrayBoolValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected empty bool array")
  }
  
  // å•å…ƒç´ æ•°ç»„
  let single_string_array = AttributeValue::array_string(["single"])
  let single_int_array = AttributeValue::array_int([42L])
  let single_float_array = AttributeValue::array_float([3.14])
  let single_bool_array = AttributeValue::array_bool([true])
  
  match single_string_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], "single")
    }
    _ => @test.fail("Expected single string array")
  }
  
  match single_int_array {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], 42L)
    }
    _ => @test.fail("Expected single int array")
  }
  
  match single_float_array {
    ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], 3.14)
    }
    _ => @test.fail("Expected single float array")
  }
  
  match single_bool_array {
    ArrayBoolValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], true)
    }
    _ => @test.fail("Expected single bool array")
  }
  
  // å¤§æ•°ç»„
  let large_string_array = AttributeValue::array_string(["item" + i.to_string() | i <- 0..999])  // 1000ä¸ªå…ƒç´ 
  let large_int_array = AttributeValue::array_int([i | i <- 0..999])  // 1000ä¸ªå…ƒç´ 
  
  match large_string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 1000)
    _ => @test.fail("Expected large string array")
  }
  
  match large_int_array {
    ArrayIntValue(arr) => assert_eq(arr.length(), 1000)
    _ => @test.fail("Expected large int array")
  }
  
  // åŒ…å«æå€¼çš„æ•°ç»„
  let extreme_int_array = AttributeValue::array_int([
    0L, 1L, -1L, 9223372036854775807L, -9223372036854775808L
  ])
  let extreme_float_array = AttributeValue::array_float([
    0.0, 1.0, -1.0, 1.0/0.0, -1.0/0.0, 0.0/0.0, 1e-308, 1e+308
  ])
  
  match extreme_int_array {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 5)
      assert_eq(arr[0], 0L)
      assert_eq(arr[1], 1L)
      assert_eq(arr[2], -1L)
      assert_eq(arr[3], 9223372036854775807L)
      assert_eq(arr[4], -9223372036854775808L)
    }
    _ => @test.fail("Expected extreme int array")
  }
  
  match extreme_float_array {
    ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 8)
      assert_eq(arr[0], 0.0)
      assert_eq(arr[1], 1.0)
      assert_eq(arr[2], -1.0)
      assert_eq(arr[3], 1.0/0.0)
      assert_eq(arr[4], -1.0/0.0)
      assert_eq(arr[5], 0.0/0.0)
      assert_eq(arr[6], 1e-308)
      assert_eq(arr[7], 1e+308)
    }
    _ => @test.fail("Expected extreme float array")
  }
}

test "context_edge_cases_and_error_handling" {
  // æµ‹è¯•Contextçš„è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯å¤„ç†
  
  // ç©ºContext
  let empty_ctx = Context::empty()
  let nonexistent_key = create_key("nonexistent.key")
  
  match empty_ctx.get(nonexistent_key) {
    Some(_) => @test.fail("Expected None for nonexistent key in empty context")
    None => assert_eq(true, true)
  }
  
  // å¤§é‡é”®å€¼å¯¹
  let ctx_with_many_values = { 
    let mut ctx = Context::empty()
    let mut i = 0
    while i < 1000 {
      ctx = ctx.with_value(create_key("key" + i.to_string()), "value" + i.to_string())
      i = i + 1
    }
    ctx
  }
  
  // éªŒè¯å¤§é‡é”®å€¼å¯¹
  match ctx_with_many_values.get(create_key("key0")) {
    Some(value) => assert_eq(value, "value0")
    None => @test.fail("Expected key0 to be found")
  }
  
  match ctx_with_many_values.get(create_key("key999")) {
    Some(value) => assert_eq(value, "value999")
    None => @test.fail("Expected key999 to be found")
  }
  
  match ctx_with_many_values.get(create_key("key1000")) {
    Some(_) => @test.fail("Expected None for key1000")
    None => assert_eq(true, true)
  }
  
  // ç‰¹æ®Šé”®å
  let special_keys = [
    ("", "empty key"),
    (" ", "space key"),
    ("key.with.dots", "dotted key"),
    ("key/with/slashes", "slashed key"),
    ("key with spaces", "spaced key"),
    ("special!@#$%^&*()chars", "special chars key"),
    ("Unicodeé”®æµ‹è¯•ğŸš€", "Unicode key"),
    ("key\nwith\nnewlines", "newline key"),
    ("key\twith\ttabs", "tab key")
  ]
  
  let ctx_with_special_keys = {
    let mut ctx = Context::empty()
    let mut i = 0
    while i < special_keys.length() {
      let (key_name, key_value) = special_keys[i]
      ctx = ctx.with_value(create_key(key_name), key_value)
      i = i + 1
    }
    ctx
  }
  
  // éªŒè¯ç‰¹æ®Šé”®å
  let mut i = 0
  while i < special_keys.length() {
    let (key_name, key_value) = special_keys[i]
    match ctx_with_special_keys.get(create_key(key_name)) {
      Some(value) => assert_eq(value, key_value)
      None => @test.fail("Expected special key to be found: " + key_name)
    }
    i = i + 1
  }
  
  // ç›¸åŒé”®åçš„å¤šæ¬¡è¦†ç›–
  let same_key = create_key("same.key")
  let ctx_with_overrides = {
    let mut ctx = Context::empty()
    let mut i = 0
    while i < 100 {
      ctx = ctx.with_value(same_key, "value" + i.to_string())
      i = i + 1
    }
    ctx
  }
  
  // éªŒè¯æœ€ç»ˆå€¼
  match ctx_with_overrides.get(same_key) {
    Some(value) => assert_eq(value, "value99")
    None => @test.fail("Expected final override value")
  }
}

test "span_context_edge_cases" {
  // æµ‹è¯•SpanContextçš„è¾¹ç•Œæƒ…å†µ
  
  // å…¨é›¶SpanContext
  let zero_span_context = SpanContext::{
    trace_id: Array::make(16, 0_byte),
    span_id: Array::make(8, 0_byte),
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  assert_eq(zero_span_context.trace_id.length(), 16)
  assert_eq(zero_span_context.span_id.length(), 8)
  assert_eq(zero_span_context.trace_flags, 0_byte)
  assert_eq(zero_span_context.trace_state, "")
  
  // æœ€å¤§å€¼SpanContext
  let max_span_context = SpanContext::{
    trace_id: Array::make(16, 255_byte),
    span_id: Array::make(8, 255_byte),
    trace_flags: 255_byte,
    trace_state: "key1=value1,key2=value2,key3=value3"
  }
  
  assert_eq(max_span_context.trace_id.length(), 16)
  assert_eq(max_span_context.span_id.length(), 8)
  assert_eq(max_span_context.trace_flags, 255_byte)
  assert_eq(max_span_context.trace_state, "key1=value1,key2=value2,key3=value3")
  
  // å¤æ‚trace_state
  let complex_trace_state = "vendor1=value1,vendor2=value2 with spaces,vendor3=value3!@#$%^&*(),vendor4=Unicodeå€¼æµ‹è¯•ğŸš€"
  let complex_span_context = SpanContext::{
    trace_id: Array::make(16, 128_byte),
    span_id: Array::make(8, 128_byte),
    trace_flags: 1_byte,
    trace_state: complex_trace_state
  }
  
  assert_eq(complex_span_context.trace_state, complex_trace_state)
  
  // éªŒè¯trace_idå’Œspan_idçš„å…·ä½“å­—èŠ‚
  let mut i = 0
  while i < 16 {
    assert_eq(zero_span_context.trace_id[i], 0_byte)
    assert_eq(max_span_context.trace_id[i], 255_byte)
    assert_eq(complex_span_context.trace_id[i], 128_byte)
    i = i + 1
  }
  
  let mut i = 0
  while i < 8 {
    assert_eq(zero_span_context.span_id[i], 0_byte)
    assert_eq(max_span_context.span_id[i], 255_byte)
    assert_eq(complex_span_context.span_id[i], 128_byte)
    i = i + 1
  }
}

test "propagation_error_scenarios" {
  // æµ‹è¯•ä¼ æ’­çš„é”™è¯¯åœºæ™¯
  
  // æ— æ•ˆçš„traceparentæ ¼å¼
  let invalid_trace_parents = [
    "",  // ç©ºå­—ç¬¦ä¸²
    "invalid-format",  // æ— æ•ˆæ ¼å¼
    "01-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331",  // ç¼ºå°‘trace_flags
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01-extra",  // é¢å¤–éƒ¨åˆ†
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-XX",  // æ— æ•ˆtrace_flags
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b71692033",  // span_idå¤ªçŸ­
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // æ­£ç¡®æ ¼å¼ï¼ˆç”¨äºå¯¹æ¯”ï¼‰
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // é‡å¤çš„æ­£ç¡®æ ¼å¼
    "ff-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"   // ä¸åŒç‰ˆæœ¬
  ]
  
  let ctx = Context::empty()
  let propagator = W3CTraceContextPropagator::{}
  
  let mut i = 0
  while i < invalid_trace_parents.length() {
    let invalid_trace_parent = invalid_trace_parents[i]
    let carrier_data = [(TRACE_PARENT_HEADER, invalid_trace_parent)]
    let carrier = MapCarrier::from_map(carrier_data)
    
    // å³ä½¿æ ¼å¼æ— æ•ˆï¼Œæå–æ“ä½œä¹Ÿä¸åº”è¯¥å´©æºƒ
    let extracted_ctx = propagator.extract(ctx, carrier)
    assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒå°±ç®—é€šè¿‡
    
    i = i + 1
  }
  
  // æ— æ•ˆçš„baggageæ ¼å¼
  let invalid_baggages = [
    "",  // ç©ºå­—ç¬¦ä¸²
    "invalid",  // æ— æ•ˆæ ¼å¼ï¼ˆæ²¡æœ‰=ï¼‰
    "key=",  // ç©ºå€¼
    "=value",  // ç©ºé”®
    "key=value=extra",  // å¤šä¸ªç­‰å·
    "key=value,invalid",  // æ··åˆæ ¼å¼
    "key=value,key2=",  // æ··åˆæœ‰æ•ˆå’Œæ— æ•ˆ
    "key=value,key2=value2,invalid"  // å¤šä¸ªæ¡ç›®ä¸­æœ‰æ— æ•ˆçš„
  ]
  
  let baggage_propagator = W3CBaggagePropagator::{}
  
  let mut i = 0
  while i < invalid_baggages.length() {
    let invalid_baggage = invalid_baggages[i]
    let carrier_data = [(BAGGAGE_HEADER, invalid_baggage)]
    let carrier = MapCarrier::from_map(carrier_data)
    
    // å³ä½¿æ ¼å¼æ— æ•ˆï¼Œæå–æ“ä½œä¹Ÿä¸åº”è¯¥å´©æºƒ
    let extracted_ctx = baggage_propagator.extract(ctx, carrier)
    assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒå°±ç®—é€šè¿‡
    
    i = i + 1
  }
  
  // MapCarrieré”™è¯¯åœºæ™¯
  let error_carrier_data = [
    ("", ""),  // ç©ºé”®å’Œå€¼
    ("key", ""),  // ç©ºå€¼
    ("", "value"),  // ç©ºé”®
    ("special/key/with/special.chars", "ç‰¹æ®Šå€¼!@#$%^&*()"),  // ç‰¹æ®Šå­—ç¬¦
    ("Unicodeé”®æµ‹è¯•ğŸš€", "Unicodeå€¼æµ‹è¯•ğŸŒŸ"),  // Unicodeå­—ç¬¦
    ("key\nwith\nnewlines", "value\nwith\nnewlines"),  // æ¢è¡Œç¬¦
    ("key\twith\ttabs", "value\twith\ttabs")  // åˆ¶è¡¨ç¬¦
  ]
  
  let error_carrier = MapCarrier::from_map(error_carrier_data)
  
  // éªŒè¯æ‰€æœ‰é”®éƒ½å¯ä»¥è®¿é—®
  let mut i = 0
  while i < error_carrier_data.length() {
    let (key, expected_value) = error_carrier_data[i]
    match error_carrier.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Expected error carrier key to be found: " + key)
    }
    i = i + 1
  }
  
  // éªŒè¯keysæ“ä½œ
  let keys = error_carrier.keys()
  assert_eq(keys.length(), error_carrier_data.length())
}

test "resource_and_instrumentation_scope_edge_cases" {
  // æµ‹è¯•Resourceå’ŒInstrumentationScopeçš„è¾¹ç•Œæƒ…å†µ
  
  // æç«¯æœåŠ¡åç§°
  let extreme_service_names = [
    "",  // ç©ºå­—ç¬¦ä¸²
    " ",  // ç©ºæ ¼
    "a",  // å•å­—ç¬¦
    "service.with.dots",  // åŒ…å«ç‚¹
    "service/with/slashes",  // åŒ…å«æ–œæ 
    "service with spaces",  // åŒ…å«ç©ºæ ¼
    "service!@#$%^&*()with+special-chars",  // ç‰¹æ®Šå­—ç¬¦
    "UnicodeæœåŠ¡æµ‹è¯•ğŸš€",  // Unicodeå­—ç¬¦
    "service\nwith\nnewlines",  // æ¢è¡Œç¬¦
    "service\twith\ttabs",  // åˆ¶è¡¨ç¬¦
    "a" * 1000  // é•¿å­—ç¬¦ä¸²
  ]
  
  let mut i = 0
  while i < extreme_service_names.length() {
    let service_name = extreme_service_names[i]
    let resource = Resource::default(service_name)
    
    assert_eq(resource.service_name, service_name)
    assert_eq(resource.telemetry_sdk_name, "azimuth")
    assert_eq(resource.telemetry_sdk_version, "0.1.0")
    
    i = i + 1
  }
  
  // å¤æ‚å±æ€§ç»„åˆ
  let complex_attrs : Attributes = [
    ("", AttributeValue::string("empty key")),  // ç©ºé”®
    ("empty.value", AttributeValue::string("")),  // ç©ºå€¼
    ("special.chars.key", AttributeValue::string("!@#$%^&*()")),  // ç‰¹æ®Šå­—ç¬¦
    ("Unicode.key.æµ‹è¯•", AttributeValue::string("Unicodeå€¼æµ‹è¯•ğŸš€")),  // Unicode
    ("key.with.dots", AttributeValue::string("dotted.value")),  // ç‚¹å·
    ("key/with/slashes", AttributeValue::string("slashed.value")),  // æ–œæ 
    ("key with spaces", AttributeValue::string("spaced.value")),  // ç©ºæ ¼
    ("multiline.key", AttributeValue::string("value\nwith\nnewlines")),  // å¤šè¡Œ
    ("tab.key", AttributeValue::string("value\twith\ttabs")),  // åˆ¶è¡¨ç¬¦
    ("very.long.key.name.that.exceeds.normal.expectations.and.tests.boundary.conditions", AttributeValue::string("long key")),  // é•¿é”®å
    ("array.value", AttributeValue::array_string(["item1", "item2", "item3"])),  // æ•°ç»„å€¼
    ("nested.value", AttributeValue::string("value.with.nested.structure")),  // åµŒå¥—ç»“æ„
    ("numeric.key.123", AttributeValue::string("numeric.key")),  // æ•°å­—é”®å
    ("mixed.case.KEY", AttributeValue::string("Mixed.Case.Value"))  // å¤§å°å†™æ··åˆ
  ]
  
  // éªŒè¯å¤æ‚å±æ€§
  assert_eq(complex_attrs.length(), 14)
  
  // éªŒè¯ç‰¹å®šå±æ€§
  match complex_attrs[0].1 {
    AttributeValue::StringValue(value) => assert_eq(value, "empty key")
    _ => @test.fail("Expected StringValue for empty key")
  }
  
  match complex_attrs[1].1 {
    AttributeValue::StringValue(value) => assert_eq(value, "")
    _ => @test.fail("Expected StringValue for empty value")
  }
  
  match complex_attrs[10].1 {
    AttributeValue::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], "item1")
      assert_eq(arr[1], "item2")
      assert_eq(arr[2], "item3")
    }
    _ => @test.fail("Expected ArrayStringValue for array.value")
  }
}