// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µæµ‹è¯• - æµ‹è¯•å¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸º
// éªŒè¯é¥æµ‹åº“åœ¨è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µä¸‹çš„å¥å£®æ€§

test "attribute_value_edge_cases" {
  // æµ‹è¯•AttributeValueçš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºå€¼å’Œæå€¼
  let empty_string = common::AttributeValue::string("")
  let max_int = common::AttributeValue::int(9223372036854775807L)
  let min_int = common::AttributeValue::int(-9223372036854775808L)
  let zero_float = common::AttributeValue::float(0.0)
  let infinity_float = common::AttributeValue::float(1.0/0.0)
  let negative_infinity = common::AttributeValue::float(-1.0/0.0)
  let nan_float = common::AttributeValue::float(0.0/0.0)
  
  // éªŒè¯è¾¹ç•Œå€¼åˆ›å»º
  assert_eq(empty_string is common::StringValue, true)
  assert_eq(max_int is common::IntValue, true)
  assert_eq(min_int is common::IntValue, true)
  assert_eq(zero_float is common::FloatValue, true)
  assert_eq(infinity_float is common::FloatValue, true)
  assert_eq(negative_infinity is common::FloatValue, true)
  assert_eq(nan_float is common::FloatValue, true)
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = common::AttributeValue::array_string([])
  let empty_int_array = common::AttributeValue::array_int([])
  let empty_float_array = common::AttributeValue::array_float([])
  let empty_bool_array = common::AttributeValue::array_bool([])
  
  assert_eq(empty_string_array is common::ArrayStringValue, true)
  assert_eq(empty_int_array is common::ArrayIntValue, true)
  assert_eq(empty_float_array is common::ArrayFloatValue, true)
  assert_eq(empty_bool_array is common::ArrayBoolValue, true)
  
  // éªŒè¯ç©ºæ•°ç»„é•¿åº¦
  match empty_string_array {
    common::ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Empty string array test failed")
  }
}

test "context_boundary_conditions" {
  // æµ‹è¯•Contextçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•ç©ºContext
  let empty_ctx = context::Context::empty()
  let empty_key = context::create_key("")
  let test_key = context::create_key("test-key")
  
  // éªŒè¯ç©ºContextè¡Œä¸º
  match empty_ctx.get(test_key) {
    Some(_) => @test.fail("Should not find value in empty context")
    None => assert_eq(true, true)  // é¢„æœŸè¡Œä¸º
  }
  
  // æµ‹è¯•ç©ºé”®
  let ctx_with_empty_key = empty_ctx.with_value(empty_key, "value-for-empty-key")
  match ctx_with_empty_key.get(empty_key) {
    Some(value) => assert_eq(value, "value-for-empty-key")
    None => @test.fail("Should find value for empty key")
  }
  
  // æµ‹è¯•æé•¿é”®å’Œå€¼
  let long_key = context::create_key("a" * 1000)
  let long_value = "b" * 10000
  let ctx_with_long_values = empty_ctx.with_value(long_key, long_value)
  
  match ctx_with_long_values.get(long_key) {
    Some(value) => assert_eq(value.length(), 10000)
    None => @test.fail("Should find value for long key")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_key = context::create_key("special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let special_value = "special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let ctx_with_special = empty_ctx.with_value(special_key, special_value)
  
  match ctx_with_special.get(special_key) {
    Some(value) => assert_eq(value, special_value)
    None => @test.fail("Should find value for special key")
  }
}

test "log_record_error_conditions" {
  // æµ‹è¯•LogRecordçš„é”™è¯¯æ¡ä»¶
  
  // æµ‹è¯•å„ç§ä¸¥é‡æ€§çº§åˆ«
  let trace_log = logs::LogRecord::builder()
    .severity(logs::Trace)
    .body("Trace level log")
    .build()
  
  let debug_log = logs::LogRecord::builder()
    .severity(logs::Debug)
    .body("Debug level log")
    .build()
  
  let info_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("Info level log")
    .build()
  
  let warn_log = logs::LogRecord::builder()
    .severity(logs::Warn)
    .body("Warning level log")
    .build()
  
  let error_log = logs::LogRecord::builder()
    .severity(logs::Error)
    .body("Error level log")
    .build()
  
  let fatal_log = logs::LogRecord::builder()
    .severity(logs::Fatal)
    .body("Fatal level log")
    .build()
  
  // éªŒè¯ä¸åŒä¸¥é‡æ€§çº§åˆ«
  assert_eq(trace_log.severity_number, logs::Trace)
  assert_eq(debug_log.severity_number, logs::Debug)
  assert_eq(info_log.severity_number, logs::Info)
  assert_eq(warn_log.severity_number, logs::Warn)
  assert_eq(error_log.severity_number, logs::Error)
  assert_eq(fatal_log.severity_number, logs::Fatal)
  
  // æµ‹è¯•ç©ºå’Œæé•¿æ—¥å¿—ä½“
  let empty_body_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("")
    .build()
  
  let long_body_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("x" * 100000)
    .build()
  
  match empty_body_log.body {
    Some(body) => assert_eq(body, "")
    None => @test.fail("Empty body should be Some(\"\")")
  }
  
  match long_body_log.body {
    Some(body) => assert_eq(body.length(), 100000)
    None => @test.fail("Long body should not be None")
  }
  
  // æµ‹è¯•Unicodeå’Œç‰¹æ®Šå­—ç¬¦
  let unicode_log = logs::LogRecord::builder()
    .severity(logs::Info)
    .body("Unicodeæµ‹è¯•ğŸš€ with Ã©mojis and spÃ«cial chars")
    .build()
  
  match unicode_log.body {
    Some(body) => assert_eq(body.contains("æµ‹è¯•"), true)
    None => @test.fail("Unicode body should not be None")
  }
}

test "metric_boundary_conditions" {
  // æµ‹è¯•æŒ‡æ ‡çš„è¾¹ç•Œæ¡ä»¶
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("boundary-test-meter")
  
  // åˆ›å»ºå„ç§æŒ‡æ ‡
  let counter = meter.create_counter("", "count", "")  // ç©ºåç§°
  let histogram = meter.create_histogram("a" * 1000, "ms", "a" * 1000)  // æé•¿åç§°å’Œæè¿°
  let up_down_counter = meter.create_up_down_counter("up-down", "", "")  // ç©ºå•ä½å’Œæè¿°
  let gauge = meter.create_gauge("gauge", "unit", nil)  // nilæè¿°
  
  // æµ‹è¯•æå€¼è®°å½•
  counter.add(9223372036854775807L)  // æœ€å¤§Int64
  counter.add(-9223372036854775808L)  // æœ€å°Int64
  counter.add(0L)  // é›¶å€¼
  
  histogram.record(1.7976931348623157e+308)  // æœ€å¤§Double
  histogram.record(-1.7976931348623157e+308)  // æœ€å°Double
  histogram.record(0.0)  // é›¶å€¼
  histogram.record(1.0/0.0)  // æ— ç©·å¤§
  histogram.record(0.0/0.0)  // NaN
  
  up_down_counter.add(9223372036854775807L)  // æœ€å¤§æ­£å€¼
  up_down_counter.add(-9223372036854775808L)  // æœ€å¤§è´Ÿå€¼
  
  gauge.record(1.7976931348623157e+308)  // æœ€å¤§å€¼
  gauge.record(-1.7976931348623157e+308)  // æœ€å°å€¼
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  let mut i = 0
  while i < 1000 {
    many_attrs.push(("attr-" + i.to_string(), common::AttributeValue::string("value-" + i.to_string())))
    i = i + 1
  }
  
  counter.add(1L, many_attrs)
  histogram.record(100.0, many_attrs)
  
  // éªŒè¯æ“ä½œä¸ä¼šå¤±è´¥
  assert_eq(true, true)
}

test "span_edge_cases" {
  // æµ‹è¯•Spançš„è¾¹ç•Œæƒ…å†µ
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("edge-case-tracer")
  
  // æµ‹è¯•ç©ºåç§°å’Œæé•¿åç§°
  let (empty_name_ctx, empty_name_span) = tracer.start_span(
    context::Context::empty(),
    "",
    trace::Internal
  )
  
  let (long_name_ctx, long_name_span) = tracer.start_span(
    context::Context::empty(),
    "a" * 10000,
    trace::Server
  )
  
  // éªŒè¯ä¸åŒåç§°çš„Span
  assert_eq(empty_name_span.name, "")
  assert_eq(long_name_span.name.length(), 10000)
  
  // æµ‹è¯•å„ç§SpanKind
  let (internal_ctx, internal_span) = tracer.start_span(
    context::Context::empty(),
    "internal-span",
    trace::Internal
  )
  
  let (server_ctx, server_span) = tracer.start_span(
    context::Context::empty(),
    "server-span",
    trace::Server
  )
  
  let (client_ctx, client_span) = tracer.start_span(
    context::Context::empty(),
    "client-span",
    trace::Client
  )
  
  let (producer_ctx, producer_span) = tracer.start_span(
    context::Context::empty(),
    "producer-span",
    trace::Producer
  )
  
  let (consumer_ctx, consumer_span) = tracer.start_span(
    context::Context::empty(),
    "consumer-span",
    trace::Consumer
  )
  
  // éªŒè¯ä¸åŒSpanKind
  assert_eq(internal_span.kind, trace::Internal)
  assert_eq(server_span.kind, trace::Server)
  assert_eq(client_span.kind, trace::Client)
  assert_eq(producer_span.kind, trace::Producer)
  assert_eq(consumer_span.kind, trace::Consumer)
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let (min_time_ctx, min_time_span) = tracer.start_span(
    context::Context::empty(),
    "min-time-span",
    trace::Internal,
    [],
    -9223372036854775808L
  )
  
  let (max_time_ctx, max_time_span) = tracer.start_span(
    context::Context::empty(),
    "max-time-span",
    trace::Internal,
    [],
    9223372036854775807L
  )
  
  // éªŒè¯æå€¼æ—¶é—´æˆ³
  assert_eq(min_time_span.start_time_unix_nanos, -9223372036854775808L)
  assert_eq(max_time_span.start_time_unix_nanos, 9223372036854775807L)
}

test "propagation_error_handling" {
  // æµ‹è¯•ä¼ æ’­çš„é”™è¯¯å¤„ç†
  
  let trace_propagator = propagation::W3CTraceContextPropagator::{}
  let baggage_propagator = propagation::W3CBaggagePropagator::{}
  let composite_propagator = propagation::CompositePropagator::new([trace_propagator, baggage_propagator])
  
  // æµ‹è¯•ç©ºcarrier
  let empty_carrier = propagation::MapCarrier::new()
  let extracted_from_empty = composite_propagator.extract(context::Context::empty(), empty_carrier)
  
  // éªŒè¯ä»ç©ºcarrieræå–
  assert_eq(extracted_from_empty.values.length(), 0)
  
  // æµ‹è¯•æŸåçš„traceparentæ ¼å¼
  let corrupted_carrier = propagation::MapCarrier::from_map([
    ("traceparent", "invalid-format"),
    ("baggage", "invalid=baggage=format=with=too=many=equals")
  ])
  
  let extracted_from_corrupted = composite_propagator.extract(context::Context::empty(), corrupted_carrier)
  
  // éªŒè¯ä»æŸåcarrieræå–ä¸ä¼šå´©æºƒ
  assert_eq(true, true)
  
  // æµ‹è¯•æé•¿headerå€¼
  let long_traceparent = "00-" + "a" * 32 + "-" + "b" * 16 + "-01"
  let long_baggage = "key1=" + "a" * 1000 + ",key2=" + "b" * 1000
  
  let long_carrier = propagation::MapCarrier::from_map([
    ("traceparent", long_traceparent),
    ("baggage", long_baggage)
  ])
  
  let extracted_from_long = composite_propagator.extract(context::Context::empty(), long_carrier)
  
  // éªŒè¯ä»æé•¿headeræå–ä¸ä¼šå´©æºƒ
  assert_eq(true, true)
}

test "baggage_boundary_conditions" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼
  let empty_key_baggage = context::Baggage::empty()
    .with_entry("", "value-for-empty-key")
  let empty_value_baggage = context::Baggage::empty()
    .with_entry("key-for-empty-value", "")
  
  // éªŒè¯ç©ºé”®å’Œå€¼
  match empty_key_baggage.get("") {
    Some(value) => assert_eq(value, "value-for-empty-key")
    None => @test.fail("Should find value for empty key")
  }
  
  match empty_value_baggage.get("key-for-empty-value") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Should find empty value")
  }
  
  // æµ‹è¯•æé•¿é”®å’Œå€¼
  let long_key = "a" * 1000
  let long_value = "b" * 10000
  let long_baggage = context::Baggage::empty()
    .with_entry(long_key, long_value)
  
  match long_baggage.get(long_key) {
    Some(value) => assert_eq(value.length(), 10000)
    None => @test.fail("Should find value for long key")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = "special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_value = "special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_baggage = context::Baggage::empty()
    .with_entry(special_key, special_value)
  
  match special_baggage.get(special_key) {
    Some(value) => assert_eq(value, special_value)
    None => @test.fail("Should find value for special key")
  }
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = "Unicodeé”®æµ‹è¯•ğŸš€"
  let unicode_value = "Unicodeå€¼æµ‹è¯•ğŸŒŸ"
  let unicode_baggage = context::Baggage::empty()
    .with_entry(unicode_key, unicode_value)
  
  match unicode_baggage.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_value)
    None => @test.fail("Should find value for Unicode key")
  }
}

test "resource_error_conditions" {
  // æµ‹è¯•Resourceçš„é”™è¯¯æ¡ä»¶
  
  // æµ‹è¯•ç©ºæœåŠ¡åç§°
  let empty_service_resource = common::Resource::default("")
  
  // æµ‹è¯•æé•¿æœåŠ¡åç§°
  let long_service_resource = common::Resource::default("a" * 10000)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æœåŠ¡åç§°
  let special_service_resource = common::Resource::default("special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  // æµ‹è¯•UnicodeæœåŠ¡åç§°
  let unicode_service_resource = common::Resource::default("UnicodeæœåŠ¡æµ‹è¯•ğŸš€")
  
  // éªŒè¯å„ç§æœåŠ¡åç§°
  assert_eq(empty_service_resource.service_name, "")
  assert_eq(long_service_resource.service_name.length(), 10000)
  assert_eq(special_service_resource.service_name, "special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  assert_eq(unicode_service_resource.service_name, "UnicodeæœåŠ¡æµ‹è¯•ğŸš€")
  
  // éªŒè¯æ‰€æœ‰Resourceéƒ½æœ‰ç›¸åŒçš„SDKä¿¡æ¯
  assert_eq(empty_service_resource.telemetry_sdk_name, "azimuth")
  assert_eq(long_service_resource.telemetry_sdk_name, "azimuth")
  assert_eq(special_service_resource.telemetry_sdk_name, "azimuth")
  assert_eq(unicode_service_resource.telemetry_sdk_name, "azimuth")
  
  assert_eq(empty_service_resource.telemetry_sdk_version, "0.1.0")
  assert_eq(long_service_resource.telemetry_sdk_version, "0.1.0")
  assert_eq(special_service_resource.telemetry_sdk_version, "0.1.0")
  assert_eq(unicode_service_resource.telemetry_sdk_version, "0.1.0")
}

test "graceful_degradation_test" {
  // æµ‹è¯•ä¼˜é›…é™çº§
  
  // æµ‹è¯•åœ¨å†…å­˜ä¸è¶³æƒ…å†µä¸‹çš„è¡Œä¸ºï¼ˆæ¨¡æ‹Ÿï¼‰
  let large_objects = []
  let mut i = 0
  while i < 100000 {
    let large_string = "x" * 10000
    let large_array = [for j = 0; j < 1000; j = j + 1].map(fn(_) { large_string })
    large_objects.push(large_array)
    i = i + 1
  }
  
  // å³ä½¿åˆ›å»ºäº†å¤§é‡å¯¹è±¡ï¼ŒåŸºæœ¬æ“ä½œä»åº”å·¥ä½œ
  let ctx = context::Context::empty()
  let key = context::create_key("test-key")
  let ctx_with_value = ctx.with_value(key, "test-value")
  
  match ctx_with_value.get(key) {
    Some(value) => assert_eq(value, "test-value")
    None => @test.fail("Basic context operations should work even under memory pressure")
  }
  
  // æµ‹è¯•åœ¨å¿«é€Ÿè¿ç»­æ“ä½œä¸‹çš„ç¨³å®šæ€§
  let mut i = 0
  while i < 10000 {
    let tracer_provider = trace::NoopTracerProvider::{}
    let tracer = tracer_provider.get_tracer("stress-test-" + i.to_string())
    let (_, span) = tracer.start_span(context::Context::empty(), "stress-span-" + i.to_string())
    
    let meter_provider = metrics::NoopMeterProvider::{}
    let meter = meter_provider.get_meter("stress-meter-" + i.to_string())
    let counter = meter.create_counter("stress-counter-" + i.to_string())
    counter.add(1L)
    
    let logger_provider = logs::NoopLoggerProvider::{}
    let logger = logger_provider.get_logger("stress-logger-" + i.to_string())
    logger.info("Stress test log " + i.to_string())
    
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½æˆåŠŸå®Œæˆ
  assert_eq(i, 10000)
}