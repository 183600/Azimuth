// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µæµ‹è¯• - æµ‹è¯•å¼‚å¸¸è¾“å…¥å’Œè¾¹ç•Œæ¡ä»¶çš„å¤„ç†
use azimuth.telemetry.api.common.{AttributeValue, Resource}
use azimuth.telemetry.api.trace.{SpanContext, Span, SpanKind, StatusCode, SpanEvent, NoopTracer, NoopTracerProvider}
use azimuth.telemetry.api.metrics.{NoopMeter, NoopMeterProvider}
use azimuth.telemetry.api.logs.{SeverityNumber, LogRecordBuilder, NoopLogger, NoopLoggerProvider}
use azimuth.telemetry.api.context.{Context, ContextKey, Baggage, create_key}

test "error_handling_span_creation_edge_cases" {
  // æµ‹è¯•spanåˆ›å»ºæ—¶çš„è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯å¤„ç†
  
  let ctx = Context::empty()
  let tracer_provider = NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("error-test", Some("1.0.0"))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²spanåç§°
  let (_, empty_span) = tracer.start_span(ctx, "", Internal, None)
  assert_eq(empty_span.name, "")
  assert_eq(empty_span.kind, Internal)
  
  // æµ‹è¯•éå¸¸é•¿çš„spanåç§°
  let long_name = "a" * 10000
  let (_, long_span) = tracer.start_span(ctx, long_name, Internal, None)
  assert_eq(long_span.name.length(), 10000)
  assert_eq(long_span.kind, Internal)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„spanåç§°
  let special_name = "span_with_special_chars!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let (_, special_span) = tracer.start_span(ctx, special_name, Internal, None)
  assert_eq(special_span.name, special_name)
  
  // æµ‹è¯•Unicodeå­—ç¬¦çš„spanåç§°
  let unicode_name = "Unicodeæµ‹è¯•_span_ğŸš€_ğŸŒŸ_ğŸ’«"
  let (_, unicode_span) = tracer.start_span(ctx, unicode_name, Internal, None)
  assert_eq(unicode_span.name, unicode_name)
  
  // æµ‹è¯•åŒ…å«æ¢è¡Œç¬¦çš„spanåç§°
  let newline_name = "span_with\nnewlines\nand\ttabs"
  let (_, newline_span) = tracer.start_span(ctx, newline_name, Internal, None)
  assert_eq(newline_span.name, newline_name)
}

test "error_handling_attribute_boundary_values" {
  // æµ‹è¯•å±æ€§çš„è¾¹ç•Œå€¼å’Œé”™è¯¯å¤„ç†
  
  let ctx = Context::empty()
  let tracer_provider = NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("attribute-test", Some("1.0.0"))
  
  // æµ‹è¯•æå€¼æ•´æ•°
  let extreme_int_attributes = [
    ("max.int64", AttributeValue::int(9223372036854775807L)),  // Int64æœ€å¤§å€¼
    ("min.int64", AttributeValue::int(-9223372036854775808L)), // Int64æœ€å°å€¼
    ("zero.int64", AttributeValue::int(0L))
  ]
  
  let (_, extreme_int_span) = tracer.start_span(ctx, "extreme_int_test", Internal, Some(extreme_int_attributes))
  assert_eq(extreme_int_span.attributes.length(), 3)
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°
  let extreme_float_attributes = [
    ("max.double", AttributeValue::float(1.7976931348623157e+308)),    // Doubleæœ€å¤§å€¼
    ("min.double", AttributeValue::float(-1.7976931348623157e+308)),   // Doubleæœ€å°å€¼
    ("min.positive.double", AttributeValue::float(5e-324)),            // æœ€å°æ­£æ•°
    ("infinity", AttributeValue::float(1.0/0.0)),                      // æ­£æ— ç©·
    ("negative.infinity", AttributeValue::float(-1.0/0.0)),            // è´Ÿæ— ç©·
    ("nan", AttributeValue::float(0.0/0.0))                           // NaN
  ]
  
  let (_, extreme_float_span) = tracer.start_span(ctx, "extreme_float_test", Internal, Some(extreme_float_attributes))
  assert_eq(extreme_float_span.attributes.length(), 6)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦ä¸²å€¼
  let string_boundary_attributes = [
    ("empty.string", AttributeValue::string("")),
    ("space.string", AttributeValue::string(" ")),
    ("many.spaces", AttributeValue::string(" " * 1000)),
    ("null.chars", AttributeValue::string("\0\0\0")),
    ("unicode.test", AttributeValue::string("ğŸš€ğŸŒŸğŸ’«âœ¨ğŸ‰")),
    ("emoji.stress", AttributeValue::string("ğŸ˜€ğŸ˜ƒğŸ˜„ğŸ˜ğŸ˜†ğŸ˜…ğŸ˜‚ğŸ¤£ğŸ˜ŠğŸ˜‡"))
  ]
  
  let (_, string_boundary_span) = tracer.start_span(ctx, "string_boundary_test", Internal, Some(string_boundary_attributes))
  assert_eq(string_boundary_span.attributes.length(), 6)
}

test "error_handling_array_attributes_edge_cases" {
  // æµ‹è¯•æ•°ç»„å±æ€§çš„è¾¹ç•Œæƒ…å†µ
  
  let ctx = Context::empty()
  let tracer_provider = NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("array-test", Some("1.0.0"))
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_array_attributes = [
    ("empty.string.array", AttributeValue::array_string([])),
    ("empty.int.array", AttributeValue::array_int([])),
    ("empty.float.array", AttributeValue::array_float([])),
    ("empty.bool.array", AttributeValue::array_bool([]))
  ]
  
  let (_, empty_array_span) = tracer.start_span(ctx, "empty_array_test", Internal, Some(empty_array_attributes))
  assert_eq(empty_array_span.attributes.length(), 4)
  
  // éªŒè¯æ‰€æœ‰æ•°ç»„éƒ½æ˜¯ç©ºçš„
  let mut i = 0
  while i < empty_array_span.attributes.length() {
    match empty_array_span.attributes[i].1 {
      ArrayStringValue(arr) => assert_eq(arr.length(), 0)
      ArrayIntValue(arr) => assert_eq(arr.length(), 0)
      ArrayFloatValue(arr) => assert_eq(arr.length(), 0)
      ArrayBoolValue(arr) => assert_eq(arr.length(), 0)
      _ => @test.fail("Test failed")
    }
    i = i + 1
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_element_arrays = [
    ("single.string", AttributeValue::array_string(["only_element"])),
    ("single.int", AttributeValue::array_int([42L])),
    ("single.float", AttributeValue::array_float([3.14])),
    ("single.bool", AttributeValue::array_bool([true]))
  ]
  
  let (_, single_array_span) = tracer.start_span(ctx, "single_array_test", Internal, Some(single_element_arrays))
  assert_eq(single_array_span.attributes.length(), 4)
  
  // æµ‹è¯•å¤§å‹æ•°ç»„
  let large_string_array = []
  let large_int_array = []
  let large_float_array = []
  let large_bool_array = []
  
  let mut j = 0
  while j < 1000 {
    large_string_array.push("item_" + j.to_string())
    large_int_array.push(j.to_int64())
    large_float_array.push(j.to_double() * 0.1)
    large_bool_array.push(j % 2 == 0)
    j = j + 1
  }
  
  let large_array_attributes = [
    ("large.string.array", AttributeValue::array_string(large_string_array)),
    ("large.int.array", AttributeValue::array_int(large_int_array)),
    ("large.float.array", AttributeValue::array_float(large_float_array)),
    ("large.bool.array", AttributeValue::array_bool(large_bool_array))
  ]
  
  let (_, large_array_span) = tracer.start_span(ctx, "large_array_test", Internal, Some(large_array_attributes))
  assert_eq(large_array_span.attributes.length(), 4)
  
  // éªŒè¯å¤§å‹æ•°ç»„çš„å¤§å°
  match large_array_span.attributes[0].1 {
    ArrayStringValue(arr) => assert_eq(arr.length(), 1000)
    _ => @test.fail("Test failed")
  }
}

test "error_handling_context_edge_cases" {
  // æµ‹è¯•Contextæ“ä½œçš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_ctx = Context::empty()
  assert_eq(empty_ctx.values.length(), 0)
  
  // æµ‹è¯•åœ¨ç©ºä¸Šä¸‹æ–‡ä¸­è·å–å€¼
  let non_existent_key = create_key("non.existent.key")
  match empty_ctx.get(non_existent_key) {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•é‡å¤è®¾ç½®ç›¸åŒçš„é”®
  let ctx = Context::empty()
  let key = create_key("test.key")
  let ctx1 = ctx.with_value(key, "value1")
  let ctx2 = ctx1.with_value(key, "value2")
  let ctx3 = ctx2.with_value(key, "value3")
  
  // éªŒè¯æœ€åè®¾ç½®çš„å€¼è¢«ä¿ç•™
  match ctx3.get(key) {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®å’Œå€¼
  let empty_key = create_key("")
  let ctx_with_empty_key = ctx.with_value(empty_key, "value_with_empty_key")
  match ctx_with_empty_key.get(empty_key) {
    Some(value) => assert_eq(value, "value_with_empty_key")
    None => @test.fail("Test failed")
  }
  
  let normal_key = create_key("normal.key")
  let ctx_with_empty_value = ctx.with_value(normal_key, "")
  match ctx_with_empty_value.get(normal_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
}

test "error_handling_baggage_edge_cases" {
  // æµ‹è¯•Baggageæ“ä½œçš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºbaggage
  let empty_baggage = Baggage::empty()
  assert_eq(empty_baggage.entries.length(), 0)
  
  // æµ‹è¯•åœ¨ç©ºbaggageä¸­è·å–å€¼
  match empty_baggage.get("non.existent.key") {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•é‡å¤è®¾ç½®ç›¸åŒçš„é”®
  let baggage = Baggage::empty()
  let baggage1 = baggage.with_entry("test.key", "value1")
  let baggage2 = baggage1.with_entry("test.key", "value2")
  let baggage3 = baggage2.with_entry("test.key", "value3")
  
  // éªŒè¯æœ€åè®¾ç½®çš„å€¼è¢«ä¿ç•™
  match baggage3.get("test.key") {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®å’Œå€¼
  let baggage_with_empty_key = baggage.with_entry("", "value_with_empty_key")
  match baggage_with_empty_key.get("") {
    Some(value) => assert_eq(value, "value_with_empty_key")
    None => @test.fail("Test failed")
  }
  
  let baggage_with_empty_value = baggage.with_entry("normal.key", "")
  match baggage_with_empty_value.get("normal.key") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®å’Œå€¼
  let special_key = "special.key!@#$%^&*()"
  let special_value = "special.value!@#$%^&*()"
  let baggage_with_special = baggage.with_entry(special_key, special_value)
  match baggage_with_special.get(special_key) {
    Some(value) => assert_eq(value, special_value)
    None => @test.fail("Test failed")
  }
}

test "error_handling_log_record_edge_cases" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„è¾¹ç•Œæƒ…å†µ
  
  let logger_provider = NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("edge-case-logger", Some("1.0.0"))
  
  // æµ‹è¯•ç©ºæ—¥å¿—è®°å½•
  let empty_log_record = LogRecord::builder()
    .timestamp(0L)
    .severity(SeverityNumber::Info)
    .body("")
    .build()
  
  logger.emit(empty_log_record)
  assert_eq(empty_log_record.severity_number, SeverityNumber::Info)
  match empty_log_record.body {
    Some(body) => assert_eq(body, "")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let extreme_timestamp_log = LogRecord::builder()
    .timestamp(-9223372036854775808L)  // Int64æœ€å°å€¼
    .severity(SeverityNumber::Error)
    .body("Log with minimum timestamp")
    .build()
  
  logger.emit(extreme_timestamp_log)
  assert_eq(extreme_timestamp_log.timestamp_unix_nanos, -9223372036854775808L)
  
  let max_timestamp_log = LogRecord::builder()
    .timestamp(9223372036854775807L)   // Int64æœ€å¤§å€¼
    .severity(SeverityNumber::Fatal)
    .body("Log with maximum timestamp")
    .build()
  
  logger.emit(max_timestamp_log)
  assert_eq(max_timestamp_log.timestamp_unix_nanos, 9223372036854775807L)
  
  // æµ‹è¯•éå¸¸é•¿çš„æ—¥å¿—æ¶ˆæ¯
  let long_message = "x" * 100000
  let long_log_record = LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(SeverityNumber::Info)
    .body(long_message)
    .build()
  
  logger.emit(long_log_record)
  match long_log_record.body {
    Some(body) => assert_eq(body.length(), 100000)
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—æ¶ˆæ¯
  let special_message = "Special chars: !@#$%^&*()_+-={}[]|\\:;\"'<>?,./\n\t\0Unicode: ğŸš€ğŸŒŸğŸ’«"
  let special_log_record = LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(SeverityNumber::Warn)
    .body(special_message)
    .build()
  
  logger.emit(special_log_record)
  match special_log_record.body {
    Some(body) => assert_eq(body, special_message)
    None => @test.fail("Test failed")
  }
}

test "error_handling_resource_edge_cases" {
  // æµ‹è¯•Resourceåˆ›å»ºçš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºæœåŠ¡åç§°
  let empty_service_resource = Resource::default("")
  assert_eq(empty_service_resource.service_name, "")
  assert_eq(empty_service_resource.telemetry_sdk_name, "azimuth")
  
  // æµ‹è¯•éå¸¸é•¿çš„æœåŠ¡åç§°
  let long_service_name = "a" * 10000
  let long_service_resource = Resource::default(long_service_name)
  assert_eq(long_service_resource.service_name.length(), 10000)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æœåŠ¡åç§°
  let special_service_name = "service!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let special_service_resource = Resource::default(special_service_name)
  assert_eq(special_service_resource.service_name, special_service_name)
  
  // æµ‹è¯•UnicodeæœåŠ¡åç§°
  let unicode_service_name = "UnicodeæœåŠ¡æµ‹è¯•ğŸš€ğŸŒŸğŸ’«"
  let unicode_service_resource = Resource::default(unicode_service_name)
  assert_eq(unicode_service_resource.service_name, unicode_service_name)
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„æœåŠ¡åç§°
  let space_service_name = "service with multiple   spaces"
  let space_service_resource = Resource::default(space_service_name)
  assert_eq(space_service_resource.service_name, space_service_name)
}

test "error_handling_span_context_edge_cases" {
  // æµ‹è¯•SpanContextçš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•å…¨é›¶çš„trace_idå’Œspan_id
  let zero_trace_id = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte })
  let zero_span_id = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte })
  
  let zero_context = SpanContext::{
    trace_id: zero_trace_id,
    span_id: zero_span_id,
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  assert_eq(zero_context.trace_id.length(), 16)
  assert_eq(zero_context.span_id.length(), 8)
  assert_eq(zero_context.trace_flags, 0_byte)
  assert_eq(zero_context.trace_state, "")
  
  // æµ‹è¯•å…¨1çš„trace_idå’Œspan_id
  let max_trace_id = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0xff_byte })
  let max_span_id = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0xff_byte })
  
  let max_context = SpanContext::{
    trace_id: max_trace_id,
    span_id: max_span_id,
    trace_flags: 0xff_byte,
    trace_state: ""
  }
  
  assert_eq(max_context.trace_id.length(), 16)
  assert_eq(max_context.span_id.length(), 8)
  assert_eq(max_context.trace_flags, 0xff_byte)
  
  // æµ‹è¯•å¤æ‚çš„trace_state
  let complex_trace_state = "key1=value1,key2=value2;prop1=val1,key3=value3;prop1=val1;prop2=val2"
  let complex_context = SpanContext::{
    trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x12_byte }),
    span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x34_byte }),
    trace_flags: 1_byte,
    trace_state: complex_trace_state
  }
  
  assert_eq(complex_context.trace_state, complex_trace_state)
  assert_eq(complex_context.trace_flags, 1_byte)
  
  // æµ‹è¯•éå¸¸é•¿çš„trace_state
  let long_trace_state = "key=" + "value" * 1000
  let long_context = SpanContext::{
    trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0x56_byte }),
    span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0x78_byte }),
    trace_flags: 1_byte,
    trace_state: long_trace_state
  }
  
  assert_eq(long_context.trace_state.length(), long_trace_state.length())
}