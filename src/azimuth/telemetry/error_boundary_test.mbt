// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯• - éªŒè¯APIçš„é”™è¯¯å¤„ç†èƒ½åŠ›å’Œè¾¹ç•Œæ¡ä»¶

test "trace_api_error_handling" {
  // æµ‹è¯•Trace APIçš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºåç§°çš„Spanåˆ›å»º
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("error-test-tracer")
  let (_, empty_name_span) = tracer.start_span(
    context::Context::current(),
    "",  // ç©ºåç§°
    trace::Internal
  )
  @assert.eq(empty_name_span.name, "")
  
  // æµ‹è¯•æé•¿åç§°çš„Spanåˆ›å»º
  let mut long_name = ""
  let mut i = 0
  while i < 1000 {
    long_name = long_name + "a"
    i = i + 1
  }
  let (_, long_name_span) = tracer.start_span(
    context::Context::current(),
    long_name,
    trace::Server
  )
  @assert.eq(long_name_span.name.length(), 1000)
  
  // æµ‹è¯•è´Ÿæ—¶é—´æˆ³
  let (_, negative_time_span) = tracer.start_span(
    context::Context::current(),
    "negative-time-span",
    trace::Client,
    [],
    -1000000L  // è´Ÿæ—¶é—´æˆ³
  )
  @assert.eq(negative_time_span.start_time_unix_nanos, -1000000L)
  
  // æµ‹è¯•æå¤§æ—¶é—´æˆ³
  let max_time = 9223372036854775807L
  let (_, max_time_span) = tracer.start_span(
    context::Context::current(),
    "max-time-span",
    trace::Producer,
    [],
    max_time
  )
  @assert.eq(max_time_span.start_time_unix_nanos, max_time)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut many_attributes : Array[(String, common::AttributeValue)] = []
  let mut j = 0
  while j < 200 {
    many_attributes.push(("attr." + j.to_string(), common::AttributeValue::int(j.to_int64())))
    j = j + 1
  }
  
  let (_, many_attrs_span) = tracer.start_span(
    context::Context::current(),
    "many-attrs-span",
    trace::Consumer,
    many_attributes
  )
  @assert.eq(many_attrs_span.attributes.length(), 200)
}

test "metrics_api_error_handling" {
  // æµ‹è¯•Metrics APIçš„é”™è¯¯å¤„ç†
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("error-test-meter")
  
  // æµ‹è¯•ç©ºåç§°çš„æŒ‡æ ‡åˆ›å»º
  let empty_counter = meter.create_counter("", "count", "Empty name counter")
  empty_counter.add(1L, [("test", common::AttributeValue::string("empty-name"))])
  
  let empty_histogram = meter.create_histogram("", "ms", "Empty name histogram")
  empty_histogram.record(100.0, [("test", common::AttributeValue::string("empty-name"))])
  
  // æµ‹è¯•æé•¿åç§°çš„æŒ‡æ ‡åˆ›å»º
  let mut long_instrument_name = ""
  let mut i = 0
  while i < 500 {
    long_instrument_name = long_instrument_name + "i"
    i = i + 1
  }
  
  let long_counter = meter.create_counter(long_instrument_name, "count", "Long name counter")
  long_counter.add(42L, [("name.length", common::AttributeValue::int(long_instrument_name.length().to_int64()))])
  
  // æµ‹è¯•è´Ÿæ•°å€¼
  let counter = meter.create_counter("negative-test", "count", "Counter for negative values")
  counter.add(-100L, [("negative", common::AttributeValue::bool(true))])
  
  // æµ‹è¯•æå¤§æ•°å€¼
  let max_int64 = 9223372036854775807L
  counter.add(max_int64, [("max.value", common::AttributeValue::bool(true))])
  
  // æµ‹è¯•æå°æ•°å€¼
  let min_int64 = -9223372036854775808L
  counter.add(min_int64, [("min.value", common::AttributeValue::bool(true))])
  
  // æµ‹è¯•æå¤§æµ®ç‚¹æ•°å€¼
  let histogram = meter.create_histogram("float-extreme-test", "ms", "Histogram for extreme float values")
  histogram.record(1.7976931348623157e+308, [("max.float", common::AttributeValue::bool(true))])
  histogram.record(-1.7976931348623157e+308, [("min.float", common::AttributeValue::bool(true))])
  histogram.record(0.0, [("zero.float", common::AttributeValue::bool(true))])
  
  // æµ‹è¯•NaNå’Œæ— ç©·å¤§ï¼ˆå¦‚æœæ”¯æŒï¼‰
  histogram.record(1.0 / 0.0, [("infinity", common::AttributeValue::bool(true))])  // æ­£æ— ç©·
  histogram.record(-1.0 / 0.0, [("neg.infinity", common::AttributeValue::bool(true))]) // è´Ÿæ— ç©·
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut many_metric_attrs : Array[(String, common::AttributeValue)] = []
  let mut k = 0
  while k < 150 {
    many_metric_attrs.push(("metric.attr." + k.to_string(), common::AttributeValue::float(k.to_float())))
    k = k + 1
  }
  
  histogram.record(500.0, many_metric_attrs)
}

test "logs_api_error_handling" {
  // æµ‹è¯•Logs APIçš„é”™è¯¯å¤„ç†
  
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("error-test-logger")
  
  // æµ‹è¯•ç©ºæ—¥å¿—æ¶ˆæ¯
  logger.debug("", [("empty.message", common::AttributeValue::bool(true))])
  logger.info("", [("empty.message", common::AttributeValue::bool(true))])
  logger.warn("", [("empty.message", common::AttributeValue::bool(true))])
  logger.error("", [("empty.message", common::AttributeValue::bool(true))])
  logger.fatal("", [("empty.message", common::AttributeValue::bool(true))])
  
  // æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯
  let mut long_message = ""
  let mut i = 0
  while i < 10000 {
    long_message = long_message + "x"
    i = i + 1
  }
  logger.info(long_message, [("long.message", common::AttributeValue::bool(true))])
  
  // æµ‹è¯•è´Ÿæ—¶é—´æˆ³çš„æ—¥å¿—è®°å½•
  let negative_time_log = logs::LogRecord::builder()
    .timestamp(-5000000L)
    .severity(logs::Error)
    .body("Negative timestamp log")
    .with_attribute("negative.time", common::AttributeValue::bool(true))
    .build()
  
  logger.emit(negative_time_log)
  @assert.eq(negative_time_log.timestamp_unix_nanos, -5000000L)
  
  // æµ‹è¯•æå¤§æ—¶é—´æˆ³çš„æ—¥å¿—è®°å½•
  let max_time_log = logs::LogRecord::builder()
    .timestamp(9223372036854775807L)
    .severity(logs::Fatal)
    .body("Max timestamp log")
    .with_attribute("max.time", common::AttributeValue::bool(true))
    .build()
  
  logger.emit(max_time_log)
  @assert.eq(max_time_log.timestamp_unix_nanos, 9223372036854775807L)
  
  // æµ‹è¯•ç©ºæ—¥å¿—è®°å½•
  let empty_log = logs::LogRecord::builder()
    .timestamp(0L)
    .severity(logs::Unset)  // ä½¿ç”¨Unsetä½œä¸ºè¾¹ç•Œæ¡ä»¶
    .body("")
    .build()
  
  logger.emit(empty_log)
  @assert.eq(empty_log.body.unwrap(), "")
  @assert.eq(empty_log.severity_number, logs::Unset)
  
  // æµ‹è¯•åŒ…å«å¤§é‡å±æ€§çš„æ—¥å¿—è®°å½•
  let log_with_many_attrs = logs::LogRecord::builder()
    .timestamp(6000000L)
    .severity(logs::Info)
    .body("Log with many attributes")
  
  let mut j = 0
  while j < 300 {
    log_with_many_attrs = log_with_many_attrs.with_attribute(
      "log.attr." + j.to_string(), 
      common::AttributeValue::string("value." + j.to_string())
    )
    j = j + 1
  }
  
  let final_log = log_with_many_attrs.build()
  logger.emit(final_log)
  @assert.eq(final_log.attributes.length(), 300)
}

test "context_api_error_handling" {
  // æµ‹è¯•Context APIçš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡æ“ä½œ
  let empty_ctx = context::Context::current()
  
  // æµ‹è¯•åœ¨ä¸Šä¸‹æ–‡ä¸­å­˜å‚¨å’Œæ£€ç´¢æå€¼
  let extreme_key = "extremely.long.key.name.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  let extreme_string_value = "extremely.long.value.string.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¼ æ’­çš„è¾¹ç•Œæƒ…å†µ
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("context-error-test")
  
  // åˆ›å»ºæ·±å±‚åµŒå¥—çš„Spanå±‚æ¬¡ç»“æ„
  let (ctx1, span1) = tracer.start_span(empty_ctx, "level-1", trace::Internal)
  let (ctx2, span2) = tracer.start_span(ctx1, "level-2", trace::Internal)
  let (ctx3, span3) = tracer.start_span(ctx2, "level-3", trace::Internal)
  let (ctx4, span4) = tracer.start_span(ctx3, "level-4", trace::Internal)
  let (ctx5, span5) = tracer.start_span(ctx4, "level-5", trace::Internal)
  
  // éªŒè¯åµŒå¥—å±‚æ¬¡
  @assert.eq(span5.parent_span_id.unwrap(), span4.context.span_id)
  @assert.eq(span4.parent_span_id.unwrap(), span3.context.span_id)
  @assert.eq(span3.parent_span_id.unwrap(), span2.context.span_id)
  @assert.eq(span2.parent_span_id.unwrap(), span1.context.span_id)
  @assert.assert(span1.parent_span_id.length() == 0, "Root span should not have parent")
}

test "propagation_api_error_handling" {
  // æµ‹è¯•Propagation APIçš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºè½½ä½“
  let empty_carrier = propagation::MapCarrier::new()
  let empty_text_map_propagator = propagation::TextMapPropagator::new()
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„è½½ä½“
  let special_char_carrier = propagation::MapCarrier::new()
  // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾æœ‰MapCarrierçš„setæ–¹æ³•ï¼Œå®é™…APIå¯èƒ½ä¸åŒ
  // special_char_carrier.set("special-key!@#$%^&*()", "special-value!@#$%^&*()")
  
  // æµ‹è¯•æé•¿çš„trace-idå’Œspan-idï¼ˆå¦‚æœæ”¯æŒï¼‰
  let mut long_trace_id = ""
  let mut long_span_id = ""
  let mut i = 0
  while i < 100 {
    long_trace_id = long_trace_id + "a"
    long_span_id = long_span_id + "b"
    i = i + 1
  }
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„æ³¨å…¥å’Œæå–
  let ctx = context::Context::current()
  let span_context = trace::SpanContext::{
    trace_id: Array::make(16, 0_byte),  // å…¨é›¶trace_id
    span_id: Array::make(8, 0_byte),    // å…¨é›¶span_id
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  // æµ‹è¯•å„ç§trace_flagså€¼
  let span_context_max_flags = trace::SpanContext::{
    trace_id: Array::make(16, 255_byte),  // å…¨255 trace_id
    span_id: Array::make(8, 255_byte),    // å…¨255 span_id
    trace_flags: 255_byte,                // æœ€å¤§flagså€¼
    trace_state: "key1=value1,key2=value2"
  }
}

test "common_types_boundary_conditions" {
  // æµ‹è¯•Commonç±»å‹çš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•Resourceçš„è¾¹ç•Œæ¡ä»¶
  let empty_service_name_resource = common::Resource::{
    service_name: "",
    service_version: None,
    telemetry_sdk_name: "",
    telemetry_sdk_version: "",
    attributes: []
  }
  
  @assert.eq(empty_service_name_resource.service_name, "")
  @assert.eq(empty_service_name_resource.telemetry_sdk_name, "")
  @assert.eq(empty_service_name_resource.telemetry_sdk_version, "")
  
  // æµ‹è¯•InstrumentationScopeçš„è¾¹ç•Œæ¡ä»¶
  let empty_scope = common::InstrumentationScope::{
    name: "",
    version: None,
    schema_url: None
  }
  
  @assert.eq(empty_scope.name, "")
  @assert.eq(empty_scope.version, None)
  @assert.eq(empty_scope.schema_url, None)
  
  // æµ‹è¯•æé•¿çš„å­—ç¬¦ä¸²å€¼
  let mut very_long_string = ""
  let mut i = 0
  while i < 5000 {
    very_long_string = very_long_string + "c"
    i = i + 1
  }
  
  let long_string_resource = common::Resource::{
    service_name: very_long_string,
    service_version: Some(very_long_string),
    telemetry_sdk_name: very_long_string,
    telemetry_sdk_version: very_long_string,
    attributes: [
      ("long.key", common::AttributeValue::string(very_long_string)),
      ("long.value", common::AttributeValue::string(very_long_string))
    ]
  }
  
  @assert.eq(long_string_resource.service_name.length(), 5000)
  @assert.eq(long_string_resource.service_version.unwrap().length(), 5000)
  @assert.eq(long_string_resource.telemetry_sdk_name.length(), 5000)
  @assert.eq(long_string_resource.telemetry_sdk_version.length(), 5000)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~ \t\n\r"
  let special_resource = common::Resource::{
    service_name: "service-with-special-chars-" + special_chars,
    service_version: Some("version-with-special-chars-" + special_chars),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: [
      ("special.chars", common::AttributeValue::string(special_chars)),
      ("unicode.chars", common::AttributeValue::string("æµ‹è¯•ä¸­æ–‡å­—ç¬¦ğŸš€emoji")),
      ("emoji.chars", common::AttributeValue::string("ğŸ‰ğŸŠğŸˆğŸ"))
    ]
  }
  
  @assert.assert(special_resource.service_name.contains(special_chars), "Service name should contain special characters")
  @assert.assert(special_resource.service_version.unwrap().contains(special_chars), "Version should contain special characters")
}

test "error_recovery_and_resilience" {
  // æµ‹è¯•é”™è¯¯æ¢å¤å’Œå¼¹æ€§
  
  // æ¨¡æ‹Ÿéƒ¨åˆ†å¤±è´¥çš„é¥æµ‹æ“ä½œ
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("resilience-test")
  
  // åœ¨å„ç§æ¡ä»¶ä¸‹åˆ›å»ºSpan
  let mut i = 0
  while i < 10 {
    let (_, span) = tracer.start_span(
      context::Context::current(),
      "resilience-span-" + i.to_string(),
      trace::Internal,
      [("iteration", common::AttributeValue::int(i.to_int64()))],
      i.to_int64() * 1000000L
    )
    
    // éªŒè¯æ¯ä¸ªSpanéƒ½æ­£ç¡®åˆ›å»º
    @assert.eq(span.name, "resilience-span-" + i.to_string())
    @assert.eq(span.attributes.length(), 1)
    @assert.eq(span.start_time_unix_nanos, i.to_int64() * 1000000L)
    
    i = i + 1
  }
  
  // æµ‹è¯•æŒ‡æ ‡æ“ä½œçš„å¼¹æ€§
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("resilience-meter")
  let counter = meter.create_counter("resilience-counter")
  let histogram = meter.create_histogram("resilience-histogram")
  
  // åœ¨å„ç§æ¡ä»¶ä¸‹è®°å½•æŒ‡æ ‡
  let mut j = 0
  while j < 20 {
    counter.add(j.to_int64(), [("batch", common::AttributeValue::int(j.to_int64()))])
    histogram.record(j.to_float(), [("batch", common::AttributeValue::int(j.to_int64()))])
    j = j + 1
  }
  
  // æµ‹è¯•æ—¥å¿—æ“ä½œçš„å¼¹æ€§
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("resilience-logger")
  
  // åœ¨å„ç§æ¡ä»¶ä¸‹è®°å½•æ—¥å¿—
  let mut k = 0
  while k < 15 {
    let log_record = logs::LogRecord::builder()
      .timestamp(k.to_int64() * 1000000L)
      .severity(match k % 6 {
        0 => logs::Trace
        1 => logs::Debug
        2 => logs::Info
        3 => logs::Warn
        4 => logs::Error
        _ => logs::Fatal
      })
      .body("Resilience log message " + k.to_string())
      .with_attribute("sequence", common::AttributeValue::int(k.to_int64()))
      .build()
    
    logger.emit(log_record)
    k = k + 1
  }
}