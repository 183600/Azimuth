// å…¼å®¹æ€§æµ‹è¯• - æµ‹è¯•ç‰ˆæœ¬å…¼å®¹æ€§

test "api_backward_compatibility" {
  // æµ‹è¯•APIå‘åå…¼å®¹æ€§
  
  // 1. æµ‹è¯•Resourceåˆ›å»ºçš„å‘åå…¼å®¹æ€§
  let resource_v1 = common::Resource::default("test-service")
  
  // éªŒè¯åŸºæœ¬å±æ€§ä¿æŒä¸å˜
  assert_eq(resource_v1.service_name, "test-service")
  assert_eq(resource_v1.service_version, None)
  assert_eq(resource_v1.telemetry_sdk_name, "azimuth")
  assert_eq(resource_v1.telemetry_sdk_version, "0.1.0")
  assert_eq(resource_v1.attributes.length(), 0)
  
  // 2. æµ‹è¯•AttributeValueçš„å‘åå…¼å®¹æ€§
  let string_attr = AttributeValue::string("test")
  let int_attr = AttributeValue::int(42L)
  let float_attr = AttributeValue::float(3.14)
  let bool_attr = AttributeValue::bool(true)
  
  // éªŒè¯æ‰€æœ‰å±æ€§ç±»å‹ä»ç„¶å¯ç”¨
  match string_attr {
    StringValue(s) => assert_eq(s, "test")
    _ => @test.fail("Test failed")
  }
  
  match int_attr {
    IntValue(i) => assert_eq(i, 42L)
    _ => @test.fail("Test failed")
  }
  
  match float_attr {
    FloatValue(f) => assert_eq(f, 3.14)
    _ => @test.fail("Test failed")
  }
  
  match bool_attr {
    BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("Test failed")
  }
  
  // 3. æµ‹è¯•Context APIçš„å‘åå…¼å®¹æ€§
  let ctx = context::Context::empty()
  let key = context::create_key("test-key")
  let ctx_with_value = ctx.with_value(key, "test-value")
  
  match ctx_with_value.get(key) {
    Some(value) => assert_eq(value, "test-value")
    None => @test.fail("Test failed")
  }
  
  // 4. æµ‹è¯•Baggage APIçš„å‘åå…¼å®¹æ€§
  let baggage = context::Baggage::empty()
  let baggage_with_entry = baggage.with_entry("test-entry", "test-value")
  
  match baggage_with_entry.get("test-entry") {
    Some(value) => assert_eq(value, "test-value")
    None => @test.fail("Test failed")
  }
}

test "version_specific_features" {
  // æµ‹è¯•ç‰ˆæœ¬ç‰¹å®šåŠŸèƒ½
  
  // 1. æµ‹è¯•å½“å‰ç‰ˆæœ¬çš„æ‰€æœ‰åŠŸèƒ½
  let resource = common::Resource::default("version-test-service")
  
  // éªŒè¯å½“å‰ç‰ˆæœ¬çš„SDKä¿¡æ¯
  assert_eq(resource.telemetry_sdk_name, "azimuth")
  assert_eq(resource.telemetry_sdk_version, "0.1.0")
  
  // 2. æµ‹è¯•æ•°ç»„å±æ€§ç±»å‹ï¼ˆå¯èƒ½æ˜¯è¾ƒæ–°ç‰ˆæœ¬çš„åŠŸèƒ½ï¼‰
  let string_array = AttributeValue::array_string(["item1", "item2", "item3"])
  let int_array = AttributeValue::array_int([1L, 2L, 3L])
  let float_array = AttributeValue::array_float([1.1, 2.2, 3.3])
  let bool_array = AttributeValue::array_bool([true, false, true])
  
  // éªŒè¯æ•°ç»„ç±»å‹å¯ç”¨
  match string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
  
  match int_array {
    ArrayIntValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
  
  match float_array {
    ArrayFloatValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
  
  match bool_array {
    ArrayBoolValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
  
  // 3. æµ‹è¯•LogRecordBuilderçš„æ‰€æœ‰åŠŸèƒ½
  let log_record = logs::LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(logs::Info)
    .body("Version test log")
    .with_attribute("version.test", AttributeValue::string("0.1.0"))
    .build()
  
  // éªŒè¯LogRecordBuilderåŠŸèƒ½å®Œæ•´
  match log_record.body {
    Some(body) => assert_eq(body, "Version test log")
    None => @test.fail("Test failed")
  }
  
  match log_record.severity_number {
    logs::Info => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  assert_eq(log_record.attributes.length(), 1)
}

test "cross_version_interoperability" {
  // æµ‹è¯•è·¨ç‰ˆæœ¬äº’æ“ä½œæ€§
  
  // 1. æ¨¡æ‹Ÿä¸åŒç‰ˆæœ¬çš„æ•°æ®æ ¼å¼
  let v1_resource = common::Resource::default("v1-service")
  let v2_resource = common::Resource::default("v2-service")
  
  // éªŒè¯ä¸åŒç‰ˆæœ¬åˆ›å»ºçš„èµ„æºå¯ä»¥å…±å­˜
  assert_eq(v1_resource.service_name, "v1-service")
  assert_eq(v2_resource.service_name, "v2-service")
  
  // 2. æµ‹è¯•ä¸åŒç‰ˆæœ¬çš„å±æ€§æ ¼å¼å…¼å®¹æ€§
  let v1_attrs : Array[(String, common::AttributeValue)] = [
    ("legacy.attr", AttributeValue::string("legacy-value")),
    ("numeric.attr", AttributeValue::int(100L))
  ]
  
  let v2_attrs : Array[(String, common::AttributeValue)] = [
    ("legacy.attr", AttributeValue::string("legacy-value")),
    ("numeric.attr", AttributeValue::int(100L)),
    ("array.attr", AttributeValue::array_string(["new", "feature"]))
  ]
  
  // éªŒè¯å±æ€§æ ¼å¼å…¼å®¹
  assert_eq(v1_attrs.length(), 2)
  assert_eq(v2_attrs.length(), 3)
  
  // 3. æµ‹è¯•ä¸åŒç‰ˆæœ¬çš„SpanKindå…¼å®¹æ€§
  let ctx = context::Context::empty()
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("compatibility-test-tracer")
  
  let (v1_ctx, v1_span) = tracer.start_span(ctx, "v1-span", trace::Internal)
  let (v2_ctx, v2_span) = tracer.start_span(ctx, "v2-span", trace::Server)
  
  // éªŒè¯æ‰€æœ‰SpanKindä»ç„¶å¯ç”¨
  match v1_span.kind { trace::Internal => assert_eq(true, true) _ => @test.fail("Test failed") }
  match v2_span.kind { trace::Server => assert_eq(true, true) _ => @test.fail("Test failed") }
  
  // 4. æµ‹è¯•ä¸åŒç‰ˆæœ¬çš„SeverityNumberå…¼å®¹æ€§
  let v1_log = logs::LogRecord::builder().severity(logs::Info).build()
  let v2_log = logs::LogRecord::builder().severity(logs::Warn).build()
  
  match v1_log.severity_number { logs::Info => assert_eq(true, true) _ => @test.fail("Test failed") }
  match v2_log.severity_number { logs::Warn => assert_eq(true, true) _ => @test.fail("Test failed") }
}

test "deprecation_compatibility" {
  // æµ‹è¯•å¼ƒç”¨åŠŸèƒ½çš„å…¼å®¹æ€§
  
  // 1. æµ‹è¯•å¯èƒ½å¼ƒç”¨çš„åŠŸèƒ½ä»ç„¶å¯ç”¨
  let resource = common::Resource::default("deprecation-test")
  
  // éªŒè¯æ—§çš„Resourceåˆ›å»ºæ–¹å¼ä»ç„¶å·¥ä½œ
  assert_eq(resource.service_name, "deprecation-test")
  assert_eq(resource.telemetry_sdk_name, "azimuth")
  
  // 2. æµ‹è¯•å¯èƒ½å¼ƒç”¨çš„å±æ€§ç±»å‹
  let legacy_string = AttributeValue::string("legacy")
  let legacy_int = AttributeValue::int(42)
  let legacy_float = AttributeValue::float(3.14)
  let legacy_bool = AttributeValue::bool(true)
  
  // éªŒè¯æ—§çš„å±æ€§ç±»å‹ä»ç„¶å¯ç”¨
  match legacy_string {
    StringValue(s) => assert_eq(s, "legacy")
    _ => @test.fail("Test failed")
  }
  
  match legacy_int {
    IntValue(i) => assert_eq(i, 42L)
    _ => @test.fail("Test failed")
  }
  
  match legacy_float {
    FloatValue(f) => assert_eq(f, 3.14)
    _ => @test.fail("Test failed")
  }
  
  match legacy_bool {
    BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("Test failed")
  }
  
  // 3. æµ‹è¯•å¯èƒ½å¼ƒç”¨çš„APIè°ƒç”¨
  let ctx = context::Context::empty()
  let key = context::create_key("legacy-key")
  let ctx_with_legacy = ctx.with_value(key, "legacy-value")
  
  match ctx_with_legacy.get(key) {
    Some(value) => assert_eq(value, "legacy-value")
    None => @test.fail("Test failed")
  }
  
  // 4. æµ‹è¯•å¯èƒ½å¼ƒç”¨çš„ä¼ æ’­æ ¼å¼
  let carrier = propagation::MapCarrier::new()
  let trace_propagator = propagation::W3CTraceContextPropagator::{}
  
  trace_propagator.inject(ctx, carrier)
  
  match carrier.get(propagation::TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
}

test "future_compatibility" {
  // æµ‹è¯•æœªæ¥å…¼å®¹æ€§
  
  // 1. æµ‹è¯•æ‰©å±•æ€§ - é¢„ç•™æœªæ¥æ‰©å±•çš„ç©ºé—´
  let resource = common::Resource::default("future-test")
  
  // éªŒè¯å½“å‰ç»“æ„å¯ä»¥å®¹çº³æœªæ¥æ‰©å±•
  assert_eq(resource.service_name, "future-test")
  assert_eq(resource.service_version, None)  // å¯ä»¥ä¸ºæœªæ¥ç‰ˆæœ¬é¢„ç•™
  
  // 2. æµ‹è¯•å±æ€§æ‰©å±•æ€§
  let extensible_attrs : Array[(String, common::AttributeValue)] = [
    ("current.attr", AttributeValue::string("current")),
    ("future.attr1", AttributeValue::string("future1")),
    ("future.attr2", AttributeValue::int(123L)),
    ("future.attr3", AttributeValue::bool(true))
  ]
  
  // éªŒè¯å¯ä»¥æ·»åŠ æœªæ¥çš„å±æ€§
  assert_eq(extensible_attrs.length(), 4)
  
  // 3. æµ‹è¯•æšä¸¾æ‰©å±•æ€§
  let all_severities = [
    logs::Trace, logs::Debug, logs::Info, logs::Warn, logs::Error, logs::Fatal
  ]
  
  // éªŒè¯æ‰€æœ‰å½“å‰ä¸¥é‡çº§åˆ«éƒ½å¯ç”¨
  assert_eq(all_severities.length(), 6)
  
  let all_kinds = [
    trace::Internal, trace::Server, trace::Client, trace::Producer, trace::Consumer
  ]
  
  // éªŒè¯æ‰€æœ‰å½“å‰SpanKindéƒ½å¯ç”¨
  assert_eq(all_kinds.length(), 5)
  
  // 4. æµ‹è¯•ä¼ æ’­æ ¼å¼æ‰©å±•æ€§
  let carrier = propagation::MapCarrier::from_map([
    ("existing.header", "existing-value"),
    ("future.header1", "future-value1"),
    ("future.header2", "future-value2")
  ])
  
  // éªŒè¯å¯ä»¥æ·»åŠ æœªæ¥çš„å¤´éƒ¨
  let keys = carrier.keys()
  assert_eq(keys.length(), 3)
  
  // 5. æµ‹è¯•æ•°ç»„ç±»å‹æ‰©å±•æ€§
  let large_arrays = [
    AttributeValue::array_string([for i = 0; i < 1000; i = i + 1].map(fn(_) { "item" })),
    AttributeValue::array_int([for i = 0; i < 1000; i = i + 1].map(fn(_) { 1L })),
    AttributeValue::array_float([for i = 0; i < 1000; i = i + 1].map(fn(_) { 1.0 })),
    AttributeValue::array_bool([for i = 0; i < 1000; i = i + 1].map(fn(_) { true }))
  ]
  
  // éªŒè¯æ•°ç»„å¯ä»¥å¤„ç†å¤§é‡æ•°æ®ï¼ˆä¸ºæœªæ¥æ‰©å±•åšå‡†å¤‡ï¼‰
  let mut i = 0
  while i < large_arrays.length() {
    match large_arrays[i] {
      ArrayStringValue(arr) => assert_eq(arr.length(), 1000)
      ArrayIntValue(arr) => assert_eq(arr.length(), 1000)
      ArrayFloatValue(arr) => assert_eq(arr.length(), 1000)
      ArrayBoolValue(arr) => assert_eq(arr.length(), 1000)
      _ => @test.fail("Test failed")
    }
    i = i + 1
  }
}

test "configuration_compatibility" {
  // æµ‹è¯•é…ç½®å…¼å®¹æ€§
  
  // 1. æµ‹è¯•é»˜è®¤é…ç½®çš„å…¼å®¹æ€§
  let default_resource = common::Resource::default("config-test")
  
  // éªŒè¯é»˜è®¤é…ç½®å€¼
  assert_eq(default_resource.telemetry_sdk_name, "azimuth")
  assert_eq(default_resource.telemetry_sdk_version, "0.1.0")
  assert_eq(default_resource.service_version, None)
  assert_eq(default_resource.attributes.length(), 0)
  
  // 2. æµ‹è¯•ä¸åŒé…ç½®ç»„åˆçš„å…¼å®¹æ€§
  let config1 = common::Resource::default("config1")
  let config2 = common::Resource::default("config2")
  let config3 = common::Resource::default("config3")
  
  // éªŒè¯ä¸åŒé…ç½®å¯ä»¥å…±å­˜
  assert_eq(config1.service_name, "config1")
  assert_eq(config2.service_name, "config2")
  assert_eq(config3.service_name, "config3")
  
  // 3. æµ‹è¯•ä¼ æ’­å™¨é…ç½®å…¼å®¹æ€§
  let trace_propagator = propagation::W3CTraceContextPropagator::{}
  let baggage_propagator = propagation::W3CBaggagePropagator::{}
  let composite = propagation::CompositePropagator::new([trace_propagator, baggage_propagator])
  
  // éªŒè¯ä¸åŒä¼ æ’­å™¨é…ç½®å¯ä»¥å·¥ä½œ
  let ctx = context::Context::empty()
  let carrier = propagation::MapCarrier::new()
  
  trace_propagator.inject(ctx, carrier)
  baggage_propagator.inject(ctx, carrier)
  composite.inject(ctx, carrier)
  
  // 4. æµ‹è¯•æŒ‡æ ‡é…ç½®å…¼å®¹æ€§
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("config-meter", "1.0.0", "http://example.com/schema")
  
  // éªŒè¯meteré…ç½®
  let counter = meter.create_counter("config-counter", "count", "Config test counter")
  let histogram = meter.create_histogram("config-histogram", "ms", "Config test histogram")
  let gauge = meter.create_gauge("config-gauge", "percent", "Config test gauge")
  let up_down = meter.create_up_down_counter("config-updown", "count", "Config test up-down")
  
  // éªŒè¯æ‰€æœ‰æŒ‡æ ‡ç±»å‹éƒ½å¯ä»¥åˆ›å»º
  counter.add(1L)
  histogram.record(100.0)
  gauge.record(75.0)
  up_down.add(1L)
  
  // 5. æµ‹è¯•æ—¥å¿—é…ç½®å…¼å®¹æ€§
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("config-logger", "1.0.0", "http://example.com/schema")
  
  // éªŒè¯loggeré…ç½®
  logger.debug("Debug message", [])
  logger.info("Info message", [])
  logger.warn("Warn message", [])
  logger.error("Error message", [])
  logger.fatal("Fatal message", [])
}

test "data_format_compatibility" {
  // æµ‹è¯•æ•°æ®æ ¼å¼å…¼å®¹æ€§
  
  // 1. æµ‹è¯•å±æ€§å€¼æ ¼å¼å…¼å®¹æ€§
  let string_values = [
    AttributeValue::string(""),
    AttributeValue::string("simple"),
    AttributeValue::string("with spaces"),
    AttributeValue::string("with-symbols!@#$%"),
    AttributeValue::string("Unicodeæµ‹è¯•ğŸš€"),
    AttributeValue::string("very-long-string-" + "x" * 1000)
  ]
  
  // éªŒè¯å„ç§å­—ç¬¦ä¸²æ ¼å¼
  let mut i = 0
  while i < string_values.length() {
    match string_values[i] {
      StringValue(s) => assert_eq(s.length() > 0, true)
      _ => @test.fail("Test failed")
    }
    i = i + 1
  }
  
  // 2. æµ‹è¯•æ•°å€¼æ ¼å¼å…¼å®¹æ€§
  let numeric_values = [
    AttributeValue::int(0L),
    AttributeValue::int(-1L),
    AttributeValue::int(1L),
    AttributeValue::int(9223372036854775807L),  // Int64æœ€å¤§å€¼
    AttributeValue::int(-9223372036854775808L), // Int64æœ€å°å€¼
    AttributeValue::float(0.0),
    AttributeValue::float(-1.0),
    AttributeValue::float(1.0),
    AttributeValue::float(1.7976931348623157e+308), // Doubleæœ€å¤§å€¼
    AttributeValue::float(-1.7976931348623157e+308), // Doubleæœ€å°å€¼
    AttributeValue::float(1.0/0.0), // æ— ç©·å¤§
    AttributeValue::float(0.0/0.0)  // NaN
  ]
  
  // éªŒè¯å„ç§æ•°å€¼æ ¼å¼
  i = 0
  while i < numeric_values.length() {
    match numeric_values[i] {
      IntValue(_) => assert_eq(true, true)
      FloatValue(_) => assert_eq(true, true)
      _ => @test.fail("Test failed")
    }
    i = i + 1
  }
  
  // 3. æµ‹è¯•æ•°ç»„æ ¼å¼å…¼å®¹æ€§
  let array_formats = [
    AttributeValue::array_string([]),
    AttributeValue::array_string(["single"]),
    AttributeValue::array_string(["multiple", "values"]),
    AttributeValue::array_int([]),
    AttributeValue::array_int([1L]),
    AttributeValue::array_int([1L, 2L, 3L]),
    AttributeValue::array_float([]),
    AttributeValue::array_float([1.0]),
    AttributeValue::array_float([1.1, 2.2, 3.3]),
    AttributeValue::array_bool([]),
    AttributeValue::array_bool([true]),
    AttributeValue::array_bool([true, false, true])
  ]
  
  // éªŒè¯å„ç§æ•°ç»„æ ¼å¼
  i = 0
  while i < array_formats.length() {
    match array_formats[i] {
      ArrayStringValue(_) => assert_eq(true, true)
      ArrayIntValue(_) => assert_eq(true, true)
      ArrayFloatValue(_) => assert_eq(true, true)
      ArrayBoolValue(_) => assert_eq(true, true)
      _ => @test.fail("Test failed")
    }
    i = i + 1
  }
  
  // 4. æµ‹è¯•ä¼ æ’­æ ¼å¼å…¼å®¹æ€§
  let ctx = context::Context::empty()
  let carrier = propagation::MapCarrier::from_map([
    ("simple.header", "simple-value"),
    ("complex.header", "complex-value-with-dashes"),
    ("numeric.header", "12345"),
    ("empty.header", ""),
    ("unicode.header", "Unicodeæµ‹è¯•ğŸš€")
  ])
  
  // éªŒè¯å„ç§å¤´éƒ¨æ ¼å¼
  let trace_propagator = propagation::W3CTraceContextPropagator::{}
  let extracted_ctx = trace_propagator.extract(ctx, carrier)
  
  // éªŒè¯æå–æ“ä½œæˆåŠŸ
  assert_eq(true, true)
}