// Azimuth Telemetry - Error Handling Test
// æµ‹è¯•å„ç§é”™è¯¯æƒ…å†µçš„å¤„ç†

use azimuth.telemetry.api.common
use azimuth.telemetry.api.context
use azimuth.telemetry.api.trace
use azimuth.telemetry.api.metrics
use azimuth.telemetry.api.logs

// é”™è¯¯ç±»å‹å®šä¹‰
pub enum TelemetryError {
  InvalidArgument(String)
  InvalidState(String)
  ResourceExhausted(String)
  InternalError(String)
  TimeoutError(String)
  NetworkError(String)
  SerializationError(String)
  ConfigurationError(String)
}

// é”™è¯¯å¤„ç†è¾…åŠ©ç»“æ„
pub struct ErrorHandler {
  error_count : Int
  last_error : TelemetryError?
  error_history : Array[TelemetryError]
}

pub fn ErrorHandler::new() -> ErrorHandler {
  ErrorHandler::{
    error_count: 0,
    last_error: None,
    error_history: []
  }
}

pub fn ErrorHandler::handle_error(self : ErrorHandler, error : TelemetryError) -> ErrorHandler {
  ErrorHandler::{
    error_count: self.error_count + 1,
    last_error: Some(error),
    error_history: self.error_history.push(error)
  }
}

pub fn ErrorHandler::has_errors(self : ErrorHandler) -> Bool {
  self.error_count > 0
}

pub fn ErrorHandler::get_error_count(self : ErrorHandler) -> Int {
  self.error_count
}

test "trace_error_handling" {
  // æµ‹è¯•Trace APIçš„é”™è¯¯å¤„ç†
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("error-test-tracer", "1.0.0")
  let ctx = context::Context::new()
  let mut error_handler = ErrorHandler::new()
  
  // æµ‹è¯•ç©ºSpanåç§°å¤„ç†
  let (_, empty_span) = tracer.start_span(ctx, "", trace::Internal, [], 0L)
  @assert(empty_span.name == "") // No-opå®ç°åº”è¯¥èƒ½å¤„ç†ç©ºåç§°
  
  // æµ‹è¯•æé•¿Spanåç§°å¤„ç†
  let long_name = "a" * 10000 // åˆ›å»º10000ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²
  let (_, long_span) = tracer.start_span(ctx, long_name, trace::Internal, [], 0L)
  @assert(long_span.name.length() == 10000)
  
  // æµ‹è¯•æ— æ•ˆæ—¶é—´æˆ³å¤„ç†
  let (_, invalid_time_span) = tracer.start_span(ctx, "invalid-time-span", trace::Internal, [], -1L)
  @assert(invalid_time_span.start_time_unix_nanos == -1L)
  
  let (_, max_time_span) = tracer.start_span(ctx, "max-time-span", trace::Internal, [], 9223372036854775807L)
  @assert(max_time_span.start_time_unix_nanos == 9223372036854775807L)
  
  // æµ‹è¯•ç©ºå±æ€§æ•°ç»„å¤„ç†
  let (_, empty_attrs_span) = tracer.start_span(ctx, "empty-attrs-span", trace::Internal, [], 0L)
  @assert(empty_attrs_span.attributes.length() == 0)
  
  // æµ‹è¯•å¤§é‡å±æ€§å¤„ç†
  let mut large_attrs = []
  let mut i = 0
  while i < 1000 {
    large_attrs.push(("attr." + i.to_string(), common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  
  let (_, large_attrs_span) = tracer.start_span(ctx, "large-attrs-span", trace::Internal, large_attrs, 0L)
  @assert(large_attrs_span.attributes.length() == 1000)
  
  // æµ‹è¯•æ— æ•ˆå±æ€§å€¼å¤„ç†
  let invalid_attrs = [
    ("null.key", common::AttributeValue::string("")),
    ("empty.key", common::AttributeValue::string(""))
  ]
  
  let (_, invalid_attrs_span) = tracer.start_span(ctx, "invalid-attrs-span", trace::Internal, invalid_attrs, 0L)
  @assert(invalid_attrs_span.attributes.length() == 2)
  
  // éªŒè¯é”™è¯¯å¤„ç†çŠ¶æ€
  @assert(!error_handler.has_errors())
  @assert(error_handler.get_error_count() == 0)
}

test "metrics_error_handling" {
  // æµ‹è¯•Metrics APIçš„é”™è¯¯å¤„ç†
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("error-test-meter", "1.0.0")
  let mut error_handler = ErrorHandler::new()
  
  // æµ‹è¯•ç©ºæŒ‡æ ‡åç§°å¤„ç†
  let empty_counter = meter.create_counter("", "count", "")
  empty_counter.add(1L, [])
  @assert(true) // No-opå®ç°åº”è¯¥èƒ½å¤„ç†ç©ºåç§°
  
  let empty_histogram = meter.create_histogram("", "ms", "")
  empty_histogram.record(1.0, [])
  @assert(true)
  
  // æµ‹è¯•æé•¿æŒ‡æ ‡åç§°å¤„ç†
  let long_name = "a" * 10000
  let long_counter = meter.create_counter(long_name, "count", "Long name counter")
  long_counter.add(1L, [])
  @assert(true)
  
  let long_histogram = meter.create_histogram(long_name, "ms", "Long name histogram")
  long_histogram.record(1.0, [])
  @assert(true)
  
  // æµ‹è¯•è´Ÿæ•°æŒ‡æ ‡å€¼å¤„ç†ï¼ˆCounterï¼‰
  let negative_counter = meter.create_counter("negative.test", "count", "Negative test counter")
  negative_counter.add(-1L, []) // No-opå®ç°åº”è¯¥èƒ½å¤„ç†è´Ÿæ•°
  @assert(true)
  
  // æµ‹è¯•NaNå’Œæ— ç©·å¤§å€¼å¤„ç†ï¼ˆHistogramï¼‰
  let nan_histogram = meter.create_histogram("nan.test", "ms", "NaN test histogram")
  nan_histogram.record(0.0 / 0.0, []) // NaN
  nan_histogram.record(1.0 / 0.0, []) // +Infinity
  nan_histogram.record(-1.0 / 0.0, []) // -Infinity
  @assert(true)
  
  // æµ‹è¯•æå¤§å€¼å¤„ç†
  let large_histogram = meter.create_histogram("large.test", "ms", "Large value test histogram")
  large_histogram.record(1.7976931348623157e+308, []) // æœ€å¤§Doubleå€¼
  large_histogram.record(-1.7976931348623157e+308, []) // æœ€å°Doubleå€¼
  @assert(true)
  
  // æµ‹è¯•ç©ºå±æ€§æ•°ç»„å¤„ç†
  let empty_counter = meter.create_counter("empty.attrs.test", "count", "Empty attrs test")
  empty_counter.add(1L, [])
  @assert(true)
  
  // æµ‹è¯•å¤§é‡å±æ€§å¤„ç†
  let mut large_attrs = []
  let mut i = 0
  while i < 1000 {
    large_attrs.push(("attr." + i.to_string(), common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  
  let large_counter = meter.create_counter("large.attrs.test", "count", "Large attrs test")
  large_counter.add(1L, large_attrs)
  @assert(true)
  
  // æµ‹è¯•æ— æ•ˆå±æ€§å€¼å¤„ç†
  let invalid_attrs = [
    ("null.value", common::AttributeValue::string("")),
    ("empty.value", common::AttributeValue::string(""))
  ]
  
  let invalid_counter = meter.create_counter("invalid.attrs.test", "count", "Invalid attrs test")
  invalid_counter.add(1L, invalid_attrs)
  @assert(true)
  
  // éªŒè¯é”™è¯¯å¤„ç†çŠ¶æ€
  @assert(!error_handler.has_errors())
  @assert(error_handler.get_error_count() == 0)
}

test "logs_error_handling" {
  // æµ‹è¯•Logs APIçš„é”™è¯¯å¤„ç†
  
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("error-test-logger", "1.0.0")
  let mut error_handler = ErrorHandler::new()
  
  // æµ‹è¯•ç©ºæ—¥å¿—æ¶ˆæ¯å¤„ç†
  logger.info("", [])
  logger.warn("", [])
  logger.error("", [])
  logger.debug("", [])
  logger.fatal("", [])
  @assert(true) // No-opå®ç°åº”è¯¥èƒ½å¤„ç†ç©ºæ¶ˆæ¯
  
  // æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯å¤„ç†
  let long_message = "a" * 1000000 // 100ä¸‡ä¸ªå­—ç¬¦
  logger.info(long_message, [])
  @assert(true)
  
  // æµ‹è¯•æ— æ•ˆæ—¶é—´æˆ³å¤„ç†
  let invalid_log_record = logs::LogRecord::builder()
    .timestamp(-1L)
    .severity(logs::Info)
    .body("Invalid timestamp test")
    .build()
  
  logger.emit(invalid_log_record)
  @assert(true)
  
  // æµ‹è¯•æå¤§æ—¶é—´æˆ³å¤„ç†
  let max_log_record = logs::LogRecord::builder()
    .timestamp(9223372036854775807L)
    .severity(logs::Info)
    .body("Max timestamp test")
    .build()
  
  logger.emit(max_log_record)
  @assert(true)
  
  // æµ‹è¯•ç©ºå±æ€§æ•°ç»„å¤„ç†
  let empty_log_record = logs::LogRecord::builder()
    .timestamp(1234567890L)
    .severity(logs::Info)
    .body("Empty attributes test")
    .build()
  
  logger.emit(empty_log_record)
  @assert(true)
  
  // æµ‹è¯•å¤§é‡å±æ€§å¤„ç†
  let mut large_log_record = logs::LogRecord::builder()
    .timestamp(1234567890L)
    .severity(logs::Info)
    .body("Large attributes test")
  
  let mut i = 0
  while i < 1000 {
    large_log_record = large_log_record.with_attribute(
      "attr." + i.to_string(),
      common::AttributeValue::int(i.to_int64())
    )
    i = i + 1
  }
  
  logger.emit(large_log_record.build())
  @assert(true)
  
  // æµ‹è¯•æ— æ•ˆå±æ€§å€¼å¤„ç†
  let invalid_log_record = logs::LogRecord::builder()
    .timestamp(1234567890L)
    .severity(logs::Info)
    .body("Invalid attributes test")
    .with_attribute("null.value", common::AttributeValue::string(""))
    .with_attribute("empty.value", common::AttributeValue::string(""))
    .build()
  
  logger.emit(invalid_log_record)
  @assert(true)
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡çº§åˆ«å¤„ç†
  let mut severity = logs::Trace
  while severity <= logs::Fatal {
    let severity_log_record = logs::LogRecord::builder()
      .timestamp(1234567890L)
      .severity(severity)
      .body("Severity test")
      .build()
    
    logger.emit(severity_log_record)
    severity = match severity {
      logs::Trace => logs::Debug
      logs::Debug => logs::Info
      logs::Info => logs::Warn
      logs::Warn => logs::Error
      logs::Error => logs::Fatal
      logs::Fatal => logs::Fatal // ç»“æŸå¾ªç¯
    }
  }
  
  // éªŒè¯é”™è¯¯å¤„ç†çŠ¶æ€
  @assert(!error_handler.has_errors())
  @assert(error_handler.get_error_count() == 0)
}

test "attribute_error_handling" {
  // æµ‹è¯•å±æ€§å€¼çš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•å­—ç¬¦ä¸²å±æ€§è¾¹ç•Œæƒ…å†µ
  let empty_string_attr = common::AttributeValue::string("")
  let long_string_attr = common::AttributeValue::string("a" * 100000)
  let unicode_string_attr = common::AttributeValue::string("æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸² ğŸš€ emoji")
  let special_char_string_attr = common::AttributeValue::string("Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  @assert(match empty_string_attr { common::StringValue(s) => s == "" _ => false })
  @assert(match long_string_attr { common::StringValue(s) => s.length() == 100000 _ => false })
  @assert(match unicode_string_attr { common::StringValue(s) => s.length() > 0 _ => false })
  @assert(match special_char_string_attr { common::StringValue(s) => s.length() > 0 _ => false })
  
  // æµ‹è¯•æ•´æ•°å±æ€§è¾¹ç•Œæƒ…å†µ
  let min_int_attr = common::AttributeValue::int(-9223372036854775808L)
  let max_int_attr = common::AttributeValue::int(9223372036854775807L)
  let zero_int_attr = common::AttributeValue::int(0L)
  
  @assert(match min_int_attr { common::IntValue(v) => v == -9223372036854775808L _ => false })
  @assert(match max_int_attr { common::IntValue(v) => v == 9223372036854775807L _ => false })
  @assert(match zero_int_attr { common::IntValue(v) => v == 0L _ => false })
  
  // æµ‹è¯•æµ®ç‚¹æ•°å±æ€§è¾¹ç•Œæƒ…å†µ
  let min_float_attr = common::AttributeValue::float(-1.7976931348623157e+308)
  let max_float_attr = common::AttributeValue::float(1.7976931348623157e+308)
  let nan_float_attr = common::AttributeValue::float(0.0 / 0.0)
  let inf_float_attr = common::AttributeValue::float(1.0 / 0.0)
  let neg_inf_float_attr = common::AttributeValue::float(-1.0 / 0.0)
  let zero_float_attr = common::AttributeValue::float(0.0)
  
  @assert(match min_float_attr { common::FloatValue(v) => v == -1.7976931348623157e+308 _ => false })
  @assert(match max_float_attr { common::FloatValue(v) => v == 1.7976931348623157e+308 _ => false })
  @assert(match nan_float_attr { common::FloatValue(v) => (v != v) _ => false }) // NaN check
  @assert(match inf_float_attr { common::FloatValue(v) => v == 1.0 / 0.0 _ => false })
  @assert(match neg_inf_float_attr { common::FloatValue(v) => v == -1.0 / 0.0 _ => false })
  @assert(match zero_float_attr { common::FloatValue(v) => v == 0.0 _ => false })
  
  // æµ‹è¯•å¸ƒå°”å±æ€§
  let true_attr = common::AttributeValue::bool(true)
  let false_attr = common::AttributeValue::bool(false)
  
  @assert(match true_attr { common::BoolValue(v) => v == true _ => false })
  @assert(match false_attr { common::BoolValue(v) => v == false _ => false })
  
  // æµ‹è¯•æ•°ç»„å±æ€§è¾¹ç•Œæƒ…å†µ
  let empty_string_array = common::AttributeValue::array_string([])
  let large_string_array = common::AttributeValue::array_string(["a" * 1000; 1000]) // 1000ä¸ªé•¿å­—ç¬¦ä¸²
  let empty_int_array = common::AttributeValue::array_int([])
  let large_int_array = common::AttributeValue::array_int([0L; 10000]) // 10000ä¸ªæ•´æ•°
  let empty_float_array = common::AttributeValue::array_float([])
  let large_float_array = common::AttributeValue::array_float([0.0; 10000]) // 10000ä¸ªæµ®ç‚¹æ•°
  let empty_bool_array = common::AttributeValue::array_bool([])
  let large_bool_array = common::AttributeValue::array_bool([true; 10000]) // 10000ä¸ªå¸ƒå°”å€¼
  
  @assert(match empty_string_array { common::ArrayStringValue(arr) => arr.length() == 0 _ => false })
  @assert(match large_string_array { common::ArrayStringValue(arr) => arr.length() == 1000 _ => false })
  @assert(match empty_int_array { common::ArrayIntValue(arr) => arr.length() == 0 _ => false })
  @assert(match large_int_array { common::ArrayIntValue(arr) => arr.length() == 10000 _ => false })
  @assert(match empty_float_array { common::ArrayFloatValue(arr) => arr.length() == 0 _ => false })
  @assert(match large_float_array { common::ArrayFloatValue(arr) => arr.length() == 10000 _ => false })
  @assert(match empty_bool_array { common::ArrayBoolValue(arr) => arr.length() == 0 _ => false })
  @assert(match large_bool_array { common::ArrayBoolValue(arr) => arr.length() == 10000 _ => false })
}

test "resource_error_handling" {
  // æµ‹è¯•èµ„æºé”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºæœåŠ¡å
  let empty_resource = common::Resource::default("")
  @assert(empty_resource.service_name == "")
  
  // æµ‹è¯•æé•¿æœåŠ¡å
  let long_service_name = "a" * 10000
  let long_resource = common::Resource::default(long_service_name)
  @assert(long_resource.service_name.length() == 10000)
  
  // æµ‹è¯•UnicodeæœåŠ¡å
  let unicode_service_name = "æµ‹è¯•æœåŠ¡ ğŸš€"
  let unicode_resource = common::Resource::default(unicode_service_name)
  @assert(unicode_resource.service_name == unicode_service_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æœåŠ¡å
  let special_service_name = "Special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_resource = common::Resource::default(special_service_name)
  @assert(special_resource.service_name == special_service_name)
  
  // æµ‹è¯•æé•¿ç‰ˆæœ¬å·
  let long_version = "1.0.0-" + ("a" * 1000)
  let long_version_resource = common::Resource::{
    service_name: "test-service",
    service_version: Some(long_version),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: []
  }
  @assert(long_version_resource.service_version.unwrap_or("").length() > 1000)
  
  // æµ‹è¯•å¤§é‡èµ„æºå±æ€§
  let mut large_attrs = []
  let mut i = 0
  while i < 1000 {
    large_attrs.push(("resource.attr." + i.to_string(), common::AttributeValue::string("value." + i.to_string())))
    i = i + 1
  }
  
  let large_attrs_resource = common::Resource::{
    service_name: "large-attrs-service",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: large_attrs
  }
  @assert(large_attrs_resource.attributes.length() == 1000)
  
  // æµ‹è¯•æ— æ•ˆèµ„æºå±æ€§
  let invalid_attrs_resource = common::Resource::{
    service_name: "invalid-attrs-service",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: [
      ("", common::AttributeValue::string("empty key")),
      ("null.value", common::AttributeValue::string("")),
      ("special.key!@#$%", common::AttributeValue::string("special key"))
    ]
  }
  @assert(invalid_attrs_resource.attributes.length() == 3)
}

test "context_error_handling" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_ctx = context::Context::new()
  @assert(true) // åº”è¯¥èƒ½æ­£å¸¸åˆ›å»ºç©ºä¸Šä¸‹æ–‡
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¸æ— æ•ˆæ•°æ®äº¤äº’
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("context-error-test-tracer")
  
  // ä½¿ç”¨ç©ºä¸Šä¸‹æ–‡åˆ›å»ºSpan
  let (_, empty_ctx_span) = tracer.start_span(empty_ctx, "empty-context-span", trace::Internal, [], 0L)
  @assert(empty_ctx_span.name == "empty-context-span")
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¼ æ’­ä¸­çš„é”™è¯¯å¤„ç†
  let (ctx1, span1) = tracer.start_span(empty_ctx, "parent-span", trace::Internal, [], 0L)
  let (_, span2) = tracer.start_span(ctx1, "child-span", trace::Internal, [], 0L)
  
  // éªŒè¯çˆ¶å­å…³ç³»ï¼ˆå³ä½¿æœ‰é”™è¯¯ä¹Ÿåº”è¯¥ä¿æŒåŸºæœ¬ç»“æ„ï¼‰
  @assert(span1.name == "parent-span")
  @assert(span2.name == "child-span")
  @assert(span1.context.trace_id.length() == 16)
  @assert(span2.context.trace_id.length() == 16)
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¸æ— æ•ˆå±æ€§äº¤äº’
  let invalid_attrs = [
    ("", common::AttributeValue::string("empty key")),
    ("null.value", common::AttributeValue::string("")),
    ("special!@#$%", common::AttributeValue::string("special key"))
  ]
  
  let (_, invalid_attrs_span) = tracer.start_span(empty_ctx, "invalid-attrs-span", trace::Internal, invalid_attrs, 0L)
  @assert(invalid_attrs_span.attributes.length() == 3)
}