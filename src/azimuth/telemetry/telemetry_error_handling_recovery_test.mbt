// é¥æµ‹ç³»ç»Ÿé”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•
// æµ‹è¯•å„ç§å¼‚å¸¸æƒ…å†µä¸‹çš„é”™è¯¯å¤„ç†æœºåˆ¶å’Œæ¢å¤èƒ½åŠ›

test "invalid_attribute_handling" {
  // æµ‹è¯•æ— æ•ˆå±æ€§çš„å¤„ç†
  
  // æµ‹è¯•ç©ºé”®å
  let empty_key_attr = ("", common::AttributeValue::string("value"))
  assert_eq(empty_key_attr.0, "")
  assert_eq(empty_key_attr.1, common::StringValue("value"))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  let empty_string_attr = ("key", common::AttributeValue::string(""))
  match empty_string_attr.1 {
    common::StringValue(value) => assert_eq(value, "")
    _ => @test.fail("Expected StringValue")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®å
  let special_key_attr = ("key-with.special@chars#", common::AttributeValue::string("value"))
  assert_eq(special_key_attr.0, "key-with.special@chars#")
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²å€¼
  let special_value_attr = ("key", common::AttributeValue::string("value\nwith\tspecial\rchars"))
  match special_value_attr.1 {
    common::StringValue(value) => {
      assert_eq(value.contains("\n"), true)
      assert_eq(value.contains("\t"), true)
      assert_eq(value.contains("\r"), true)
    }
    _ => @test.fail("Expected StringValue")
  }
  
  // æµ‹è¯•æç«¯æ•°å€¼
  let extreme_values = [
    ("max_int", common::AttributeValue::int(9223372036854775807L)),
    ("min_int", common::AttributeValue::int(-9223372036854775808L)),
    ("max_float", common::AttributeValue::float(1.7976931348623157e+308)),
    ("min_float", common::AttributeValue::float(-1.7976931348623157e+308)),
    ("infinity", common::AttributeValue::float(1.0/0.0)),  // æ­£æ— ç©·
    ("neg_infinity", common::AttributeValue::float(-1.0/0.0)),  // è´Ÿæ— ç©·
    ("nan", common::AttributeValue::float(0.0/0.0))  // NaN
  ]
  
  // éªŒè¯æç«¯å€¼èƒ½æ­£ç¡®å­˜å‚¨
  let mut i = 0
  while i < extreme_values.length() {
    let (key, value) = extreme_values[i]
    match value {
      common::IntValue(_) => assert_eq(true, true)  // èƒ½æ­£ç¡®åŒ¹é…IntValueç±»å‹
      common::FloatValue(_) => assert_eq(true, true)  // èƒ½æ­£ç¡®åŒ¹é…FloatValueç±»å‹
      _ => @test.fail("Expected numeric value type")
    }
    i = i + 1
  }
}

test "context_error_recovery" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡æ“ä½œçš„é”™è¯¯æ¢å¤
  
  let base_context = context::Context::empty()
  
  // æµ‹è¯•ä½¿ç”¨ç©ºé”®å
  let empty_key = context::create_key("")
  let context_with_empty_key = base_context.with_value(empty_key, "empty_key_value")
  let retrieved_empty = context_with_empty_key.get(empty_key)
  assert_eq(retrieved_empty.unwrap(), "empty_key_value")
  
  // æµ‹è¯•ä½¿ç”¨æé•¿çš„é”®å
  let long_key_name = "a" * 1000
  let long_key = context::create_key(long_key_name)
  let context_with_long_key = base_context.with_value(long_key, "long_key_value")
  let retrieved_long = context_with_long_key.get(long_key)
  assert_eq(retrieved_long.unwrap(), "long_key_value")
  
  // æµ‹è¯•ä½¿ç”¨ç‰¹æ®Šå­—ç¬¦é”®å
  let special_key_name = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_key = context::create_key(special_key_name)
  let context_with_special_key = base_context.with_value(special_key, "special_key_value")
  let retrieved_special = context_with_special_key.get(special_key)
  assert_eq(retrieved_special.unwrap(), "special_key_value")
  
  // æµ‹è¯•ä½¿ç”¨ç©ºå€¼
  let empty_value_key = context::create_key("empty_value")
  let context_with_empty_value = base_context.with_value(empty_value_key, "")
  let retrieved_empty_value = context_with_empty_value.get(empty_value_key)
  assert_eq(retrieved_empty_value.unwrap(), "")
  
  // æµ‹è¯•ä½¿ç”¨æé•¿çš„å€¼
  let long_value = "v" * 10000
  let long_value_key = context::create_key("long_value")
  let context_with_long_value = base_context.with_value(long_value_key, long_value)
  let retrieved_long_value = context_with_long_value.get(long_value_key)
  assert_eq(retrieved_long_value.unwrap().length(), 10000)
}

test "span_creation_error_handling" {
  // æµ‹è¯•spanåˆ›å»ºæ—¶çš„é”™è¯¯å¤„ç†
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("error_handling_tracer")
  
  // æµ‹è¯•ä½¿ç”¨ç©ºspanåç§°
  let (ctx1, span1) = tracer.start_span(
    context::Context::empty(),
    "",
    trace::Internal,
    [],
    0L
  )
  assert_eq(span1.name, "")
  assert_eq(span1.kind, trace::Internal)
  
  // æµ‹è¯•ä½¿ç”¨æé•¿spanåç§°
  let very_long_name = "a" * 10000
  let (ctx2, span2) = tracer.start_span(
    context::Context::empty(),
    very_long_name,
    trace::Server,
    [],
    1234567890000000L
  )
  assert_eq(span2.name.length(), 10000)
  assert_eq(span2.kind, trace::Server)
  
  // æµ‹è¯•ä½¿ç”¨åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„spanåç§°
  let special_name = "span-with.special@chars#and\nnewlines\tand\tabs"
  let (ctx3, span3) = tracer.start_span(
    context::Context::empty(),
    special_name,
    trace::Client,
    [],
    1234567890000000L
  )
  assert_eq(span3.name, special_name)
  assert_eq(span3.kind, trace::Client)
  
  // æµ‹è¯•ä½¿ç”¨æ— æ•ˆæ—¶é—´æˆ³
  let invalid_timestamps = [
    -9223372036854775808L,  // æœ€å°Int64å€¼
    9223372036854775807L    // æœ€å¤§Int64å€¼
  ]
  
  let mut i = 0
  while i < invalid_timestamps.length() {
    let timestamp = invalid_timestamps[i]
    let (ctx, span) = tracer.start_span(
      context::Context::empty(),
      "invalid_timestamp_span",
      trace::Producer,
      [],
      timestamp
    )
    assert_eq(span.start_time_unix_nanos, timestamp)
    i = i + 1
  }
  
  // æµ‹è¯•ä½¿ç”¨åŒ…å«æ— æ•ˆæ•°æ®çš„å±æ€§
  let invalid_attributes = [
    ("", common::AttributeValue::string("empty_key")),
    ("normal_key", common::StringValue("")),
    ("special_chars_key", common::AttributeValue::string("!@#$%^&*()")),
    ("unicode_key", common::AttributeValue::string("æµ‹è¯•ğŸš€emoji"))
  ]
  
  let (ctx4, span4) = tracer.start_span(
    context::Context::empty(),
    "invalid_attributes_span",
    trace::Consumer,
    invalid_attributes
  )
  assert_eq(span4.attributes.length(), 4)
}

test "metric_recording_error_handling" {
  // æµ‹è¯•æŒ‡æ ‡è®°å½•æ—¶çš„é”™è¯¯å¤„ç†
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("error_handling_meter")
  
  // æµ‹è¯•ä½¿ç”¨ç©ºåç§°åˆ›å»ºä»ªå™¨
  let empty_counter = meter.create_counter("", "", "")
  let empty_histogram = meter.create_histogram("", "", "")
  let empty_gauge = meter.create_gauge("", "", "")
  
  // æµ‹è¯•ä½¿ç”¨æé•¿åç§°åˆ›å»ºä»ªå™¨
  let long_name = "a" * 1000
  let long_counter = meter.create_counter(long_name, long_name, long_name)
  let long_histogram = meter.create_histogram(long_name, long_name, long_name)
  let long_gauge = meter.create_gauge(long_name, long_name, long_name)
  
  // æµ‹è¯•ä½¿ç”¨ç‰¹æ®Šå­—ç¬¦åç§°åˆ›å»ºä»ªå™¨
  let special_name = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_counter = meter.create_counter(special_name, special_name, special_name)
  let special_histogram = meter.create_histogram(special_name, special_name, special_name)
  let special_gauge = meter.create_gauge(special_name, special_name, special_name)
  
  // æµ‹è¯•è®°å½•æå€¼
  let extreme_values = [
    9223372036854775807L,     // æœ€å¤§Int64
    -9223372036854775808L,    // æœ€å°Int64
    0L                        // é›¶å€¼
  ]
  
  let mut i = 0
  while i < extreme_values.length() {
    let value = extreme_values[i]
    empty_counter.add(value)
    long_counter.add(value)
    special_counter.add(value)
    i = i + 1
  }
  
  // æµ‹è¯•è®°å½•æå€¼æµ®ç‚¹æ•°
  let extreme_floats = [
    1.7976931348623157e+308,  // æœ€å¤§Double
    -1.7976931348623157e+308, // æœ€å°Double
    0.0,                      // é›¶å€¼
    1.0/0.0,                  // æ­£æ— ç©·
    -1.0/0.0,                 // è´Ÿæ— ç©·
    0.0/0.0                   // NaN
  ]
  
  let mut j = 0
  while j < extreme_floats.length() {
    let float_value = extreme_floats[j]
    empty_histogram.record(float_value)
    long_histogram.record(float_value)
    special_histogram.record(float_value)
    empty_gauge.record(float_value)
    long_gauge.record(float_value)
    special_gauge.record(float_value)
    j = j + 1
  }
  
  // æµ‹è¯•ä½¿ç”¨æ— æ•ˆå±æ€§è®°å½•æŒ‡æ ‡
  let invalid_attributes = [
    ("", common::AttributeValue::string("empty_key")),
    ("special_chars", common::AttributeValue::string("!@#$%^&*()")),
    ("unicode", common::AttributeValue::string("æµ‹è¯•ğŸš€"))
  ]
  
  empty_counter.add(1L, invalid_attributes)
  empty_histogram.record(100.0, invalid_attributes)
  empty_gauge.record(50.0, invalid_attributes)
}

test "log_record_error_handling" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„é”™è¯¯å¤„ç†
  
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("error_handling_logger")
  
  // æµ‹è¯•è®°å½•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—
  let special_messages = [
    "",                                    // ç©ºæ¶ˆæ¯
    "a" * 10000,                          // æé•¿æ¶ˆæ¯
    "Message with\nnewlines\tand\tabs",   // åŒ…å«æ§åˆ¶å­—ç¬¦
    "Message with!@#$%^&*()special_chars", // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    "æµ‹è¯•ä¸­æ–‡ğŸš€emojiæ¶ˆæ¯",                   // åŒ…å«Unicodeå­—ç¬¦
    "Message with\"quotes'and\\backslashes" // åŒ…å«å¼•å·å’Œåæ–œæ 
  ]
  
  let mut i = 0
  while i < special_messages.length() {
    let message = special_messages[i]
    
    // æµ‹è¯•ä¸åŒæ—¥å¿—çº§åˆ«
    logger.debug(message, [])
    logger.info(message, [])
    logger.warn(message, [])
    logger.error(message, [])
    logger.fatal(message, [])
    
    i = i + 1
  }
  
  // æµ‹è¯•ä½¿ç”¨æ— æ•ˆå±æ€§è®°å½•æ—¥å¿—
  let invalid_attributes = [
    ("", common::AttributeValue::string("empty_key")),
    ("empty_value", common::StringValue("")),
    ("special_chars_key", common::AttributeValue::string("!@#$%^&*()")),
    ("unicode_value", common::AttributeValue::string("æµ‹è¯•ğŸš€")),
    ("null_value", common::AttributeValue::string("null"))
  ]
  
  logger.info("Test with invalid attributes", invalid_attributes)
  
  // æµ‹è¯•åˆ›å»ºåŒ…å«æ— æ•ˆæ•°æ®çš„LogRecord
  let invalid_log = logs::LogRecord::builder()
    .timestamp(-9223372036854775808L)  // æœ€å°æ—¶é—´æˆ³
    .severity(logs::Error)
    .body("a" * 10000)  // æé•¿æ¶ˆæ¯
    .with_attribute("", common::AttributeValue::string("empty_key"))  // ç©ºé”®
    .with_attribute("empty_value", common::StringValue(""))  // ç©ºå€¼
    .with_attribute("special", common::AttributeValue::string("!@#$%^&*()"))  // ç‰¹æ®Šå­—ç¬¦
    .build()
  
  assert_eq(invalid_log.timestamp_unix_nanos, -9223372036854775808L)
  assert_eq(invalid_log.severity_number, logs::Error)
  assert_eq(invalid_log.body.unwrap().length(), 10000)
  assert_eq(invalid_log.attributes.length(), 3)
}

test "resource_creation_error_handling" {
  // æµ‹è¯•èµ„æºåˆ›å»ºçš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ä½¿ç”¨ç©ºæœåŠ¡åç§°
  let empty_resource = common::Resource::default("")
  assert_eq(empty_resource.service_name, "")
  assert_eq(empty_resource.telemetry_sdk_name, "azimuth")
  
  // æµ‹è¯•ä½¿ç”¨æé•¿æœåŠ¡åç§°
  let long_name = "a" * 10000
  let long_resource = common::Resource::default(long_name)
  assert_eq(long_resource.service_name.length(), 10000)
  
  // æµ‹è¯•ä½¿ç”¨åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æœåŠ¡åç§°
  let special_name = "!@#$%^&*()_+-=[]{}|;':\",./<>?æµ‹è¯•ğŸš€"
  let special_resource = common::Resource::default(special_name)
  assert_eq(special_resource.service_name, special_name)
  
  // æµ‹è¯•åˆ›å»ºåŒ…å«æ— æ•ˆå±æ€§çš„Resource
  let invalid_attributes = [
    ("", common::AttributeValue::string("empty_key")),
    ("empty_value", common::StringValue("")),
    ("special_chars_key", common::AttributeValue::string("!@#$%^&*()")),
    ("unicode_value", common::AttributeValue::string("æµ‹è¯•ğŸš€")),
    ("null_value", common::AttributeValue::string("null"))
  ]
  
  let resource_with_invalid_attrs = common::Resource::{
    service_name: "test_service",
    service_version: Some(""),
    telemetry_sdk_name: "",
    telemetry_sdk_version: "",
    attributes: invalid_attributes
  }
  
  assert_eq(resource_with_invalid_attrs.service_name, "test_service")
  assert_eq(resource_with_invalid_attrs.service_version.unwrap(), "")
  assert_eq(resource_with_invalid_attrs.telemetry_sdk_name, "")
  assert_eq(resource_with_invalid_attrs.telemetry_sdk_version, "")
  assert_eq(resource_with_invalid_attrs.attributes.length(), 5)
}

test "baggage_error_handling" {
  // æµ‹è¯•baggageæ“ä½œçš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ä½¿ç”¨ç©ºé”®å
  let empty_key_baggage = context::Baggage::empty()
    .with_entry("", "empty_key_value")
  assert_eq(empty_key_baggage.get("").unwrap(), "empty_key_value")
  
  // æµ‹è¯•ä½¿ç”¨ç©ºå€¼
  let empty_value_baggage = context::Baggage::empty()
    .with_entry("empty_value", "")
  assert_eq(empty_value_baggage.get("empty_value").unwrap(), "")
  
  // æµ‹è¯•ä½¿ç”¨æé•¿é”®åå’Œå€¼
  let long_key = "k" * 1000
  let long_value = "v" * 1000
  let long_baggage = context::Baggage::empty()
    .with_entry(long_key, long_value)
  assert_eq(long_baggage.get(long_key).unwrap().length(), 1000)
  
  // æµ‹è¯•ä½¿ç”¨åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®åå’Œå€¼
  let special_key = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_value = "!@#$%^&*()_+-=[]{}|;':\",./<>?æµ‹è¯•ğŸš€"
  let special_baggage = context::Baggage::empty()
    .with_entry(special_key, special_value)
  assert_eq(special_baggage.get(special_key).unwrap(), special_value)
  
  // æµ‹è¯•é‡å¤é”®åçš„å¤„ç†ï¼ˆåº”è¯¥è¦†ç›–åŸæœ‰å€¼ï¼‰
  let override_baggage = context::Baggage::empty()
    .with_entry("test_key", "original_value")
    .with_entry("test_key", "overridden_value")
  assert_eq(override_baggage.get("test_key").unwrap(), "overridden_value")
  assert_eq(override_baggage.entries.length(), 1)  // åº”è¯¥åªæœ‰ä¸€ä¸ªæ¡ç›®
}