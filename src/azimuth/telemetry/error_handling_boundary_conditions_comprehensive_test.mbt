// Azimuth Telemetry - Error Handling and Boundary Conditions Test
// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•

test "trace_api_error_handling" {
  // Trace API é”™è¯¯å¤„ç†æµ‹è¯•
  let provider = trace::NoopTracerProvider::{}
  let tracer = provider.get_tracer("error-test")
  let ctx = context::Context::empty()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²spanåç§°
  let (_, empty_span) = tracer.start_span(ctx, "")
  assert_eq(empty_span.name, "")
  
  // æµ‹è¯•æé•¿spanåç§°
  let very_long_name = "a".repeat(10000)
  let (_, long_span) = tracer.start_span(ctx, very_long_name)
  assert_eq(long_span.name.length(), 10000)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦spanåç§°
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?\\"
  let (_, special_span) = tracer.start_span(ctx, special_chars)
  assert_eq(special_span.name, special_chars)
  
  // æµ‹è¯•Unicode spanåç§°
  let unicode_name = "Unicodeæµ‹è¯•ğŸš€ğŸŒŸØ§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  let (_, unicode_span) = tracer.start_span(ctx, unicode_name)
  assert_eq(unicode_span.name, unicode_name)
  
  // æµ‹è¯•Noneå±æ€§ï¼ˆåº”è¯¥ä½¿ç”¨é»˜è®¤ç©ºæ•°ç»„ï¼‰
  let (_, none_attrs_span) = tracer.start_span(ctx, "none-attrs", Some(trace::Internal), None)
  assert_eq(none_attrs_span.attributes.length(), 0)
  
  // æµ‹è¯•ç©ºå±æ€§æ•°ç»„
  let (_, empty_attrs_span) = tracer.start_span(ctx, "empty-attrs", Some(trace::Internal), Some([]))
  assert_eq(empty_attrs_span.attributes.length(), 0)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  let mut i = 0
  while i < 1000 {
    many_attrs.push(("attr-" + i.to_string(), common::AttributeValue::string("value-" + i.to_string())))
    i = i + 1
  }
  let (_, many_attrs_span) = tracer.start_span(ctx, "many-attrs", Some(trace::Internal), Some(many_attrs))
  assert_eq(many_attrs_span.attributes.length(), 1000)
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let min_time = Int64::min_value()
  let max_time = Int64::max_value()
  let (_, min_time_span) = tracer.start_span(ctx, "min-time", Some(trace::Internal), Some([]), Some(min_time))
  let (_, max_time_span) = tracer.start_span(ctx, "max-time", Some(trace::Internal), Some([]), Some(max_time))
  assert_eq(min_time_span.start_time_unix_nanos, min_time)
  assert_eq(max_time_span.start_time_unix_nanos, max_time)
}

test "metrics_api_error_handling" {
  // Metrics API é”™è¯¯å¤„ç†æµ‹è¯•
  let provider = metrics::NoopMeterProvider::{}
  let meter = provider.get_meter("error-test")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²æŒ‡æ ‡åç§°
  let empty_counter = meter.create_counter("")
  let empty_histogram = meter.create_histogram("")
  let empty_gauge = meter.create_gauge("")
  let empty_updown = meter.create_up_down_counter("")
  
  empty_counter.add(1L)
  empty_histogram.record(1.0)
  empty_gauge.record(1.0)
  empty_updown.add(1L)
  
  // æµ‹è¯•æé•¿æŒ‡æ ‡åç§°
  let very_long_name = "metric-".repeat(1000)
  let long_counter = meter.create_counter(very_long_name)
  long_counter.add(1L)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æŒ‡æ ‡åç§°
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?\\"
  let special_counter = meter.create_counter(special_chars)
  special_counter.add(1L)
  
  // æµ‹è¯•UnicodeæŒ‡æ ‡åç§°
  let unicode_name = "UnicodeæŒ‡æ ‡ğŸš€ğŸŒŸæµ‹è¯•"
  let unicode_counter = meter.create_counter(unicode_name)
  unicode_counter.add(1L)
  
  // æµ‹è¯•æå€¼è®¡æ•°å™¨æ“ä½œ
  let extreme_counter = meter.create_counter("extreme-test")
  extreme_counter.add(Int64::max_value())
  extreme_counter.add(Int64::min_value())
  extreme_counter.add(0L)
  
  // æµ‹è¯•æå€¼ç›´æ–¹å›¾æ“ä½œ
  let extreme_histogram = meter.create_histogram("extreme-float-test")
  extreme_histogram.record(Double::max_value())
  extreme_histogram.record(Double::min_value())
  extreme_histogram.record(Double::infinity)
  extreme_histogram.record(Double::neg_infinity)
  extreme_histogram.record(Double::nan)
  extreme_histogram.record(0.0)
  extreme_histogram.record(-0.0)
  
  // æµ‹è¯•æå€¼ä»ªè¡¨æ“ä½œ
  let extreme_gauge = meter.create_gauge("extreme-gauge-test")
  extreme_gauge.record(Double::max_value())
  extreme_gauge.record(Double::min_value())
  extreme_gauge.record(Double::infinity)
  extreme_gauge.record(Double::neg_infinity)
  extreme_gauge.record(Double::nan)
  
  // æµ‹è¯•æå€¼ä¸Šä¸‹è®¡æ•°å™¨æ“ä½œ
  let extreme_updown = meter.create_up_down_counter("extreme-updown-test")
  extreme_updown.add(Int64::max_value())
  extreme_updown.add(Int64::min_value())
  extreme_updown.add(0L)
  
  // æµ‹è¯•ç©ºå±æ€§å’ŒNoneå±æ€§
  let test_counter = meter.create_counter("attr-test")
  test_counter.add(1L, None)
  test_counter.add(1L, Some([]))
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  let mut i = 0
  while i < 1000 {
    many_attrs.push(("attr-" + i.to_string(), common::AttributeValue::string("value-" + i.to_string())))
    i = i + 1
  }
  test_counter.add(1L, Some(many_attrs))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®å’Œå€¼
  test_counter.add(1L, Some([("", common::AttributeValue::string(""))]))
  test_counter.add(1L, Some([("key", common::AttributeValue::string(""))]))
  test_counter.add(1L, Some([("", common::AttributeValue::string("value"))]))
}

test "logs_api_error_handling" {
  // Logs API é”™è¯¯å¤„ç†æµ‹è¯•
  let provider = logs::NoopLoggerProvider::{}
  let logger = provider.get_logger("error-test")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²æ—¥å¿—æ¶ˆæ¯
  logger.debug("")
  logger.info("")
  logger.warn("")
  logger.error("")
  logger.fatal("")
  
  // æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯
  let very_long_message = "x".repeat(100000)
  logger.info(very_long_message)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ—¥å¿—æ¶ˆæ¯
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?\\\n\t\r"
  logger.info(special_chars)
  
  // æµ‹è¯•Unicodeæ—¥å¿—æ¶ˆæ¯
  let unicode_message = "Unicodeæµ‹è¯•ğŸš€ğŸŒŸØ§Ù„Ø¹Ø±Ø¨ÙŠØ©\n\t\r"
  logger.info(unicode_message)
  
  // æµ‹è¯•ç©ºLoggeråç§°
  let empty_logger = provider.get_logger("")
  empty_logger.info("Empty logger name test")
  
  // æµ‹è¯•æé•¿Loggeråç§°
  let long_name = "logger-".repeat(1000)
  let long_logger = provider.get_logger(long_name)
  long_logger.info("Long logger name test")
  
  // æµ‹è¯•LogRecordè¾¹ç•Œæ¡ä»¶
  let empty_log_record = logs::LogRecord::builder()
    .timestamp(0L)
    .severity(logs::Info)
    .body("")
    .build()
  logger.emit(empty_log_record)
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let min_time_record = logs::LogRecord::builder()
    .timestamp(Int64::min_value())
    .severity(logs::Error)
    .body("Min time test")
    .build()
  logger.emit(min_time_record)
  
  let max_time_record = logs::LogRecord::builder()
    .timestamp(Int64::max_value())
    .severity(logs::Error)
    .body("Max time test")
    .build()
  logger.emit(max_time_record)
  
  // æµ‹è¯•ç©ºå±æ€§å’ŒNoneå±æ€§
  logger.info("No attributes", None)
  logger.info("Empty attributes", Some([]))
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  let mut i = 0
  while i < 1000 {
    many_attrs.push(("attr-" + i.to_string(), common::AttributeValue::string("value-" + i.to_string())))
    i = i + 1
  }
  logger.info("Many attributes", Some(many_attrs))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®å’Œå€¼
  logger.info("Empty keys and values", Some([
    ("", common::AttributeValue::string("")),
    ("key", common::AttributeValue::string("")),
    ("", common::AttributeValue::string("value"))
  ]))
}

test "context_error_handling" {
  // Context é”™è¯¯å¤„ç†æµ‹è¯•
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²Contexté”®
  let empty_key = context::create_key("")
  let ctx = context::Context::empty()
  let ctx_with_empty = ctx.with_value(empty_key, "empty-key-value")
  let retrieved_empty = ctx_with_empty.get(empty_key)
  match retrieved_empty {
    Some(v) => assert_eq(v, "empty-key-value")
    None => assert(false, "Expected value for empty key")
  }
  
  // æµ‹è¯•æé•¿Contexté”®
  let long_key_name = "key-".repeat(1000)
  let long_key = context::create_key(long_key_name)
  let ctx_with_long = ctx.with_value(long_key, "long-key-value")
  let retrieved_long = ctx_with_long.get(long_key)
  match retrieved_long {
    Some(v) => assert_eq(v, "long-key-value")
    None => assert(false, "Expected value for long key")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Contexté”®
  let special_key_name = "!@#$%^&*()_+-=[]{}|;':\",./<>?\\"
  let special_key = context::create_key(special_key_name)
  let ctx_with_special = ctx.with_value(special_key, "special-key-value")
  let retrieved_special = ctx_with_special.get(special_key)
  match retrieved_special {
    Some(v) => assert_eq(v, "special-key-value")
    None => assert(false, "Expected value for special key")
  }
  
  // æµ‹è¯•Unicode Contexté”®
  let unicode_key_name = "Unicodeé”®ğŸš€ğŸŒŸæµ‹è¯•"
  let unicode_key = context::create_key(unicode_key_name)
  let ctx_with_unicode = ctx.with_value(unicode_key, "unicode-key-value")
  let retrieved_unicode = ctx_with_unicode.get(unicode_key)
  match retrieved_unicode {
    Some(v) => assert_eq(v, "unicode-key-value")
    None => assert(false, "Expected value for unicode key")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²Contextå€¼
  let key = context::create_key("empty-value-test")
  let ctx_with_empty_value = ctx.with_value(key, "")
  let retrieved_empty_value = ctx_with_empty_value.get(key)
  match retrieved_empty_value {
    Some(v) => assert_eq(v, "")
    None => assert(false, "Expected empty value")
  }
  
  // æµ‹è¯•æé•¿Contextå€¼
  let long_value = "value-".repeat(10000)
  let ctx_with_long_value = ctx.with_value(key, long_value)
  let retrieved_long_value = ctx_with_long_value.get(key)
  match retrieved_long_value {
    Some(v) => assert_eq(v, long_value)
    None => assert(false, "Expected long value")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Contextå€¼
  let special_value = "!@#$%^&*()_+-=[]{}|;':\",./<>?\\\n\t\r"
  let ctx_with_special_value = ctx.with_value(key, special_value)
  let retrieved_special_value = ctx_with_special_value.get(key)
  match retrieved_special_value {
    Some(v) => assert_eq(v, special_value)
    None => assert(false, "Expected special value")
  }
  
  // æµ‹è¯•Unicode Contextå€¼
  let unicode_value = "Unicodeå€¼ğŸš€ğŸŒŸæµ‹è¯•\n\t\r"
  let ctx_with_unicode_value = ctx.with_value(key, unicode_value)
  let retrieved_unicode_value = ctx_with_unicode_value.get(key)
  match retrieved_unicode_value {
    Some(v) => assert_eq(v, unicode_value)
    None => assert(false, "Expected unicode value")
  }
  
  // æµ‹è¯•Baggageè¾¹ç•Œæ¡ä»¶
  let baggage = context::Baggage::empty()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²Baggageé”®å’Œå€¼
  let baggage_with_empty_key = baggage.with_entry("", "empty-key-value")
  let baggage_with_empty_value = baggage.with_entry("empty-value-key", "")
  let baggage_with_both_empty = baggage.with_entry("", "")
  
  match baggage_with_empty_key.get("") {
    Some(v) => assert_eq(v, "empty-key-value")
    None => assert(false, "Expected baggage value for empty key")
  }
  
  match baggage_with_empty_value.get("empty-value-key") {
    Some(v) => assert_eq(v, "")
    None => assert(false, "Expected empty baggage value")
  }
  
  match baggage_with_both_empty.get("") {
    Some(v) => assert_eq(v, "")
    None => assert(false, "Expected empty baggage value for empty key")
  }
  
  // æµ‹è¯•æé•¿Baggageé”®å’Œå€¼
  let long_baggage_key = "baggage-key-".repeat(500)
  let long_baggage_value = "baggage-value-".repeat(500)
  let baggage_with_long = baggage.with_entry(long_baggage_key, long_baggage_value)
  
  match baggage_with_long.get(long_baggage_key) {
    Some(v) => assert_eq(v, long_baggage_value)
    None => assert(false, "Expected long baggage value")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Baggageé”®å’Œå€¼
  let special_baggage_key = "!@#$%^&*()_+-=[]{}|;':\",./<>?\\"
  let special_baggage_value = "!@#$%^&*()_+-=[]{}|;':\",./<>?\\\n\t\r"
  let baggage_with_special = baggage.with_entry(special_baggage_key, special_baggage_value)
  
  match baggage_with_special.get(special_baggage_key) {
    Some(v) => assert_eq(v, special_baggage_value)
    None => assert(false, "Expected special baggage value")
  }
  
  // æµ‹è¯•Unicode Baggageé”®å’Œå€¼
  let unicode_baggage_key = "Unicodeé”®ğŸš€ğŸŒŸæµ‹è¯•"
  let unicode_baggage_value = "Unicodeå€¼ğŸš€ğŸŒŸæµ‹è¯•\n\t\r"
  let baggage_with_unicode = baggage.with_entry(unicode_baggage_key, unicode_baggage_value)
  
  match baggage_with_unicode.get(unicode_baggage_key) {
    Some(v) => assert_eq(v, unicode_baggage_value)
    None => assert(false, "Expected unicode baggage value")
  }
}

test "common_types_error_handling" {
  // Commonç±»å‹é”™è¯¯å¤„ç†æµ‹è¯•
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²AttributeValue
  let empty_string = common::AttributeValue::string("")
  match empty_string {
    common::StringValue(s) => assert_eq(s, "")
    _ => assert(false, "Expected string value")
  }
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²AttributeValue
  let long_string = common::AttributeValue::string("x".repeat(100000))
  match long_string {
    common::StringValue(s) => assert_eq(s.length(), 100000)
    _ => assert(false, "Expected string value")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦AttributeValue
  let special_string = common::AttributeValue::string("!@#$%^&*()_+-=[]{}|;':\",./<>?\\\n\t\r")
  match special_string {
    common::StringValue(s) => assert_eq(s, "!@#$%^&*()_+-=[]{}|;':\",./<>?\\\n\t\r")
    _ => assert(false, "Expected string value")
  }
  
  // æµ‹è¯•Unicode AttributeValue
  let unicode_string = common::AttributeValue::string("Unicodeæµ‹è¯•ğŸš€ğŸŒŸØ§Ù„Ø¹Ø±Ø¨ÙŠØ©\n\t\r")
  match unicode_string {
    common::StringValue(s) => assert_eq(s, "Unicodeæµ‹è¯•ğŸš€ğŸŒŸØ§Ù„Ø¹Ø±Ø¨ÙŠØ©\n\t\r")
    _ => assert(false, "Expected string value")
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„AttributeValue
  let empty_string_array = common::AttributeValue::array_string([])
  let empty_int_array = common::AttributeValue::array_int([])
  let empty_float_array = common::AttributeValue::array_float([])
  let empty_bool_array = common::AttributeValue::array_bool([])
  
  match empty_string_array {
    common::ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => assert(false, "Expected string array value")
  }
  
  match empty_int_array {
    common::ArrayIntValue(arr) => assert_eq(arr.length(), 0)
    _ => assert(false, "Expected int array value")
  }
  
  match empty_float_array {
    common::ArrayFloatValue(arr) => assert_eq(arr.length(), 0)
    _ => assert(false, "Expected float array value")
  }
  
  match empty_bool_array {
    common::ArrayBoolValue(arr) => assert_eq(arr.length(), 0)
    _ => assert(false, "Expected bool array value")
  }
  
  // æµ‹è¯•åŒ…å«ç©ºå­—ç¬¦ä¸²çš„æ•°ç»„
  let array_with_empty_strings = common::AttributeValue::array_string(["", "normal", ""])
  match array_with_empty_strings {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], "")
      assert_eq(arr[1], "normal")
      assert_eq(arr[2], "")
    }
    _ => assert(false, "Expected string array value")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ•°ç»„
  let array_with_special = common::AttributeValue::array_string([
    "!@#$%^&*()", "()_+-=[]", "{}|;':\"", "./<>?\\"
  ])
  match array_with_special {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 4)
      assert_eq(arr[0], "!@#$%^&*()")
      assert_eq(arr[1], "()_+-=[]")
      assert_eq(arr[2], "{}|;':\"")
      assert_eq(arr[3], "./<>?\\")
    }
    _ => assert(false, "Expected string array value")
  }
  
  // æµ‹è¯•åŒ…å«Unicodeçš„æ•°ç»„
  let array_with_unicode = common::AttributeValue::array_string([
    "Unicodeæµ‹è¯•", "ğŸš€ğŸŒŸ", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "ä¸­æ–‡"
  ])
  match array_with_unicode {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 4)
      assert_eq(arr[0], "Unicodeæµ‹è¯•")
      assert_eq(arr[1], "ğŸš€ğŸŒŸ")
      assert_eq(arr[2], "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
      assert_eq(arr[3], "ä¸­æ–‡")
    }
    _ => assert(false, "Expected string array value")
  }
  
  // æµ‹è¯•Resourceè¾¹ç•Œæ¡ä»¶
  let empty_service_resource = common::Resource::default("")
  assert_eq(empty_service_resource.service_name, "")
  
  let long_service_resource = common::Resource::default("service-".repeat(1000))
  assert_eq(long_service_resource.service_name.length(), 8000)
  
  let special_service_resource = common::Resource::default("!@#$%^&*()_+-=[]{}|;':\",./<>?\\")
  assert_eq(special_service_resource.service_name, "!@#$%^&*()_+-=[]{}|;':\",./<>?\\")
  
  let unicode_service_resource = common::Resource::default("UnicodeæœåŠ¡ğŸš€ğŸŒŸæµ‹è¯•")
  assert_eq(unicode_service_resource.service_name, "UnicodeæœåŠ¡ğŸš€ğŸŒŸæµ‹è¯•")
  
  // æµ‹è¯•InstrumentationScopeè¾¹ç•Œæ¡ä»¶
  let empty_name_scope = common::InstrumentationScope::{
    name: "",
    version: Some(""),
    schema_url: Some("")
  }
  assert_eq(empty_name_scope.name, "")
  assert_eq(empty_name_scope.version, Some(""))
  assert_eq(empty_name_scope.schema_url, Some(""))
  
  let long_name_scope = common::InstrumentationScope::{
    name: "scope-".repeat(500),
    version: Some("version-".repeat(100)),
    schema_url: Some("http://example.com/".repeat(50))
  }
  assert_eq(long_name_scope.name.length(), 3000)
  assert_eq(long_name_scope.version.unwrap().length(), 700)
  assert_eq(long_name_scope.schema_url.unwrap().length(), 800)
  
  let special_scope = common::InstrumentationScope::{
    name: "!@#$%^&*()_+-=[]{}|;':\",./<>?\\",
    version: Some("!@#$%^&*()_+-=[]{}|;':\",./<>?\\"),
    schema_url: Some("http://!@#$%^&*()_+-=[]{}|;':\",./<>?\\.example.com")
  }
  assert_eq(special_scope.name, "!@#$%^&*()_+-=[]{}|;':\",./<>?\\")
  assert_eq(special_scope.version, Some("!@#$%^&*()_+-=[]{}|;':\",./<>?\\"))
  assert_eq(special_scope.schema_url, Some("http://!@#$%^&*()_+-=[]{}|;':\",./<>?\\.example.com"))
  
  let unicode_scope = common::InstrumentationScope::{
    name: "Unicodeä½œç”¨åŸŸğŸš€ğŸŒŸæµ‹è¯•",
    version: Some("Unicodeç‰ˆæœ¬ğŸš€ğŸŒŸæµ‹è¯•"),
    schema_url: Some("http://Unicodeæµ‹è¯•ğŸš€ğŸŒŸ.example.com")
  }
  assert_eq(unicode_scope.name, "Unicodeä½œç”¨åŸŸğŸš€ğŸŒŸæµ‹è¯•")
  assert_eq(unicode_scope.version, Some("Unicodeç‰ˆæœ¬ğŸš€ğŸŒŸæµ‹è¯•"))
  assert_eq(unicode_scope.schema_url, Some("http://Unicodeæµ‹è¯•ğŸš€ğŸŒŸ.example.com"))
}

test "cross_api_error_scenarios" {
  // è·¨APIé”™è¯¯åœºæ™¯æµ‹è¯•
  let trace_provider = trace::NoopTracerProvider::{}
  let metrics_provider = metrics::NoopMeterProvider::{}
  let logs_provider = logs::NoopLoggerProvider::{}
  
  let tracer = trace_provider.get_tracer("")
  let meter = metrics_provider.get_meter("")
  let logger = logs_provider.get_logger("")
  
  let ctx = context::Context::empty()
  
  // åˆ›å»ºå¸¦æœ‰é”™è¯¯æ¡ä»¶çš„span
  let (_, error_span) = tracer.start_span(ctx, "", Some(trace::Internal), Some([
    ("", common::AttributeValue::string("")),
    ("!@#$%", common::AttributeValue::string("!@#$%")),
    ("UnicodeğŸš€", common::AttributeValue::string("UnicodeğŸš€"))
  ]))
  
  // è®°å½•å¸¦æœ‰é”™è¯¯æ¡ä»¶çš„æŒ‡æ ‡
  let error_counter = meter.create_counter("!@#$%^&*()")
  error_counter.add(Int64::min_value(), Some([
    ("", common::AttributeValue::string("")),
    ("special!@#$%", common::AttributeValue::string("!@#$%")),
    ("unicodeğŸš€", common::AttributeValue::string("ğŸš€"))
  ]))
  
  let error_histogram = meter.create_histogram("")
  error_histogram.record(Double::nan, Some([
    ("nan", common::AttributeValue::float(Double::nan)),
    ("infinity", common::AttributeValue::float(Double::infinity)),
    ("neg_infinity", common::AttributeValue::float(Double::neg_infinity))
  ]))
  
  // è®°å½•å¸¦æœ‰é”™è¯¯æ¡ä»¶çš„æ—¥å¿—
  logger.error("", Some([
    ("", common::AttributeValue::string("")),
    ("special!@#$%", common::AttributeValue::array_string(["", "!@#$%", "ğŸš€"])),
    ("unicodeğŸš€", common::AttributeValue::array_bool([true, false]))
  ]))
  
  // åˆ›å»ºå¸¦æœ‰é”™è¯¯æ¡ä»¶çš„LogRecord
  let error_log_record = logs::LogRecord::builder()
    .timestamp(Int64::min_value())
    .severity(logs::Error)
    .severity_text(Some(""))
    .body("")
    .with_attribute("", common::AttributeValue::string(""))
    .with_attribute("!@#$%", common::AttributeValue::string("!@#$%"))
    .with_attribute("ğŸš€", common::AttributeValue::string("ğŸš€"))
    .build()
  
  logger.emit(error_log_record)
  
  // æµ‹è¯•Contexté”™è¯¯æ¡ä»¶
  let error_key = context::create_key("")
  let error_ctx = ctx.with_value(error_key, "")
  let error_baggage = context::Baggage::empty().with_entry("", "")
  
  let retrieved_error_value = error_ctx.get(error_key)
  match retrieved_error_value {
    Some(v) => assert_eq(v, "")
    None => assert(false, "Expected empty value")
  }
  
  let retrieved_baggage_value = error_baggage.get("")
  match retrieved_baggage_value {
    Some(v) => assert_eq(v, "")
    None => assert(false, "Expected empty baggage value")
  }
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½èƒ½æ­£å¸¸å®Œæˆï¼ˆå³ä½¿æœ‰é”™è¯¯æ¡ä»¶ï¼‰
  assert_eq(error_span.name, "")
  assert_type(error_counter, metrics::NoopCounter)
  assert_type(error_histogram, metrics::NoopHistogram)
  assert_type(logger, logs::NoopLogger)
}