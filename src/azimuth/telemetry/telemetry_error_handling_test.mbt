// é¥æµ‹é”™è¯¯å¤„ç†æµ‹è¯•ç”¨ä¾‹

test "error_handling_invalid_inputs" {
  // æµ‹è¯•æ— æ•ˆè¾“å…¥çš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®
  let ctx = Context::empty()
  let empty_key = create_key("")
  let ctx_with_empty_key = ctx.with_value(empty_key, "value.for.empty.key")
  
  match ctx_with_empty_key.get(empty_key) {
    Some(value) => assert_eq(value, "value.for.empty.key")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  let normal_key = create_key("normal.key")
  let ctx_with_empty_value = ctx.with_value(normal_key, "")
  
  match ctx_with_empty_value.get(normal_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_key = create_key("!@#$%^&*()_+-={}[]|\\:;\"'<>?,./")
  let ctx_with_special_key = ctx.with_value(special_key, "special.value")
  
  match ctx_with_special_key.get(special_key) {
    Some(value) => assert_eq(value, "special.value")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•éå¸¸é•¿çš„é”®
  let long_key_name = "this.is.a.very.long.key.name.that.exceeds.normal.expectations.and.tests.the.system.ability.to.handle.extremely.long.identifiers.without.causing.errors.or.failures.in.the.telemetry.system"
  let long_key = create_key(long_key_name)
  let ctx_with_long_key = ctx.with_value(long_key, "long.key.value")
  
  match ctx_with_long_key.get(long_key) {
    Some(value) => assert_eq(value, "long.key.value")
    None => @test.fail("Test failed")
  }
}

test "error_handling_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼é”™è¯¯å¤„ç†
  
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œ
  let max_int = 9223372036854775807L
  let min_int = -9223372036854775808L
  let zero_int = 0L
  
  // åˆ›å»ºåŒ…å«è¾¹ç•Œå€¼çš„ä¸Šä¸‹æ–‡
  let ctx = Context::empty()
  let max_key = create_key("max.int.value")
  let min_key = create_key("min.int.value")
  let zero_key = create_key("zero.int.value")
  
  let ctx_with_boundary_values = ctx
    .with_value(max_key, max_int.to_string())
    .with_value(min_key, min_int.to_string())
    .with_value(zero_key, zero_int.to_string())
  
  // éªŒè¯è¾¹ç•Œå€¼å¤„ç†
  match ctx_with_boundary_values.get(max_key) {
    Some(value) => assert_eq(value, "9223372036854775807")
    None => @test.fail("Test failed")
  }
  
  match ctx_with_boundary_values.get(min_key) {
    Some(value) => assert_eq(value, "-9223372036854775808")
    None => @test.fail("Test failed")
  }
  
  match ctx_with_boundary_values.get(zero_key) {
    Some(value) => assert_eq(value, "0")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œ
  let infinity = 1.0/0.0
  let neg_infinity = -1.0/0.0
  let nan = 0.0/0.0
  
  let inf_key = create_key("infinity.value")
  let neg_inf_key = create_key("neg.infinity.value")
  let nan_key = create_key("nan.value")
  
  let ctx_with_float_boundary = ctx_with_boundary_values
    .with_value(inf_key, infinity.to_string())
    .with_value(neg_inf_key, neg_infinity.to_string())
    .with_value(nan_key, nan.to_string())
  
  // éªŒè¯æµ®ç‚¹è¾¹ç•Œå€¼å¤„ç†
  match ctx_with_float_boundary.get(inf_key) {
    Some(value) => assert_eq(value.length() > 0, true)
    None => @test.fail("Test failed")
  }
  
  match ctx_with_float_boundary.get(nan_key) {
    Some(value) => assert_eq(value.length() > 0, true)
    None => @test.fail("Test failed")
  }
}

test "error_handling_corrupted_data" {
  // æµ‹è¯•æŸåæ•°æ®çš„é”™è¯¯å¤„ç†
  
  // æ¨¡æ‹ŸæŸåçš„å­—ç¬¦ä¸²æ•°æ®
  let corrupted_strings = [
    "null",
    "undefined",
    "\0\0\0",  // ç©ºå­—ç¬¦
    "   ",     // åªæœ‰ç©ºæ ¼
    "\n\r\t",  // åªæœ‰æ§åˆ¶å­—ç¬¦
    "x\0y",    // ä¸­é—´æœ‰ç©ºå­—ç¬¦
    "very long string that might cause issues if not handled properly" +
    "and continues to grow even more to test memory handling" +
    "with various special characters !@#$%^&*()_+-={}[]|\\:;\"'<>?,./" +
    "and unicode characters æµ‹è¯•ğŸš€ and more..."
  ]
  
  // æµ‹è¯•æ¯ä¸ªæŸåå­—ç¬¦ä¸²
  let mut i = 0
  while i < corrupted_strings.length() {
    let corrupted_str = corrupted_strings[i]
    let ctx = Context::empty()
    let key = create_key("corrupted.test." + i.to_string())
    
    // å°è¯•å­˜å‚¨æŸåæ•°æ®
    let ctx_with_corrupted = ctx.with_value(key, corrupted_str)
    
    // éªŒè¯å¯ä»¥æ£€ç´¢æ•°æ®
    match ctx_with_corrupted.get(key) {
      Some(value) => {
        // éªŒè¯æ•°æ®é•¿åº¦åŒ¹é…
        assert_eq(value.length(), corrupted_str.length())
      }
      None => @test.fail("Test failed")
    }
    
    i = i + 1
  }
  
  // æµ‹è¯•æŸåçš„baggageæ•°æ®
  let baggage = Baggage::empty()
  let baggage_with_corrupted = baggage.with_entry("corrupted.key", "\0\0\0")
  
  match baggage_with_corrupted.get("corrupted.key") {
    Some(value) => assert_eq(value, "\0\0\0")
    None => @test.fail("Test failed")
  }
}

test "error_handling_resource_constraints" {
  // æµ‹è¯•èµ„æºçº¦æŸé”™è¯¯å¤„ç†
  
  // æµ‹è¯•å¤§é‡æ•°æ®çš„å¤„ç†
  let ctx = Context::empty()
  let mut ctx_with_many_values = ctx
  
  // æ·»åŠ å¤§é‡é”®å€¼å¯¹
  let mut i = 0
  while i < 100 {
    let key = create_key("many.values.key." + i.to_string())
    let value = "value." + i.to_string() + ".with.additional.data.to.increase.size"
    ctx_with_many_values = ctx_with_many_values.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯å¤§æ•°æ®é›†å¤„ç†
  let test_key = create_key("many.values.key.50")
  match ctx_with_many_values.get(test_key) {
    Some(value) => {
      assert_eq(value.contains("value.50"), true)
      assert_eq(value.contains("additional.data"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•baggageçš„å¤§æ•°æ®å¤„ç†
  let baggage = Baggage::empty()
  let mut baggage_with_many_entries = baggage
  
  let mut j = 0
  while j < 50 {
    let entry_key = "baggage.entry." + j.to_string()
    let entry_value = "baggage.value." + j.to_string() + ".with.extra.data"
    baggage_with_many_entries = baggage_with_many_entries.with_entry(entry_key, entry_value)
    j = j + 1
  }
  
  // éªŒè¯å¤§æ•°æ®é›†baggageå¤„ç†
  match baggage_with_many_entries.get("baggage.entry.25") {
    Some(value) => {
      assert_eq(value.contains("baggage.value.25"), true)
      assert_eq(value.contains("extra.data"), true)
    }
    None => @test.fail("Test failed")
  }
}

test "error_handling_concurrent_access" {
  // æµ‹è¯•å¹¶å‘è®¿é—®é”™è¯¯å¤„ç†ï¼ˆæ¨¡æ‹Ÿï¼‰
  
  // åˆ›å»ºå¤šä¸ªä¸Šä¸‹æ–‡å®ä¾‹æ¨¡æ‹Ÿå¹¶å‘
  let ctx1 = Context::empty()
  let ctx2 = Context::empty()
  let ctx3 = Context::empty()
  
  // åœ¨ä¸åŒä¸Šä¸‹æ–‡ä¸­è®¾ç½®ç›¸åŒé”®çš„å€¼
  let shared_key = create_key("concurrent.shared.key")
  
  let ctx1_with_value = ctx1.with_value(shared_key, "value.from.ctx1")
  let ctx2_with_value = ctx2.with_value(shared_key, "value.from.ctx2")
  let ctx3_with_value = ctx3.with_value(shared_key, "value.from.ctx3")
  
  // éªŒè¯ä¸Šä¸‹æ–‡éš”ç¦»
  match ctx1_with_value.get(shared_key) {
    Some(value) => assert_eq(value, "value.from.ctx1")
    None => @test.fail("Test failed")
  }
  
  match ctx2_with_value.get(shared_key) {
    Some(value) => assert_eq(value, "value.from.ctx2")
    None => @test.fail("Test failed")
  }
  
  match ctx3_with_value.get(shared_key) {
    Some(value) => assert_eq(value, "value.from.ctx3")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•baggageçš„å¹¶å‘è®¿é—®
  let baggage1 = Baggage::empty()
  let baggage2 = Baggage::empty()
  
  let baggage1_with_entry = baggage1.with_entry("concurrent.baggage.key", "baggage.value.1")
  let baggage2_with_entry = baggage2.with_entry("concurrent.baggage.key", "baggage.value.2")
  
  match baggage1_with_entry.get("concurrent.baggage.key") {
    Some(value) => assert_eq(value, "baggage.value.1")
    None => @test.fail("Test failed")
  }
  
  match baggage2_with_entry.get("concurrent.baggage.key") {
    Some(value) => assert_eq(value, "baggage.value.2")
    None => @test.fail("Test failed")
  }
}

test "error_handling_recovery_scenarios" {
  // æµ‹è¯•é”™è¯¯æ¢å¤åœºæ™¯
  
  // æ¨¡æ‹Ÿéƒ¨åˆ†å¤±è´¥çš„æ•°æ®å¤„ç†
  let ctx = Context::empty()
  
  // æ­£å¸¸æ•°æ®
  let normal_key = create_key("normal.data.key")
  let ctx_with_normal = ctx.with_value(normal_key, "normal.value")
  
  // æ½œåœ¨é—®é¢˜æ•°æ®
  let problem_key = create_key("problem.data.key")
  let problem_value = "value with \0 null character and \n newlines"
  let ctx_with_problem = ctx_with_normal.with_value(problem_key, problem_value)
  
  // éªŒè¯æ­£å¸¸æ•°æ®ä¸å—é—®é¢˜æ•°æ®å½±å“
  match ctx_with_problem.get(normal_key) {
    Some(value) => assert_eq(value, "normal.value")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯é—®é¢˜æ•°æ®å¯ä»¥å¤„ç†
  match ctx_with_problem.get(problem_key) {
    Some(value) => {
      assert_eq(value.contains("null character"), true)
      assert_eq(value.contains("newlines"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æ•°æ®æ¢å¤
  let recovery_key = create_key("recovery.data.key")
  let ctx_with_recovery = ctx_with_problem.with_value(recovery_key, "recovered.value")
  
  // éªŒè¯æ‰€æœ‰æ•°æ®éƒ½å­˜åœ¨
  match ctx_with_recovery.get(normal_key) {
    Some(value) => assert_eq(value, "normal.value")
    None => @test.fail("Test failed")
  }
  
  match ctx_with_recovery.get(problem_key) {
    Some(value) => assert_eq(value.contains("null character"), true)
    None => @test.fail("Test failed")
  }
  
  match ctx_with_recovery.get(recovery_key) {
    Some(value) => assert_eq(value, "recovered.value")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•baggageæ¢å¤
  let baggage = Baggage::empty()
  let baggage_with_normal = baggage.with_entry("normal.baggage.key", "normal.baggage.value")
  let baggage_with_problem = baggage_with_normal.with_entry("problem.baggage.key", "problem\0value")
  let baggage_with_recovery = baggage_with_problem.with_entry("recovery.baggage.key", "recovered.baggage.value")
  
  // éªŒè¯baggageæ¢å¤
  match baggage_with_recovery.get("normal.baggage.key") {
    Some(value) => assert_eq(value, "normal.baggage.value")
    None => @test.fail("Test failed")
  }
  
  match baggage_with_recovery.get("recovery.baggage.key") {
    Some(value) => assert_eq(value, "recovered.baggage.value")
    None => @test.fail("Test failed")
  }
}