// å›½é™…åŒ–æ”¯æŒæµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºæµ‹è¯•é¥æµ‹ç³»ç»Ÿçš„å›½é™…åŒ–åŠŸèƒ½ï¼ŒåŒ…æ‹¬å¤šè¯­è¨€æ”¯æŒã€æ—¶åŒºå¤„ç†ã€æœ¬åœ°åŒ–ç­‰

test "telemetry_message_localization" {
  // æµ‹è¯•é¥æµ‹æ¶ˆæ¯æœ¬åœ°åŒ–åŠŸèƒ½
  
  // 1. å®šä¹‰æ”¯æŒçš„è¯­è¨€å’Œå¯¹åº”çš„æ¶ˆæ¯
  let localization_data = {
    "en" => {
      "service.started" => "Service {0} started successfully",
      "service.stopped" => "Service {0} stopped",
      "error.connection" => "Connection failed: {0}",
      "metric.high_cpu" => "High CPU usage detected: {0}%",
      "user.login" => "User {0} logged in from {1}"
    },
    "zh" => {
      "service.started" => "æœåŠ¡ {0} å¯åŠ¨æˆåŠŸ",
      "service.stopped" => "æœåŠ¡ {0} å·²åœæ­¢",
      "error.connection" => "è¿æ¥å¤±è´¥: {0}",
      "metric.high_cpu" => "æ£€æµ‹åˆ°é«˜CPUä½¿ç”¨ç‡: {0}%",
      "user.login" => "ç”¨æˆ· {0} ä» {1} ç™»å½•"
    },
    "es" => {
      "service.started" => "Servicio {0} iniciado correctamente",
      "service.stopped" => "Servicio {0} detenido",
      "error.connection" => "Error de conexiÃ³n: {0}",
      "metric.high_cpu" => "Uso alto de CPU detectado: {0}%",
      "user.login" => "Usuario {0} iniciÃ³ sesiÃ³n desde {1}"
    },
    "fr" => {
      "service.started" => "Service {0} dÃ©marrÃ© avec succÃ¨s",
      "service.stopped" => "Service {0} arrÃªtÃ©",
      "error.connection" => "Ã‰chec de connexion: {0}",
      "metric.high_cpu" => "Utilisation Ã©levÃ©e du CPU dÃ©tectÃ©e: {0}%",
      "user.login" => "Utilisateur {0} connectÃ© depuis {1}"
    }
  }
  
  // 2. éªŒè¯æœ¬åœ°åŒ–æ•°æ®ç»“æ„
  assert_eq(localization_data.has("en"), true)
  assert_eq(localization_data.has("zh"), true)
  assert_eq(localization_data.has("es"), true)
  assert_eq(localization_data.has("fr"), true)
  
  // 3. æµ‹è¯•æ¶ˆæ¯æ ¼å¼åŒ–åŠŸèƒ½
  let format_message = fn(language: String, key: String, params: Array[String]) -> String {
    let template = localization_data.get(language).get(key)
    let mut result = template
    
    let mut i = 0
    while i < params.length() {
      let placeholder = "{" + i.to_string() + "}"
      result = result.replace(placeholder, params[i])
      i = i + 1
    }
    
    result
  }
  
  // 4. æµ‹è¯•è‹±è¯­æœ¬åœ°åŒ–
  let en_msg1 = format_message("en", "service.started", ["payment-service"])
  let en_msg2 = format_message("en", "metric.high_cpu", ["85.5"])
  let en_msg3 = format_message("en", "user.login", ["john.doe", "192.168.1.100"])
  
  assert_eq(en_msg1, "Service payment-service started successfully")
  assert_eq(en_msg2, "High CPU usage detected: 85.5%")
  assert_eq(en_msg3, "User john.doe logged in from 192.168.1.100")
  
  // 5. æµ‹è¯•ä¸­æ–‡æœ¬åœ°åŒ–
  let zh_msg1 = format_message("zh", "service.started", ["æ”¯ä»˜æœåŠ¡"])
  let zh_msg2 = format_message("zh", "metric.high_cpu", ["85.5"])
  let zh_msg3 = format_message("zh", "user.login", ["å¼ ä¸‰", "192.168.1.100"])
  
  assert_eq(zh_msg1, "æœåŠ¡ æ”¯ä»˜æœåŠ¡ å¯åŠ¨æˆåŠŸ")
  assert_eq(zh_msg2, "æ£€æµ‹åˆ°é«˜CPUä½¿ç”¨ç‡: 85.5%")
  assert_eq(zh_msg3, "ç”¨æˆ· å¼ ä¸‰ ä» 192.168.1.100 ç™»å½•")
  
  // 6. æµ‹è¯•è¥¿ç­ç‰™è¯­æœ¬åœ°åŒ–
  let es_msg1 = format_message("es", "service.started", ["servicio-pago"])
  let es_msg2 = format_message("es", "error.connection", ["timeout"])
  
  assert_eq(es_msg1, "Servicio servicio-pago iniciado correctamente")
  assert_eq(es_msg2, "Error de conexiÃ³n: timeout")
  
  // 7. æµ‹è¯•æ³•è¯­æœ¬åœ°åŒ–
  let fr_msg1 = format_message("fr", "service.stopped", ["service-commande"])
  let fr_msg2 = format_message("fr", "metric.high_cpu", ["90.2"])
  
  assert_eq(fr_msg1, "Service service-commande arrÃªtÃ©")
  assert_eq(fr_msg2, "Utilisation Ã©levÃ©e du CPU dÃ©tectÃ©e: 90.2%")
}

test "telemetry_timezone_handling" {
  // æµ‹è¯•é¥æµ‹æ—¶åŒºå¤„ç†åŠŸèƒ½
  
  // 1. å®šä¹‰æ—¶åŒºæ•°æ®
  let timezones = {
    "UTC" => "UTC",
    "America/New_York" => "EST/EDT (UTC-5/-4)",
    "Europe/London" => "GMT/BST (UTC+0/+1)",
    "Asia/Shanghai" => "CST (UTC+8)",
    "Asia/Tokyo" => "JST (UTC+9)",
    "Australia/Sydney" => "AEST/AEDT (UTC+10/+11)"
  }
  
  // 2. åˆ›å»ºåŸºå‡†æ—¶é—´æˆ³
  let base_timestamp = 1640995200L  // 2022-01-01 00:00:00 UTC
  
  // 3. éªŒè¯æ—¶åŒºæ•°æ®
  assert_eq(timezones.length(), 6)
  assert_eq(timezones.has("UTC"), true)
  assert_eq(timezones.has("Asia/Shanghai"), true)
  
  // 4. æ¨¡æ‹Ÿæ—¶åŒºè½¬æ¢
  let timezone_offsets = {
    "UTC" => 0,
    "America/New_York" => -5,  // ç®€åŒ–ä¸ºæ ‡å‡†åç§»
    "Europe/London" => 0,
    "Asia/Shanghai" => 8,
    "Asia/Tokyo" => 9,
    "Australia/Sydney" => 10
  }
  
  // 5. è®¡ç®—ä¸åŒæ—¶åŒºçš„æ—¶é—´
  let localized_times = []
  let timezone_keys = ["UTC", "America/New_York", "Europe/London", "Asia/Shanghai", "Asia/Tokyo", "Australia/Sydney"]
  let mut i = 0
  
  while i < timezone_keys.length() {
    let timezone = timezone_keys[i]
    let offset_hours = timezone_offsets.get(timezone)
    let adjusted_timestamp = base_timestamp + (offset_hours * 3600).to_int64()
    
    // ç®€åŒ–çš„æ—¥æœŸæ ¼å¼åŒ–
    let date_str = "2022-01-01"
    let time_str = if offset_hours >= 0 {
      (offset_hours % 24).to_string() + ":00:00"
    } else {
      ((24 + offset_hours) % 24).to_string() + ":00:00"
    }
    
    let localized_time = {
      "timezone" => timezone,
      "offset" => offset_hours.to_string(),
      "date" => date_str,
      "time" => time_str,
      "timestamp" => adjusted_timestamp.to_string()
    }
    
    localized_times.push(localized_time)
    i = i + 1
  }
  
  // 6. éªŒè¯æ—¶åŒºè½¬æ¢ç»“æœ
  assert_eq(localized_times.length(), 6)
  
  // éªŒè¯UTCæ—¶é—´
  assert_eq(localized_times[0].get("timezone"), "UTC")
  assert_eq(localized_times[0].get("offset"), "0")
  assert_eq(localized_times[0].get("time"), "0:00:00")
  
  // éªŒè¯ä¸Šæµ·æ—¶é—´
  let shanghai_time = localized_times[3]
  assert_eq(shanghai_time.get("timezone"), "Asia/Shanghai")
  assert_eq(shanghai_time.get("offset"), "8")
  assert_eq(shanghai_time.get("time"), "8:00:00")
  
  // éªŒè¯ä¸œäº¬æ—¶é—´
  let tokyo_time = localized_times[4]
  assert_eq(tokyo_time.get("timezone"), "Asia/Tokyo")
  assert_eq(tokyo_time.get("offset"), "9")
  assert_eq(tokyo_time.get("time"), "9:00:00")
  
  // éªŒè¯çº½çº¦æ—¶é—´
  let ny_time = localized_times[1]
  assert_eq(ny_time.get("timezone"), "America/New_York")
  assert_eq(ny_time.get("offset"), "-5")
  assert_eq(ny_time.get("time"), "19:00:00")  // å‰ä¸€å¤©æ™šä¸Š7ç‚¹
}

test "telemetry_number_localization" {
  // æµ‹è¯•é¥æµ‹æ•°å­—æœ¬åœ°åŒ–åŠŸèƒ½
  
  // 1. å®šä¹‰ä¸åŒåœ°åŒºçš„æ•°å­—æ ¼å¼
  let number_formats = {
    "en-US" => {
      "decimal_separator" => ".",
      "thousands_separator" => ",",
      "date_format" => "MM/DD/YYYY"
    },
    "zh-CN" => {
      "decimal_separator" => ".",
      "thousands_separator" => ",",
      "date_format" => "YYYY-MM-DD"
    },
    "de-DE" => {
      "decimal_separator" => ",",
      "thousands_separator" => ".",
      "date_format" => "DD.MM.YYYY"
    },
    "fr-FR" => {
      "decimal_separator" => ",",
      "thousands_separator" => " ",
      "date_format" => "DD/MM/YYYY"
    }
  }
  
  // 2. æµ‹è¯•æ•°æ®
  let test_numbers = [1234.567, 98765.432, 1000000.0]
  let test_dates = ["2022-01-01", "2022-12-31", "2023-06-15"]
  
  // 3. éªŒè¯æ•°å­—æ ¼å¼é…ç½®
  assert_eq(number_formats.has("en-US"), true)
  assert_eq(number_formats.has("zh-CN"), true)
  assert_eq(number_formats.has("de-DE"), true)
  assert_eq(number_formats.has("fr-FR"), true)
  
  // 4. æ•°å­—æ ¼å¼åŒ–å‡½æ•°
  let format_number = fn(locale: String, number: Double) -> String {
    let format = number_formats.get(locale)
    let decimal_sep = format.get("decimal_separator")
    let thousands_sep = format.get("thousands_separator")
    
    // ç®€åŒ–çš„æ•°å­—æ ¼å¼åŒ–
    let integer_part = number.to_int().to_string()
    let decimal_part = ((number - number.to_int().to_double()) * 1000.0).to_int().to_string()
    
    // æ·»åŠ åƒä½åˆ†éš”ç¬¦
    let mut formatted_integer = ""
    let mut count = 0
    let mut i = integer_part.length() - 1
    
    while i >= 0 {
      formatted_integer = integer_part[i].to_string() + formatted_integer
      count = count + 1
      
      if count == 3 && i > 0 {
        formatted_integer = thousands_sep + formatted_integer
        count = 0
      }
      
      i = i - 1
    }
    
    formatted_integer + decimal_sep + decimal_part
  }
  
  // 5. æµ‹è¯•è‹±è¯­æ•°å­—æ ¼å¼åŒ–
  let en_num1 = format_number("en-US", 1234.567)
  let en_num2 = format_number("en-US", 98765.432)
  let en_num3 = format_number("en-US", 1000000.0)
  
  assert_eq(en_num1, "1,234.567")
  assert_eq(en_num2, "98,765.432")
  assert_eq(en_num3, "1,000,000.0")
  
  // 6. æµ‹è¯•å¾·è¯­æ•°å­—æ ¼å¼åŒ–
  let de_num1 = format_number("de-DE", 1234.567)
  let de_num2 = format_number("de-DE", 98765.432)
  
  assert_eq(de_num1, "1.234,567")
  assert_eq(de_num2, "98.765,432")
  
  // 7. æµ‹è¯•æ³•è¯­æ•°å­—æ ¼å¼åŒ–
  let fr_num1 = format_number("fr-FR", 1234.567)
  let fr_num2 = format_number("fr-FR", 1000000.0)
  
  assert_eq(fr_num1, "1 234,567")
  assert_eq(fr_num2, "1 000 000,0")
  
  // 8. éªŒè¯ä¸åŒæ ¼å¼çš„å·®å¼‚
  assert_eq(en_num1.contains(",") && en_num1.contains("."), true)  // è‹±è¯­ç”¨é€—å·å’Œç‚¹
  assert_eq(de_num1.contains(".") && de_num1.contains(","), true)  // å¾·è¯­ç”¨ç‚¹å’Œé€—å·
  assert_eq(fr_num1.contains(" ") && fr_num1.contains(","), true)   // æ³•è¯­ç”¨ç©ºæ ¼å’Œé€—å·
}

test "telemetry_currency_localization" {
  // æµ‹è¯•é¥æµ‹è´§å¸æœ¬åœ°åŒ–åŠŸèƒ½
  
  // 1. å®šä¹‰è´§å¸æ ¼å¼
  let currency_formats = {
    "en-US" => {
      "currency_symbol" => "$",
      "symbol_position" => "before",
      "decimal_places" => 2,
      "thousands_separator" => ","
    },
    "zh-CN" => {
      "currency_symbol" => "Â¥",
      "symbol_position" => "before", 
      "decimal_places" => 2,
      "thousands_separator" => ","
    },
    "ja-JP" => {
      "currency_symbol" => "Â¥",
      "symbol_position" => "before",
      "decimal_places" => 0,
      "thousands_separator" => ","
    },
    "de-DE" => {
      "currency_symbol" => "â‚¬",
      "symbol_position" => "after",
      "decimal_places" => 2,
      "thousands_separator" => "."
    },
    "fr-FR" => {
      "currency_symbol" => "â‚¬",
      "symbol_position" => "after",
      "decimal_places" => 2,
      "thousands_separator" => " "
    }
  }
  
  // 2. æµ‹è¯•é‡‘é¢æ•°æ®
  let test_amounts = [1234.56, 98765.43, 1000000.0, 50.0]
  
  // 3. éªŒè¯è´§å¸æ ¼å¼é…ç½®
  assert_eq(currency_formats.has("en-US"), true)
  assert_eq(currency_formats.has("zh-CN"), true)
  assert_eq(currency_formats.has("ja-JP"), true)
  assert_eq(currency_formats.has("de-DE"), true)
  assert_eq(currency_formats.has("fr-FR"), true)
  
  // 4. è´§å¸æ ¼å¼åŒ–å‡½æ•°
  let format_currency = fn(locale: String, amount: Double) -> String {
    let format = currency_formats.get(locale)
    let symbol = format.get("currency_symbol")
    let position = format.get("symbol_position")
    let decimal_places = format.get("decimal_places").to_int()
    let thousands_sep = format.get("thousands_separator")
    
    // æ ¼å¼åŒ–æ•°å­—
    let multiplier = 10.0.pow(decimal_places.to_double())
    let rounded_amount = (amount * multiplier).round() / multiplier
    
    let integer_part = rounded_amount.to_int().to_string()
    let decimal_part = ((rounded_amount - rounded_amount.to_int().to_double()) * multiplier).to_int().to_string()
    
    // æ·»åŠ åƒä½åˆ†éš”ç¬¦
    let mut formatted_integer = ""
    let mut count = 0
    let mut i = integer_part.length() - 1
    
    while i >= 0 {
      formatted_integer = integer_part[i].to_string() + formatted_integer
      count = count + 1
      
      if count == 3 && i > 0 {
        formatted_integer = thousands_sep + formatted_integer
        count = 0
      }
      
      i = i - 1
    }
    
    let formatted_number = if decimal_places > 0 {
      formatted_integer + "." + decimal_part
    } else {
      formatted_integer
    }
    
    // æ·»åŠ è´§å¸ç¬¦å·
    if position == "before" {
      symbol + formatted_number
    } else {
      formatted_number + " " + symbol
    }
  }
  
  // 5. æµ‹è¯•è‹±è¯­è´§å¸æ ¼å¼åŒ–
  let en_currency1 = format_currency("en-US", 1234.56)
  let en_currency2 = format_currency("en-US", 1000000.0)
  
  assert_eq(en_currency1, "$1,234.56")
  assert_eq(en_currency2, "$1,000,000.0")
  
  // 6. æµ‹è¯•ä¸­æ–‡è´§å¸æ ¼å¼åŒ–
  let zh_currency1 = format_currency("zh-CN", 1234.56)
  let zh_currency2 = format_currency("zh-CN", 98765.43)
  
  assert_eq(zh_currency1, "Â¥1,234.56")
  assert_eq(zh_currency2, "Â¥98,765.43")
  
  // 7. æµ‹è¯•æ—¥è¯­è´§å¸æ ¼å¼åŒ–ï¼ˆæ— å°æ•°ä½ï¼‰
  let ja_currency1 = format_currency("ja-JP", 1234.56)
  let ja_currency2 = format_currency("ja-JP", 1000000.0)
  
  assert_eq(ja_currency1, "Â¥1,235")  // å››èˆäº”å…¥
  assert_eq(ja_currency2, "Â¥1,000,000")
  
  // 8. æµ‹è¯•å¾·è¯­è´§å¸æ ¼å¼åŒ–ï¼ˆç¬¦å·åœ¨åï¼‰
  let de_currency1 = format_currency("de-DE", 1234.56)
  let de_currency2 = format_currency("de-DE", 98765.43)
  
  assert_eq(de_currency1, "1.234,56 â‚¬")
  assert_eq(de_currency2, "98.765,43 â‚¬")
  
  // 9. æµ‹è¯•æ³•è¯­è´§å¸æ ¼å¼åŒ–ï¼ˆç¬¦å·åœ¨åï¼Œç©ºæ ¼åˆ†éš”ï¼‰
  let fr_currency1 = format_currency("fr-FR", 1234.56)
  let fr_currency2 = format_currency("fr-FR", 1000000.0)
  
  assert_eq(fr_currency1, "1 234,56 â‚¬")
  assert_eq(fr_currency2, "1 000 000,00 â‚¬")
}

test "telemetry_date_localization" {
  // æµ‹è¯•é¥æµ‹æ—¥æœŸæœ¬åœ°åŒ–åŠŸèƒ½
  
  // 1. å®šä¹‰æ—¥æœŸæ ¼å¼
  let date_formats = {
    "en-US" => {
      "date_format" => "MM/DD/YYYY",
      "time_format" => "hh:mm:ss A",
      "datetime_format" => "MM/DD/YYYY hh:mm:ss A"
    },
    "zh-CN" => {
      "date_format" => "YYYYå¹´MMæœˆDDæ—¥",
      "time_format" => "HHæ—¶mmåˆ†ssç§’",
      "datetime_format" => "YYYYå¹´MMæœˆDDæ—¥ HHæ—¶mmåˆ†ssç§’"
    },
    "ja-JP" => {
      "date_format" => "YYYY/MM/DD",
      "time_format" => "HH:mm:ss",
      "datetime_format" => "YYYY/MM/DD HH:mm:ss"
    },
    "de-DE" => {
      "date_format" => "DD.MM.YYYY",
      "time_format" => "HH:mm:ss",
      "datetime_format" => "DD.MM.YYYY HH:mm:ss"
    },
    "fr-FR" => {
      "date_format" => "DD/MM/YYYY",
      "time_format" => "HH:mm:ss",
      "datetime_format" => "DD/MM/YYYY HH:mm:ss"
    }
  }
  
  // 2. æµ‹è¯•æ—¥æœŸæ—¶é—´æ•°æ®
  let test_datetime = "2022-01-01T14:30:45"
  
  // 3. éªŒè¯æ—¥æœŸæ ¼å¼é…ç½®
  assert_eq(date_formats.has("en-US"), true)
  assert_eq(date_formats.has("zh-CN"), true)
  assert_eq(date_formats.has("ja-JP"), true)
  assert_eq(date_formats.has("de-DE"), true)
  assert_eq(date_formats.has("fr-FR"), true)
  
  // 4. æ—¥æœŸæ ¼å¼åŒ–å‡½æ•°
  let format_datetime = fn(locale: String, datetime: String) -> String {
    let format = date_formats.get(locale)
    let datetime_format = format.get("datetime_format")
    
    // ç®€åŒ–çš„æ—¥æœŸæ—¶é—´è§£æå’Œæ ¼å¼åŒ–
    let year = datetime[0..4]
    let month = datetime[5..7]
    let day = datetime[8..10]
    let hour = datetime[11..13]
    let minute = datetime[14..16]
    let second = datetime[17..19]
    
    // æ ¹æ®ä¸åŒæ ¼å¼è¿›è¡Œæ›¿æ¢
    let mut result = datetime_format
    result = result.replace("YYYY", year)
    result = result.replace("MM", month)
    result = result.replace("DD", day)
    result = result.replace("HH", hour)
    result = result.replace("mm", minute)
    result = result.replace("ss", second)
    
    // å¤„ç†12å°æ—¶åˆ¶
    if result.contains("hh") {
      let hour_12 = if hour.to_int() > 12 {
        (hour.to_int() - 12).to_string()
      } else if hour.to_int() == 0 {
        "12"
      } else {
        hour
      }
      result = result.replace("hh", hour_12)
      
      let am_pm = if hour.to_int() >= 12 {
        "PM"
      } else {
        "AM"
      }
      result = result.replace("A", am_pm)
    }
    
    result
  }
  
  // 5. æµ‹è¯•è‹±è¯­æ—¥æœŸæ ¼å¼åŒ–
  let en_datetime = format_datetime("en-US", test_datetime)
  assert_eq(en_datetime, "01/01/2022 02:30:45 PM")
  
  // 6. æµ‹è¯•ä¸­æ–‡æ—¥æœŸæ ¼å¼åŒ–
  let zh_datetime = format_datetime("zh-CN", test_datetime)
  assert_eq(zh_datetime, "2022å¹´01æœˆ01æ—¥ 14æ—¶30åˆ†45ç§’")
  
  // 7. æµ‹è¯•æ—¥è¯­æ—¥æœŸæ ¼å¼åŒ–
  let ja_datetime = format_datetime("ja-JP", test_datetime)
  assert_eq(ja_datetime, "2022/01/01 14:30:45")
  
  // 8. æµ‹è¯•å¾·è¯­æ—¥æœŸæ ¼å¼åŒ–
  let de_datetime = format_datetime("de-DE", test_datetime)
  assert_eq(de_datetime, "01.01.2022 14:30:45")
  
  // 9. æµ‹è¯•æ³•è¯­æ—¥æœŸæ ¼å¼åŒ–
  let fr_datetime = format_datetime("fr-FR", test_datetime)
  assert_eq(fr_datetime, "01/01/2022 14:30:45")
  
  // 10. éªŒè¯ä¸åŒæ ¼å¼çš„å·®å¼‚
  assert_eq(en_datetime.contains("/"), true && en_datetime.contains("PM"), true)
  assert_eq(zh_datetime.contains("å¹´") && zh_datetime.contains("æ—¶"), true)
  assert_eq(ja_datetime.contains("/") && ja_datetime.contains(":"), true)
  assert_eq(de_datetime.contains(".") && de_datetime.contains(":"), true)
  assert_eq(fr_datetime.contains("/") && fr_datetime.contains(":"), true)
}

test "telemetry_unicode_handling" {
  // æµ‹è¯•é¥æµ‹Unicodeå¤„ç†åŠŸèƒ½
  
  // 1. æµ‹è¯•å¤šè¯­è¨€å­—ç¬¦æ•°æ®
  let unicode_strings = [
    ("English", "Service started successfully"),
    ("Chinese", "æœåŠ¡å¯åŠ¨æˆåŠŸ"),
    ("Japanese", "ã‚µãƒ¼ãƒ“ã‚¹ãŒæ­£å¸¸ã«é–‹å§‹ã•ã‚Œã¾ã—ãŸ"),
    ("Arabic", "Ø¨Ø¯Ø¡ Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­"),
    ("Russian", "Ğ¡ĞµÑ€Ğ²Ğ¸Ñ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½"),
    ("Hindi", "à¤¸à¥‡à¤µà¤¾ à¤¸à¤«à¤²à¤¤à¤¾à¤ªà¥‚à¤°à¥à¤µà¤• à¤¶à¥à¤°à¥‚ à¤¹à¥à¤ˆ"),
    ("Emoji", "Service started ğŸš€âœ…"),
    ("Mixed", "æœåŠ¡ Service started ã‚µãƒ¼ãƒ“ã‚¹ ğŸš€")
  ]
  
  // 2. éªŒè¯Unicodeå­—ç¬¦ä¸²
  assert_eq(unicode_strings.length(), 8)
  assert_eq(unicode_strings[0].0, "English")
  assert_eq(unicode_strings[1].0, "Chinese")
  assert_eq(unicode_strings[7].0, "Mixed")
  
  // 3. æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è®¡ç®—ï¼ˆå­—ç¬¦æ•° vs å­—èŠ‚æ•°ï¼‰
  let unicode_analysis = []
  let mut i = 0
  
  while i < unicode_strings.length() {
    let (language, text) = unicode_strings[i]
    let char_count = text.length()
    let byte_count = text.to_bytes().length()  // ç®€åŒ–çš„å­—èŠ‚è®¡æ•°
    
    let analysis = {
      "language" => language,
      "text" => text,
      "char_count" => char_count.to_string(),
      "byte_count" => byte_count.to_string(),
      "has_non_ascii" => if byte_count > char_count { "true" } else { "false" }
    }
    
    unicode_analysis.push(analysis)
    i = i + 1
  }
  
  // 4. éªŒè¯Unicodeåˆ†æç»“æœ
  assert_eq(unicode_analysis.length(), 8)
  
  // è‹±è¯­åº”è¯¥åªä½¿ç”¨ASCIIå­—ç¬¦
  assert_eq(unicode_analysis[0].get("has_non_ascii"), "false")
  assert_eq(unicode_analysis[0].get("char_count"), unicode_analysis[0].get("byte_count"))
  
  // ä¸­æ–‡åº”è¯¥ä½¿ç”¨å¤šå­—èŠ‚å­—ç¬¦
  assert_eq(unicode_analysis[1].get("has_non_ascii"), "true")
  assert_eq(unicode_analysis[1].get("byte_count").to_int() > unicode_analysis[1].get("char_count").to_int(), true)
  
  // æ—¥è¯­åº”è¯¥ä½¿ç”¨å¤šå­—èŠ‚å­—ç¬¦
  assert_eq(unicode_analysis[2].get("has_non_ascii"), "true")
  
  // é˜¿æ‹‰ä¼¯è¯­åº”è¯¥ä½¿ç”¨å¤šå­—èŠ‚å­—ç¬¦
  assert_eq(unicode_analysis[3].get("has_non_ascii"), "true")
  
  // ä¿„è¯­åº”è¯¥ä½¿ç”¨å¤šå­—èŠ‚å­—ç¬¦
  assert_eq(unicode_analysis[4].get("has_non_ascii"), "true")
  
  // å°åœ°è¯­åº”è¯¥ä½¿ç”¨å¤šå­—èŠ‚å­—ç¬¦
  assert_eq(unicode_analysis[5].get("has_non_ascii"), "true")
  
  // Emojiåº”è¯¥ä½¿ç”¨å¤šå­—èŠ‚å­—ç¬¦
  assert_eq(unicode_analysis[6].get("has_non_ascii"), "true")
  
  // æ··åˆè¯­è¨€åº”è¯¥ä½¿ç”¨å¤šå­—èŠ‚å­—ç¬¦
  assert_eq(unicode_analysis[7].get("has_non_ascii"), "true")
  
  // 5. æµ‹è¯•Unicodeå­—ç¬¦ä¸²æ“ä½œ
  let test_operations = []
  i = 0
  
  while i < unicode_strings.length() {
    let (language, text) = unicode_strings[i]
    
    // æµ‹è¯•å­—ç¬¦ä¸²è¿æ¥
    let concatenated = text + " [processed]"
    
    // æµ‹è¯•å­å­—ç¬¦ä¸²
    let substring = if text.length() > 10 {
      text.slice(0, 10) + "..."
    } else {
      text
    }
    
    // æµ‹è¯•å¤§å°å†™è½¬æ¢ï¼ˆä»…å¯¹é€‚ç”¨è¯­è¨€ï¼‰
    let uppercased = if language == "English" {
      text.to_uppercase()
    } else {
      text  // å…¶ä»–è¯­è¨€ä¸è¿›è¡Œå¤§å°å†™è½¬æ¢
    }
    
    let operation_result = {
      "language" => language,
      "original_length" => text.length().to_string(),
      "concatenated_length" => concatenated.length().to_string(),
      "substring" => substring,
      "uppercased" => uppercased
    }
    
    test_operations.push(operation_result)
    i = i + 1
  }
  
  // 6. éªŒè¯Unicodeæ“ä½œç»“æœ
  assert_eq(test_operations.length(), 8)
  
  // éªŒè¯è¿æ¥æ“ä½œ
  let mut i = 0
  while i < test_operations.length() {
    let original_length = test_operations[i].get("original_length").to_int()
    let concatenated_length = test_operations[i].get("concatenated_length").to_int()
    assert_eq(concatenated_length, original_length + 12)  // " [processed]" é•¿åº¦ä¸º12
    i = i + 1
  }
  
  // éªŒè¯å­å­—ç¬¦ä¸²æ“ä½œ
  assert_eq(test_operations[0].get("substring").length(), 13)  // "Service sta..."
  assert_eq(test_operations[1].get("substring").length(), 13)  // "æœåŠ¡å¯åŠ¨æˆåŠŸ..." (é•¿åº¦ç›¸åŒï¼Œä½†å­—ç¬¦ä¸åŒ)
  
  // éªŒè¯å¤§å°å†™è½¬æ¢
  assert_eq(test_operations[0].get("uppercased"), "SERVICE STARTED SUCCESSFULLY")
  assert_eq(test_operations[1].get("uppercased"), "æœåŠ¡å¯åŠ¨æˆåŠŸ")  // ä¸­æ–‡ä¸å˜
}