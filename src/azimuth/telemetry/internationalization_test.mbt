// å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•ç³»ç»Ÿåœ¨ä¸åŒè¯­è¨€å’Œåœ°åŒºçš„æ”¯æŒ

test "unicode_character_handling" {
  // æµ‹è¯•Unicodeå­—ç¬¦å¤„ç†
  
  let unicode_test_strings = [
    ("English", "Hello World"),
    ("Chinese", "ä½ å¥½ä¸–ç•Œ"),
    ("Japanese", "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ"),
    ("Korean", "ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„"),
    ("Arabic", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"),
    ("Russian", "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€"),
    ("German", "Hallo Welt"),
    ("French", "Bonjour le monde"),
    ("Spanish", "Hola Mundo"),
    ("Emoji", "ğŸš€ Telemetry ğŸ“Š Monitoring ğŸ”")
  ]
  
  let processed_strings = []
  
  for test_string in unicode_test_strings {
    let language = test_string.0
    let content = test_string.1
    
    // éªŒè¯å­—ç¬¦ä¸²é•¿åº¦å’Œå†…å®¹
    assert_eq(content.length() > 0, true)
    
    // éªŒè¯å­—ç¬¦ç¼–ç 
    let byte_count = content.length() * 4  // å‡è®¾UTF-8ç¼–ç 
    assert_eq(byte_count > 0, true)
    
    // å¤„ç†å­—ç¬¦ä¸²ï¼ˆæ¨¡æ‹Ÿå›½é™…åŒ–å¤„ç†ï¼‰
    let processed = "[" + language + "] " + content
    processed_strings.push(processed)
  }
  
  // éªŒè¯Unicodeå¤„ç†ç»“æœ
  assert_eq(processed_strings.length(), 10)
  assert_eq(processed_strings[0], "[English] Hello World")
  assert_eq(processed_strings[1], "[Chinese] ä½ å¥½ä¸–ç•Œ")
  assert_eq(processed_strings[9], "[Emoji] ğŸš€ Telemetry ğŸ“Š Monitoring ğŸ”")
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let emoji_string = processed_strings[9]
  assert_eq(emoji_string.contains("ğŸš€"), true)
  assert_eq(emoji_string.contains("ğŸ“Š"), true)
  assert_eq(emoji_string.contains("ğŸ”"), true)
}

test "localized_error_messages" {
  // æµ‹è¯•æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯
  
  let error_codes = [
    "TRACE_ID_INVALID",
    "SPAN_NOT_FOUND", 
    "METRIC_AGGREGATION_FAILED",
    "SERIALIZATION_ERROR",
    "NETWORK_TIMEOUT"
  ]
  
  let localized_messages = {
    "en": {
      "TRACE_ID_INVALID": "Invalid trace ID format",
      "SPAN_NOT_FOUND": "Span not found",
      "METRIC_AGGREGATION_FAILED": "Metric aggregation failed",
      "SERIALIZATION_ERROR": "Data serialization error",
      "NETWORK_TIMEOUT": "Network operation timed out"
    },
    "zh": {
      "TRACE_ID_INVALID": "æ— æ•ˆçš„è¿½è¸ªIDæ ¼å¼",
      "SPAN_NOT_FOUND": "æœªæ‰¾åˆ°Span",
      "METRIC_AGGREGATION_FAILED": "æŒ‡æ ‡èšåˆå¤±è´¥",
      "SERIALIZATION_ERROR": "æ•°æ®åºåˆ—åŒ–é”™è¯¯",
      "NETWORK_TIMEOUT": "ç½‘ç»œæ“ä½œè¶…æ—¶"
    },
    "ja": {
      "TRACE_ID_INVALID": "ç„¡åŠ¹ãªãƒˆãƒ¬ãƒ¼ã‚¹IDå½¢å¼",
      "SPAN_NOT_FOUND": "ã‚¹ãƒ‘ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
      "METRIC_AGGREGATION_FAILED": "ãƒ¡ãƒˆãƒªãƒƒã‚¯é›†è¨ˆã«å¤±æ•—ã—ã¾ã—ãŸ",
      "SERIALIZATION_ERROR": "ãƒ‡ãƒ¼ã‚¿ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã‚¨ãƒ©ãƒ¼",
      "NETWORK_TIMEOUT": "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ“ä½œãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ"
    }
  }
  
  let languages = ["en", "zh", "ja"]
  let test_results = []
  
  for language in languages {
    let messages = localized_messages[language]
    
    for error_code in error_codes {
      let message = messages[error_code]
      test_results.push((language, error_code, message))
      
      // éªŒè¯æ¶ˆæ¯å­˜åœ¨ä¸”éç©º
      assert_eq(message.length() > 0, true)
    }
  }
  
  // éªŒè¯æœ¬åœ°åŒ–æ¶ˆæ¯
  assert_eq(test_results.length(), 15)  // 3 languages * 5 error codes
  
  // éªŒè¯ç‰¹å®šè¯­è¨€çš„é”™è¯¯æ¶ˆæ¯
  let en_trace_error = test_results.find(fn(result) { 
    result.0 == "en" and result.1 == "TRACE_ID_INVALID" 
  })
  let zh_trace_error = test_results.find(fn(result) { 
    result.0 == "zh" and result.1 == "TRACE_ID_INVALID" 
  })
  let ja_trace_error = test_results.find(fn(result) { 
    result.0 == "ja" and result.1 == "TRACE_ID_INVALID" 
  })
  
  match en_trace_error {
    Some(result) => assert_eq(result.2, "Invalid trace ID format")
    None => @test.fail("English error message not found")
  }
  
  match zh_trace_error {
    Some(result) => assert_eq(result.2, "æ— æ•ˆçš„è¿½è¸ªIDæ ¼å¼")
    None => @test.fail("Chinese error message not found")
  }
  
  match ja_trace_error {
    Some(result) => assert_eq(result.2, "ç„¡åŠ¹ãªãƒˆãƒ¬ãƒ¼ã‚¹IDå½¢å¼")
    None => @test.fail("Japanese error message not found")
  }
}

test "locale_specific_formatting" {
  // æµ‹è¯•åœ°åŒºç‰¹å®šæ ¼å¼åŒ–
  
  let test_data = {
    "timestamp": "2023-01-01T12:30:45Z",
    "number": 1234.567,
    "percentage": 0.75,
    "duration_ms": 2500
  }
  
  let locale_formats = {
    "en-US": {
      "date": "01/01/2023",
      "time": "12:30:45 PM",
      "number": "1,234.567",
      "percentage": "75.0%",
      "duration": "2.5s"
    },
    "zh-CN": {
      "date": "2023å¹´01æœˆ01æ—¥",
      "time": "12:30:45",
      "number": "1,234.567",
      "percentage": "75.0%",
      "duration": "2.5ç§’"
    },
    "de-DE": {
      "date": "01.01.2023",
      "time": "12:30:45",
      "number": "1.234,567",
      "percentage": "75,0%",
      "duration": "2,5s"
    },
    "ja-JP": {
      "date": "2023/01/01",
      "time": "12:30:45",
      "number": "1,234.567",
      "percentage": "75.0%",
      "duration": "2.5ç§’"
    }
  }
  
  let formatting_results = []
  
  for locale in locale_formats.keys() {
    let format = locale_formats[locale]
    
    // éªŒè¯æ—¥æœŸæ ¼å¼
    assert_eq(format["date"].length() > 0, true)
    assert_eq(format["date"].contains("2023"), true)
    assert_eq(format["date"].contains("01"), true)
    
    // éªŒè¯æ—¶é—´æ ¼å¼
    assert_eq(format["time"].length() > 0, true)
    assert_eq(format["time"].contains("12"), true)
    assert_eq(format["time"].contains("30"), true)
    
    // éªŒè¯æ•°å­—æ ¼å¼
    assert_eq(format["number"].contains("1"), true)
    assert_eq(format["number"].contains("234"), true)
    
    // éªŒè¯ç™¾åˆ†æ¯”æ ¼å¼
    assert_eq(format["percentage"].contains("75"), true)
    assert_eq(format["percentage"].contains("%"), true)
    
    // éªŒè¯æŒç»­æ—¶é—´æ ¼å¼
    assert_eq(format["duration"].contains("2.5"), true)
    
    formatting_results.push((locale, format))
  }
  
  // éªŒè¯åœ°åŒºç‰¹å®šæ ¼å¼åŒ–ç»“æœ
  assert_eq(formatting_results.length(), 4)
  
  // éªŒè¯ç‰¹å®šåœ°åŒºçš„æ ¼å¼å·®å¼‚
  let us_format = locale_formats["en-US"]
  let german_format = locale_formats["de-DE"]
  
  // å¾·è¯­ä½¿ç”¨é€—å·ä½œä¸ºå°æ•°ç‚¹åˆ†éš”ç¬¦
  assert_eq(german_format["number"].contains(","), true)
  assert_eq(us_format["number"].contains("."), true)
  
  // ä¸åŒçš„æ—¥æœŸæ ¼å¼
  assert_eq(us_format["date"], "01/01/2023")
  assert_eq(german_format["date"], "01.01.2023")
}

test "rtl_language_support" {
  // æµ‹è¯•ä»å³åˆ°å·¦è¯­è¨€æ”¯æŒ
  
  let rtl_languages = {
    "ar": {
      "service_name": "Ø®Ø¯Ù…Ø© Ø§Ù„Ø¯ÙØ¹",
      "operation_name": "Ø·Ù„Ø¨ HTTP",
      "status": "Ù†Ø¬Ø­",
      "error_message": "Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø´Ø¨ÙƒØ©"
    },
    "he": {
      "service_name": "×©×™×¨×•×ª ×ª×©×œ×•××™×",
      "operation_name": "×‘×§×©×ª HTTP",
      "status": "×”×¦×œ×™×—",
      "error_message": "×ª× ×”×–××Ÿ ×”××•×§×¦×‘ ×œ×¨×©×ª"
    },
    "fa": {
      "service_name": "Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø®Øª",
      "operation_name": "Ø¯Ø±Ø®ÙˆØ§Ø³Øª HTTP",
      "status": "Ù…ÙˆÙÙ‚ÛŒØª",
      "error_message": "Ø§ØªØµØ§Ù„ Ø´Ø¨Ú©Ù‡ Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯"
    }
  }
  
  let rtl_test_results = []
  
  for language in rtl_languages.keys() {
    let translations = rtl_languages[language]
    
    for key in translations.keys() {
      let text = translations[key]
      
      // éªŒè¯RTLæ–‡æœ¬
      assert_eq(text.length() > 0, true)
      
      // æ£€æŸ¥æ˜¯å¦åŒ…å«RTLå­—ç¬¦ï¼ˆç®€åŒ–æ£€æŸ¥ï¼‰
      let has_rtl_chars = text.any(fn(char) { 
        char >= "\u0590" and char <= "\u08FF"  // é˜¿æ‹‰ä¼¯ã€å¸Œä¼¯æ¥è¯­å­—ç¬¦èŒƒå›´
      })
      
      rtl_test_results.push((language, key, text, has_rtl_chars))
    }
  }
  
  // éªŒè¯RTLè¯­è¨€æ”¯æŒ
  assert_eq(rtl_test_results.length(), 12)  // 3 languages * 4 keys
  
  // éªŒè¯é˜¿æ‹‰ä¼¯è¯­ç¤ºä¾‹
  let arabic_service = rtl_test_results.find(fn(result) { 
    result.0 == "ar" and result.1 == "service_name" 
  })
  
  match arabic_service {
    Some(result) => {
      assert_eq(result.2, "Ø®Ø¯Ù…Ø© Ø§Ù„Ø¯ÙØ¹")
      assert_eq(result.3, true)  // åº”è¯¥åŒ…å«RTLå­—ç¬¦
    }
    None => @test.fail("Arabic service name not found")
  }
  
  // éªŒè¯å¸Œä¼¯æ¥è¯­ç¤ºä¾‹
  let hebrew_status = rtl_test_results.find(fn(result) { 
    result.0 == "he" and result.1 == "status" 
  })
  
  match hebrew_status {
    Some(result) => {
      assert_eq(result.2, "×”×¦×œ×™×—")
      assert_eq(result.3, true)  // åº”è¯¥åŒ…å«RTLå­—ç¬¦
    }
    None => @test.fail("Hebrew status not found")
  }
}

test "multi_language_attribute_handling" {
  // æµ‹è¯•å¤šè¯­è¨€å±æ€§å¤„ç†
  
  let multi_language_attributes = [
    ("service.name", {
      "en": "Payment Service",
      "zh": "æ”¯ä»˜æœåŠ¡",
      "ja": "æ”¯æ‰•ã„ã‚µãƒ¼ãƒ“ã‚¹",
      "ko": "ê²°ì œ ì„œë¹„ìŠ¤",
      "ar": "Ø®Ø¯Ù…Ø© Ø§Ù„Ø¯ÙØ¹"
    }),
    ("operation.description", {
      "en": "Process user payment",
      "zh": "å¤„ç†ç”¨æˆ·æ”¯ä»˜",
      "ja": "ãƒ¦ãƒ¼ã‚¶ãƒ¼æ”¯æ‰•ã„å‡¦ç†",
      "ko": "ì‚¬ìš©ì ê²°ì œ ì²˜ë¦¬",
      "ar": "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¯ÙØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"
    }),
    ("error.message", {
      "en": "Connection timeout",
      "zh": "è¿æ¥è¶…æ—¶",
      "ja": "æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ",
      "ko": "ì—°ê²° ì‹œê°„ ì´ˆê³¼",
      "ar": "Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„"
    })
  ]
  
  let supported_languages = ["en", "zh", "ja", "ko", "ar"]
  let attribute_processing_results = []
  
  for attribute in multi_language_attributes {
    let attribute_name = attribute.0
    let translations = attribute.1
    
    for language in supported_languages {
      let translated_value = translations[language]
      
      // éªŒè¯ç¿»è¯‘å­˜åœ¨
      assert_eq(translated_value.length() > 0, true)
      
      // æ¨¡æ‹Ÿå±æ€§å¤„ç†
      let processed_attribute = attribute_name + "[" + language + "]=" + translated_value
      attribute_processing_results.push(processed_attribute)
    }
  }
  
  // éªŒè¯å¤šè¯­è¨€å±æ€§å¤„ç†
  assert_eq(attribute_processing_results.length(), 15)  // 3 attributes * 5 languages
  
  // éªŒè¯ç‰¹å®šå±æ€§å’Œè¯­è¨€çš„ç»„åˆ
  let service_name_zh = attribute_processing_results.find(fn(result) { 
    result.contains("service.name[zh]")
  })
  let operation_desc_ja = attribute_processing_results.find(fn(result) { 
    result.contains("operation.description[ja]")
  })
  let error_message_ar = attribute_processing_results.find(fn(result) { 
    result.contains("error.message[ar]")
  })
  
  match service_name_zh {
    Some(result) => assert_eq(result, "service.name[zh]=æ”¯ä»˜æœåŠ¡")
    None => @test.fail("Chinese service name not found")
  }
  
  match operation_desc_ja {
    Some(result) => assert_eq(result, "operation.description[ja]=ãƒ¦ãƒ¼ã‚¶ãƒ¼æ”¯æ‰•ã„å‡¦ç†")
    None => @test.fail("Japanese operation description not found")
  }
  
  match error_message_ar {
    Some(result) => assert_eq(result, "error.message[ar]=Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„")
    None => @test.fail("Arabic error message not found")
  }
}