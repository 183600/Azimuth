// å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•ç”¨ä¾‹
test "unicode_and_multilingual_support" {
  // æµ‹è¯•Unicodeå’Œå¤šè¯­è¨€å­—ç¬¦æ”¯æŒ
  
  // 1. å®šä¹‰å¤šè¯­è¨€æµ‹è¯•æ•°æ®
  let multilingual_strings = [
    // ä¸­æ–‡
    "ç”¨æˆ·ç™»å½•æˆåŠŸ",
    "æ•°æ®åº“è¿æ¥å¤±è´¥",
    "è¯·æ±‚å¤„ç†æ—¶é—´è¶…æ—¶",
    // æ—¥æ–‡
    "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ",
    "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šå¤±æ•—",
    "ãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ",
    // éŸ©æ–‡
    "ì‚¬ìš©ì ë¡œê·¸ì¸ ì„±ê³µ",
    "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨",
    "ìš”ì²­ ì²˜ë¦¬ ì‹œê°„ ì´ˆê³¼",
    // é˜¿æ‹‰ä¼¯æ–‡
    "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­",
    "ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª",
    "Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨",
    // ä¿„æ–‡
    "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ²Ğ¾ÑˆĞµĞ» Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ",
    "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…",
    "Ğ’Ñ€ĞµĞ¼Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ¸ÑÑ‚ĞµĞºĞ»Ğ¾",
    // å°åœ°æ–‡
    "à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤¸à¤«à¤²à¤¤à¤¾à¤ªà¥‚à¤°à¥à¤µà¤• à¤²à¥‰à¤— à¤‡à¤¨ à¤•à¤¿à¤¯à¤¾",
    "à¤¡à¥‡à¤Ÿà¤¾à¤¬à¥‡à¤¸ à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤µà¤¿à¤«à¤²",
    "à¤…à¤¨à¥à¤°à¥‹à¤§ à¤ªà¥à¤°à¤¸à¤‚à¤¸à¥à¤•à¤°à¤£ à¤¸à¤®à¤¯ à¤¸à¤®à¤¾à¤ªà¥à¤¤",
    // è¡¨æƒ…ç¬¦å·å’Œç‰¹æ®Šå­—ç¬¦
    "ç”¨æˆ·ç™»å½•æˆåŠŸ ğŸ‰",
    "Error: Database connection failed ğŸ’¥",
    "Request timeout â° Please try again",
    // æ··åˆè¯­è¨€
    "User ç”¨æˆ·ç™»å½•æˆåŠŸ successfully",
    "Error: æ•°æ®åº“è¿æ¥ failed",
    "Timeout: è¯·æ±‚å¤„ç†è¶…æ—¶ (Request timeout)"
  ]
  
  // 2. æµ‹è¯•å¤šè¯­è¨€å±æ€§å€¼
  let mut i = 0
  while i < multilingual_strings.length() {
    let message = multilingual_strings[i]
    
    // åˆ›å»ºåŒ…å«å¤šè¯­è¨€æ–‡æœ¬çš„å±æ€§
    let attributes = [
      ("message", AttributeValue::string(message)),
      ("language", AttributeValue::string(detect_language(message))),
      ("length", AttributeValue::int(message.length().to_int64()))
    ]
    
    // åˆ›å»ºåŒ…å«å¤šè¯­è¨€æ–‡æœ¬çš„æ—¥å¿—è®°å½•
    let log_record = LogRecord::{
      timestamp_unix_nanos: 1640995200000000000L,
      observed_timestamp_unix_nanos: None,
      severity_number: Info,
      severity_text: Some("MULTILINGUAL"),
      body: Some(message),
      attributes: attributes,
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    }
    
    // éªŒè¯å¤šè¯­è¨€æ–‡æœ¬å¤„ç†
    match log_record.body {
      Some(body) => {
        assert_eq(body, message)
        assert_eq(body.length() > 0, true)
      }
      None => @test.fail("Expected Some(body)")
    }
    
    // éªŒè¯å±æ€§å€¼ä¸­çš„å¤šè¯­è¨€æ–‡æœ¬
    assert_eq(log_record.attributes.length(), 3)
    match log_record.attributes[0].1 {
      StringValue(msg) => assert_eq(msg, message)
      _ => @test.fail("Expected StringValue")
    }
    
    i = i + 1
  }
  
  // 3. æµ‹è¯•ç‰¹æ®ŠUnicodeå­—ç¬¦
  let special_unicode_chars = [
    "ğŸš€ Rocket emoji",
    "ğŸ”¥ Fire emoji",
    "ğŸ’¯ Hundred points",
    "â„¢ Trademark symbol",
    "Â® Registered symbol",
    "Â© Copyright symbol",
    "â‚¬ Euro symbol",
    "Â¥ Yen symbol",
    "Â£ Pound symbol",
    "â†’ Right arrow",
    "â† Left arrow",
    "â†‘ Up arrow",
    "â†“ Down arrow",
    "â€¦ Ellipsis",
    "â€” Em dash",
    "â€“ En dash",
    "" Smart quotes"",
    "' Apostrophe",
    "â€¢ Bullet point",
    "Â° Degree symbol"
  ]
  
  let mut j = 0
  while j < special_unicode_chars.length() {
    let special_char = special_unicode_chars[j]
    
    // æµ‹è¯•åŒ…å«ç‰¹æ®ŠUnicodeå­—ç¬¦çš„Spanåç§°
    let resource = Resource::default("æµ‹è¯•æœåŠ¡-" + special_char)
    assert_eq(resource.service_name.contains(special_char), true)
    
    // æµ‹è¯•åŒ…å«ç‰¹æ®ŠUnicodeå­—ç¬¦çš„å±æ€§å€¼
    let special_attributes = [
      ("special.char", AttributeValue::string(special_char)),
      ("char.length", AttributeValue::int(special_char.length().to_int64())),
      ("char.bytes", AttributeValue::int(special_char.to_byte_array().length().to_int64()))
    ]
    
    assert_eq(special_attributes.length(), 3)
    
    j = j + 1
  }
  
  // 4. æµ‹è¯•ä»å³åˆ°å·¦(RTL)è¯­è¨€
  let rtl_strings = [
    "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±",
    "×¢×‘×¨×™×ª ××™××™×Ÿ ×œ×©×××œ",
    "ÙØ§Ø±Ø³ÛŒ Ø§Ø² Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾"
  ]
  
  let mut k = 0
  while k < rtl_strings.length() {
    let rtl_string = rtl_strings[k]
    
    // æµ‹è¯•RTLå­—ç¬¦ä¸²åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å¤„ç†
    let ctx = Context::empty()
    let rtl_key = create_key("rtl.message")
    let ctx_with_rtl = ctx.with_value(rtl_key, rtl_string)
    
    match ctx_with_rtl.get(rtl_key) {
      Some(value) => assert_eq(value, rtl_string)
      None => @test.fail("Expected Some(value) for RTL string")
    }
    
    k = k + 1
  }
}

test "character_encoding_and_normalization" {
  // æµ‹è¯•å­—ç¬¦ç¼–ç å’Œè§„èŒƒåŒ–
  
  // 1. æµ‹è¯•Unicodeè§„èŒƒåŒ–
  let composed_strings = [
    "Ã©",  // ç»„åˆå½¢å¼
    "cafÃ©",  // å¸¦é‡éŸ³çš„å­—ç¬¦
    "naÃ¯ve",  // åˆ†éŸ³ç¬¦
    "rÃ©sumÃ©",  // å¤šä¸ªé‡éŸ³ç¬¦å·
    "faÃ§ade",  // è½¯éŸ³ç¬¦
    "seÃ±or",  // æ³¢æµªå·
    "Zurich",  // å¸¦åˆ†éŸ³ç¬¦çš„å¾·è¯­
    "Ã…ngstrÃ¶m",  // ç‘å…¸å­—æ¯
    "Moskva",  // ä¿„è¯­åŸå¸‚
    "Beijing",  // ä¸­æ–‡æ‹¼éŸ³
    "TÅkyÅ",  // æ—¥è¯­ç½—é©¬å­—
    "SeÃºl",  // éŸ©è¯­
    "Cairo",  // é˜¿æ‹‰ä¼¯è¯­
    "Mumbai",  // å°åœ°è¯­
    "SÃ£o Paulo",  // è‘¡è„ç‰™è¯­
    "MÃ¼nchen",  // å¾·è¯­
    "GÃ¶teborg",  // ç‘å…¸è¯­
    "KrakÃ³w",  // æ³¢å…°è¯­
    "Barcelona",  // åŠ æ³°ç½—å°¼äºšè¯­
    "MontrÃ©al"  // æ³•è¯­
  ]
  
  // 2. æµ‹è¯•åˆ†è§£å½¢å¼
  let decomposed_strings = [
    "e\u0301",  // e + ç»„åˆé‡éŸ³ç¬¦
    "cafe\u0301",  // cafe + ç»„åˆé‡éŸ³ç¬¦
    "nai\u0308ve",  // nai + ç»„åˆåˆ†éŸ³ç¬¦
    "re\u0301sume\u0301",  // å¤šä¸ªç»„åˆé‡éŸ³ç¬¦
    "fac\u0327ade",  // fac + ç»„åˆè½¯éŸ³ç¬¦
    "sen\u0303or",  // sen + ç»„åˆæ³¢æµªå·
    "Zuri\u0308ch",  // Zuri + ç»„åˆåˆ†éŸ³ç¬¦
    "A\u030angstro\u0308m",  // A + ç»„åˆç¯ + ngstro + ç»„åˆåˆ†éŸ³ç¬¦ + m
    // å…¶ä»–è¯­è¨€...
  ]
  
  // 3. éªŒè¯è§„èŒƒåŒ–å¤„ç†
  let mut i = 0
  while i < composed_strings.length() {
    let composed = composed_strings[i]
    
    // åˆ›å»ºåŒ…å«ç»„åˆå­—ç¬¦çš„å±æ€§
    let composed_attributes = [
      ("original", AttributeValue::string(composed)),
      ("normalized", AttributeValue::string(normalize_unicode(composed))),
      ("length.composed", AttributeValue::int(composed.length().to_int64()))
    ]
    
    // æµ‹è¯•ç»„åˆå­—ç¬¦åœ¨é¥æµ‹æ•°æ®ä¸­çš„å¤„ç†
    let log_record = LogRecord::{
      timestamp_unix_nanos: 1640995200000000000L,
      observed_timestamp_unix_nanos: None,
      severity_number: Info,
      severity_text: Some("UNICODE_NORMALIZATION"),
      body: Some(composed),
      attributes: composed_attributes,
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    }
    
    match log_record.body {
      Some(body) => assert_eq(body, composed)
      None => @test.fail("Expected Some(body)")
    }
    
    i = i + 1
  }
  
  // 4. æµ‹è¯•é›¶å®½å­—ç¬¦
  let zero_width_strings = [
    "text\u200Bwith\u200Bzero\u200Bwidth\u200Bspaces",  // é›¶å®½ç©ºæ ¼
    "text\u200Cwith\u200Czero\u200Cwidth\u200Cnon-joiners",  // é›¶å®½éè¿æ¥ç¬¦
    "text\u200Dwith\u200Czero\u200Cwidth\u200Cjoiners",  // é›¶å®½è¿æ¥ç¬¦
    "text\uFEFFwith\uFEFFbyte\uFEFForder\uFEFFmarks"  // å­—èŠ‚é¡ºåºæ ‡è®°
  ]
  
  let mut j = 0
  while j < zero_width_strings.length() {
    let zw_string = zero_width_strings[j]
    let cleaned_string = remove_zero_width_chars(zw_string)
    
    // éªŒè¯é›¶å®½å­—ç¬¦æ¸…ç†
    assert_eq(cleaned_string.contains("\u200B"), false)
    assert_eq(cleaned_string.contains("\u200C"), false)
    assert_eq(cleaned_string.contains("\u200D"), false)
    assert_eq(cleaned_string.contains("\uFEFF"), false)
    
    j = j + 1
  }
}

test "locale_specific_formatting" {
  // æµ‹è¯•ç‰¹å®šåŒºåŸŸè®¾ç½®çš„æ ¼å¼åŒ–
  
  // 1. å®šä¹‰åŒºåŸŸè®¾ç½®é…ç½®
  struct LocaleConfig {
    language : String
    region : String
    date_format : String
    number_format : String
    currency : String
    time_zone : String
  }
  
  let locales = [
    LocaleConfig::{
      language: "zh",
      region: "CN",
      date_format: "YYYY-MM-DD",
      number_format: "#,##0.##",
      currency: "CNY",
      time_zone: "Asia/Shanghai"
    },
    LocaleConfig::{
      language: "en",
      region: "US",
      date_format: "MM/DD/YYYY",
      number_format: "#,##0.##",
      currency: "USD",
      time_zone: "America/New_York"
    },
    LocaleConfig::{
      language: "ja",
      region: "JP",
      date_format: "YYYY/MM/DD",
      number_format: "#,##0.##",
      currency: "JPY",
      time_zone: "Asia/Tokyo"
    },
    LocaleConfig::{
      language: "de",
      region: "DE",
      date_format: "DD.MM.YYYY",
      number_format: "#.##0,##",
      currency: "EUR",
      time_zone: "Europe/Berlin"
    },
    LocaleConfig::{
      language: "fr",
      region: "FR",
      date_format: "DD/MM/YYYY",
      number_format: "# ##0,##",
      currency: "EUR",
      time_zone: "Europe/Paris"
    }
  ]
  
  // 2. æµ‹è¯•æœ¬åœ°åŒ–æ ¼å¼åŒ–
  let mut i = 0
  while i < locales.length() {
    let locale = locales[i]
    
    // åˆ›å»ºæœ¬åœ°åŒ–çš„é¥æµ‹æ•°æ®
    let localized_attributes = [
      ("locale.language", AttributeValue::string(locale.language)),
      ("locale.region", AttributeValue::string(locale.region)),
      ("locale.date_format", AttributeValue::string(locale.date_format)),
      ("locale.number_format", AttributeValue::string(locale.number_format)),
      ("locale.currency", AttributeValue::string(locale.currency)),
      ("locale.time_zone", AttributeValue::string(locale.time_zone))
    ]
    
    // æµ‹è¯•æœ¬åœ°åŒ–çš„æ•°å­—æ ¼å¼
    let test_number = 1234.56
    let formatted_number = format_number(test_number, locale.number_format)
    
    let number_attributes = [
      ("number.raw", AttributeValue::float(test_number)),
      ("number.formatted", AttributeValue::string(formatted_number)),
      ("locale", AttributeValue::string(locale.language + "_" + locale.region))
    ]
    
    // æµ‹è¯•æœ¬åœ°åŒ–çš„æ—¥æœŸæ ¼å¼
    let test_timestamp = 1640995200000000000L  // 2022-01-01 00:00:00 UTC
    let formatted_date = format_timestamp(test_timestamp, locale.date_format, locale.time_zone)
    
    let date_attributes = [
      ("timestamp.raw", AttributeValue::int(test_timestamp)),
      ("date.formatted", AttributeValue::string(formatted_date)),
      ("locale", AttributeValue::string(locale.language + "_" + locale.region))
    ]
    
    // åˆ›å»ºåŒ…å«æœ¬åœ°åŒ–æ•°æ®çš„æ—¥å¿—è®°å½•
    let localized_log = LogRecord::{
      timestamp_unix_nanos: test_timestamp,
      observed_timestamp_unix_nanos: None,
      severity_number: Info,
      severity_text: Some("LOCALIZED_FORMATTING"),
      body: Some("Localized formatting test for " + locale.language + "_" + locale.region),
      attributes: localized_attributes,
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    }
    
    // éªŒè¯æœ¬åœ°åŒ–æ•°æ®
    assert_eq(localized_log.attributes.length(), 6)
    match localized_log.attributes[0].1 {
      StringValue(lang) => assert_eq(lang, locale.language)
      _ => @test.fail("Expected StringValue for language")
    }
    
    i = i + 1
  }
  
  // 3. æµ‹è¯•åŒå‘æ–‡æœ¬å¤„ç†
  let bidi_texts = [
    ("Hello Ù…Ø±Ø­Ø¨Ø§ World", "Mixed English-Arabic"),
    ("English ×¢×‘×¨×™×ª Text", "Mixed English-Hebrew"),
    ("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© English Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "Arabic-English-Arabic"),
    ("×¢×‘×¨×™×ª English ×¢×‘×¨×™×ª", "Hebrew-English-Hebrew")
  ]
  
  let mut j = 0
  while j < bidi_texts.length() {
    let (bidi_text, description) = bidi_texts[j]
    
    // æµ‹è¯•åŒå‘æ–‡æœ¬åœ¨å±æ€§ä¸­çš„å¤„ç†
    let bidi_attributes = [
      ("bidi.text", AttributeValue::string(bidi_text)),
      ("bidi.description", AttributeValue::string(description)),
      ("bidi.length", AttributeValue::int(bidi_text.length().to_int64())),
      ("bidi.direction", AttributeValue::string(detect_text_direction(bidi_text)))
    ]
    
    // éªŒè¯åŒå‘æ–‡æœ¬å¤„ç†
    assert_eq(bidi_attributes.length(), 4)
    
    j = j + 1
  }
}

// è¾…åŠ©å‡½æ•°
fn detect_language(text : String) -> String {
  if text.contains("ç”¨æˆ·") or text.contains("æ•°æ®åº“") or text.contains("è¯·æ±‚") {
    "zh"
  } else if text.contains("ãƒ¦ãƒ¼ã‚¶ãƒ¼") or text.contains("ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹") or text.contains("ãƒªã‚¯ã‚¨ã‚¹ãƒˆ") {
    "ja"
  } else if text.contains("ì‚¬ìš©ì") or text.contains("ë°ì´í„°ë² ì´ìŠ¤") or text.contains("ìš”ì²­") {
    "ko"
  } else if text.contains("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…") or text.contains("Ù‚Ø§Ø¹Ø¯Ø©") or text.contains("Ø§Ù„Ø·Ù„Ø¨") {
    "ar"
  } else if text.contains("ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ") or text.contains("Ğ±Ğ°Ğ·Ñ‹") or text.contains("Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°") {
    "ru"
  } else if text.contains("à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾") or text.contains("à¤¡à¥‡à¤Ÿà¤¾à¤¬à¥‡à¤¸") or text.contains("à¤…à¤¨à¥à¤°à¥‹à¤§") {
    "hi"
  } else {
    "en"
  }
}

fn normalize_unicode(text : String) -> String {
  // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ä½¿ç”¨Unicodeè§„èŒƒåŒ–åº“
  text
}

fn remove_zero_width_chars(text : String) -> String {
  let mut result = ""
  let mut i = 0
  while i < text.length() {
    let char = text.char_at(i)
    if char != "\u200B" and char != "\u200C" and char != "\u200D" and char != "\uFEFF" {
      result = result + char
    }
    i = i + 1
  }
  result
}

fn format_number(number : Double, format : String) -> String {
  // ç®€åŒ–å®ç°ï¼Œå®é™…åº”æ ¹æ®åŒºåŸŸè®¾ç½®æ ¼å¼åŒ–
  number.to_string()
}

fn format_timestamp(timestamp : Int64, format : String, timezone : String) -> String {
  // ç®€åŒ–å®ç°ï¼Œå®é™…åº”æ ¹æ®åŒºåŸŸè®¾ç½®å’Œæ—¶åŒºæ ¼å¼åŒ–
  "2022-01-01 00:00:00"
}

fn detect_text_direction(text : String) -> String {
  // ç®€åŒ–å®ç°ï¼Œå®é™…åº”æ£€æµ‹æ–‡æœ¬æ–¹å‘
  if text.contains("Ù…Ø±Ø­Ø¨Ø§") or text.contains("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©") {
    "rtl"
  } else if text.contains("×¢×‘×¨×™×ª") {
    "rtl"
  } else {
    "ltr"
  }
}