// å›½é™…åŒ–æ”¯æŒæµ‹è¯• - éªŒè¯é¥æµ‹ç³»ç»Ÿçš„å›½é™…åŒ–åŠŸèƒ½

test "multilingual_error_messages" {
  // æµ‹è¯•å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  
  let error_codes = ["E001", "E002", "E003", "E004"]
  let english_messages = [
    "Connection timeout",
    "Invalid authentication credentials",
    "Rate limit exceeded",
    "Service unavailable"
  ]
  let chinese_messages = [
    "è¿æ¥è¶…æ—¶",
    "èº«ä»½éªŒè¯å‡­æ®æ— æ•ˆ",
    "è¶…è¿‡é€Ÿç‡é™åˆ¶",
    "æœåŠ¡ä¸å¯ç”¨"
  ]
  let japanese_messages = [
    "æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ",
    "ç„¡åŠ¹ãªèªè¨¼è³‡æ ¼æƒ…å ±",
    "ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’è¶…ãˆã¾ã—ãŸ",
    "ã‚µãƒ¼ãƒ“ã‚¹ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“"
  ]
  
  // éªŒè¯é”™è¯¯ä»£ç 
  assert_eq(error_codes.length(), 4)
  assert_eq(error_codes[0], "E001")
  assert_eq(error_codes[3], "E004")
  
  // éªŒè¯è‹±æ–‡æ¶ˆæ¯
  assert_eq(english_messages.length(), 4)
  assert_eq(english_messages[0], "Connection timeout")
  assert_eq(english_messages[2], "Rate limit exceeded")
  
  // éªŒè¯ä¸­æ–‡æ¶ˆæ¯
  assert_eq(chinese_messages.length(), 4)
  assert_eq(chinese_messages[0], "è¿æ¥è¶…æ—¶")
  assert_eq(chinese_messages[1], "èº«ä»½éªŒè¯å‡­æ®æ— æ•ˆ")
  
  // éªŒè¯æ—¥æ–‡æ¶ˆæ¯
  assert_eq(japanese_messages.length(), 4)
  assert_eq(japanese_messages[0], "æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
  assert_eq(japanese_messages[3], "ã‚µãƒ¼ãƒ“ã‚¹ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
  
  // åˆ›å»ºå¤šè¯­è¨€é”™è¯¯æŠ¥å‘Š
  let mut i = 0
  let multilingual_errors = []
  while i < error_codes.length() {
    let error_report = error_codes[i] + ":"
    error_report = error_report + " EN:" + english_messages[i] + ","
    error_report = error_report + " ZH:" + chinese_messages[i] + ","
    error_report = error_report + " JA:" + japanese_messages[i]
    multilingual_errors.push(error_report)
    i = i + 1
  }
  
  // éªŒè¯å¤šè¯­è¨€é”™è¯¯æŠ¥å‘Š
  assert_eq(multilingual_errors.length(), 4)
  assert_eq(multilingual_errors[0].contains("E001:"), true)
  assert_eq(multilingual_errors[0].contains("EN:Connection timeout"), true)
  assert_eq(multilingual_errors[0].contains("ZH:è¿æ¥è¶…æ—¶"), true)
  assert_eq(multilingual_errors[0].contains("JA:æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"), true)
}

test "timezone_handling" {
  // æµ‹è¯•æ—¶åŒºå¤„ç†
  
  let utc_timestamp = 1640995200L // 2022-01-01 00:00:00 UTC
  let timezones = ["UTC", "America/New_York", "Asia/Shanghai", "Europe/London", "Asia/Tokyo"]
  let expected_offsets = [0, -5, 8, 0, 9] // ç›¸å¯¹äºUTCçš„åç§»å°æ—¶æ•°
  
  // éªŒè¯æ—¶åŒºåˆ—è¡¨
  assert_eq(timezones.length(), 5)
  assert_eq(timezones[0], "UTC")
  assert_eq(timezones[2], "Asia/Shanghai")
  
  // éªŒè¯æ—¶åŒºåç§»
  assert_eq(expected_offsets.length(), 5)
  assert_eq(expected_offsets[0], 0) // UTC
  assert_eq(expected_offsets[1], -5) // EST (UTC-5)
  assert_eq(expected_offsets[4], 9) // JST (UTC+9)
  
  // åˆ›å»ºæ—¶åŒºè½¬æ¢æ•°æ®
  let mut timezone_conversions = []
  let mut i = 0
  while i < timezones.length() {
    let timezone = timezones[i]
    let offset = expected_offsets[i]
    let local_time = utc_timestamp + (offset * 3600L) // åç§»ç§’æ•°
    
    let conversion = timezone + ":" + local_time.to_string() + "(offset:" + offset.to_string() + "h)"
    timezone_conversions.push(conversion)
    i = i + 1
  }
  
  // éªŒè¯æ—¶åŒºè½¬æ¢ç»“æœ
  assert_eq(timezone_conversions.length(), 5)
  assert_eq(timezone_conversions[0].contains("UTC:1640995200(offset:0h)"), true)
  assert_eq(timezone_conversions[1].contains("America/New_York:1640993400(offset:-5h)"), true)
  assert_eq(timezone_conversions[2].contains("Asia/Shanghai:1640998800(offset:8h)"), true)
  
  // éªŒè¯æ—¶åŒºæ ¼å¼åŒ–
  let formatted_utc = "2022-01-01T00:00:00Z"
  let formatted_shanghai = "2022-01-01T08:00:00+08:00"
  let formatted_new_york = "2021-12-31T19:00:00-05:00"
  
  assert_eq(formatted_utc.has_suffix("Z"), true)
  assert_eq(formatted_shanghai.contains("+08:00"), true)
  assert_eq(formatted_new_york.contains("-05:00"), true)
}

test "character_encoding_support" {
  // æµ‹è¯•å­—ç¬¦ç¼–ç æ”¯æŒ
  
  let utf8_strings = [
    "Hello World", // è‹±æ–‡
    "ä½ å¥½ä¸–ç•Œ", // ä¸­æ–‡
    "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ", // æ—¥æ–‡
    "Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ Ğ¼Ğ¸Ñ€", // ä¿„æ–‡
    "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", // é˜¿æ‹‰ä¼¯æ–‡
    "ğŸŒğŸŒğŸŒ", // Emoji
    "CafÃ© rÃ©sumÃ© naÃ¯ve", // å¸¦é‡éŸ³ç¬¦å·
    "åŒ—äº¬/æ±äº¬/ĞœĞ¾ÑĞºĞ²Ğ°" // æ··åˆå­—ç¬¦
  ]
  
  // éªŒè¯UTF-8å­—ç¬¦ä¸²
  assert_eq(utf8_strings.length(), 8)
  assert_eq(utf8_strings[0], "Hello World")
  assert_eq(utf8_strings[1], "ä½ å¥½ä¸–ç•Œ")
  assert_eq(utf8_strings[2], "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ")
  
  // éªŒè¯å­—ç¬¦ä¸²é•¿åº¦å’Œå­—èŠ‚é•¿åº¦
  let mut i = 0
  while i < utf8_strings.length() {
    let str = utf8_strings[i]
    let char_length = str.length()
    let byte_length = str.to_bytes().length()
    
    // éªŒè¯å­—ç¬¦é•¿åº¦
    assert_eq(char_length > 0, true)
    
    // éªŒè¯å­—èŠ‚é•¿åº¦ï¼ˆå¯¹äºéASCIIå­—ç¬¦ï¼Œå­—èŠ‚é•¿åº¦é€šå¸¸å¤§äºå­—ç¬¦é•¿åº¦ï¼‰
    if i > 0 { // éè‹±æ–‡å­—ç¬¦
      assert_eq(byte_length >= char_length, true)
    }
    
    i = i + 1
  }
  
  // åˆ›å»ºå¤šè¯­è¨€é¥æµ‹æ•°æ®
  let mut multilingual_telemetry = []
  i = 0
  while i < utf8_strings.length() {
    let message = utf8_strings[i]
    let telemetry_data = "message=\"" + message + "\",lang=" + i.to_string()
    multilingual_telemetry.push(telemetry_data)
    i = i + 1
  }
  
  // éªŒè¯å¤šè¯­è¨€é¥æµ‹æ•°æ®
  assert_eq(multilingual_telemetry.length(), 8)
  assert_eq(multilingual_telemetry[0].contains("message=\"Hello World\""), true)
  assert_eq(multilingual_telemetry[1].contains("message=\"ä½ å¥½ä¸–ç•Œ\""), true)
  assert_eq(multilingual_telemetry[4].contains("message=\"Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…\""), true)
  assert_eq(multilingual_telemetry[5].contains("message=\"ğŸŒğŸŒğŸŒ\""), true)
}

test "locale_specific_formatting" {
  // æµ‹è¯•åŒºåŸŸç‰¹å®šæ ¼å¼åŒ–
  
  let locales = ["en-US", "zh-CN", "ja-JP", "de-DE", "fr-FR"]
  let number = 1234567.89
  let date = 1640995200L // 2022-01-01
  
  // éªŒè¯åŒºåŸŸè®¾ç½®
  assert_eq(locales.length(), 5)
  assert_eq(locales[0], "en-US")
  assert_eq(locales[1], "zh-CN")
  
  // æ¨¡æ‹ŸåŒºåŸŸç‰¹å®šæ•°å­—æ ¼å¼
  let number_formats = [
    "1,234,567.89", // en-US
    "1,234,567.89", // zh-CN
    "1,234,567.89", // ja-JP
    "1.234.567,89", // de-DE
    "1 234 567,89"  // fr-FR
  ]
  
  // éªŒè¯æ•°å­—æ ¼å¼
  assert_eq(number_formats.length(), 5)
  assert_eq(number_formats[0], "1,234,567.89")
  assert_eq(number_formats[3], "1.234.567,89")
  assert_eq(number_formats[4], "1 234 567,89")
  
  // æ¨¡æ‹ŸåŒºåŸŸç‰¹å®šæ—¥æœŸæ ¼å¼
  let date_formats = [
    "1/1/2022",      // en-US (MM/DD/YYYY)
    "2022/1/1",      // zh-CN (YYYY/MM/DD)
    "2022/01/01",    // ja-JP (YYYY/MM/DD)
    "1.1.2022",      // de-DE (DD.MM.YYYY)
    "01/01/2022"     // fr-FR (DD/MM/YYYY)
  ]
  
  // éªŒè¯æ—¥æœŸæ ¼å¼
  assert_eq(date_formats.length(), 5)
  assert_eq(date_formats[0], "1/1/2022")
  assert_eq(date_formats[1], "2022/1/1")
  assert_eq(date_formats[3], "1.1.2022")
  
  // åˆ›å»ºåŒºåŸŸç‰¹å®šé¥æµ‹æ•°æ®
  let mut locale_telemetry = []
  let mut i = 0
  while i < locales.length() {
    let locale = locales[i]
    let num_format = number_formats[i]
    let date_format = date_formats[i]
    
    let telemetry_data = "locale=" + locale + ","
    telemetry_data = telemetry_data + "number=" + num_format + ","
    telemetry_data = telemetry_data + "date=" + date_format
    
    locale_telemetry.push(telemetry_data)
    i = i + 1
  }
  
  // éªŒè¯åŒºåŸŸç‰¹å®šé¥æµ‹æ•°æ®
  assert_eq(locale_telemetry.length(), 5)
  assert_eq(locale_telemetry[0].contains("locale=en-US"), true)
  assert_eq(locale_telemetry[0].contains("number=1,234,567.89"), true)
  assert_eq(locale_telemetry[3].contains("locale=de-DE"), true)
  assert_eq(locale_telemetry[3].contains("date=1.1.2022"), true)
}

test "rtl_language_support" {
  // æµ‹è¯•ä»å³åˆ°å·¦è¯­è¨€æ”¯æŒ
  
  let rtl_languages = ["ar", "he", "fa", "ur"] // é˜¿æ‹‰ä¼¯è¯­ã€å¸Œä¼¯æ¥è¯­ã€æ³¢æ–¯è¯­ã€ä¹Œå°”éƒ½è¯­
  let rtl_texts = [
    "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", // é˜¿æ‹‰ä¼¯è¯­ï¼šHello World
    "×©×œ×•× ×¢×•×œ×",    // å¸Œä¼¯æ¥è¯­ï¼šHello World
    "Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§",     // æ³¢æ–¯è¯­ï¼šHello World
    "ÛÛŒÙ„Ùˆ Ø¯Ù†ÛŒØ§"      // ä¹Œå°”éƒ½è¯­ï¼šHello World
  ]
  
  // éªŒè¯RTLè¯­è¨€ä»£ç 
  assert_eq(rtl_languages.length(), 4)
  assert_eq(rtl_languages[0], "ar")
  assert_eq(rtl_languages[2], "fa")
  
  // éªŒè¯RTLæ–‡æœ¬
  assert_eq(rtl_texts.length(), 4)
  assert_eq(rtl_texts[0], "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…")
  assert_eq(rtl_texts[1], "×©×œ×•× ×¢×•×œ×")
  
  // åˆ›å»ºRTLé¥æµ‹æ•°æ®
  let mut rtl_telemetry = []
  let mut i = 0
  while i < rtl_languages.length() {
    let lang = rtl_languages[i]
    let text = rtl_texts[i]
    let direction = "rtl"
    
    let telemetry_data = "lang=" + lang + ","
    telemetry_data = telemetry_data + "direction=" + direction + ","
    telemetry_data = telemetry_data + "message=\"" + text + "\""
    
    rtl_telemetry.push(telemetry_data)
    i = i + 1
  }
  
  // éªŒè¯RTLé¥æµ‹æ•°æ®
  assert_eq(rtl_telemetry.length(), 4)
  assert_eq(rtl_telemetry[0].contains("lang=ar"), true)
  assert_eq(rtl_telemetry[0].contains("direction=rtl"), true)
  assert_eq(rtl_telemetry[0].contains("message=\"Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…\""), true)
  
  // éªŒè¯RTLæ–‡æœ¬æ–¹å‘æ ‡è®°
  let rtl_mark = "\u200F" // Right-to-Left Mark
  let ltr_mark = "\u200E" // Left-to-Right Mark
  
  let marked_texts = [
    rtl_mark + "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…" + rtl_mark,
    rtl_mark + "×©×œ×•× ×¢×•×œ×" + rtl_mark,
    rtl_mark + "Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§" + rtl_mark,
    rtl_mark + "ÛÛŒÙ„Ùˆ Ø¯Ù†ÛŒØ§" + rtl_mark
  ]
  
  // éªŒè¯æ–¹å‘æ ‡è®°
  assert_eq(marked_texts.length(), 4)
  assert_eq(marked_texts[0].has_prefix(rtl_mark), true)
  assert_eq(marked_texts[0].has_suffix(rtl_mark), true)
}

test "currency_and_number_localization" {
  // æµ‹è¯•è´§å¸å’Œæ•°å­—æœ¬åœ°åŒ–
  
  let currencies = ["USD", "CNY", "JPY", "EUR", "GBP"]
  let amounts = [1234.56, 1234.56, 1234.56, 1234.56, 1234.56]
  let currency_symbols = ["$", "Â¥", "Â¥", "â‚¬", "Â£"]
  
  // éªŒè¯è´§å¸ä»£ç 
  assert_eq(currencies.length(), 5)
  assert_eq(currencies[0], "USD")
  assert_eq(currencies[2], "JPY")
  
  // éªŒè¯è´§å¸ç¬¦å·
  assert_eq(currency_symbols.length(), 5)
  assert_eq(currency_symbols[0], "$")
  assert_eq(currency_symbols[1], "Â¥") // äººæ°‘å¸
  assert_eq(currency_symbols[2], "Â¥") // æ—¥å…ƒ
  assert_eq(currency_symbols[4], "Â£")
  
  // åˆ›å»ºæœ¬åœ°åŒ–è´§å¸æ ¼å¼
  let mut localized_currencies = []
  let mut i = 0
  while i < currencies.length() {
    let currency = currencies[i]
    let amount = amounts[i]
    let symbol = currency_symbols[i]
    
    let formatted_currency = symbol + amount.to_string() + " " + currency
    localized_currencies.push(formatted_currency)
    i = i + 1
  }
  
  // éªŒè¯æœ¬åœ°åŒ–è´§å¸æ ¼å¼
  assert_eq(localized_currencies.length(), 5)
  assert_eq(localized_currencies[0], "$1234.56 USD")
  assert_eq(localized_currencies[1], "Â¥1234.56 CNY")
  assert_eq(localized_currencies[3], "â‚¬1234.56 EUR")
  
  // åˆ›å»ºç™¾åˆ†æ¯”æœ¬åœ°åŒ–
  let percentages = [0.25, 0.50, 0.75, 1.00]
  let locales = ["en-US", "zh-CN", "ja-JP", "de-DE"]
  let percentage_formats = ["25%", "50%", "75%", "100%"]
  
  // éªŒè¯ç™¾åˆ†æ¯”æ ¼å¼
  assert_eq(percentages.length(), 4)
  assert_eq(percentage_formats.length(), 4)
  assert_eq(percentage_formats[0], "25%")
  assert_eq(percentage_formats[3], "100%")
  
  // åˆ›å»ºæœ¬åœ°åŒ–é¥æµ‹æŒ‡æ ‡
  let mut localized_metrics = []
  i = 0
  while i < currencies.length() {
    let metric_name = "revenue"
    let currency_amount = localized_currencies[i]
    let currency_code = currencies[i]
    
    let metric_data = metric_name + "{currency=\"" + currency_code + "\"} " + currency_amount
    localized_metrics.push(metric_data)
    i = i + 1
  }
  
  // éªŒè¯æœ¬åœ°åŒ–é¥æµ‹æŒ‡æ ‡
  assert_eq(localized_metrics.length(), 5)
  assert_eq(localized_metrics[0].contains("revenue{currency=\"USD\"} $1234.56 USD"), true)
  assert_eq(localized_metrics[2].contains("revenue{currency=\"JPY\"} Â¥1234.56 JPY"), true)
}