// Azimuth Telemetry - Serialization and Format Test
// æµ‹è¯•æ•°æ®åºåˆ—åŒ–å’Œæ ¼å¼åŒ–åœºæ™¯

test "attribute_value_serialization_scenarios" {
  // æµ‹è¯•å„ç§AttributeValueçš„åºåˆ—åŒ–åœºæ™¯
  
  // åŸºæœ¬ç±»å‹å±æ€§
  let basic_attrs = [
    ("string_value", common::AttributeValue::string("hello world")),
    ("int_value", common::AttributeValue::int(42)),
    ("float_value", common::AttributeValue::float(3.14159)),
    ("bool_value", common::AttributeValue::bool(true))
  ]
  
  // ç‰¹æ®Šå­—ç¬¦ä¸²å€¼
  let special_string_attrs = [
    ("empty_string", common::AttributeValue::string("")),
    ("unicode_string", common::AttributeValue::string("æµ‹è¯•ä¸­æ–‡ ğŸŒŸ")),
    ("json_string", common::AttributeValue::string("{\"key\": \"value\", \"array\": [1, 2, 3]}")),
    ("xml_string", common::AttributeValue::string("<root><item>test</item></root>")),
    ("base64_string", common::AttributeValue::string("SGVsbG8gV29ybGQ=")),
    ("url_string", common::AttributeValue::string("https://example.com/path?param=value&other=test")),
    ("newline_string", common::AttributeValue::string("line1\nline2\rline3")),
    ("tab_string", common::AttributeValue::string("col1\tcol2\tcol3")),
    ("quote_string", common::AttributeValue::string("He said \"Hello\" and left")),
    ("backslash_string", common::AttributeValue::string("path\\to\\file"))
  ]
  
  // æå€¼æ•°å­—å±æ€§
  let extreme_number_attrs = [
    ("max_int64", common::AttributeValue::int(9223372036854775807L)),
    ("min_int64", common::AttributeValue::int(-9223372036854775808L)),
    ("zero_int", common::AttributeValue::int(0)),
    ("negative_int", common::AttributeValue::int(-123456789)),
    ("max_double", common::AttributeValue::float(1.7976931348623157e+308)),
    ("min_double", common::AttributeValue::float(-1.7976931348623157e+308)),
    ("zero_double", common::AttributeValue::float(0.0)),
    ("infinity", common::AttributeValue::float(1.0/0.0)),
    ("negative_infinity", common::AttributeValue::float(-1.0/0.0)),
    ("nan", common::AttributeValue::float(0.0/0.0))
  ]
  
  // æ•°ç»„å±æ€§
  let array_attrs = [
    ("empty_string_array", common::AttributeValue::array_string([])),
    ("empty_int_array", common::AttributeValue::array_int([])),
    ("empty_float_array", common::AttributeValue::array_float([])),
    ("empty_bool_array", common::AttributeValue::array_bool([])),
    ("single_string_array", common::AttributeValue::array_string(["single"])),
    ("single_int_array", common::AttributeValue::array_int([42])),
    ("mixed_string_array", common::AttributeValue::array_string(["a", "b", "c", "d", "e"])),
    ("large_int_array", common::AttributeValue::array_int([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])),
    ("float_precision_array", common::AttributeValue::array_float([0.1, 0.01, 0.001, 0.0001])),
    ("bool_mixed_array", common::AttributeValue::array_bool([true, false, true, true, false]))
  ]
  
  // éªŒè¯å±æ€§æ•°é‡
  assert_eq(basic_attrs.length(), 4)
  assert_eq(special_string_attrs.length(), 10)
  assert_eq(extreme_number_attrs.length(), 10)
  assert_eq(array_attrs.length(), 10)
  
  // éªŒè¯ç‰¹å®šå±æ€§å€¼
  assert_eq(basic_attrs[0], ("string_value", common::AttributeValue::string("hello world")))
  assert_eq(special_string_attrs[2], ("json_string", common::AttributeValue::string("{\"key\": \"value\", \"array\": [1, 2, 3]}")))
  assert_eq(extreme_number_attrs[0], ("max_int64", common::AttributeValue::int(9223372036854775807L)))
  assert_eq(array_attrs[7], ("large_int_array", common::AttributeValue::array_int([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])))
}

test "span_context_format_validation" {
  // æµ‹è¯•SpanContextæ ¼å¼éªŒè¯
  
  // æœ‰æ•ˆçš„trace_idå’Œspan_idæ ¼å¼ï¼ˆ16å­—èŠ‚å’Œ8å­—èŠ‚çš„åå…­è¿›åˆ¶è¡¨ç¤ºï¼‰
  let valid_trace_id = "0af7651916cd43dd8448eb211c80319c"
  let valid_span_id = "b7ad6b7169203331"
  
  // åˆ›å»ºæœ‰æ•ˆçš„SpanContext
  let valid_trace_bytes = Array::make(16, 0_byte)  // åœ¨å®é™…å®ç°ä¸­åº”è¯¥è§£æåå…­è¿›åˆ¶å­—ç¬¦ä¸²
  let valid_span_bytes = Array::make(8, 0_byte)   // åœ¨å®é™…å®ç°ä¸­åº”è¯¥è§£æåå…­è¿›åˆ¶å­—ç¬¦ä¸²
  
  let valid_span_context = trace::SpanContext::{
    trace_id: valid_trace_bytes,
    span_id: valid_span_bytes,
    trace_flags: 1_byte,
    trace_state: "rojo=00f067aa0ba902b7,congo=t61rcWkgMzE"
  }
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„trace_flags
  let flag_scenarios = [
    (0_byte, "no flags"),
    (1_byte, "sampled"),
    (2_byte, "custom flag 1"),
    (4_byte, "custom flag 2"),
    (8_byte, "custom flag 3"),
    (255_byte, "all flags set")
  ]
  
  // åˆ›å»ºä¸åŒæ ‡å¿—çš„SpanContext
  let mut contexts = [] : Array[trace::SpanContext]
  let mut i = 0
  while i < flag_scenarios.length() {
    let (flag, description) = flag_scenarios[i]
    let context = trace::SpanContext::{
      trace_id: valid_trace_bytes,
      span_id: valid_span_bytes,
      trace_flags: flag,
      trace_state: description
    }
    contexts.push(context)
    i = i + 1
  }
  
  // éªŒè¯ä¸åŒçš„trace_flagså€¼
  assert_eq(contexts[0].trace_flags, 0_byte)
  assert_eq(contexts[1].trace_flags, 1_byte)
  assert_eq(contexts[6].trace_flags, 255_byte)
  
  // æµ‹è¯•trace_stateæ ¼å¼
  let trace_state_cases = [
    "",  // ç©ºtrace_state
    "key=value",  // ç®€å•é”®å€¼å¯¹
    "key1=value1,key2=value2",  // å¤šä¸ªé”®å€¼å¯¹
    "complex.key=complex.value,with.special=chars",  // å¤æ‚é”®å€¼å¯¹
    "vendor1=opaque_value,vendor2=another_value"  // ä¾›åº”å•†ç‰¹å®šå€¼
  ]
  
  // åˆ›å»ºä¸åŒtrace_stateçš„SpanContext
  i = 0
  while i < trace_state_cases.length() {
    let trace_state = trace_state_cases[i]
    let context = trace::SpanContext::{
      trace_id: valid_trace_bytes,
      span_id: valid_span_bytes,
      trace_flags: 1_byte,
      trace_state: trace_state
    }
    assert_eq(context.trace_state, trace_state)
    i = i + 1
  }
}

test "log_record_format_standards" {
  // æµ‹è¯•LogRecordæ ¼å¼æ ‡å‡†
  
  // åˆ›å»ºç¬¦åˆä¸åŒä¸¥é‡æ€§çº§åˆ«çš„LogRecord
  let severity_levels = [
    (logs::Trace, "TRACE", "Detailed trace information"),
    (logs::Debug, "DEBUG", "Debug information for developers"),
    (logs::Info, "INFO", "General information messages"),
    (logs::Warn, "WARN", "Warning messages"),
    (logs::Error, "ERROR", "Error messages"),
    (logs::Fatal, "FATAL", "Critical error messages")
  ]
  
  // ä¸ºæ¯ä¸ªä¸¥é‡æ€§çº§åˆ«åˆ›å»ºLogRecord
  let mut i = 0
  while i < severity_levels.length() {
    let (severity_enum, severity_string, message) = severity_levels[i]
    
    let log_record = logs::LogRecord::builder()
      .timestamp(1640995200000000000L + i.to_int64() * 1000000L)
      .severity(severity_enum)
      .severity_text(severity_string)
      .body(message)
      .with_attribute("severity.level", common::AttributeValue::int(i))
      .with_attribute("log.source", common::AttributeValue::string("test_module"))
      |> build
    
    // éªŒè¯LogRecordæ ¼å¼
    assert_eq(log_record.severity_number, severity_enum)
    assert_eq(log_record.severity_text, Some(severity_string))
    assert_eq(log_record.body, Some(message))
    assert_eq(log_record.attributes.length(), 2)
    
    i = i + 1
  }
  
  // æµ‹è¯•æ—¶é—´æˆ³æ ¼å¼
  let timestamp_cases = [
    0L,  // Unixçºªå…ƒ
    1640995200000000000L,  // 2022-01-01 00:00:00 UTC
    -1640995200000000000L,  // è´Ÿæ—¶é—´æˆ³
    9223372036854775807L,  // æœ€å¤§Int64å€¼
    -9223372036854775808L   // æœ€å°Int64å€¼
  ]
  
  i = 0
  while i < timestamp_cases.length() {
    let timestamp = timestamp_cases[i]
    let time_record = logs::LogRecord::builder()
      .timestamp(timestamp)
      .severity(logs::Info)
      .body("Timestamp test")
      |> build
    
    assert_eq(time_record.timestamp_unix_nanos, timestamp)
    i = i + 1
  }
}

test "carrier_header_format_compliance" {
  // æµ‹è¯•Carrierå¤´éƒ¨æ ¼å¼åˆè§„æ€§
  
  // W3C TraceContextå¤´éƒ¨æ ¼å¼æµ‹è¯•
  let valid_trace_parents = [
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // æ ‡å‡†æ ¼å¼
    "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01",  // å¦ä¸€ä¸ªæœ‰æ•ˆç¤ºä¾‹
    "00-00000000000000000000000000000000-0000000000000000-00",   // å…¨é›¶å€¼
    "ff-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"   // æœªæ¥ç‰ˆæœ¬
  ]
  
  let trace_state_cases = [
    "",  // ç©ºtracestate
    "rojo=00f067aa0ba902b7",  // å•ä¸ªä¾›åº”å•†
    "rojo=00f067aa0ba902b7,congo=t61rcWkgMzE",  // å¤šä¸ªä¾›åº”å•†
    "vendor1=opaqueValue,vendor2=anotherValue,vendor3=thirdValue"  // å¤šä¸ªå¤æ‚å€¼
  ]
  
  // Baggageå¤´éƒ¨æ ¼å¼æµ‹è¯•
  let valid_baggages = [
    "",  // ç©ºbaggage
    "key=value",  // ç®€å•é”®å€¼å¯¹
    "key1=value1,key2=value2",  // å¤šä¸ªé”®å€¼å¯¹
    "keywith%20space=valuewith%20space",  // URLç¼–ç 
    "key=value;param1;param2",  // å¸¦å‚æ•°
    "complex%2Bkey=complex%2Bvalue,simple=simple"  // æ··åˆå¤æ‚å’Œç®€å•
  ]
  
  // åˆ›å»ºåŒ…å«ä¸åŒå¤´ä¿¡æ¯çš„carrier
  let mut i = 0
  while i < valid_trace_parents.length() {
    let trace_parent = valid_trace_parents[i]
    let trace_state = trace_state_cases[i % trace_state_cases.length()]
    let baggage = valid_baggages[i % valid_baggages.length()]
    
    let carrier_data = [
      ("traceparent", trace_parent),
      ("tracestate", trace_state),
      ("baggage", baggage),
      ("x-request-id", "req-" + i.to_string()),
      ("x-correlation-id", "corr-" + i.to_string())
    ]
    
    let carrier = propagation::MapCarrier::from_map(carrier_data)
    
    // éªŒè¯carrieråŒ…å«é¢„æœŸçš„é”®
    let keys = carrier.keys()
    assert_eq(keys.contains("traceparent"), true)
    assert_eq(keys.contains("tracestate"), true)
    assert_eq(keys.contains("baggage"), true)
    assert_eq(keys.contains("x-request-id"), true)
    assert_eq(keys.contains("x-correlation-id"), true)
    
    // éªŒè¯ç‰¹å®šçš„å€¼
    assert_eq(carrier.get("traceparent"), Some(trace_parent))
    assert_eq(carrier.get("tracestate"), if trace_state == "" { None } else { Some(trace_state) })
    assert_eq(carrier.get("baggage"), if baggage == "" { None } else { Some(baggage) })
    
    i = i + 1
  }
}

test "resource_and_instrumentation_format_standards" {
  // æµ‹è¯•Resourceå’ŒInstrumentationScopeæ ¼å¼æ ‡å‡†
  
  // æ ‡å‡†Resourceå±æ€§
  let standard_resource_attrs = [
    ("service.name", common::AttributeValue::string("my-service")),
    ("service.version", common::AttributeValue::string("1.0.0")),
    ("service.instance.id", common::AttributeValue::string("instance-123")),
    ("telemetry.sdk.name", common::AttributeValue::string("azimuth")),
    ("telemetry.sdk.version", common::AttributeValue::string("0.1.0")),
    ("telemetry.sdk.language", common::AttributeValue::string("moonbit")),
    ("host.name", common::AttributeValue::string("host-001")),
    ("host.arch", common::AttributeValue::string("amd64")),
    ("os.type", common::AttributeValue::string("linux")),
    ("deployment.environment", common::AttributeValue::string("production"))
  ]
  
  // åˆ›å»ºç¬¦åˆæ ‡å‡†çš„Resource
  let standard_resource = common::Resource::{
    service_name: "my-service",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: standard_resource_attrs
  }
  
  // éªŒè¯Resourceæ ¼å¼
  assert_eq(standard_resource.service_name, "my-service")
  assert_eq(standard_resource.service_version, Some("1.0.0"))
  assert_eq(standard_resource.telemetry_sdk_name, "azimuth")
  assert_eq(standard_resource.telemetry_sdk_version, "0.1.0")
  assert_eq(standard_resource.attributes.length(), 10)
  
  // æ ‡å‡†InstrumentationScopeå±æ€§
  let standard_scope = common::InstrumentationScope::{
    name: "my-instrumentation",
    version: Some("1.2.3"),
    schema_url: Some("https://example.com/schema/v1")
  }
  
  // éªŒè¯InstrumentationScopeæ ¼å¼
  assert_eq(standard_scope.name, "my-instrumentation")
  assert_eq(standard_scope.version, Some("1.2.3"))
  assert_eq(standard_scope.schema_url, Some("https://example.com/schema/v1"))
  
  // æµ‹è¯•å„ç§schema URLæ ¼å¼
  let schema_urls = [
    "https://opentelemetry.io/schemas/v1.20.0",
    "http://example.com/custom/schema",
    "https://github.com/company/telemetry-schema/v2.1",
    "https://api.example.org/schemas/telemetry/v1.0.0"
  ]
  
  let mut i = 0
  while i < schema_urls.length() {
    let scope_with_schema = common::InstrumentationScope::{
      name: "instrumentation-" + i.to_string(),
      version: Some("1.0.0"),
      schema_url: Some(schema_urls[i])
    }
    
    assert_eq(scope_with_schema.schema_url, Some(schema_urls[i]))
    i = i + 1
  }
}