// å›½é™…åŒ–æ•°æ®æ ¼å¼æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿåœ¨ä¸åŒè¯­è¨€å’Œåœ°åŒºç¯å¢ƒä¸‹çš„æ•°æ®æ ¼å¼å¤„ç†

test "telemetry_date_format_localization" {
  // æµ‹è¯•æ—¥æœŸæ ¼å¼æœ¬åœ°åŒ–
  
  let utc_timestamp = 1640995200L  // 2022-01-01 00:00:00 UTC
  
  // ä¸åŒåœ°åŒºçš„æ—¥æœŸæ ¼å¼
  let locale_formats = [
    ("en_US", "01/01/2022 12:00:00 AM"),    // ç¾å›½è‹±è¯­
    ("en_GB", "01/01/2022 00:00:00"),       // è‹±å›½è‹±è¯­
    ("zh_CN", "2022å¹´01æœˆ01æ—¥ 00:00:00"),   // ä¸­å›½ä¸­æ–‡
    ("ja_JP", "2022å¹´01æœˆ01æ—¥ 00æ™‚00åˆ†00ç§’"), // æ—¥æœ¬æ—¥è¯­
    ("de_DE", "01.01.2022 00:00:00"),       // å¾·å›½å¾·è¯­
    ("fr_FR", "01/01/2022 00:00:00"),       // æ³•å›½æ³•è¯­
    ("ru_RU", "01.01.2022 00:00:00"),       // ä¿„ç½—æ–¯ä¿„è¯­
    ("ar_SA", "Ù Ù¡/Ù Ù¡/Ù¢Ù Ù¢Ù¢ Ù Ù :Ù Ù :Ù Ù ")        // æ²™ç‰¹é˜¿æ‹‰ä¼¯è¯­
  ]
  
  // éªŒè¯ä¸åŒåœ°åŒºçš„æ—¥æœŸæ ¼å¼
  let mut i = 0
  while i < locale_formats.length() {
    let (locale, format) = locale_formats[i]
    
    // éªŒè¯æ ¼å¼åŒ…å«å…³é”®ç»„ä»¶
    assert_eq(format.contains("2022") || format.contains("Ù¢Ù Ù¢Ù¢"), true)  // åŒ…å«å¹´ä»½
    assert_eq(format.contains("01") || format.contains("Ù Ù¡"), true)     // åŒ…å«æœˆä»½å’Œæ—¥æœŸ
    assert_eq(format.contains("00") || format.contains("Ù Ù "), true)     // åŒ…å«æ—¶é—´
    
    // éªŒè¯åœ°åŒºç‰¹å®šæ ¼å¼ç‰¹å¾
    if locale == "en_US" {
      assert_eq(format.contains("AM"), true)  // ç¾å›½æ ¼å¼åŒ…å«AM/PM
    } else if locale == "zh_CN" {
      assert_eq(format.contains("å¹´"), true)  // ä¸­æ–‡æ ¼å¼åŒ…å«å¹´æœˆæ—¥
    } else if locale == "ja_JP" {
      assert_eq(format.contains("æ™‚"), true)  // æ—¥è¯­æ ¼å¼åŒ…å«æ™‚åˆ†ç§’
    } else if locale == "de_DE" {
      assert_eq(format.contains("."), true)   // å¾·è¯­æ ¼å¼ä½¿ç”¨ç‚¹åˆ†éš”
    } else if locale == "ar_SA" {
      assert_eq(format.contains("Ù "), true)   // é˜¿æ‹‰ä¼¯è¯­ä½¿ç”¨é˜¿æ‹‰ä¼¯æ•°å­—
    }
    
    i = i + 1
  }
}

test "telemetry_number_format_localization" {
  // æµ‹è¯•æ•°å­—æ ¼å¼æœ¬åœ°åŒ–
  
  let test_number = 1234.5678
  
  // ä¸åŒåœ°åŒºçš„æ•°å­—æ ¼å¼
  let locale_numbers = [
    ("en_US", "1,234.5678"),     // ç¾å›½è‹±è¯­ï¼šé€—å·åˆ†éš”æ•´æ•°éƒ¨åˆ†ï¼Œç‚¹åˆ†éš”å°æ•°
    ("en_GB", "1,234.5678"),     // è‹±å›½è‹±è¯­ï¼šåŒç¾å›½æ ¼å¼
    ("de_DE", "1.234,5678"),     // å¾·å›½å¾·è¯­ï¼šç‚¹åˆ†éš”æ•´æ•°éƒ¨åˆ†ï¼Œé€—å·åˆ†éš”å°æ•°
    ("fr_FR", "1 234,5678"),     // æ³•å›½æ³•è¯­ï¼šç©ºæ ¼åˆ†éš”æ•´æ•°éƒ¨åˆ†ï¼Œé€—å·åˆ†éš”å°æ•°
    ("zh_CN", "1,234.5678"),     // ä¸­å›½ä¸­æ–‡ï¼šä½¿ç”¨è¥¿å¼æ ¼å¼
    ("ja_JP", "1,234.5678"),     // æ—¥æœ¬æ—¥è¯­ï¼šä½¿ç”¨è¥¿å¼æ ¼å¼
    ("ru_RU", "1 234,5678"),     // ä¿„ç½—æ–¯ä¿„è¯­ï¼šç©ºæ ¼åˆ†éš”æ•´æ•°éƒ¨åˆ†ï¼Œé€—å·åˆ†éš”å°æ•°
    ("ar_SA", "Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦Ù§Ù¨")       // æ²™ç‰¹é˜¿æ‹‰ä¼¯è¯­ï¼šé˜¿æ‹‰ä¼¯æ•°å­—å’Œåˆ†éš”ç¬¦
  ]
  
  // éªŒè¯æ•°å­—æ ¼å¼æœ¬åœ°åŒ–
  let mut i = 0
  while i < locale_numbers.length() {
    let (locale, format) = locale_numbers[i]
    
    // éªŒè¯æ•°å­—å€¼ä¿æŒä¸å˜
    assert_eq(format.contains("1234") || format.contains("Ù¡Ù¢Ù£Ù¤"), true)  // åŒ…å«ä¸»è¦æ•°å­—
    assert_eq(format.contains("5678") || format.contains("Ù¥Ù¦Ù§Ù¨"), true)  // åŒ…å«å°æ•°éƒ¨åˆ†
    
    // éªŒè¯åœ°åŒºç‰¹å®šæ ¼å¼
    if locale == "en_US" || locale == "en_GB" || locale == "zh_CN" || locale == "ja_JP" {
      assert_eq(format.contains(","), true)   // ä½¿ç”¨é€—å·ä½œä¸ºåƒä½åˆ†éš”ç¬¦
      assert_eq(format.contains("."), true)   // ä½¿ç”¨ç‚¹ä½œä¸ºå°æ•°åˆ†éš”ç¬¦
    } else if locale == "de_DE" {
      assert_eq(format.contains("."), true)   // ä½¿ç”¨ç‚¹ä½œä¸ºåƒä½åˆ†éš”ç¬¦
      assert_eq(format.contains(","), true)   // ä½¿ç”¨é€—å·ä½œä¸ºå°æ•°åˆ†éš”ç¬¦
    } else if locale == "fr_FR" || locale == "ru_RU" {
      assert_eq(format.contains(" "), true)   // ä½¿ç”¨ç©ºæ ¼ä½œä¸ºåƒä½åˆ†éš”ç¬¦
      assert_eq(format.contains(","), true)   // ä½¿ç”¨é€—å·ä½œä¸ºå°æ•°åˆ†éš”ç¬¦
    } else if locale == "ar_SA" {
      assert_eq(format.contains("Ù¬"), true)   // ä½¿ç”¨é˜¿æ‹‰ä¼¯åƒä½åˆ†éš”ç¬¦
      assert_eq(format.contains("Ù«"), true)   // ä½¿ç”¨é˜¿æ‹‰ä¼¯å°æ•°åˆ†éš”ç¬¦
    }
    
    i = i + 1
  }
}

test "telemetry_currency_format_localization" {
  // æµ‹è¯•è´§å¸æ ¼å¼æœ¬åœ°åŒ–
  
  let amount = 1234.56
  let currency_code = "USD"
  
  // ä¸åŒåœ°åŒºçš„è´§å¸æ ¼å¼
  let locale_currencies = [
    ("en_US", "$1,234.56"),           // ç¾å›½è‹±è¯­
    ("en_GB", "Â£1,234.56"),           // è‹±å›½è‹±è¯­
    ("ja_JP", "Â¥1,235"),              // æ—¥æœ¬æ—¥è¯­ï¼ˆæ— å°æ•°ï¼‰
    ("zh_CN", "Â¥1,234.56"),           // ä¸­å›½ä¸­æ–‡
    ("de_DE", "1.234,56 â‚¬"),          // å¾·å›½å¾·è¯­ï¼ˆè´§å¸ç¬¦å·åœ¨åï¼‰
    ("fr_FR", "1 234,56 â‚¬"),          // æ³•å›½æ³•è¯­
    ("ru_RU", "1 234,56 â‚½"),          // ä¿„ç½—æ–¯ä¿„è¯­
    ("ar_SA", "Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦ Ø±.Ø³")         // æ²™ç‰¹é˜¿æ‹‰ä¼¯è¯­
  ]
  
  // éªŒè¯è´§å¸æ ¼å¼æœ¬åœ°åŒ–
  let mut i = 0
  while i < locale_currencies.length() {
    let (locale, format) = locale_currencies[i]
    
    // éªŒè¯åŒ…å«è´§å¸ç¬¦å·
    let currency_symbols = ["$", "Â£", "Â¥", "â‚¬", "â‚½", "Ø±.Ø³"]
    let has_currency_symbol = false
    let mut j = 0
    
    while j < currency_symbols.length() {
      if format.contains(currency_symbols[j]) {
        has_currency_symbol = true
        break
      }
      j = j + 1
    }
    
    assert_eq(has_currency_symbol, true)  // æ¯ç§æ ¼å¼éƒ½åŒ…å«è´§å¸ç¬¦å·
    
    // éªŒè¯åŒ…å«æ•°å­—å€¼
    assert_eq(format.contains("1234") || format.contains("Ù¡Ù¢Ù£Ù¤"), true)
    
    // éªŒè¯åœ°åŒºç‰¹å®šçš„è´§å¸ä½ç½®
    if locale == "de_DE" || locale == "fr_FR" || locale == "ru_RU" {
      assert_eq(format.has_suffix(" â‚¬") || format.has_suffix(" â‚½"), true)  // è´§å¸ç¬¦å·åœ¨å
    } else if locale == "en_US" || locale == "en_GB" || locale == "zh_CN" {
      assert_eq(format.has_prefix("$") || format.has_prefix("Â£") || format.has_prefix("Â¥"), true)  // è´§å¸ç¬¦å·åœ¨å‰
    }
    
    i = i + 1
  }
}

test "telemetry_timezone_handling" {
  // æµ‹è¯•æ—¶åŒºå¤„ç†
  
  let base_timestamp = 1640995200L  // 2022-01-01 00:00:00 UTC
  
  // ä¸åŒæ—¶åŒºçš„æ—¶é—´å’Œæ ¼å¼
  let timezone_formats = [
    ("UTC", "2022-01-01 00:00:00 UTC"),           // UTC
    ("America/New_York", "2021-12-31 19:00:00 EST"), // çº½çº¦ï¼ˆUTC-5ï¼‰
    ("America/Los_Angeles", "2021-12-31 16:00:00 PST"), // æ´›æ‰çŸ¶ï¼ˆUTC-8ï¼‰
    ("Europe/London", "2022-01-01 00:00:00 GMT"),  // ä¼¦æ•¦ï¼ˆUTC+0ï¼‰
    ("Europe/Paris", "2022-01-01 01:00:00 CET"),   // å·´é»ï¼ˆUTC+1ï¼‰
    ("Asia/Tokyo", "2022-01-01 09:00:00 JST"),     // ä¸œäº¬ï¼ˆUTC+9ï¼‰
    ("Asia/Shanghai", "2022-01-01 08:00:00 CST"),  // ä¸Šæµ·ï¼ˆUTC+8ï¼‰
    ("Australia/Sydney", "2022-01-01 11:00:00 AEDT") // æ‚‰å°¼ï¼ˆUTC+11ï¼‰
  ]
  
  // éªŒè¯æ—¶åŒºè½¬æ¢
  let mut i = 0
  while i < timezone_formats.length() {
    let (timezone, format) = timezone_formats[i]
    
    // éªŒè¯æ ¼å¼åŒ…å«æ—¥æœŸå’Œæ—¶é—´
    assert_eq(format.contains("2022") || format.contains("2021"), true)  // åŒ…å«å¹´ä»½
    assert_eq(format.contains("01") && format.contains("01"), true)      // åŒ…å«æœˆæ—¥
    assert_eq(format.contains("00") || format.contains("19") || format.contains("16") || 
              format.contains("01") || format.contains("09") || format.contains("08") || 
              format.contains("11"), true)  // åŒ…å«å°æ—¶
    
    // éªŒè¯æ—¶åŒºç¼©å†™
    let timezone_abbrevs = ["UTC", "EST", "PST", "GMT", "CET", "JST", "CST", "AEDT"]
    let has_timezone_abbrev = false
    let mut j = 0
    
    while j < timezone_abbrevs.length() {
      if format.has_suffix(timezone_abbrevs[j]) {
        has_timezone_abbrev = true
        break
      }
      j = j + 1
    }
    
    assert_eq(has_timezone_abbrev, true)
    
    i = i + 1
  }
}

test "telemetry_text_encoding_handling" {
  // æµ‹è¯•æ–‡æœ¬ç¼–ç å¤„ç†
  
  let unicode_texts = [
    ("English", "Hello World"),
    ("Chinese", "ä½ å¥½ä¸–ç•Œ"),
    ("Japanese", "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ"),
    ("Korean", "ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„"),
    ("Arabic", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"),
    ("Russian", "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€"),
    ("German", "Hallo Welt"),
    ("French", "Bonjour le monde"),
    ("Spanish", "Hola Mundo"),
    ("Emoji", "ğŸŒğŸ“ŠğŸ“ˆ")
  ]
  
  // éªŒè¯Unicodeæ–‡æœ¬å¤„ç†
  let mut i = 0
  while i < unicode_texts.length() {
    let (language, text) = unicode_texts[i]
    
    // éªŒè¯æ–‡æœ¬é•¿åº¦
    assert_eq(text.length() > 0, true)
    
    // éªŒè¯æ–‡æœ¬ç¼–ç ç‰¹æ€§
    if language == "Chinese" {
      assert_eq(text.contains("ä½ "), true)  // åŒ…å«ä¸­æ–‡å­—ç¬¦
    } else if language == "Japanese" {
      assert_eq(text.contains("ã“"), true)  // åŒ…å«æ—¥æ–‡å­—ç¬¦
    } else if language == "Korean" {
      assert_eq(text.contains("ì•ˆ"), true)  // åŒ…å«éŸ©æ–‡å­—ç¬¦
    } else if language == "Arabic" {
      assert_eq(text.contains("Ù…"), true)   // åŒ…å«é˜¿æ‹‰ä¼¯æ–‡å­—ç¬¦
    } else if language == "Russian" {
      assert_eq(text.contains("ĞŸ"), true)  // åŒ…å«è¥¿é‡Œå°”å­—ç¬¦
    } else if language == "Emoji" {
      assert_eq(text.contains("ğŸŒ"), true)  // åŒ…å«Emojiå­—ç¬¦
    }
    
    // éªŒè¯æ–‡æœ¬å¯ä»¥æ­£ç¡®æ‹¼æ¥
    let concatenated = language + ": " + text
    assert_eq(concatenated.contains(language), true)
    assert_eq(concatenated.contains(text), true)
    
    i = i + 1
  }
}

test "telemetry_measurement_units_localization" {
  // æµ‹è¯•åº¦é‡å•ä½æœ¬åœ°åŒ–
  
  let measurements = [
    ("length", 1.0, [
      ("en_US", "1.0 m"),           // ç±³
      ("en_GB", "1.0 m"),           
      ("en_US_imperial", "3.28 ft"), // è‹±å°º
      ("zh_CN", "1.0 ç±³"),          // ä¸­æ–‡ç±³
      ("ja_JP", "1.0 ãƒ¡ãƒ¼ãƒˆãƒ«")      // æ—¥æ–‡ç±³
    ]),
    ("weight", 70.5, [
      ("en_US", "70.5 kg"),         // åƒå…‹
      ("en_US_imperial", "155.4 lbs"), // ç£…
      ("zh_CN", "70.5 å…¬æ–¤"),        // ä¸­æ–‡åƒå…‹
      ("ja_JP", "70.5 ã‚­ãƒ­ã‚°ãƒ©ãƒ ")   // æ—¥æ–‡åƒå…‹
    ]),
    ("temperature", 25.0, [
      ("en_US", "77.0 Â°F"),         // åæ°åº¦
      ("en_GB", "25.0 Â°C"),         // æ‘„æ°åº¦
      ("zh_CN", "25.0 æ‘„æ°åº¦"),      // ä¸­æ–‡æ‘„æ°åº¦
      ("ja_JP", "25.0 åº¦")           // æ—¥æ–‡åº¦
    ])
  ]
  
  // éªŒè¯åº¦é‡å•ä½æœ¬åœ°åŒ–
  let mut i = 0
  while i < measurements.length() {
    let (measurement_type, value, locale_formats) = measurements[i]
    
    let mut j = 0
    while j < locale_formats.length() {
      let (locale, format) = locale_formats[j]
      
      // éªŒè¯åŒ…å«æ•°å€¼
      assert_eq(format.contains(value.to_string().split(".")[0]), true)
      
      // éªŒè¯åŒ…å«å•ä½
      if measurement_type == "length" {
        assert_eq(format.contains("m") || format.contains("ft") || 
                  format.contains("ç±³") || format.contains("ãƒ¡ãƒ¼ãƒˆãƒ«"), true)
      } else if measurement_type == "weight" {
        assert_eq(format.contains("kg") || format.contains("lbs") || 
                  format.contains("å…¬æ–¤") || format.contains("ã‚­ãƒ­ã‚°ãƒ©ãƒ "), true)
      } else if measurement_type == "temperature" {
        assert_eq(format.contains("Â°F") || format.contains("Â°C") || 
                  format.contains("æ‘„æ°åº¦") || format.contains("åº¦"), true)
      }
      
      j = j + 1
    }
    
    i = i + 1
  }
}

test "telemetry_error_message_localization" {
  // æµ‹è¯•é”™è¯¯ä¿¡æ¯æœ¬åœ°åŒ–
  
  let error_codes = [
    ("CONNECTION_TIMEOUT", [
      ("en_US", "Connection timeout after 30 seconds"),
      ("zh_CN", "è¿æ¥è¶…æ—¶ï¼Œå·²ç­‰å¾…30ç§’"),
      ("ja_JP", "30ç§’å¾Œã«æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ"),
      ("de_DE", "Verbindungs-Timeout nach 30 Sekunden"),
      ("fr_FR", "DÃ©lai de connexion dÃ©passÃ© aprÃ¨s 30 secondes")
    ]),
    ("INVALID_DATA_FORMAT", [
      ("en_US", "Invalid data format: expected JSON"),
      ("zh_CN", "æ— æ•ˆçš„æ•°æ®æ ¼å¼ï¼šæœŸæœ›JSONæ ¼å¼"),
      ("ja_JP", "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿å½¢å¼ï¼šJSONå½¢å¼ãŒå¿…è¦ã§ã™"),
      ("de_DE", "UngÃ¼ltiges Datenformat: JSON erwartet"),
      ("fr_FR", "Format de donnÃ©es invalide: JSON attendu")
    ]),
    ("RATE_LIMIT_EXCEEDED", [
      ("en_US", "Rate limit exceeded: 1000 requests per hour"),
      ("zh_CN", "è¶…è¿‡é€Ÿç‡é™åˆ¶ï¼šæ¯å°æ—¶1000æ¬¡è¯·æ±‚"),
      ("ja_JP", "ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’è¶…éã—ã¾ã—ãŸï¼š1æ™‚é–“ã‚ãŸã‚Š1000ãƒªã‚¯ã‚¨ã‚¹ãƒˆ"),
      ("de_DE", "Rate-Limit Ã¼berschritten: 1000 Anfragen pro Stunde"),
      ("fr_FR", "Limite de dÃ©bit dÃ©passÃ©e: 1000 requÃªtes par heure")
    ])
  ]
  
  // éªŒè¯é”™è¯¯ä¿¡æ¯æœ¬åœ°åŒ–
  let mut i = 0
  while i < error_codes.length() {
    let (error_code, locale_messages) = error_codes[i]
    
    let mut j = 0
    while j < locale_messages.length() {
      let (locale, message) = locale_messages[j]
      
      // éªŒè¯é”™è¯¯ä¿¡æ¯ä¸ä¸ºç©º
      assert_eq(message.length() > 0, true)
      
      // éªŒè¯é”™è¯¯ä¿¡æ¯åŒ…å«ç›¸å…³å…³é”®è¯
      if error_code == "CONNECTION_TIMEOUT" {
        let timeout_keywords = ["timeout", "è¶…æ—¶", "ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ", "Timeout", "dÃ©lai"]
        let has_timeout_keyword = timeout_keywords.exists(fn(keyword) { message.contains(keyword) })
        assert_eq(has_timeout_keyword, true)
      } else if error_code == "INVALID_DATA_FORMAT" {
        let format_keywords = ["format", "æ ¼å¼", "å½¢å¼", "Format"]
        let has_format_keyword = format_keywords.exists(fn(keyword) { message.contains(keyword) })
        assert_eq(has_format_keyword, true)
      } else if error_code == "RATE_LIMIT_EXCEEDED" {
        let limit_keywords = ["limit", "é™åˆ¶", "åˆ¶é™", "limit", "limite"]
        let has_limit_keyword = limit_keywords.exists(fn(keyword) { message.contains(keyword) })
        assert_eq(has_limit_keyword, true)
      }
      
      j = j + 1
    }
    
    i = i + 1
  }
}

test "telemetry_collation_and_sorting" {
  // æµ‹è¯•æ’åºå’Œæ’åºè§„åˆ™
  
  let names_to_sort = [
    "å¼ ä¸‰",      // ä¸­æ–‡
    "æå››",      // ä¸­æ–‡
    "ç‹äº”",      // ä¸­æ–‡
    "Alice",     // è‹±æ–‡
    "Bob",       // è‹±æ–‡
    "Charlie",   // è‹±æ–‡
    "Ã‰milie",    // æ³•æ–‡ï¼ˆå¸¦é‡éŸ³ï¼‰
    "JosÃ©",      // è¥¿ç­ç‰™æ–‡ï¼ˆå¸¦é‡éŸ³ï¼‰
    "Ã…ke",       // ç‘å…¸æ–‡ï¼ˆå¸¦ç‰¹æ®Šå­—ç¬¦ï¼‰
    "Ã˜yvind"     // æŒªå¨æ–‡ï¼ˆå¸¦ç‰¹æ®Šå­—ç¬¦ï¼‰
  ]
  
  // æ¨¡æ‹Ÿä¸åŒè¯­è¨€çš„æ’åºç»“æœ
  let locale_sorted_results = [
    ("en_US", ["Alice", "Bob", "Charlie", "Ã‰milie", "JosÃ©", "Ã…ke", "Ã˜yvind", "å¼ ä¸‰", "æå››", "ç‹äº”"]),
    ("zh_CN", ["å¼ ä¸‰", "æå››", "ç‹äº”", "Alice", "Bob", "Charlie", "Ã‰milie", "JosÃ©", "Ã…ke", "Ã˜yvind"]),
    ("sv_SE", ["Alice", "Bob", "Charlie", "Ã…ke", "Ã˜yvind", "Ã‰milie", "JosÃ©", "å¼ ä¸‰", "æå››", "ç‹äº”"])
  ]
  
  // éªŒè¯æ’åºç»“æœ
  let mut i = 0
  while i < locale_sorted_results.length() {
    let (locale, sorted_names) = locale_sorted_results[i]
    
    // éªŒè¯æ’åºç»“æœåŒ…å«æ‰€æœ‰åç§°
    assert_eq(sorted_names.length(), names_to_sort.length())
    
    // éªŒè¯æ’åºé¡ºåº
    if locale == "en_US" {
      // è‹±æ–‡æ’åºï¼šè‹±æ–‡åç§°åœ¨å‰ï¼ŒæŒ‰å­—æ¯é¡ºåº
      assert_eq(sorted_names[0], "Alice")
      assert_eq(sorted_names[1], "Bob")
      assert_eq(sorted_names[2], "Charlie")
    } else if locale == "zh_CN" {
      // ä¸­æ–‡æ’åºï¼šä¸­æ–‡åç§°åœ¨å‰ï¼ŒæŒ‰æ‹¼éŸ³é¡ºåº
      assert_eq(sorted_names[0], "å¼ ä¸‰")
      assert_eq(sorted_names[1], "æå››")
      assert_eq(sorted_names[2], "ç‹äº”")
    } else if locale == "sv_SE" {
      // ç‘å…¸æ–‡æ’åºï¼šÃ…å’ŒÃ˜åœ¨ç‰¹æ®Šä½ç½®
      assert_eq(sorted_names[3], "Ã…ke")
      assert_eq(sorted_names[4], "Ã˜yvind")
    }
    
    i = i + 1
  }
  
  // éªŒè¯æ’åºç¨³å®šæ€§ï¼šç›¸åŒè¾“å…¥åœ¨ä¸åŒlocaleä¸‹äº§ç”Ÿä¸åŒä½†ä¸€è‡´çš„è¾“å‡º
  let en_us_result = locale_sorted_results[0].1
  let zh_cn_result = locale_sorted_results[1].1
  let sv_se_result = locale_sorted_results[2].1
  
  // è‹±æ–‡å’Œä¸­æ–‡æ’åºç»“æœåº”è¯¥ä¸åŒ
  let en_vs_zh_different = en_us_result != zh_cn_result
  assert_eq(en_vs_zh_different, true)
  
  // è‹±æ–‡å’Œç‘å…¸æ–‡æ’åºç»“æœåº”è¯¥ä¸åŒ
  let en_vs_sv_different = en_us_result != sv_se_result
  assert_eq(en_vs_sv_different, true)
}