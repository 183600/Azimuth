// é¥æµ‹åºåˆ—åŒ–æµ‹è¯•ç”¨ä¾‹

test "serialization_basic_types" {
  // æµ‹è¯•åŸºæœ¬ç±»å‹çš„åºåˆ—åŒ–
  
  // å­—ç¬¦ä¸²åºåˆ—åŒ–
  let string_value = "telemetry.test.string"
  let serialized_string = "\"" + string_value + "\""
  assert_eq(serialized_string, "\"telemetry.test.string\"")
  
  // æ•´æ•°åºåˆ—åŒ–
  let int_value = 42L
  let serialized_int = int_value.to_string()
  assert_eq(serialized_int, "42")
  
  // æµ®ç‚¹æ•°åºåˆ—åŒ–
  let float_value = 3.14159
  let serialized_float = float_value.to_string()
  assert_eq(serialized_float.contains("3.14159"), true)
  
  // å¸ƒå°”å€¼åºåˆ—åŒ–
  let bool_value = true
  let serialized_bool = bool_value.to_string()
  assert_eq(serialized_bool, "true")
  
  let bool_value_false = false
  let serialized_bool_false = bool_value_false.to_string()
  assert_eq(serialized_bool_false, "false")
}

test "serialization_attribute_values" {
  // æµ‹è¯•å±æ€§å€¼åºåˆ—åŒ–
  use azimuth.telemetry.api.common.AttributeValue
  
  let string_attr = AttributeValue::string("test.value")
  let int_attr = AttributeValue::int(123L)
  let float_attr = AttributeValue::float(45.67)
  let bool_attr = AttributeValue::bool(true)
  
  // æ¨¡æ‹Ÿåºåˆ—åŒ–è¿‡ç¨‹
  let serialized_string_attr = match string_attr {
    StringValue(s) => "string:" + s
    _ => "unknown"
  }
  
  let serialized_int_attr = match int_attr {
    IntValue(i) => "int:" + i.to_string()
    _ => "unknown"
  }
  
  let serialized_float_attr = match float_attr {
    FloatValue(f) => "float:" + f.to_string()
    _ => "unknown"
  }
  
  let serialized_bool_attr = match bool_attr {
    BoolValue(b) => "bool:" + b.to_string()
    _ => "unknown"
  }
  
  // éªŒè¯åºåˆ—åŒ–ç»“æœ
  assert_eq(serialized_string_attr, "string:test.value")
  assert_eq(serialized_int_attr, "int:123")
  assert_eq(serialized_float_attr.contains("float:45.67"), true)
  assert_eq(serialized_bool_attr, "bool:true")
}

test "serialization_array_types" {
  // æµ‹è¯•æ•°ç»„ç±»å‹åºåˆ—åŒ–
  use azimuth.telemetry.api.common.AttributeValue
  
  let string_array = AttributeValue::array_string(["a", "b", "c"])
  let int_array = AttributeValue::array_int([1L, 2L, 3L, 4L])
  let float_array = AttributeValue::array_float([1.1, 2.2, 3.3])
  let bool_array = AttributeValue::array_bool([true, false, true])
  
  // æ¨¡æ‹Ÿæ•°ç»„åºåˆ—åŒ–
  let serialized_string_array = match string_array {
    ArrayStringValue(arr) => {
      let mut result = "[string:"
      let mut i = 0
      while i < arr.length() {
        if i > 0 {
          result = result + ","
        }
        result = result + arr[i]
        i = i + 1
      }
      result = result + "]"
      result
    }
    _ => "unknown"
  }
  
  // éªŒè¯æ•°ç»„åºåˆ—åŒ–
  assert_eq(serialized_string_array, "[string:a,b,c]")
  
  // æµ‹è¯•ç©ºæ•°ç»„åºåˆ—åŒ–
  let empty_array = AttributeValue::array_string([])
  let serialized_empty = match empty_array {
    ArrayStringValue(arr) => {
      if arr.length() == 0 {
        "[string:]"
      } else {
        "not_empty"
      }
    }
    _ => "unknown"
  }
  
  assert_eq(serialized_empty, "[string:]")
}

test "serialization_complex_structures" {
  // æµ‹è¯•å¤æ‚ç»“æ„åºåˆ—åŒ–
  
  // æ¨¡æ‹Ÿå¤æ‚é¥æµ‹æ•°æ®ç»“æ„
  let telemetry_data = [
    ("trace.id", "0af7651916cd43dd8448eb211c80319c"),
    ("span.id", "b7ad6b7169203331"),
    ("service.name", "payment-service"),
    ("service.version", "1.2.3"),
    ("http.method", "GET"),
    ("http.status_code", "200"),
    ("http.url", "/api/v1/payments"),
    ("user.id", "user-12345"),
    ("session.id", "session-abcdef"),
    ("request.duration_ms", "150")
  ]
  
  // åºåˆ—åŒ–ä¸ºé”®å€¼å¯¹å­—ç¬¦ä¸²
  let mut serialized = ""
  let mut i = 0
  while i < telemetry_data.length() {
    let (key, value) = telemetry_data[i]
    if i > 0 {
      serialized = serialized + "&"
    }
    serialized = serialized + key + "=" + value
    i = i + 1
  }
  
  // éªŒè¯åºåˆ—åŒ–ç»“æœ
  assert_eq(serialized.contains("trace.id=0af7651916cd43dd8448eb211c80319c"), true)
  assert_eq(serialized.contains("service.name=payment-service"), true)
  assert_eq(serialized.contains("http.method=GET"), true)
  assert_eq(serialized.contains("&"), true)  // ç¡®ä¿æœ‰åˆ†éš”ç¬¦
  
  // è®¡ç®—é”®å€¼å¯¹æ•°é‡
  let pairs = serialized.split("&")
  assert_eq(pairs.length(), telemetry_data.length())
}

test "serialization_deserialization_roundtrip" {
  // æµ‹è¯•åºåˆ—åŒ–/ååºåˆ—åŒ–å¾€è¿”
  
  // åŸå§‹æ•°æ®
  let original_data = [
    ("string.key", "string.value"),
    ("int.key", "42"),
    ("float.key", "3.14"),
    ("bool.key", "true")
  ]
  
  // åºåˆ—åŒ–
  let mut serialized = ""
  let mut i = 0
  while i < original_data.length() {
    let (key, value) = original_data[i]
    if i > 0 {
      serialized = serialized + ";"
    }
    serialized = serialized + key + ":" + value
    i = i + 1
  }
  
  // ååºåˆ—åŒ–
  let deserialized_pairs = serialized.split(";")
  let mut roundtrip_success = true
  
  let mut j = 0
  while j < deserialized_pairs.length() {
    let pair = deserialized_pairs[j]
    let parts = pair.split(":")
    if parts.length() == 2 {
      let key = parts[0]
      let value = parts[1]
      
      // éªŒè¯é”®å€¼å¯¹
      let mut found = false
      let mut k = 0
      while k < original_data.length() {
        let (orig_key, orig_value) = original_data[k]
        if key == orig_key && value == orig_value {
          found = true
          break
        }
        k = k + 1
      }
      
      if !found {
        roundtrip_success = false
        break
      }
    } else {
      roundtrip_success = false
      break
    }
    j = j + 1
  }
  
  assert_eq(roundtrip_success, true)
}

test "serialization_edge_cases" {
  // æµ‹è¯•åºåˆ—åŒ–è¾¹ç•Œæƒ…å†µ
  
  // ç©ºå­—ç¬¦ä¸²
  let empty_string = ""
  let serialized_empty = "\"" + empty_string + "\""
  assert_eq(serialized_empty, "\"\"")
  
  // ç‰¹æ®Šå­—ç¬¦
  let special_chars = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let serialized_special = "\"" + special_chars + "\""
  assert_eq(serialized_special.contains("!@#$%^&*()"), true)
  
  // Unicodeå­—ç¬¦
  let unicode_string = "Unicodeæµ‹è¯•ğŸš€"
  let serialized_unicode = "\"" + unicode_string + "\""
  assert_eq(serialized_unicode.contains("Unicode"), true)
  assert_eq(serialized_unicode.contains("æµ‹è¯•"), true)
  assert_eq(serialized_unicode.contains("ğŸš€"), true)
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = "This is a very long string that tests serialization performance with large amounts of data that need to be properly handled without loss or corruption during the serialization and deserialization process."
  let serialized_long = "\"" + long_string + "\""
  assert_eq(serialized_long.length() > long_string.length(), true)
  assert_eq(serialized_long.contains("very long string"), true)
  
  // æ•°å€¼è¾¹ç•Œ
  let max_int = 9223372036854775807L
  let min_int = -9223372036854775808L
  let zero = 0L
  
  assert_eq(max_int.to_string(), "9223372036854775807")
  assert_eq(min_int.to_string(), "-9223372036854775808")
  assert_eq(zero.to_string(), "0")
  
  // æµ®ç‚¹æ•°è¾¹ç•Œ
  let infinity = 1.0/0.0
  let neg_infinity = -1.0/0.0
  let nan = 0.0/0.0
  
  let infinity_str = infinity.to_string()
  let neg_infinity_str = neg_infinity.to_string()
  let nan_str = nan.to_string()
  
  // éªŒè¯ç‰¹æ®Šæµ®ç‚¹æ•°å€¼çš„å­—ç¬¦ä¸²è¡¨ç¤º
  assert_eq(infinity_str.length() > 0, true)
  assert_eq(neg_infinity_str.length() > 0, true)
  assert_eq(nan_str.length() > 0, true)
}