// è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯• - æµ‹è¯•ç³»ç»Ÿåœ¨ä¸åŒå¹³å°å’Œç¯å¢ƒä¸‹çš„å…¼å®¹æ€§
use azimuth.telemetry.api.common.{AttributeValue, Resource}
use azimuth.telemetry.api.context.{Context, create_key}
use azimuth.telemetry.api.logs.{LogRecord, SeverityNumber}
use azimuth.telemetry.api.metrics.{NoopMeter}
use azimuth.telemetry.api.trace.{SpanKind}
use azimuth.telemetry.api.propagation.{MapCarrier, W3CTraceContextPropagator}

test "platform_compatibility_basic_types" {
  // æµ‹è¯•åŸºæœ¬ç±»å‹çš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. å­—ç¬¦ä¸²å…¼å®¹æ€§æµ‹è¯•
  let ascii_string = "ASCII string: Hello World!"
  let unicode_string = "Unicode string: ä½ å¥½ä¸–ç•Œ! ğŸŒ"
  let mixed_string = "Mixed: ASCII + ä½ å¥½ + ğŸš€ + Special: \n\t\r"
  
  let ascii_attr = AttributeValue::string(ascii_string)
  let unicode_attr = AttributeValue::string(unicode_string)
  let mixed_attr = AttributeValue::string(mixed_string)
  
  // éªŒè¯å­—ç¬¦ä¸²å…¼å®¹æ€§
  match ascii_attr {
    StringValue(s) => {
      assert_eq(s, ascii_string)
      assert_eq(s.length(), 24)
    }
    _ => @test.fail("Test failed")
  }
  
  match unicode_attr {
    StringValue(s) => {
      assert_eq(s, unicode_string)
      assert_eq(s.length(), 19)
    }
    _ => @test.fail("Test failed")
  }
  
  match mixed_attr {
    StringValue(s) => {
      assert_eq(s, mixed_string)
      assert_eq(s.length(), 39)
    }
    _ => @test.fail("Test failed")
  }
  
  // 2. æ•°å€¼å…¼å®¹æ€§æµ‹è¯•
  let positive_int = AttributeValue::int(9223372036854775807L)
  let negative_int = AttributeValue::int(-9223372036854775808L)
  let zero_int = AttributeValue::int(0L)
  
  let positive_float = AttributeValue::float(1.7976931348623157e+308)
  let negative_float = AttributeValue::float(-1.7976931348623157e+308)
  let zero_float = AttributeValue::float(0.0)
  let nan_float = AttributeValue::float(0.0/0.0)
  let infinity_float = AttributeValue::float(1.0/0.0)
  
  // éªŒè¯æ•°å€¼å…¼å®¹æ€§
  match positive_int {
    IntValue(v) => assert_eq(v, 9223372036854775807L)
    _ => @test.fail("Test failed")
  }
  
  match negative_int {
    IntValue(v) => assert_eq(v, -9223372036854775808L)
    _ => @test.fail("Test failed")
  }
  
  match zero_int {
    IntValue(v) => assert_eq(v, 0L)
    _ => @test.fail("Test failed")
  }
  
  match positive_float {
    FloatValue(v) => assert_eq(v > 1.0e+308, true)
    _ => @test.fail("Test failed")
  }
  
  match negative_float {
    FloatValue(v) => assert_eq(v < -1.0e+308, true)
    _ => @test.fail("Test failed")
  }
  
  match zero_float {
    FloatValue(v) => assert_eq(v, 0.0)
    _ => @test.fail("Test failed")
  }
  
  match nan_float {
    FloatValue(v) => assert_eq(v != v, true)
    _ => @test.fail("Test failed")
  }
  
  match infinity_float {
    FloatValue(v) => assert_eq(v > 1.0e+308, true)
    _ => @test.fail("Test failed")
  }
  
  // 3. å¸ƒå°”å…¼å®¹æ€§æµ‹è¯•
  let true_attr = AttributeValue::bool(true)
  let false_attr = AttributeValue::bool(false)
  
  match true_attr {
    BoolValue(v) => assert_eq(v, true)
    _ => @test.fail("Test failed")
  }
  
  match false_attr {
    BoolValue(v) => assert_eq(v, false)
    _ => @test.fail("Test failed")
  }
}

test "platform_compatibility_array_types" {
  // æµ‹è¯•æ•°ç»„ç±»å‹çš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. å­—ç¬¦ä¸²æ•°ç»„å…¼å®¹æ€§
  let string_array = AttributeValue::array_string([
    "ASCII",
    "Unicode: ä¸­æ–‡",
    "Emoji: ğŸ‰",
    "Special: \n\t\r",
    "Empty: ",
    "Mixed: Hello ä¸–ç•Œ ğŸŒ"
  ])
  
  match string_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 6)
      assert_eq(arr[0], "ASCII")
      assert_eq(arr[1], "Unicode: ä¸­æ–‡")
      assert_eq(arr[2], "Emoji: ğŸ‰")
      assert_eq(arr[3], "Special: \n\t\r")
      assert_eq(arr[4], "")
      assert_eq(arr[5], "Mixed: Hello ä¸–ç•Œ ğŸŒ")
    }
    _ => @test.fail("Test failed")
  }
  
  // 2. æ•´æ•°æ•°ç»„å…¼å®¹æ€§
  let int_array = AttributeValue::array_int([
    0L,
    -1L,
    1L,
    9223372036854775807L,
    -9223372036854775808L,
    42L,
    -42L
  ])
  
  match int_array {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 7)
      assert_eq(arr[0], 0L)
      assert_eq(arr[1], -1L)
      assert_eq(arr[2], 1L)
      assert_eq(arr[3], 9223372036854775807L)
      assert_eq(arr[4], -9223372036854775808L)
      assert_eq(arr[5], 42L)
      assert_eq(arr[6], -42L)
    }
    _ => @test.fail("Test failed")
  }
  
  // 3. æµ®ç‚¹æ•°æ•°ç»„å…¼å®¹æ€§
  let float_array = AttributeValue::array_float([
    0.0,
    -0.0,
    1.0,
    -1.0,
    3.14159265359,
    -3.14159265359,
    1.7976931348623157e+308,
    -1.7976931348623157e+308,
    0.0/0.0,  // NaN
    1.0/0.0   // Infinity
  ])
  
  match float_array {
    ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 10)
      assert_eq(arr[0], 0.0)
      assert_eq(arr[1], -0.0)
      assert_eq(arr[2], 1.0)
      assert_eq(arr[3], -1.0)
      assert_eq(arr[4], 3.14159265359)
      assert_eq(arr[5], -3.14159265359)
      assert_eq(arr[6] > 1.0e+308, true)
      assert_eq(arr[7] < -1.0e+308, true)
      assert_eq(arr[8] != arr[8], true)  // NaN check
      assert_eq(arr[9] > 1.0e+308, true)  // Infinity check
    }
    _ => @test.fail("Test failed")
  }
  
  // 4. å¸ƒå°”æ•°ç»„å…¼å®¹æ€§
  let bool_array = AttributeValue::array_bool([
    true,
    false,
    true && false,
    true || false,
    !true,
    !false
  ])
  
  match bool_array {
    ArrayBoolValue(arr) => {
      assert_eq(arr.length(), 6)
      assert_eq(arr[0], true)
      assert_eq(arr[1], false)
      assert_eq(arr[2], false)
      assert_eq(arr[3], true)
      assert_eq(arr[4], false)
      assert_eq(arr[5], true)
    }
    _ => @test.fail("Test failed")
  }
}

test "platform_compatibility_resource" {
  // æµ‹è¯•Resourceçš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. åŸºæœ¬Resourceå…¼å®¹æ€§
  let basic_resource = Resource::default("platform-compatibility-service")
  
  assert_eq(basic_resource.service_name, "platform-compatibility-service")
  assert_eq(basic_resource.service_version, None)
  assert_eq(basic_resource.telemetry_sdk_name, "azimuth")
  assert_eq(basic_resource.telemetry_sdk_version, "0.1.0")
  assert_eq(basic_resource.attributes.length(), 0)
  
  // 2. ç‰¹æ®Šå­—ç¬¦Resourceå…¼å®¹æ€§
  let special_resource = Resource::default("special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  assert_eq(special_resource.service_name, "special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  assert_eq(special_resource.telemetry_sdk_name, "azimuth")
  
  // 3. Unicode Resourceå…¼å®¹æ€§
  let unicode_resource = Resource::default("UnicodeæœåŠ¡æµ‹è¯•ğŸš€")
  
  assert_eq(unicode_resource.service_name, "UnicodeæœåŠ¡æµ‹è¯•ğŸš€")
  assert_eq(unicode_resource.telemetry_sdk_name, "azimuth")
  
  // 4. ç©ºå’Œè¾¹ç•ŒResourceå…¼å®¹æ€§
  let empty_resource = Resource::default("")
  let space_resource = Resource::default("   ")
  let newline_resource = Resource::default("line1\nline2")
  
  assert_eq(empty_resource.service_name, "")
  assert_eq(space_resource.service_name, "   ")
  assert_eq(newline_resource.service_name, "line1\nline2")
}

test "platform_compatibility_context" {
  // æµ‹è¯•Contextçš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. åŸºæœ¬Contextå…¼å®¹æ€§
  let empty_context = Context::empty()
  assert_eq(empty_context.values.length(), 0)
  
  // 2. ç‰¹æ®Šé”®å€¼Contextå…¼å®¹æ€§
  let special_key = create_key("special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let unicode_key = create_key("Unicodeé”®æµ‹è¯•ğŸ”‘")
  let empty_key = create_key("")
  
  let special_context = empty_context
    .with_value(special_key, "special!@#$%^&*()_+-=[]{}|;':\",./<>?")
    .with_value(unicode_key, "Unicodeå€¼æµ‹è¯•ğŸ“")
    .with_value(empty_key, "")
  
  match special_context.get(special_key) {
    Some(value) => assert_eq(value, "special!@#$%^&*()_+-=[]{}|;':\",./<>?")
    None => @test.fail("Test failed")
  }
  
  match special_context.get(unicode_key) {
    Some(value) => assert_eq(value, "Unicodeå€¼æµ‹è¯•ğŸ“")
    None => @test.fail("Test failed")
  }
  
  match special_context.get(empty_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  // 3. é•¿é”®å€¼Contextå…¼å®¹æ€§
  let long_key = create_key("a" * 1000)
  let long_value = "b" * 10000
  let long_context = empty_context.with_value(long_key, long_value)
  
  match long_context.get(long_key) {
    Some(value) => assert_eq(value.length(), 10000)
    None => @test.fail("Test failed")
  }
}

test "platform_compatibility_log_record" {
  // æµ‹è¯•LogRecordçš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. åŸºæœ¬LogRecordå…¼å®¹æ€§
  let basic_log = LogRecord::builder()
    .severity(SeverityNumber::Info)
    .body("Basic platform compatibility test")
    .build()
  
  assert_eq(basic_log.severity_number, SeverityNumber::Info)
  assert_eq(basic_log.body.unwrap_or(""), "Basic platform compatibility test")
  
  // 2. ç‰¹æ®Šå­—ç¬¦LogRecordå…¼å®¹æ€§
  let special_log = LogRecord::builder()
    .severity(SeverityNumber::Error)
    .body("Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?")
    .severity_text("ERROR!@#$%")
    .with_attribute("special.key", AttributeValue::string("special!@#$%^&*()"))
    .with_attribute("unicode.key", AttributeValue::string("Unicode: ä½ å¥½ä¸–ç•Œ ğŸŒ"))
    .with_attribute("empty.key", AttributeValue::string(""))
    .with_attribute("null.key", AttributeValue::string("null"))
    .build()
  
  assert_eq(special_log.severity_number, SeverityNumber::Error)
  assert_eq(special_log.severity_text.unwrap_or(""), "ERROR!@#$%")
  assert_eq(special_log.body.unwrap_or("").contains("!@#$%^&*()"), true)
  assert_eq(special_log.attributes.length(), 4)
  
  // 3. æå€¼LogRecordå…¼å®¹æ€§
  let extreme_log = LogRecord::builder()
    .severity(SeverityNumber::Fatal)
    .body("")
    .severity_text("")
    .with_attribute("max.int", AttributeValue::int(9223372036854775807L))
    .with_attribute("min.int", AttributeValue::int(-9223372036854775808L))
    .with_attribute("max.float", AttributeValue::float(1.7976931348623157e+308))
    .with_attribute("min.float", AttributeValue::float(-1.7976931348623157e+308))
    .with_attribute("nan.float", AttributeValue::float(0.0/0.0))
    .with_attribute("infinity.float", AttributeValue::float(1.0/0.0))
    .build()
  
  assert_eq(extreme_log.severity_number, SeverityNumber::Fatal)
  assert_eq(extreme_log.body.unwrap_or(""), "")
  assert_eq(extreme_log.severity_text.unwrap_or(""), "")
  assert_eq(extreme_log.attributes.length(), 6)
}

test "platform_compatibility_metrics" {
  // æµ‹è¯•Metricsçš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. åŸºæœ¬Metricså…¼å®¹æ€§
  let meter = NoopMeter::{}
  let counter = meter.create_counter("platform.counter", "count", "Platform counter")
  let histogram = meter.create_histogram("platform.histogram", "ms", "Platform histogram")
  let gauge = meter.create_gauge("platform.gauge", "units", "Platform gauge")
  
  // 2. ç‰¹æ®Šå­—ç¬¦Metricså…¼å®¹æ€§
  let special_counter = meter.create_counter("special!@#$%^&*()", "count", "Special counter")
  let unicode_histogram = meter.create_histogram("Unicodeç›´æ–¹å›¾ğŸ“Š", "ms", "Unicode histogram")
  let empty_gauge = meter.create_gauge("", "", "Empty gauge")
  
  // 3. å¸¦ç‰¹æ®Šå±æ€§çš„Metricsæ“ä½œå…¼å®¹æ€§
  counter.add(1L, [
    ("special.key", AttributeValue::string("special!@#$%^&*()")),
    ("unicode.key", AttributeValue::string("Unicodeå€¼ ğŸŒ")),
    ("empty.key", AttributeValue::string("")),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("min.int", AttributeValue::int(-9223372036854775808L)),
    ("max.float", AttributeValue::float(1.7976931348623157e+308)),
    ("min.float", AttributeValue::float(-1.7976931348623157e+308)),
    ("nan.float", AttributeValue::float(0.0/0.0)),
    ("infinity.float", AttributeValue::float(1.0/0.0)),
    ("bool.true", AttributeValue::bool(true)),
    ("bool.false", AttributeValue::bool(false))
  ])
  
  histogram.record(3.14159265359, [
    ("unicode.attribute", AttributeValue::string("Unicodeå±æ€§ ğŸ“")),
    ("special.attribute", AttributeValue::string("special!@#$%^&*()"))
  ])
  
  gauge.record(42.0, [
    ("array.string", AttributeValue::array_string(["a", "b", "c"])),
    ("array.int", AttributeValue::array_int([1L, 2L, 3L])),
    ("array.float", AttributeValue::array_float([1.1, 2.2, 3.3])),
    ("array.bool", AttributeValue::array_bool([true, false, true]))
  ])
  
  // éªŒè¯æ“ä½œä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(true, true)
}

test "platform_compatibility_spans" {
  // æµ‹è¯•Spançš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. åŸºæœ¬Spanå…¼å®¹æ€§
  let tracer = NoopTracer::{}
  let context = Context::empty()
  
  let (ctx1, span1) = tracer.start_span(
    context,
    "platform-span",
    Some(SpanKind::Internal),
    [("platform.test", AttributeValue::bool(true))]
  )
  
  // 2. ç‰¹æ®Šå­—ç¬¦Spanå…¼å®¹æ€§
  let (ctx2, span2) = tracer.start_span(
    ctx1,
    "special!@#$%^&*()_+-=[]{}|;':\",./<>?",
    Some(SpanKind::Server),
    [("special.name", AttributeValue::string("special!@#$%^&*()"))]
  )
  
  // 3. Unicode Spanå…¼å®¹æ€§
  let (ctx3, span3) = tracer.start_span(
    ctx2,
    "Unicodeæµ‹è¯•Span ğŸ¯",
    Some(SpanKind::Client),
    [("unicode.name", AttributeValue::string("Unicodeå€¼ ğŸŒ"))]
  )
  
  // 4. ç©ºå’Œè¾¹ç•ŒSpanå…¼å®¹æ€§
  let (ctx4, span4) = tracer.start_span(
    ctx3,
    "",
    Some(SpanKind::Producer),
    [("empty.name", AttributeValue::string(""))]
  )
  
  // éªŒè¯æ‰€æœ‰Spanéƒ½æ­£ç¡®åˆ›å»º
  assert_eq(span1.name, "platform-span")
  assert_eq(span1.kind, SpanKind::Internal)
  assert_eq(span1.attributes.length(), 1)
  
  assert_eq(span2.name, "special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  assert_eq(span2.kind, SpanKind::Server)
  assert_eq(span2.attributes.length(), 1)
  
  assert_eq(span3.name, "Unicodeæµ‹è¯•Span ğŸ¯")
  assert_eq(span3.kind, SpanKind::Client)
  assert_eq(span3.attributes.length(), 1)
  
  assert_eq(span4.name, "")
  assert_eq(span4.kind, SpanKind::Producer)
  assert_eq(span4.attributes.length(), 1)
}

test "platform_compatibility_propagation" {
  // æµ‹è¯•ä¼ æ’­çš„è·¨å¹³å°å…¼å®¹æ€§
  
  // 1. åŸºæœ¬ä¼ æ’­å…¼å®¹æ€§
  let propagator = W3CTraceContextPropagator::{}
  let context = Context::empty()
  let carrier = MapCarrier::new()
  
  propagator.inject(context, carrier)
  let extracted_context = propagator.extract(Context::empty(), carrier)
  
  // 2. ç‰¹æ®Šå­—ç¬¦ä¼ æ’­å…¼å®¹æ€§
  let special_key = create_key("special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let special_context = context.with_value(special_key, "special!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  let special_carrier = MapCarrier::new()
  propagator.inject(special_context, special_carrier)
  let special_extracted_context = propagator.extract(Context::empty(), special_carrier)
  
  // 3. Unicodeä¼ æ’­å…¼å®¹æ€§
  let unicode_key = create_key("Unicodeä¼ æ’­é”®ğŸ”‘")
  let unicode_context = context.with_value(unicode_key, "Unicodeä¼ æ’­å€¼ ğŸ“¡")
  
  let unicode_carrier = MapCarrier::new()
  propagator.inject(unicode_context, unicode_carrier)
  let unicode_extracted_context = propagator.extract(Context::empty(), unicode_carrier)
  
  // 4. é•¿å€¼ä¼ æ’­å…¼å®¹æ€§
  let long_key = create_key("long.key")
  let long_value = "a" * 10000
  let long_context = context.with_value(long_key, long_value)
  
  let long_carrier = MapCarrier::new()
  propagator.inject(long_context, long_carrier)
  let long_extracted_context = propagator.extract(Context::empty(), long_carrier)
  
  // éªŒè¯ä¼ æ’­æ“ä½œä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(true, true)
}

test "platform_compatibility_endianness" {
  // æµ‹è¯•å­—èŠ‚åºå…¼å®¹æ€§
  
  // 1. SpanContextå­—èŠ‚åºå…¼å®¹æ€§
  let trace_id = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte })
  let span_id = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte })
  
  // è®¾ç½®ç‰¹å®šå­—èŠ‚å€¼æµ‹è¯•å­—èŠ‚åº
  let mut i = 0
  while i < trace_id.length() {
    trace_id[i] = (i % 256).to_byte()
    i = i + 1
  }
  
  let mut j = 0
  while j < span_id.length() {
    span_id[j] = (j % 256).to_byte()
    j = j + 1
  }
  
  let span_context = SpanContext::{
    trace_id: trace_id,
    span_id: span_id,
    trace_flags: 255_byte,
    trace_state: "key1=value1,key2=value2"
  }
  
  // éªŒè¯å­—èŠ‚åºå…¼å®¹æ€§
  assert_eq(span_context.trace_id.length(), 16)
  assert_eq(span_context.span_id.length(), 8)
  assert_eq(span_context.trace_flags, 255_byte)
  assert_eq(span_context.trace_state.length() > 0, true)
  
  // 2. éªŒè¯å­—èŠ‚å€¼
  let mut k = 0
  while k < trace_id.length() {
    assert_eq(span_context.trace_id[k], (k % 256).to_byte())
    k = k + 1
  }
  
  let mut l = 0
  while l < span_id.length() {
    assert_eq(span_context.span_id[l], (l % 256).to_byte())
    l = l + 1
  }
}