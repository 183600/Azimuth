// é”™è¯¯æ¢å¤å®¹é”™æµ‹è¯•
test "attribute_value_error_recovery" {
  // æµ‹è¯•AttributeValueçš„é”™è¯¯æ¢å¤å’Œå®¹é”™
  
  // æµ‹è¯•æå€¼å’Œå¼‚å¸¸å€¼
  let max_int = AttributeValue::int(9223372036854775807L)
  let min_int = AttributeValue::int(-9223372036854775808L)
  let inf_float = AttributeValue::float(1.0/0.0)
  let neg_inf_float = AttributeValue::float(-1.0/0.0)
  let nan_float = AttributeValue::float(0.0/0.0)
  
  // éªŒè¯æå€¼ä¸ä¼šå¯¼è‡´å´©æºƒ
  match max_int {
    IntValue(i) => {
      assert_eq(i, 9223372036854775807L)
      // æµ‹è¯•ç®—æœ¯è¿ç®—çš„é”™è¯¯æ¢å¤
      let overflow_add = i + 1L  // åœ¨å®é™…ç³»ç»Ÿä¸­å¯èƒ½æº¢å‡ºï¼Œä½†è¿™é‡Œåº”è¯¥ä¼˜é›…å¤„ç†
      assert_eq(overflow_add, -9223372036854775808L)  // æº¢å‡ºå›ç»•
    }
    _ => @test.fail("Expected max int")
  }
  
  match min_int {
    IntValue(i) => {
      assert_eq(i, -9223372036854775808L)
      // æµ‹è¯•ç®—æœ¯è¿ç®—çš„é”™è¯¯æ¢å¤
      let underflow_add = i - 1L  // åœ¨å®é™…ç³»ç»Ÿä¸­å¯èƒ½ä¸‹æº¢ï¼Œä½†è¿™é‡Œåº”è¯¥ä¼˜é›…å¤„ç†
      assert_eq(underflow_add, 9223372036854775807L)  // ä¸‹æº¢å›ç»•
    }
    _ => @test.fail("Expected min int")
  }
  
  // éªŒè¯ç‰¹æ®Šæµ®ç‚¹å€¼
  match inf_float {
    FloatValue(f) => {
      assert_eq(f > 0.0, true)
      // æµ‹è¯•æ— ç©·å¤§è¿ç®—çš„é”™è¯¯æ¢å¤
      let inf_mult = f * 2.0
      assert_eq(inf_mult > 0.0, true)  // æ— ç©·å¤§ä¹˜ä»¥æ­£æ•°ä»æ˜¯æ— ç©·å¤§
      
      let inf_div = f / f
      assert_eq(inf_div != inf_div, true)  // æ— ç©·å¤§é™¤ä»¥æ— ç©·å¤§æ˜¯NaN
    }
    _ => @test.fail("Expected infinity float")
  }
  
  match nan_float {
    FloatValue(f) => {
      assert_eq(f != f, true)  // NaNä¸ç­‰äºè‡ªèº«
      // æµ‹è¯•NaNè¿ç®—çš„é”™è¯¯æ¢å¤
      let nan_add = f + 1.0
      assert_eq(nan_add != nan_add, true)  // NaNåŠ ä»»ä½•æ•°ä»æ˜¯NaN
      
      let nan_mult = f * 0.0
      assert_eq(nan_mult != nan_mult, true)  // NaNä¹˜ä»¥ä»»ä½•æ•°ä»æ˜¯NaN
    }
    _ => @test.fail("Expected NaN float")
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„å’Œå¤§å‹æ•°ç»„
  let empty_array = AttributeValue::array_string([])
  let large_array = AttributeValue::array_string(Array::make(10000, "item"))
  
  match empty_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 0)
      // æµ‹è¯•ç©ºæ•°ç»„è®¿é—®çš„é”™è¯¯æ¢å¤
      if arr.length() > 0 {
        let first_item = arr[0]  // è¿™é‡Œä¸åº”è¯¥æ‰§è¡Œ
        assert_eq(false, true)  // ä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œ
      }
    }
    _ => @test.fail("Expected empty array")
  }
  
  match large_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 10000)
      // æµ‹è¯•å¤§å‹æ•°ç»„è®¿é—®çš„é”™è¯¯æ¢å¤
      if arr.length() > 9999 {
        let last_item = arr[9999]
        assert_eq(last_item, "item")
      }
      
      // æµ‹è¯•è¾¹ç•Œè®¿é—®
      if arr.length() > 0 {
        let first_item = arr[0]
        assert_eq(first_item, "item")
      }
    }
    _ => @test.fail("Expected large array")
  }
}

test "context_error_recovery" {
  // æµ‹è¯•Contextçš„é”™è¯¯æ¢å¤å’Œå®¹é”™
  
  let ctx = Context::empty()
  
  // æµ‹è¯•ç©ºContextæ“ä½œ
  let empty_key = create_key("")
  let normal_key = create_key("normal.key")
  
  // å‘ç©ºContextæ·»åŠ å€¼
  let ctx_with_empty_key = ctx.with_value(empty_key, "empty.key.value")
  let ctx_with_normal_key = ctx.with_value(normal_key, "normal.key.value")
  
  // éªŒè¯ç©ºé”®å€¼å¯¹
  match ctx_with_empty_key.get(empty_key) {
    Some(value) => assert_eq(value, "empty.key.value")
    None => @test.fail("Expected value for empty key")
  }
  
  match ctx_with_normal_key.get(normal_key) {
    Some(value) => assert_eq(value, "normal.key.value")
    None => @test.fail("Expected value for normal key")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®è®¿é—®
  let nonexistent_key = create_key("nonexistent.key")
  match ctx_with_normal_key.get(nonexistent_key) {
    Some(_) => @test.fail("Expected None for nonexistent key")
    None => assert_eq(true, true)  // æ­£ç¡®è¿”å›None
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_keys = [
    create_key("special!@#$%^&*()"),
    create_key("æµ‹è¯•ä¸­æ–‡"),
    create_key("key with spaces"),
    create_key("key.with.dots"),
    create_key("key_with_underscores"),
    create_key("key-with-hyphens"),
    create_key("UPPERCASE.KEY"),
    create_key("123numeric.start"),
    create_key("very.long.key.name.with.many.parts.that.might.cause.issues.in.some.systems.but.should.work.fine.in.our.implementation")
  ]
  
  let mut i = 0
  while i < special_keys.length() {
    let special_value = "value.for." + i.to_string()
    let ctx_with_special = ctx.with_value(special_keys[i], special_value)
    
    match ctx_with_special.get(special_keys[i]) {
      Some(value) => assert_eq(value, special_value)
      None => @test.fail("Expected value for special key: " + i.to_string())
    }
    
    i = i + 1
  }
  
  // æµ‹è¯•é“¾å¼æ“ä½œçš„é”™è¯¯æ¢å¤
  let mut chain_ctx = ctx
  let mut j = 0
  while j < 1000 {
    chain_ctx = chain_ctx.with_value(create_key("chain.key." + j.to_string()), "chain.value." + j.to_string())
    j = j + 1
  }
  
  // éªŒè¯é“¾å¼æ“ä½œçš„ç»“æœ
  match chain_ctx.get(create_key("chain.key.0")) {
    Some(value) => assert_eq(value, "chain.value.0")
    None => @test.fail("Expected chain value 0")
  }
  
  match chain_ctx.get(create_key("chain.key.999")) {
    Some(value) => assert_eq(value, "chain.value.999")
    None => @test.fail("Expected chain value 999")
  }
  
  match chain_ctx.get(create_key("chain.key.500")) {
    Some(value) => assert_eq(value, "chain.value.500")
    None => @test.fail("Expected chain value 500")
  }
}

test "baggage_error_recovery" {
  // æµ‹è¯•Baggageçš„é”™è¯¯æ¢å¤å’Œå®¹é”™
  
  let baggage = Baggage::empty()
  
  // æµ‹è¯•ç©ºBaggageæ“ä½œ
  let empty_baggage = baggage.with_entry("", "")
  let normal_baggage = baggage.with_entry("normal.key", "normal.value")
  
  // éªŒè¯ç©ºé”®å€¼å¯¹
  match empty_baggage.get("") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty value for empty key")
  }
  
  match normal_baggage.get("normal.key") {
    Some(value) => assert_eq(value, "normal.value")
    None => @test.fail("Expected normal value")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®è®¿é—®
  match normal_baggage.get("nonexistent.key") {
    Some(_) => @test.fail("Expected None for nonexistent key")
    None => assert_eq(true, true)  // æ­£ç¡®è¿”å›None
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_entries = [
    ("special!@#$%^&*()", "special!@#$%^&*()"),
    ("æµ‹è¯•ä¸­æ–‡", "æµ‹è¯•ä¸­æ–‡å€¼"),
    ("key with spaces", "value with spaces"),
    ("", "empty.key.value"),
    ("empty.value", ""),
    ("unicode.key", "Unicodeå€¼ğŸš€"),
    ("very.long.key.name.that.exceeds.normal.limits", "very.long.value.name.that.exceeds.normal.limits")
  ]
  
  let mut special_baggage = baggage
  let mut i = 0
  while i < special_entries.length() {
    let (key, value) = special_entries[i]
    special_baggage = special_baggage.with_entry(key, value)
    
    match special_baggage.get(key) {
      Some(retrieved_value) => assert_eq(retrieved_value, value)
      None => @test.fail("Expected value for special key: " + key)
    }
    
    i = i + 1
  }
  
  // æµ‹è¯•é‡å¤é”®çš„å¤„ç†
  let duplicate_baggage = baggage
    .with_entry("duplicate.key", "first.value")
    .with_entry("duplicate.key", "second.value")
    .with_entry("duplicate.key", "third.value")
  
  // éªŒè¯é‡å¤é”®çš„å¤„ç†ï¼ˆåº”è¯¥ä¿ç•™æœ€åä¸€ä¸ªå€¼ï¼‰
  match duplicate_baggage.get("duplicate.key") {
    Some(value) => assert_eq(value, "third.value")
    None => @test.fail("Expected third value for duplicate key")
  }
  
  // æµ‹è¯•å¤§é‡æ¡ç›®
  let mut large_baggage = baggage
  let mut k = 0
  while k < 1000 {
    large_baggage = large_baggage.with_entry("large.key." + k.to_string(), "large.value." + k.to_string())
    k = k + 1
  }
  
  // éªŒè¯å¤§é‡æ¡ç›®çš„è®¿é—®
  match large_baggage.get("large.key.0") {
    Some(value) => assert_eq(value, "large.value.0")
    None => @test.fail("Expected large value 0")
  }
  
  match large_baggage.get("large.key.999") {
    Some(value) => assert_eq(value, "large.value.999")
    None => @test.fail("Expected large value 999")
  }
}

test "span_error_recovery" {
  // æµ‹è¯•Spançš„é”™è¯¯æ¢å¤å’Œå®¹é”™
  
  let ctx = Context::empty()
  let tracer = NoopTracer::{}
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´å€¼
  let zero_time = 0L
  let max_time = 9223372036854775807L
  let negative_time = -1L
  
  let (_, zero_span) = tracer.start_span(ctx, "zero-time-span", Internal, None, Some(zero_time))
  let (_, max_span) = tracer.start_span(ctx, "max-time-span", Internal, None, Some(max_time))
  let (_, negative_span) = tracer.start_span(ctx, "negative-time-span", Internal, None, Some(negative_time))
  
  // éªŒè¯è¾¹ç•Œæ—¶é—´å€¼
  assert_eq(zero_span.start_time_unix_nanos, zero_time)
  assert_eq(max_span.start_time_unix_nanos, max_time)
  assert_eq(negative_span.start_time_unix_nanos, negative_time)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„Spanåç§°
  let special_span_names = [
    "",
    " ",
    "special!@#$%^&*()",
    "æµ‹è¯•ä¸­æ–‡ğŸš€",
    "span with spaces",
    "span.with.dots",
    "span_with_underscores",
    "span-with-hyphens",
    "UPPERCASE_SPAN",
    "123numeric.start",
    "a".repeat(1000)  // éå¸¸é•¿çš„Spanåç§°
  ]
  
  let mut i = 0
  while i < special_span_names.length() {
    let (_, special_span) = tracer.start_span(
      ctx,
      special_span_names[i],
      Internal,
      Some([("span.type", AttributeValue::string("special"))]),
      Some(1234567890L + i.to_int64())
    )
    
    assert_eq(special_span.name, special_span_names[i])
    assert_eq(special_span.kind, Internal)
    assert_eq(special_span.attributes.length(), 1)
    
    i = i + 1
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut large_attributes = []
  let mut j = 0
  while j < 1000 {
    large_attributes.push(("large.attr." + j.to_string(), AttributeValue::string("large.value." + j.to_string())))
    j = j + 1
  }
  
  let (_, large_attr_span) = tracer.start_span(
    ctx,
    "large-attributes-span",
    Server,
    Some(large_attributes),
    Some(1234567890L)
  )
  
  // éªŒè¯å¤§é‡å±æ€§
  assert_eq(large_attr_span.attributes.length(), 1000)
  
  // æµ‹è¯•ç‰¹æ®Šå±æ€§å€¼
  let special_attributes = [
    ("empty.string", AttributeValue::string("")),
    ("zero.int", AttributeValue::int(0L)),
    ("negative.int", AttributeValue::int(-1L)),
    ("zero.float", AttributeValue::float(0.0)),
    ("negative.float", AttributeValue::float(-1.0)),
    ("false.bool", AttributeValue::bool(false)),
    ("empty.array", AttributeValue::array_string([])),
    ("inf.float", AttributeValue::float(1.0/0.0)),
    ("neg.inf.float", AttributeValue::float(-1.0/0.0)),
    ("nan.float", AttributeValue::float(0.0/0.0)),
    ("unicode.string", AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€")),
    ("special.chars", AttributeValue::string("!@#$%^&*()")),
    ("very.long.string", AttributeValue::string("a".repeat(1000)))
  ]
  
  let (_, special_attr_span) = tracer.start_span(
    ctx,
    "special-attributes-span",
    Client,
    Some(special_attributes),
    Some(1234567891L)
  )
  
  // éªŒè¯ç‰¹æ®Šå±æ€§
  assert_eq(special_attr_span.attributes.length(), 13)
}

test "log_record_error_recovery" {
  // æµ‹è¯•LogRecordçš„é”™è¯¯æ¢å¤å’Œå®¹é”™
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´å€¼
  let zero_time_log = LogRecord::{
    timestamp_unix_nanos: 0L,
    observed_timestamp_unix_nanos: Some(0L),
    severity_number: Info,
    severity_text: Some("INFO"),
    body: Some("Zero time log"),
    attributes: [],
    trace_id: None,
    span_id: None,
    trace_flags: None,
    resource: None,
    instrumentation_scope: None
  }
  
  let max_time_log = LogRecord::{
    timestamp_unix_nanos: 9223372036854775807L,
    observed_timestamp_unix_nanos: Some(9223372036854775807L),
    severity_number: Error,
    severity_text: Some("ERROR"),
    body: Some("Max time log"),
    attributes: [],
    trace_id: None,
    span_id: None,
    trace_flags: None,
    resource: None,
    instrumentation_scope: None
  }
  
  // éªŒè¯è¾¹ç•Œæ—¶é—´å€¼
  assert_eq(zero_time_log.timestamp_unix_nanos, 0L)
  assert_eq(max_time_log.timestamp_unix_nanos, 9223372036854775807L)
  
  // æµ‹è¯•ç‰¹æ®Šä¸¥é‡ç¨‹åº¦
  let severity_levels = [Trace, Debug, Info, Warn, Error, Fatal]
  let mut i = 0
  while i < severity_levels.length() {
    let severity_log = LogRecord::{
      timestamp_unix_nanos: 1234567890L + i.to_int64(),
      observed_timestamp_unix_nanos: Some(1234567891L + i.to_int64()),
      severity_number: severity_levels[i],
      severity_text: Some(match severity_levels[i] {
        Trace => "TRACE"
        Debug => "DEBUG"
        Info => "INFO"
        Warn => "WARN"
        Error => "ERROR"
        Fatal => "FATAL"
      }),
      body: Some("Severity test log"),
      attributes: [("severity.level", AttributeValue::int(i.to_int64()))],
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    }
    
    assert_eq(severity_log.severity_number, severity_levels[i])
    i = i + 1
  }
  
  // æµ‹è¯•ç‰¹æ®Šbodyå†…å®¹
  let special_bodies = [
    "",
    " ",
    "special!@#$%^&*()",
    "æµ‹è¯•ä¸­æ–‡ğŸš€",
    "body with\nnewlines\rand\ttabs",
    "a".repeat(10000),  // éå¸¸é•¿çš„body
    "body with \"quotes\" and 'apostrophes'",
    "body with \\backslashes and /forward/slashes",
    "body with <html> &entities; </html>",
    "body with {json: \"format\"} and [arrays]"
  ]
  
  let mut j = 0
  while j < special_bodies.length() {
    let special_body_log = LogRecord::{
      timestamp_unix_nanos: 1234567890L + j.to_int64(),
      observed_timestamp_unix_nanos: None,
      severity_number: Info,
      severity_text: None,
      body: Some(special_bodies[j]),
      attributes: [("body.index", AttributeValue::int(j.to_int64()))],
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    }
    
    match special_body_log.body {
      Some(body) => assert_eq(body, special_bodies[j])
      None => @test.fail("Expected body: " + j.to_string())
    }
    
    j = j + 1
  }
  
  // æµ‹è¯•ç‰¹æ®Šå±æ€§
  let special_log_attributes = [
    ("empty.string", AttributeValue::string("")),
    ("zero.int", AttributeValue::int(0L)),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("min.int", AttributeValue::int(-9223372036854775808L)),
    ("zero.float", AttributeValue::float(0.0)),
    ("inf.float", AttributeValue::float(1.0/0.0)),
    ("neg.inf.float", AttributeValue::float(-1.0/0.0)),
    ("nan.float", AttributeValue::float(0.0/0.0)),
    ("false.bool", AttributeValue::bool(false)),
    ("empty.array", AttributeValue::array_string([])),
    ("large.array", AttributeValue::array_string(Array::make(1000, "item")))
  ]
  
  let special_attr_log = LogRecord::{
    timestamp_unix_nanos: 1234567890L,
    observed_timestamp_unix_nanos: Some(1234567891L),
    severity_number: Warn,
    severity_text: Some("WARN"),
    body: Some("Special attributes log"),
    attributes: special_log_attributes,
    trace_id: Some(Array::make(16, 0xFF_byte)),
    span_id: Some(Array::make(8, 0xEE_byte)),
    trace_flags: Some(0x01_byte),
    resource: Some(Resource::default("test-service")),
    instrumentation_scope: None
  }
  
  // éªŒè¯ç‰¹æ®Šå±æ€§
  assert_eq(special_attr_log.attributes.length(), 11)
}

test "metrics_error_recovery" {
  // æµ‹è¯•Metricsçš„é”™è¯¯æ¢å¤å’Œå®¹é”™
  
  let meter = NoopMeter::{}
  
  // æµ‹è¯•è¾¹ç•Œå€¼åº¦é‡
  let counter = meter.create_counter("error.recovery.counter", "operations", "Error recovery counter")
  let histogram = meter.create_histogram("error.recovery.histogram", "seconds", "Error recovery histogram")
  let up_down_counter = meter.create_up_down_counter("error.recovery.up_down_counter", "operations", "Error recovery up-down counter")
  let gauge = meter.create_gauge("error.recovery.gauge", "bytes", "Error recovery gauge")
  
  // æµ‹è¯•æå€¼æ“ä½œ
  let extreme_values = [
    0L,  // é›¶å€¼
    1L,  // æœ€å°æ­£å€¼
    -1L,  // è´Ÿå€¼
    9223372036854775807L,  // æœ€å¤§å€¼
    -9223372036854775808L,  // æœ€å°å€¼
    1000000L,  // å¤§å€¼
    -1000000L  // å¤§è´Ÿå€¼
  ]
  
  let mut i = 0
  while i < extreme_values.length() {
    // Counteræ“ä½œ
    counter.add(extreme_values[i], Some([
      ("test.type", AttributeValue::string("extreme")),
      ("test.value", AttributeValue::int(extreme_values[i]))
    ]))
    
    // UpDownCounteræ“ä½œ
    up_down_counter.add(extreme_values[i], Some([
      ("test.type", AttributeValue::string("extreme")),
      ("test.value", AttributeValue::int(extreme_values[i]))
    ]))
    
    i = i + 1
  }
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°æ“ä½œ
  let extreme_float_values = [
    0.0,  // é›¶å€¼
    1.0e-10,  // æå°æ­£å€¼
    -1.0e-10,  // æå°è´Ÿå€¼
    1.7976931348623157e+308,  // æœ€å¤§å€¼
    -1.7976931348623157e+308,  // æœ€å°å€¼
    1.0/0.0,  // æ­£æ— ç©·å¤§
    -1.0/0.0,  // è´Ÿæ— ç©·å¤§
    0.0/0.0  // NaN
  ]
  
  let mut j = 0
  while j < extreme_float_values.length() {
    // Histogramæ“ä½œ
    histogram.record(extreme_float_values[j], Some([
      ("test.type", AttributeValue::string("extreme.float")),
      ("test.value", AttributeValue::float(extreme_float_values[j]))
    ]))
    
    // Gaugeæ“ä½œ
    gauge.record(extreme_float_values[j], Some([
      ("test.type", AttributeValue::string("extreme.float")),
      ("test.value", AttributeValue::float(extreme_float_values[j]))
    ]))
    
    j = j + 1
  }
  
  // æµ‹è¯•ç‰¹æ®Šå±æ€§
  let special_attributes = [
    ("empty.string", AttributeValue::string("")),
    ("zero.int", AttributeValue::int(0L)),
    ("false.bool", AttributeValue::bool(false)),
    ("empty.array", AttributeValue::array_string([])),
    ("unicode.string", AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€")),
    ("special.chars", AttributeValue::string("!@#$%^&*()")),
    ("very.long.string", AttributeValue::string("a".repeat(1000)))
  ]
  
  // ä½¿ç”¨ç‰¹æ®Šå±æ€§è¿›è¡Œåº¦é‡æ“ä½œ
  counter.add(1L, Some(special_attributes))
  histogram.record(1.0, Some(special_attributes))
  up_down_counter.add(1L, Some(special_attributes))
  gauge.record(1.0, Some(special_attributes))
  
  // æµ‹è¯•ç©ºå±æ€§
  counter.add(1L, None)
  histogram.record(1.0, None)
  up_down_counter.add(1L, None)
  gauge.record(1.0, None)
  
  counter.add(1L, Some([]))
  histogram.record(1.0, Some([]))
  up_down_counter.add(1L, Some([]))
  gauge.record(1.0, Some([]))
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut large_attributes = []
  let mut k = 0
  while k < 1000 {
    large_attributes.push(("large.attr." + k.to_string(), AttributeValue::int(k.to_int64())))
    k = k + 1
  }
  
  counter.add(1L, Some(large_attributes))
  histogram.record(1.0, Some(large_attributes))
  up_down_counter.add(1L, Some(large_attributes))
  gauge.record(1.0, Some(large_attributes))
}

test "propagation_error_recovery" {
  // æµ‹è¯•ä¼ æ’­çš„é”™è¯¯æ¢å¤å’Œå®¹é”™
  
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  let composite = CompositePropagator::new([trace_propagator, baggage_propagator])
  
  let ctx = Context::empty()
  
  // æµ‹è¯•æ— æ•ˆçš„traceparentæ ¼å¼
  let invalid_traceparents = [
    "",
    "invalid",
    "00-",
    "00-0af7651916cd43dd8448eb211c80319c",
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331",
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01-extra",
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-xyz",
    "gg-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"
  ]
  
  let mut i = 0
  while i < invalid_traceparents.length() {
    let carrier = MapCarrier::from_map([
      ("traceparent", invalid_traceparents[i])
    ])
    
    // å³ä½¿traceparentæ— æ•ˆï¼Œæå–ä¹Ÿä¸åº”è¯¥å´©æºƒ
    let extracted_ctx = composite.extract(ctx, carrier)
    assert_eq(true, true)
    
    i = i + 1
  }
  
  // æµ‹è¯•æ— æ•ˆçš„baggageæ ¼å¼
  let invalid_baggages = [
    "",
    "invalid",
    "key=",
    "=value",
    "key=value,invalid",
    "key=value,,",
    ",key=value",
    "key=value,"
  ]
  
  let mut j = 0
  while j < invalid_baggages.length() {
    let carrier = MapCarrier::from_map([
      ("baggage", invalid_baggages[j])
    ])
    
    // å³ä½¿baggageæ— æ•ˆï¼Œæå–ä¹Ÿä¸åº”è¯¥å´©æºƒ
    let extracted_ctx = composite.extract(ctx, carrier)
    assert_eq(true, true)
    
    j = j + 1
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„header
  let special_carriers = [
    MapCarrier::from_map([
      ("traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
      ("baggage", "æµ‹è¯•ä¸­æ–‡=value"),
      ("unicode.header", "æµ‹è¯•ä¸­æ–‡å€¼")
    ]),
    MapCarrier::from_map([
      ("traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
      ("baggage", "special!@#$%^&*()=value"),
      ("special.header", "special!@#$%^&*()")
    ]),
    MapCarrier::from_map([
      ("traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
      ("baggage", ""),
      ("empty.header", "")
    ])
  ]
  
  let mut k = 0
  while k < special_carriers.length() {
    // å³ä½¿headeråŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼Œæå–ä¹Ÿä¸åº”è¯¥å´©æºƒ
    let extracted_ctx = composite.extract(ctx, special_carriers[k])
    assert_eq(true, true)
    
    k = k + 1
  }
  
  // æµ‹è¯•æé•¿çš„headerå€¼
  let very_long_traceparent = "00-" + "a".repeat(32) + "-" + "b".repeat(16) + "-01"
  let very_long_baggage = "key=" + "value".repeat(1000)
  
  let long_carrier = MapCarrier::from_map([
    ("traceparent", very_long_traceparent),
    ("baggage", very_long_baggage)
  ])
  
  // å³ä½¿headerå€¼æé•¿ï¼Œæå–ä¹Ÿä¸åº”è¯¥å´©æºƒ
  let extracted_long_ctx = composite.extract(ctx, long_carrier)
  assert_eq(true, true)
}

test "comprehensive_error_recovery" {
  // æµ‹è¯•ç»¼åˆé”™è¯¯æ¢å¤å’Œå®¹é”™
  
  let ctx = Context::empty()
  let tracer = NoopTracer::{}
  let meter = NoopMeter::{}
  let logger_provider = NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("error.recovery.logger")
  
  // åˆ›å»ºåŒ…å«å„ç§è¾¹ç•Œæƒ…å†µçš„å¤æ‚é¥æµ‹åœºæ™¯
  let complex_ctx = ctx
    .with_value(create_key(""), "")  // ç©ºé”®å€¼å¯¹
    .with_value(create_key("special!@#$%^&*()"), "special!@#$%^&*()")  // ç‰¹æ®Šå­—ç¬¦
    .with_value(create_key("æµ‹è¯•ä¸­æ–‡"), "æµ‹è¯•ä¸­æ–‡å€¼")  // Unicode
    .with_value(create_key("very.long.key.name.that.exceeds.normal.limits"), "very.long.value.name.that.exceeds.normal.limits")
  
  // åˆ›å»ºåŒ…å«è¾¹ç•Œå€¼çš„Span
  let (_, complex_span) = tracer.start_span(
    complex_ctx,
    "complex!@#$%^&*()spanæµ‹è¯•ä¸­æ–‡",  // ç‰¹æ®Šå­—ç¬¦Spanåç§°
    Server,
    Some([
      ("empty.string", AttributeValue::string("")),
      ("zero.int", AttributeValue::int(0L)),
      ("max.int", AttributeValue::int(9223372036854775807L)),
      ("inf.float", AttributeValue::float(1.0/0.0)),
      ("nan.float", AttributeValue::float(0.0/0.0)),
      ("false.bool", AttributeValue::bool(false)),
      ("empty.array", AttributeValue::array_string([])),
      ("unicode.string", AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€"))
    ]),
    Some(9223372036854775807L)  // æœ€å¤§æ—¶é—´å€¼
  )
  
  // åˆ›å»ºåŒ…å«è¾¹ç•Œå€¼çš„LogRecord
  let complex_log_record = LogRecord::{
    timestamp_unix_nanos: 0L,  // é›¶æ—¶é—´
    observed_timestamp_unix_nanos: Some(9223372036854775807L),  // æœ€å¤§æ—¶é—´
    severity_number: Fatal,
    severity_text: Some("FATAL"),
    body: Some("Complex!@#$%^&*()logæµ‹è¯•ä¸­æ–‡"),  // ç‰¹æ®Šå­—ç¬¦body
    attributes: [
      ("empty.string", AttributeValue::string("")),
      ("zero.int", AttributeValue::int(0L)),
      ("max.int", AttributeValue::int(9223372036854775807L)),
      ("inf.float", AttributeValue::float(1.0/0.0)),
      ("nan.float", AttributeValue::float(0.0/0.0)),
      ("false.bool", AttributeValue::bool(false)),
      ("empty.array", AttributeValue::array_string([])),
      ("unicode.string", AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€"))
    ],
    trace_id: Some(Array::make(16, 0xFF_byte)),  // æœ€å¤§trace_id
    span_id: Some(Array::make(8, 0xFF_byte)),  // æœ€å¤§span_id
    trace_flags: Some(0xFF_byte),  // æœ€å¤§trace_flags
    resource: Some(Resource::default("complex!@#$%^&*()serviceæµ‹è¯•ä¸­æ–‡")),  // ç‰¹æ®Šå­—ç¬¦æœåŠ¡å
    instrumentation_scope: None
  }
  
  // åˆ›å»ºåŒ…å«è¾¹ç•Œå€¼çš„åº¦é‡
  let counter = meter.create_counter("complex!@#$%^&*()counteræµ‹è¯•ä¸­æ–‡", "operations", "Complex counter")
  let histogram = meter.create_histogram("complex!@#$%^&*()histogramæµ‹è¯•ä¸­æ–‡", "seconds", "Complex histogram")
  
  // æ‰§è¡Œè¾¹ç•Œå€¼åº¦é‡æ“ä½œ
  counter.add(9223372036854775807L, Some([
    ("empty.string", AttributeValue::string("")),
    ("zero.int", AttributeValue::int(0L)),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("inf.float", AttributeValue::float(1.0/0.0)),
    ("nan.float", AttributeValue::float(0.0/0.0)),
    ("false.bool", AttributeValue::bool(false)),
    ("empty.array", AttributeValue::array_string([])),
    ("unicode.string", AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€"))
  ]))
  
  histogram.record(1.7976931348623157e+308, Some([
    ("empty.string", AttributeValue::string("")),
    ("zero.int", AttributeValue::int(0L)),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("inf.float", AttributeValue::float(1.0/0.0)),
    ("nan.float", AttributeValue::float(0.0/0.0)),
    ("false.bool", AttributeValue::bool(false)),
    ("empty.array", AttributeValue::array_string([])),
    ("unicode.string", AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€"))
  ]))
  
  // å‘é€å¤æ‚æ—¥å¿—è®°å½•
  logger.emit(complex_log_record)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½æˆåŠŸå®Œæˆ
  assert_eq(complex_span.name, "complex!@#$%^&*()spanæµ‹è¯•ä¸­æ–‡")
  assert_eq(complex_span.start_time_unix_nanos, 9223372036854775807L)
  assert_eq(complex_span.attributes.length(), 8)
  
  assert_eq(complex_log_record.timestamp_unix_nanos, 0L)
  assert_eq(complex_log_record.severity_number, Fatal)
  match complex_log_record.body {
    Some(body) => assert_eq(body, "Complex!@#$%^&*()logæµ‹è¯•ä¸­æ–‡")
    None => @test.fail("Expected complex body")
  }
  assert_eq(complex_log_record.attributes.length(), 8)
  
  // éªŒè¯å¤æ‚Contextä»ç„¶å¯ä»¥æ­£å¸¸å·¥ä½œ
  match complex_ctx.get(create_key("")) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty key value")
  }
  
  match complex_ctx.get(create_key("æµ‹è¯•ä¸­æ–‡")) {
    Some(value) => assert_eq(value, "æµ‹è¯•ä¸­æ–‡å€¼")
    None => @test.fail("Expected Chinese key value")
  }
  
  // éªŒè¯é”™è¯¯æ¢å¤æˆåŠŸ
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œè¯´æ˜é”™è¯¯æ¢å¤æˆåŠŸ
}