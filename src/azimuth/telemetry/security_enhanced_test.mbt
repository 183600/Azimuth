// å®‰å…¨æ€§æµ‹è¯• - æµ‹è¯•æ¶æ„æ•°æ®å¤„ç†

test "malicious_attribute_value_handling" {
  // æµ‹è¯•æ¶æ„AttributeValueçš„å¤„ç†
  
  // 1. SQLæ³¨å…¥æ”»å‡»æµ‹è¯•
  let sql_injection_string = "'; DROP TABLE users; --"
  let sql_injection_attr = AttributeValue::string(sql_injection_string)
  
  match sql_injection_attr {
    StringValue(s) => {
      assert_eq(s, sql_injection_string)
      // éªŒè¯å­—ç¬¦ä¸²è¢«æ­£ç¡®å­˜å‚¨ï¼Œæ²¡æœ‰æ‰§è¡ŒSQL
      assert_eq(s.contains("DROP TABLE"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  // 2. XSSæ”»å‡»æµ‹è¯•
  let xss_string = "<script>alert('XSS')</script>"
  let xss_attr = AttributeValue::string(xss_string)
  
  match xss_attr {
    StringValue(s) => {
      assert_eq(s, xss_string)
      // éªŒè¯XSSä»£ç è¢«æ­£ç¡®å­˜å‚¨ï¼Œæ²¡æœ‰æ‰§è¡Œ
      assert_eq(s.contains("<script>"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  // 3. è·¯å¾„éå†æ”»å‡»æµ‹è¯•
  let path_traversal_string = "../../../etc/passwd"
  let path_traversal_attr = AttributeValue::string(path_traversal_string)
  
  match path_traversal_attr {
    StringValue(s) => {
      assert_eq(s, path_traversal_string)
      // éªŒè¯è·¯å¾„éå†å­—ç¬¦ä¸²è¢«æ­£ç¡®å­˜å‚¨
      assert_eq(s.contains("../"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  // 4. å‘½ä»¤æ³¨å…¥æµ‹è¯•
  let command_injection_string = "rm -rf /"
  let command_injection_attr = AttributeValue::string(command_injection_string)
  
  match command_injection_attr {
    StringValue(s) => {
      assert_eq(s, command_injection_string)
      // éªŒè¯å‘½ä»¤æ³¨å…¥å­—ç¬¦ä¸²è¢«æ­£ç¡®å­˜å‚¨ï¼Œæ²¡æœ‰æ‰§è¡Œ
      assert_eq(s.contains("rm -rf"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  // 5. Unicodeæ”»å‡»æµ‹è¯•
  let unicode_attack_string = "ğ•³ğ•°ğ•·ğ•·ğ•º ğ•ğ•ºğ•½ğ•·ğ•¯"
  let unicode_attack_attr = AttributeValue::string(unicode_attack_string)
  
  match unicode_attack_attr {
    StringValue(s) => {
      assert_eq(s, unicode_attack_string)
      // éªŒè¯Unicodeå­—ç¬¦è¢«æ­£ç¡®å­˜å‚¨
      assert_eq(s.contains("ğ•³"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  // 6. é•¿å­—ç¬¦ä¸²æ”»å‡»æµ‹è¯•ï¼ˆç¼“å†²åŒºæº¢å‡ºï¼‰
  let long_string = "A" * 1000000
  let long_string_attr = AttributeValue::string(long_string)
  
  match long_string_attr {
    StringValue(s) => {
      assert_eq(s.length(), 1000000)
      // éªŒè¯é•¿å­—ç¬¦ä¸²è¢«æ­£ç¡®å­˜å‚¨
      assert_eq(s[0], "A")
      assert_eq(s[s.length() - 1], "A")
    }
    _ => @test.fail("Test failed")
  }
  
  // 7. ç©ºå­—èŠ‚æ³¨å…¥æµ‹è¯•
  let null_byte_string = "prefix\x00\x01\x02suffix"
  let null_byte_attr = AttributeValue::string(null_byte_string)
  
  match null_byte_attr {
    StringValue(s) => {
      assert_eq(s, null_byte_string)
      // éªŒè¯ç©ºå­—èŠ‚è¢«æ­£ç¡®å­˜å‚¨
      assert_eq(s.contains("\x00"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  // 8. ç‰¹æ®Šå­—ç¬¦æ”»å‡»æµ‹è¯•
  let special_chars_string = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./\x00\x01\x02\x7f"
  let special_chars_attr = AttributeValue::string(special_chars_string)
  
  match special_chars_attr {
    StringValue(s) => {
      assert_eq(s, special_chars_string)
      // éªŒè¯ç‰¹æ®Šå­—ç¬¦è¢«æ­£ç¡®å­˜å‚¨
      assert_eq(s.contains("!@#$%"), true)
    }
    _ => @test.fail("Test failed")
  }
}

test "malicious_context_key_handling" {
  // æµ‹è¯•æ¶æ„Context Keyçš„å¤„ç†
  
  let ctx = Context::empty()
  
  // 1. SQLæ³¨å…¥åœ¨é”®åä¸­
  let sql_injection_key = create_key("'; DROP TABLE context; --")
  let ctx_with_sql = ctx.with_value(sql_injection_key, "safe_value")
  
  match ctx_with_sql.get(sql_injection_key) {
    Some(value) => assert_eq(value, "safe_value")
    None => @test.fail("Test failed")
  }
  
  // 2. XSSåœ¨é”®åä¸­
  let xss_key = create_key("<script>alert('XSS')</script>")
  let ctx_with_xss = ctx_with_sql.with_value(xss_key, "xss_value")
  
  match ctx_with_xss.get(xss_key) {
    Some(value) => assert_eq(value, "xss_value")
    None => @test.fail("Test failed")
  }
  
  // 3. è·¯å¾„éå†åœ¨é”®åä¸­
  let path_traversal_key = create_key("../../../etc/context")
  let ctx_with_path = ctx_with_xss.with_value(path_traversal_key, "path_value")
  
  match ctx_with_path.get(path_traversal_key) {
    Some(value) => assert_eq(value, "path_value")
    None => @test.fail("Test failed")
  }
  
  // 4. Unicodeæ”»å‡»åœ¨é”®åä¸­
  let unicode_key = create_key("ğ•¸ğ•¬ğ•·ğ•´ğ•®ğ•´ğ•ºğ–€ğ–˜_ğ•¶ğ•°ğ–„")
  let ctx_with_unicode = ctx_with_path.with_value(unicode_key, "unicode_value")
  
  match ctx_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, "unicode_value")
    None => @test.fail("Test failed")
  }
  
  // 5. é•¿é”®åæ”»å‡»
  let long_key_name = "A" * 10000
  let long_key = create_key(long_key_name)
  let ctx_with_long = ctx_with_unicode.with_value(long_key, "long_value")
  
  match ctx_with_long.get(long_key) {
    Some(value) => assert_eq(value, "long_value")
    None => @test.fail("Test failed")
  }
  
  // 6. ç©ºå­—èŠ‚åœ¨é”®åä¸­
  let null_byte_key = create_key("key\x00\x01\x02injection")
  let ctx_with_null = ctx_with_long.with_value(null_byte_key, "null_value")
  
  match ctx_with_null.get(null_byte_key) {
    Some(value) => assert_eq(value, "null_value")
    None => @test.fail("Test failed")
  }
  
  // 7. ç‰¹æ®Šå­—ç¬¦åœ¨é”®åä¸­
  let special_chars_key = create_key("!@#$%^&*()_+-={}[]|\\:;\"'<>?,./key")
  let ctx_with_special = ctx_with_null.with_value(special_chars_key, "special_value")
  
  match ctx_with_special.get(special_chars_key) {
    Some(value) => assert_eq(value, "special_value")
    None => @test.failed")
  }
  
  // 8. éªŒè¯æ‰€æœ‰æ¶æ„é”®éƒ½æ­£ç¡®å¤„ç†
  assert_eq(ctx_with_special.get(sql_injection_key).unwrap(), "safe_value")
  assert_eq(ctx_with_special.get(xss_key).unwrap(), "xss_value")
  assert_eq(ctx_with_special.get(path_traversal_key).unwrap(), "path_value")
  assert_eq(ctx_with_special.get(unicode_key).unwrap(), "unicode_value")
  assert_eq(ctx_with_special.get(long_key).unwrap(), "long_value")
  assert_eq(ctx_with_special.get(null_byte_key).unwrap(), "null_value")
  assert_eq(ctx_with_special.get(special_chars_key).unwrap(), "special_value")
}

test "malicious_span_name_handling" {
  // æµ‹è¯•æ¶æ„Spanåç§°çš„å¤„ç†
  
  let ctx = Context::empty()
  
  // 1. SQLæ³¨å…¥åœ¨Spanåç§°ä¸­
  let sql_injection_span_name = "'; DROP TABLE spans; --"
  let (_, sql_span) = NoopTracer::start_span(
    ctx,
    sql_injection_span_name,
    Server,
    Some([("test.type", AttributeValue::string("sql_injection"))])
  )
  
  assert_eq(sql_span.name, sql_injection_span_name)
  assert_eq(sql_span.name.contains("DROP TABLE"), true)
  
  // 2. XSSåœ¨Spanåç§°ä¸­
  let xss_span_name = "<script>alert('XSS in span')</script>"
  let (_, xss_span) = NoopTracer::start_span(
    ctx,
    xss_span_name,
    Server,
    Some([("test.type", AttributeValue::string("xss"))])
  )
  
  assert_eq(xss_span.name, xss_span_name)
  assert_eq(xss_span.name.contains("<script>"), true)
  
  // 3. é•¿Spanåç§°æ”»å‡»
  let long_span_name = "A" * 100000
  let (_, long_span) = NoopTracer::start_span(
    ctx,
    long_span_name,
    Server,
    Some([("test.type", AttributeValue::string("long_name"))])
  )
  
  assert_eq(long_span.name.length(), 100000)
  assert_eq(long_span.name[0], "A")
  assert_eq(long_span.name[long_span.name.length() - 1], "A")
  
  // 4. Unicodeæ”»å‡»åœ¨Spanåç§°ä¸­
  let unicode_span_name = "ğ•¾ğ–•ğ–†ğ–†_ğ–‚ğ–ğ–™ğ–_ğ–€ğ–šğ–“ğ–ğ–ˆğ–”ğ–‰ğ–Š"
  let (_, unicode_span) = NoopTracer::start_span(
    ctx,
    unicode_span_name,
    Server,
    Some([("test.type", AttributeValue::string("unicode"))])
  )
  
  assert_eq(unicode_span.name, unicode_span_name)
  assert_eq(unicode_span.name.contains("ğ•¾"), true)
  
  // 5. ç‰¹æ®Šå­—ç¬¦åœ¨Spanåç§°ä¸­
  let special_chars_span_name = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./span"
  let (_, special_span) = NoopTracer::start_span(
    ctx,
    special_chars_span_name,
    Server,
    Some([("test.type", AttributeValue::string("special_chars"))])
  )
  
  assert_eq(special_span.name, special_chars_span_name)
  assert_eq(special_span.name.contains("!@#$%"), true)
  
  // 6. ç©ºå­—èŠ‚åœ¨Spanåç§°ä¸­
  let null_byte_span_name = "span\x00\x01\x02injection"
  let (_, null_span) = NoopTracer::start_span(
    ctx,
    null_byte_span_name,
    Server,
    Some([("test.type", AttributeValue::string("null_bytes"))])
  )
  
  assert_eq(null_span.name, null_byte_span_name)
  assert_eq(null_span.name.contains("\x00"), true)
  
  // 7. æ ¼å¼åŒ–å­—ç¬¦ä¸²æ”»å‡»
  let format_string_span_name = "%s%s%s%s%s%s%s%s"
  let (_, format_span) = NoopTracer::start_span(
    ctx,
    format_string_span_name,
    Server,
    Some([("test.type", AttributeValue::string("format_string"))])
  )
  
  assert_eq(format_span.name, format_string_span_name)
  assert_eq(format_span.name.contains("%s"), true)
}

test "malicious_log_record_handling" {
  // æµ‹è¯•æ¶æ„LogRecordçš„å¤„ç†
  
  let logger = NoopLogger::{}
  
  // 1. SQLæ³¨å…¥åœ¨æ—¥å¿—æ¶ˆæ¯ä¸­
  let sql_injection_log = LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(Error)
    .body("'; DROP TABLE logs; --")
    .with_attribute("attack.type", AttributeValue::string("sql_injection"))
    .build()
  
  logger.emit(sql_injection_log)
  
  match sql_injection_log.body {
    Some(message) => {
      assert_eq(message, "'; DROP TABLE logs; --")
      assert_eq(message.contains("DROP TABLE"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // 2. XSSåœ¨æ—¥å¿—æ¶ˆæ¯ä¸­
  let xss_log = LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(Error)
    .body("<script>alert('XSS in log')</script>")
    .with_attribute("attack.type", AttributeValue::string("xss"))
    .build()
  
  logger.emit(xss_log)
  
  match xss_log.body {
    Some(message) => {
      assert_eq(message, "<script>alert('XSS in log')</script>")
      assert_eq(message.contains("<script>"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // 3. é•¿æ—¥å¿—æ¶ˆæ¯æ”»å‡»
  let long_message = "A" * 1000000
  let long_log = LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(Error)
    .body(long_message)
    .with_attribute("attack.type", AttributeValue::string("long_message"))
    .build()
  
  logger.emit(long_log)
  
  match long_log.body {
    Some(message) => {
      assert_eq(message.length(), 1000000)
      assert_eq(message[0], "A")
      assert_eq(message[message.length() - 1], "A")
    }
    None => @test.fail("Test failed")
  }
  
  // 4. æ¶æ„å±æ€§åœ¨æ—¥å¿—ä¸­
  let malicious_attributes = [
    ("sql.injection", AttributeValue::string("'; DROP TABLE attributes; --")),
    ("xss.attack", AttributeValue::string("<script>alert('XSS')</script>")),
    ("path.traversal", AttributeValue::string("../../../etc/passwd")),
    ("command.injection", AttributeValue::string("rm -rf /")),
    ("unicode.attack", AttributeValue::string("ğ•¸ğ•¬ğ•·ğ•´ğ•®ğ•´ğ•ºğ–€ğ–˜")),
    ("null.bytes", AttributeValue::string("prefix\x00\x01\x02suffix"))
  ]
  
  let malicious_log = LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(Error)
    .body("Log with malicious attributes")
    .with_attribute("attack.type", AttributeValue::string("malicious_attributes"))
    .build()
  
  // æ‰‹åŠ¨åˆ›å»ºåŒ…å«æ¶æ„å±æ€§çš„LogRecord
  let full_malicious_log = LogRecord::{
    timestamp_unix_nanos: 1640995200000000000L,
    observed_timestamp_unix_nanos: None,
    severity_number: Error,
    severity_text: Some("MALICIOUS_LOG"),
    body: Some("Log with malicious attributes"),
    attributes: malicious_attributes,
    trace_id: None,
    span_id: None,
    trace_flags: None,
    resource: None,
    instrumentation_scope: None
  }
  
  logger.emit(full_malicious_log)
  
  // éªŒè¯æ¶æ„å±æ€§è¢«æ­£ç¡®å­˜å‚¨
  assert_eq(full_malicious_log.attributes.length(), 6)
  match full_malicious_log.attributes[0].1 {
    StringValue(value) => {
      assert_eq(value, "'; DROP TABLE attributes; --")
      assert_eq(value.contains("DROP TABLE"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  match full_malicious_log.attributes[1].1 {
    StringValue(value) => {
      assert_eq(value, "<script>alert('XSS')</script>")
      assert_eq(value.contains("<script>"), true)
    }
    _ => @test.fail("Test failed")
  }
  
  // 5. æ¶æ„ä¸¥é‡æ€§æ–‡æœ¬
  let malicious_severity_log = LogRecord::builder()
    .timestamp(1640995200000000000L)
    .severity(Error)
    .severity_text("'; DROP TABLE severity; --")
    .body("Log with malicious severity text")
    .with_attribute("attack.type", AttributeValue::string("malicious_severity"))
    .build()
  
  logger.emit(malicious_severity_log)
  
  match malicious_severity_log.severity_text {
    Some(text) => {
      assert_eq(text, "'; DROP TABLE severity; --")
      assert_eq(text.contains("DROP TABLE"), true)
    }
    None => @test.fail("Test failed")
  }
}

test "malicious_baggage_handling" {
  // æµ‹è¯•æ¶æ„Baggageçš„å¤„ç†
  
  // 1. SQLæ³¨å…¥åœ¨Baggageæ¡ç›®ä¸­
  let sql_injection_baggage = Baggage::empty()
    .with_entry("'; DROP TABLE baggage; --", "sql_value")
    .with_entry("safe_key", "'; DROP TABLE baggage; --")
  
  match sql_injection_baggage.get("'; DROP TABLE baggage; --") {
    Some(value) => {
      assert_eq(value, "sql_value")
      assert_eq(value.contains("sql_value"), true)
    }
    None => @test.fail("Test failed")
  }
  
  match sql_injection_baggage.get("safe_key") {
    Some(value) => {
      assert_eq(value, "'; DROP TABLE baggage; --")
      assert_eq(value.contains("DROP TABLE"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // 2. XSSåœ¨Baggageæ¡ç›®ä¸­
  let xss_baggage = Baggage::empty()
    .with_entry("<script>alert('XSS')</script>", "xss_value")
    .with_entry("xss_key", "<script>alert('XSS')</script>")
  
  match xss_baggage.get("<script>alert('XSS')</script>") {
    Some(value) => {
      assert_eq(value, "xss_value")
      assert_eq(value.contains("xss_value"), true)
    }
    None => @test.fail("Test failed")
  }
  
  match xss_baggage.get("xss_key") {
    Some(value) => {
      assert_eq(value, "<script>alert('XSS')</script>")
      assert_eq(value.contains("<script>"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // 3. é•¿é”®å€¼åœ¨Baggageä¸­
  let long_key = "A" * 10000
  let long_value = "B" * 10000
  let long_baggage = Baggage::empty()
    .with_entry(long_key, long_value)
  
  match long_baggage.get(long_key) {
    Some(value) => {
      assert_eq(value.length(), 10000)
      assert_eq(value[0], "B")
      assert_eq(value[value.length() - 1], "B")
    }
    None => @test.fail("Test failed")
  }
  
  // 4. Unicodeæ”»å‡»åœ¨Baggageä¸­
  let unicode_baggage = Baggage::empty()
    .with_entry("ğ•¸ğ•¬ğ•·ğ•´ğ•®ğ•´ğ•ºğ–€ğ–˜_ğ•¶ğ•°ğ–„", "ğ•¸ğ•¬ğ•·ğ•´ğ•®ğ•´ğ•ºğ–€ğ–˜_ğ–ğ•¬ğ•·ğ–€ğ–€ğ•´ğ•°")
  
  match unicode_baggage.get("ğ•¸ğ•¬ğ•·ğ•´ğ•®ğ•´ğ•ºğ–€ğ–˜_ğ•¶ğ•°ğ–„") {
    Some(value) => {
      assert_eq(value, "ğ•¸ğ•¬ğ•·ğ•´ğ•®ğ•´ğ•ºğ–€ğ–˜_ğ–ğ•¬ğ•·ğ–€ğ–€ğ•´ğ•°")
      assert_eq(value.contains("ğ•¸"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // 5. ç‰¹æ®Šå­—ç¬¦åœ¨Baggageä¸­
  let special_baggage = Baggage::empty()
    .with_entry("!@#$%^&*()_+-={}[]|\\:;\"'<>?,./key", "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./value")
  
  match special_baggage.get("!@#$%^&*()_+-={}[]|\\:;\"'<>?,./key") {
    Some(value) => {
      assert_eq(value, "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./value")
      assert_eq(value.contains("!@#$%"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // 6. ç©ºå­—èŠ‚åœ¨Baggageä¸­
  let null_byte_baggage = Baggage::empty()
    .with_entry("key\x00\x01\x02injection", "value\x00\x01\x02injection")
  
  match null_byte_baggage.get("key\x00\x01\x02injection") {
    Some(value) => {
      assert_eq(value, "value\x00\x01\x02injection")
      assert_eq(value.contains("\x00"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // 7. è·¯å¾„éå†åœ¨Baggageä¸­
  let path_baggage = Baggage::empty()
    .with_entry("../../../etc/baggage", "../../../etc/passwd")
  
  match path_baggage.get("../../../etc/baggage") {
    Some(value) => {
      assert_eq(value, "../../../etc/passwd")
      assert_eq(value.contains("../"), true)
    }
    None => @test.fail("Test failed")
  }
}

test "malicious_propagation_data_handling" {
  // æµ‹è¯•æ¶æ„ä¼ æ’­æ•°æ®çš„å¤„ç†
  
  // 1. æ¶æ„traceparent header
  let malicious_traceparent = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01'; DROP TABLE traces; --"
  let malicious_carrier = MapCarrier::from_map([
    ("traceparent", malicious_traceparent),
    ("baggage", "user_id='; DROP TABLE users; --")
  ])
  
  let w3c_propagator = W3CTraceContextPropagator::{}
  let ctx = Context::empty()
  
  // æµ‹è¯•æå–æ¶æ„traceparentä¸ä¼šå´©æºƒ
  let extracted_ctx = w3c_propagator.extract(ctx, malicious_carrier)
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
  
  // 2. æ¶æ„baggage header
  let malicious_baggage = "user_id=<script>alert('XSS')</script>,session_id=../../../etc/passwd"
  let baggage_carrier = MapCarrier::from_map([
    ("baggage", malicious_baggage),
    ("traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  ])
  
  let baggage_propagator = W3CBaggagePropagator::{}
  
  // æµ‹è¯•æå–æ¶æ„baggageä¸ä¼šå´©æºƒ
  let baggage_extracted_ctx = baggage_propagator.extract(ctx, baggage_carrier)
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
  
  // 3. æ ¼å¼é”™è¯¯çš„traceparent
  let malformed_traceparents = [
    "invalid-traceparent-format",
    "00-not-hex-trace-id-b7ad6b7169203331-01",
    "00-0af7651916cd43dd8448eb211c80319c-not-hex-span-id-01",
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-not-hex-flags",
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331",  // ç¼ºå°‘flags
    "00-0af7651916cd43dd8448eb211c80319c",  // ç¼ºå°‘span_idå’Œflags
    "00",  // åªæœ‰ç‰ˆæœ¬
    "",  // ç©ºå­—ç¬¦ä¸²
    "01-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01-extra-data"  // é¢å¤–æ•°æ®
  ]
  
  let mut i = 0
  while i < malformed_traceparents.length() {
    let malformed_carrier = MapCarrier::from_map([
      ("traceparent", malformed_traceparents[i])
    ])
    
    // æµ‹è¯•æ ¼å¼é”™è¯¯çš„traceparentä¸ä¼šå´©æºƒ
    let malformed_extracted_ctx = w3c_propagator.extract(ctx, malformed_carrier)
    assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
    i = i + 1
  }
  
  // 4. æ ¼å¼é”™è¯¯çš„baggage
  let malformed_baggages = [
    "malformed=baggage=format",
    "key=",
    "=value",
    "key",
    "key=value=with=too=many=equals",
    "key=value;invalid-properties",
    "key=value;property=",
    "key=value;=invalid-property",
    "key=value;property\x00with\x00nulls"
  ]
  
  let mut j = 0
  while j < malformed_baggages.length() {
    let malformed_baggage_carrier = MapCarrier::from_map([
      ("baggage", malformed_baggages[j])
    ])
    
    // æµ‹è¯•æ ¼å¼é”™è¯¯çš„baggageä¸ä¼šå´©æºƒ
    let malformed_baggage_extracted_ctx = baggage_propagator.extract(ctx, malformed_baggage_carrier)
    assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
    j = j + 1
  }
  
  // 5. è¶…é•¿header
  let very_long_traceparent = "00-" + "a" * 32 + "-" + "b" * 16 + "-01"
  let very_long_baggage = "key=" + "c" * 10000
  
  let very_long_carrier = MapCarrier::from_map([
    ("traceparent", very_long_traceparent),
    ("baggage", very_long_baggage)
  ])
  
  // æµ‹è¯•è¶…é•¿headerä¸ä¼šå´©æºƒ
  let very_long_extracted_ctx = w3c_propagator.extract(ctx, very_long_carrier)
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
  
  // 6. Unicodeæ”»å‡»header
  let unicode_traceparent = "00-ğ•µğ–“ğ–ğ–ˆğ–”ğ–‰ğ–Šğ•¿ğ–—ğ–†ğ–ˆğ–Šğ•´ğ–‰-ğ•´ğ–“ğ–ğ–ˆğ–”ğ–‰ğ–Šğ•¾ğ–•ğ–†ğ–“ğ•´ğ–‰-01"
  let unicode_baggage = "ğ–€ğ–“ğ–ğ–ˆğ–”ğ–‰ğ–Šğ•¶ğ–Šğ–=ğ–€ğ–“ğ–ğ–ˆğ–”ğ–‰ğ–Šğ–ğ–†ğ–‘ğ–šğ–Š"
  
  let unicode_carrier = MapCarrier::from_map([
    ("traceparent", unicode_traceparent),
    ("baggage", unicode_baggage)
  ])
  
  // æµ‹è¯•Unicode headerä¸ä¼šå´©æºƒ
  let unicode_extracted_ctx = w3c_propagator.extract(ctx, unicode_carrier)
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
  
  // 7. å¤åˆä¼ æ’­å™¨æ¶æ„æ•°æ®å¤„ç†
  let composite_propagator = CompositePropagator::new([w3c_propagator, baggage_propagator])
  let composite_malicious_carrier = MapCarrier::from_map([
    ("traceparent", malicious_traceparent),
    ("baggage", malicious_baggage),
    ("malicious-header", "malicious-value")
  ])
  
  // æµ‹è¯•å¤åˆä¼ æ’­å™¨å¤„ç†æ¶æ„æ•°æ®ä¸ä¼šå´©æºƒ
  let composite_extracted_ctx = composite_propagator.extract(ctx, composite_malicious_carrier)
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
}