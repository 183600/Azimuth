// é¥æµ‹å›½é™…åŒ–æ”¯æŒæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•å¤šè¯­è¨€ã€æ—¶åŒºã€ç¼–ç ç­‰å›½é™…åŒ–åŠŸèƒ½

test "multi_language_error_messages" {
  // æµ‹è¯•å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  
  let error_codes = [
    "TIMEOUT_ERROR",
    "CONNECTION_FAILED", 
    "INVALID_DATA",
    "RATE_LIMIT_EXCEEDED"
  ]
  
  let translations = {
    "en": {
      "TIMEOUT_ERROR": "Request timeout after 30 seconds",
      "CONNECTION_FAILED": "Failed to connect to collector",
      "INVALID_DATA": "Invalid telemetry data format",
      "RATE_LIMIT_EXCEEDED": "Rate limit exceeded"
    },
    "zh": {
      "TIMEOUT_ERROR": "è¯·æ±‚åœ¨30ç§’åè¶…æ—¶",
      "CONNECTION_FAILED": "è¿æ¥æ”¶é›†å™¨å¤±è´¥",
      "INVALID_DATA": "æ— æ•ˆçš„é¥æµ‹æ•°æ®æ ¼å¼",
      "RATE_LIMIT_EXCEEDED": "è¶…è¿‡é€Ÿç‡é™åˆ¶"
    },
    "ja": {
      "TIMEOUT_ERROR": "30ç§’å¾Œã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ",
      "CONNECTION_FAILED": "ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã¸ã®æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ",
      "INVALID_DATA": "ç„¡åŠ¹ãªãƒ†ãƒ¬ãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿å½¢å¼",
      "RATE_LIMIT_EXCEEDED": "ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’è¶…ãˆã¾ã—ãŸ"
    }
  }
  
  let supported_languages = ["en", "zh", "ja"]
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„é”™è¯¯æ¶ˆæ¯
  for lang in supported_languages {
    for error_code in error_codes {
      let localized_message = ""
      
      // è·å–æœ¬åœ°åŒ–æ¶ˆæ¯
      if lang == "en" {
        localized_message = translations["en"][error_code]
      } else if lang == "zh" {
        localized_message = translations["zh"][error_code]
      } else if lang == "ja" {
        localized_message = translations["ja"][error_code]
      }
      
      // éªŒè¯æ¶ˆæ¯ä¸ä¸ºç©º
      assert_eq(localized_message.length() > 0, true)
      
      // éªŒè¯ç‰¹å®šè¯­è¨€çš„å­—ç¬¦ç‰¹å¾
      if lang == "zh" {
        assert_eq(error_code == "TIMEOUT_ERROR" && localized_message.contains("è¶…æ—¶"), true)
      } else if lang == "ja" {
        assert_eq(error_code == "TIMEOUT_ERROR" && localized_message.contains("ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"), true)
      } else if lang == "en" {
        assert_eq(error_code == "TIMEOUT_ERROR" && localized_message.contains("timeout"), true)
      }
    }
  }
  
  // éªŒè¯è¯­è¨€æ”¯æŒæ•°é‡
  assert_eq(supported_languages.length(), 3)
  assert_eq(error_codes.length(), 4)
}

test "timezone_aware_timestamps" {
  // æµ‹è¯•æ—¶åŒºæ„ŸçŸ¥çš„æ—¶é—´æˆ³
  
  let utc_timestamp = 1640995200L  // 2022-01-01 00:00:00 UTC
  let timezones = [
    ("UTC", 0),
    ("America/New_York", -5),      // EST (UTC-5)
    ("Europe/London", 0),          // GMT (UTC+0)
    ("Asia/Shanghai", 8),          // CST (UTC+8)
    ("Asia/Tokyo", 9)              // JST (UTC+9)
  ]
  
  // æµ‹è¯•æ¯ä¸ªæ—¶åŒºçš„æ—¶é—´è½¬æ¢
  for timezone in timezones {
    let timezone_name = timezone.0
    let offset_hours = timezone.1
    
    // è®¡ç®—æ—¶åŒºåç§»åçš„æ—¶é—´æˆ³
    let offset_seconds = offset_hours * 3600
    let localized_timestamp = utc_timestamp + offset_seconds
    
    // éªŒè¯æ—¶åŒºåç§»è®¡ç®—
    if timezone_name == "UTC" {
      assert_eq(localized_timestamp, utc_timestamp)
    } else if timezone_name == "Asia/Shanghai" {
      assert_eq(localized_timestamp, utc_timestamp + 8 * 3600)
    } else if timezone_name == "America/New_York" {
      assert_eq(localized_timestamp, utc_timestamp - 5 * 3600)
    }
    
    // æ ¼å¼åŒ–æ—¶é—´æˆ³ä¸ºå­—ç¬¦ä¸²
    let timestamp_str = localized_timestamp.to_string()
    assert_eq(timestamp_str.length() > 0, true)
  }
  
  // éªŒè¯æ—¶åŒºæ•°é‡
  assert_eq(timezones.length(), 5)
  
  // éªŒè¯æ—¶åŒºåç§»èŒƒå›´
  let mut min_offset = 0
  let mut max_offset = 0
  
  for timezone in timezones {
    let offset = timezone.1
    if offset < min_offset { min_offset = offset }
    if offset > max_offset { max_offset = offset }
  }
  
  assert_eq(min_offset, -5)   // çº½çº¦æ˜¯æœ€æ—©çš„æ—¶åŒº
  assert_eq(max_offset, 9)    // ä¸œäº¬æ˜¯æœ€æ™šçš„æ—¶åŒº
}

test "character_encoding_handling" {
  // æµ‹è¯•å­—ç¬¦ç¼–ç å¤„ç†
  
  let test_messages = [
    ("English", "Telemetry data processing completed successfully"),
    ("Chinese", "é¥æµ‹æ•°æ®å¤„ç†æˆåŠŸå®Œæˆ"),
    ("Japanese", "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿å‡¦ç†ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ"),
    ("Emoji", "Processing complete âœ… ğŸ“Š ğŸ“ˆ"),
    ("Mixed", "é¥æµ‹ Telemetry ãƒ‡ãƒ¼ã‚¿ Data å‡¦ç† Processing")
  ]
  
  let encoding_results = []
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„ç¼–ç å¤„ç†
  for message in test_messages {
    let language = message.0
    let content = message.1
    
    // æ¨¡æ‹ŸUTF-8ç¼–ç å¤„ç†
    let encoded_length = content.length()  // ç®€åŒ–çš„é•¿åº¦è®¡ç®—
    let is_utf8_compatible = true
    
    // æ£€æŸ¥ç‰¹æ®Šå­—ç¬¦
    let contains_unicode = content.contains("é¥") || content.contains("ãƒ†") || content.contains("âœ…")
    
    // éªŒè¯ç¼–ç ç»“æœ
    encoding_results.push((language, encoded_length, is_utf8_compatible, contains_unicode))
    
    // åŸºæœ¬éªŒè¯
    assert_eq(encoded_length > 0, true)
    assert_eq(is_utf8_compatible, true)
  }
  
  // éªŒè¯ç¼–ç ç»“æœæ•°é‡
  assert_eq(encoding_results.length(), 5)
  
  // éªŒè¯Unicodeå­—ç¬¦æ£€æµ‹
  let mut unicode_count = 0
  for result in encoding_results {
    if result.3 {
      unicode_count = unicode_count + 1
    }
  }
  assert_eq(unicode_count, 4)  // Chinese, Japanese, Emoji, MixedåŒ…å«Unicodeå­—ç¬¦
}

test "locale_specific_number_formatting" {
  // æµ‹è¯•æœ¬åœ°åŒ–æ•°å­—æ ¼å¼
  
  let number = 1234.567
  let locales = [
    ("en-US", "1,234.567"),      // ç¾å¼è‹±è¯­
    ("de-DE", "1.234,567"),      // å¾·è¯­
    ("fr-FR", "1 234,567"),      // æ³•è¯­
    ("zh-CN", "1,234.567"),      // ç®€ä½“ä¸­æ–‡
    ("ja-JP", "1,234.567")       // æ—¥è¯­
  ]
  
  let formatted_numbers = []
  
  // æµ‹è¯•æ¯ç§åœ°åŒºçš„æ•°å­—æ ¼å¼
  for locale in locales {
    let locale_code = locale.0
    let expected_format = locale.1
    let formatted_number = ""
    
    // æ¨¡æ‹Ÿæœ¬åœ°åŒ–æ ¼å¼åŒ–
    if locale_code == "en-US" || locale_code == "zh-CN" || locale_code == "ja-JP" {
      formatted_number = "1,234.567"  // é€—å·ä½œä¸ºåƒä½åˆ†éš”ç¬¦ï¼Œç‚¹ä½œä¸ºå°æ•°ç‚¹
    } else if locale_code == "de-DE" {
      formatted_number = "1.234,567"  // ç‚¹ä½œä¸ºåƒä½åˆ†éš”ç¬¦ï¼Œé€—å·ä½œä¸ºå°æ•°ç‚¹
    } else if locale_code == "fr-FR" {
      formatted_number = "1 234,567"  // ç©ºæ ¼ä½œä¸ºåƒä½åˆ†éš”ç¬¦ï¼Œé€—å·ä½œä¸ºå°æ•°ç‚¹
    }
    
    formatted_numbers.push((locale_code, formatted_number))
    
    // éªŒè¯æ ¼å¼åŒ–ç»“æœ
    assert_eq(formatted_number, expected_format)
    assert_eq(formatted_number.contains("1"), true)
    assert_eq(formatted_number.contains("234"), true)
    assert_eq(formatted_number.contains("567"), true)
  }
  
  // éªŒè¯æ ¼å¼åŒ–ç»“æœæ•°é‡
  assert_eq(formatted_numbers.length(), 5)
  
  // éªŒè¯ä¸åŒåœ°åŒºçš„æ ¼å¼å·®å¼‚
  let us_format = formatted_numbers[0].1
  let german_format = formatted_numbers[1].1
  let french_format = formatted_numbers[2].1
  
  assert_eq(us_format != german_format, true)  // ç¾å¼å’Œå¾·å¼æ ¼å¼ä¸åŒ
  assert_eq(german_format != french_format, true)  // å¾·å¼å’Œæ³•å¼æ ¼å¼ä¸åŒ
  assert_eq(us_format != french_format, true)  // ç¾å¼å’Œæ³•å¼æ ¼å¼ä¸åŒ
}

test "rtl_language_support" {
  // æµ‹è¯•ä»å³åˆ°å·¦(RTL)è¯­è¨€æ”¯æŒ
  
  let rtl_languages = ["ar", "he", "fa"]  // é˜¿æ‹‰ä¼¯è¯­ã€å¸Œä¼¯æ¥è¯­ã€æ³¢æ–¯è¯­
  let ltr_languages = ["en", "zh", "ja"]  // ä»å·¦åˆ°å³è¯­è¨€
  
  let test_text = "Error: Connection failed"
  
  // æµ‹è¯•RTLè¯­è¨€å¤„ç†
  let rtl_directions = []
  for lang in rtl_languages {
    let is_rtl = true
    let processed_text = ""
    
    // æ¨¡æ‹ŸRTLæ–‡æœ¬å¤„ç†
    if lang == "ar" {
      processed_text = "Ø®Ø·Ø£: ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„"
    } else if lang == "he" {
      processed_text = "×©×’×™××”: ×”×—×™×‘×•×¨ × ×›×©×œ"
    } else if lang == "fa" {
      processed_text = "Ø®Ø·Ø§: Ø¨Ø±Ù‚Ø±Ø§Ø±ÛŒ Ø§Ø±ØªØ¨Ø§Ø· Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯"
    }
    
    rtl_directions.push((lang, is_rtl, processed_text))
    
    // éªŒè¯RTLå¤„ç†
    assert_eq(is_rtl, true)
    assert_eq(processed_text.length() > 0, true)
  }
  
  // æµ‹è¯•LTRè¯­è¨€å¤„ç†
  let ltr_directions = []
  for lang in ltr_languages {
    let is_rtl = false
    let processed_text = test_text  // LTRè¯­è¨€ä¿æŒåŸæ ·
    
    ltr_directions.push((lang, is_rtl, processed_text))
    
    // éªŒè¯LTRå¤„ç†
    assert_eq(is_rtl, false)
    assert_eq(processed_text, test_text)
  }
  
  // éªŒè¯æ–¹å‘æ£€æµ‹ç»“æœ
  assert_eq(rtl_directions.length(), 3)
  assert_eq(ltr_directions.length(), 3)
  
  // éªŒè¯æ‰€æœ‰RTLè¯­è¨€éƒ½è¢«æ­£ç¡®æ ‡è¯†
  for direction in rtl_directions {
    assert_eq(direction.1, true)
  }
  
  // éªŒè¯æ‰€æœ‰LTRè¯­è¨€éƒ½è¢«æ­£ç¡®æ ‡è¯†
  for direction in ltr_directions {
    assert_eq(direction.1, false)
  }
}

test "currency_and_unit_localization" {
  // æµ‹è¯•è´§å¸å’Œå•ä½æœ¬åœ°åŒ–
  
  let amount = 1234.56
  let currency_localizations = [
    ("en-US", "USD", "$1,234.56"),
    ("en-GB", "GBP", "Â£1,234.56"),
    ("de-DE", "EUR", "1.234,56 â‚¬"),
    ("ja-JP", "JPY", "Â¥1,235"),
    ("zh-CN", "CNY", "Â¥1,234.56")
  ]
  
  let localized_currencies = []
  
  // æµ‹è¯•è´§å¸æœ¬åœ°åŒ–
  for localization in currency_localizations {
    let locale = localization.0
    let currency = localization.1
    let expected_format = localization.2
    let formatted_amount = ""
    
    // æ¨¡æ‹Ÿè´§å¸æ ¼å¼åŒ–
    if locale == "en-US" {
      formatted_amount = "$1,234.56"
    } else if locale == "en-GB" {
      formatted_amount = "Â£1,234.56"
    } else if locale == "de-DE" {
      formatted_amount = "1.234,56 â‚¬"
    } else if locale == "ja-JP" {
      formatted_amount = "Â¥1,235"  // æ—¥å…ƒæ²¡æœ‰å°æ•°
    } else if locale == "zh-CN" {
      formatted_amount = "Â¥1,234.56"
    }
    
    localized_currencies.push((locale, currency, formatted_amount))
    
    // éªŒè¯è´§å¸æ ¼å¼
    assert_eq(formatted_amount, expected_format)
    assert_eq(formatted_amount.contains("1"), true)
  }
  
  // éªŒè¯è´§å¸æœ¬åœ°åŒ–ç»“æœ
  assert_eq(localized_currencies.length(), 5)
  
  // æµ‹è¯•å•ä½æœ¬åœ°åŒ–
  let distance = 1000.0
  let unit_localizations = [
    ("en-US", "mi", "621.37 mi"),
    ("en-GB", "mi", "621.37 mi"),
    ("de-DE", "km", "1,000.00 km"),
    ("ja-JP", "km", "1,000.00 km"),
    ("zh-CN", "å…¬é‡Œ", "1,000.00 å…¬é‡Œ")
  ]
  
  let localized_units = []
  
  for localization in unit_localizations {
    let locale = localization.0
    let unit = localization.1
    let expected_format = localization.2
    let formatted_distance = ""
    
    // æ¨¡æ‹Ÿè·ç¦»æ ¼å¼åŒ–
    if locale == "en-US" || locale == "en-GB" {
      formatted_distance = "621.37 mi"  // è‹±é‡Œ
    } else if locale == "de-DE" || locale == "ja-JP" {
      formatted_distance = "1,000.00 km"  // å…¬é‡Œ
    } else if locale == "zh-CN" {
      formatted_distance = "1,000.00 å…¬é‡Œ"  // å…¬é‡Œï¼ˆä¸­æ–‡ï¼‰
    }
    
    localized_units.push((locale, unit, formatted_distance))
    
    // éªŒè¯å•ä½æ ¼å¼
    assert_eq(formatted_distance, expected_format)
  }
  
  // éªŒè¯å•ä½æœ¬åœ°åŒ–ç»“æœ
  assert_eq(localized_units.length(), 5)
}

test "date_time_localization" {
  // æµ‹è¯•æ—¥æœŸæ—¶é—´æœ¬åœ°åŒ–
  
  let timestamp = 1640995200L  // 2022-01-01 00:00:00 UTC
  let date_formats = [
    ("en-US", "1/1/2022, 12:00:00 AM"),
    ("en-GB", "01/01/2022 00:00:00"),
    ("de-DE", "01.01.2022, 00:00:00"),
    ("ja-JP", "2022/01/01 0:00:00"),
    ("zh-CN", "2022/1/1 ä¸Šåˆ12:00:00")
  ]
  
  let localized_dates = []
  
  // æµ‹è¯•æ—¥æœŸæ—¶é—´æœ¬åœ°åŒ–
  for format in date_formats {
    let locale = format.0
    let expected_format = format.1
    let formatted_date = ""
    
    // æ¨¡æ‹Ÿæ—¥æœŸæ—¶é—´æ ¼å¼åŒ–
    if locale == "en-US" {
      formatted_date = "1/1/2022, 12:00:00 AM"
    } else if locale == "en-GB" {
      formatted_date = "01/01/2022 00:00:00"
    } else if locale == "de-DE" {
      formatted_date = "01.01.2022, 00:00:00"
    } else if locale == "ja-JP" {
      formatted_date = "2022/01/01 0:00:00"
    } else if locale == "zh-CN" {
      formatted_date = "2022/1/1 ä¸Šåˆ12:00:00"
    }
    
    localized_dates.push((locale, formatted_date))
    
    // éªŒè¯æ—¥æœŸæ ¼å¼
    assert_eq(formatted_date, expected_format)
    assert_eq(formatted_date.contains("2022"), true)
    assert_eq(formatted_date.contains("01") || formatted_date.contains("1"), true)
  }
  
  // éªŒè¯æ—¥æœŸæœ¬åœ°åŒ–ç»“æœ
  assert_eq(localized_dates.length(), 5)
  
  // éªŒè¯ä¸åŒåœ°åŒºçš„æ ¼å¼å·®å¼‚
  let us_date = localized_dates[0].1
  let uk_date = localized_dates[1].1
  let german_date = localized_dates[2].1
  let japanese_date = localized_dates[3].1
  let chinese_date = localized_dates[4].1
  
  assert_eq(us_date != uk_date, true)      // ç¾å¼å’Œè‹±å¼æ ¼å¼ä¸åŒ
  assert_eq(uk_date != german_date, true)  // è‹±å¼å’Œå¾·å¼æ ¼å¼ä¸åŒ
  assert_eq(german_date != japanese_date, true)  // å¾·å¼å’Œæ—¥å¼æ ¼å¼ä¸åŒ
  assert_eq(japanese_date != chinese_date, true)  // æ—¥å¼å’Œä¸­æ–‡æ ¼å¼ä¸åŒ
  
  // éªŒè¯AM/PMæ ‡è®°
  assert_eq(us_date.contains("AM"), true)
  assert_eq(chinese_date.contains("ä¸Šåˆ"), true)
  assert_eq(uk_date.contains("AM"), false)  // 24å°æ—¶åˆ¶
  assert_eq(german_date.contains("AM"), false)  // 24å°æ—¶åˆ¶
}

test "cultural_sensitivity_validation" {
  // æµ‹è¯•æ–‡åŒ–æ•æ„Ÿæ€§éªŒè¯
  
  let sensitive_content = [
    ("color", ["color", "colour"]),  // ç¾å¼vsè‹±å¼è‹±è¯­
    ("calendar", ["Gregorian", "Islamic", "Hebrew", "Chinese"]),  // ä¸åŒå†æ³•
    ("name_format", ["First Last", "Last First", "Family Given"])  // å§“åæ ¼å¼
  ]
  
  let cultural_preferences = []
  
  // æµ‹è¯•æ–‡åŒ–åå¥½è®¾ç½®
  for content in sensitive_content {
    let content_type = content.0
    let variants = content.1
    
    for variant in variants {
      let is_appropriate = true  // ç®€åŒ–çš„é€‚å½“æ€§æ£€æŸ¥
      let target_region = ""
      
      // ç¡®å®šç›®æ ‡åœ°åŒº
      if content_type == "color" {
        if variant == "color" { target_region = "US" }
        else if variant == "colour" { target_region = "UK" }
      } else if content_type == "calendar" {
        if variant == "Gregorian" { target_region = "Global" }
        else if variant == "Islamic" { target_region = "Middle East" }
        else if variant == "Hebrew" { target_region = "Israel" }
        else if variant == "Chinese" { target_region = "China" }
      } else if content_type == "name_format" {
        if variant == "First Last" { target_region = "Western" }
        else if variant == "Last First" { target_region = "Eastern" }
        else if variant == "Family Given" { target_region = "Formal" }
      }
      
      cultural_preferences.push((content_type, variant, target_region, is_appropriate))
      
      // éªŒè¯æ–‡åŒ–é€‚å½“æ€§
      assert_eq(is_appropriate, true)
      assert_eq(target_region.length() > 0, true)
    }
  }
  
  // éªŒè¯æ–‡åŒ–åå¥½è®¾ç½®æ•°é‡
  assert_eq(cultural_preferences.length(), 9)  // 2 + 4 + 3
  
  // éªŒè¯ä¸åŒå†…å®¹ç±»å‹çš„åˆ†å¸ƒ
  let mut color_count = 0
  let mut calendar_count = 0
  let mut name_format_count = 0
  
  for preference in cultural_preferences {
    if preference.0 == "color" { color_count = color_count + 1 }
    else if preference.0 == "calendar" { calendar_count = calendar_count + 1 }
    else if preference.0 == "name_format" { name_format_count = name_format_count + 1 }
  }
  
  assert_eq(color_count, 2)
  assert_eq(calendar_count, 4)
  assert_eq(name_format_count, 3)
  
  // éªŒè¯åœ°åŒºè¦†ç›–
  let regions = ["US", "UK", "Global", "Middle East", "Israel", "China", "Western", "Eastern", "Formal"]
  assert_eq(regions.length(), 9)
}