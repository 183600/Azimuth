// é¥æµ‹è¾¹ç•Œæƒ…å†µæµ‹è¯•ç”¨ä¾‹

test "edge_cases_extreme_string_lengths" {
  // æµ‹è¯•æç«¯å­—ç¬¦ä¸²é•¿åº¦
  
  // ç©ºå­—ç¬¦ä¸²
  let empty_string = ""
  assert_eq(empty_string.length(), 0)
  
  // å•å­—ç¬¦å­—ç¬¦ä¸²
  let single_char = "a"
  assert_eq(single_char.length(), 1)
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = "This is a very long string that tests the system's ability to handle large amounts of text data without performance degradation or memory issues. It contains multiple sentences and various types of content to simulate real-world telemetry data that might include long log messages, detailed error descriptions, or extensive metadata."
  assert_eq(long_string.length() > 200, true)
  
  // åœ¨ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨æç«¯é•¿åº¦å­—ç¬¦ä¸²
  let ctx = Context::empty()
  let empty_key = create_key("empty.string")
  let single_key = create_key("single.char")
  let long_key = create_key("long.string")
  
  let ctx_with_extreme_strings = ctx
    .with_value(empty_key, empty_string)
    .with_value(single_key, single_char)
    .with_value(long_key, long_string)
  
  // éªŒè¯æç«¯å­—ç¬¦ä¸²å¤„ç†
  match ctx_with_extreme_strings.get(empty_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Should handle empty string")
  }
  
  match ctx_with_extreme_strings.get(single_key) {
    Some(value) => assert_eq(value, "a")
    None => @test.fail("Should handle single character string")
  }
  
  match ctx_with_extreme_strings.get(long_key) {
    Some(value) => assert_eq(value.length() > 200, true)
    None => @test.fail("Should handle long string")
  }
  
  // æµ‹è¯•æç«¯é”®åé•¿åº¦
  let extremely_long_key_name = "this.is.an.extremely.long.key.name.that.tests.the.boundaries.of.what.the.system.can.handle.in.terms.of.key.identifiers.and.should.still.work.correctly.without.causing.any.issues.or.failures"
  let extreme_key = create_key(extremely_long_key_name)
  let ctx_with_extreme_key = ctx_with_extreme_strings.with_value(extreme_key, "extreme.key.value")
  
  match ctx_with_extreme_key.get(extreme_key) {
    Some(value) => assert_eq(value, "extreme.key.value")
    None => @test.fail("Should handle extremely long key name")
  }
}

test "edge_cases_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  
  // æ§åˆ¶å­—ç¬¦
  let control_chars = "\0\1\2\3\4\5\6\7\n\r\t"
  
  // æ ‡ç‚¹ç¬¦å·
  let punctuation = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  
  // Unicodeå­—ç¬¦
  let unicode_chars = "æµ‹è¯•ğŸš€ğŸŒŸğŸ’»ğŸ“ŠğŸ“ˆğŸ”"
  
  // æ··åˆç‰¹æ®Šå­—ç¬¦
  let mixed_special = control_chars + punctuation + unicode_chars
  
  // åœ¨ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ç‰¹æ®Šå­—ç¬¦
  let ctx = Context::empty()
  let control_key = create_key("control.chars")
  let punctuation_key = create_key("punctuation.chars")
  let unicode_key = create_key("unicode.chars")
  let mixed_key = create_key("mixed.special.chars")
  
  let ctx_with_special = ctx
    .with_value(control_key, control_chars)
    .with_value(punctuation_key, punctuation)
    .with_value(unicode_key, unicode_chars)
    .with_value(mixed_key, mixed_special)
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å¤„ç†
  match ctx_with_special.get(control_key) {
    Some(value) => assert_eq(value, control_chars)
    None => @test.fail("Should handle control characters")
  }
  
  match ctx_with_special.get(punctuation_key) {
    Some(value) => assert_eq(value, punctuation)
    None => @test.fail("Should handle punctuation")
  }
  
  match ctx_with_special.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_chars)
    None => @test.fail("Should handle unicode characters")
  }
  
  match ctx_with_special.get(mixed_key) {
    Some(value) => assert_eq(value, mixed_special)
    None => @test.fail("Should handle mixed special characters")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å
  let special_key_name = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let special_key = create_key(special_key_name)
  let ctx_with_special_key = ctx_with_special.with_value(special_key, "special.key.value")
  
  match ctx_with_special_key.get(special_key) {
    Some(value) => assert_eq(value, "special.key.value")
    None => @test.fail("Should handle special characters in key name")
  }
  
  // æµ‹è¯•baggageä¸­çš„ç‰¹æ®Šå­—ç¬¦
  let baggage = Baggage::empty()
  let baggage_with_special = baggage
    .with_entry("special.key", "special\0value!@#$%")
    .with_entry("unicode.key", "æµ‹è¯•å€¼ğŸš€")
    .with_entry("", "empty.key.value")
  
  match baggage_with_special.get("special.key") {
    Some(value) => assert_eq(value, "special\0value!@#$%")
    None => @test.fail("Should handle special characters in baggage value")
  }
  
  match baggage_with_special.get("unicode.key") {
    Some(value) => assert_eq(value, "æµ‹è¯•å€¼ğŸš€")
    None => @test.fail("Should handle unicode in baggage value")
  }
  
  match baggage_with_special.get("") {
    Some(value) => assert_eq(value, "empty.key.value")
    None => @test.fail("Should handle empty key in baggage")
  }
}

test "edge_cases_numeric_boundaries" {
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œ
  
  // æ•´æ•°è¾¹ç•Œ
  let max_int64 = 9223372036854775807L
  let min_int64 = -9223372036854775808L
  let zero = 0L
  let one = 1L
  let neg_one = -1L
  
  // æµ®ç‚¹æ•°è¾¹ç•Œ
  let max_double = 1.7976931348623157e+308  // æ¥è¿‘Doubleæœ€å¤§å€¼
  let min_double = -1.7976931348623157e+308  // æ¥è¿‘Doubleæœ€å°å€¼
  let pos_inf = 1.0/0.0
  let neg_inf = -1.0/0.0
  let nan = 0.0/0.0
  let very_small = 1.0e-308
  let very_large = 1.0e+308
  
  // åœ¨ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨è¾¹ç•Œæ•°å€¼
  let ctx = Context::empty()
  let max_int_key = create_key("max.int64")
  let min_int_key = create_key("min.int64")
  let zero_key = create_key("zero")
  let max_double_key = create_key("max.double")
  let min_double_key = create_key("min.double")
  let inf_key = create_key("infinity")
  let nan_key = create_key("nan")
  let small_key = create_key("very.small")
  let large_key = create_key("very.large")
  
  let ctx_with_boundaries = ctx
    .with_value(max_int_key, max_int64.to_string())
    .with_value(min_int_key, min_int64.to_string())
    .with_value(zero_key, zero.to_string())
    .with_value(max_double_key, max_double.to_string())
    .with_value(min_double_key, min_double.to_string())
    .with_value(inf_key, pos_inf.to_string())
    .with_value(nan_key, nan.to_string())
    .with_value(small_key, very_small.to_string())
    .with_value(large_key, very_large.to_string())
  
  // éªŒè¯è¾¹ç•Œæ•°å€¼å¤„ç†
  match ctx_with_boundaries.get(max_int_key) {
    Some(value) => assert_eq(value, "9223372036854775807")
    None => @test.fail("Should handle max int64")
  }
  
  match ctx_with_boundaries.get(min_int_key) {
    Some(value) => assert_eq(value, "-9223372036854775808")
    None => @test.fail("Should handle min int64")
  }
  
  match ctx_with_boundaries.get(zero_key) {
    Some(value) => assert_eq(value, "0")
    None => @test.fail("Should handle zero")
  }
  
  match ctx_with_boundaries.get(inf_key) {
    Some(value) => assert_eq(value.length() > 0, true)
    None => @test.fail("Should handle infinity")
  }
  
  match ctx_with_boundaries.get(nan_key) {
    Some(value) => assert_eq(value.length() > 0, true)
    None => @test.fail("Should handle NaN")
  }
  
  // æµ‹è¯•æ•°å€¼è¿ç®—è¾¹ç•Œ
  let addition_overflow = max_int64 + one  // å¯èƒ½æº¢å‡º
  let subtraction_underflow = min_int64 - neg_one  // å¯èƒ½ä¸‹æº¢
  
  // éªŒè¯è¿ç®—ç»“æœ
  assert_eq(addition_overflow >= min_int64, true)  // ç»“æœåº”è¯¥åœ¨æœ‰æ•ˆèŒƒå›´å†…
  assert_eq(subtraction_underflow <= max_int64, true)  // ç»“æœåº”è¯¥åœ¨æœ‰æ•ˆèŒƒå›´å†…
  
  // æµ‹è¯•æµ®ç‚¹æ•°ç‰¹æ®Šè¿ç®—
  let inf_times_zero = pos_inf * zero.to_double()
  let inf_div_inf = pos_inf / pos_inf
  let zero_div_zero = zero.to_double() / zero.to_double()
  
  // éªŒè¯ç‰¹æ®Šæµ®ç‚¹è¿ç®—ç»“æœ
  assert_eq(inf_times_zero.to_string().length() > 0, true)
  assert_eq(inf_div_inf.to_string().length() > 0, true)
  assert_eq(zero_div_zero.to_string().length() > 0, true)
}

test "edge_cases_array_operations" {
  // æµ‹è¯•æ•°ç»„æ“ä½œè¾¹ç•Œ
  
  // ç©ºæ•°ç»„
  let empty_string_array = []
  let empty_int_array = []
  let empty_float_array = []
  let empty_bool_array = []
  
  // å•å…ƒç´ æ•°ç»„
  let single_string_array = ["single"]
  let single_int_array = [1L]
  let single_float_array = [1.0]
  let single_bool_array = [true]
  
  // å¤§æ•°ç»„
  let mut large_string_array = []
  let mut large_int_array = []
  let mut large_float_array = []
  let mut large_bool_array = []
  
  let mut i = 0
  while i < 100 {
    large_string_array.push("item." + i.to_string())
    large_int_array.push(i.to_int64())
    large_float_array.push(i.to_double())
    large_bool_array.push(i % 2 == 0)
    i = i + 1
  }
  
  // éªŒè¯æ•°ç»„è¾¹ç•Œ
  assert_eq(empty_string_array.length(), 0)
  assert_eq(single_string_array.length(), 1)
  assert_eq(large_string_array.length(), 100)
  
  assert_eq(empty_int_array.length(), 0)
  assert_eq(single_int_array.length(), 1)
  assert_eq(large_int_array.length(), 100)
  
  // éªŒè¯æ•°ç»„è®¿é—®è¾¹ç•Œ
  assert_eq(single_string_array[0], "single")
  assert_eq(single_int_array[0], 1L)
  assert_eq(large_string_array[0], "item.0")
  assert_eq(large_string_array[99], "item.99")
  assert_eq(large_int_array[0], 0L)
  assert_eq(large_int_array[99], 99L)
  
  // æµ‹è¯•æ•°ç»„è¾¹ç•Œæ“ä½œ
  let mut sum = 0L
  let mut j = 0
  while j < large_int_array.length() {
    sum = sum + large_int_array[j]
    j = j + 1
  }
  
  // éªŒè¯æ±‚å’Œç»“æœ (0 + 1 + 2 + ... + 99 = 4950)
  assert_eq(sum, 4950L)
  
  // æµ‹è¯•æ•°ç»„æŸ¥æ‰¾è¾¹ç•Œ
  let mut found_first = false
  let mut found_last = false
  let mut found_middle = false
  
  let mut k = 0
  while k < large_string_array.length() {
    if large_string_array[k] == "item.0" {
      found_first = true
    } else if large_string_array[k] == "item.99" {
      found_last = true
    } else if large_string_array[k] == "item.50" {
      found_middle = true
    }
    k = k + 1
  }
  
  assert_eq(found_first, true)
  assert_eq(found_last, true)
  assert_eq(found_middle, true)
}

test "edge_cases_context_chaining" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡é“¾å¼æ“ä½œè¾¹ç•Œ
  
  let ctx = Context::empty()
  
  // æé•¿é“¾å¼æ“ä½œ
  let mut chained_ctx = ctx
  let mut i = 0
  while i < 50 {
    let key = create_key("chained.key." + i.to_string())
    let value = "chained.value." + i.to_string()
    chained_ctx = chained_ctx.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯é“¾å¼æ“ä½œç»“æœ
  let first_key = create_key("chained.key.0")
  let last_key = create_key("chained.key.49")
  let middle_key = create_key("chained.key.25")
  
  match chained_ctx.get(first_key) {
    Some(value) => assert_eq(value, "chained.value.0")
    None => @test.fail("Should handle long chaining - first key")
  }
  
  match chained_ctx.get(last_key) {
    Some(value) => assert_eq(value, "chained.value.49")
    None => @test.fail("Should handle long chaining - last key")
  }
  
  match chained_ctx.get(middle_key) {
    Some(value) => assert_eq(value, "chained.value.25")
    None => @test.fail("Should handle long chaining - middle key")
  }
  
  // æµ‹è¯•é”®è¦†ç›–é“¾å¼æ“ä½œ
  let mut override_ctx = ctx
  let override_key = create_key("override.test")
  
  let mut j = 0
  while j < 10 {
    let value = "override.value." + j.to_string()
    override_ctx = override_ctx.with_value(override_key, value)
    j = j + 1
  }
  
  // éªŒè¯æœ€ç»ˆè¦†ç›–å€¼
  match override_ctx.get(override_key) {
    Some(value) => assert_eq(value, "override.value.9")
    None => @test.fail("Should handle key overriding in chaining")
  }
  
  // æµ‹è¯•æ··åˆé“¾å¼æ“ä½œï¼ˆä¸åŒé”®åï¼‰
  let mut mixed_ctx = ctx
  let mut k = 0
  while k < 20 {
    let string_key = create_key("mixed.string." + k.to_string())
    let int_key = create_key("mixed.int." + k.to_string())
    
    mixed_ctx = mixed_ctx
      .with_value(string_key, "string.value." + k.to_string())
      .with_value(int_key, k.to_string())
    
    k = k + 1
  }
  
  // éªŒè¯æ··åˆé“¾å¼æ“ä½œ
  match mixed_ctx.get(create_key("mixed.string.10")) {
    Some(value) => assert_eq(value, "string.value.10")
    None => @test.fail("Should handle mixed chaining - string")
  }
  
  match mixed_ctx.get(create_key("mixed.int.15")) {
    Some(value) => assert_eq(value, "15")
    None => @test.fail("Should handle mixed chaining - int")
  }
}

test "edge_cases_memory_pressure" {
  // æµ‹è¯•å†…å­˜å‹åŠ›æƒ…å†µ
  
  // åˆ›å»ºå¤§é‡ä¸Šä¸‹æ–‡å®ä¾‹
  let mut contexts = []
  let mut i = 0
  while i < 20 {
    let ctx = Context::empty()
    contexts.push(ctx)
    i = i + 1
  }
  
  // åœ¨æ¯ä¸ªä¸Šä¸‹æ–‡ä¸­æ·»åŠ å¤§é‡æ•°æ®
  let mut contexts_with_data = []
  let mut j = 0
  while j < contexts.length() {
    let ctx = contexts[j]
    let mut ctx_with_data = ctx
    
    // æ¯ä¸ªä¸Šä¸‹æ–‡æ·»åŠ 10ä¸ªé”®å€¼å¯¹
    let mut k = 0
    while k < 10 {
      let key = create_key("memory.test." + j.to_string() + "." + k.to_string())
      let value = "memory.value." + j.to_string() + "." + k.to_string() + ".with.additional.data.to.increase.memory.usage"
      ctx_with_data = ctx_with_data.with_value(key, value)
      k = k + 1
    }
    
    contexts_with_data.push(ctx_with_data)
    j = j + 1
  }
  
  // éªŒè¯å†…å­˜å‹åŠ›ä¸‹çš„æ•°æ®å®Œæ•´æ€§
  let mut verification_ctx = contexts_with_data[10]  // é€‰æ‹©ä¸­é—´çš„ä¸Šä¸‹æ–‡
  let test_key = create_key("memory.test.10.5")
  let expected_value = "memory.value.10.5.with.additional.data.to.increase.memory.usage"
  
  match verification_ctx.get(test_key) {
    Some(value) => assert_eq(value, expected_value)
    None => @test.fail("Should maintain data integrity under memory pressure")
  }
  
  // æµ‹è¯•baggageå†…å­˜å‹åŠ›
  let mut baggages = []
  let mut l = 0
  while l < 10 {
    let baggage = Baggage::empty()
    baggages.push(baggage)
    l = l + 1
  }
  
  // åœ¨æ¯ä¸ªbaggageä¸­æ·»åŠ å¤§é‡æ•°æ®
  let mut baggages_with_data = []
  let mut m = 0
  while m < baggages.length() {
    let baggage = baggages[m]
    let mut baggage_with_data = baggage
    
    // æ¯ä¸ªbaggageæ·»åŠ 5ä¸ªæ¡ç›®
    let mut n = 0
    while n < 5 {
      let entry_key = "baggage.memory." + m.to_string() + "." + n.to_string()
      let entry_value = "baggage.value." + m.to_string() + "." + n.to_string() + ".with.extra.memory.data"
      baggage_with_data = baggage_with_data.with_entry(entry_key, entry_value)
      n = n + 1
    }
    
    baggages_with_data.push(baggage_with_data)
    m = m + 1
  }
  
  // éªŒè¯baggageå†…å­˜å‹åŠ›ä¸‹çš„æ•°æ®å®Œæ•´æ€§
  let verification_baggage = baggages_with_data[5]
  match verification_baggage.get("baggage.memory.5.3") {
    Some(value) => assert_eq(value, "baggage.value.5.3.with.extra.memory.data")
    None => @test.fail("Should maintain baggage data integrity under memory pressure")
  }
  
  // éªŒè¯å¯¹è±¡è®¡æ•°
  assert_eq(contexts_with_data.length(), 20)
  assert_eq(baggages_with_data.length(), 10)
}