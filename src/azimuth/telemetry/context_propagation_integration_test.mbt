// ä¸Šä¸‹æ–‡ä¼ æ’­APIé›†æˆæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•ä¸Šä¸‹æ–‡ç®¡ç†å’Œè·¨è¿›ç¨‹ä¼ æ’­çš„æ ¸å¿ƒåŠŸèƒ½

test "context_basic_operations" {
  // æµ‹è¯•ContextåŸºç¡€æ“ä½œ
  
  // åˆ›å»ºç©ºä¸Šä¸‹æ–‡
  let empty_ctx = context::Context::empty()
  assert_eq(empty_ctx.values.length(), 0)
  
  // åˆ›å»ºContextKey
  let user_key = context::create_key("user.id")
  let session_key = context::create_key("session.id")
  let request_key = context::create_key("request.id")
  
  // æ·»åŠ å€¼åˆ°ä¸Šä¸‹æ–‡
  let ctx1 = empty_ctx.with_value(user_key, "user123")
  let ctx2 = ctx1.with_value(session_key, "session456")
  let ctx3 = ctx2.with_value(request_key, "request789")
  
  // éªŒè¯å€¼å¯ä»¥æ­£ç¡®è·å–
  assert_eq(ctx3.get(user_key).unwrap_or(""), "user123")
  assert_eq(ctx3.get(session_key).unwrap_or(""), "session456")
  assert_eq(ctx3.get(request_key).unwrap_or(""), "request789")
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®è¿”å›None
  let missing_key = context::create_key("missing.key")
  assert_eq(ctx3.get(missing_key), None)
}

test "context_immutability_and_chaining" {
  // æµ‹è¯•Contextä¸å¯å˜æ€§å’Œé“¾å¼æ“ä½œ
  
  let base_ctx = context::Context::empty()
  
  // åˆ›å»ºå¤šä¸ªContextKey
  let keys = [
    context::create_key("service.name"),
    context::create_key("service.version"),
    context::create_key("deployment.environment"),
    context::create_key("host.name"),
    context::create_key("trace.id")
  ]
  
  let values = ["payment-api", "1.2.3", "production", "server-01", "trace123"]
  
  // é“¾å¼æ·»åŠ å€¼
  let mut ctx = base_ctx
  let mut i = 0
  while i < keys.length() {
    ctx = ctx.with_value(keys[i], values[i])
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½æ­£ç¡®å­˜å‚¨
  i = 0
  while i < keys.length() {
    assert_eq(ctx.get(keys[i]).unwrap_or(""), values[i])
    i = i + 1
  }
  
  // éªŒè¯åŸå§‹ä¸Šä¸‹æ–‡æœªå—å½±å“
  assert_eq(base_ctx.values.length(), 0)
  
  // éªŒè¯æ¯ä¸ªwith_valueéƒ½åˆ›å»ºæ–°çš„Context
  let ctx1 = base_ctx.with_value(keys[0], values[0])
  let ctx2 = ctx1.with_value(keys[1], values[1])
  
  assert_eq(ctx1.values.length(), 1)
  assert_eq(ctx2.values.length(), 2)
  assert_eq(base_ctx.values.length(), 0)
}

test "context_baggage_operations" {
  // æµ‹è¯•Baggageæ“ä½œ
  
  // åˆ›å»ºç©ºBaggage
  let empty_baggage = context::Baggage::empty()
  assert_eq(empty_baggage.entries.length(), 0)
  
  // æ·»åŠ æ¡ç›®åˆ°Baggage
  let baggage1 = empty_baggage.with_entry("user.id", "12345")
  let baggage2 = baggage1.with_entry("user.role", "admin")
  let baggage3 = baggage2.with_entry("request.source", "mobile")
  
  // éªŒè¯Baggageæ¡ç›®
  assert_eq(baggage3.get("user.id").unwrap_or(""), "12345")
  assert_eq(baggage3.get("user.role").unwrap_or(""), "admin")
  assert_eq(baggage3.get("request.source").unwrap_or(""), "mobile")
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®
  assert_eq(baggage3.get("nonexistent.key"), None)
  
  // æµ‹è¯•è¦†ç›–ç°æœ‰æ¡ç›®
  let baggage4 = baggage3.with_entry("user.id", "67890")
  assert_eq(baggage4.get("user.id").unwrap_or(""), "67890")
  assert_eq(baggage3.get("user.id").unwrap_or(""), "12345")  // åŸå§‹baggageä¸å˜
}

test "context_cross_service_propagation" {
  // æµ‹è¯•è·¨æœåŠ¡ä¸Šä¸‹æ–‡ä¼ æ’­
  
  // æ¨¡æ‹ŸAPI Gatewayåˆ›å»ºåˆå§‹ä¸Šä¸‹æ–‡
  let gateway_ctx = context::Context::empty()
  let gateway_keys = [
    ("request.id", "req_abc123"),
    ("user.id", "user_456"),
    ("correlation.id", "corr_def789"),
    ("trace.id", "trace_ghi012")
  ]
  
  let mut ctx = gateway_ctx
  let mut i = 0
  while i < gateway_keys.length() {
    let (key_name, value) = gateway_keys[i]
    let key = context::create_key(key_name)
    ctx = ctx.with_value(key, value)
    i = i + 1
  }
  
  // æ¨¡æ‹Ÿä¼ é€’ç»™Order Service
  let order_service_ctx = ctx
  let order_key = context::create_key("service.name")
  let order_ctx = order_service_ctx.with_value(order_key, "order-service")
  
  // Order Serviceæ·»åŠ è‡ªå·±çš„ä¸Šä¸‹æ–‡
  let order_id_key = context::create_key("order.id")
  let final_order_ctx = order_ctx.with_value(order_id_key, "order_jkl345")
  
  // éªŒè¯ä¸Šä¸‹æ–‡ä¼ æ’­
  assert_eq(final_order_ctx.get(context::create_key("request.id")).unwrap_or(""), "req_abc123")
  assert_eq(final_order_ctx.get(context::create_key("user.id")).unwrap_or(""), "user_456")
  assert_eq(final_order_ctx.get(context::create_key("correlation.id")).unwrap_or(""), "corr_def789")
  assert_eq(final_order_ctx.get(context::create_key("trace.id")).unwrap_or(""), "trace_ghi012")
  assert_eq(final_order_ctx.get(order_key).unwrap_or(""), "order-service")
  assert_eq(final_order_ctx.get(order_id_key).unwrap_or(""), "order_jkl345")
}

test "context_baggage_serialization" {
  // æµ‹è¯•Baggageåºåˆ—åŒ–å’Œååºåˆ—åŒ–
  
  // åˆ›å»ºå¤æ‚çš„Baggage
  let baggage = context::Baggage::empty()
    .with_entry("user.id", "12345")
    .with_entry("user.role", "premium")
    .with_entry("request.source", "mobile")
    .with_entry("geo.country", "US")
    .with_entry("experiment.cohort", "variant_a")
  
  // æ¨¡æ‹Ÿåºåˆ—åŒ–ä¸ºHTTPå¤´æ ¼å¼
  let mut serialized_entries = []
  let mut i = 0
  while i < baggage.entries.length() {
    let (key, value) = baggage.entries[i]
    serialized_entries.push(key + "=" + value)
    i = i + 1
  }
  
  // æ¨¡æ‹ŸHTTPå¤´æ ¼å¼ï¼škey1=value1,key2=value2,...
  let mut serialized = ""
  i = 0
  while i < serialized_entries.length() {
    if i > 0 {
      serialized = serialized + ","
    }
    serialized = serialized + serialized_entries[i]
    i = i + 1
  }
  
  // éªŒè¯åºåˆ—åŒ–ç»“æœ
  assert_eq(serialized.contains("user.id=12345"), true)
  assert_eq(serialized.contains("user.role=premium"), true)
  assert_eq(serialized.contains("request.source=mobile"), true)
  assert_eq(serialized.contains("geo.country=US"), true)
  assert_eq(serialized.contains("experiment.cohort=variant_a"), true)
  
  // æ¨¡æ‹Ÿååºåˆ—åŒ–ï¼ˆç®€åŒ–å®ç°ï¼‰
  let parsed_baggage = context::Baggage::empty()
  // åœ¨çœŸå®å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥è§£æserializedå­—ç¬¦ä¸²å¹¶é‡å»ºBaggage
  
  // éªŒè¯åŸå§‹Baggageæœªå—å½±å“
  assert_eq(baggage.entries.length(), 5)
}

test "context_performance_benchmark" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡æ“ä½œæ€§èƒ½
  
  // æ€§èƒ½æµ‹è¯•å‚æ•°
  let operation_count = 10000
  
  // æµ‹è¯•Contextåˆ›å»ºå’Œå€¼è®¾ç½®æ€§èƒ½
  let mut i = 0
  let base_ctx = context::Context::empty()
  
  while i < operation_count {
    let key = context::create_key("perf.key." + i.to_string())
    let value = "perf.value." + i.to_string()
    let _ = base_ctx.with_value(key, value)
    i = i + 1
  }
  
  // æµ‹è¯•Contextå€¼è·å–æ€§èƒ½
  let ctx = context::Context::empty()
    .with_value(context::create_key("test.key"), "test.value")
  
  i = 0
  while i < operation_count {
    let _ = ctx.get(context::create_key("test.key"))
    i = i + 1
  }
  
  // æµ‹è¯•Baggageæ“ä½œæ€§èƒ½
  let mut baggage = context::Baggage::empty()
  i = 0
  while i < 100 {  // è¾ƒå°‘çš„æ¡ç›®æ•°
    baggage = baggage.with_entry("baggage.key." + i.to_string(), "baggage.value." + i.to_string())
    i = i + 1
  }
  
  // æµ‹è¯•BaggageæŸ¥æ‰¾æ€§èƒ½
  i = 0
  while i < operation_count {
    let key_index = i % 100  // å¾ªç¯ä½¿ç”¨å·²å­˜åœ¨çš„é”®
    let _ = baggage.get("baggage.key." + key_index.to_string())
    i = i + 1
  }
  
  // éªŒè¯æ“ä½œå®Œæˆ
  assert_eq(i, operation_count)
}

test "context_concurrent_operations" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡å¹¶å‘æ“ä½œ
  
  let base_ctx = context::Context::empty()
  let base_baggage = context::Baggage::empty()
  
  // æ¨¡æ‹Ÿå¤šä¸ª"çº¿ç¨‹"åŒæ—¶æ“ä½œä¸Šä¸‹æ–‡
  let thread_count = 10
  let operations_per_thread = 100
  
  // ä¸ºæ¯ä¸ª"çº¿ç¨‹"åˆ›å»ºç‹¬ç«‹çš„ä¸Šä¸‹æ–‡åˆ†æ”¯
  let mut contexts = []
  let mut i = 0
  while i < thread_count {
    contexts.push(base_ctx)
    i = i + 1
  }
  
  // æ¯ä¸ªçº¿ç¨‹æ‰§è¡Œæ“ä½œ
  i = 0
  while i < thread_count {
    let mut thread_ctx = contexts[i]
    let mut j = 0
    while j < operations_per_thread {
      let key = context::create_key("thread." + i.to_string() + ".key." + j.to_string())
      let value = "thread." + i.to_string() + ".value." + j.to_string()
      thread_ctx = thread_ctx.with_value(key, value)
      j = j + 1
    }
    contexts[i] = thread_ctx
    i = i + 1
  }
  
  // éªŒè¯æ¯ä¸ªçº¿ç¨‹çš„ä¸Šä¸‹æ–‡ç‹¬ç«‹
  i = 0
  while i < thread_count {
    let thread_ctx = contexts[i]
    let expected_key = context::create_key("thread." + i.to_string() + ".key.99")
    let expected_value = "thread." + i.to_string() + ".value.99"
    assert_eq(thread_ctx.get(expected_key).unwrap_or(""), expected_value)
    i = i + 1
  }
  
  // éªŒè¯ä¸åŒçº¿ç¨‹é—´çš„ä¸Šä¸‹æ–‡éš”ç¦»
  let thread0_key = context::create_key("thread.0.key.50")
  let thread1_ctx = contexts[1]
  assert_eq(thread1_ctx.get(thread0_key), None)  // thread1åº”è¯¥æ²¡æœ‰thread0çš„é”®
}

test "context_error_handling_and_edge_cases" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  let ctx = context::Context::empty()
  let empty_key = context::create_key("")
  let empty_value = ""
  
  let ctx_with_empty = ctx.with_value(empty_key, empty_value)
  assert_eq(ctx_with_empty.get(empty_key).unwrap_or(""), empty_value)
  
  // æµ‹è¯•é•¿é”®å’Œé•¿å€¼
  let long_key_name = "this.is.a.very.long.key.name.that.might.be.used.in.some.scenarios.to.test.edge.cases"
  let long_value = "this.is.a.very.long.value.that.contains.a.lot.of.information.and.might.be.used.to.test.how.the.system.handles.long.values"
  
  let long_key = context::create_key(long_key_name)
  let ctx_with_long = ctx.with_value(long_key, long_value)
  assert_eq(ctx_with_long.get(long_key).unwrap_or(""), long_value)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars_key = context::create_key("key.with.special.chars!@#$%^&*()")
  let special_chars_value = "value.with.special.chars<>{}[]|\\:;\"'?/.,"
  
  let ctx_with_special = ctx.with_value(special_chars_key, special_chars_value)
  assert_eq(ctx_with_special.get(special_chars_key).unwrap_or(""), special_chars_value)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_key = context::create_key("é”®.åŒ…å«.ä¸­æ–‡")
  let unicode_value = "å€¼.åŒ…å«.ä¸­æ–‡.å’Œ.emoji.ğŸš€"
  
  let ctx_with_unicode = ctx.with_value(unicode_key, unicode_value)
  assert_eq(ctx_with_unicode.get(unicode_key).unwrap_or(""), unicode_value)
  
  // æµ‹è¯•Baggageè¾¹ç•Œæƒ…å†µ
  let baggage = context::Baggage::empty()
    .with_entry("", "empty.key")
    .with_entry("empty.value", "")
    .with_entry("special.chars", "!@#$%^&*()")
    .with_entry("unicode", "æµ‹è¯•æ•°æ®")
  
  assert_eq(baggage.get("").unwrap_or(""), "empty.key")
  assert_eq(baggage.get("empty.value").unwrap_or(""), "")
  assert_eq(baggage.get("special.chars").unwrap_or(""), "!@#$%^&*()")
  assert_eq(baggage.get("unicode").unwrap_or(""), "æµ‹è¯•æ•°æ®")
}

test "context_real_world_scenario" {
  // æµ‹è¯•çœŸå®ä¸–ç•Œåœºæ™¯çš„ä¸Šä¸‹æ–‡ä½¿ç”¨
  
  // æ¨¡æ‹Ÿå¾®æœåŠ¡è°ƒç”¨é“¾ä¸­çš„ä¸Šä¸‹æ–‡ä¼ æ’­
  
  // 1. API Gatewayæ¥æ”¶è¯·æ±‚
  let gateway_ctx = context::Context::empty()
    .with_value(context::create_key("request.id"), "req_gateway_001")
    .with_value(context::create_key("user.id"), "user_alice")
    .with_value(context::create_key("request.timestamp"), "2023-01-01T10:00:00Z")
    .with_value(context::create_key("client.ip"), "203.0.113.1")
  
  let gateway_baggage = context::Baggage::empty()
    .with_entry("user.tier", "premium")
    .with_entry("geo.region", "us-west-2")
    .with_entry("experiment.group", "blue")
  
  // 2. è°ƒç”¨è®¤è¯æœåŠ¡
  let auth_ctx = gateway_ctx
    .with_value(context::create_key("service.name"), "auth-service")
    .with_value(context::create_key("operation.name"), "validate_token")
  
  let auth_result = auth_ctx.with_value(context::create_key("auth.result"), "success")
  
  // 3. è°ƒç”¨è®¢å•æœåŠ¡
  let order_ctx = auth_result
    .with_value(context::create_key("service.name"), "order-service")
    .with_value(context::create_key("operation.name"), "create_order")
    .with_value(context::create_key("order.id"), "order_12345")
  
  // 4. è°ƒç”¨æ”¯ä»˜æœåŠ¡
  let payment_ctx = order_ctx
    .with_value(context::create_key("service.name"), "payment-service")
    .with_value(context::create_key("operation.name"), "process_payment")
    .with_value(context::create_key("payment.id"), "pay_67890")
    .with_value(context::create_key("payment.amount"), "99.99")
  
  // 5. è°ƒç”¨åº“å­˜æœåŠ¡
  let inventory_ctx = order_ctx
    .with_value(context::create_key("service.name"), "inventory-service")
    .with_value(context::create_key("operation.name"), "reserve_items")
    .with_value(context::create_key("product.id"), "prod_abc")
    .with_value(context::create_key("quantity"), "2")
  
  // éªŒè¯ä¸Šä¸‹æ–‡åœ¨æ•´ä¸ªè°ƒç”¨é“¾ä¸­çš„ä¼ æ’­
  let final_contexts = [auth_result, order_ctx, payment_ctx, inventory_ctx]
  let mut i = 0
  while i < final_contexts.length() {
    let ctx = final_contexts[i]
    
    // éªŒè¯åŸå§‹è¯·æ±‚ä¿¡æ¯ä¿æŒä¸å˜
    assert_eq(ctx.get(context::create_key("request.id")).unwrap_or(""), "req_gateway_001")
    assert_eq(ctx.get(context::create_key("user.id")).unwrap_or(""), "user_alice")
    assert_eq(ctx.get(context::create_key("request.timestamp")).unwrap_or(""), "2023-01-01T10:00:00Z")
    assert_eq(ctx.get(context::create_key("client.ip")).unwrap_or(""), "203.0.113.1")
    
    i = i + 1
  }
  
  // éªŒè¯æ¯ä¸ªæœåŠ¡çš„ç‰¹å®šä¸Šä¸‹æ–‡
  assert_eq(payment_ctx.get(context::create_key("service.name")).unwrap_or(""), "payment-service")
  assert_eq(payment_ctx.get(context::create_key("payment.id")).unwrap_or(""), "pay_67890")
  assert_eq(payment_ctx.get(context::create_key("payment.amount")).unwrap_or(""), "99.99")
  
  assert_eq(inventory_ctx.get(context::create_key("service.name")).unwrap_or(""), "inventory-service")
  assert_eq(inventory_ctx.get(context::create_key("product.id")).unwrap_or(""), "prod_abc")
  assert_eq(inventory_ctx.get(context::create_key("quantity")).unwrap_or(""), "2")
}