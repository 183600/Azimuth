// Azimuth Telemetry - Internationalization Support Test
// æµ‹è¯•å›½é™…åŒ–åŠŸèƒ½

use azimuth.telemetry.api.common
use azimuth.telemetry.api.context
use azimuth.telemetry.api.trace
use azimuth.telemetry.api.metrics
use azimuth.telemetry.api.logs

// å›½é™…åŒ–æµ‹è¯•æ•°æ®
pub struct I18nTestData {
  language : String
  region : String
  script : String?
  display_name : String
  sample_text : String
  special_characters : String
  date_format : String
  number_format : String
}

pub fn I18nTestData::new(
  language : String,
  region : String,
  script : String?,
  display_name : String,
  sample_text : String,
  special_characters : String,
  date_format : String,
  number_format : String
) -> I18nTestData {
  I18nTestData::{
    language,
    region,
    script,
    display_name,
    sample_text,
    special_characters,
    date_format,
    number_format
  }
}

// è·å–æµ‹è¯•ç”¨çš„å›½é™…åŒ–æ•°æ®
pub fn get_i18n_test_data() -> Array[I18nTestData] {
  [
    I18nTestData::new(
      "zh",
      "CN",
      Some("Hans"),
      "ç®€ä½“ä¸­æ–‡ (ä¸­å›½)",
      "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ¶ˆæ¯ï¼Œç”¨äºéªŒè¯ä¸­æ–‡æ”¯æŒã€‚åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "ä¸­æ–‡ç‰¹æ®Šå­—ç¬¦ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss",
      "1,234,567.89"
    ),
    I18nTestData::new(
      "zh",
      "TW",
      Some("Hant"),
      "ç¹é«”ä¸­æ–‡ (å°ç£)",
      "é€™æ˜¯ä¸€å€‹æ¸¬è©¦è¨Šæ¯ï¼Œç”¨æ–¼é©—è­‰ç¹é«”ä¸­æ–‡æ”¯æ´ã€‚åŒ…å«ç‰¹æ®Šå­—å…ƒï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "ç¹é«”ä¸­æ–‡ç‰¹æ®Šå­—å…ƒï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss",
      "1,234,567.89"
    ),
    I18nTestData::new(
      "ja",
      "JP",
      Some("Jpan"),
      "æ—¥æœ¬èª (æ—¥æœ¬)",
      "ã“ã‚Œã¯æ—¥æœ¬èªã‚µãƒãƒ¼ãƒˆã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã®ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã™ã€‚ç‰¹æ®Šæ–‡å­—ï¼šï¼ï¼ ï¼ƒï¼„ï¼…ï¼¾ï¼†ï¼Šï¼ˆï¼‰ï¼ï¼‹ï¼ï½›ï½ã€ã€‘ï½œï¼›'\"ï¼š""ï¼Ÿï¼ï¼œï¼",
      "æ—¥æœ¬èªç‰¹æ®Šæ–‡å­—ï¼šï¼ï¼ ï¼ƒï¼„ï¼…ï¼¾ï¼†ï¼Šï¼ˆï¼‰ï¼ï¼‹ï¼ï½›ï½ã€ã€‘ï½œï¼›'\"ï¼š""ï¼Ÿï¼ï¼œï¼",
      "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss",
      "1,234,567.89"
    ),
    I18nTestData::new(
      "ko",
      "KR",
      Some("Kore"),
      "í•œêµ­ì–´ (í•œêµ­)",
      "ì´ê²ƒì€ í•œêµ­ì–´ ì§€ì›ì„ ê²€ì¦í•˜ê¸° ìœ„í•œ í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ì…ë‹ˆë‹¤. íŠ¹ìˆ˜ ë¬¸ìï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "í•œêµ­ì–´ íŠ¹ìˆ˜ ë¬¸ìï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "YYYYë…„ MMì›” DDì¼ HH:mm:ss",
      "1,234,567.89"
    ),
    I18nTestData::new(
      "ar",
      "SA",
      Some("Arab"),
      "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (Ø§Ù„Ù…Ù…Ù„ÙƒØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©)",
      "Ù‡Ø°Ù‡ Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªØ¨Ø§Ø± Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¯Ø¹Ù… Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©. Ø£Ø­Ø±Ù Ø®Ø§ØµØ©ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "Ø£Ø­Ø±Ù Ø¹Ø±Ø¨ÙŠØ© Ø®Ø§ØµØ©ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "YYYY/MM/DD HH:mm:ss",
      "1,234,567.89"
    ),
    I18nTestData::new(
      "he",
      "IL",
      Some("Hebr"),
      "×¢×‘×¨×™×ª (×™×©×¨××œ)",
      "×–×•×”×™ ×”×•×“×¢×ª ×‘×“×™×§×” ×œ××™××•×ª ×ª××™×›×” ×‘×¢×‘×¨×™×ª. ×ª×•×•×™× ××™×•×—×“×™×ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "×ª×•×•×™× ×¢×‘×¨×™×™× ××™×•×—×“×™×ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "DD/MM/YYYY HH:mm:ss",
      "1,234,567.89"
    ),
    I18nTestData::new(
      "ru",
      "RU",
      Some("Cyrl"),
      "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (Ğ Ğ¾ÑÑĞ¸Ñ)",
      "Ğ­Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ¸ Ñ€ÑƒÑÑĞºĞ¾Ğ³Ğ¾ ÑĞ·Ñ‹ĞºĞ°. Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "Ğ ÑƒÑÑĞºĞ¸Ğµ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ï¼šï¼@#ï¿¥%â€¦â€¦&*ï¼ˆï¼‰â€”â€”+-={}ã€ã€‘|ï¼›'\"ï¼š""ï¼Ÿ/ã€Šã€‹<>",
      "DD.MM.YYYY HH:mm:ss",
      "1 234 567,89"
    ),
    I18nTestData::new(
      "de",
      "DE",
      Some("Latn"),
      "Deutsch (Deutschland)",
      "Dies ist eine Testnachricht zur ÃœberprÃ¼fung der deutschen UnterstÃ¼tzung. Sonderzeichenï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>",
      "Deutsche Sonderzeichenï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>ÃŸÃ¤Ã¶Ã¼Ã„Ã–Ãœ",
      "DD.MM.YYYY HH:mm:ss",
      "1.234.567,89"
    ),
    I18nTestData::new(
      "fr",
      "FR",
      Some("Latn"),
      "FranÃ§ais (France)",
      "Ceci est un message de test pour vÃ©rifier le support franÃ§ais. CaractÃ¨res spÃ©ciauxï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>",
      "CaractÃ¨res spÃ©ciaux franÃ§aisï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>Ã Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã¯Ã®Ã´Ã¶Ã¹Ã»Ã¼Ã¿Ã±Ã§",
      "DD/MM/YYYY HH:mm:ss",
      "1 234 567,89"
    ),
    I18nTestData::new(
      "es",
      "ES",
      Some("Latn"),
      "EspaÃ±ol (EspaÃ±a)",
      "Este es un mensaje de prueba para verificar el soporte espaÃ±ol. Caracteres especialesï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>",
      "Caracteres especiales espaÃ±olesï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>Ã±Ã¡Ã©Ã­Ã³ÃºÃ¼Ã‘ÃÃ‰ÃÃ“ÃšÃœÂ¿Â¡",
      "DD/MM/YYYY HH:mm:ss",
      "1.234.567,89"
    ),
    I18nTestData::new(
      "en",
      "US",
      Some("Latn"),
      "English (United States)",
      "This is a test message to verify English support. Special charactersï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>",
      "English special charactersï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>",
      "MM/DD/YYYY HH:mm:ss",
      "1,234,567.89"
    ),
    I18nTestData::new(
      "th",
      "TH",
      Some("Thai"),
      "à¹„à¸—à¸¢ (à¸›à¸£à¸°à¹€à¸—à¸¨à¹„à¸—à¸¢)",
      "à¸™à¸µà¹ˆà¸„à¸·à¸­à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸—à¸”à¸ªà¸­à¸šà¹€à¸à¸·à¹ˆà¸­à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™à¸ à¸²à¸©à¸²à¹„à¸—à¸¢ à¸­à¸±à¸à¸‚à¸£à¸°à¸à¸´à¹€à¸¨à¸©ï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>",
      "à¸­à¸±à¸à¸‚à¸£à¸°à¸à¸´à¹€à¸¨à¸©à¹„à¸—à¸¢ï¼š!@#$%^&*()_-+={}[]|;':\"?,/<>à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸à¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸à¸Ÿà¸ à¸¡à¸¢à¸£à¸¥à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®",
      "DD/MM/YYYY HH:mm:ss",
      "1,234,567.89"
    )
  ]
}

test "trace_i18n_support" {
  // æµ‹è¯•Trace APIçš„å›½é™…åŒ–æ”¯æŒ
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("i18n-test-tracer", "1.0.0")
  let ctx = context::Context::new()
  let test_data = get_i18n_test_data()
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„Spanåç§°å’Œå±æ€§
  let mut i = 0
  while i < test_data.length() {
    let data = test_data[i]
    
    // åˆ›å»ºåŒ…å«å›½é™…åŒ–å†…å®¹çš„Span
    let (_, span) = tracer.start_span(
      ctx,
      data.sample_text,
      trace::Internal,
      [
        ("language", common::AttributeValue::string(data.language)),
        ("region", common::AttributeValue::string(data.region)),
        ("script", common::AttributeValue::string(data.script.unwrap_or(""))),
        ("display.name", common::AttributeValue::string(data.display_name)),
        ("special.chars", common::AttributeValue::string(data.special_characters)),
        ("date.format", common::AttributeValue::string(data.date_format)),
        ("number.format", common::AttributeValue::string(data.number_format))
      ],
      1234567890L
    )
    
    // éªŒè¯å›½é™…åŒ–å†…å®¹æ­£ç¡®ä¿å­˜
    @assert(span.name == data.sample_text)
    @assert(span.attributes.length() == 7)
    
    // éªŒè¯æ¯ä¸ªå±æ€§å€¼éƒ½æ­£ç¡®ä¿å­˜
    let mut j = 0
    while j < span.attributes.length() {
      let (key, value) = span.attributes[j]
      @assert(match value { common::StringValue(s) => s.length() > 0 _ => false })
      j = j + 1
    }
    
    i = i + 1
  }
}

test "metrics_i18n_support" {
  // æµ‹è¯•Metrics APIçš„å›½é™…åŒ–æ”¯æŒ
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("i18n-test-meter", "1.0.0")
  let test_data = get_i18n_test_data()
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„æŒ‡æ ‡åç§°å’Œå±æ€§
  let mut i = 0
  while i < test_data.length() {
    let data = test_data[i]
    
    // åˆ›å»ºåŒ…å«å›½é™…åŒ–å†…å®¹çš„æŒ‡æ ‡
    let counter = meter.create_counter(
      data.sample_text + ".counter",
      "count",
      data.display_name + " counter"
    )
    
    let histogram = meter.create_histogram(
      data.sample_text + ".histogram",
      "ms",
      data.display_name + " histogram"
    )
    
    let up_down_counter = meter.create_up_down_counter(
      data.sample_text + ".up_down_counter",
      "count",
      data.display_name + " up-down counter"
    )
    
    let gauge = meter.create_gauge(
      data.sample_text + ".gauge",
      "value",
      data.display_name + " gauge"
    )
    
    // è®°å½•åŒ…å«å›½é™…åŒ–å±æ€§çš„æŒ‡æ ‡
    let i18n_attributes = [
      ("language", common::AttributeValue::string(data.language)),
      ("region", common::AttributeValue::string(data.region)),
      ("script", common::AttributeValue::string(data.script.unwrap_or(""))),
      ("display.name", common::AttributeValue::string(data.display_name)),
      ("special.chars", common::AttributeValue::string(data.special_characters)),
      ("date.format", common::AttributeValue::string(data.date_format)),
      ("number.format", common::AttributeValue::string(data.number_format))
    ]
    
    counter.add(1L, i18n_attributes)
    histogram.record(100.5, i18n_attributes)
    up_down_counter.add(1L, i18n_attributes)
    gauge.record(50.25, i18n_attributes)
    
    // éªŒè¯å›½é™…åŒ–å±æ€§æ­£ç¡®å¤„ç†
    @assert(i18n_attributes.length() == 7)
    
    let mut j = 0
    while j < i18n_attributes.length() {
      let (key, value) = i18n_attributes[j]
      @assert(match value { common::StringValue(s) => s.length() > 0 _ => false })
      j = j + 1
    }
    
    i = i + 1
  }
}

test "logs_i18n_support" {
  // æµ‹è¯•Logs APIçš„å›½é™…åŒ–æ”¯æŒ
  
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("i18n-test-logger", "1.0.0")
  let test_data = get_i18n_test_data()
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„æ—¥å¿—æ¶ˆæ¯
  let mut i = 0
  while i < test_data.length() {
    let data = test_data[i]
    
    // ä½¿ç”¨ä¾¿æ·æ–¹æ³•è®°å½•å›½é™…åŒ–æ—¥å¿—
    logger.debug(data.sample_text, [
      ("language", common::AttributeValue::string(data.language)),
      ("region", common::AttributeValue::string(data.region)),
      ("log.level", common::AttributeValue::string("debug"))
    ])
    
    logger.info(data.sample_text, [
      ("language", common::AttributeValue::string(data.language)),
      ("region", common::AttributeValue::string(data.region)),
      ("log.level", common::AttributeValue::string("info"))
    ])
    
    logger.warn(data.sample_text, [
      ("language", common::AttributeValue::string(data.language)),
      ("region", common::AttributeValue::string(data.region)),
      ("log.level", common::AttributeValue::string("warn"))
    ])
    
    logger.error(data.sample_text, [
      ("language", common::AttributeValue::string(data.language)),
      ("region", common::AttributeValue::string(data.region)),
      ("log.level", common::AttributeValue::string("error"))
    ])
    
    logger.fatal(data.sample_text, [
      ("language", common::AttributeValue::string(data.language)),
      ("region", common::AttributeValue::string(data.region)),
      ("log.level", common::AttributeValue::string("fatal"))
    ])
    
    // åˆ›å»ºåŒ…å«å›½é™…åŒ–å†…å®¹çš„LogRecord
    let log_record = logs::LogRecord::builder()
      .timestamp(1234567890L)
      .severity(logs::Info)
      .severity_text("INFO")
      .body(data.sample_text)
      .with_attribute("language", common::AttributeValue::string(data.language))
      .with_attribute("region", common::AttributeValue::string(data.region))
      .with_attribute("script", common::AttributeValue::string(data.script.unwrap_or("")))
      .with_attribute("display.name", common::AttributeValue::string(data.display_name))
      .with_attribute("special.chars", common::AttributeValue::string(data.special_characters))
      .with_attribute("date.format", common::AttributeValue::string(data.date_format))
      .with_attribute("number.format", common::AttributeValue::string(data.number_format))
      .build()
    
    logger.emit(log_record)
    
    i = i + 1
  }
}

test "attribute_i18n_support" {
  // æµ‹è¯•å±æ€§å€¼çš„å›½é™…åŒ–æ”¯æŒ
  
  let test_data = get_i18n_test_data()
  
  // æµ‹è¯•å„ç§å›½é™…åŒ–å­—ç¬¦ä¸²å±æ€§
  let mut i = 0
  while i < test_data.length() {
    let data = test_data[i]
    
    // åˆ›å»ºå„ç§ç±»å‹çš„å›½é™…åŒ–å±æ€§
    let string_attr = common::AttributeValue::string(data.sample_text)
    let display_name_attr = common::AttributeValue::string(data.display_name)
    let special_chars_attr = common::AttributeValue::string(data.special_characters)
    let date_format_attr = common::AttributeValue::string(data.date_format)
    let number_format_attr = common::AttributeValue::string(data.number_format)
    
    // åˆ›å»ºåŒ…å«å›½é™…åŒ–å†…å®¹çš„æ•°ç»„å±æ€§
    let string_array_attr = common::AttributeValue::array_string([
      data.sample_text,
      data.display_name,
      data.special_characters
    ])
    
    // éªŒè¯å­—ç¬¦ä¸²å±æ€§
    @assert(match string_attr { common::StringValue(s) => s == data.sample_text _ => false })
    @assert(match display_name_attr { common::StringValue(s) => s == data.display_name _ => false })
    @assert(match special_chars_attr { common::StringValue(s) => s == data.special_characters _ => false })
    @assert(match date_format_attr { common::StringValue(s) => s == data.date_format _ => false })
    @assert(match number_format_attr { common::StringValue(s) => s == data.number_format _ => false })
    
    // éªŒè¯æ•°ç»„å±æ€§
    @assert(match string_array_attr { 
      common::ArrayStringValue(arr) => {
        arr.length() == 3 && 
        arr[0] == data.sample_text && 
        arr[1] == data.display_name && 
        arr[2] == data.special_characters
      } 
      _ => false 
    })
    
    i = i + 1
  }
}

test "resource_i18n_support" {
  // æµ‹è¯•èµ„æºçš„å›½é™…åŒ–æ”¯æŒ
  
  let test_data = get_i18n_test_data()
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„èµ„æºé…ç½®
  let mut i = 0
  while i < test_data.length() {
    let data = test_data[i]
    
    // åˆ›å»ºåŒ…å«å›½é™…åŒ–å†…å®¹çš„èµ„æº
    let i18n_resource = common::Resource::{
      service_name: data.display_name + " service",
      service_version: Some("1.0.0"),
      telemetry_sdk_name: "azimuth",
      telemetry_sdk_version: "0.1.0",
      attributes: [
        ("language", common::AttributeValue::string(data.language)),
        ("region", common::AttributeValue::string(data.region)),
        ("script", common::AttributeValue::string(data.script.unwrap_or(""))),
        ("description", common::AttributeValue::string(data.sample_text)),
        ("special.chars", common::AttributeValue::string(data.special_characters)),
        ("date.format", common::AttributeValue::string(data.date_format)),
        ("number.format", common::AttributeValue::string(data.number_format))
      ]
    }
    
    // éªŒè¯å›½é™…åŒ–èµ„æºå±æ€§
    @assert(i18n_resource.service_name.contains(data.display_name))
    @assert(i18n_resource.attributes.length() == 6)
    
    let mut j = 0
    while j < i18n_resource.attributes.length() {
      let (key, value) = i18n_resource.attributes[j]
      @assert(match value { common::StringValue(s) => s.length() > 0 _ => false })
      j = j + 1
    }
    
    i = i + 1
  }
}

test "cross_api_i18n_consistency" {
  // æµ‹è¯•è·¨APIçš„å›½é™…åŒ–ä¸€è‡´æ€§
  
  let test_data = get_i18n_test_data()
  
  // æµ‹è¯•æ¯ç§è¯­è¨€åœ¨æ‰€æœ‰APIä¸­çš„ä¸€è‡´æ€§
  let mut i = 0
  while i < test_data.length() {
    let data = test_data[i]
    
    // åˆ›å»ºä¸€è‡´çš„å›½é™…åŒ–å±æ€§é›†
    let i18n_attributes = [
      ("language", common::AttributeValue::string(data.language)),
      ("region", common::AttributeValue::string(data.region)),
      ("script", common::AttributeValue::string(data.script.unwrap_or(""))),
      ("display.name", common::AttributeValue::string(data.display_name)),
      ("sample.text", common::AttributeValue::string(data.sample_text)),
      ("special.chars", common::AttributeValue::string(data.special_characters))
    ]
    
    // åœ¨Traceä¸­ä½¿ç”¨å›½é™…åŒ–å±æ€§
    let tracer_provider = trace::NoopTracerProvider::{}
    let tracer = tracer_provider.get_tracer("i18n-consistency-tracer", "1.0.0")
    let (_, span) = tracer.start_span(
      context::Context::new(),
      data.sample_text,
      trace::Internal,
      i18n_attributes,
      1234567890L
    )
    
    // åœ¨Metricsä¸­ä½¿ç”¨å›½é™…åŒ–å±æ€§
    let meter_provider = metrics::NoopMeterProvider::{}
    let meter = meter_provider.get_meter("i18n-consistency-meter", "1.0.0")
    let counter = meter.create_counter(data.display_name + ".counter", "count", "Consistency test counter")
    counter.add(1L, i18n_attributes)
    
    // åœ¨Logsä¸­ä½¿ç”¨å›½é™…åŒ–å±æ€§
    let logger_provider = logs::NoopLoggerProvider::{}
    let logger = logger_provider.get_logger("i18n-consistency-logger", "1.0.0")
    let log_record = logs::LogRecord::builder()
      .severity(logs::Info)
      .body(data.sample_text)
      .with_attribute("language", common::AttributeValue::string(data.language))
      .with_attribute("region", common::AttributeValue::string(data.region))
      .with_attribute("script", common::AttributeValue::string(data.script.unwrap_or("")))
      .with_attribute("display.name", common::AttributeValue::string(data.display_name))
      .with_attribute("sample.text", common::AttributeValue::string(data.sample_text))
      .with_attribute("special.chars", common::AttributeValue::string(data.special_characters))
      .build()
    
    logger.emit(log_record)
    
    // éªŒè¯è·¨APIçš„ä¸€è‡´æ€§
    @assert(span.name == data.sample_text)
    @assert(span.attributes.length() == 6)
    
    let mut j = 0
    while j < i18n_attributes.length() {
      let (key, value) = i18n_attributes[j]
      @assert(match value { common::StringValue(s) => s.length() > 0 _ => false })
      j = j + 1
    }
    
    i = i + 1
  }
}

test "i18n_special_characters_handling" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„å¤„ç†
  
  let test_data = get_i18n_test_data()
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let mut i = 0
  while i < test_data.length() {
    let data = test_data[i]
    
    // åˆ›å»ºåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å±æ€§
    let special_char_attr = common::AttributeValue::string(data.special_characters)
    
    // éªŒè¯ç‰¹æ®Šå­—ç¬¦æ­£ç¡®ä¿å­˜
    @assert(match special_char_attr { 
      common::StringValue(s) => s == data.special_characters && s.length() > 0 
      _ => false 
    })
    
    // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åœ¨Spanä¸­çš„å¤„ç†
    let tracer_provider = trace::NoopTracerProvider::{}
    let tracer = tracer_provider.get_tracer("special-chars-tracer", "1.0.0")
    let (_, special_span) = tracer.start_span(
      context::Context::new(),
      "special-chars-test-" + data.language,
      trace::Internal,
      [("special.chars", common::AttributeValue::string(data.special_characters))],
      1234567890L
    )
    
    @assert(special_span.attributes.length() == 1)
    @assert(match special_span.attributes[0].1 { 
      common::StringValue(s) => s == data.special_characters 
      _ => false 
    })
    
    // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åœ¨æ—¥å¿—ä¸­çš„å¤„ç†
    let logger_provider = logs::NoopLoggerProvider::{}
    let logger = logger_provider.get_logger("special-chars-logger", "1.0.0")
    logger.info(data.special_characters, [
      ("language", common::AttributeValue::string(data.language)),
      ("special.chars", common::AttributeValue::string(data.special_characters))
    ])
    
    i = i + 1
  }
}

test "i18n_unicode_support" {
  // æµ‹è¯•Unicodeæ”¯æŒ
  
  // æµ‹è¯•å„ç§Unicodeå­—ç¬¦
  let unicode_test_cases = [
    ("Emoji", "ğŸš€ğŸŒŸğŸ’»ğŸ“±ğŸ”§âš¡"),
    ("Mathematical", "âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚âˆÂ±â‰¤â‰¥â‰ â‰ˆâˆˆâˆ‰âŠ‚âŠƒâˆ§âˆ¨Â¬"),
    ("Currency", "$â‚¬Â£Â¥â‚¹â‚½â‚©â‚ªâ‚«â‚¡â‚¨â‚¦â‚±â‚²â‚´â‚¸â‚¼â‚½"),
    ("Arrows", "â†â†’â†‘â†“â†–â†—â†˜â†™â‡â‡’â‡‘â‡“â‡”â‡•â‡–â‡—â‡˜â‡™"),
    ("Geometric", "â– â–¡â–²â–³â—â—‹â—†â—‡â˜…â˜†â™ â™£â™¥â™¦"),
    ("Combining", "e\u0301a\u0300o\u0302u\u0308n\u0303"),
    ("Miscellaneous", "â„¢Â®Â©Â§Â¶â€ â€¡â€¢â€¦â€°â€¹â€º""''â€“â€”"),
    ("Braille", "â â ‚â ƒâ „â …â †â ‡â ˆâ ‰â Šâ ‹â Œâ â â "),
    ("Box Drawing", "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â•­â•®â•¯â•°â•±â•²â•³"),
    ("CJK Symbols", "ã€ˆã€‰ã€Šã€‹ã€Œã€ã€ã€ã€ã€‘ã€”ã€•ã€–ã€—")
  ]
  
  // æµ‹è¯•æ¯ä¸ªUnicodeå­—ç¬¦é›†
  let mut i = 0
  while i < unicode_test_cases.length() {
    let (name, chars) = unicode_test_cases[i]
    
    // åˆ›å»ºåŒ…å«Unicodeå­—ç¬¦çš„å±æ€§
    let unicode_attr = common::AttributeValue::string(chars)
    
    // éªŒè¯Unicodeå­—ç¬¦æ­£ç¡®ä¿å­˜
    @assert(match unicode_attr { 
      common::StringValue(s) => s == chars && s.length() > 0 
      _ => false 
    })
    
    // åœ¨Spanä¸­ä½¿ç”¨Unicodeå­—ç¬¦
    let tracer_provider = trace::NoopTracerProvider::{}
    let tracer = tracer_provider.get_tracer("unicode-test-tracer", "1.0.0")
    let (_, unicode_span) = tracer.start_span(
      context::Context::new(),
      "unicode-test-" + name,
      trace::Internal,
      [
        ("unicode.name", common::AttributeValue::string(name)),
        ("unicode.chars", common::AttributeValue::string(chars))
      ],
      1234567890L
    )
    
    @assert(unicode_span.attributes.length() == 2)
    
    // åœ¨æ—¥å¿—ä¸­ä½¿ç”¨Unicodeå­—ç¬¦
    let logger_provider = logs::NoopLoggerProvider::{}
    let logger = logger_provider.get_logger("unicode-test-logger", "1.0.0")
    logger.info("Unicode test: " + name, [
      ("unicode.name", common::AttributeValue::string(name)),
      ("unicode.chars", common::AttributeValue::string(chars))
    ])
    
    // åˆ›å»ºåŒ…å«Unicodeå­—ç¬¦çš„LogRecord
    let unicode_log = logs::LogRecord::builder()
      .severity(logs::Info)
      .body("Unicode " + name + " test: " + chars)
      .with_attribute("unicode.name", common::AttributeValue::string(name))
      .with_attribute("unicode.chars", common::AttributeValue::string(chars))
      .build()
    
    logger.emit(unicode_log)
    
    i = i + 1
  }
}