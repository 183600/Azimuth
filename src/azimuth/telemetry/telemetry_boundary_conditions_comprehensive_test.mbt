// é¥æµ‹ç³»ç»Ÿè¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µæµ‹è¯•
// æµ‹è¯•å„ç§æç«¯å€¼ã€ç©ºå€¼å’Œé”™è¯¯æƒ…å†µçš„å¤„ç†

test "attribute_value_boundary_conditions" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶
  let empty_string = common::AttributeValue::string("")
  let long_string = common::AttributeValue::string("a" * 1000)
  
  match empty_string {
    common::StringValue(value) => assert_eq(value.length(), 0)
    _ => @test.fail("Expected StringValue")
  }
  
  match long_string {
    common::StringValue(value) => assert_eq(value.length(), 1000)
    _ => @test.fail("Expected StringValue")
  }
  
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œæ¡ä»¶
  let max_int = common::AttributeValue::int(9223372036854775807L)  // Int64æœ€å¤§å€¼
  let min_int = common::AttributeValue::int(-9223372036854775808L) // Int64æœ€å°å€¼
  let max_float = common::AttributeValue::float(1.7976931348623157e+308) // Doubleæœ€å¤§å€¼
  let min_float = common::AttributeValue::float(-1.7976931348623157e+308) // Doubleæœ€å°å€¼
  
  match max_int {
    common::IntValue(value) => assert_eq(value, 9223372036854775807L)
    _ => @test.fail("Expected IntValue")
  }
  
  match min_int {
    common::IntValue(value) => assert_eq(value, -9223372036854775808L)
    _ => @test.fail("Expected IntValue")
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = common::AttributeValue::array_string([])
  let empty_int_array = common::AttributeValue::array_int([])
  let empty_float_array = common::AttributeValue::array_float([])
  let empty_bool_array = common::AttributeValue::array_bool([])
  
  match empty_string_array {
    common::ArrayStringValue(values) => assert_eq(values.length(), 0)
    _ => @test.fail("Expected ArrayStringValue")
  }
  
  match empty_int_array {
    common::ArrayIntValue(values) => assert_eq(values.length(), 0)
    _ => @test.fail("Expected ArrayIntValue")
  }
}

test "context_extreme_conditions" {
  // æµ‹è¯•å¤§é‡é”®å€¼å¯¹çš„ä¸Šä¸‹æ–‡
  let mut context = context::Context::empty()
  let mut i = 0
  
  // æ·»åŠ 100ä¸ªé”®å€¼å¯¹
  while i < 100 {
    let key = context::create_key("key_" + i.to_string())
    context = context.with_value(key, "value_" + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½èƒ½æ­£ç¡®æ£€ç´¢
  i = 0
  while i < 100 {
    let key = context::create_key("key_" + i.to_string())
    let value = context.get(key)
    assert_eq(value.unwrap(), "value_" + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®è¿”å›None
  let non_existent_key = context::create_key("non_existent")
  let non_existent_value = context.get(non_existent_key)
  assert_eq(non_existent_value, None)
}

test "span_lifecycle_edge_cases" {
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("edge_case_tracer")
  
  // æµ‹è¯•ç©ºåç§°çš„span
  let (ctx1, span1) = tracer.start_span(
    context::Context::empty(),
    "",
    trace::Internal,
    [],
    0L
  )
  assert_eq(span1.name, "")
  assert_eq(span1.kind, trace::Internal)
  
  // æµ‹è¯•æé•¿åç§°çš„span
  let long_name = "a" * 1000
  let (ctx2, span2) = tracer.start_span(
    context::Context::empty(),
    long_name,
    trace::Server,
    [],
    -9223372036854775808L  // æœ€å°æ—¶é—´æˆ³
  )
  assert_eq(span2.name.length(), 1000)
  assert_eq(span2.kind, trace::Server)
  assert_eq(span2.start_time_unix_nanos, -9223372036854775808L)
  
  // æµ‹è¯•å¤§é‡å±æ€§çš„span
  let mut large_attributes = []
  let mut i = 0
  while i < 100 {
    large_attributes.push(("attr_" + i.to_string(), common::AttributeValue::int(i.to_int64())))
    i = i + 1
  }
  
  let (ctx3, span3) = tracer.start_span(
    context::Context::empty(),
    "large_attributes_span",
    trace::Client,
    large_attributes
  )
  assert_eq(span3.attributes.length(), 100)
}

test "log_record_extreme_values" {
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let min_timestamp = -9223372036854775808L
  let max_timestamp = 9223372036854775807L
  
  let log1 = logs::LogRecord::{
    timestamp_unix_nanos: min_timestamp,
    severity_number: logs::Trace,
    body: Some("Minimum timestamp log"),
    attributes: []
  }
  
  let log2 = logs::LogRecord::{
    timestamp_unix_nanos: max_timestamp,
    severity_number: logs::Fatal,
    body: Some("Maximum timestamp log"),
    attributes: []
  }
  
  assert_eq(log1.timestamp_unix_nanos, min_timestamp)
  assert_eq(log1.severity_number, logs::Trace)
  assert_eq(log2.timestamp_unix_nanos, max_timestamp)
  assert_eq(log2.severity_number, logs::Fatal)
  
  // æµ‹è¯•ä½¿ç”¨builderæ¨¡å¼åˆ›å»ºæå€¼æ—¥å¿—
  let extreme_log = logs::LogRecord::builder()
    .timestamp(9223372036854775807L)
    .severity(logs::Fatal)
    .body("Extreme conditions test")
    .with_attribute("large_number", common::AttributeValue::int(9223372036854775807L))
    .with_attribute("small_number", common::AttributeValue::int(-9223372036854775808L))
    .with_attribute("precision_float", common::AttributeValue::float(1.23456789012345e-308))
    .build()
  
  assert_eq(extreme_log.timestamp_unix_nanos, 9223372036854775807L)
  assert_eq(extreme_log.severity_number, logs::Fatal)
  assert_eq(extreme_log.attributes.length(), 3)
}

test "metric_instrument_boundary_conditions" {
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("boundary_test_meter")
  
  // åˆ›å»ºå„ç§æŒ‡æ ‡ä»ªå™¨
  let counter = meter.create_counter("", "", "")  // ç©ºåç§°ã€å•ä½ã€æè¿°
  let histogram = meter.create_histogram("a" * 1000, "b" * 100, "c" * 1000)  // æé•¿åç§°
  let up_down_counter = meter.create_up_down_counter("test_counter", "count", "Test counter")
  let gauge = meter.create_gauge("test_gauge", "value", "Test gauge")
  
  // æµ‹è¯•æå€¼æ“ä½œ
  counter.add(9223372036854775807L)  // æœ€å¤§Int64å€¼
  counter.add(-9223372036854775808L)  // æœ€å°Int64å€¼
  
  histogram.record(1.7976931348623157e+308)  // æœ€å¤§Doubleå€¼
  histogram.record(-1.7976931348623157e+308) // æœ€å°Doubleå€¼
  histogram.record(0.0)                       // é›¶å€¼
  histogram.record(1.23456789012345e-308)     // æœ€å°æ­£Doubleå€¼
  
  up_down_counter.add(9223372036854775807L)   // æœ€å¤§æ­£å€¼
  up_down_counter.add(-9223372036854775808L)  // æœ€å¤§è´Ÿå€¼
  
  gauge.record(3.14159265358979323846)        // é«˜ç²¾åº¦Ï€å€¼
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut large_metric_attributes = []
  let mut i = 0
  while i < 50 {
    large_metric_attributes.push(("metric_attr_" + i.to_string(), common::AttributeValue::float(i.to_double())))
    i = i + 1
  }
  
  counter.add(1L, large_metric_attributes)
  histogram.record(100.0, large_metric_attributes)
}

test "resource_configuration_edge_cases" {
  // æµ‹è¯•ç©ºæœåŠ¡åç§°
  let empty_resource = common::Resource::default("")
  assert_eq(empty_resource.service_name, "")
  assert_eq(empty_resource.service_version, None)
  
  // æµ‹è¯•æé•¿æœåŠ¡åç§°
  let long_service_name = "a" * 1000
  let long_resource = common::Resource::default(long_service_name)
  assert_eq(long_resource.service_name.length(), 1000)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut large_attributes = []
  let mut i = 0
  while i < 200 {
    large_attributes.push(("resource_attr_" + i.to_string(), common::AttributeValue::string("value_" + i.to_string())))
    i = i + 1
  }
  
  let resource_with_many_attrs = common::Resource::{
    service_name: "test_service",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: large_attributes
  }
  
  assert_eq(resource_with_many_attrs.attributes.length(), 200)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§å€¼
  let special_attributes = [
    ("unicode", common::AttributeValue::string("æµ‹è¯•ğŸš€emoji")),
    ("special_chars", common::AttributeValue::string("!@#$%^&*()_+-=[]{}|;':\",./<>?")),
    ("newlines", common::AttributeValue::string("line1\nline2\rline3")),
    ("tabs", common::AttributeValue::string("col1\tcol2\tcol3")),
    ("quotes", common::AttributeValue::string("\"single\" and 'double' quotes"))
  ]
  
  let special_resource = common::Resource::{
    service_name: "special_test",
    service_version: None,
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: special_attributes
  }
  
  assert_eq(special_resource.attributes.length(), 5)
}