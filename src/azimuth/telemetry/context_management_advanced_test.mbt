// ä¸Šä¸‹æ–‡ç®¡ç†é«˜çº§æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Azimuth Telemetry Context APIçš„é«˜çº§åŠŸèƒ½

test "context_creation_and_basic_operations" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡åˆ›å»ºå’ŒåŸºæœ¬æ“ä½œ
  
  // åˆ›å»ºç©ºä¸Šä¸‹æ–‡
  let empty_context = context::Context::empty()
  assert_eq(empty_context.values.length(), 0)
  
  // åˆ›å»ºContextKey
  let trace_key = context::create_key("trace.id")
  let user_key = context::create_key("user.id")
  let request_key = context::create_key("request.id")
  
  assert_eq(trace_key.name, "trace.id")
  assert_eq(user_key.name, "user.id")
  assert_eq(request_key.name, "request.id")
  
  // åœ¨ä¸Šä¸‹æ–‡ä¸­è®¾ç½®å€¼
  let context_with_trace = empty_context.with_value(trace_key, "0af7651916cd43dd8448eb211c80319c")
  assert_eq(context_with_trace.values.length(), 1)
  
  let context_with_user = context_with_trace.with_value(user_key, "user-12345")
  assert_eq(context_with_user.values.length(), 2)
  
  let context_with_request = context_with_user.with_value(request_key, "req-67890")
  assert_eq(context_with_request.values.length(), 3)
  
  // ä»ä¸Šä¸‹æ–‡ä¸­è·å–å€¼
  match context_with_request.get(trace_key) {
    Some(trace_id) => assert_eq(trace_id, "0af7651916cd43dd8448eb211c80319c")
    None => assert_eq(false, true, "Expected trace ID to be found")
  }
  
  match context_with_request.get(user_key) {
    Some(user_id) => assert_eq(user_id, "user-12345")
    None => assert_eq(false, true, "Expected user ID to be found")
  }
  
  match context_with_request.get(request_key) {
    Some(request_id) => assert_eq(request_id, "req-67890")
    None => assert_eq(false, true, "Expected request ID to be found")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  let missing_key = context::create_key("missing.key")
  match context_with_request.get(missing_key) {
    Some(_) => assert_eq(false, true, "Expected missing key to return None")
    None => assert_eq(true, true)  // æœŸæœ›çš„è¡Œä¸º
  }
}

test "context_immutability_and_chaining" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¸å¯å˜æ€§å’Œé“¾å¼æ“ä½œ
  
  let base_context = context::Context::empty()
  
  // åˆ›å»ºå¤šä¸ªé”®
  let key1 = context::create_key("key1")
  let key2 = context::create_key("key2")
  let key3 = context::create_key("key3")
  
  // é“¾å¼è®¾ç½®å€¼
  let context1 = base_context.with_value(key1, "value1")
  let context2 = context1.with_value(key2, "value2")
  let context3 = context2.with_value(key3, "value3")
  
  // éªŒè¯æ¯ä¸ªä¸Šä¸‹æ–‡çš„çŠ¶æ€
  assert_eq(base_context.values.length(), 0)
  assert_eq(context1.values.length(), 1)
  assert_eq(context2.values.length(), 2)
  assert_eq(context3.values.length(), 3)
  
  // éªŒè¯åŸå§‹ä¸Šä¸‹æ–‡æœªè¢«ä¿®æ”¹
  match base_context.get(key1) {
    Some(_) => assert_eq(false, true, "Original context should not contain key1")
    None => assert_eq(true, true)
  }
  
  // éªŒè¯æ¯ä¸ªä¸Šä¸‹æ–‡åŒ…å«æ­£ç¡®çš„å€¼
  match context1.get(key1) {
    Some(value) => assert_eq(value, "value1")
    None => assert_eq(false, true, "context1 should contain key1")
  }
  
  match context2.get(key1) {
    Some(value) => assert_eq(value, "value1")
    None => assert_eq(false, true, "context2 should contain key1")
  }
  
  match context2.get(key2) {
    Some(value) => assert_eq(value, "value2")
    None => assert_eq(false, true, "context2 should contain key2")
  }
  
  match context3.get(key3) {
    Some(value) => assert_eq(value, "value3")
    None => assert_eq(false, true, "context3 should contain key3")
  }
  
  // æµ‹è¯•å€¼è¦†ç›–
  let context3_updated = context3.with_value(key1, "new_value1")
  
  match context3_updated.get(key1) {
    Some(value) => assert_eq(value, "new_value1")
    None => assert_eq(false, true, "Updated context should contain new value for key1")
  }
  
  // åŸå§‹ä¸Šä¸‹æ–‡åº”è¯¥ä¿æŒä¸å˜
  match context3.get(key1) {
    Some(value) => assert_eq(value, "value1")
    None => assert_eq(false, true, "Original context3 should still contain old value for key1")
  }
}

test "baggage_operations_and_management" {
  // æµ‹è¯•è¡Œæ(Baggage)æ“ä½œå’Œç®¡ç†
  
  // åˆ›å»ºç©ºè¡Œæ
  let empty_baggage = context::Baggage::empty()
  assert_eq(empty_baggage.entries.length(), 0)
  
  // æ·»åŠ è¡Œææ¡ç›®
  let baggage_with_user = empty_baggage.with_entry("user.id", "user-12345")
  assert_eq(baggage_with_user.entries.length(), 1)
  
  let baggage_with_session = baggage_with_user.with_entry("session.id", "session-abcdef")
  assert_eq(baggage_with_session.entries.length(), 2)
  
  let baggage_with_tenant = baggage_with_session.with_entry("tenant.id", "tenant-001")
  assert_eq(baggage_with_tenant.entries.length(), 3)
  
  // éªŒè¯è¡Œææ¡ç›®
  match baggage_with_tenant.get("user.id") {
    Some(user_id) => assert_eq(user_id, "user-12345")
    None => assert_eq(false, true, "Expected user.id to be found")
  }
  
  match baggage_with_tenant.get("session.id") {
    Some(session_id) => assert_eq(session_id, "session-abcdef")
    None => assert_eq(false, true, "Expected session.id to be found")
  }
  
  match baggage_with_tenant.get("tenant.id") {
    Some(tenant_id) => assert_eq(tenant_id, "tenant-001")
    None => assert_eq(false, true, "Expected tenant.id to be found")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  match baggage_with_tenant.get("nonexistent.key") {
    Some(_) => assert_eq(false, true, "Expected nonexistent key to return None")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•è¡Œæä¸å¯å˜æ€§
  let original_baggage = baggage_with_tenant
  let updated_baggage = baggage_with_tenant.with_entry("user.id", "user-67890")
  
  // åŸå§‹è¡Œæåº”è¯¥ä¿æŒä¸å˜
  match original_baggage.get("user.id") {
    Some(user_id) => assert_eq(user_id, "user-12345")
    None => assert_eq(false, true, "Original baggage should contain original user.id")
  }
  
  // æ›´æ–°çš„è¡Œæåº”è¯¥åŒ…å«æ–°å€¼
  match updated_baggage.get("user.id") {
    Some(user_id) => assert_eq(user_id, "user-67890")
    None => assert_eq(false, true, "Updated baggage should contain new user.id")
  }
  
  // éªŒè¯å…¶ä»–æ¡ç›®ä¿æŒä¸å˜
  match updated_baggage.get("session.id") {
    Some(session_id) => assert_eq(session_id, "session-abcdef")
    None => assert_eq(false, true, "Updated baggage should still contain session.id")
  }
}

test "context_and_baggage_integration" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡å’Œè¡Œæçš„é›†æˆ
  
  let base_context = context::Context::empty()
  let base_baggage = context::Baggage::empty()
  
  // åˆ›å»ºä¸Šä¸‹æ–‡é”®
  let trace_id_key = context::create_key("trace.id")
  let span_id_key = context::create_key("span.id")
  let baggage_key = context::create_key("baggage")
  
  // åœ¨ä¸Šä¸‹æ–‡ä¸­è®¾ç½®è¿½è¸ªä¿¡æ¯
  let trace_context = base_context.with_value(trace_id_key, "0af7651916cd43dd8448eb211c80319c")
  let full_trace_context = trace_context.with_value(span_id_key, "b7ad6b7169203331")
  
  // åˆ›å»ºè¡Œææ¡ç›®
  let baggage = base_baggage
    .with_entry("user.id", "user-12345")
    .with_entry("request.id", "req-67890")
    .with_entry("tenant.id", "tenant-001")
    .with_entry("session.id", "session-abcdef")
  
  // å°†è¡Œæåºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²å¹¶å­˜å‚¨åœ¨ä¸Šä¸‹æ–‡ä¸­
  let baggage_string = "user.id=user-12345,request.id=req-67890,tenant.id=tenant-001,session.id=session-abcdef"
  let context_with_baggage = full_trace_context.with_value(baggage_key, baggage_string)
  
  // éªŒè¯ä¸Šä¸‹æ–‡åŒ…å«æ‰€æœ‰ä¿¡æ¯
  match context_with_baggage.get(trace_id_key) {
    Some(trace_id) => assert_eq(trace_id, "0af7651916cd43dd8448eb211c80319c")
    None => assert_eq(false, true, "Expected trace ID in context")
  }
  
  match context_with_baggage.get(span_id_key) {
    Some(span_id) => assert_eq(span_id, "b7ad6b7169203331")
    None => assert_eq(false, true, "Expected span ID in context")
  }
  
  match context_with_baggage.get(baggage_key) {
    Some(baggage_data) => {
      assert_eq(baggage_data.contains("user.id=user-12345"), true)
      assert_eq(baggage_data.contains("request.id=req-67890"), true)
      assert_eq(baggage_data.contains("tenant.id=tenant-001"), true)
      assert_eq(baggage_data.contains("session.id=session-abcdef"), true)
    }
    None => assert_eq(false, true, "Expected baggage in context")
  }
  
  // æµ‹è¯•å¤æ‚åœºæ™¯ï¼šå¤šå±‚ä¸Šä¸‹æ–‡
  let operation_key = context::create_key("operation.name")
  let service_key = context::create_key("service.name")
  
  let operation_context = context_with_baggage.with_value(operation_key, "process-payment")
  let service_context = operation_context.with_value(service_key, "payment-service")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨
  match service_context.get(operation_key) {
    Some(operation) => assert_eq(operation, "process-payment")
    None => assert_eq(false, true, "Expected operation name")
  }
  
  match service_context.get(service_key) {
    Some(service) => assert_eq(service, "payment-service")
    None => assert_eq(false, true, "Expected service name")
  }
  
  // éªŒè¯ä¹‹å‰çš„å€¼ä»ç„¶å­˜åœ¨
  match service_context.get(trace_id_key) {
    Some(trace_id) => assert_eq(trace_id, "0af7651916cd43dd8448eb211c80319c")
    None => assert_eq(false, true, "Expected trace ID to persist")
  }
}

test "context_edge_cases_and_error_handling" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯å¤„ç†
  
  let empty_context = context::Context::empty()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®å’Œå€¼
  let empty_key = context::create_key("")
  let context_with_empty_key = empty_context.with_value(empty_key, "value")
  
  match context_with_empty_key.get(empty_key) {
    Some(value) => assert_eq(value, "value")
    None => assert_eq(false, true, "Should handle empty key")
  }
  
  let normal_key = context::create_key("normal.key")
  let context_with_empty_value = empty_context.with_value(normal_key, "")
  
  match context_with_empty_value.get(normal_key) {
    Some(value) => assert_eq(value, "")
    None => assert_eq(false, true, "Should handle empty value")
  }
  
  // æµ‹è¯•é•¿é”®å’Œå€¼
  let long_key_name = "this.is.a.very.long.key.name.that.tests.the.systems.ability.to.handle.extended.key.names.without.issues"
  let long_key = context::create_key(long_key_name)
  let long_value = "this.is.a.very.long.value.that.tests.the.systems.ability.to.handle.extended.values.without.issues.and.includes.various.characters.like.1234567890.and.special.chars.@#$%"
  
  let context_with_long_values = empty_context.with_value(long_key, long_value)
  
  match context_with_long_values.get(long_key) {
    Some(value) => assert_eq(value, long_value)
    None => assert_eq(false, true, "Should handle long key and value")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_char_key = context::create_key("key.with-special_chars@123#$%^&*()")
  let special_char_value = "value.with-special_chars@123#$%^&*() and spaces and	tabs
and newlines"
  
  let context_with_special_chars = empty_context.with_value(special_char_key, special_char_value)
  
  match context_with_special_chars.get(special_char_key) {
    Some(value) => assert_eq(value, special_char_value)
    None => assert_eq(false, true, "Should handle special characters")
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_key = context::create_key("unicode.key.æµ‹è¯•")
  let unicode_value = "unicode.value.æµ‹è¯•.ğŸš€.ğŸŒŸ.ğŸ’«"
  
  let context_with_unicode = empty_context.with_value(unicode_key, unicode_value)
  
  match context_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_value)
    None => assert_eq(false, true, "Should handle Unicode characters")
  }
  
  // æµ‹è¯•å¤§é‡ä¸Šä¸‹æ–‡æ¡ç›®
  let mut context_with_many_entries = empty_context
  let mut i = 0
  while i < 100 {
    let key = context::create_key("key." + i.to_string())
    let value = "value." + i.to_string()
    context_with_many_entries = context_with_many_entries.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯ä¸€äº›æ¡ç›®
  let test_key_0 = context::create_key("key.0")
  let test_key_50 = context::create_key("key.50")
  let test_key_99 = context::create_key("key.99")
  
  match context_with_many_entries.get(test_key_0) {
    Some(value) => assert_eq(value, "value.0")
    None => assert_eq(false, true, "Should find key.0")
  }
  
  match context_with_many_entries.get(test_key_50) {
    Some(value) => assert_eq(value, "value.50")
    None => assert_eq(false, true, "Should find key.50")
  }
  
  match context_with_many_entries.get(test_key_99) {
    Some(value) => assert_eq(value, "value.99")
    None => assert_eq(false, true, "Should find key.99")
  }
}

test "baggage_serialization_and_deserialization" {
  // æµ‹è¯•è¡Œæåºåˆ—åŒ–å’Œååºåˆ—åŒ–
  
  let empty_baggage = context::Baggage::empty()
  
  // åˆ›å»ºå¤æ‚çš„è¡Œæ
  let complex_baggage = empty_baggage
    .with_entry("user.id", "user-12345")
    .with_entry("session.id", "session-abcdef")
    .with_entry("tenant.id", "tenant-001")
    .with_entry("request.id", "req-67890")
    .with_entry("correlation.id", "corr-12345")
    .with_entry("trace.id", "trace-abcdef123456")
    .with_entry("service.name", "payment-service")
    .with_entry("service.version", "v2.1.0")
    .with_entry("environment", "production")
    .with_entry("region", "us-west-2")
  
  // æ‰‹åŠ¨åºåˆ—åŒ–è¡Œæï¼ˆåœ¨å®é™…å®ç°ä¸­å¯èƒ½æœ‰ä¸“é—¨çš„åºåˆ—åŒ–å‡½æ•°ï¼‰
  let mut baggage_string = ""
  let mut i = 0
  while i < complex_baggage.entries.length() {
    let (key, value) = complex_baggage.entries[i]
    if i > 0 {
      baggage_string = baggage_string + ","
    }
    baggage_string = baggage_string + key + "=" + value
    i = i + 1
  }
  
  // éªŒè¯åºåˆ—åŒ–å­—ç¬¦ä¸²
  assert_eq(baggage_string.contains("user.id=user-12345"), true)
  assert_eq(baggage_string.contains("session.id=session-abcdef"), true)
  assert_eq(baggage_string.contains("tenant.id=tenant-001"), true)
  assert_eq(baggage_string.contains("environment=production"), true)
  assert_eq(baggage_string.contains("region=us-west-2"), true)
  
  // è®¡ç®—æ¡ç›®æ•°é‡
  let mut entry_count = 0
  let mut pos = 0
  while pos < baggage_string.length() {
    if baggage_string[pos] == '=' {
      entry_count = entry_count + 1
    }
    pos = pos + 1
  }
  assert_eq(entry_count, 10)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„è¡Œæå€¼
  let special_baggage = empty_baggage
    .with_entry("complex.value", "value,with,commas")
    .with_entry("url.value", "https://example.com/path?param=value&other=123")
    .with_entry("json.value", "{\"key\":\"value\",\"number\":123}")
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å€¼
  match special_baggage.get("complex.value") {
    Some(value) => assert_eq(value, "value,with,commas")
    None => assert_eq(false, true, "Should find complex value")
  }
  
  match special_baggage.get("url.value") {
    Some(value) => assert_eq(value.contains("https://"), true)
    None => assert_eq(false, true, "Should find URL value")
  }
  
  match special_baggage.get("json.value") {
    Some(value) => assert_eq(value.contains("\"key\":\"value\""), true)
    None => assert_eq(false, true, "Should find JSON value")
  }
}

test "context_performance_and_efficiency" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡æ€§èƒ½å’Œæ•ˆç‡
  
  let empty_context = context::Context::empty()
  
  // æµ‹è¯•å¤§é‡ä¸Šä¸‹æ–‡åˆ›å»ºå’Œæ“ä½œçš„æ€§èƒ½
  let start_time = 1000000L  // æ¨¡æ‹Ÿå¼€å§‹æ—¶é—´
  
  let mut performance_context = empty_context
  let mut i = 0
  
  // åˆ›å»º1000ä¸ªä¸Šä¸‹æ–‡æ¡ç›®
  while i < 1000 {
    let key = context::create_key("perf.key." + i.to_string())
    let value = "perf.value." + i.to_string()
    performance_context = performance_context.with_value(key, value)
    i = i + 1
  }
  
  let mid_time = 1001000L  // æ¨¡æ‹Ÿä¸­é—´æ—¶é—´
  
  // éªŒè¯æ€§èƒ½ä¸Šä¸‹æ–‡åŒ…å«æ‰€æœ‰æ¡ç›®
  assert_eq(performance_context.values.length(), 1000)
  
  // æµ‹è¯•æŸ¥æ‰¾æ€§èƒ½
  let test_key_100 = context::create_key("perf.key.100")
  let test_key_500 = context::create_key("perf.key.500")
  let test_key_999 = context::create_key("perf.key.999")
  
  match performance_context.get(test_key_100) {
    Some(value) => assert_eq(value, "perf.value.100")
    None => assert_eq(false, true, "Should find perf.key.100")
  }
  
  match performance_context.get(test_key_500) {
    Some(value) => assert_eq(value, "perf.value.500")
    None => assert_eq(false, true, "Should find perf.key.500")
  }
  
  match performance_context.get(test_key_999) {
    Some(value) => assert_eq(value, "perf.value.999")
    None => assert_eq(false, true, "Should find perf.key.999")
  }
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡é“¾çš„æ€§èƒ½
  let mut chained_context = empty_context
  i = 0
  
  // åˆ›å»ºæ·±å±‚ä¸Šä¸‹æ–‡é“¾
  while i < 100 {
    let key = context::create_key("chain.key." + i.to_string())
    let value = "chain.value." + i.to_string()
    chained_context = chained_context.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯é“¾å¼ä¸Šä¸‹æ–‡
  assert_eq(chained_context.values.length(), 100)
  
  let chain_test_key = context::create_key("chain.key.50")
  match chained_context.get(chain_test_key) {
    Some(value) => assert_eq(value, "chain.value.50")
    None => assert_eq(false, true, "Should find chain.key.50")
  }
  
  let end_time = 1002000L  // æ¨¡æ‹Ÿç»“æŸæ—¶é—´
  
  // è®¡ç®—æ“ä½œæ—¶é—´ï¼ˆåœ¨å®é™…æ€§èƒ½æµ‹è¯•ä¸­ä¼šä½¿ç”¨çœŸå®æ—¶é—´ï¼‰
  let total_operations = 1000 + 100  // 1000ä¸ªç›´æ¥æ“ä½œ + 100ä¸ªé“¾å¼æ“ä½œ
  let total_time = end_time - start_time
  
  assert_eq(total_time > 0L, true)
  assert_eq(total_operations, 1100)
}