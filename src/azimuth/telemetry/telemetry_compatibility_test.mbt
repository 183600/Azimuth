// é¥æµ‹å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹

test "compatibility_data_format_evolution" {
  // æµ‹è¯•æ•°æ®æ ¼å¼æ¼”åŒ–çš„å…¼å®¹æ€§
  
  // æ¨¡æ‹Ÿæ—§ç‰ˆæœ¬æ•°æ®æ ¼å¼
  let legacy_data = [
    ("service.name", "legacy-service"),
    ("service.version", "1.0.0"),
    ("trace.id", "legacy-trace-123"),
    ("span.id", "legacy-span-456")
  ]
  
  // æ¨¡æ‹Ÿæ–°ç‰ˆæœ¬æ•°æ®æ ¼å¼ï¼ˆåŒ…å«é¢å¤–å­—æ®µï¼‰
  let modern_data = [
    ("service.name", "modern-service"),
    ("service.version", "2.0.0"),
    ("service.namespace", "production"),
    ("service.instance.id", "instance-789"),
    ("trace.id", "modern-trace-abc"),
    ("span.id", "modern-span-def"),
    ("trace.flags", "01"),
    ("trace.state", "rojo=00f067aa0ba902b7")
  ]
  
  // éªŒè¯æ–°æ—§æ ¼å¼çš„åŸºæœ¬å…¼å®¹æ€§
  let mut legacy_has_basic_fields = true
  let mut modern_has_basic_fields = true
  
  // æ£€æŸ¥åŸºæœ¬å­—æ®µå­˜åœ¨
  let mut i = 0
  while i < legacy_data.length() {
    let (key, _) = legacy_data[i]
    if key == "service.name" || key == "service.version" || key == "trace.id" || key == "span.id" {
      // åŸºæœ¬å­—æ®µå­˜åœ¨
    } else {
      legacy_has_basic_fields = false
      break
    }
    i = i + 1
  }
  
  let mut j = 0
  while j < modern_data.length() {
    let (key, _) = modern_data[j]
    if key == "service.name" || key == "service.version" || key == "trace.id" || key == "span.id" {
      // åŸºæœ¬å­—æ®µå­˜åœ¨
    }
    j = j + 1
  }
  
  assert_eq(legacy_has_basic_fields, true)
  assert_eq(modern_has_basic_fields, true)
  
  // éªŒè¯æ–°æ ¼å¼åŒ…å«é¢å¤–å­—æ®µ
  let mut has_namespace = false
  let mut has_instance_id = false
  let mut has_trace_flags = false
  
  let mut k = 0
  while k < modern_data.length() {
    let (key, _) = modern_data[k]
    if key == "service.namespace" {
      has_namespace = true
    } else if key == "service.instance.id" {
      has_instance_id = true
    } else if key == "trace.flags" {
      has_trace_flags = true
    }
    k = k + 1
  }
  
  assert_eq(has_namespace, true)
  assert_eq(has_instance_id, true)
  assert_eq(has_trace_flags, true)
}

test "compatibility_attribute_value_types" {
  // æµ‹è¯•å±æ€§å€¼ç±»å‹çš„å…¼å®¹æ€§
  use azimuth.telemetry.api.common.AttributeValue
  
  // ä¼ ç»Ÿç±»å‹
  let legacy_string = AttributeValue::string("legacy.value")
  let legacy_int = AttributeValue::int(42L)
  let legacy_float = AttributeValue::float(3.14)
  let legacy_bool = AttributeValue::bool(true)
  
  // æ–°å¢ç±»å‹ï¼ˆæ•°ç»„ç±»å‹ï¼‰
  let modern_string_array = AttributeValue::array_string(["item1", "item2", "item3"])
  let modern_int_array = AttributeValue::array_int([1L, 2L, 3L, 4L])
  let modern_float_array = AttributeValue::array_float([1.1, 2.2, 3.3])
  let modern_bool_array = AttributeValue::array_bool([true, false, true])
  
  // éªŒè¯ä¼ ç»Ÿç±»å‹ä»ç„¶å·¥ä½œ
  match legacy_string {
    StringValue(s) => assert_eq(s, "legacy.value")
    _ => @test.fail("Test failed")
  }
  
  match legacy_int {
    IntValue(i) => assert_eq(i, 42L)
    _ => @test.fail("Test failed")
  }
  
  match legacy_float {
    FloatValue(f) => assert_eq(f, 3.14)
    _ => @test.fail("Test failed")
  }
  
  match legacy_bool {
    BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("Test failed")
  }
  
  // éªŒè¯æ–°ç±»å‹å·¥ä½œ
  match modern_string_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], "item1")
      assert_eq(arr[2], "item3")
    }
    _ => @test.fail("Test failed")
  }
  
  match modern_int_array {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 4)
      assert_eq(arr[0], 1L)
      assert_eq(arr[3], 4L)
    }
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç±»å‹å…¼å®¹æ€§ï¼šæ··åˆä½¿ç”¨æ–°æ—§ç±»å‹
  let mixed_attrs : Array[(String, AttributeValue)] = [
    ("legacy.string", legacy_string),
    ("legacy.int", legacy_int),
    ("modern.string.array", modern_string_array),
    ("modern.int.array", modern_int_array)
  ]
  
  assert_eq(mixed_attrs.length(), 4)
  
  // éªŒè¯æ··åˆå±æ€§è®¿é—®
  match mixed_attrs[0].1 {
    StringValue(s) => assert_eq(s, "legacy.value")
    _ => @test.fail("Test failed")
  }
  
  match mixed_attrs[2].1 {
    ArrayStringValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
}

test "compatibility_context_api_evolution" {
  // æµ‹è¯•Context APIæ¼”åŒ–çš„å…¼å®¹æ€§
  
  // ä¼ ç»ŸAPIä½¿ç”¨æ–¹å¼
  let ctx = Context::empty()
  let legacy_key = create_key("legacy.key")
  let ctx_with_legacy = ctx.with_value(legacy_key, "legacy.value")
  
  // éªŒè¯ä¼ ç»ŸAPIä»ç„¶å·¥ä½œ
  match ctx_with_legacy.get(legacy_key) {
    Some(value) => assert_eq(value, "legacy.value")
    None => @test.fail("Test failed")
  }
  
  // æ–°å¼APIä½¿ç”¨æ–¹å¼ï¼ˆæ¨¡æ‹Ÿï¼‰
  let modern_key = create_key("modern.key.with.dots")
  let ctx_with_modern = ctx_with_legacy.with_value(modern_key, "modern.value")
  
  // éªŒè¯æ–°å¼APIå·¥ä½œ
  match ctx_with_modern.get(modern_key) {
    Some(value) => assert_eq(value, "modern.value")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯å‘åå…¼å®¹ï¼šä¼ ç»Ÿæ•°æ®ä»ç„¶å¯è®¿é—®
  match ctx_with_modern.get(legacy_key) {
    Some(value) => assert_eq(value, "legacy.value")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç‰¹æ®Šé”®åçš„å…¼å®¹æ€§
  let special_keys = [
    create_key("key.with.dots"),
    create_key("key_with_underscores"),
    create_key("key-with-hyphens"),
    create_key("key.with spaces"),
    create_key("key@with#special%chars")
  ]
  
  let mut ctx_with_special_keys = ctx_with_modern
  let mut idx = 0
  while idx < special_keys.length() {
    let key = special_keys[idx]
    let value = "value.for." + idx.to_string()
    ctx_with_special_keys = ctx_with_special_keys.with_value(key, value)
    idx = idx + 1
  }
  
  // éªŒè¯ç‰¹æ®Šé”®åå…¼å®¹æ€§
  let mut verify_idx = 0
  while verify_idx < special_keys.length() {
    let key = special_keys[verify_idx]
    let expected_value = "value.for." + verify_idx.to_string()
    
    match ctx_with_special_keys.get(key) {
      Some(value) => assert_eq(value, expected_value)
      None => @test.fail("Special key compatibility failed for key " + verify_idx.to_string())
    }
    verify_idx = verify_idx + 1
  }
}

test "compatibility_baggage_format_changes" {
  // æµ‹è¯•Baggageæ ¼å¼å˜åŒ–çš„å…¼å®¹æ€§
  
  // ä¼ ç»Ÿbaggageæ ¼å¼
  let legacy_baggage = Baggage::empty()
  let legacy_with_data = legacy_baggage
    .with_entry("legacy.key1", "legacy.value1")
    .with_entry("legacy.key2", "legacy.value2")
  
  // æ–°å¼baggageæ ¼å¼ï¼ˆåŒ…å«æ›´å¤æ‚çš„é”®åå’Œå€¼ï¼‰
  let modern_baggage = Baggage::empty()
  let modern_with_data = modern_baggage
    .with_entry("modern.namespace.key1", "modern.value1")
    .with_entry("modern.namespace.key2", "modern.value2")
    .with_entry("complex.key-with.special.chars", "complex.value!@#$%")
    .with_entry("unicode.key.æµ‹è¯•", "unicode.value.ğŸš€")
  
  // éªŒè¯ä¼ ç»Ÿæ ¼å¼å·¥ä½œ
  match legacy_with_data.get("legacy.key1") {
    Some(value) => assert_eq(value, "legacy.value1")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯æ–°å¼æ ¼å¼å·¥ä½œ
  match modern_with_data.get("modern.namespace.key1") {
    Some(value) => assert_eq(value, "modern.value1")
    None => @test.fail("Test failed")
  }
  
  match modern_with_data.get("unicode.key.æµ‹è¯•") {
    Some(value) => assert_eq(value, "unicode.value.ğŸš€")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æ ¼å¼æ··åˆä½¿ç”¨
  let mixed_baggage = legacy_with_data
    .with_entry("modern.mixed.key", "mixed.value")
    .with_entry("another.legacy.key", "another.legacy.value")
  
  // éªŒè¯æ··åˆæ ¼å¼å…¼å®¹æ€§
  match mixed_baggage.get("legacy.key1") {
    Some(value) => assert_eq(value, "legacy.value1")
    None => @test.fail("Test failed")
  }
  
  match mixed_baggage.get("modern.mixed.key") {
    Some(value) => assert_eq(value, "mixed.value")
    None => @test.fail("Test failed")
  }
}

test "compatibility_serialization_formats" {
  // æµ‹è¯•åºåˆ—åŒ–æ ¼å¼çš„å…¼å®¹æ€§
  
  // ä¼ ç»Ÿåºåˆ—åŒ–æ ¼å¼ï¼ˆé”®å€¼å¯¹ï¼‰
  let legacy_format_data = [
    ("service.name", "legacy-service"),
    ("trace.id", "123456"),
    ("span.id", "789012")
  ]
  
  // ä¼ ç»Ÿæ ¼å¼åºåˆ—åŒ–
  let mut legacy_serialized = ""
  let mut i = 0
  while i < legacy_format_data.length() {
    let (key, value) = legacy_format_data[i]
    if i > 0 {
      legacy_serialized = legacy_serialized + ","
    }
    legacy_serialized = legacy_serialized + key + "=" + value
    i = i + 1
  }
  
  // æ–°å¼åºåˆ—åŒ–æ ¼å¼ï¼ˆJSONé£æ ¼ï¼‰
  let modern_format_data = [
    ("service.name", "modern-service"),
    ("service.version", "2.0.0"),
    ("trace.id", "abcdef"),
    ("span.id", "fedcba"),
    ("metadata.timestamp", "1640995200000000000")
  ]
  
  // æ–°å¼æ ¼å¼åºåˆ—åŒ–
  let mut modern_serialized = "{"
  let mut j = 0
  while j < modern_format_data.length() {
    let (key, value) = modern_format_data[j]
    if j > 0 {
      modern_serialized = modern_serialized + ","
    }
    modern_serialized = modern_serialized + "\"" + key + "\":\"" + value + "\""
    j = j + 1
  }
  modern_serialized = modern_serialized + "}"
  
  // éªŒè¯ä¼ ç»Ÿæ ¼å¼è§£æ
  assert_eq(legacy_serialized.contains("service.name=legacy-service"), true)
  assert_eq(legacy_serialized.contains("trace.id=123456"), true)
  assert_eq(legacy_serialized.contains(","), true)  // æœ‰åˆ†éš”ç¬¦
  
  // éªŒè¯æ–°å¼æ ¼å¼è§£æ
  assert_eq(modern_serialized.contains("\"service.name\":\"modern-service\""), true)
  assert_eq(modern_serialized.contains("\"trace.id\":\"abcdef\""), true)
  assert_eq(modern_serialized.has_prefix("{"), true)
  assert_eq(modern_serialized.has_suffix("}"), true)
  
  // æµ‹è¯•æ ¼å¼å…¼å®¹æ€§ï¼šä¸¤ç§æ ¼å¼éƒ½èƒ½è§£æåŸºæœ¬æ•°æ®
  let legacy_pairs = legacy_serialized",".split_to_string()
  let modern_content = modern_serialized.slice(1, modern_serialized.length() - 1)  // å»æ‰å¤§æ‹¬å·
  let modern_pairs = modern_content",".split_to_string()
  
  assert_eq(legacy_pairs.length(), 3)
  assert_eq(modern_pairs.length(), 5)
  
  // éªŒè¯åŸºæœ¬å­—æ®µåœ¨ä¸¤ç§æ ¼å¼ä¸­éƒ½å­˜åœ¨
  let mut legacy_has_service_name = false
  let mut modern_has_service_name = false
  
  let mut k = 0
  while k < legacy_pairs.length() {
    if legacy_pairs[k].contains("service.name") {
      legacy_has_service_name = true
      break
    }
    k = k + 1
  }
  
  let mut l = 0
  while l < modern_pairs.length() {
    if modern_pairs[l].contains("service.name") {
      modern_has_service_name = true
      break
    }
    l = l + 1
  }
  
  assert_eq(legacy_has_service_name, true)
  assert_eq(modern_has_service_name, true)
}

test "compatibility_version_negotiation" {
  // æµ‹è¯•ç‰ˆæœ¬åå•†å…¼å®¹æ€§
  
  // æ¨¡æ‹Ÿä¸åŒç‰ˆæœ¬çš„é¥æµ‹æ•°æ®
  let v1_data = [
    ("version", "1.0"),
    ("service.name", "v1-service"),
    ("trace.id", "v1-trace")
  ]
  
  let v2_data = [
    ("version", "2.0"),
    ("service.name", "v2-service"),
    ("service.namespace", "production"),
    ("trace.id", "v2-trace"),
    ("trace.flags", "01")
  ]
  
  let v3_data = [
    ("version", "3.0"),
    ("service.name", "v3-service"),
    ("service.namespace", "staging"),
    ("service.instance.id", "instance-123"),
    ("trace.id", "v3-trace"),
    ("trace.flags", "01"),
    ("trace.state", "rojo=00f067aa0ba902b7"),
    ("metadata.timestamp", "1640995200000000000")
  ]
  
  // éªŒè¯ç‰ˆæœ¬è¯†åˆ«
  let mut v1_found = false
  let mut v2_found = false
  let mut v3_found = false
  
  let mut i = 0
  while i < v1_data.length() {
    let (key, value) = v1_data[i]
    if key == "version" && value == "1.0" {
      v1_found = true
      break
    }
    i = i + 1
  }
  
  let mut j = 0
  while j < v2_data.length() {
    let (key, value) = v2_data[j]
    if key == "version" && value == "2.0" {
      v2_found = true
      break
    }
    j = j + 1
  }
  
  let mut k = 0
  while k < v3_data.length() {
    let (key, value) = v3_data[k]
    if key == "version" && value == "3.0" {
      v3_found = true
      break
    }
    k = k + 1
  }
  
  assert_eq(v1_found, true)
  assert_eq(v2_found, true)
  assert_eq(v3_found, true)
  
  // éªŒè¯å‘åå…¼å®¹æ€§ï¼šæ–°ç‰ˆæœ¬åº”è¯¥èƒ½å¤„ç†æ—§ç‰ˆæœ¬æ•°æ®
  let mut v1_compatible_fields = 0
  let mut v2_compatible_fields = 0
  let mut v3_compatible_fields = 0
  
  // æ£€æŸ¥v1å…¼å®¹å­—æ®µ
  let mut check_i = 0
  while check_i < v1_data.length() {
    let (key, _) = v1_data[check_i]
    if key == "service.name" || key == "trace.id" {
      v1_compatible_fields = v1_compatible_fields + 1
    }
    check_i = check_i + 1
  }
  
  // æ£€æŸ¥v2å…¼å®¹å­—æ®µ
  let mut check_j = 0
  while check_j < v2_data.length() {
    let (key, _) = v2_data[check_j]
    if key == "service.name" || key == "trace.id" {
      v2_compatible_fields = v2_compatible_fields + 1
    }
    check_j = check_j + 1
  }
  
  // æ£€æŸ¥v3å…¼å®¹å­—æ®µ
  let mut check_k = 0
  while check_k < v3_data.length() {
    let (key, _) = v3_data[check_k]
    if key == "service.name" || key == "trace.id" {
      v3_compatible_fields = v3_compatible_fields + 1
    }
    check_k = check_k + 1
  }
  
  // æ‰€æœ‰ç‰ˆæœ¬éƒ½åº”è¯¥æœ‰åŸºæœ¬å…¼å®¹å­—æ®µ
  assert_eq(v1_compatible_fields >= 2, true)
  assert_eq(v2_compatible_fields >= 2, true)
  assert_eq(v3_compatible_fields >= 2, true)
  
  // éªŒè¯å‰å‘å…¼å®¹æ€§ï¼šæ—§ç‰ˆæœ¬åº”è¯¥èƒ½å¿½ç•¥æ–°ç‰ˆæœ¬å­—æ®µ
  // è¿™é‡Œé€šè¿‡æ£€æŸ¥æ–°ç‰ˆæœ¬æœ‰æ›´å¤šå­—æ®µæ¥éªŒè¯
  assert_eq(v2_data.length() > v1_data.length(), true)
  assert_eq(v3_data.length() > v2_data.length(), true)
}