// ç»¼åˆé”™è¯¯å¤„ç†æµ‹è¯• - æµ‹è¯•å„ç§é”™è¯¯åœºæ™¯å’Œæ¢å¤æœºåˆ¶
test "error_handling_invalid_trace_data" {
  // æµ‹è¯•æ— æ•ˆTraceæ•°æ®çš„å¤„ç†
  
  // æµ‹è¯•æ— æ•ˆçš„trace_idé•¿åº¦
  let invalid_trace_id_short = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte })  // åº”è¯¥æ˜¯16å­—èŠ‚
  let invalid_trace_id_long = [for i = 0; i < 32; i = i + 1].map(fn(_) { 0_byte })   // åº”è¯¥æ˜¯16å­—èŠ‚
  
  // æµ‹è¯•æ— æ•ˆçš„span_idé•¿åº¦
  let invalid_span_id_short = [for i = 0; i < 4; i = i + 1].map(fn(_) { 0_byte })   // åº”è¯¥æ˜¯8å­—èŠ‚
  let invalid_span_id_long = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte })    // åº”è¯¥æ˜¯8å­—èŠ‚
  
  // åˆ›å»ºå¸¦æœ‰æ— æ•ˆæ•°æ®çš„SpanContextï¼ˆåœ¨å®é™…å®ç°ä¸­åº”è¯¥æœ‰éªŒè¯ï¼‰
  let span_context_invalid_trace = trace::SpanContext::{
    trace_id: invalid_trace_id_short,
    span_id: [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte }),
    trace_flags: 1_byte,
    trace_state: ""
  }
  
  let span_context_invalid_span = trace::SpanContext::{
    trace_id: [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte }),
    span_id: invalid_span_id_short,
    trace_flags: 1_byte,
    trace_state: ""
  }
  
  // éªŒè¯æ— æ•ˆæ•°æ®è¢«æ­£ç¡®å¤„ç†
  assert_eq(span_context_invalid_trace.trace_id.length(), 8)  // é•¿åº¦ä¸æ­£ç¡®ä½†è¢«æ¥å—
  assert_eq(span_context_invalid_span.span_id.length(), 4)    // é•¿åº¦ä¸æ­£ç¡®ä½†è¢«æ¥å—
}

test "error_handling_corrupted_attribute_values" {
  // æµ‹è¯•æŸåçš„å±æ€§å€¼å¤„ç†
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®
  let attributes_with_empty_key = [
    ("", common::AttributeValue::string("value_with_empty_key")),
    ("valid.key", common::AttributeValue::string("valid_value"))
  ]
  
  // æµ‹è¯•Noneå€¼ï¼ˆåœ¨å®ç°ä¸­åº”è¯¥å¤„ç†ï¼‰
  let attributes_with_special_chars = [
    ("key.with.dots", common::AttributeValue::string("value.with.dots")),
    ("key with spaces", common::AttributeValue::string("value with spaces")),
    ("key/with/slashes", common::AttributeValue::string("value/with/slashes")),
    ("key\\with\\backslashes", common::AttributeValue::string("value\\with\\backslashes"))
  ]
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let attributes_with_unicode = [
    ("unicode.é”®", common::AttributeValue::string("Unicodeå€¼")),
    ("emoji.ğŸš€", common::AttributeValue::string("rocket")),
    ("special.chars.Ã±Ã¡Ã©Ã­Ã³Ãº", common::AttributeValue::string("espaÃ±ol"))
  ]
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½èƒ½è¢«åˆ›å»º
  assert_eq(attributes_with_empty_key.length(), 2)
  assert_eq(attributes_with_special_chars.length(), 4)
  assert_eq(attributes_with_unicode.length(), 3)
}

test "error_handling_resource_creation_failures" {
  // æµ‹è¯•èµ„æºåˆ›å»ºå¤±è´¥çš„å¤„ç†
  
  // æµ‹è¯•ç©ºæœåŠ¡å
  let empty_service_resource = common::Resource::default("")
  assert_eq(empty_service_resource.service_name, "")
  
  // æµ‹è¯•éå¸¸é•¿çš„æœåŠ¡å
  let very_long_name = "a".repeat(10000)
  let long_name_resource = common::Resource::default(very_long_name)
  assert_eq(long_name_resource.service_name.length(), 10000)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æœåŠ¡å
  let special_chars_name = "service!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_chars_resource = common::Resource::default(special_chars_name)
  assert_eq(special_chars_resource.service_name, special_chars_name)
  
  // æµ‹è¯•UnicodeæœåŠ¡å
  let unicode_name = "æœåŠ¡åç§°ğŸš€æµ‹è¯•"
  let unicode_resource = common::Resource::default(unicode_name)
  assert_eq(unicode_resource.service_name, unicode_name)
}

test "error_handling_context_corruption" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡æŸåçš„å¤„ç†
  
  // æµ‹è¯•ç©ºé”®çš„ä¸Šä¸‹æ–‡æ“ä½œ
  let ctx = context::Context::empty()
  let empty_key = context::create_key("")
  let ctx_with_empty_key = ctx.with_value(empty_key, "value_with_empty_key")
  
  // æµ‹è¯•éå¸¸é•¿çš„é”®å’Œå€¼
  let long_key_name = "k".repeat(1000)
  let long_value = "v".repeat(1000)
  let long_key = context::create_key(long_key_name)
  let ctx_with_long_values = ctx.with_value(long_key, long_value)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®å’Œå€¼
  let special_key = context::create_key("key!@#$%^&*()")
  let special_value = "value!@#$%^&*()"
  let ctx_with_special_chars = ctx.with_value(special_key, special_value)
  
  // éªŒè¯ä¸Šä¸‹æ–‡æ“ä½œä¸ä¼šå´©æºƒ
  let _empty_key_result = ctx_with_empty_key.get(empty_key)
  let _long_key_result = ctx_with_long_values.get(long_key)
  let _special_key_result = ctx_with_special_chars.get(special_key)
  
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
}

test "error_handling_propagation_failures" {
  // æµ‹è¯•ä¼ æ’­å¤±è´¥çš„å¤„ç†
  
  // æµ‹è¯•æŸåçš„traceparent header
  let corrupted_traceparent = "invalid-traceparent-format"
  let carrier_corrupted = propagation::MapCarrier::new([
    ("traceparent", corrupted_traceparent)
  ])
  
  // æµ‹è¯•ç©ºtraceparent header
  let empty_traceparent = ""
  let carrier_empty = propagation::MapCarrier::new([
    ("traceparent", empty_traceparent)
  ])
  
  // æµ‹è¯•éƒ¨åˆ†ç¼ºå¤±çš„header
  let partial_header = "00-0af7651916cd43dd8448eb211c80319c"  // ç¼ºå°‘span_idå’Œflags
  let carrier_partial = propagation::MapCarrier::new([
    ("traceparent", partial_header)
  ])
  
  let ctx = context::Context::empty()
  let propagator = propagation::W3CTraceContextPropagator::{}
  
  // æµ‹è¯•ä»æŸåçš„headerä¸­æå–
  let _ctx_from_corrupted = propagator.extract(ctx, carrier_corrupted)
  let _ctx_from_empty = propagator.extract(ctx, carrier_empty)
  let _ctx_from_partial = propagator.extract(ctx, carrier_partial)
  
  // æµ‹è¯•å‘æŸåçš„carrierä¸­æ³¨å…¥
  propagator.inject(ctx, carrier_corrupted)
  propagator.inject(ctx, carrier_empty)
  propagator.inject(ctx, carrier_partial)
  
  assert_eq(true, true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œæµ‹è¯•é€šè¿‡
}

test "error_handling_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼å¤„ç†
  
  // æµ‹è¯•æå€¼
  let max_int64 = 9223372036854775807L
  let min_int64 = -9223372036854775808L
  let max_double = 1.7976931348623157e+308
  let min_double = -1.7976931348623157e+308
  let infinity = 1.0/0.0
  let neg_infinity = -1.0/0.0
  let nan = 0.0/0.0
  
  let boundary_attributes = [
    ("max.int64", common::AttributeValue::int(max_int64)),
    ("min.int64", common::AttributeValue::int(min_int64)),
    ("max.double", common::AttributeValue::float(max_double)),
    ("min.double", common::AttributeValue::float(min_double)),
    ("infinity", common::AttributeValue::float(infinity)),
    ("neg.infinity", common::AttributeValue::float(neg_infinity)),
    ("nan", common::AttributeValue::float(nan))
  ]
  
  // éªŒè¯è¾¹ç•Œå€¼å±æ€§åˆ›å»º
  assert_eq(boundary_attributes.length(), 7)
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_arrays = [
    ("empty.string.array", common::AttributeValue::array_string([])),
    ("empty.int.array", common::AttributeValue::array_int([])),
    ("empty.float.array", common::AttributeValue::array_float([])),
    ("empty.bool.array", common::AttributeValue::array_bool([]))
  ]
  
  assert_eq(empty_arrays.length(), 4)
  
  // æµ‹è¯•å¤§å‹æ•°ç»„
  let large_string_array = []
  let mut i = 0
  while i < 10000 {
    large_string_array.push("item_" + i.to_string())
    i = i + 1
  }
  
  let large_array_attr = common::AttributeValue::array_string(large_string_array)
  match large_array_attr {
    common::ArrayStringValue(arr) => assert_eq(arr.length(), 10000)
    _ => @test.fail("Test failed")
  }
}

test "error_handling_concurrent_access_issues" {
  // æµ‹è¯•å¹¶å‘è®¿é—®é—®é¢˜
  
  // æ¨¡æ‹Ÿå¹¶å‘ä¿®æ”¹åŒä¸€ä¸ªContext
  let ctx = context::Context::empty()
  let key1 = context::create_key("concurrent_key1")
  let key2 = context::create_key("concurrent_key2")
  
  // æ¨¡æ‹Ÿå¤šä¸ªæ“ä½œåŒæ—¶ä¿®æ”¹Context
  let ctx1 = ctx.with_value(key1, "value1")
  let ctx2 = ctx1.with_value(key2, "value2")
  let ctx3 = ctx.with_value(key2, "alternative_value2")
  let ctx4 = ctx3.with_value(key1, "alternative_value1")
  
  // éªŒè¯ä¸åŒçš„Contextç‰ˆæœ¬
  let value1_from_ctx2 = ctx2.get(key1)
  let value2_from_ctx2 = ctx2.get(key2)
  let value1_from_ctx4 = ctx4.get(key1)
  let value2_from_ctx4 = ctx4.get(key2)
  
  match value1_from_ctx2 {
    Some(v) => assert_eq(v, "value1")
    None => @test.fail("Test failed")
  }
  
  match value2_from_ctx2 {
    Some(v) => assert_eq(v, "value2")
    None => @test.fail("Test failed")
  }
  
  match value1_from_ctx4 {
    Some(v) => assert_eq(v, "alternative_value1")
    None => @test.fail("Test failed")
  }
  
  match value2_from_ctx4 {
    Some(v) => assert_eq(v, "alternative_value2")
    None => @test.fail("Test failed")
  }
}

test "error_handling_memory_pressure" {
  // æµ‹è¯•å†…å­˜å‹åŠ›ä¸‹çš„é”™è¯¯å¤„ç†
  
  // åˆ›å»ºå¤§é‡å¯¹è±¡ä»¥æ¨¡æ‹Ÿå†…å­˜å‹åŠ›
  let mut large_resources = []
  let mut i = 0
  while i < 1000 {
    let resource = common::Resource::default("memory_test_service_" + i.to_string())
    large_resources.push(resource)
    i = i + 1
  }
  
  // åˆ›å»ºå¤§é‡Span
  let mut large_spans = []
  i = 0
  while i < 1000 {
    let span = trace::Span::{
      name: "memory_test_span_" + i.to_string(),
      context: trace::SpanContext::{
        trace_id: [for j = 0; j < 16; j = j + 1].map(fn(_) { (i + j).to_byte() }),
        span_id: [for j = 0; j < 8; j = j + 1].map(fn(_) { (i + j).to_byte() }),
        trace_flags: 1_byte,
        trace_state: ""
      },
      kind: trace::Internal,
      parent_span_id: None,
      start_time_unix_nanos: i.to_int64() * 1000L,
      end_time_unix_nanos: Some((i.to_int64() + 1) * 1000L),
      status: trace::Ok,
      status_description: None,
      attributes: [
        ("iteration", common::AttributeValue::int(i.to_int64())),
        ("memory.test", common::AttributeValue::bool(true))
      ],
      events: [],
      links: []
    }
    large_spans.push(span)
    i = i + 1
  }
  
  // éªŒè¯åœ¨å†…å­˜å‹åŠ›ä¸‹å¯¹è±¡åˆ›å»ºæˆåŠŸ
  assert_eq(large_resources.length(), 1000)
  assert_eq(large_spans.length(), 1000)
}