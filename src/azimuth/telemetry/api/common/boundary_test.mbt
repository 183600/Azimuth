// è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶ã€å¼‚å¸¸æƒ…å†µå’Œé”™è¯¯å¤„ç†

test "attribute_value_extreme_edge_cases" {
  // æµ‹è¯•AttributeValueçš„æç«¯è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²
  let very_long_string = "This is an extremely long string that contains many characters and tests how the system handles very long attribute values without any issues or problems that might arise from memory allocation or string processing limitations that could potentially cause crashes or unexpected behavior in the telemetry system when dealing with unusually long attribute values that exceed typical expected lengths for normal telemetry data."
  let long_string_attr = AttributeValue::string(very_long_string)
  
  match long_string_attr {
    StringValue(s) => assert_eq(s, very_long_string)
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼ˆç§»é™¤æ§åˆ¶å­—ç¬¦ï¼‰
  let special_chars_string = "Special chars: !@#$%^&*()_+-={}[]|\\:;\"'<>?,./\n\t\r"
  let special_chars_attr = AttributeValue::string(special_chars_string)
  
  match special_chars_attr {
    StringValue(s) => assert_eq(s, special_chars_string)
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "Unicode test: ä¸­æ–‡æµ‹è¯• ğŸš€ Î±Î²Î³Î´Îµ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹ æ—¥æœ¬èª í•œêµ­ì–´"
  let unicode_attr = AttributeValue::string(unicode_string)
  
  match unicode_attr {
    StringValue(s) => assert_eq(s, unicode_string)
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æå€¼æ•´æ•°
  let max_int_attr = AttributeValue::int(9223372036854775807L)  // Int64æœ€å¤§å€¼
  let min_int_attr = AttributeValue::int(-9223372036854775808L)  // Int64æœ€å°å€¼
  let zero_int_attr = AttributeValue::int(0L)
  
  match max_int_attr {
    IntValue(i) => assert_eq(i, 9223372036854775807L)
    _ => @test.fail("Test failed")
  }
  
  match min_int_attr {
    IntValue(i) => assert_eq(i, -9223372036854775808L)
    _ => @test.fail("Test failed")
  }
  
  match zero_int_attr {
    IntValue(i) => assert_eq(i, 0L)
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°
  let max_float_attr = AttributeValue::float(1.7976931348623157e308)  // Doubleæœ€å¤§å€¼
  let min_float_attr = AttributeValue::float(-1.7976931348623157e308)  // Doubleæœ€å°å€¼
  let smallest_float_attr = AttributeValue::float(0.000001)  // ä½¿ç”¨æ›´å°çš„æ­£æ•°
  let infinity_attr = AttributeValue::float(1.0/0.0)  // æ­£æ— ç©·
  let neg_infinity_attr = AttributeValue::float(-1.0/0.0)  // è´Ÿæ— ç©·
  let nan_attr = AttributeValue::float(0.0/0.0)  // NaN
  
  match max_float_attr {
    FloatValue(f) => assert_eq(f, 1.7976931348623157e308)
    _ => @test.fail("Test failed")
  }
  
  match min_float_attr {
    FloatValue(f) => assert_eq(f, -1.7976931348623157e308)
    _ => @test.fail("Test failed")
  }
  
  match infinity_attr {
    FloatValue(f) => assert_eq(f, 1.0/0.0)
    _ => @test.fail("Test failed")
  }
  
  match nan_attr {
    FloatValue(f) => {
      // NaNæ¯”è¾ƒéœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œå› ä¸ºNaN != NaN
      let is_nan = f != f
      assert_eq(is_nan, true)
    }
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æé•¿æ•°ç»„
  let large_string_array = []
  let mut i = 0
  while i < 100 {  // å‡å°‘æ•°ç»„å¤§å°ä»¥é¿å…æ€§èƒ½é—®é¢˜
    large_string_array.push("item" + i.to_string())
    i = i + 1
  }
  
  let large_array_attr = AttributeValue::array_string(large_string_array)
  
  match large_array_attr {
    ArrayStringValue(arr) => assert_eq(arr.length(), 100)
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«æå€¼çš„æ•°ç»„
  let extreme_int_array = AttributeValue::array_int([
    9223372036854775807L,
    -9223372036854775808L,
    0L,
    1L,
    -1L
  ])
  
  let extreme_float_array = AttributeValue::array_float([
    1.7976931348623157e308,
    -1.7976931348623157e308,
    0.0,
    1.0/0.0,
    -1.0/0.0,
    0.0/0.0
  ])
  
  match extreme_int_array {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 5)
      assert_eq(arr[0], 9223372036854775807L)
      assert_eq(arr[1], -9223372036854775808L)
    }
    _ => @test.fail("Test failed")
  }
  
  match extreme_float_array {
    ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 6)
      assert_eq(arr[0], 1.7976931348623157e308)
      assert_eq(arr[1], -1.7976931348623157e308)
    }
    _ => @test.fail("Test failed")
  }
}

test "resource_boundary_conditions" {
  // æµ‹è¯•Resourceçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æé•¿çš„æœåŠ¡åç§°
  let very_long_service_name = "this.is.a.very.long.service.name.that.tests.the.system.ability.to.handle.extremely.long.service.names.with.many.characters.that.might.exceed.typical.limits.for.telemetry.data.structures"
  let long_name_resource = Resource::default(very_long_service_name)
  
  assert_eq(long_name_resource.service_name, very_long_service_name)
  assert_eq(long_name_resource.telemetry_sdk_name, "azimuth")
  assert_eq(long_name_resource.telemetry_sdk_version, "0.1.0")
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æœåŠ¡åç§°
  let special_service_name = "special!@#$%^&*()_+-={}[]|\\:;\"'<>?,./service"
  let special_resource = Resource::default(special_service_name)
  
  assert_eq(special_resource.service_name, special_service_name)
  
  // æµ‹è¯•UnicodeæœåŠ¡åç§°
  let unicode_service_name = "UnicodeæœåŠ¡æµ‹è¯•ğŸš€Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©Ñ€ÑƒÑÑĞºĞ¸Ğ¹æ—¥æœ¬èªí•œêµ­ì–´"
  let unicode_resource = Resource::default(unicode_service_name)
  
  assert_eq(unicode_resource.service_name, unicode_service_name)
  
  // æµ‹è¯•ç©ºæœåŠ¡åç§°
  let empty_resource = Resource::default("")
  assert_eq(empty_resource.service_name, "")
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„æœåŠ¡åç§°
  let space_resource = Resource::default("service with spaces")
  assert_eq(space_resource.service_name, "service with spaces")
  
  // æµ‹è¯•å¤æ‚çš„å±æ€§é›†åˆ
  let very_long_attributes = []
  let mut i = 0
  while i < 100 {  // å‡å°‘å±æ€§æ•°é‡ä»¥é¿å…æ€§èƒ½é—®é¢˜
    very_long_attributes.push(("very.long.attribute.name." + i.to_string(), AttributeValue::string("very.long.attribute.value." + i.to_string() + "with.many.characters")))
    i = i + 1
  }
  
  assert_eq(very_long_attributes.length(), 100)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å±æ€§
  let special_attributes = [
    ("special!@#$%^&*()", AttributeValue::string("special!@#$%^&*()")),
    ("unicodeæµ‹è¯•", AttributeValue::string("Unicodeå€¼æµ‹è¯•ğŸš€")),
    ("empty.string", AttributeValue::string("")),
    ("zero.int", AttributeValue::int(0L)),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("min.int", AttributeValue::int(-9223372036854775808L)),
    ("zero.float", AttributeValue::float(0.0)),
    ("infinity", AttributeValue::float(1.0/0.0)),
    ("nan", AttributeValue::float(0.0/0.0)),
    ("true.bool", AttributeValue::bool(true)),
    ("false.bool", AttributeValue::bool(false)),
    ("empty.array", AttributeValue::array_string([])),
    ("string.array", AttributeValue::array_string(["a", "b", "c"])),
    ("int.array", AttributeValue::array_int([1L, 2L, 3L])),
    ("float.array", AttributeValue::array_float([1.1, 2.2, 3.3])),
    ("bool.array", AttributeValue::array_bool([true, false, true]))
  ]
  
  assert_eq(special_attributes.length(), 16)
  
  // éªŒè¯ç‰¹æ®Šå±æ€§
  match special_attributes[0].1 {
    StringValue(value) => assert_eq(value, "special!@#$%^&*()")
    _ => @test.fail("Test failed")
  }
  
  match special_attributes[1].1 {
    StringValue(value) => assert_eq(value, "Unicodeå€¼æµ‹è¯•ğŸš€")
    _ => @test.fail("Test failed")
  }
  
  match special_attributes[2].1 {
    StringValue(value) => assert_eq(value, "")
    _ => @test.fail("Test failed")
  }
  
  match special_attributes[3].1 {
    IntValue(value) => assert_eq(value, 0L)
    _ => @test.fail("Test failed")
  }
  
  match special_attributes[12].1 {
    ArrayStringValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
}

test "array_boundary_conditions" {
  // æµ‹è¯•æ•°ç»„çš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²æ•°ç»„
  let very_long_strings = []
  let mut i = 0
  while i < 100 {  // å‡å°‘æ•°ç»„å¤§å°ä»¥é¿å…æ€§èƒ½é—®é¢˜
    very_long_strings.push("very.long.string." + i.to_string() + ".with.many.characters.to.test.array.handling")
    i = i + 1
  }
  
  let long_string_array = AttributeValue::array_string(very_long_strings)
  
  match long_string_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 100)
      assert_eq(arr[0], "very.long.string.0.with.many.characters.to.test.array.handling")
      assert_eq(arr[99], "very.long.string.99.with.many.characters.to.test.array.handling")
    }
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æå€¼æ•´æ•°æ•°ç»„
  let extreme_ints = [
    9223372036854775807L,  // æœ€å¤§Int64
    -9223372036854775808L, // æœ€å°Int64
    0L,
    1L,
    -1L,
    1234567890L,
    -1234567890L
  ]
  
  let extreme_int_array = AttributeValue::array_int(extreme_ints)
  
  match extreme_int_array {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 7)
      assert_eq(arr[0], 9223372036854775807L)
      assert_eq(arr[1], -9223372036854775808L)
      assert_eq(arr[2], 0L)
    }
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°æ•°ç»„
  let extreme_floats = [
    1.7976931348623157e308,  // æœ€å¤§Double
    -1.7976931348623157e308, // æœ€å°Double
    0.0,
    1.0/0.0,  // æ­£æ— ç©·
    -1.0/0.0, // è´Ÿæ— ç©·
    0.0/0.0   // NaN
  ]
  
  let extreme_float_array = AttributeValue::array_float(extreme_floats)
  
  match extreme_float_array {
    ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 6)
      assert_eq(arr[0], 1.7976931348623157e308)
      assert_eq(arr[1], -1.7976931348623157e308)
      
      // æµ‹è¯•NaN
      let nan_value = arr[5]
      let is_nan = nan_value != nan_value
      assert_eq(is_nan, true)
    }
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•å¸ƒå°”æ•°ç»„
  let bool_values = [
    true,
    false,
    true,
    false,
    true
  ]
  
  let bool_array = AttributeValue::array_bool(bool_values)
  
  match bool_array {
    ArrayBoolValue(arr) => {
      assert_eq(arr.length(), 5)
      assert_eq(arr[0], true)
      assert_eq(arr[1], false)
      assert_eq(arr[2], true)
      assert_eq(arr[3], false)
      assert_eq(arr[4], true)
    }
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = AttributeValue::array_string([])
  let empty_int_array = AttributeValue::array_int([])
  let empty_float_array = AttributeValue::array_float([])
  let empty_bool_array = AttributeValue::array_bool([])
  
  match empty_string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  match empty_int_array {
    ArrayIntValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  match empty_float_array {
    ArrayFloatValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  match empty_bool_array {
    ArrayBoolValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå€¼çš„æ•°ç»„
  let special_string_array = AttributeValue::array_string([
    "",
    "special!@#$%^&*()",
    "Unicodeæµ‹è¯•ğŸš€",
    "string with spaces",
    "string\nwith\nnewlines",
    "string\twith\ttabs"
  ])
  
  match special_string_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 6)
      assert_eq(arr[0], "")
      assert_eq(arr[1], "special!@#$%^&*()")
      assert_eq(arr[2], "Unicodeæµ‹è¯•ğŸš€")
    }
    _ => @test.fail("Test failed")
  }
}

test "resource_extreme_scenarios" {
  // æµ‹è¯•Resourceçš„æç«¯åœºæ™¯
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°ä½œä¸ºSDKç‰ˆæœ¬ï¼ˆè™½ç„¶ä¸å®é™…ï¼Œä½†æµ‹è¯•ç³»ç»Ÿå¤„ç†èƒ½åŠ›ï¼‰
  let resource_with_float_values = Resource::default("test-service")
  
  // éªŒè¯åŸºæœ¬å±æ€§
  assert_eq(resource_with_float_values.service_name, "test-service")
  assert_eq(resource_with_float_values.telemetry_sdk_name, "azimuth")
  assert_eq(resource_with_float_values.telemetry_sdk_version, "0.1.0")
  
  // æµ‹è¯•åŒ…å«æå€¼å±æ€§çš„Resource
  let extreme_attributes = [
    ("max.float", AttributeValue::float(1.7976931348623157e308)),
    ("min.float", AttributeValue::float(-1.7976931348623157e308)),
    ("infinity", AttributeValue::float(1.0/0.0)),
    ("neg.infinity", AttributeValue::float(-1.0/0.0)),
    ("nan", AttributeValue::float(0.0/0.0)),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("min.int", AttributeValue::int(-9223372036854775808L)),
    ("unicode", AttributeValue::string("Unicodeæµ‹è¯•ğŸš€")),
    ("special.chars", AttributeValue::string("!@#$%^&*()")),
    ("empty", AttributeValue::string("")),
    ("array.large", AttributeValue::array_string(["a", "b", "c", "d", "e"]))
  ]
  
  assert_eq(extreme_attributes.length(), 11)
  
  // éªŒè¯æå€¼å±æ€§
  match extreme_attributes[0].1 {
    FloatValue(value) => assert_eq(value, 1.7976931348623157e308)
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[1].1 {
    FloatValue(value) => assert_eq(value, -1.7976931348623157e308)
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[2].1 {
    FloatValue(value) => assert_eq(value, 1.0/0.0)
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[3].1 {
    FloatValue(value) => assert_eq(value, -1.0/0.0)
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[4].1 {
    FloatValue(value) => {
      let is_nan = value != value
      assert_eq(is_nan, true)
    }
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[5].1 {
    IntValue(value) => assert_eq(value, 9223372036854775807L)
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[6].1 {
    IntValue(value) => assert_eq(value, -9223372036854775808L)
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[7].1 {
    StringValue(value) => assert_eq(value, "Unicodeæµ‹è¯•ğŸš€")
    _ => @test.fail("Test failed")
  }
  
  match extreme_attributes[10].1 {
    ArrayStringValue(arr) => assert_eq(arr.length(), 5)
    _ => @test.fail("Test failed")
  }
}

test "attributes_complex_scenarios" {
  // æµ‹è¯•å±æ€§çš„å¤æ‚åœºæ™¯
  
  // æµ‹è¯•æé•¿çš„å±æ€§é”®å’Œå€¼
  let very_long_key = "this.is.a.very.long.attribute.key.name.that.tests.the.system.ability.to.handle.extremely.long.keys.with.many.characters.that.might.exceed.typical.limits"
  let very_long_value = "this.is.a.very.long.attribute.value.that.tests.the.system.ability.to.handle.extremely.long.values.with.many.characters.that.might.exceed.typical.limits.for.telemetry.data"
  
  let long_key_value = (very_long_key, AttributeValue::string(very_long_value))
  
  match long_key_value.1 {
    StringValue(value) => assert_eq(value, very_long_value)
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å±æ€§é”®å’Œå€¼
  let special_key_value = ("special!@#$%^&*()_+-={}[]|\\:;\"'<>?,./", AttributeValue::string("special!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"))
  
  match special_key_value.1 {
    StringValue(value) => assert_eq(value, "special!@#$%^&*()_+-={}[]|\\:;\"'<>?,./")
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•Unicodeå±æ€§é”®å’Œå€¼
  let unicode_key_value = ("Unicodeé”®.æµ‹è¯•.ğŸš€", AttributeValue::string("Unicodeå€¼.æµ‹è¯•.ğŸš€.ä¸­æ–‡.Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.Ñ€ÑƒÑÑĞºĞ¸Ğ¹.æ—¥æœ¬èª.í•œêµ­ì–´"))
  
  match unicode_key_value.1 {
    StringValue(value) => assert_eq(value, "Unicodeå€¼.æµ‹è¯•.ğŸš€.ä¸­æ–‡.Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.Ñ€ÑƒÑÑĞºĞ¸Ğ¹.æ—¥æœ¬èª.í•œêµ­ì–´")
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç©ºå±æ€§é”®å’Œå€¼
  let empty_key_value = ("", AttributeValue::string(""))
  
  match empty_key_value.1 {
    StringValue(value) => assert_eq(value, "")
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å±æ€§é”®å’Œå€¼
  let space_key_value = ("key with spaces", AttributeValue::string("value with spaces"))
  
  match space_key_value.1 {
    StringValue(value) => assert_eq(value, "value with spaces")
    _ => @test.fail("Test failed")
  }
  
  // æµ‹è¯•æ··åˆç±»å‹çš„å±æ€§é›†åˆ
  let mixed_attributes = [
    ("string.attr", AttributeValue::string("string value")),
    ("int.attr", AttributeValue::int(42L)),
    ("float.attr", AttributeValue::float(3.14)),
    ("bool.attr", AttributeValue::bool(true)),
    ("string.array.attr", AttributeValue::array_string(["a", "b", "c"])),
    ("int.array.attr", AttributeValue::array_int([1L, 2L, 3L])),
    ("float.array.attr", AttributeValue::array_float([1.1, 2.2, 3.3])),
    ("bool.array.attr", AttributeValue::array_bool([true, false, true]))
  ]
  
  assert_eq(mixed_attributes.length(), 8)
  
  // éªŒè¯æ··åˆå±æ€§
  match mixed_attributes[0].1 {
    StringValue(value) => assert_eq(value, "string value")
    _ => @test.fail("Test failed")
  }
  
  match mixed_attributes[1].1 {
    IntValue(value) => assert_eq(value, 42L)
    _ => @test.fail("Test failed")
  }
  
  match mixed_attributes[2].1 {
    FloatValue(value) => assert_eq(value, 3.14)
    _ => @test.fail("Test failed")
  }
  
  match mixed_attributes[3].1 {
    BoolValue(value) => assert_eq(value, true)
    _ => @test.fail("Test failed")
  }
  
  match mixed_attributes[4].1 {
    ArrayStringValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
  
  match mixed_attributes[5].1 {
    ArrayIntValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
  
  match mixed_attributes[6].1 {
    ArrayFloatValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
  
  match mixed_attributes[7].1 {
    ArrayBoolValue(arr) => assert_eq(arr.length(), 3)
    _ => @test.fail("Test failed")
  }
}