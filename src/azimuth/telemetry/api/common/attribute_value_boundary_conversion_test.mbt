// AttributeValueç±»å‹è½¬æ¢è¾¹ç•Œæµ‹è¯•
// æµ‹è¯•AttributeValueåœ¨å„ç§è¾¹ç•Œæƒ…å†µä¸‹çš„ç±»å‹è½¬æ¢å’Œè¡Œä¸º

test "attribute_value_string_boundary_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²ç±»å‹çš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºå­—ç¬¦ä¸²
  let empty_string = AttributeValue::string("")
  match empty_string {
    StringValue(value) => assert_eq(value, "")
    _ => @test.fail("Test failed")
  }
  
  // å•å­—ç¬¦å­—ç¬¦ä¸²
  let single_char = AttributeValue::string("a")
  match single_char {
    StringValue(value) => assert_eq(value, "a")
    _ => @test.fail("Test failed")
  }
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = AttributeValue::string("This is a very long string that contains many characters and tests the system's ability to handle lengthy attribute values without any issues or performance degradation")
  match long_string {
    StringValue(value) => assert_eq(value.length() > 100, true)
    _ => @test.fail("Test failed")
  }
  
  // åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = AttributeValue::string("!@#$%^&*()_+-=[]{}|;':\",./<>?~`")
  match special_chars {
    StringValue(value) => assert_eq(value, "!@#$%^&*()_+-=[]{}|;':\",./<>?~`")
    _ => @test.fail("Test failed")
  }
  
  // åŒ…å«æ¢è¡Œç¬¦çš„å­—ç¬¦ä¸²
  let multiline = AttributeValue::string("Line 1\nLine 2\nLine 3")
  match multiline {
    StringValue(value) => assert_eq(value, "Line 1\nLine 2\nLine 3")
    _ => @test.fail("Test failed")
  }
  
  // Unicodeå­—ç¬¦ä¸²
  let unicode = AttributeValue::string("Hello ä¸–ç•Œ ğŸŒ Ã±Ã¡Ã©Ã­Ã³Ãº ä¸­æ–‡ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹")
  match unicode {
    StringValue(value) => assert_eq(value, "Hello ä¸–ç•Œ ğŸŒ Ã±Ã¡Ã©Ã­Ã³Ãº ä¸­æ–‡ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹")
    _ => @test.fail("Test failed")
  }
  
  // åªåŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let spaces = AttributeValue::string("   ")
  match spaces {
    StringValue(value) => assert_eq(value, "   ")
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_int_boundary_cases" {
  // æµ‹è¯•æ•´æ•°ç±»å‹çš„è¾¹ç•Œæƒ…å†µ
  
  // é›¶
  let zero = AttributeValue::int(0L)
  match zero {
    IntValue(value) => assert_eq(value, 0L)
    _ => @test.fail("Test failed")
  }
  
  // æœ€å°å€¼
  let min_int = AttributeValue::int(-9223372036854775808L)
  match min_int {
    IntValue(value) => assert_eq(value, -9223372036854775808L)
    _ => @test.fail("Test failed")
  }
  
  // æœ€å¤§å€¼
  let max_int = AttributeValue::int(9223372036854775807L)
  match max_int {
    IntValue(value) => assert_eq(value, 9223372036854775807L)
    _ => @test.fail("Test failed")
  }
  
  // è´Ÿæ•°
  let negative = AttributeValue::int(-42L)
  match negative {
    IntValue(value) => assert_eq(value, -42L)
    _ => @test.fail("Test failed")
  }
  
  // å¤§æ­£æ•°
  let large_positive = AttributeValue::int(1000000000000L)
  match large_positive {
    IntValue(value) => assert_eq(value, 1000000000000L)
    _ => @test.fail("Test failed")
  }
  
  // å¤§è´Ÿæ•°
  let large_negative = AttributeValue::int(-1000000000000L)
  match large_negative {
    IntValue(value) => assert_eq(value, -1000000000000L)
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_float_boundary_cases" {
  // æµ‹è¯•æµ®ç‚¹æ•°ç±»å‹çš„è¾¹ç•Œæƒ…å†µ
  
  // é›¶
  let zero_float = AttributeValue::float(0.0)
  match zero_float {
    FloatValue(value) => assert_eq(value, 0.0)
    _ => @test.fail("Test failed")
  }
  
  // è´Ÿé›¶
  let negative_zero = AttributeValue::float(-0.0)
  match negative_zero {
    FloatValue(value) => assert_eq(value, -0.0)
    _ => @test.fail("Test failed")
  }
  
  // éå¸¸å°çš„æ­£æ•°
  let tiny_positive = AttributeValue::float(1.0e-10)
  match tiny_positive {
    FloatValue(value) => assert_eq(value, 1.0e-10)
    _ => @test.fail("Test failed")
  }
  
  // éå¸¸å°çš„è´Ÿæ•°
  let tiny_negative = AttributeValue::float(-1.0e-10)
  match tiny_negative {
    FloatValue(value) => assert_eq(value, -1.0e-10)
    _ => @test.fail("Test failed")
  }
  
  // å¤§æ­£æ•°
  let large_float = AttributeValue::float(1.0e10)
  match large_float {
    FloatValue(value) => assert_eq(value, 1.0e10)
    _ => @test.fail("Test failed")
  }
  
  // å¤§è´Ÿæ•°
  let large_negative_float = AttributeValue::float(-1.0e10)
  match large_negative_float {
    FloatValue(value) => assert_eq(value, -1.0e10)
    _ => @test.fail("Test failed")
  }
  
  // ç²¾ç¡®å°æ•°
  let precise = AttributeValue::float(3.14159265359)
  match precise {
    FloatValue(value) => assert_eq(value, 3.14159265359)
    _ => @test.fail("Test failed")
  }
  
  // ç§‘å­¦è®¡æ•°æ³•
  let scientific = AttributeValue::float(1.23e-5)
  match scientific {
    FloatValue(value) => assert_eq(value, 1.23e-5)
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_bool_boundary_cases" {
  // æµ‹è¯•å¸ƒå°”ç±»å‹çš„è¾¹ç•Œæƒ…å†µ
  
  // true
  let true_value = AttributeValue::bool(true)
  match true_value {
    BoolValue(value) => assert_eq(value, true)
    _ => @test.fail("Test failed")
  }
  
  // false
  let false_value = AttributeValue::bool(false)
  match false_value {
    BoolValue(value) => assert_eq(value, false)
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_array_string_boundary_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ•°ç»„çš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºæ•°ç»„
  let empty_array = AttributeValue::array_string([])
  match empty_array {
    ArrayStringValue(values) => assert_eq(values.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  // å•å…ƒç´ æ•°ç»„
  let single_element = AttributeValue::array_string(["single"])
  match single_element {
    ArrayStringValue(values) => {
      assert_eq(values.length(), 1)
      assert_eq(values[0], "single")
    }
    _ => @test.fail("Test failed")
  }
  
  // åŒ…å«ç©ºå­—ç¬¦ä¸²çš„æ•°ç»„
  let with_empty = AttributeValue::array_string(["", "non-empty", ""])
  match with_empty {
    ArrayStringValue(values) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "")
      assert_eq(values[1], "non-empty")
      assert_eq(values[2], "")
    }
    _ => @test.fail("Test failed")
  }
  
  // åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ•°ç»„
  let special_chars_array = AttributeValue::array_string(["!@#$%", "^&*()", "[]{}"])
  match special_chars_array {
    ArrayStringValue(values) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "!@#$%")
      assert_eq(values[1], "^&*()")
      assert_eq(values[2], "[]{}")
    }
    _ => @test.fail("Test failed")
  }
  
  // å¤§æ•°ç»„
  let mut large_array = []
  let mut i = 0
  while i < 100 {
    large_array.push("item_" + i.to_string())
    i = i + 1
  }
  let large = AttributeValue::array_string(large_array)
  match large {
    ArrayStringValue(values) => {
      assert_eq(values.length(), 100)
      assert_eq(values[0], "item_0")
      assert_eq(values[99], "item_99")
    }
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_array_int_boundary_cases" {
  // æµ‹è¯•æ•´æ•°æ•°ç»„çš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºæ•°ç»„
  let empty_int_array = AttributeValue::array_int([])
  match empty_int_array {
    ArrayIntValue(values) => assert_eq(values.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  // åŒ…å«è¾¹ç•Œå€¼çš„æ•°ç»„
  let boundary_ints = AttributeValue::array_int([
    -9223372036854775808L,  // æœ€å°å€¼
    0L,                       // é›¶
    9223372036854775807L     // æœ€å¤§å€¼
  ])
  match boundary_ints {
    ArrayIntValue(values) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], -9223372036854775808L)
      assert_eq(values[1], 0L)
      assert_eq(values[2], 9223372036854775807L)
    }
    _ => @test.fail("Test failed")
  }
  
  // åŒ…å«æ­£è´Ÿæ•°çš„æ•°ç»„
  let mixed_ints = AttributeValue::array_int([-100L, -50L, 0L, 50L, 100L])
  match mixed_ints {
    ArrayIntValue(values) => {
      assert_eq(values.length(), 5)
      assert_eq(values[0], -100L)
      assert_eq(values[2], 0L)
      assert_eq(values[4], 100L)
    }
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_array_float_boundary_cases" {
  // æµ‹è¯•æµ®ç‚¹æ•°æ•°ç»„çš„è¾¹ç•Œæƒ…å†µ
  
  // åŒ…å«ç‰¹æ®Šæµ®ç‚¹å€¼çš„æ•°ç»„
  let special_floats = AttributeValue::array_float([
    0.0,        // é›¶
    -0.0,       // è´Ÿé›¶
    1.0e-10,    // éå¸¸å°çš„æ­£æ•°
    -1.0e-10,   // éå¸¸å°çš„è´Ÿæ•°
    1.0e10,     // å¤§æ­£æ•°
    -1.0e10,    // å¤§è´Ÿæ•°
    3.14159265359  // åœ†å‘¨ç‡
  ])
  match special_floats {
    ArrayFloatValue(values) => {
      assert_eq(values.length(), 7)
      assert_eq(values[0], 0.0)
      assert_eq(values[1], -0.0)
      assert_eq(values[2], 1.0e-10)
      assert_eq(values[6], 3.14159265359)
    }
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_array_bool_boundary_cases" {
  // æµ‹è¯•å¸ƒå°”æ•°ç»„çš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºæ•°ç»„
  let empty_bool_array = AttributeValue::array_bool([])
  match empty_bool_array {
    ArrayBoolValue(values) => assert_eq(values.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  // å•å…ƒç´ æ•°ç»„
  let single_true = AttributeValue::array_bool([true])
  match single_true {
    ArrayBoolValue(values) => {
      assert_eq(values.length(), 1)
      assert_eq(values[0], true)
    }
    _ => @test.fail("Test failed")
  }
  
  // å•å…ƒç´ falseæ•°ç»„
  let single_false = AttributeValue::array_bool([false])
  match single_false {
    ArrayBoolValue(values) => {
      assert_eq(values.length(), 1)
      assert_eq(values[0], false)
    }
    _ => @test.fail("Test failed")
  }
  
  // æ··åˆå¸ƒå°”å€¼æ•°ç»„
  let mixed_bools = AttributeValue::array_bool([true, false, true, true, false])
  match mixed_bools {
    ArrayBoolValue(values) => {
      assert_eq(values.length(), 5)
      assert_eq(values[0], true)
      assert_eq(values[1], false)
      assert_eq(values[2], true)
      assert_eq(values[3], true)
      assert_eq(values[4], false)
    }
    _ => @test.fail("Test failed")
  }
  
  // å…¨trueæ•°ç»„
  let all_true = AttributeValue::array_bool([true, true, true, true, true])
  match all_true {
    ArrayBoolValue(values) => {
      assert_eq(values.length(), 5)
      let mut i = 0
      while i < values.length() {
        assert_eq(values[i], true)
        i = i + 1
      }
    }
    _ => @test.fail("Test failed")
  }
  
  // å…¨falseæ•°ç»„
  let all_false = AttributeValue::array_bool([false, false, false, false, false])
  match all_false {
    ArrayBoolValue(values) => {
      assert_eq(values.length(), 5)
      let mut i = 0
      while i < values.length() {
        assert_eq(values[i], false)
        i = i + 1
      }
    }
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_complex_attribute_collections" {
  // æµ‹è¯•å¤æ‚å±æ€§é›†åˆ
  
  // åˆ›å»ºåŒ…å«å„ç§ç±»å‹çš„å±æ€§é›†åˆ
  let complex_attributes = [
    ("string.simple", AttributeValue::string("simple_value")),
    ("string.empty", AttributeValue::string("")),
    ("string.special", AttributeValue::string("!@#$%^&*()")),
    ("string.unicode", AttributeValue::string("Hello ä¸–ç•Œ ğŸŒ")),
    ("int.zero", AttributeValue::int(0L)),
    ("int.min", AttributeValue::int(-9223372036854775808L)),
    ("int.max", AttributeValue::int(9223372036854775807L)),
    ("int.negative", AttributeValue::int(-42L)),
    ("float.zero", AttributeValue::float(0.0)),
    ("float.tiny", AttributeValue::float(1.0e-10)),
    ("float.large", AttributeValue::float(1.0e10)),
    ("float.precise", AttributeValue::float(3.14159265359)),
    ("bool.true", AttributeValue::bool(true)),
    ("bool.false", AttributeValue::bool(false)),
    ("array.string.empty", AttributeValue::array_string([])),
    ("array.string.single", AttributeValue::array_string(["single"])),
    ("array.string.mixed", AttributeValue::array_string(["", "value", ""])),
    ("array.int.empty", AttributeValue::array_int([])),
    ("array.int.boundary", AttributeValue::array_int([-1L, 0L, 1L])),
    ("array.float.empty", AttributeValue::array_float([])),
    ("array.float.special", AttributeValue::array_float([0.0, -0.0, 1.0e-10])),
    ("array.bool.empty", AttributeValue::array_bool([])),
    ("array.bool.mixed", AttributeValue::array_bool([true, false, true]))
  ]
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½æ­£ç¡®åˆ›å»º
  assert_eq(complex_attributes.length(), 24)
  
  // éªŒè¯å­—ç¬¦ä¸²å±æ€§
  match complex_attributes[0].1 {
    StringValue(value) => assert_eq(value, "simple_value")
    _ => @test.fail("Test failed")
  }
  
  match complex_attributes[1].1 {
    StringValue(value) => assert_eq(value, "")
    _ => @test.fail("Test failed")
  }
  
  // éªŒè¯æ•´æ•°å±æ€§
  match complex_attributes[4].1 {
    IntValue(value) => assert_eq(value, 0L)
    _ => @test.fail("Test failed")
  }
  
  match complex_attributes[5].1 {
    IntValue(value) => assert_eq(value, -9223372036854775808L)
    _ => @test.fail("Test failed")
  }
  
  // éªŒè¯æµ®ç‚¹æ•°å±æ€§
  match complex_attributes[9].1 {
    FloatValue(value) => assert_eq(value, 0.0)
    _ => @test.fail("Test failed")
  }
  
  match complex_attributes[10].1 {
    FloatValue(value) => assert_eq(value, 1.0e-10)
    _ => @test.fail("Test failed")
  }
  
  // éªŒè¯å¸ƒå°”å±æ€§
  match complex_attributes[12].1 {
    BoolValue(value) => assert_eq(value, true)
    _ => @test.fail("Test failed")
  }
  
  match complex_attributes[13].1 {
    BoolValue(value) => assert_eq(value, false)
    _ => @test.fail("Test failed")
  }
  
  // éªŒè¯æ•°ç»„å±æ€§
  match complex_attributes[14].1 {
    ArrayStringValue(values) => assert_eq(values.length(), 0)
    _ => @test.fail("Test failed")
  }
  
  match complex_attributes[15].1 {
    ArrayStringValue(values) => {
      assert_eq(values.length(), 1)
      assert_eq(values[0], "single")
    }
    _ => @test.fail("Test failed")
  }
}

test "attribute_value_type_safety_validation" {
  // æµ‹è¯•AttributeValueçš„ç±»å‹å®‰å…¨æ€§
  
  // åˆ›å»ºå„ç§ç±»å‹çš„å€¼
  let string_val = AttributeValue::string("test")
  let int_val = AttributeValue::int(42L)
  let float_val = AttributeValue::float(3.14)
  let bool_val = AttributeValue::bool(true)
  let string_array_val = AttributeValue::array_string(["a", "b"])
  let int_array_val = AttributeValue::array_int([1L, 2L])
  let float_array_val = AttributeValue::array_float([1.0, 2.0])
  let bool_array_val = AttributeValue::array_bool([true, false])
  
  // éªŒè¯æ¯ä¸ªå€¼çš„ç±»å‹
  match string_val {
    StringValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  match int_val {
    IntValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  match float_val {
    FloatValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  match bool_val {
    BoolValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  match string_array_val {
    ArrayStringValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  match int_array_val {
    ArrayIntValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  match float_array_val {
    ArrayFloatValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
  
  match bool_array_val {
    ArrayBoolValue(_) => assert_eq(true, true)
    _ => @test.fail("Test failed")
  }
}