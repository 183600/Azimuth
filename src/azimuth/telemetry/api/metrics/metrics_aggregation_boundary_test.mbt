// Metricsèšåˆè¾¹ç•Œæµ‹è¯•
test "metrics_counter_boundary_conditions" {
  // æµ‹è¯•Counterçš„è¾¹ç•Œæ¡ä»¶
  
  let meter = NoopMeter::{}
  let counter = meter.create_counter("boundary.test.counter", "requests", "Boundary test counter")
  
  // æµ‹è¯•è¾¹ç•Œå€¼
  let boundary_values = [
    0L,  // é›¶å€¼
    1L,  // æœ€å°æ­£å€¼
    -1L,  // è´Ÿå€¼
    9223372036854775807L,  // æœ€å¤§64ä½æ•´æ•°
    -9223372036854775808L,  // æœ€å°64ä½æ•´æ•°
    1000000L,  // å¤§å€¼
    -1000000L,  // å¤§è´Ÿå€¼
    42L,  // å¸¸è§„å€¼
    -42L  // å¸¸è§„è´Ÿå€¼
  ]
  
  let mut i = 0
  while i < boundary_values.length() {
    let attributes = Some([
      ("test.value", AttributeValue::int(boundary_values[i])),
      ("test.index", AttributeValue::int(i.to_int64()))
    ])
    
    // æµ‹è¯•è¾¹ç•Œå€¼çš„æ·»åŠ 
    counter.add(boundary_values[i], attributes)
    i = i + 1
  }
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„è¾¹ç•Œå€¼
  let edge_attributes = [
    ("empty.string", AttributeValue::string("")),
    ("empty.array", AttributeValue::array_string([])),
    ("zero.int", AttributeValue::int(0L)),
    ("zero.float", AttributeValue::float(0.0)),
    ("false.bool", AttributeValue::bool(false)),
    ("max.int", AttributeValue::int(9223372036854775807L)),
    ("min.int", AttributeValue::int(-9223372036854775808L)),
    ("inf.float", AttributeValue::float(1.0/0.0)),
    ("neg.inf.float", AttributeValue::float(-1.0/0.0)),
    ("nan.float", AttributeValue::float(0.0/0.0)),
    ("unicode.string", AttributeValue::string("æµ‹è¯•ä¸­æ–‡ğŸš€")),
    ("special.chars", AttributeValue::string("!@#$%^&*()")),
    ("very.long.string", AttributeValue::string("a".repeat(1000))),
    ("large.array", AttributeValue::array_string([for i = 0; i < 100; i = i + 1].map(fn(_) { "item" })))
  ]
  
  // æµ‹è¯•è¾¹ç•Œå±æ€§
  counter.add(1L, Some(edge_attributes))
  
  // æµ‹è¯•ç©ºå±æ€§
  counter.add(1L, None)
  counter.add(1L, Some([]))
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut large_attributes = []
  let mut j = 0
  while j < 1000 {
    large_attributes.push(("large.attr." + j.to_string(), AttributeValue::int(j.to_int64())))
    j = j + 1
  }
  
  counter.add(1L, Some(large_attributes))
}

test "metrics_histogram_boundary_conditions" {
  // æµ‹è¯•Histogramçš„è¾¹ç•Œæ¡ä»¶
  
  let meter = NoopMeter::{}
  let histogram = meter.create_histogram("boundary.test.histogram", "seconds", "Boundary test histogram")
  
  // æµ‹è¯•è¾¹ç•Œå€¼
  let boundary_values = [
    0.0,  // é›¶å€¼
    1.0e-10,  // æå°æ­£å€¼
    -1.0e-10,  // æå°è´Ÿå€¼
    1.7976931348623157e+308,  // æœ€å¤§åŒç²¾åº¦æµ®ç‚¹æ•°
    -1.7976931348623157e+308,  // æœ€å°åŒç²¾åº¦æµ®ç‚¹æ•°
    1.0/0.0,  // æ­£æ— ç©·å¤§
    -1.0/0.0,  // è´Ÿæ— ç©·å¤§
    0.0/0.0,  // NaN
    3.14159265359,  // Pi
    -3.14159265359,  // è´ŸPi
    1.0e6,  // å¤§å€¼
    -1.0e6,  // å¤§è´Ÿå€¼
    42.0,  // å¸¸è§„å€¼
    -42.0  // å¸¸è§„è´Ÿå€¼
  ]
  
  let mut i = 0
  while i < boundary_values.length() {
    let attributes = Some([
      ("test.value", AttributeValue::float(boundary_values[i])),
      ("test.index", AttributeValue::int(i.to_int64())),
      ("value.type", AttributeValue::string(if boundary_values[i] >= 0.0 { "positive" } else { "negative" }))
    ])
    
    // æµ‹è¯•è¾¹ç•Œå€¼çš„è®°å½•
    histogram.record(boundary_values[i], attributes)
    i = i + 1
  }
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼çš„å±æ€§
  let special_float_attributes = [
    ("zero.value", AttributeValue::float(0.0)),
    ("inf.value", AttributeValue::float(1.0/0.0)),
    ("neg.inf.value", AttributeValue::float(-1.0/0.0)),
    ("nan.value", AttributeValue::float(0.0/0.0)),
    ("very.small", AttributeValue::float(1.0e-100)),
    ("very.large", AttributeValue::float(1.0e100))
  ]
  
  histogram.record(1.0, Some(special_float_attributes))
  
  // æµ‹è¯•ç©ºå±æ€§
  histogram.record(1.0, None)
  histogram.record(1.0, Some([]))
}

test "metrics_up_down_counter_boundary_conditions" {
  // æµ‹è¯•UpDownCounterçš„è¾¹ç•Œæ¡ä»¶
  
  let meter = NoopMeter::{}
  let up_down_counter = meter.create_up_down_counter("boundary.test.up_down_counter", "operations", "Boundary test up-down counter")
  
  // æµ‹è¯•è¾¹ç•Œå€¼
  let boundary_values = [
    0L,  // é›¶å€¼
    1L,  // æœ€å°æ­£å€¼
    -1L,  // è´Ÿå€¼
    9223372036854775807L,  // æœ€å¤§64ä½æ•´æ•°
    -9223372036854775808L,  // æœ€å°64ä½æ•´æ•°
    1000000L,  // å¤§å€¼
    -1000000L,  // å¤§è´Ÿå€¼
    42L,  // å¸¸è§„å€¼
    -42L  // å¸¸è§„è´Ÿå€¼
  ]
  
  let mut i = 0
  while i < boundary_values.length() {
    let attributes = Some([
      ("operation.type", AttributeValue::string(if boundary_values[i] >= 0L { "increment" } else { "decrement" })),
      ("operation.value", AttributeValue::int(boundary_values[i])),
      ("operation.index", AttributeValue::int(i.to_int64()))
    ])
    
    // æµ‹è¯•è¾¹ç•Œå€¼çš„æ·»åŠ 
    up_down_counter.add(boundary_values[i], attributes)
    i = i + 1
  }
  
  // æµ‹è¯•äº¤æ›¿å¢å‡
  let mut j = 0
  while j < 100 {
    if j % 2 == 0 {
      up_down_counter.add(1L, Some([("alternating", AttributeValue::bool(true))]))
    } else {
      up_down_counter.add(-1L, Some([("alternating", AttributeValue::bool(true))]))
    }
    j = j + 1
  }
  
  // æµ‹è¯•å¤§èŒƒå›´å¢å‡
  up_down_counter.add(1000000L, Some([("large.operation", AttributeValue::string("large_increment"))]))
  up_down_counter.add(-999999L, Some([("large.operation", AttributeValue::string("large_decrement"))]))
}

test "metrics_gauge_boundary_conditions" {
  // æµ‹è¯•Gaugeçš„è¾¹ç•Œæ¡ä»¶
  
  let meter = NoopMeter::{}
  let gauge = meter.create_gauge("boundary.test.gauge", "bytes", "Boundary test gauge")
  
  // æµ‹è¯•è¾¹ç•Œå€¼
  let boundary_values = [
    0.0,  // é›¶å€¼
    1.0e-10,  // æå°æ­£å€¼
    -1.0e-10,  // æå°è´Ÿå€¼
    1.7976931348623157e+308,  // æœ€å¤§åŒç²¾åº¦æµ®ç‚¹æ•°
    -1.7976931348623157e+308,  // æœ€å°åŒç²¾åº¦æµ®ç‚¹æ•°
    1.0/0.0,  // æ­£æ— ç©·å¤§
    -1.0/0.0,  // è´Ÿæ— ç©·å¤§
    0.0/0.0,  // NaN
    3.14159265359,  // Pi
    -3.14159265359,  // è´ŸPi
    1.0e6,  // å¤§å€¼
    -1.0e6,  // å¤§è´Ÿå€¼
    42.0,  // å¸¸è§„å€¼
    -42.0  // å¸¸è§„è´Ÿå€¼
  ]
  
  let mut i = 0
  while i < boundary_values.length() {
    let attributes = Some([
      ("gauge.type", AttributeValue::string(if boundary_values[i] >= 0.0 { "positive" } else { "negative" })),
      ("gauge.value", AttributeValue::float(boundary_values[i])),
      ("gauge.index", AttributeValue::int(i.to_int64()))
    ])
    
    // æµ‹è¯•è¾¹ç•Œå€¼çš„è®°å½•
    gauge.record(boundary_values[i], attributes)
    i = i + 1
  }
  
  // æµ‹è¯•å¿«é€Ÿå˜åŒ–çš„å€¼
  let mut j = 0
  while j < 1000 {
    gauge.record(j.to_double(), Some([("rapid.change", AttributeValue::bool(true))]))
    j = j + 1
  }
  
  // æµ‹è¯•å‘¨æœŸæ€§å€¼
  let mut k = 0
  while k < 100 {
    let sine_value = (k.to_double() * 0.1).sin()
    gauge.record(sine_value, Some([("periodic", AttributeValue::bool(true))]))
    k = k + 1
  }
}

test "metrics_aggregation_edge_cases" {
  // æµ‹è¯•åº¦é‡èšåˆçš„è¾¹ç•Œæƒ…å†µ
  
  let meter = NoopMeter::{}
  
  // åˆ›å»ºå¤šä¸ªç›¸åŒç±»å‹çš„åº¦é‡
  let counter1 = meter.create_counter("aggregation.test.counter", "requests", "Aggregation test counter 1")
  let counter2 = meter.create_counter("aggregation.test.counter", "requests", "Aggregation test counter 2")
  let counter3 = meter.create_counter("aggregation.test.counter", "requests", "Aggregation test counter 3")
  
  let histogram1 = meter.create_histogram("aggregation.test.histogram", "seconds", "Aggregation test histogram 1")
  let histogram2 = meter.create_histogram("aggregation.test.histogram", "seconds", "Aggregation test histogram 2")
  
  let gauge1 = meter.create_gauge("aggregation.test.gauge", "bytes", "Aggregation test gauge 1")
  let gauge2 = meter.create_gauge("aggregation.test.gauge", "bytes", "Aggregation test gauge 2")
  
  // æµ‹è¯•ç›¸åŒåç§°åº¦é‡çš„å¹¶å‘æ“ä½œ
  let mut i = 0
  while i < 100 {
    counter1.add(1L, Some([("counter.id", AttributeValue::int(1L))]))
    counter2.add(2L, Some([("counter.id", AttributeValue::int(2L))]))
    counter3.add(3L, Some([("counter.id", AttributeValue::int(3L))]))
    
    histogram1.record(i.to_double(), Some([("histogram.id", AttributeValue::int(1L))]))
    histogram2.record(i.to_double() * 2.0, Some([("histogram.id", AttributeValue::int(2L))]))
    
    gauge1.record(i.to_double() * 0.1, Some([("gauge.id", AttributeValue::int(1L))]))
    gauge2.record(i.to_double() * 0.2, Some([("gauge.id", AttributeValue::int(2L))]))
    
    i = i + 1
  }
  
  // æµ‹è¯•ä¸åŒå±æ€§ç»„åˆçš„èšåˆ
  let attribute_combinations = [
    [("service.name", AttributeValue::string("service-a")), ("operation.name", AttributeValue::string("op1"))],
    [("service.name", AttributeValue::string("service-a")), ("operation.name", AttributeValue::string("op2"))],
    [("service.name", AttributeValue::string("service-b")), ("operation.name", AttributeValue::string("op1"))],
    [("service.name", AttributeValue::string("service-b")), ("operation.name", AttributeValue::string("op2"))],
    [("service.name", AttributeValue::string("service-c")), ("operation.name", AttributeValue::string("op1"))],
    [("service.name", AttributeValue::string("service-c")), ("operation.name", AttributeValue::string("op2"))]
  ]
  
  let mut j = 0
  while j < attribute_combinations.length() {
    counter1.add(10L, Some(attribute_combinations[j]))
    histogram1.record(j.to_double(), Some(attribute_combinations[j]))
    gauge1.record(j.to_double() * 10.0, Some(attribute_combinations[j]))
    j = j + 1
  }
}

test "metrics_high_cardinality_attributes" {
  // æµ‹è¯•é«˜åŸºæ•°å±æ€§çš„åº¦é‡
  
  let meter = NoopMeter::{}
  let counter = meter.create_counter("high.cardinality.test.counter", "requests", "High cardinality test counter")
  let histogram = meter.create_histogram("high.cardinality.test.histogram", "seconds", "High cardinality test histogram")
  
  // æµ‹è¯•é«˜åŸºæ•°ç”¨æˆ·ID
  let mut user_id = 0
  while user_id < 1000 {
    counter.add(1L, Some([
      ("user.id", AttributeValue::string("user-" + user_id.to_string())),
      ("operation.type", AttributeValue::string("api_request"))
    ]))
    
    histogram.record(0.1, Some([
      ("user.id", AttributeValue::string("user-" + user_id.to_string())),
      ("operation.type", AttributeValue::string("api_request"))
    ]))
    
    user_id = user_id + 1
  }
  
  // æµ‹è¯•é«˜åŸºæ•°è¯·æ±‚ID
  let mut request_id = 0
  while request_id < 500 {
    counter.add(1L, Some([
      ("request.id", AttributeValue::string("req-" + request_id.to_string())),
      ("service.name", AttributeValue::string("api-service"))
    ]))
    
    histogram.record(0.05, Some([
      ("request.id", AttributeValue::string("req-" + request_id.to_string())),
      ("service.name", AttributeValue::string("api-service"))
    ]))
    
    request_id = request_id + 1
  }
  
  // æµ‹è¯•é«˜åŸºæ•°ä¼šè¯ID
  let mut session_id = 0
  while session_id < 200 {
    counter.add(1L, Some([
      ("session.id", AttributeValue::string("session-" + session_id.to_string())),
      ("user.type", AttributeValue::string("premium"))
    ]))
    
    histogram.record(0.2, Some([
      ("session.id", AttributeValue::string("session-" + session_id.to_string())),
      ("user.type", AttributeValue::string("premium"))
    ]))
    
    session_id = session_id + 1
  }
  
  // æµ‹è¯•å¤åˆé«˜åŸºæ•°å±æ€§
  let mut k = 0
  while k < 100 {
    counter.add(1L, Some([
      ("user.id", AttributeValue::string("user-" + k.to_string())),
      ("session.id", AttributeValue::string("session-" + (k * 2).to_string())),
      ("request.id", AttributeValue::string("req-" + (k * 3).to_string())),
      ("trace.id", AttributeValue::string("trace-" + (k * 5).to_string()))
    ]))
    k = k + 1
  }
}

test "metrics_large_scale_operations" {
  // æµ‹è¯•å¤§è§„æ¨¡åº¦é‡æ“ä½œ
  
  let meter = NoopMeter::{}
  
  // åˆ›å»ºå¤šä¸ªåº¦é‡å®ä¾‹
  let counters = []
  let histograms = []
  let gauges = []
  let up_down_counters = []
  
  let mut i = 0
  while i < 100 {
    counters.push(meter.create_counter("large.scale.counter." + i.to_string(), "operations", "Large scale counter " + i.to_string()))
    histograms.push(meter.create_histogram("large.scale.histogram." + i.to_string(), "seconds", "Large scale histogram " + i.to_string()))
    gauges.push(meter.create_gauge("large.scale.gauge." + i.to_string(), "bytes", "Large scale gauge " + i.to_string()))
    up_down_counters.push(meter.create_up_down_counter("large.scale.up_down_counter." + i.to_string(), "operations", "Large scale up-down counter " + i.to_string()))
    i = i + 1
  }
  
  // å¯¹æ¯ä¸ªåº¦é‡æ‰§è¡Œå¤§é‡æ“ä½œ
  let mut j = 0
  while j < 100 {
    let mut k = 0
    while k < 100 {
      // å¯¹æ¯ä¸ªè®¡æ•°å™¨æ·»åŠ å€¼
      let mut idx = 0
      while idx < counters.length() {
        counters[idx].add(j.to_int64(), Some([
          ("batch.index", AttributeValue::int(j.to_int64())),
          ("operation.index", AttributeValue::int(k.to_int64())),
          ("counter.index", AttributeValue::int(idx.to_int64()))
        ]))
        idx = idx + 1
      }
      
      // å¯¹æ¯ä¸ªç›´æ–¹å›¾è®°å½•å€¼
      idx = 0
      while idx < histograms.length() {
        histograms[idx].record(k.to_double(), Some([
          ("batch.index", AttributeValue::int(j.to_int64())),
          ("operation.index", AttributeValue::int(k.to_int64())),
          ("histogram.index", AttributeValue::int(idx.to_int64()))
        ]))
        idx = idx + 1
      }
      
      // å¯¹æ¯ä¸ªä»ªè¡¨è®°å½•å€¼
      idx = 0
      while idx < gauges.length() {
        gauges[idx].record(k.to_double() * 0.01, Some([
          ("batch.index", AttributeValue::int(j.to_int64())),
          ("operation.index", AttributeValue::int(k.to_int64())),
          ("gauge.index", AttributeValue::int(idx.to_int64()))
        ]))
        idx = idx + 1
      }
      
      // å¯¹æ¯ä¸ªä¸Šä¸‹è¡Œè®¡æ•°å™¨æ·»åŠ å€¼
      idx = 0
      while idx < up_down_counters.length() {
        let value = if k % 2 == 0 { 1L } else { -1L }
        up_down_counters[idx].add(value, Some([
          ("batch.index", AttributeValue::int(j.to_int64())),
          ("operation.index", AttributeValue::int(k.to_int64())),
          ("up_down_counter.index", AttributeValue::int(idx.to_int64())),
          ("operation.sign", AttributeValue::string(if value >= 0L { "positive" } else { "negative" }))
        ]))
        idx = idx + 1
      }
      
      k = k + 1
    }
    j = j + 1
  }
}

test "metrics_attribute_boundary_combinations" {
  // æµ‹è¯•å±æ€§è¾¹ç•Œç»„åˆ
  
  let meter = NoopMeter::{}
  let counter = meter.create_counter("attribute.boundary.test.counter", "requests", "Attribute boundary test counter")
  
  // æµ‹è¯•æ‰€æœ‰å±æ€§ç±»å‹çš„è¾¹ç•Œç»„åˆ
  let string_attributes = [
    "",  // ç©ºå­—ç¬¦ä¸²
    " ",  // ç©ºæ ¼
    "normal_string",  // æ­£å¸¸å­—ç¬¦ä¸²
    "string_with_spaces",  // åŒ…å«ç©ºæ ¼
    "string-with-dashes",  // åŒ…å«è¿å­—ç¬¦
    "string_with_underscores",  // åŒ…å«ä¸‹åˆ’çº¿
    "string.with.dots",  // åŒ…å«ç‚¹å·
    "UPPERCASE_STRING",  // å¤§å†™
    "lowercase_string",  // å°å†™
    "MixedCase_String",  // æ··åˆå¤§å°å†™
    "123numeric_start",  // æ•°å­—å¼€å¤´
    "numeric_end_123",  // æ•°å­—ç»“å°¾
    "special!@#$%^&*()chars",  // ç‰¹æ®Šå­—ç¬¦
    "æµ‹è¯•ä¸­æ–‡",  // ä¸­æ–‡
    "ğŸš€emoji_test",  // emoji
    "a".repeat(1000),  // é•¿å­—ç¬¦ä¸²
    "unicode_\u0000_test",  // Unicodeç©ºå­—ç¬¦
    "new\nline\ntest",  // æ¢è¡Œç¬¦
    "tab\ttest\ttab",  // åˆ¶è¡¨ç¬¦
    "carriage\rreturn\rtes"  // å›è½¦ç¬¦
  ]
  
  let int_attributes = [
    0L,  // é›¶
    1L,  // æœ€å°æ­£å€¼
    -1L,  // è´Ÿå€¼
    9223372036854775807L,  // æœ€å¤§å€¼
    -9223372036854775808L,  // æœ€å°å€¼
    42L,  // å¸¸è§„å€¼
    -42L,  // å¸¸è§„è´Ÿå€¼
    1000000L,  // å¤§å€¼
    -1000000L  // å¤§è´Ÿå€¼
  ]
  
  let float_attributes = [
    0.0,  // é›¶
    1.0e-10,  // æå°æ­£å€¼
    -1.0e-10,  // æå°è´Ÿå€¼
    1.7976931348623157e+308,  // æœ€å¤§å€¼
    -1.7976931348623157e+308,  // æœ€å°å€¼
    1.0/0.0,  // æ­£æ— ç©·
    -1.0/0.0,  // è´Ÿæ— ç©·
    0.0/0.0,  // NaN
    3.14159265359,  // Pi
    -3.14159265359  // è´ŸPi
  ]
  
  let bool_attributes = [
    true,  // çœŸ
    false  // å‡
  ]
  
  let array_string_attributes = [
    [],  // ç©ºæ•°ç»„
    ["single_item"],  // å•é¡¹æ•°ç»„
    ["item1", "item2", "item3"],  // å¤šé¡¹æ•°ç»„
    [for i = 0; i < 100; i = i + 1].map(fn(_) { "repeated_item" }),  // å¤§æ•°ç»„
    ["", " ", "normal", "special!@#$%", "æµ‹è¯•ä¸­æ–‡", "ğŸš€"]  // æ··åˆå†…å®¹
  ]
  
  let array_int_attributes = [
    [],  // ç©ºæ•°ç»„
    [42L],  // å•é¡¹æ•°ç»„
    [1L, 2L, 3L, 4L, 5L],  // å¤šé¡¹æ•°ç»„
    [for i = 0; i < 100; i = i + 1].map(fn(_) { 999L }),  // å¤§æ•°ç»„
    [0L, 1L, -1L, 9223372036854775807L, -9223372036854775808L]  // è¾¹ç•Œå€¼æ•°ç»„
  ]
  
  let array_float_attributes = [
    [],  // ç©ºæ•°ç»„
    [3.14],  // å•é¡¹æ•°ç»„
    [1.1, 2.2, 3.3, 4.4, 5.5],  // å¤šé¡¹æ•°ç»„
    [for i = 0; i < 100; i = i + 1].map(fn(_) { 99.99 }),  // å¤§æ•°ç»„
    [0.0, 1.0e-10, 1.7976931348623157e+308, 1.0/0.0, 0.0/0.0]  // ç‰¹æ®Šå€¼æ•°ç»„
  ]
  
  let array_bool_attributes = [
    [],  // ç©ºæ•°ç»„
    [true],  // å•é¡¹æ•°ç»„
    [true, false, true, false],  // å¤šé¡¹æ•°ç»„
    [for i = 0; i < 100; i = i + 1].map(fn(_) { true }),  // å¤§æ•°ç»„
    [true, false]  // æ··åˆæ•°ç»„
  ]
  
  // æµ‹è¯•å„ç§å±æ€§ç»„åˆ
  let mut i = 0
  while i < string_attributes.length() {
    let mut j = 0
    while j < int_attributes.length() {
      let mut k = 0
      while k < float_attributes.length() {
        let mut l = 0
        while l < bool_attributes.length() {
          // æµ‹è¯•åŸºæœ¬å±æ€§ç»„åˆ
          counter.add(1L, Some([
            ("string.attr", AttributeValue::string(string_attributes[i])),
            ("int.attr", AttributeValue::int(int_attributes[j])),
            ("float.attr", AttributeValue::float(float_attributes[k])),
            ("bool.attr", AttributeValue::bool(bool_attributes[l]))
          ]))
          
          l = l + 1
        }
        k = k + 1
      }
      j = j + 1
    }
    i = i + 1
  }
  
  // æµ‹è¯•æ•°ç»„å±æ€§ç»„åˆ
  let m = 0
  while m < array_string_attributes.length() {
    counter.add(1L, Some([
      ("array.string.attr", AttributeValue::array_string(array_string_attributes[m]))
    ]))
    m = m + 1
  }
  
  let n = 0
  while n < array_int_attributes.length() {
    counter.add(1L, Some([
      ("array.int.attr", AttributeValue::array_int(array_int_attributes[n]))
    ]))
    n = n + 1
  }
  
  let o = 0
  while o < array_float_attributes.length() {
    counter.add(1L, Some([
      ("array.float.attr", AttributeValue::array_float(array_float_attributes[o]))
    ]))
    o = o + 1
  }
  
  let p = 0
  while p < array_bool_attributes.length() {
    counter.add(1L, Some([
      ("array.bool.attr", AttributeValue::array_bool(array_bool_attributes[p]))
    ]))
    p = p + 1
  }
}