// Metricsæ¨¡å—è¾¹ç•Œå€¼æµ‹è¯•ç”¨ä¾‹
test "counter_boundary_values" {
  // æµ‹è¯•Counterçš„è¾¹ç•Œå€¼
  let meter = NoopMeter::{}
  let counter = meter.create_counter("boundary.test.counter", "operations", "Counter boundary test")
  
  // æµ‹è¯•æœ€å°å€¼
  counter.add(0L)
  counter.add(-1L)
  counter.add(-9223372036854775808L)  // Int64æœ€å°å€¼
  
  // æµ‹è¯•æœ€å¤§å€¼
  counter.add(1L)
  counter.add(9223372036854775807L)   // Int64æœ€å¤§å€¼
  
  // æµ‹è¯•è¾¹ç•Œé™„è¿‘çš„å€¼
  counter.add(-1L)
  counter.add(0L)
  counter.add(1L)
  
  // æµ‹è¯•å¤§æ•°æ“ä½œ
  counter.add(1000000000000L)  // 1ä¸‡äº¿
  counter.add(-1000000000000L)
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„è¾¹ç•Œå€¼
  let boundary_attrs : Array[(String, AttributeValue)] = [
    ("boundary.type", AttributeValue::string("counter")),
    ("test.category", AttributeValue::string("boundary")),
    ("operation", AttributeValue::string("boundary.test"))
  ]
  
  counter.add(9223372036854775807L, Some(boundary_attrs))
  counter.add(-9223372036854775808L, Some(boundary_attrs))
  
  assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜è¾¹ç•Œå€¼æµ‹è¯•é€šè¿‡
}

test "histogram_boundary_values" {
  // æµ‹è¯•Histogramçš„è¾¹ç•Œå€¼
  let meter = NoopMeter::{}
  let histogram = meter.create_histogram("boundary.test.histogram", "seconds", "Histogram boundary test")
  
  // æµ‹è¯•æœ€å°å€¼
  histogram.record(0.0)
  histogram.record(-1.0)
  histogram.record(-1.7976931348623157e+308)  // Doubleæœ€å°å€¼ï¼ˆè¿‘ä¼¼ï¼‰
  
  // æµ‹è¯•æœ€å¤§å€¼
  histogram.record(1.0)
  histogram.record(1.7976931348623157e+308)   // Doubleæœ€å¤§å€¼ï¼ˆè¿‘ä¼¼ï¼‰
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  histogram.record(1.0/0.0)   // æ­£æ— ç©·
  histogram.record(-1.0/0.0)  // è´Ÿæ— ç©·
  histogram.record(0.0/0.0)   // NaN
  
  // æµ‹è¯•éå¸¸å°çš„å€¼
  histogram.record(1.0e-100)
  histogram.record(1.0e-200)
  histogram.record(1.0e-300)
  
  // æµ‹è¯•éå¸¸å¤§çš„å€¼
  histogram.record(1.0e+100)
  histogram.record(1.0e+200)
  histogram.record(1.0e+300)
  
  // æµ‹è¯•ç§‘å­¦è®¡æ•°æ³•è¾¹ç•Œå€¼
  histogram.record(2.2250738585072014e-308)  // æœ€å°æ­£è§„èŒƒæ•°
  histogram.record(1.7976931348623157e+308)  // æœ€å¤§æœ‰é™æ•°
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„è¾¹ç•Œå€¼
  let boundary_attrs : Array[(String, AttributeValue)] = [
    ("boundary.type", AttributeValue::string("histogram")),
    ("test.category", AttributeValue::string("boundary")),
    ("operation", AttributeValue::string("boundary.test"))
  ]
  
  histogram.record(1.7976931348623157e+308, Some(boundary_attrs))
  histogram.record(-1.7976931348623157e+308, Some(boundary_attrs))
  
  assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜è¾¹ç•Œå€¼æµ‹è¯•é€šè¿‡
}

test "up_down_counter_boundary_values" {
  // æµ‹è¯•UpDownCounterçš„è¾¹ç•Œå€¼
  let meter = NoopMeter::{}
  let up_down_counter = meter.create_up_down_counter("boundary.test.up_down_counter", "items", "UpDownCounter boundary test")
  
  // æµ‹è¯•æœ€å°å€¼
  up_down_counter.add(0L)
  up_down_counter.add(-1L)
  up_down_counter.add(-9223372036854775808L)  // Int64æœ€å°å€¼
  
  // æµ‹è¯•æœ€å¤§å€¼
  up_down_counter.add(1L)
  up_down_counter.add(9223372036854775807L)   // Int64æœ€å¤§å€¼
  
  // æµ‹è¯•äº¤æ›¿å¢å‡åˆ°è¾¹ç•Œ
  up_down_counter.add(9223372036854775807L)   // åŠ åˆ°æœ€å¤§å€¼
  up_down_counter.add(-9223372036854775808L)  // å‡åˆ°æœ€å°å€¼
  up_down_counter.add(9223372036854775807L)   // å†æ¬¡åŠ åˆ°æœ€å¤§å€¼
  
  // æµ‹è¯•å¿«é€Ÿå˜åŒ–çš„å€¼
  let mut i = 0
  while i < 100 {
    if i % 2 == 0 {
      up_down_counter.add(1000L)
    } else {
      up_down_counter.add(-1000L)
    }
    i = i + 1
  }
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„è¾¹ç•Œå€¼
  let boundary_attrs : Array[(String, AttributeValue)] = [
    ("boundary.type", AttributeValue::string("up_down_counter")),
    ("test.category", AttributeValue::string("boundary")),
    ("operation", AttributeValue::string("boundary.test"))
  ]
  
  up_down_counter.add(9223372036854775807L, Some(boundary_attrs))
  up_down_counter.add(-9223372036854775808L, Some(boundary_attrs))
  
  assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜è¾¹ç•Œå€¼æµ‹è¯•é€šè¿‡
}

test "gauge_boundary_values" {
  // æµ‹è¯•Gaugeçš„è¾¹ç•Œå€¼
  let meter = NoopMeter::{}
  let gauge = meter.create_gauge("boundary.test.gauge", "percent", "Gauge boundary test")
  
  // æµ‹è¯•æœ€å°å€¼
  gauge.record(0.0)
  gauge.record(-1.0)
  gauge.record(-1.7976931348623157e+308)  // Doubleæœ€å°å€¼ï¼ˆè¿‘ä¼¼ï¼‰
  
  // æµ‹è¯•æœ€å¤§å€¼
  gauge.record(1.0)
  gauge.record(100.0)  // ç™¾åˆ†æ¯”è¾¹ç•Œ
  gauge.record(1.7976931348623157e+308)   // Doubleæœ€å¤§å€¼ï¼ˆè¿‘ä¼¼ï¼‰
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  gauge.record(1.0/0.0)   // æ­£æ— ç©·
  gauge.record(-1.0/0.0)  // è´Ÿæ— ç©·
  gauge.record(0.0/0.0)   // NaN
  
  // æµ‹è¯•ç²¾åº¦è¾¹ç•Œå€¼
  gauge.record(0.1 + 0.2)  // æµ®ç‚¹ç²¾åº¦æµ‹è¯•
  gauge.record(0.9999999999999999)
  gauge.record(1.0000000000000001)
  
  // æµ‹è¯•éå¸¸æ¥è¿‘çš„å€¼
  gauge.record(0.0000000000000001)
  gauge.record(-0.0000000000000001)
  
  // æµ‹è¯•ç§‘å­¦è®¡æ•°æ³•è¾¹ç•Œå€¼
  gauge.record(4.9406564584124654e-324)  // æœ€å°æ­£åŒç²¾åº¦æ•°
  gauge.record(1.7976931348623157e+308)  // æœ€å¤§æœ‰é™æ•°
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„è¾¹ç•Œå€¼
  let boundary_attrs : Array[(String, AttributeValue)] = [
    ("boundary.type", AttributeValue::string("gauge")),
    ("test.category", AttributeValue::string("boundary")),
    ("operation", AttributeValue::string("boundary.test"))
  ]
  
  gauge.record(1.7976931348623157e+308, Some(boundary_attrs))
  gauge.record(-1.7976931348623157e+308, Some(boundary_attrs))
  
  assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜è¾¹ç•Œå€¼æµ‹è¯•é€šè¿‡
}

test "meter_creation_boundary_values" {
  // æµ‹è¯•Meteråˆ›å»ºçš„è¾¹ç•Œå€¼
  let meter_provider = NoopMeterProvider::{}
  
  // æµ‹è¯•æé•¿çš„åç§°
  let very_long_name = "this.is.a.very.long.metric.name.that.exceeds.normal.expectations.and.tests.the.boundary.conditions.of.the.metric.creation.system.with.many.characters.and.symbols"
  let long_counter = meter_provider.get_meter(very_long_name).create_counter("long.name.test", "operations", "Test with long meter name")
  long_counter.add(1L)
  
  // æµ‹è¯•ç©ºåç§°
  let empty_meter = meter_provider.get_meter("").create_counter("empty.meter.test", "operations", "Test with empty meter name")
  empty_meter.add(1L)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°
  let special_meter = meter_provider.get_meter("special!@#$%^&*()_+-={}[]|\\:;\"'<>?,./").create_counter("special.meter.test", "operations", "Test with special characters")
  special_meter.add(1L)
  
  // æµ‹è¯•Unicodeåç§°
  let unicode_meter = meter_provider.get_meter("Unicodeæµ‹è¯•ğŸš€").create_counter("unicode.meter.test", "operations", "Test with Unicode characters")
  unicode_meter.add(1L)
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„åç§°
  let space_meter = meter_provider.get_meter("meter with spaces").create_counter("space.meter.test", "operations", "Test with spaces")
  space_meter.add(1L)
  
  // æµ‹è¯•æé•¿çš„åº¦é‡åç§°
  let very_long_metric_name = "this.is.a.very.long.metric.name.that.exceeds.normal.expectations.and.tests.the.boundary.conditions.of.the.metric.creation.system.with.many.characters.and.symbols.and.should.still.work.correctly"
  let long_metric_counter = meter_provider.get_meter("test.meter").create_counter(very_long_metric_name, "operations", "Test with long metric name")
  long_metric_counter.add(1L)
  
  // æµ‹è¯•æé•¿çš„å•ä½
  let very_long_unit = "this.is.a.very.long.unit.that.exceeds.normal.expectations.and.tests.the.boundary.conditions.of.the.unit.creation.system"
  let long_unit_counter = meter_provider.get_meter("test.meter").create_counter("long.unit.test", very_long_unit, "Test with long unit")
  long_unit_counter.add(1L)
  
  // æµ‹è¯•æé•¿çš„æè¿°
  let very_long_description = "this.is.a.very.long.description.that.exceeds.normal.expectations.and.tests.the.boundary.conditions.of.the.description.creation.system.with.many.characters.and.symbols.and.should.still.work.correctly.even.when.it.contains.a.lot.of.text.and.information.about.the.metric.and.its.purpose.and.usage"
  let long_description_counter = meter_provider.get_meter("test.meter").create_counter("long.description.test", "operations", very_long_description)
  long_description_counter.add(1L)
  
  assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜è¾¹ç•Œå€¼æµ‹è¯•é€šè¿‡
}

test "measurement_boundary_values" {
  // æµ‹è¯•Measurementçš„è¾¹ç•Œå€¼
  let boundary_measurements : Array[Measurement] = [
    // è¾¹ç•Œæ•°å€¼
    Measurement::{ value: 0.0, attributes: [] },
    Measurement::{ value: -1.7976931348623157e+308, attributes: [] },  // æœ€å°å€¼
    Measurement::{ value: 1.7976931348623157e+308, attributes: [] },   // æœ€å¤§å€¼
    Measurement::{ value: 1.0/0.0, attributes: [] },                  // æ­£æ— ç©·
    Measurement::{ value: -1.0/0.0, attributes: [] },                 // è´Ÿæ— ç©·
    Measurement::{ value: 0.0/0.0, attributes: [] },                  // NaN
    
    // ç²¾åº¦è¾¹ç•Œå€¼
    Measurement::{ value: 2.2250738585072014e-308, attributes: [] },  // æœ€å°æ­£è§„èŒƒæ•°
    Measurement::{ value: 4.9406564584124654e-324, attributes: [] },  // æœ€å°æ­£åŒç²¾åº¦æ•°
    
    // ç§‘å­¦è®¡æ•°æ³•è¾¹ç•Œå€¼
    Measurement::{ value: 1.0e-100, attributes: [] },
    Measurement::{ value: 1.0e+100, attributes: [] },
    Measurement::{ value: 1.0e-200, attributes: [] },
    Measurement::{ value: 1.0e+200, attributes: [] },
    
    // å¸¦æœ‰å¤æ‚å±æ€§çš„è¾¹ç•Œå€¼æµ‹é‡
    Measurement::{
      value: 1.7976931348623157e+308,
      attributes: [
        ("boundary.type", AttributeValue::string("measurement")),
        ("test.category", AttributeValue::string("boundary")),
        ("value.type", AttributeValue::string("maximum")),
        ("precision", AttributeValue::string("double")),
        ("special", AttributeValue::bool(true))
      ]
    },
    Measurement::{
      value: -1.7976931348623157e+308,
      attributes: [
        ("boundary.type", AttributeValue::string("measurement")),
        ("test.category", AttributeValue::string("boundary")),
        ("value.type", AttributeValue::string("minimum")),
        ("precision", AttributeValue::string("double")),
        ("special", AttributeValue::bool(false))
      ]
    }
  ]
  
  // éªŒè¯æ‰€æœ‰è¾¹ç•Œå€¼æµ‹é‡
  let mut i = 0
  while i < boundary_measurements.length() {
    let measurement = boundary_measurements[i]
    
    // éªŒè¯æµ‹é‡å€¼æ˜¯æœ‰æ•ˆçš„ï¼ˆå³ä½¿æ˜¯ç‰¹æ®Šå€¼ï¼‰
    assert_eq(measurement.attributes.length() >= 0, true)
    
    // å¯¹äºæœ‰å±æ€§çš„æµ‹é‡ï¼ŒéªŒè¯å±æ€§
    if measurement.attributes.length() > 0 {
      let mut j = 0
      while j < measurement.attributes.length() {
        let (key, value) = measurement.attributes[j]
        assert_eq(key.length() > 0, true)
        j = j + 1
      }
    }
    
    i = i + 1
  }
  
  assert_eq(boundary_measurements.length(), 13)
}

test "instrument_type_boundary_coverage" {
  // æµ‹è¯•æ‰€æœ‰ä»ªå™¨ç±»å‹çš„è¾¹ç•Œå€¼è¦†ç›–
  let meter = NoopMeter::{}
  
  // ä¸ºæ¯ç§ä»ªå™¨ç±»å‹åˆ›å»ºå®ä¾‹å¹¶æµ‹è¯•è¾¹ç•Œå€¼
  let counter = meter.create_counter("", "", "")
  let histogram = meter.create_histogram("", "", "")
  let up_down_counter = meter.create_up_down_counter("", "", "")
  let gauge = meter.create_gauge("", "", "")
  
  // æµ‹è¯•æ‰€æœ‰ä»ªå™¨ç±»å‹éƒ½èƒ½å¤„ç†è¾¹ç•Œå€¼
  counter.add(9223372036854775807L)
  counter.add(-9223372036854775808L)
  
  histogram.record(1.7976931348623157e+308)
  histogram.record(-1.7976931348623157e+308)
  histogram.record(1.0/0.0)
  histogram.record(-1.0/0.0)
  histogram.record(0.0/0.0)
  
  up_down_counter.add(9223372036854775807L)
  up_down_counter.add(-9223372036854775808L)
  
  gauge.record(1.7976931348623157e+308)
  gauge.record(-1.7976931348623157e+308)
  gauge.record(1.0/0.0)
  gauge.record(-1.0/0.0)
  gauge.record(0.0/0.0)
  
  // æµ‹è¯•å¸¦æœ‰å¤æ‚å±æ€§çš„è¾¹ç•Œå€¼
  let complex_attrs : Array[(String, AttributeValue)] = [
    ("instrument.type", AttributeValue::string("boundary.test")),
    ("boundary.category", AttributeValue::string("extreme")),
    ("test.scenario", AttributeValue::string("all.instrument.types")),
    ("array.attr", AttributeValue::array_string(["boundary", "test", "extreme"])),
    ("int.attr", AttributeValue::int(9223372036854775807L)),
    ("float.attr", AttributeValue::float(1.7976931348623157e+308)),
    ("bool.attr", AttributeValue::bool(true))
  ]
  
  counter.add(1L, Some(complex_attrs))
  histogram.record(1.0, Some(complex_attrs))
  up_down_counter.add(1L, Some(complex_attrs))
  gauge.record(1.0, Some(complex_attrs))
  
  assert_eq(true, true)  // å¦‚æœèƒ½æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜æ‰€æœ‰ä»ªå™¨ç±»å‹çš„è¾¹ç•Œå€¼æµ‹è¯•é€šè¿‡
}