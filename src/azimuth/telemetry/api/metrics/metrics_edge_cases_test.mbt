// Metricsæ¨¡å—è¾¹ç¼˜æƒ…å†µæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•metricsçš„è¾¹ç¼˜æƒ…å†µå’Œé”™è¯¯å¤„ç†

test "metrics_boundary_conditions" {
  // æµ‹è¯•metricsçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æå€¼æƒ…å†µ
  let max_int64 = 9223372036854775807L
  let min_int64 = -9223372036854775808L
  let zero_int64 = 0L
  
  let max_double = 1.7976931348623157e308
  let min_double = -1.7976931348623157e308
  let zero_double = 0.0
  let infinity_double = 1.0/0.0
  let neg_infinity_double = -1.0/0.0
  let nan_double = 0.0/0.0
  
  // æµ‹è¯•Counterçš„æå€¼
  let counter_attrs_max = [
    ("counter.value", AttributeValue::int(max_int64)),
    ("counter.name", AttributeValue::string("max-counter"))
  ]
  
  let counter_attrs_min = [
    ("counter.value", AttributeValue::int(min_int64)),
    ("counter.name", AttributeValue::string("min-counter"))
  ]
  
  let counter_attrs_zero = [
    ("counter.value", AttributeValue::int(zero_int64)),
    ("counter.name", AttributeValue::string("zero-counter"))
  ]
  
  // éªŒè¯Counterå±æ€§
  assert_eq(counter_attrs_max.length(), 2)
  match counter_attrs_max[0].1 {
    IntValue(value) => assert_eq(value, max_int64)
    _ => @test.fail("Expected IntValue")
  }
  
  assert_eq(counter_attrs_min.length(), 2)
  match counter_attrs_min[0].1 {
    IntValue(value) => assert_eq(value, min_int64)
    _ => @test.fail("Expected IntValue")
  }
  
  assert_eq(counter_attrs_zero.length(), 2)
  match counter_attrs_zero[0].1 {
    IntValue(value) => assert_eq(value, zero_int64)
    _ => @test.fail("Expected IntValue")
  }
  
  // æµ‹è¯•Histogramçš„æå€¼
  let histogram_attrs_max = [
    ("histogram.value", AttributeValue::float(max_double)),
    ("histogram.name", AttributeValue::string("max-histogram"))
  ]
  
  let histogram_attrs_min = [
    ("histogram.value", AttributeValue::float(min_double)),
    ("histogram.name", AttributeValue::string("min-histogram"))
  ]
  
  let histogram_attrs_zero = [
    ("histogram.value", AttributeValue::float(zero_double)),
    ("histogram.name", AttributeValue::string("zero-histogram"))
  ]
  
  let histogram_attrs_inf = [
    ("histogram.value", AttributeValue::float(infinity_double)),
    ("histogram.name", AttributeValue::string("inf-histogram"))
  ]
  
  let histogram_attrs_nan = [
    ("histogram.value", AttributeValue::float(nan_double)),
    ("histogram.name", AttributeValue::string("nan-histogram"))
  ]
  
  // éªŒè¯Histogramå±æ€§
  assert_eq(histogram_attrs_max.length(), 2)
  match histogram_attrs_max[0].1 {
    FloatValue(value) => assert_eq(value, max_double)
    _ => @test.fail("Expected FloatValue")
  }
  
  assert_eq(histogram_attrs_min.length(), 2)
  match histogram_attrs_min[0].1 {
    FloatValue(value) => assert_eq(value, min_double)
    _ => @test.fail("Expected FloatValue")
  }
  
  assert_eq(histogram_attrs_zero.length(), 2)
  match histogram_attrs_zero[0].1 {
    FloatValue(value) => assert_eq(value, zero_double)
    _ => @test.fail("Expected FloatValue")
  }
  
  assert_eq(histogram_attrs_inf.length(), 2)
  match histogram_attrs_inf[0].1 {
    FloatValue(value) => {
      // å¯¹äºinfinityï¼Œæˆ‘ä»¬åªéªŒè¯ç±»å‹è€Œä¸éªŒè¯å…·ä½“å€¼
      assert_eq(true, true)
    }
    _ => @test.fail("Expected FloatValue")
  }
  
  assert_eq(histogram_attrs_nan.length(), 2)
  match histogram_attrs_nan[0].1 {
    FloatValue(value) => {
      // å¯¹äºNaNï¼Œæˆ‘ä»¬åªéªŒè¯ç±»å‹è€Œä¸éªŒè¯å…·ä½“å€¼
      assert_eq(true, true)
    }
    _ => @test.fail("Expected FloatValue")
  }
}

test "metrics_error_conditions" {
  // æµ‹è¯•metricsçš„é”™è¯¯æ¡ä»¶
  
  // æµ‹è¯•æ— æ•ˆçš„metricåç§°
  let invalid_names = [
    "",                    // ç©ºå­—ç¬¦ä¸²
    " ",                   // åªæœ‰ç©ºæ ¼
    "name with spaces",    // åŒ…å«ç©ºæ ¼
    "name@with#special",   // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    "123invalid",          // ä»¥æ•°å­—å¼€å¤´
    "a".repeat(300),       // è¿‡é•¿çš„åç§°
    "na\nme",              // åŒ…å«æ¢è¡Œç¬¦
    "na\tme",              // åŒ…å«åˆ¶è¡¨ç¬¦
    "na\rme",              // åŒ…å«å›è½¦ç¬¦
    "na/me",               // åŒ…å«è·¯å¾„åˆ†éš”ç¬¦
  ]
  
  // æµ‹è¯•æ¯ä¸ªæ— æ•ˆåç§°
  for invalid_name in invalid_names {
    let is_valid_name = invalid_name.length() > 0 &&
                        !invalid_name.contains(" ") &&
                        !invalid_name.contains("@") &&
                        !invalid_name.contains("#") &&
                        !invalid_name.starts_with("0") &&
                        invalid_name.length() <= 255 &&
                        !invalid_name.contains("\n") &&
                        !invalid_name.contains("\t") &&
                        !invalid_name.contains("\r") &&
                        !invalid_name.contains("/")
    
    // æ‰€æœ‰è¿™äº›åç§°éƒ½åº”è¯¥æ˜¯æ— æ•ˆçš„
    assert_eq(is_valid_name, false)
  }
  
  // æµ‹è¯•æœ‰æ•ˆçš„metricåç§°
  let valid_names = [
    "valid.metric.name",
    "metric_with_underscores",
    "metric-with-dashes",
    "metric123",
    "a.b.c.d.e",
    "short",
    "metric_with_numbers_123"
  ]
  
  // æµ‹è¯•æ¯ä¸ªæœ‰æ•ˆåç§°
  for valid_name in valid_names {
    let is_valid_name = valid_name.length() > 0 &&
                        !valid_name.contains(" ") &&
                        !valid_name.contains("@") &&
                        !valid_name.contains("#") &&
                        !valid_name.starts_with("0") &&
                        valid_name.length() <= 255 &&
                        !valid_name.contains("\n") &&
                        !valid_name.contains("\t") &&
                        !valid_name.contains("\r") &&
                        !valid_name.contains("/")
    
    // æ‰€æœ‰è¿™äº›åç§°éƒ½åº”è¯¥æ˜¯æœ‰æ•ˆçš„
    assert_eq(is_valid_name, true)
  }
  
  // æµ‹è¯•æ— æ•ˆçš„å±æ€§å€¼
  let empty_string_attr = ("empty.string", AttributeValue::string(""))
  let empty_array_attr = ("empty.array", AttributeValue::array_string([]))
  
  // éªŒè¯ç©ºå€¼å±æ€§
  match empty_string_attr.1 {
    StringValue(value) => assert_eq(value, "")
    _ => @test.fail("Expected StringValue")
  }
  
  match empty_array_attr.1 {
    ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => @test.fail("Expected ArrayStringValue")
  }
  
  // æµ‹è¯•å±æ€§é”®çš„è¾¹ç•Œæƒ…å†µ
  let very_long_key = "a".repeat(500)
  let key_with_unicode = "é”®å€¼å¯¹æµ‹è¯•"
  let key_with_emoji = "emoji_testğŸš€"
  
  let long_key_attr = (very_long_key, AttributeValue::string("test"))
  let unicode_key_attr = (key_with_unicode, AttributeValue::string("æµ‹è¯•"))
  let emoji_key_attr = (key_with_emoji, AttributeValue::string("rocket"))
  
  // éªŒè¯é•¿é”®åå±æ€§
  assert_eq(long_key_attr.0.length(), 500)
  
  // éªŒè¯Unicodeé”®åå±æ€§
  assert_eq(unicode_key_attr.0.contains("é”®å€¼"), true)
  
  // éªŒè¯emojié”®åå±æ€§
  assert_eq(emoji_key_attr.0.contains("ğŸš€"), true)
}