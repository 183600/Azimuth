// Contextå’ŒBaggageäº¤äº’æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Contextå’ŒBaggageä¹‹é—´çš„å¤æ‚äº¤äº’åœºæ™¯

test "context_with_multiple_baggage_entries" {
  // æµ‹è¯•Contextä¸­åŒ…å«å¤šä¸ªBaggageæ¡ç›®çš„åœºæ™¯
  
  // åˆ›å»ºåŸºç¡€Context
  let base_context = Context::empty()
  
  // åˆ›å»ºå¤šä¸ªContextKey
  let user_key = create_key("user.id")
  let session_key = create_key("session.id")
  let request_key = create_key("request.id")
  let trace_key = create_key("trace.id")
  
  // å‘Contextæ·»åŠ å¤šä¸ªå€¼
  let context_with_user = base_context.with_value(user_key, "user12345")
  let context_with_session = context_with_user.with_value(session_key, "sess_abcdef")
  let context_with_request = context_with_session.with_value(request_key, "req_123456")
  let full_context = context_with_request.with_value(trace_key, "trace_789")
  
  // éªŒè¯Contextä¸­çš„å€¼
  match full_context.get(user_key) {
    Some(user_id) => assert_eq(user_id, "user12345")
    None => @test.fail("Expected user.id in context")
  }
  
  match full_context.get(session_key) {
    Some(session_id) => assert_eq(session_id, "sess_abcdef")
    None => @test.fail("Expected session.id in context")
  }
  
  match full_context.get(request_key) {
    Some(request_id) => assert_eq(request_id, "req_123456")
    None => @test.fail("Expected request.id in context")
  }
  
  match full_context.get(trace_key) {
    Some(trace_id) => assert_eq(trace_id, "trace_789")
    None => @test.fail("Expected trace.id in context")
  }
  
  // åˆ›å»ºå¯¹åº”çš„Baggage
  let base_baggage = Baggage::empty()
  let baggage_with_user = base_baggage.with_entry("user.id", "user12345")
  let baggage_with_session = baggage_with_user.with_entry("session.id", "sess_abcdef")
  let baggage_with_request = baggage_with_session.with_entry("request.id", "req_123456")
  let full_baggage = baggage_with_request.with_entry("trace.id", "trace_789")
  
  // éªŒè¯Baggageä¸­çš„æ¡ç›®
  match full_baggage.get("user.id") {
    Some(user_id) => assert_eq(user_id, "user12345")
    None => @test.fail("Expected user.id in baggage")
  }
  
  match full_baggage.get("session.id") {
    Some(session_id) => assert_eq(session_id, "sess_abcdef")
    None => @test.fail("Expected session.id in baggage")
  }
  
  match full_baggage.get("request.id") {
    Some(request_id) => assert_eq(request_id, "req_123456")
    None => @test.fail("Expected request.id in baggage")
  }
  
  match full_baggage.get("trace.id") {
    Some(trace_id) => assert_eq(trace_id, "trace_789")
    None => @test.fail("Expected trace.id in baggage")
  }
  
  // éªŒè¯Contextå’ŒBaggageçš„ä¸€è‡´æ€§
  let verify_consistency = fn(ctx : Context, baggage : Baggage) -> Bool {
    let context_keys = ["user.id", "session.id", "request.id", "trace.id"]
    let mut consistent = true
    let mut i = 0
    
    while i < context_keys.length() && consistent {
      let key = context_keys[i]
      let context_key = create_key(key)
      
      match ctx.get(context_key) {
        Some(context_value) => {
          match baggage.get(key) {
            Some(baggage_value) => {
              if context_value != baggage_value {
                consistent = false
              }
            }
            None => consistent = false
          }
        }
        None => consistent = false
      }
      
      i = i + 1
    }
    
    consistent
  }
  
  assert_eq(verify_consistency(full_context, full_baggage), true)
}

test "context_baggage_value_overriding" {
  // æµ‹è¯•Contextå’ŒBaggageä¸­çš„å€¼è¦†ç›–åœºæ™¯
  
  // åˆ›å»ºåŸºç¡€Context
  let base_context = Context::empty()
  let user_key = create_key("user.id")
  
  // æ·»åŠ åˆå§‹å€¼
  let context_v1 = base_context.with_value(user_key, "user_v1")
  
  // éªŒè¯åˆå§‹å€¼
  match context_v1.get(user_key) {
    Some(user_id) => assert_eq(user_id, "user_v1")
    None => @test.fail("Expected user_v1")
  }
  
  // è¦†ç›–å€¼
  let context_v2 = context_v1.with_value(user_key, "user_v2")
  
  // éªŒè¯è¦†ç›–åçš„å€¼
  match context_v2.get(user_key) {
    Some(user_id) => assert_eq(user_id, "user_v2")
    None => @test.fail("Expected user_v2")
  }
  
  // æµ‹è¯•Baggageçš„å€¼è¦†ç›–
  let base_baggage = Baggage::empty()
  let baggage_v1 = base_baggage.with_entry("user.id", "user_v1")
  
  match baggage_v1.get("user.id") {
    Some(user_id) => assert_eq(user_id, "user_v1")
    None => @test.fail("Expected user_v1 in baggage")
  }
  
  // æ³¨æ„ï¼šç”±äºMoonBitçš„Arrayæ˜¯ä¸å¯å˜çš„ï¼Œwith_entryå®é™…ä¸Šæ˜¯æ·»åŠ æ–°æ¡ç›®
  // åœ¨å®é™…å®ç°ä¸­ï¼Œå¯èƒ½éœ€è¦ä¸åŒçš„ç­–ç•¥æ¥å¤„ç†é‡å¤é”®
  let baggage_v2 = baggage_v1.with_entry("user.id", "user_v2")
  
  // éªŒè¯Baggageä¸­çš„æ¡ç›®æ•°é‡å˜åŒ–
  assert_eq(baggage_v1.entries.length(), 1)
  assert_eq(baggage_v2.entries.length(), 2)
  
  // æµ‹è¯•Contextçš„å±‚æ¬¡ç»“æ„
  let parent_context = base_context.with_value(user_key, "parent_user")
  let child_context = parent_context.with_value(create_key("child.id"), "child_123")
  
  // éªŒè¯å­ContextåŒ…å«çˆ¶Contextçš„å€¼
  match child_context.get(user_key) {
    Some(user_id) => assert_eq(user_id, "parent_user")
    None => @test.fail("Expected parent_user in child context")
  }
  
  match child_context.get(create_key("child.id")) {
    Some(child_id) => assert_eq(child_id, "child_123")
    None => @test.fail("Expected child.id in child context")
  }
  
  // æµ‹è¯•Contextå€¼çš„ç‹¬ç«‹æ€§
  let independent_context = base_context.with_value(user_key, "independent_user")
  
  match independent_context.get(user_key) {
    Some(user_id) => assert_eq(user_id, "independent_user")
    None => @test.fail("Expected independent_user")
  }
  
  // éªŒè¯ä¸åŒContextä¹‹é—´çš„å€¼ä¸å½±å“
  match context_v2.get(user_key) {
    Some(user_id) => assert_eq(user_id, "user_v2")  // ä¸å—independent_contextå½±å“
    None => @test.fail("Expected user_v2")
  }
}

test "context_baggage_complex_data_structures" {
  // æµ‹è¯•Contextå’ŒBaggageä¸­å¤æ‚æ•°æ®ç»“æ„çš„å¤„ç†
  
  // åˆ›å»ºåŒ…å«å¤æ‚æ•°æ®çš„Context
  let base_context = Context::empty()
  
  // æ·»åŠ JSONæ ¼å¼çš„å¤æ‚æ•°æ®
  let user_data_key = create_key("user.data")
  let complex_user_data = "{\"id\":\"user123\",\"name\":\"John Doe\",\"email\":\"john@example.com\",\"roles\":[\"admin\",\"user\"],\"preferences\":{\"theme\":\"dark\",\"lang\":\"en\"}}"
  let context_with_user_data = base_context.with_value(user_data_key, complex_user_data)
  
  // éªŒè¯å¤æ‚æ•°æ®
  match context_with_user_data.get(user_data_key) {
    Some(user_data) => {
      assert_eq(user_data.contains("\"id\":\"user123\""), true)
      assert_eq(user_data.contains("\"roles\""), true)
      assert_eq(user_data.contains("\"preferences\""), true)
    }
    None => @test.fail("Expected user data")
  }
  
  // æ·»åŠ åºåˆ—åŒ–çš„æ•°ç»„æ•°æ®
  let metrics_key = create_key("metrics.data")
  let metrics_data = "[{\"name\":\"cpu_usage\",\"value\":75.5,\"unit\":\"percent\"},{\"name\":\"memory_usage\",\"value\":1024,\"unit\":\"mb\"}]"
  let context_with_metrics = context_with_user_data.with_value(metrics_key, metrics_data)
  
  match context_with_metrics.get(metrics_key) {
    Some(metrics) => {
      assert_eq(metrics.contains("cpu_usage"), true)
      assert_eq(metrics.contains("memory_usage"), true)
    }
    None => @test.fail("Expected metrics data")
  }
  
  // åˆ›å»ºå¯¹åº”çš„Baggageæ¡ç›®
  let base_baggage = Baggage::empty()
  let baggage_with_user_data = base_baggage.with_entry("user.data", complex_user_data)
  let baggage_with_metrics = baggage_with_user_data.with_entry("metrics.data", metrics_data)
  
  // éªŒè¯Baggageä¸­çš„å¤æ‚æ•°æ®
  match baggage_with_metrics.get("user.data") {
    Some(user_data) => {
      assert_eq(user_data, complex_user_data)
    }
    None => @test.fail("Expected user data in baggage")
  }
  
  match baggage_with_metrics.get("metrics.data") {
    Some(metrics) => {
      assert_eq(metrics, metrics_data)
    }
    None => @test.fail("Expected metrics data in baggage")
  }
  
  // æµ‹è¯•å¤æ‚æ•°æ®çš„è§£æå‡½æ•°
  let parse_json_value = fn(json_str : String, key : String) -> String? {
    let key_pattern = "\"" + key + "\":\""
    let start_index = json_str.index_of(key_pattern)
    
    if start_index >= 0 {
      let value_start = start_index + key_pattern.length()
      let end_index = json_str.index_of("\"", value_start)
      
      if end_index > value_start {
        Some(json_str.substring(value_start, end_index - value_start))
      } else {
        None
      }
    } else {
      None
    }
  }
  
  // æµ‹è¯•JSONè§£æ
  match parse_json_value(complex_user_data, "id") {
    Some(user_id) => assert_eq(user_id, "user123")
    None => @test.fail("Expected to parse user id")
  }
  
  match parse_json_value(complex_user_data, "email") {
    Some(email) => assert_eq(email, "john@example.com")
    None => @test.fail("Expected to parse user email")
  }
  
  // æµ‹è¯•åµŒå¥—æ•°æ®ç»“æ„
  let nested_data_key = create_key("nested.data")
  let nested_data = "level1.level2.level3=value"
  let context_with_nested = context_with_metrics.with_value(nested_data_key, nested_data)
  
  match context_with_nested.get(nested_data_key) {
    Some(nested) => {
      assert_eq(nested.contains("level1"), true)
      assert_eq(nested.contains("level2"), true)
      assert_eq(nested.contains("level3"), true)
    }
    None => @test.fail("Expected nested data")
  }
  
  // æµ‹è¯•URLç¼–ç çš„æ•°æ®
  let encoded_data_key = create_key("encoded.data")
  let encoded_data = "user%20name%3DJohn%20Doe%26email%3Djohn%40example.com"
  let context_with_encoded = context_with_nested.with_value(encoded_data_key, encoded_data)
  
  match context_with_encoded.get(encoded_data_key) {
    Some(encoded) => {
      assert_eq(encoded.contains("%20"), true)
      assert_eq(encoded.contains("%3D"), true)
      assert_eq(encoded.contains("%26"), true)
    }
    None => @test.fail("Expected encoded data")
  }
}

test "context_baggage_performance_and_limits" {
  // æµ‹è¯•Contextå’ŒBaggageçš„æ€§èƒ½å’Œé™åˆ¶
  
  // æµ‹è¯•å¤§é‡Contextå€¼çš„æ€§èƒ½
  let create_large_context = fn(size : Int) -> Context {
    let base_context = Context::empty()
    let mut current_context = base_context
    let mut i = 0
    
    while i < size {
      let key = create_key("key." + i.to_string())
      let value = "value." + i.to_string()
      current_context = current_context.with_value(key, value)
      i = i + 1
    }
    
    current_context
  }
  
  // åˆ›å»ºåŒ…å«100ä¸ªæ¡ç›®çš„Context
  let large_context = create_large_context(100)
  
  // éªŒè¯å¤§å‹Contextä¸­çš„ç‰¹å®šå€¼
  let test_key = create_key("key.50")
  match large_context.get(test_key) {
    Some(value) => assert_eq(value, "value.50")
    None => @test.fail("Expected value.50 in large context")
  }
  
  // æµ‹è¯•å¤§é‡Baggageæ¡ç›®çš„æ€§èƒ½
  let create_large_baggage = fn(size : Int) -> Baggage {
    let base_baggage = Baggage::empty()
    let mut current_baggage = base_baggage
    let mut i = 0
    
    while i < size {
      let key = "baggage.key." + i.to_string()
      let value = "baggage.value." + i.to_string()
      current_baggage = current_baggage.with_entry(key, value)
      i = i + 1
    }
    
    current_baggage
  }
  
  // åˆ›å»ºåŒ…å«100ä¸ªæ¡ç›®çš„Baggage
  let large_baggage = create_large_baggage(100)
  
  // éªŒè¯å¤§å‹Baggageä¸­çš„ç‰¹å®šæ¡ç›®
  match large_baggage.get("baggage.key.75") {
    Some(value) => assert_eq(value, "baggage.value.75")
    None => @test.fail("Expected baggage.value.75 in large baggage")
  }
  
  // æµ‹è¯•Contextå€¼çš„æŸ¥æ‰¾æ€§èƒ½
  let measure_context_lookup = fn(ctx : Context, iterations : Int) -> Int64 {
    let test_key = create_key("key.25")
    let start_time = 1640995200123456789L  // æ¨¡æ‹Ÿæ—¶é—´æˆ³
    let mut i = 0
    
    while i < iterations {
      let _ = ctx.get(test_key)
      i = i + 1
    }
    
    let end_time = 1640995200123456789L + iterations.to_int64()  // æ¨¡æ‹Ÿç»è¿‡çš„æ—¶é—´
    end_time - start_time
  }
  
  let context_lookup_time = measure_context_lookup(large_context, 1000)
  assert_eq(context_lookup_time >= 0, true)  // åŸºæœ¬çš„æ—¶é—´æµ‹é‡éªŒè¯
  
  // æµ‹è¯•Baggageæ¡ç›®çš„æŸ¥æ‰¾æ€§èƒ½
  let measure_baggage_lookup = fn(baggage : Baggage, iterations : Int) -> Int64 {
    let start_time = 1640995200123456789L
    let mut i = 0
    
    while i < iterations {
      let _ = baggage.get("baggage.key.25")
      i = i + 1
    }
    
    let end_time = 1640995200123456789L + iterations.to_int64()
    end_time - start_time
  }
  
  let baggage_lookup_time = measure_baggage_lookup(large_baggage, 1000)
  assert_eq(baggage_lookup_time >= 0, true)
  
  // æµ‹è¯•é•¿é”®åå’Œå€¼çš„å½±å“
  let long_key_name = "very.long.key.name.with.many.dots.and.additional.information.to.make.it.really.long.123456789"
  let long_value = "very.long.value.with.much.information.and.data.that.could.be.used.for.various.purposes.in.a.real.world.application.scenario.987654321"
  
  let context_with_long_values = Context::empty()
    .with_value(create_key(long_key_name), long_value)
  
  match context_with_long_values.get(create_key(long_key_name)) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Expected long value")
  }
  
  let baggage_with_long_values = Baggage::empty()
    .with_entry(long_key_name, long_value)
  
  match baggage_with_long_values.get(long_key_name) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Expected long baggage value")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å
  let special_chars_key = "key.with.special.chars!@#$%^&*(){}[]|\\:;\"'<>?,./"
  let context_with_special = Context::empty()
    .with_value(create_key(special_chars_key), "special_value")
  
  match context_with_special.get(create_key(special_chars_key)) {
    Some(value) => assert_eq(value, "special_value")
    None => @test.fail("Expected special chars value")
  }
  
  let baggage_with_special = Baggage::empty()
    .with_entry(special_chars_key, "special_value")
  
  match baggage_with_special.get(special_chars_key) {
    Some(value) => assert_eq(value, "special_value")
    None => @test.fail("Expected special chars baggage value")
  }
  
  // æµ‹è¯•Unicodeé”®å
  let unicode_key = "é”®.å.åŒ…å«.ä¸­æ–‡.å’Œ.emoji.ğŸš€"
  let context_with_unicode = Context::empty()
    .with_value(create_key(unicode_key), "unicode_value")
  
  match context_with_unicode.get(create_key(unicode_key)) {
    Some(value) => assert_eq(value, "unicode_value")
    None => @test.fail("Expected unicode value")
  }
  
  let baggage_with_unicode = Baggage::empty()
    .with_entry(unicode_key, "unicode_value")
  
  match baggage_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, "unicode_value")
    None => @test.fail("Expected unicode baggage value")
  }
}

test "context_baggage_serialization_and_deserialization" {
  // æµ‹è¯•Contextå’ŒBaggageçš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  
  // åˆ›å»ºåŒ…å«å¤šç§æ•°æ®çš„Context
  let test_context = Context::empty()
    .with_value(create_key("user.id"), "user123")
    .with_value(create_key("session.id"), "sess_456")
    .with_value(create_key("request.id"), "req_789")
    .with_value(create_key("trace.id"), "trace_abc")
  
  // æ¨¡æ‹ŸContextåºåˆ—åŒ–
  let serialize_context = fn(ctx : Context) -> String {
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™å¯èƒ½ä¼šå°†Contextè½¬æ¢ä¸ºå­—ç¬¦ä¸²æˆ–å­—èŠ‚æµ
    // è¿™é‡Œæˆ‘ä»¬æ¨¡æ‹Ÿä¸€ä¸ªç®€å•çš„åºåˆ—åŒ–æ ¼å¼
    let serialized = "context:" + ctx.values.length().to_string() + ":"
    let mut i = 0
    
    while i < ctx.values.length() {
      let (key, value) = ctx.values[i]
      serialized = serialized + key + "=" + value + ";"
      i = i + 1
    }
    
    serialized
  }
  
  let serialized_context = serialize_context(test_context)
  assert_eq(serialized_context.has_prefix("context:"), true)
  assert_eq(serialized_context.contains("user.id=user123"), true)
  assert_eq(serialized_context.contains("session.id=sess_456"), true)
  
  // æ¨¡æ‹ŸContextååºåˆ—åŒ–
  let deserialize_context = fn(serialized : String) -> Context {
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™ä¼šä»å­—ç¬¦ä¸²é‡å»ºContext
    // è¿™é‡Œæˆ‘ä»¬è¿”å›ä¸€ä¸ªæ¨¡æ‹Ÿçš„Context
    Context::empty()
  }
  
  let deserialized_context = deserialize_context(serialized_context)
  assert_eq(deserialized_context.values.length(), 0)  // æ¨¡æ‹Ÿå®ç°è¿”å›ç©ºContext
  
  // åˆ›å»ºå¯¹åº”çš„Baggage
  let test_baggage = Baggage::empty()
    .with_entry("user.id", "user123")
    .with_entry("session.id", "sess_456")
    .with_entry("request.id", "req_789")
    .with_entry("trace.id", "trace_abc")
  
  // æ¨¡æ‹ŸBaggageåºåˆ—åŒ–ä¸ºHTTPå¤´æ ¼å¼
  let serialize_baggage_as_header = fn(baggage : Baggage) -> String {
    let mut header_value = ""
    let mut i = 0
    
    while i < baggage.entries.length() {
      let (key, value) = baggage.entries[i]
      if i > 0 {
        header_value = header_value + ","
      }
      header_value = header_value + key + "=" + value
      i = i + 1
    }
    
    header_value
  }
  
  let baggage_header = serialize_baggage_as_header(test_baggage)
  assert_eq(baggage_header.contains("user.id=user123"), true)
  assert_eq(baggage_header.contains("session.id=sess_456"), true)
  assert_eq(baggage_header.contains(","), true)  // åº”è¯¥æœ‰é€—å·åˆ†éš”ç¬¦
  
  // æ¨¡æ‹Ÿä»HTTPå¤´ååºåˆ—åŒ–Baggage
  let parse_baggage_header = fn(header : String) -> Baggage {
    // ç®€å•çš„HTTPå¤´è§£æ
    let entries = header.split(",")
    let baggage = Baggage::empty()
    let mut result = baggage
    let mut i = 0
    
    while i < entries.length() {
      let entry = entries[i]
      let parts = entry.split("=")
      if parts.length() == 2 {
        result = result.with_entry(parts[0], parts[1])
      }
      i = i + 1
    }
    
    result
  }
  
  let parsed_baggage = parse_baggage_header(baggage_header)
  
  // éªŒè¯è§£æåçš„BaggageåŒ…å«åŸå§‹æ¡ç›®
  match parsed_baggage.get("user.id") {
    Some(user_id) => assert_eq(user_id, "user123")
    None => @test.fail("Expected user.id in parsed baggage")
  }
  
  match parsed_baggage.get("session.id") {
    Some(session_id) => assert_eq(session_id, "sess_456")
    None => @test.fail("Expected session.id in parsed baggage")
  }
  
  // æµ‹è¯•URLç¼–ç çš„Baggageå¤´
  let url_encoded_value = "user%20name%3DJohn%20Doe"
  let encoded_baggage = Baggage::empty().with_entry("user.info", url_encoded_value)
  let encoded_header = serialize_baggage_as_header(encoded_baggage)
  
  assert_eq(encoded_header.contains("user.info=" + url_encoded_value), true)
  assert_eq(encoded_header.contains("%20"), true)
  assert_eq(encoded_header.contains("%3D"), true)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„Baggage
  let special_chars_baggage = Baggage::empty()
    .with_entry("special.key", "value with spaces and symbols!@#")
    .with_entry("unicode.key", "å€¼ åŒ…å« ä¸­æ–‡")
  
  let special_header = serialize_baggage_as_header(special_chars_baggage)
  assert_eq(special_header.contains("special.key="), true)
  assert_eq(special_header.contains("unicode.key="), true)
  
  // æµ‹è¯•ç©ºBaggageçš„åºåˆ—åŒ–
  let empty_baggage = Baggage::empty()
  let empty_header = serialize_baggage_as_header(empty_baggage)
  assert_eq(empty_header, "")
  
  // æµ‹è¯•å•æ¡ç›®Baggageçš„åºåˆ—åŒ–
  let single_entry_baggage = Baggage::empty().with_entry("single", "value")
  let single_header = serialize_baggage_as_header(single_entry_baggage)
  assert_eq(single_header, "single=value")
  assert_eq(single_header.contains(","), false)  // å•æ¡ç›®ä¸åº”æœ‰é€—å·
}