// Baggageæ•°æ®ä¸€è‡´æ€§æµ‹è¯•
// æµ‹è¯•Baggageåœ¨å„ç§æ“ä½œä¸‹çš„æ•°æ®ä¸€è‡´æ€§å’Œå®Œæ•´æ€§

test "baggage_basic_operations_consistency" {
  // æµ‹è¯•BaggageåŸºæœ¬æ“ä½œçš„æ•°æ®ä¸€è‡´æ€§
  
  // åˆ›å»ºç©ºçš„baggage
  let empty_baggage = Baggage::empty()
  assert_eq(empty_baggage.entries.length(), 0)
  
  // æ·»åŠ å•ä¸ªæ¡ç›®
  let baggage1 = empty_baggage.with_entry("user_id", "12345")
  assert_eq(baggage1.entries.length(), 1)
  
  match baggage1.get("user_id") {
    Some(value) => assert_eq(value, "12345")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®è¿”å›None
  match baggage1.get("non_existent_key") {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
  
  // æ·»åŠ æ›´å¤šæ¡ç›®
  let baggage2 = baggage1.with_entry("session_id", "abcdef")
  let baggage3 = baggage2.with_entry("request_id", "req_789")
  
  assert_eq(baggage3.entries.length(), 3)
  
  // éªŒè¯æ‰€æœ‰æ¡ç›®éƒ½å­˜åœ¨
  match baggage3.get("user_id") {
    Some(value) => assert_eq(value, "12345")
    None => @test.fail("Test failed")
  }
  
  match baggage3.get("session_id") {
    Some(value) => assert_eq(value, "abcdef")
    None => @test.fail("Test failed")
  }
  
  match baggage3.get("request_id") {
    Some(value) => assert_eq(value, "req_789")
    None => @test.fail("Test failed")
  }
}

test "baggage_overwrite_behavior_consistency" {
  // æµ‹è¯•Baggageè¦†ç›–è¡Œä¸ºçš„ä¸€è‡´æ€§
  
  let base_baggage = Baggage::empty()
  
  // æ·»åŠ åˆå§‹å€¼
  let baggage1 = base_baggage.with_entry("key1", "initial_value")
  assert_eq(baggage1.entries.length(), 1)
  
  match baggage1.get("key1") {
    Some(value) => assert_eq(value, "initial_value")
    None => @test.fail("Test failed")
  }
  
  // è¦†ç›–å€¼
  let baggage2 = baggage1.with_entry("key1", "updated_value")
  assert_eq(baggage2.entries.length(), 2)  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¦†ç›–ä¼šæ·»åŠ æ–°æ¡ç›®
  
  match baggage2.get("key1") {
    Some(value) => {
      // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œgetè¿”å›æœ€åä¸€ä¸ªåŒ¹é…çš„å€¼
      assert_eq(value == "updated_value" || value == "initial_value", true)
    }
    None => @test.fail("Test failed")
  }
  
  // å†æ¬¡è¦†ç›–
  let baggage3 = baggage2.with_entry("key1", "final_value")
  assert_eq(baggage3.entries.length(), 3)
  
  match baggage3.get("key1") {
    Some(value) => {
      // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œgetè¿”å›æœ€åä¸€ä¸ªåŒ¹é…çš„å€¼
      assert_eq(value == "final_value" || value == "updated_value" || value == "initial_value", true)
    }
    None => @test.fail("Test failed")
  }
}

test "baggage_complex_key_value_handling" {
  // æµ‹è¯•Baggageå¤„ç†å¤æ‚é”®å€¼å¯¹çš„ consistency
  
  let base_baggage = Baggage::empty()
  
  // æµ‹è¯•å„ç§å¤æ‚çš„é”®å€¼å¯¹
  let complex_entries = [
    ("simple_key", "simple_value"),
    ("", "empty_key_value"),  // ç©ºé”®
    ("empty_value", ""),  // ç©ºå€¼
    (" ", "space_key"),  // ç©ºæ ¼é”®
    ("space_value", " "),  // ç©ºæ ¼å€¼
    ("key.with.dots", "value.with.dots"),
    ("key-with-dashes", "value-with-dashes"),
    ("key_with_underscores", "value_with_underscores"),
    ("key/with/slashes", "value/with/slashes"),
    ("key\\with\\backslashes", "value\\with\\backslashes"),
    ("key\nwith\nnewlines", "value\nwith\nnewlines"),
    ("key\twith\ttabs", "value\twith\ttabs"),
    ("é”®åä¸­æ–‡", "å€¼ä¸­æ–‡"),
    ("ĞºĞ»ÑÑ‡_Ñ€ÑƒÑÑĞºĞ¸Ğ¹", "Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ_Ñ€ÑƒÑÑĞºĞ¾Ğµ"),
    ("Ù…ÙØªØ§Ø­_Ø¹Ø±Ø¨ÙŠ", "Ù‚ÙŠÙ…Ø©_Ø¹Ø±Ø¨ÙŠØ©"),
    ("very_long_key_name_that_exceeds_normal_expectations", "very_long_value_name_that_also_exceeds_normal_expectations"),
    ("special.chars.!@#$%^&*()", "special.chars.!@#$%^&*()"),
    ("unicode.value", "Hello ä¸–ç•Œ ğŸŒ Ã±Ã¡Ã©Ã­Ã³Ãº"),
    ("json.value", "{\"user\":\"admin\",\"role\":\"administrator\"}"),
    ("url.encoded", "name=John+Doe&age=30"),
    ("base64.data", "SGVsbG8gV29ybGQ="),
    ("multiline.value", "Line 1\nLine 2\nLine 3")
  ]
  
  let mut baggage = base_baggage
  let mut i = 0
  while i < complex_entries.length() {
    let (key, value) = complex_entries[i]
    baggage = baggage.with_entry(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰å¤æ‚é”®å€¼å¯¹éƒ½æ­£ç¡®å­˜å‚¨
  i = 0
  while i < complex_entries.length() {
    let (key, expected_value) = complex_entries[i]
    match baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed for key: " + key)
    }
    i = i + 1
  }
}

test "baggage_large_dataset_consistency" {
  // æµ‹è¯•Baggageå¤„ç†å¤§é‡æ•°æ®æ—¶çš„ consistency
  
  let base_baggage = Baggage::empty()
  
  // åˆ›å»ºå¤§é‡æ¡ç›®
  let mut baggage = base_baggage
  let mut i = 0
  while i < 1000 {
    let key = "key_" + i.to_string()
    let value = "value_" + i.to_string()
    baggage = baggage.with_entry(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰æ¡ç›®éƒ½æ­£ç¡®å­˜å‚¨
  i = 0
  while i < 1000 {
    let key = "key_" + i.to_string()
    let expected_value = "value_" + i.to_string()
    match baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed at index " + i.to_string())
    }
    i = i + 1
  }
  
  // éªŒè¯éšæœºè®¿é—®
  let test_indices = [0, 99, 500, 999, 123, 777]
  i = 0
  while i < test_indices.length() {
    let index = test_indices[i]
    let key = "key_" + index.to_string()
    let expected_value = "value_" + index.to_string()
    match baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed for random access at index " + index.to_string())
    }
    i = i + 1
  }
}

test "baggage_chained_operations_consistency" {
  // æµ‹è¯•Baggageé“¾å¼æ“ä½œçš„ consistency
  
  let base_baggage = Baggage::empty()
  
  // é“¾å¼æ“ä½œï¼šæ·»åŠ å¤šä¸ªæ¡ç›®
  let baggage1 = base_baggage.with_entry("step1", "value1")
  let baggage2 = baggage1.with_entry("step2", "value2")
  let baggage3 = baggage2.with_entry("step3", "value3")
  let baggage4 = baggage3.with_entry("step4", "value4")
  let baggage5 = baggage4.with_entry("step5", "value5")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨ä¸”æ­£ç¡®
  match baggage5.get("step1") {
    Some(value) => assert_eq(value, "value1")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("step2") {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("step3") {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("step4") {
    Some(value) => assert_eq(value, "value4")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("step5") {
    Some(value) => assert_eq(value, "value5")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯ä¸­é—´baggageçš„çŠ¶æ€
  match baggage3.get("step3") {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Test failed")
  }
  
  match baggage3.get("step4") {
    Some(_) => @test.fail("Test failed")  // baggage3ä¸åº”è¯¥æœ‰step4
    None => assert_eq(true, true)
  }
}

test "baggage_isolation_between_instances" {
  // æµ‹è¯•ä¸åŒBaggageå®ä¾‹ä¹‹é—´çš„éš”ç¦»æ€§
  
  let base_baggage = Baggage::empty()
  
  // åˆ›å»ºä¸¤ä¸ªç‹¬ç«‹çš„baggageåˆ†æ”¯
  let branch_a = base_baggage.with_entry("shared_key", "shared_value_a")
  let branch_b = base_baggage.with_entry("shared_key", "shared_value_b")
  
  // æ·»åŠ ä¸åŒçš„é¢å¤–æ•°æ®
  let branch_a_final = branch_a.with_entry("unique_a", "value_a")
  let branch_b_final = branch_b.with_entry("unique_b", "value_b")
  
  // éªŒè¯åˆ†æ”¯Açš„æ•°æ®
  match branch_a_final.get("shared_key") {
    Some(value) => assert_eq(value == "shared_value_a" || value == "shared_value_b", true)
    None => @test.fail("Test failed")
  }
  
  match branch_a_final.get("unique_a") {
    Some(value) => assert_eq(value, "value_a")
    None => @test.fail("Test failed")
  }
  
  match branch_a_final.get("unique_b") {
    Some(_) => @test.fail("Test failed")  // åˆ†æ”¯Aä¸åº”è¯¥æœ‰åˆ†æ”¯Bçš„æ•°æ®
    None => assert_eq(true, true)
  }
  
  // éªŒè¯åˆ†æ”¯Bçš„æ•°æ®
  match branch_b_final.get("shared_key") {
    Some(value) => assert_eq(value == "shared_value_a" || value == "shared_value_b", true)
    None => @test.fail("Test failed")
  }
  
  match branch_b_final.get("unique_b") {
    Some(value) => assert_eq(value, "value_b")
    None => @test.fail("Test failed")
  }
  
  match branch_b_final.get("unique_a") {
    Some(_) => @test.fail("Test failed")  // åˆ†æ”¯Bä¸åº”è¯¥æœ‰åˆ†æ”¯Açš„æ•°æ®
    None => assert_eq(true, true)
  }
}

test "baggage_edge_cases_consistency" {
  // æµ‹è¯•Baggageè¾¹ç•Œæƒ…å†µçš„ consistency
  
  // è¾¹ç•Œæƒ…å†µ1: ç©ºé”®å’Œç©ºå€¼
  let baggage1 = Baggage::empty()
    .with_entry("", "empty_key_value")
    .with_entry("empty_value", "")
    .with_entry("", "")
  
  match baggage1.get("") {
    Some(value) => assert_eq(value == "" || value == "empty_key_value", true)
    None => @test.fail("Test failed")
  }
  
  match baggage1.get("empty_value") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  // è¾¹ç•Œæƒ…å†µ2: åªåŒ…å«ç©ºæ ¼çš„é”®å’Œå€¼
  let baggage2 = Baggage::empty()
    .with_entry(" ", "space_key_value")
    .with_entry("space_value", " ")
    .with_entry(" ", " ")
  
  match baggage2.get(" ") {
    Some(value) => assert_eq(value == " " || value == "space_key_value", true)
    None => @test.fail("Test failed")
  }
  
  match baggage2.get("space_value") {
    Some(value) => assert_eq(value, " ")
    None => @test.fail("Test failed")
  }
  
  // è¾¹ç•Œæƒ…å†µ3: éå¸¸é•¿çš„é”®å’Œå€¼
  let long_key = "k".repeat(1000)  // 1000ä¸ª'k'
  let long_value = "v".repeat(1000)  // 1000ä¸ª'v'
  
  let baggage3 = Baggage::empty().with_entry(long_key, long_value)
  
  match baggage3.get(long_key) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Test failed")
  }
  
  // è¾¹ç•Œæƒ…å†µ4: åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®å’Œå€¼
  let special_key = "!@#$%^&*()_+-=[]{}|;':\",./<>?~`\n\t"
  let special_value = "!@#$%^&*()_+-=[]{}|;':\",./<>?~`\n\t"
  
  let baggage4 = Baggage::empty().with_entry(special_key, special_value)
  
  match baggage4.get(special_key) {
    Some(value) => assert_eq(value, special_value)
    None => @test.fail("Test failed")
  }
}

test "baggage_performance_consistency" {
  // æµ‹è¯•Baggageæ€§èƒ½ç›¸å…³çš„ consistency
  
  let base_baggage = Baggage::empty()
  
  // æ‰§è¡Œå¤§é‡æ“ä½œ
  let mut baggage = base_baggage
  let mut i = 0
  while i < 10000 {
    let key = "perf_key_" + i.to_string()
    let value = "perf_value_" + i.to_string()
    baggage = baggage.with_entry(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  i = 0
  while i < 10000 {
    let key = "perf_key_" + i.to_string()
    let expected_value = "perf_value_" + i.to_string()
    match baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed at index " + i.to_string())
    }
    i = i + 1
  }
  
  // éªŒè¯éšæœºè®¿é—®çš„æ€§èƒ½ä¸€è‡´æ€§
  let test_indices = [0, 9999, 5000, 1234, 7777]
  i = 0
  while i < test_indices.length() {
    let index = test_indices[i]
    let key = "perf_key_" + index.to_string()
    let expected_value = "perf_value_" + index.to_string()
    match baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed for random access at index " + index.to_string())
    }
    i = i + 1
  }
}

test "baggage_memory_efficiency_validation" {
  // æµ‹è¯•Baggageå†…å­˜æ•ˆç‡çš„éªŒè¯
  
  let base_baggage = Baggage::empty()
  
  // åˆ›å»ºå¤šä¸ªç›¸ä¼¼çš„baggageï¼Œæµ‹è¯•å†…å­˜ä½¿ç”¨æ¨¡å¼
  let baggage1 = base_baggage.with_entry("common_key", "common_value")
  let baggage2 = baggage1.with_entry("unique_key_1", "unique_value_1")
  let baggage3 = baggage1.with_entry("unique_key_2", "unique_value_2")
  let baggage4 = baggage1.with_entry("unique_key_3", "unique_value_3")
  
  // éªŒè¯æ¯ä¸ªbaggageéƒ½æœ‰æ­£ç¡®çš„æ•°æ®
  match baggage1.get("common_key") {
    Some(value) => assert_eq(value, "common_value")
    None => @test.fail("Test failed")
  }
  
  match baggage2.get("common_key") {
    Some(value) => assert_eq(value == "common_value", true)
    None => @test.fail("Test failed")
  }
  
  match baggage2.get("unique_key_1") {
    Some(value) => assert_eq(value, "unique_value_1")
    None => @test.fail("Test failed")
  }
  
  match baggage3.get("unique_key_2") {
    Some(value) => assert_eq(value, "unique_value_2")
    None => @test.fail("Test failed")
  }
  
  match baggage4.get("unique_key_3") {
    Some(value) => assert_eq(value, "unique_value_3")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯éš”ç¦»æ€§
  match baggage2.get("unique_key_2") {
    Some(_) => @test.fail("Test failed")  // baggage2ä¸åº”è¯¥æœ‰unique_key_2
    None => assert_eq(true, true)
  }
  
  match baggage3.get("unique_key_1") {
    Some(_) => @test.fail("Test failed")  // baggage3ä¸åº”è¯¥æœ‰unique_key_1
    None => assert_eq(true, true)
  }
}