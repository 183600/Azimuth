test "context_with_nested_values" {
  // æµ‹è¯•åµŒå¥—Contextå€¼çš„ç®¡ç†
  
  let base_ctx = Context::empty()
  let key1 = create_key("level1")
  let key2 = create_key("level2")
  let key3 = create_key("level3")
  let key4 = create_key("level4")
  
  // åˆ›å»ºå¤šå±‚åµŒå¥—çš„context
  let ctx1 = base_ctx.with_value(key1, "value1")
  let ctx2 = ctx1.with_value(key2, "value2")
  let ctx3 = ctx2.with_value(key3, "value3")
  let ctx4 = ctx3.with_value(key4, "value4")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨
  match ctx4.get(key1) {
    Some(value) => assert_eq(value, "value1")
    None => @test.fail("Expected Some(value1)")
  }
  
  match ctx4.get(key2) {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Expected Some(value2)")
  }
  
  match ctx4.get(key3) {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Expected Some(value3)")
  }
  
  match ctx4.get(key4) {
    Some(value) => assert_eq(value, "value4")
    None => @test.fail("Expected Some(value4)")
  }
  
  // éªŒè¯åŽŸå§‹contextä¸å—å½±å“
  match base_ctx.get(key1) {
    Some(_) => @test.fail("Expected None")
    None => assert_eq(true, true)
  }
}

test "baggage_with_complex_values" {
  // æµ‹è¯•Baggageçš„å¤æ‚å€¼å¤„ç†
  
  let baggage = Baggage::empty()
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å€¼
  let baggage1 = baggage.with_entry("special.chars", "!@#$%^&*()")
  let baggage2 = baggage1.with_entry("unicode.value", "æµ‹è¯•ä¸­æ–‡ðŸš€")
  let baggage3 = baggage2.with_entry("url.encoded", "hello%20world")
  let baggage4 = baggage3.with_entry("empty.value", "")
  let baggage5 = baggage4.with_entry("spaces", "   leading and trailing   ")
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å€¼
  match baggage5.get("special.chars") {
    Some(value) => assert_eq(value, "!@#$%^&*()")
    None => @test.fail("Expected Some(value)")
  }
  
  // éªŒè¯Unicodeå€¼
  match baggage5.get("unicode.value") {
    Some(value) => {
      assert_eq(value.contains("æµ‹è¯•"), true)
      assert_eq(value.contains("ðŸš€"), true)
    }
    None => @test.fail("Expected Some(value)")
  }
  
  // éªŒè¯ç©ºå€¼
  match baggage5.get("empty.value") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected Some(value)")
  }
  
  // éªŒè¯åŒ…å«ç©ºæ ¼çš„å€¼
  match baggage5.get("spaces") {
    Some(value) => assert_eq(value, "   leading and trailing   ")
    None => @test.fail("Expected Some(value)")
  }
}