// Contextæ¨¡å—çš„Baggageæ“ä½œæµ‹è¯•ç”¨ä¾‹
test "baggage_basic_operations" {
  // æµ‹è¯•Baggageçš„åŸºæœ¬æ“ä½œ
  let empty_baggage = Baggage::empty()
  assert_eq(empty_baggage.entries.length(), 0)
  
  // æ·»åŠ å•ä¸ªæ¡ç›®
  let baggage1 = empty_baggage.with_entry("user.id", "12345")
  assert_eq(baggage1.entries.length(), 1)
  assert_eq(baggage1.entries[0].0, "user.id")
  assert_eq(baggage1.entries[0].1, "12345")
  
  // æ·»åŠ å¤šä¸ªæ¡ç›®
  let baggage2 = baggage1.with_entry("request.id", "req-67890")
  assert_eq(baggage2.entries.length(), 2)
  
  // è·å–æ¡ç›®
  match baggage2.get("user.id") {
    Some(value) => assert_eq(value, "12345")
    None => @test.fail("Test failed")
  }
  
  match baggage2.get("request.id") {
    Some(value) => assert_eq(value, "req-67890")
    None => @test.fail("Test failed")
  }
  
  // è·å–ä¸å­˜åœ¨çš„æ¡ç›®
  match baggage2.get("nonexistent.key") {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
}

test "baggage_complex_scenarios" {
  // æµ‹è¯•Baggageçš„å¤æ‚åœºæ™¯
  
  // åˆ›å»ºåŒ…å«å¤šä¸ªæ¡ç›®çš„baggage
  let baggage = Baggage::empty()
    .with_entry("service.name", "payment-service")
    .with_entry("service.version", "1.2.3")
    .with_entry("deployment.environment", "production")
    .with_entry("trace.sampled", "true")
    .with_entry("user.id", "user-123")
    .with_entry("request.id", "req-456")
    .with_entry("session.id", "session-789")
    .with_entry("correlation.id", "corr-012")
  
  assert_eq(baggage.entries.length(), 8)
  
  // éªŒè¯æ‰€æœ‰æ¡ç›®
  let expected_entries = [
    ("service.name", "payment-service"),
    ("service.version", "1.2.3"),
    ("deployment.environment", "production"),
    ("trace.sampled", "true"),
    ("user.id", "user-123"),
    ("request.id", "req-456"),
    ("session.id", "session-789"),
    ("correlation.id", "corr-012")
  ]
  
  let mut i = 0
  while i < expected_entries.length() {
    let (key, expected_value) = expected_entries[i]
    match baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Expected Some value for key: " + key)
    }
    i = i + 1
  }
}

test "baggage_edge_cases" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºå­—ç¬¦ä¸²é”®å’Œå€¼
  let baggage1 = Baggage::empty()
    .with_entry("", "")
    .with_entry("empty.value", "")
    .with_entry("", "empty.key")
  
  assert_eq(baggage1.entries.length(), 3)
  
  match baggage1.get("") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  match baggage1.get("empty.value") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  // ç‰¹æ®Šå­—ç¬¦
  let baggage2 = Baggage::empty()
    .with_entry("special.chars", "!@#$%^&*()")
    .with_entry("unicode.test", "æµ‹è¯•ä¸­æ–‡ğŸš€")
    .with_entry("spaces.key", "key with spaces")
    .with_entry("url.encoded", "key%20with%20encoding")
  
  assert_eq(baggage2.entries.length(), 4)
  
  match baggage2.get("special.chars") {
    Some(value) => assert_eq(value, "!@#$%^&*()")
    None => @test.fail("Test failed")
  }
  
  match baggage2.get("unicode.test") {
    Some(value) => assert_eq(value, "æµ‹è¯•ä¸­æ–‡ğŸš€")
    None => @test.fail("Test failed")
  }
  
  // é•¿å­—ç¬¦ä¸²
  let long_key = "a".repeat(1000)
  let long_value = "b".repeat(1000)
  let baggage3 = Baggage::empty().with_entry(long_key, long_value)
  
  assert_eq(baggage3.entries.length(), 1)
  match baggage3.get(long_key) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Test failed")
  }
}

test "context_with_baggage_integration" {
  // æµ‹è¯•Contextä¸Baggageçš„é›†æˆ
  
  let ctx = Context::empty()
  let baggage_key = create_key("baggage")
  
  // åˆ›å»ºå¤æ‚çš„baggageå­—ç¬¦ä¸²
  let baggage_value = "user.id=123,request.id=456,service.name=api"
  let ctx_with_baggage = ctx.with_value(baggage_key, baggage_value)
  
  // ä»contextä¸­è·å–baggage
  match ctx_with_baggage.get(baggage_key) {
    Some(stored_baggage) => {
      assert_eq(stored_baggage, "user.id=123,request.id=456,service.name=api")
      
      // éªŒè¯baggageå†…å®¹
      assert_eq(stored_baggage.contains("user.id=123"), true)
      assert_eq(stored_baggage.contains("request.id=456"), true)
      assert_eq(stored_baggage.contains("service.name=api"), true)
    }
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•å¤šä¸ªcontextå€¼
  let trace_id_key = create_key("trace_id")
  let span_id_key = create_key("span_id")
  
  let ctx_full = ctx_with_baggage
    .with_value(trace_id_key, "0af7651916cd43dd8448eb211c80319c")
    .with_value(span_id_key, "b7ad6b7169203331")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨
  match ctx_full.get(baggage_key) {
    Some(value) => assert_eq(value, "user.id=123,request.id=456,service.name=api")
    None => @test.fail("Test failed")
  }
  
  match ctx_full.get(trace_id_key) {
    Some(value) => assert_eq(value, "0af7651916cd43dd8448eb211c80319c")
    None => @test.fail("Test failed")
  }
  
  match ctx_full.get(span_id_key) {
    Some(value) => assert_eq(value, "b7ad6b7169203331")
    None => @test.fail("Test failed")
  }
}

test "context_key_creation_and_usage" {
  // æµ‹è¯•ContextKeyçš„åˆ›å»ºå’Œä½¿ç”¨
  
  // åˆ›å»ºä¸åŒç±»å‹çš„é”®
  let string_key = create_key("string.key")
  let numeric_key = create_key("numeric.key.123")
  let special_key = create_key("special-key_with.dots-and_underscores")
  let unicode_key = create_key("unicode.é”®.æµ‹è¯•")
  
  assert_eq(string_key.name, "string.key")
  assert_eq(numeric_key.name, "numeric.key.123")
  assert_eq(special_key.name, "special-key_with.dots-and_underscores")
  assert_eq(unicode_key.name, "unicode.é”®.æµ‹è¯•")
  
  // åœ¨contextä¸­ä½¿ç”¨è¿™äº›é”®
  let ctx = Context::empty()
  
  let ctx1 = ctx.with_value(string_key, "string value")
  let ctx2 = ctx1.with_value(numeric_key, "numeric value 123")
  let ctx3 = ctx2.with_value(special_key, "special value !@#$%")
  let ctx4 = ctx3.with_value(unicode_key, "unicode å€¼ æµ‹è¯• ğŸš€")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½èƒ½æ­£ç¡®è·å–
  match ctx4.get(string_key) {
    Some(value) => assert_eq(value, "string value")
    None => @test.fail("Test failed")
  }
  
  match ctx4.get(numeric_key) {
    Some(value) => assert_eq(value, "numeric value 123")
    None => @test.fail("Test failed")
  }
  
  match ctx4.get(special_key) {
    Some(value) => assert_eq(value, "special value !@#$%")
    None => @test.fail("Test failed")
  }
  
  match ctx4.get(unicode_key) {
    Some(value) => assert_eq(value, "unicode å€¼ æµ‹è¯• ğŸš€")
    None => @test.fail("Test failed")
  }
}

test "context_value_overwrite_behavior" {
  // æµ‹è¯•Contextå€¼çš„è¦†ç›–è¡Œä¸º
  
  let ctx = Context::empty()
  let key = create_key("test.key")
  
  // è®¾ç½®åˆå§‹å€¼
  let ctx1 = ctx.with_value(key, "initial_value")
  match ctx1.get(key) {
    Some(value) => assert_eq(value, "initial_value")
    None => @test.fail("Test failed")
  }
  
  // è¦†ç›–å€¼
  let ctx2 = ctx1.with_value(key, "overwritten_value")
  match ctx2.get(key) {
    Some(value) => assert_eq(value, "overwritten_value")
    None => @test.fail("Test failed")
  }
  
  // å†æ¬¡è¦†ç›–
  let ctx3 = ctx2.with_value(key, "final_value")
  match ctx3.get(key) {
    Some(value) => assert_eq(value, "final_value")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯contextä¸­å€¼çš„æ•°é‡
  assert_eq(ctx3.values.length(), 1) // åº”è¯¥åªæœ‰ä¸€ä¸ªå€¼ï¼Œå› ä¸ºè¦†ç›–äº†ç›¸åŒé”®çš„å€¼
}

test "context_multiple_keys_isolation" {
  // æµ‹è¯•Contextä¸­å¤šä¸ªé”®çš„éš”ç¦»
  
  let ctx = Context::empty()
  let key1 = create_key("key.one")
  let key2 = create_key("key.two")
  let key3 = create_key("key.three")
  
  // è®¾ç½®å¤šä¸ªä¸åŒçš„é”®å€¼å¯¹
  let ctx_final = ctx
    .with_value(key1, "value.one")
    .with_value(key2, "value.two")
    .with_value(key3, "value.three")
  
  // éªŒè¯æ¯ä¸ªé”®éƒ½èƒ½è·å–åˆ°æ­£ç¡®çš„å€¼
  match ctx_final.get(key1) {
    Some(value) => assert_eq(value, "value.one")
    None => @test.fail("Test failed")
  }
  
  match ctx_final.get(key2) {
    Some(value) => assert_eq(value, "value.two")
    None => @test.fail("Test failed")
  }
  
  match ctx_final.get(key3) {
    Some(value) => assert_eq(value, "value.three")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯contextä¸­å€¼çš„æ€»æ•°
  assert_eq(ctx_final.values.length(), 3)
}