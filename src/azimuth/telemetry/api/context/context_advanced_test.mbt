// Contextæ¨¡å—å¤æ‚åœºæ™¯æµ‹è¯•ç”¨ä¾‹
test "context_multiple_values_and_overrides" {
  let ctx = Context::empty()
  let key1 = create_key("user.id")
  let key2 = create_key("request.id")
  let key3 = create_key("trace.id")
  
  // æ·»åŠ å¤šä¸ªå€¼
  let ctx1 = ctx.with_value(key1, "user123")
  let ctx2 = ctx1.with_value(key2, "req456")
  let ctx3 = ctx2.with_value(key3, "trace789")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨
  match ctx3.get(key1) {
    Some(value) => assert_eq(value, "user123")
    None => @test.fail("Expected user.id to be set")
  }
  
  match ctx3.get(key2) {
    Some(value) => assert_eq(value, "req456")
    None => @test.fail("Expected request.id to be set")
  }
  
  match ctx3.get(key3) {
    Some(value) => assert_eq(value, "trace789")
    None => @test.fail("Expected trace.id to be set")
  }
  
  // æµ‹è¯•è¦†ç›–å€¼
  let ctx4 = ctx3.with_value(key1, "user456")
  match ctx4.get(key1) {
    Some(value) => assert_eq(value, "user456")
    None => @test.fail("Expected user.id to be overridden")
  }
  
  // éªŒè¯å…¶ä»–å€¼æœªè¢«å½±å“
  match ctx4.get(key2) {
    Some(value) => assert_eq(value, "req456")
    None => @test.fail("Expected request.id to remain unchanged")
  }
}

test "context_with_special_characters" {
  let ctx = Context::empty()
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = create_key("special/key/with/special.chars")
  let ctx1 = ctx.with_value(special_key, "ç‰¹æ®Šå€¼!@#$%^&*()")
  
  match ctx1.get(special_key) {
    Some(value) => assert_eq(value, "ç‰¹æ®Šå€¼!@#$%^&*()")
    None => @test.fail("Expected special key to be set")
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_key = create_key("Unicodeé”®æµ‹è¯•ğŸš€")
  let ctx2 = ctx1.with_value(unicode_key, "Unicodeå€¼æµ‹è¯•ğŸŒŸ")
  
  match ctx2.get(unicode_key) {
    Some(value) => assert_eq(value, "Unicodeå€¼æµ‹è¯•ğŸŒŸ")
    None => @test.fail("Expected Unicode key to be set")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_key = create_key("")
  let ctx3 = ctx2.with_value(empty_key, "")
  
  match ctx3.get(empty_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty key to be set")
  }
}

test "context_nonexistent_keys" {
  let ctx = Context::empty()
  let existing_key = create_key("existing.key")
  let nonexistent_key1 = create_key("nonexistent.key")
  let nonexistent_key2 = create_key("another.nonexistent.key")
  
  // åªè®¾ç½®ä¸€ä¸ªé”®
  let ctx1 = ctx.with_value(existing_key, "value")
  
  // éªŒè¯å­˜åœ¨çš„é”®
  match ctx1.get(existing_key) {
    Some(value) => assert_eq(value, "value")
    None => @test.fail("Expected existing.key to be set")
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®è¿”å›None
  match ctx1.get(nonexistent_key1) {
    Some(_) => @test.fail("Expected nonexistent.key to return None")
    None => assert_eq(true, true)
  }
  
  match ctx1.get(nonexistent_key2) {
    Some(_) => @test.fail("Expected another.nonexistent.key to return None")
    None => assert_eq(true, true)
  }
}

test "baggage_complex_operations" {
  let baggage = Baggage::empty()
  
  // æ·»åŠ å¤šä¸ªæ¡ç›®
  let baggage1 = baggage.with_entry("user.id", "user123")
  let baggage2 = baggage1.with_entry("request.id", "req456")
  let baggage3 = baggage2.with_entry("trace.id", "trace789")
  
  // éªŒè¯æ‰€æœ‰æ¡ç›®
  match baggage3.get("user.id") {
    Some(value) => assert_eq(value, "user123")
    None => @test.fail("Expected user.id to be set")
  }
  
  match baggage3.get("request.id") {
    Some(value) => assert_eq(value, "req456")
    None => @test.fail("Expected request.id to be set")
  }
  
  match baggage3.get("trace.id") {
    Some(value) => assert_eq(value, "trace789")
    None => @test.fail("Expected trace.id to be set")
  }
  
  // æµ‹è¯•è¦†ç›–æ¡ç›®
  let baggage4 = baggage3.with_entry("user.id", "user456")
  match baggage4.get("user.id") {
    Some(value) => assert_eq(value, "user456")
    None => @test.fail("Expected user.id to be overridden")
  }
  
  // éªŒè¯å…¶ä»–æ¡ç›®æœªè¢«å½±å“
  match baggage4.get("request.id") {
    Some(value) => assert_eq(value, "req456")
    None => @test.fail("Expected request.id to remain unchanged")
  }
}

test "baggage_with_special_characters" {
  let baggage = Baggage::empty()
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let baggage1 = baggage.with_entry("special/key/with/special.chars", "ç‰¹æ®Šå€¼!@#$%^&*()")
  
  match baggage1.get("special/key/with/special.chars") {
    Some(value) => assert_eq(value, "ç‰¹æ®Šå€¼!@#$%^&*()")
    None => @test.fail("Expected special key to be set")
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let baggage2 = baggage1.with_entry("Unicodeé”®æµ‹è¯•ğŸš€", "Unicodeå€¼æµ‹è¯•ğŸŒŸ")
  
  match baggage2.get("Unicodeé”®æµ‹è¯•ğŸš€") {
    Some(value) => assert_eq(value, "Unicodeå€¼æµ‹è¯•ğŸŒŸ")
    None => @test.fail("Expected Unicode key to be set")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let baggage3 = baggage2.with_entry("", "")
  
  match baggage3.get("") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty key to be set")
  }
}

test "context_and_baggage_integration" {
  let ctx = Context::empty()
  let baggage = Baggage::empty()
  
  // åœ¨Contextä¸­è®¾ç½®å€¼
  let ctx_key = create_key("ctx.value")
  let ctx1 = ctx.with_value(ctx_key, "context_value")
  
  // åœ¨Baggageä¸­è®¾ç½®å€¼
  let baggage1 = baggage.with_entry("baggage.value", "baggage_value")
  
  // éªŒè¯å®ƒä»¬æ˜¯ç‹¬ç«‹çš„
  match ctx1.get(ctx_key) {
    Some(value) => assert_eq(value, "context_value")
    None => @test.fail("Expected context value to be set")
  }
  
  match baggage1.get("baggage.value") {
    Some(value) => assert_eq(value, "baggage_value")
    None => @test.fail("Expected baggage value to be set")
  }
  
  // éªŒè¯Contextä¸­æ— æ³•è®¿é—®Baggageå€¼
  let baggage_key = create_key("baggage.value")
  match ctx1.get(baggage_key) {
    Some(_) => @test.fail("Expected baggage value to not be accessible from context")
    None => assert_eq(true, true)
  }
}

test "context_key_collisions" {
  let ctx = Context::empty()
  
  // åˆ›å»ºç›¸åŒåç§°çš„é”®
  let key1 = create_key("same.name")
  let key2 = create_key("same.name")
  
  // ä½¿ç”¨ç¬¬ä¸€ä¸ªé”®è®¾ç½®å€¼
  let ctx1 = ctx.with_value(key1, "value1")
  
  // ä½¿ç”¨ç¬¬äºŒä¸ªé”®è®¾ç½®å€¼
  let ctx2 = ctx1.with_value(key2, "value2")
  
  // éªŒè¯å€¼è¢«è¦†ç›–ï¼ˆå› ä¸ºé”®åç§°ç›¸åŒï¼‰
  match ctx2.get(key1) {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Expected value to be overridden")
  }
  
  match ctx2.get(key2) {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Expected value to be overridden")
  }
}

test "context_chained_operations" {
  let ctx = Context::empty()
  
  // é“¾å¼æ“ä½œ
  let ctx1 = ctx
    .with_value(create_key("step1"), "value1")
    .with_value(create_key("step2"), "value2")
    .with_value(create_key("step3"), "value3")
    .with_value(create_key("step4"), "value4")
    .with_value(create_key("step5"), "value5")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨
  match ctx1.get(create_key("step1")) {
    Some(value) => assert_eq(value, "value1")
    None => @test.fail("Expected step1 to be set")
  }
  
  match ctx1.get(create_key("step2")) {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Expected step2 to be set")
  }
  
  match ctx1.get(create_key("step3")) {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Expected step3 to be set")
  }
  
  match ctx1.get(create_key("step4")) {
    Some(value) => assert_eq(value, "value4")
    None => @test.fail("Expected step4 to be set")
  }
  
  match ctx1.get(create_key("step5")) {
    Some(value) => assert_eq(value, "value5")
    None => @test.fail("Expected step5 to be set")
  }
}