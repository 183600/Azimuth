// Contextæ¨¡å—é«˜çº§æµ‹è¯•ç”¨ä¾‹
test "context_complex_operations" {
  let base_context = Context::empty()
  let key1 = create_key("user.id")
  let key2 = create_key("request.id")
  let key3 = create_key("session.id")
  
  // é“¾å¼æ“ä½œæµ‹è¯•
  let context1 = base_context.with_value(key1, "user-12345")
  let context2 = context1.with_value(key2, "req-67890")
  let context3 = context2.with_value(key3, "sess-abcdef")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨
  match context3.get(key1) {
    Some(value) => assert_eq(value, "user-12345")
    None => @test.fail("Test failed")
  }
  
  match context3.get(key2) {
    Some(value) => assert_eq(value, "req-67890")
    None => @test.fail("Test failed")
  }
  
  match context3.get(key3) {
    Some(value) => assert_eq(value, "sess-abcdef")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  let missing_key = create_key("missing.key")
  match context3.get(missing_key) {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
}

test "context_with_unicode_and_special_characters" {
  let context = Context::empty()
  
  // æµ‹è¯•Unicodeé”®å€¼
  let unicode_key = create_key("ç”¨æˆ·ID")
  let context_with_unicode = context.with_value(unicode_key, "ç”¨æˆ·-12345")
  
  match context_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, "ç”¨æˆ·-12345")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å€¼
  let special_key = create_key("special!@#$%^&*()")
  let context_with_special = context_with_unicode.with_value(special_key, "value!@#$%^&*()")
  
  match context_with_special.get(special_key) {
    Some(value) => assert_eq(value, "value!@#$%^&*()")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•emoji
  let emoji_key = create_key("ğŸš€rocket")
  let context_with_emoji = context_with_special.with_value(emoji_key, "ğŸ”¥fire")
  
  match context_with_emoji.get(emoji_key) {
    Some(value) => assert_eq(value, "ğŸ”¥fire")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_key = create_key("")
  let context_with_empty = context_with_emoji.with_value(empty_key, "")
  
  match context_with_empty.get(empty_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
}

test "baggage_complex_operations" {
  let base_baggage = Baggage::empty()
  
  // æ·»åŠ å¤šä¸ªæ¡ç›®
  let baggage1 = base_baggage.with_entry("user.id", "user-12345")
  let baggage2 = baggage1.with_entry("request.id", "req-67890")
  let baggage3 = baggage2.with_entry("session.id", "sess-abcdef")
  let baggage4 = baggage3.with_entry("trace.id", "trace-123456789")
  let baggage5 = baggage4.with_entry("service.name", "auth-service")
  
  // éªŒè¯æ‰€æœ‰æ¡ç›®
  match baggage5.get("user.id") {
    Some(value) => assert_eq(value, "user-12345")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("request.id") {
    Some(value) => assert_eq(value, "req-67890")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("session.id") {
    Some(value) => assert_eq(value, "sess-abcdef")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("trace.id") {
    Some(value) => assert_eq(value, "trace-123456789")
    None => @test.fail("Test failed")
  }
  
  match baggage5.get("service.name") {
    Some(value) => assert_eq(value, "auth-service")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  match baggage5.get("missing.key") {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
}

test "context_and_baggage_integration" {
  let context = Context::empty()
  let baggage = Baggage::empty()
  
  // åœ¨Contextä¸­å­˜å‚¨ä¸Šä¸‹æ–‡ä¿¡æ¯
  let trace_key = create_key("trace.id")
  let span_key = create_key("span.id")
  
  let context_with_trace = context.with_value(trace_key, "trace-123456789")
  let context_with_span = context_with_trace.with_value(span_key, "span-987654321")
  
  // åœ¨Baggageä¸­å­˜å‚¨ä¼ æ’­ä¿¡æ¯
  let baggage_with_user = baggage.with_entry("user.id", "user-12345")
  let baggage_with_session = baggage_with_user.with_entry("session.id", "sess-abcdef")
  
  // éªŒè¯Contextå’ŒBaggageçš„ç‹¬ç«‹æ€§
  match context_with_span.get(trace_key) {
    Some(value) => assert_eq(value, "trace-123456789")
    None => @test.fail("Test failed")
  }
  
  match baggage_with_session.get("user.id") {
    Some(value) => assert_eq(value, "user-12345")
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•å¤æ‚åœºæ™¯ï¼šContextå­˜å‚¨Baggageä¿¡æ¯
  let baggage_key = create_key("baggage")
  let context_with_baggage = context_with_span.with_value(
    baggage_key, 
    "user.id=user-12345,session.id=sess-abcdef"
  )
  
  match context_with_baggage.get(baggage_key) {
    Some(value) => {
      assert_eq(value, "user.id=user-12345,session.id=sess-abcdef")
      
      // æ¨¡æ‹Ÿè§£æbaggageå­—ç¬¦ä¸²
      let parts = value",".split_to_string()
      assert_eq(parts.length(), 2)
      assert_eq(parts[0], "user.id=user-12345")
      assert_eq(parts[1], "session.id=sess-abcdef")
    }
    None => @test.fail("Test failed")
  }
}

test "context_edge_cases_and_boundary_conditions" {
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶
  
  // ç©ºContextæ“ä½œ
  let empty_context = Context::empty()
  let empty_key = create_key("")
  
  let context_with_empty_key = empty_context.with_value(empty_key, "")
  match context_with_empty_key.get(empty_key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  // é•¿å­—ç¬¦ä¸²æµ‹è¯•
  let long_string = "a".repeat(10000)
  let long_key = create_key("long.key")
  
  let context_with_long = context_with_empty_key.with_value(long_key, long_string)
  match context_with_long.get(long_key) {
    Some(value) => assert_eq(value, long_string)
    None => @test.fail("Test failed")
  }
  
  // ç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?~`"
  let special_key = create_key("special.chars")
  
  let context_with_special = context_with_long.with_value(special_key, special_chars)
  match context_with_special.get(special_key) {
    Some(value) => assert_eq(value, special_chars)
    None => @test.fail("Test failed")
  }
  
  // Unicodeæµ‹è¯•
  let unicode_string = "Unicodeæµ‹è¯•å­—ç¬¦ä¸²ğŸš€ğŸ”¥ğŸ’¯"
  let unicode_key = create_key("unicode.test")
  
  let context_with_unicode = context_with_special.with_value(unicode_key, unicode_string)
  match context_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_string)
    None => @test.fail("Test failed")
  }
}

test "baggage_edge_cases_and_boundary_conditions" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæ¡ä»¶
  
  // ç©ºBaggageæ“ä½œ
  let empty_baggage = Baggage::empty()
  
  let baggage_with_empty_key = empty_baggage.with_entry("", "")
  match baggage_with_empty_key.get("") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  // é•¿å­—ç¬¦ä¸²æµ‹è¯•
  let long_key = "a".repeat(1000)
  let long_value = "b".repeat(1000)
  
  let baggage_with_long = baggage_with_empty_key.with_entry(long_key, long_value)
  match baggage_with_long.get(long_key) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Test failed")
  }
  
  // ç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  let special_key = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_value = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  
  let baggage_with_special = baggage_with_long.with_entry(special_key, special_value)
  match baggage_with_special.get(special_key) {
    Some(value) => assert_eq(value, special_value)
    None => @test.fail("Test failed")
  }
  
  // Unicodeæµ‹è¯•
  let unicode_key = "Unicodeé”®ğŸš€"
  let unicode_value = "Unicodeå€¼ğŸ”¥"
  
  let baggage_with_unicode = baggage_with_special.with_entry(unicode_key, unicode_value)
  match baggage_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_value)
    None => @test.fail("Test failed")
  }
  
  // åŒ…å«ç­‰å·å’Œé€—å·çš„å€¼ï¼ˆè¿™äº›æ˜¯baggageçš„ç‰¹æ®Šå­—ç¬¦ï¼‰
  let complex_key = "complex.key"
  let complex_value = "value=with=equals,and,commas"
  
  let baggage_with_complex = baggage_with_unicode.with_entry(complex_key, complex_value)
  match baggage_with_complex.get(complex_key) {
    Some(value) => assert_eq(value, complex_value)
    None => @test.fail("Test failed")
  }
}

test "context_performance_and_large_scale" {
  // æµ‹è¯•å¤§è§„æ¨¡Contextæ“ä½œçš„æ€§èƒ½
  
  let base_context = Context::empty()
  
  // åˆ›å»ºåŒ…å«å¤§é‡é”®å€¼å¯¹çš„Context
  let mut context = base_context
  let mut i = 0
  while i < 1000 {
    let key = create_key("key" + i.to_string())
    context = context.with_value(key, "value" + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯éšæœºè®¿é—®
  match context.get(create_key("key0")) {
    Some(value) => assert_eq(value, "value0")
    None => @test.fail("Test failed")
  }
  
  match context.get(create_key("key500")) {
    Some(value) => assert_eq(value, "value500")
    None => @test.fail("Test failed")
  }
  
  match context.get(create_key("key999")) {
    Some(value) => assert_eq(value, "value999")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®
  match context.get(create_key("key1000")) {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
}

test "baggage_performance_and_large_scale" {
  // æµ‹è¯•å¤§è§„æ¨¡Baggageæ“ä½œçš„æ€§èƒ½
  
  let base_baggage = Baggage::empty()
  
  // åˆ›å»ºåŒ…å«å¤§é‡æ¡ç›®çš„Baggage
  let mut baggage = base_baggage
  let mut i = 0
  while i < 1000 {
    baggage = baggage.with_entry("key" + i.to_string(), "value" + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯éšæœºè®¿é—®
  match baggage.get("key0") {
    Some(value) => assert_eq(value, "value0")
    None => @test.fail("Test failed")
  }
  
  match baggage.get("key500") {
    Some(value) => assert_eq(value, "value500")
    None => @test.fail("Test failed")
  }
  
  match baggage.get("key999") {
    Some(value) => assert_eq(value, "value999")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®
  match baggage.get("key1000") {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
}