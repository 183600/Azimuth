test "baggage_edge_cases" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæƒ…å†µ
  
  let empty_baggage = Baggage::empty()
  
  // æµ‹è¯•ç©ºBaggageçš„æ“ä½œ
  match empty_baggage.get("non.existent") {
    Some(_) => @test.fail("Expected None for empty baggage")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•å¤§å€¼
  let large_value = "è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„å€¼ï¼Œç”¨æ¥æµ‹è¯•Baggageåœ¨å¤„ç†å¤§å€¼æ—¶çš„è¡Œä¸ºã€‚".repeat(50)
  let baggage_with_large = empty_baggage.with_entry("large.key", large_value)
  
  match baggage_with_large.get("large.key") {
    Some(value) => assert_eq(value.length(), large_value.length())
    None => @test.fail("Expected Some(value)")
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = "special.key!@#$%^&*()"
  let special_value = "special_value!@#$%^&*()"
  let baggage_with_special = empty_baggage.with_entry(special_key, special_value)
  
  match baggage_with_special.get(special_key) {
    Some(value) => assert_eq(value, special_value)
    None => @test.fail("Expected Some(value)")
  }
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = "æµ‹è¯•é”®ğŸš€"
  let unicode_value = "æµ‹è¯•å€¼ğŸ‰"
  let baggage_with_unicode = empty_baggage.with_entry(unicode_key, unicode_value)
  
  match baggage_with_unicode.get(unicode_key) {
    Some(value) => assert_eq(value, unicode_value)
    None => @test.fail("Expected Some(value)")
  }
  
  // æµ‹è¯•è¦†ç›–å€¼
  let baggage1 = empty_baggage.with_entry("test.key", "value1")
  let baggage2 = baggage1.with_entry("test.key", "value2")
  
  match baggage2.get("test.key") {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Expected Some(value)")
  }
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  let baggage_empty_key = empty_baggage.with_entry("", "empty.key.value")
  match baggage_empty_key.get("") {
    Some(value) => assert_eq(value, "empty.key.value")
    None => @test.fail("Expected Some(value)")
  }
  
  let baggage_empty_value = empty_baggage.with_entry("empty.value.key", "")
  match baggage_empty_value.get("empty.value.key") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected Some(value)")
  }
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„é”®å’Œå€¼
  let baggage_spaces = empty_baggage.with_entry("key with spaces", "value with spaces")
  match baggage_spaces.get("key with spaces") {
    Some(value) => assert_eq(value, "value with spaces")
    None => @test.fail("Expected Some(value)")
  }
  
  // æµ‹è¯•æ•°å­—é”®ï¼ˆè™½ç„¶ç±»å‹æ˜¯Stringï¼Œä½†å¯ä»¥åŒ…å«æ•°å­—ï¼‰
  let baggage_numeric_key = empty_baggage.with_entry("123", "numeric.key.value")
  match baggage_numeric_key.get("123") {
    Some(value) => assert_eq(value, "numeric.key.value")
    None => @test.fail("Expected Some(value)")
  }
  
  // æµ‹è¯•å¤§é‡æ¡ç›®
  let mut baggage_multi = empty_baggage
  let mut i = 0
  while i < 30 {
    baggage_multi = baggage_multi.with_entry("key." + i.to_string(), "value." + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯ä¸€äº›æ¡ç›®
  match baggage_multi.get("key.0") {
    Some(value) => assert_eq(value, "value.0")
    None => @test.fail("Expected Some(value)")
  }
  
  match baggage_multi.get("key.29") {
    Some(value) => assert_eq(value, "value.29")
    None => @test.fail("Expected Some(value)")
  }
  
  match baggage_multi.get("key.30") {
    Some(_) => @test.fail("Expected None for non-existent key")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®ŠHTTPå¤´çš„é”®å€¼å¯¹
  let baggage_headers = empty_baggage
    .with_entry("user-id", "12345")
    .with_entry("session-id", "abcdef123456")
    .with_entry("request-id", "req-789")
    .with_entry("trace-id", "trace-abc123")
    .with_entry("correlation-id", "corr-def456")
  
  match baggage_headers.get("user-id") {
    Some(value) => assert_eq(value, "12345")
    None => @test.fail("Expected Some(value)")
  }
  
  match baggage_headers.get("correlation-id") {
    Some(value) => assert_eq(value, "corr-def456")
    None => @test.fail("Expected Some(value)")
  }
}