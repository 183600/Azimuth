// Contextæ¨¡å—ContextKeyè¯¦ç»†æµ‹è¯•ç”¨ä¾‹
test "context_key_creation_and_properties" {
  // æµ‹è¯•ContextKeyçš„åŸºæœ¬åˆ›å»ºå’Œå±æ€§
  let simple_key = create_key("simple.key")
  let numeric_key = create_key("key123")
  let symbolic_key = create_key("key_with_underscores_and-dashes")
  
  // éªŒè¯keyåç§°
  assert_eq(simple_key.name, "simple.key")
  assert_eq(numeric_key.name, "key123")
  assert_eq(symbolic_key.name, "key_with_underscores_and-dashes")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²key
  let empty_key = create_key("")
  assert_eq(empty_key.name, "")
  
  // æµ‹è¯•å•å­—ç¬¦key
  let single_char_key = create_key("x")
  assert_eq(single_char_key.name, "x")
  
  // æµ‹è¯•é•¿keyåç§°
  let long_key_name = "this.is.a.very.long.key.name.that.tests.the.handling.of.extremely.long.identifiers.in.the.context.system"
  let long_key = create_key(long_key_name)
  assert_eq(long_key.name, long_key_name)
}

test "context_key_with_special_characters" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„keyåç§°
  
  // Unicodeå­—ç¬¦
  let unicode_key = create_key("Unicodeé”®æµ‹è¯•ğŸš€")
  assert_eq(unicode_key.name, "Unicodeé”®æµ‹è¯•ğŸš€")
  
  // ç‰¹æ®Šç¬¦å·
  let symbols_key = create_key("key!@#$%^&*()_+-={}[]|\\:;\"'<>?,./")
  assert_eq(symbols_key.name, "key!@#$%^&*()_+-={}[]|\\:;\"'<>?,./")
  
  // ç©ºæ ¼å’Œåˆ¶è¡¨ç¬¦
  let spaces_key = create_key("key with spaces")
  assert_eq(spaces_key.name, "key with spaces")
  
  let tab_key = create_key("key\twith\ttabs")
  assert_eq(tab_key.name, "key\twith\ttabs")
  
  // æ¢è¡Œç¬¦ï¼ˆè™½ç„¶åœ¨å®é™…ä½¿ç”¨ä¸­ä¸æ¨èï¼‰
  let newline_key = create_key("key\nwith\nnewlines")
  assert_eq(newline_key.name, "key\nwith\nnewlines")
  
  // ç‚¹å·å¼€å¤´çš„key
  let dot_prefix_key = create_key(".hidden.key")
  assert_eq(dot_prefix_key.name, ".hidden.key")
  
  // æ–œæ å’Œåæ–œæ 
  let slash_key = create_key("path/key/with/slashes")
  assert_eq(slash_key.name, "path/key/with/slashes")
  
  let backslash_key = create_key("path\\key\\with\\backslashes")
  assert_eq(backslash_key.name, "path\\key\\with\\backslashes")
}

test "context_key_in_context_operations" {
  // æµ‹è¯•ContextKeyåœ¨Contextæ“ä½œä¸­çš„ä½¿ç”¨
  
  let ctx = Context::empty()
  
  // åˆ›å»ºå„ç§ç±»å‹çš„key
  let user_key = create_key("user.id")
  let session_key = create_key("session.token")
  let request_key = create_key("request.id")
  let trace_key = create_key("trace.id")
  let span_key = create_key("span.id")
  let empty_key = create_key("")
  let special_key = create_key("special!@#$%^&*()")
  
  // ä½¿ç”¨keyå­˜å‚¨å’Œè·å–å€¼
  let ctx1 = ctx.with_value(user_key, "user-12345")
  let ctx2 = ctx1.with_value(session_key, "session-abcdef")
  let ctx3 = ctx2.with_value(request_key, "req-67890")
  let ctx4 = ctx3.with_value(trace_key, "trace-111111")
  let ctx5 = ctx4.with_value(span_key, "span-222222")
  let ctx6 = ctx5.with_value(empty_key, "empty.key.value")
  let ctx7 = ctx6.with_value(special_key, "special.value")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½èƒ½æ­£ç¡®è·å–
  match ctx7.get(user_key) {
    Some(value) => assert_eq(value, "user-12345")
    None => @test.fail("Expected user.id value")
  }
  
  match ctx7.get(session_key) {
    Some(value) => assert_eq(value, "session-abcdef")
    None => @test.fail("Expected session.token value")
  }
  
  match ctx7.get(request_key) {
    Some(value) => assert_eq(value, "req-67890")
    None => @test.fail("Expected request.id value")
  }
  
  match ctx7.get(trace_key) {
    Some(value) => assert_eq(value, "trace-111111")
    None => @test.fail("Expected trace.id value")
  }
  
  match ctx7.get(span_key) {
    Some(value) => assert_eq(value, "span-222222")
    None => @test.fail("Expected span.id value")
  }
  
  match ctx7.get(empty_key) {
    Some(value) => assert_eq(value, "empty.key.value")
    None => @test.fail("Expected empty key value")
  }
  
  match ctx7.get(special_key) {
    Some(value) => assert_eq(value, "special.value")
    None => @test.fail("Expected special key value")
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„key
  let non_existent_key = create_key("non.existent.key")
  match ctx7.get(non_existent_key) {
    Some(_) => @test.fail("Expected None for non-existent key")
    None => assert_eq(true, true)
  }
}

test "context_key_value_overwrite" {
  // æµ‹è¯•ä½¿ç”¨ç›¸åŒkeyè¦†ç›–å€¼
  
  let ctx = Context::empty()
  let key = create_key("overwrite.test")
  
  // åˆå§‹å€¼
  let ctx1 = ctx.with_value(key, "initial.value")
  match ctx1.get(key) {
    Some(value) => assert_eq(value, "initial.value")
    None => @test.fail("Expected initial value")
  }
  
  // ç¬¬ä¸€æ¬¡è¦†ç›–
  let ctx2 = ctx1.with_value(key, "first.overwrite")
  match ctx2.get(key) {
    Some(value) => assert_eq(value, "first.overwrite")
    None => @test.fail("Expected first overwrite value")
  }
  
  // ç¬¬äºŒæ¬¡è¦†ç›–
  let ctx3 = ctx2.with_value(key, "second.overwrite")
  match ctx3.get(key) {
    Some(value) => assert_eq(value, "second.overwrite")
    None => @test.fail("Expected second overwrite value")
  }
  
  // è¦†ç›–ä¸ºç©ºå­—ç¬¦ä¸²
  let ctx4 = ctx3.with_value(key, "")
  match ctx4.get(key) {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty string value")
  }
  
  // è¦†ç›–ä¸ºç‰¹æ®Šå­—ç¬¦
  let ctx5 = ctx4.with_value(key, "special!@#$%^&*()")
  match ctx5.get(key) {
    Some(value) => assert_eq(value, "special!@#$%^&*()")
    None => @test.fail("Expected special characters value")
  }
  
  // è¦†ç›–ä¸ºé•¿å­—ç¬¦ä¸²
  let long_value = "this.is.a.very.long.value.that.tests.the.context.system's.ability.to.handle.large.strings.without.any.issues.or.performance.problems"
  let ctx6 = ctx5.with_value(key, long_value)
  match ctx6.get(key) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Expected long string value")
  }
}

test "context_key_with_similar_names" {
  // æµ‹è¯•åç§°ç›¸ä¼¼ä½†ä¸åŒçš„key
  
  let ctx = Context::empty()
  
  // åˆ›å»ºåç§°ç›¸ä¼¼çš„key
  let key1 = create_key("user.id")
  let key2 = create_key("user_id")  // ä¸‹åˆ’çº¿ vs ç‚¹å·
  let key3 = create_key("user.id ")  // æœ«å°¾æœ‰ç©ºæ ¼
  let key4 = create_key(" user.id")  // å¼€å¤´æœ‰ç©ºæ ¼
  let key5 = create_key("USER.ID")  // å¤§å†™
  let key6 = create_key("user.Id")  // éƒ¨åˆ†å¤§å†™
  
  // ä¸ºæ¯ä¸ªkeyè®¾ç½®ä¸åŒçš„å€¼
  let ctx1 = ctx.with_value(key1, "value1")
  let ctx2 = ctx1.with_value(key2, "value2")
  let ctx3 = ctx2.with_value(key3, "value3")
  let ctx4 = ctx3.with_value(key4, "value4")
  let ctx5 = ctx4.with_value(key5, "value5")
  let ctx6 = ctx5.with_value(key6, "value6")
  
  // éªŒè¯æ¯ä¸ªkeyéƒ½æœ‰ç‹¬ç«‹çš„å€¼
  match ctx6.get(key1) {
    Some(value) => assert_eq(value, "value1")
    None => @test.fail("Expected value1 for user.id")
  }
  
  match ctx6.get(key2) {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Expected value2 for user_id")
  }
  
  match ctx6.get(key3) {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Expected value3 for 'user.id '")
  }
  
  match ctx6.get(key4) {
    Some(value) => assert_eq(value, "value4")
    None => @test.fail("Expected value4 for ' user.id'")
  }
  
  match ctx6.get(key5) {
    Some(value) => assert_eq(value, "value5")
    None => @test.fail("Expected value5 for USER.ID")
  }
  
  match ctx6.get(key6) {
    Some(value) => assert_eq(value, "value6")
    None => @test.fail("Expected value6 for user.Id")
  }
}

test "context_key_in_complex_scenarios" {
  // æµ‹è¯•ContextKeyåœ¨å¤æ‚åœºæ™¯ä¸­çš„ä½¿ç”¨
  
  let ctx = Context::empty()
  
  // æ¨¡æ‹ŸHTTPè¯·æ±‚çš„context
  let http_method_key = create_key("http.method")
  let http_url_key = create_key("http.url")
  let http_user_agent_key = create_key("http.user_agent")
  let http_headers_key = create_key("http.headers")
  
  // æ¨¡æ‹Ÿç”¨æˆ·ä¿¡æ¯çš„context
  let user_id_key = create_key("user.id")
  let user_name_key = create_key("user.name")
  let user_email_key = create_key("user.email")
  let user_tier_key = create_key("user.tier")
  
  // æ¨¡æ‹Ÿè¿½è¸ªä¿¡æ¯çš„context
  let trace_id_key = create_key("trace.id")
  let span_id_key = create_key("span.id")
  let parent_span_id_key = create_key("parent.span.id")
  let trace_flags_key = create_key("trace.flags")
  
  // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘çš„context
  let operation_key = create_key("operation")
  let service_name_key = create_key("service.name")
  let service_version_key = create_key("service.version")
  let correlation_id_key = create_key("correlation.id")
  
  // æ„å»ºå¤æ‚çš„context
  let complex_ctx = ctx
    // HTTPç›¸å…³ä¿¡æ¯
    .with_value(http_method_key, "POST")
    .with_value(http_url_key, "https://api.example.com/v1/payments")
    .with_value(http_user_agent_key, "PaymentClient/3.2.1")
    .with_value(http_headers_key, "Authorization: Bearer token123, Content-Type: application/json")
    // ç”¨æˆ·ä¿¡æ¯
    .with_value(user_id_key, "user-12345")
    .with_value(user_name_key, "John Doe")
    .with_value(user_email_key, "john.doe@example.com")
    .with_value(user_tier_key, "premium")
    // è¿½è¸ªä¿¡æ¯
    .with_value(trace_id_key, "trace-abcdef-123456")
    .with_value(span_id_key, "span-789012-345678")
    .with_value(parent_span_id_key, "span-parent-111111")
    .with_value(trace_flags_key, "01")
    // ä¸šåŠ¡é€»è¾‘ä¿¡æ¯
    .with_value(operation_key, "payment.process")
    .with_value(service_name_key, "payment-service")
    .with_value(service_version_key, "3.2.1")
    .with_value(correlation_id_key, "corr-987654-321098")
  
  // éªŒè¯æ‰€æœ‰ä¿¡æ¯éƒ½èƒ½æ­£ç¡®è·å–
  match complex_ctx.get(http_method_key) {
    Some(value) => assert_eq(value, "POST")
    None => @test.fail("Expected HTTP method")
  }
  
  match complex_ctx.get(http_url_key) {
    Some(value) => assert_eq(value, "https://api.example.com/v1/payments")
    None => @test.fail("Expected HTTP URL")
  }
  
  match complex_ctx.get(user_id_key) {
    Some(value) => assert_eq(value, "user-12345")
    None => @test.fail("Expected user ID")
  }
  
  match complex_ctx.get(user_name_key) {
    Some(value) => assert_eq(value, "John Doe")
    None => @test.fail("Expected user name")
  }
  
  match complex_ctx.get(trace_id_key) {
    Some(value) => assert_eq(value, "trace-abcdef-123456")
    None => @test.fail("Expected trace ID")
  }
  
  match complex_ctx.get(operation_key) {
    Some(value) => assert_eq(value, "payment.process")
    None => @test.fail("Expected operation")
  }
  
  match complex_ctx.get(correlation_id_key) {
    Some(value) => assert_eq(value, "corr-987654-321098")
    None => @test.fail("Expected correlation ID")
  }
  
  // æµ‹è¯•åœ¨å¤æ‚contextä¸­æ·»åŠ æ–°çš„key-valueå¯¹
  let new_key = create_key("new.added.key")
  let updated_ctx = complex_ctx.with_value(new_key, "new.value")
  
  match updated_ctx.get(new_key) {
    Some(value) => assert_eq(value, "new.value")
    None => @test.fail("Expected new added value")
  }
  
  // éªŒè¯åŸæœ‰å€¼ä¸å—å½±å“
  match updated_ctx.get(user_id_key) {
    Some(value) => assert_eq(value, "user-12345")
    None => @test.fail("Original user ID should not be affected")
  }
}

test "context_key_edge_cases_and_boundary_conditions" {
  // æµ‹è¯•ContextKeyçš„è¾¹ç•Œæ¡ä»¶å’Œç‰¹æ®Šæƒ…å†µ
  
  let ctx = Context::empty()
  
  // æµ‹è¯•æé•¿çš„keyåç§°
  let mut very_long_key_name = ""
  let mut i = 0
  while i < 1000 {
    very_long_key_name = very_long_key_name + "a"
    i = i + 1
  }
  let very_long_key = create_key(very_long_key_name)
  assert_eq(very_long_key.name, very_long_key_name)
  
  // æµ‹è¯•åŒ…å«å„ç§æ§åˆ¶å­—ç¬¦çš„key
  let control_chars_key = create_key("key\u0000with\u0001control\u0002chars")
  assert_eq(control_chars_key.name, "key\u0000with\u0001control\u0002chars")
  
  // æµ‹è¯•åªåŒ…å«æ•°å­—çš„key
  let numbers_only_key = create_key("123456789")
  assert_eq(numbers_only_key.name, "123456789")
  
  // æµ‹è¯•åªåŒ…å«ç¬¦å·çš„key
  let symbols_only_key = create_key("!@#$%^&*()")
  assert_eq(symbols_only_key.name, "!@#$%^&*()")
  
  // æµ‹è¯•åŒ…å«emojiçš„key
  let emoji_key = create_key("key_with_emoji_ğŸš€ğŸ‰ğŸ’»")
  assert_eq(emoji_key.name, "key_with_emoji_ğŸš€ğŸ‰ğŸ’»")
  
  // æµ‹è¯•æ··åˆè¯­è¨€çš„key
  let mixed_language_key = create_key("mixed_Englishä¸­æ–‡í•œêµ­ì–´Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  assert_eq(mixed_language_key.name, "mixed_Englishä¸­æ–‡í•œêµ­ì–´Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  
  // æµ‹è¯•ä½¿ç”¨è¿™äº›ç‰¹æ®Škeyåœ¨contextä¸­å­˜å‚¨å€¼
  let ctx_with_special_keys = ctx
    .with_value(very_long_key, "very.long.key.value")
    .with_value(control_chars_key, "control.chars.value")
    .with_value(numbers_only_key, "numbers.only.value")
    .with_value(symbols_only_key, "symbols.only.value")
    .with_value(emoji_key, "emoji.value")
    .with_value(mixed_language_key, "mixed.language.value")
  
  // éªŒè¯æ‰€æœ‰ç‰¹æ®Škeyéƒ½èƒ½æ­£ç¡®å·¥ä½œ
  match ctx_with_special_keys.get(very_long_key) {
    Some(value) => assert_eq(value, "very.long.key.value")
    None => @test.fail("Expected value for very long key")
  }
  
  match ctx_with_special_keys.get(control_chars_key) {
    Some(value) => assert_eq(value, "control.chars.value")
    None => @test.fail("Expected value for control chars key")
  }
  
  match ctx_with_special_keys.get(numbers_only_key) {
    Some(value) => assert_eq(value, "numbers.only.value")
    None => @test.fail("Expected value for numbers only key")
  }
  
  match ctx_with_special_keys.get(symbols_only_key) {
    Some(value) => assert_eq(value, "symbols.only.value")
    None => @test.fail("Expected value for symbols only key")
  }
  
  match ctx_with_special_keys.get(emoji_key) {
    Some(value) => assert_eq(value, "emoji.value")
    None => @test.fail("Expected value for emoji key")
  }
  
  match ctx_with_special_keys.get(mixed_language_key) {
    Some(value) => assert_eq(value, "mixed.language.value")
    None => @test.fail("Expected value for mixed language key")
  }
}

test "context_key_performance_and_efficiency" {
  // æµ‹è¯•ContextKeyçš„æ€§èƒ½å’Œæ•ˆç‡ï¼ˆå¤§é‡key-valueæ“ä½œï¼‰
  
  let ctx = Context::empty()
  let mut current_ctx = ctx
  
  // åˆ›å»ºå°‘é‡keyå¹¶å­˜å‚¨å€¼ï¼ˆé¿å…æ•°ç»„æ“ä½œé—®é¢˜ï¼‰
  let key1 = create_key("perf.test.key.1")
  let key2 = create_key("perf.test.key.2")
  let key3 = create_key("perf.test.key.3")
  let key4 = create_key("perf.test.key.4")
  let key5 = create_key("perf.test.key.5")
  
  // å­˜å‚¨å€¼
  current_ctx = current_ctx.with_value(key1, "value.1")
  current_ctx = current_ctx.with_value(key2, "value.2")
  current_ctx = current_ctx.with_value(key3, "value.3")
  current_ctx = current_ctx.with_value(key4, "value.4")
  current_ctx = current_ctx.with_value(key5, "value.5")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½èƒ½æ­£ç¡®è·å–
  match current_ctx.get(key1) {
    Some(value) => assert_eq(value, "value.1")
    None => @test.fail("Expected value for key1")
  }
  
  match current_ctx.get(key2) {
    Some(value) => assert_eq(value, "value.2")
    None => @test.fail("Expected value for key2")
  }
  
  match current_ctx.get(key3) {
    Some(value) => assert_eq(value, "value.3")
    None => @test.fail("Expected value for key3")
  }
  
  match current_ctx.get(key4) {
    Some(value) => assert_eq(value, "value.4")
    None => @test.fail("Expected value for key4")
  }
  
  match current_ctx.get(key5) {
    Some(value) => assert_eq(value, "value.5")
    None => @test.fail("Expected value for key5")
  }
  
  // æµ‹è¯•è¦†ç›–å€¼
  current_ctx = current_ctx.with_value(key1, "updated.value.1")
  current_ctx = current_ctx.with_value(key3, "updated.value.3")
  current_ctx = current_ctx.with_value(key5, "updated.value.5")
  
  // éªŒè¯æ›´æ–°åçš„å€¼
  match current_ctx.get(key1) {
    Some(value) => assert_eq(value, "updated.value.1")
    None => @test.fail("Expected updated value for key1")
  }
  
  match current_ctx.get(key2) {
    Some(value) => assert_eq(value, "value.2")  // æœªæ›´æ–°
    None => @test.fail("Expected original value for key2")
  }
  
  match current_ctx.get(key3) {
    Some(value) => assert_eq(value, "updated.value.3")
    None => @test.fail("Expected updated value for key3")
  }
  
  match current_ctx.get(key4) {
    Some(value) => assert_eq(value, "value.4")  // æœªæ›´æ–°
    None => @test.fail("Expected original value for key4")
  }
  
  match current_ctx.get(key5) {
    Some(value) => assert_eq(value, "updated.value.5")
    None => @test.fail("Expected updated value for key5")
  }
}