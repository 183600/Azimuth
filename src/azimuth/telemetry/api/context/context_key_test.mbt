// ContextKeyåŠŸèƒ½çš„æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•ä¸Šä¸‹æ–‡é”®çš„åˆ›å»ºå’Œä½¿ç”¨

test "context_key_creation_and_usage" {
  // æµ‹è¯•ContextKeyçš„åˆ›å»ºå’ŒåŸºæœ¬ä½¿ç”¨
  let key1 = create_key("test-key-1")
  let key2 = create_key("test-key-2")
  let key3 = create_key("test-key-1") // ä¸key1åŒå
  
  assert_eq(key1.name, "test-key-1")
  assert_eq(key2.name, "test-key-2")
  assert_eq(key3.name, "test-key-1")
  
  // è™½ç„¶key1å’Œkey3åŒåï¼Œä½†å®ƒä»¬æ˜¯ä¸åŒçš„å®ä¾‹
  // åœ¨å®é™…ä½¿ç”¨ä¸­ï¼Œåº”è¯¥ä¿æŒå¯¹åŒä¸€keyå®ä¾‹çš„å¼•ç”¨
}

test "context_key_with_various_names" {
  // æµ‹è¯•å„ç§åç§°çš„ContextKey
  let simple_key = create_key("simple")
  let underscore_key = create_key("snake_case_key")
  let dot_key = create_key("dotted.key.name")
  let number_key = create_key("key123")
  let mixed_key = create_key("mixed-Style_key.name123")
  let unicode_key = create_key("æµ‹è¯•é”®")
  let empty_key = create_key("")
  
  assert_eq(simple_key.name, "simple")
  assert_eq(underscore_key.name, "snake_case_key")
  assert_eq(dot_key.name, "dotted.key.name")
  assert_eq(number_key.name, "key123")
  assert_eq(mixed_key.name, "mixed-Style_key.name123")
  assert_eq(unicode_key.name, "æµ‹è¯•é”®")
  assert_eq(empty_key.name, "")
}

test "context_operations_with_different_keys" {
  // æµ‹è¯•ä½¿ç”¨ä¸åŒé”®çš„ä¸Šä¸‹æ–‡æ“ä½œ
  let ctx = Context::empty()
  
  let string_key = create_key("string.key")
  let number_key = create_key("number.key")
  let boolean_key = create_key("boolean.key")
  let unicode_key = create_key("unicode.é”®")
  
  // è®¾ç½®ä¸åŒç±»å‹çš„å€¼
  let ctx1 = ctx.with_value(string_key, "string value")
  let ctx2 = ctx1.with_value(number_key, "42")
  let ctx3 = ctx2.with_value(boolean_key, "true")
  let ctx4 = ctx3.with_value(unicode_key, "æµ‹è¯•å€¼")
  
  // è·å–å€¼å¹¶éªŒè¯
  match ctx4.get(string_key) {
    Some(value) => assert_eq(value, "string value")
    None => @test.fail("Expected Some(value)")
  }
  
  match ctx4.get(number_key) {
    Some(value) => assert_eq(value, "42")
    None => @test.fail("Expected Some(value)")
  }
  
  match ctx4.get(boolean_key) {
    Some(value) => assert_eq(value, "true")
    None => @test.fail("Expected Some(value)")
  }
  
  match ctx4.get(unicode_key) {
    Some(value) => assert_eq(value, "æµ‹è¯•å€¼")
    None => @test.fail("Expected Some(value)")
  }
}

test "context_key_value_overwrite" {
  // æµ‹è¯•ä½¿ç”¨ç›¸åŒé”®è¦†ç›–å€¼
  let ctx = Context::empty()
  let key = create_key("overwrite.key")
  
  // è®¾ç½®åˆå§‹å€¼
  let ctx1 = ctx.with_value(key, "initial value")
  match ctx1.get(key) {
    Some(value) => assert_eq(value, "initial value")
    None => @test.fail("Expected Some(value)")
  }
  
  // è¦†ç›–å€¼
  let ctx2 = ctx1.with_value(key, "overwritten value")
  match ctx2.get(key) {
    Some(value) => assert_eq(value, "overwritten value")
    None => @test.fail("Expected Some(value)")
  }
  
  // å†æ¬¡è¦†ç›–
  let ctx3 = ctx2.with_value(key, "final value")
  match ctx3.get(key) {
    Some(value) => assert_eq(value, "final value")
    None => @test.fail("Expected Some(value)")
  }
}

test "context_key_non_existent" {
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„é”®
  let ctx = Context::empty()
  let existing_key = create_key("existing.key")
  let non_existent_key1 = create_key("non.existent.key1")
  let non_existent_key2 = create_key("non.existent.key2")
  
  // è®¾ç½®ä¸€ä¸ªå€¼
  let ctx1 = ctx.with_value(existing_key, "value")
  
  // éªŒè¯å­˜åœ¨çš„é”®
  match ctx1.get(existing_key) {
    Some(value) => assert_eq(value, "value")
    None => @test.fail("Expected Some(value)")
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®
  match ctx1.get(non_existent_key1) {
    Some(_) => @test.fail("Expected None")
    None => assert_eq(true, true)
  }
  
  match ctx1.get(non_existent_key2) {
    Some(_) => @test.fail("Expected None")
    None => assert_eq(true, true)
  }
}

test "context_key_with_special_values" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å€¼
  let ctx = Context::empty()
  
  let keys = [
    create_key("empty.string"),
    create_key("spaces"),
    create_key("special.chars"),
    create_key("unicode.value"),
    create_key("json.value"),
    create_key("newlines")
  ]
  
  let values = [
    "",
    "   ",
    "special!@#$%^&*()_+-=[]{}|;':\",./<>?",
    "æµ‹è¯• Unicode ğŸš€",
    "{\"key\": \"value\", \"number\": 42}",
    "line1\nline2\r\nline3"
  ]
  
  // è®¾ç½®å€¼
  let mut current_ctx = ctx
  let mut i = 0
  while i < keys.length() {
    current_ctx = current_ctx.with_value(keys[i], values[i])
    i = i + 1
  }
  
  // éªŒè¯å€¼
  let mut j = 0
  while j < keys.length() {
    match current_ctx.get(keys[j]) {
      Some(value) => assert_eq(value, values[j])
      None => @test.fail("Expected Some(value)")
    }
    j = j + 1
  }
}

test "context_key_with_long_names_and_values" {
  // æµ‹è¯•é•¿åç§°å’Œå€¼
  let long_key_name = "this.is.a.very.long.key.name.that.might.be.used.in.real.world.applications.to.identify.specific.context.values"
  let long_value = "this.is.a.very.long.value.that.might.contain.detailed.information.about.the.context.such.as.user.identifiers.session.ids.or.other.metadata.that.needs.to.be.stored.and.retrieved.later"
  
  let ctx = Context::empty()
  let long_key = create_key(long_key_name)
  
  // è®¾ç½®é•¿å€¼
  let ctx1 = ctx.with_value(long_key, long_value)
  
  // éªŒè¯é•¿å€¼
  match ctx1.get(long_key) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Expected Some(value)")
  }
  
  // éªŒè¯é”®å
  assert_eq(long_key.name, long_key_name)
}

test "multiple_context_keys_independence" {
  // æµ‹è¯•å¤šä¸ªä¸Šä¸‹æ–‡é”®çš„ç‹¬ç«‹æ€§
  let ctx = Context::empty()
  
  let key_a = create_key("key.a")
  let key_b = create_key("key.b")
  let key_c = create_key("key.c")
  
  // åˆ›å»ºä¸åŒçš„ä¸Šä¸‹æ–‡åˆ†æ”¯
  let ctx_a = ctx.with_value(key_a, "value.a")
  let ctx_b = ctx.with_value(key_b, "value.b")
  let ctx_c = ctx.with_value(key_c, "value.c")
  
  // éªŒè¯ç‹¬ç«‹æ€§
  match ctx_a.get(key_a) {
    Some(value) => assert_eq(value, "value.a")
    None => @test.fail("Expected Some(value)")
  }
  
  match ctx_a.get(key_b) {
    Some(_) => @test.fail("Expected None")
    None => assert_eq(true, true)
  }
  
  match ctx_b.get(key_b) {
    Some(value) => assert_eq(value, "value.b")
    None => @test.fail("Expected Some(value)")
  }
  
  match ctx_b.get(key_c) {
    Some(_) => @test.fail("Expected None")
    None => assert_eq(true, true)
  }
  
  match ctx_c.get(key_c) {
    Some(value) => assert_eq(value, "value.c")
    None => @test.fail("Expected Some(value)")
  }
  
  match ctx_c.get(key_a) {
    Some(_) => @test.fail("Expected None")
    None => assert_eq(true, true)
  }
}