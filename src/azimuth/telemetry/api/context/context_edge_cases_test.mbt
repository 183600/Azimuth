// Contextæ¨¡å—è¾¹ç¼˜æƒ…å†µæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•contextçš„è¾¹ç¼˜æƒ…å†µå’Œé”™è¯¯å¤„ç†

test "context_key_validation_edge_cases" {
  // æµ‹è¯•ContextKeyçš„è¾¹ç¼˜æƒ…å†µéªŒè¯
  
  // æµ‹è¯•å„ç§ç‰¹æ®Šçš„keyåç§°
  let special_keys = [
    "",                           // ç©ºå­—ç¬¦ä¸²
    " ",                          // åªæœ‰ç©ºæ ¼
    "key with spaces",            // åŒ…å«ç©ºæ ¼
    "key@with#special",           // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    "123invalid",                 // ä»¥æ•°å­—å¼€å¤´
    "a".repeat(1000),             // è¿‡é•¿çš„key
    "na\nme",                     // åŒ…å«æ¢è¡Œç¬¦
    "na\tme",                     // åŒ…å«åˆ¶è¡¨ç¬¦
    "na\rme",                     // åŒ…å«å›è½¦ç¬¦
    "na/me",                      // åŒ…å«è·¯å¾„åˆ†éš”ç¬¦
    "key.with.dots",              // åŒ…å«ç‚¹å·
    "key-with-dashes",            // åŒ…å«è¿å­—ç¬¦
    "key_with_underscores",       // åŒ…å«ä¸‹åˆ’çº¿
    "ä¸­æ–‡é”®å",                    // ä¸­æ–‡å­—ç¬¦
    "ĞºĞ»ÑÑ‡_Ñ€ÑƒÑÑĞºĞ¸Ğ¹",               // ä¿„æ–‡å­—ç¬¦
    "emoji_keyğŸš€",                // emojiå­—ç¬¦
    "mixedä¸­æ–‡ğŸš€english",          // æ··åˆå­—ç¬¦
  ]
  
  // æµ‹è¯•åˆ›å»ºç‰¹æ®Škey
  for key_name in special_keys {
    let key = create_key(key_name)
    assert_eq(key.name, key_name)
    
    // æµ‹è¯•keyçš„åŸºæœ¬å±æ€§
    let is_empty = key.name.length() == 0
    let has_spaces = key.name.contains(" ")
    let has_special_chars = key.name.contains("@") || key.name.contains("#")
    let starts_with_digit = key.name.length() > 0 && key.name[0] >= '0' && key.name[0] <= '9'
    let is_very_long = key.name.length() > 500
    let has_control_chars = key.name.contains("\n") || key.name.contains("\t") || key.name.contains("\r")
    let has_path_separator = key.name.contains("/")
    
    // è¿™äº›éƒ½æ˜¯è¾¹ç¼˜æƒ…å†µï¼Œä½†ä¸ä¸€å®šæ— æ•ˆ
    // åœ¨å®é™…å®ç°ä¸­ï¼Œåº”è¯¥æœ‰é€‚å½“çš„éªŒè¯é€»è¾‘
    if is_empty {
      assert_eq(key.name, "")
    }
    
    if has_spaces {
      assert_eq(key.name.contains(" "), true)
    }
    
    if has_special_chars {
      assert_eq(key.name.contains("@") || key.name.contains("#"), true)
    }
    
    if starts_with_digit {
      assert_eq(key.name[0] >= '0' && key.name[0] <= '9', true)
    }
    
    if is_very_long {
      assert_eq(key.name.length() > 500, true)
    }
    
    if has_control_chars {
      assert_eq(key.name.contains("\n") || key.name.contains("\t") || key.name.contains("\r"), true)
    }
    
    if has_path_separator {
      assert_eq(key.name.contains("/"), true)
    }
  }
}

test "context_value_edge_cases" {
  // æµ‹è¯•Contextå€¼çš„è¾¹ç¼˜æƒ…å†µ
  
  let base_ctx = Context::empty()
  
  // æµ‹è¯•å„ç§ç‰¹æ®Šçš„å€¼
  let special_values = [
    "",                           // ç©ºå­—ç¬¦ä¸²
    " ",                          // åªæœ‰ç©ºæ ¼
    "value with spaces",          // åŒ…å«ç©ºæ ¼
    "value@with#special",         // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    "a".repeat(10000),            // è¿‡é•¿çš„å€¼
    "na\nme",                     // åŒ…å«æ¢è¡Œç¬¦
    "na\tme",                     // åŒ…å«åˆ¶è¡¨ç¬¦
    "na\rme",                     // åŒ…å«å›è½¦ç¬¦
    "na/me",                      // åŒ…å«è·¯å¾„åˆ†éš”ç¬¦
    "value.with.dots",            // åŒ…å«ç‚¹å·
    "value-with-dashes",          // åŒ…å«è¿å­—ç¬¦
    "value_with_underscores",     // åŒ…å«ä¸‹åˆ’çº¿
    "ä¸­æ–‡å€¼",                      // ä¸­æ–‡å­—ç¬¦
    "Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ_Ñ€ÑƒÑÑĞºĞ¾Ğµ",           // ä¿„æ–‡å­—ç¬¦
    "emoji_valueğŸš€",              // emojiå­—ç¬¦
    "mixedä¸­æ–‡ğŸš€english",          // æ··åˆå­—ç¬¦
    "null",                       // å­—ç¬¦ä¸²"null"
    "undefined",                  // å­—ç¬¦ä¸²"undefined"
    "true",                       // å­—ç¬¦ä¸²"true"
    "false",                      // å­—ç¬¦ä¸²"false"
    "0",                          // å­—ç¬¦ä¸²"0"
    "-1",                         // å­—ç¬¦ä¸²"-1"
    "123.456",                    // å­—ç¬¦ä¸²æ•°å­—
    "[]",                         // å­—ç¬¦ä¸²"[]"
    "{}",                         // å­—ç¬¦ä¸²"{}"
    "<script>alert('xss')</script>", // XSSå°è¯•
    "'; DROP TABLE users; --",    // SQLæ³¨å…¥å°è¯•
  ]
  
  // æµ‹è¯•è®¾ç½®å’Œè·å–ç‰¹æ®Šå€¼
  for value in special_values {
    let key = create_key("test_key_" + value.length().to_string())
    let ctx_with_value = base_ctx.with_value(key, value)
    
    // éªŒè¯å€¼å¯ä»¥è¢«æ­£ç¡®è·å–
    match ctx_with_value.get(key) {
      Some(retrieved_value) => {
        assert_eq(retrieved_value, value)
      }
      None => @test.fail("Expected Some(value) for key: " + key.name)
    }
    
    // æµ‹è¯•å€¼çš„å±æ€§
    let is_empty = value.length() == 0
    let is_whitespace_only = value.trim().length() == 0 && value.length() > 0
    let has_spaces = value.contains(" ")
    let has_special_chars = value.contains("@") || value.contains("#") || value.contains(";")
    let is_very_long = value.length() > 5000
    let has_control_chars = value.contains("\n") || value.contains("\t") || value.contains("\r")
    let has_path_separator = value.contains("/")
    let looks_like_json = value.has_prefix("{") && value.has_suffix("}") || 
                          value.has_prefix("[") && value.has_suffix("]")
    let looks_like_number = value.length() > 0 && 
                           (value[0] >= '0' && value[0] <= '9' || value[0] == '-')
    let contains_xss = value.contains("<script") || value.contains("alert(")
    let contains_sql_injection = value.contains("DROP TABLE") || value.contains("DELETE FROM")
    
    // éªŒè¯è¾¹ç¼˜æƒ…å†µå±æ€§
    if is_empty {
      assert_eq(value, "")
    }
    
    if is_whitespace_only {
      assert_eq(value.trim().length(), 0)
    }
    
    if has_spaces {
      assert_eq(value.contains(" "), true)
    }
    
    if has_special_chars {
      assert_eq(value.contains("@") || value.contains("#") || value.contains(";"), true)
    }
    
    if is_very_long {
      assert_eq(value.length() > 5000, true)
    }
    
    if has_control_chars {
      assert_eq(value.contains("\n") || value.contains("\t") || value.contains("\r"), true)
    }
    
    if has_path_separator {
      assert_eq(value.contains("/"), true)
    }
    
    if looks_like_json {
      assert_eq(value.has_prefix("{") || value.has_prefix("["), true)
    }
    
    if looks_like_number {
      assert_eq(value.length() > 0 && (value[0] >= '0' && value[0] <= '9' || value[0] == '-'), true)
    }
    
    if contains_xss {
      assert_eq(value.contains("<script") || value.contains("alert("), true)
    }
    
    if contains_sql_injection {
      assert_eq(value.contains("DROP TABLE") || value.contains("DELETE FROM"), true)
    }
  }
}

test "context_chain_operations_edge_cases" {
  // æµ‹è¯•Contexté“¾å¼æ“ä½œçš„è¾¹ç¼˜æƒ…å†µ
  
  let base_ctx = Context::empty()
  
  // æµ‹è¯•æ·±åº¦é“¾å¼æ“ä½œ
  let mut ctx = base_ctx
  let mut i = 0
  while i < 1000 {
    let key = create_key("key_" + i.to_string())
    let value = "value_" + i.to_string()
    ctx = ctx.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ·±åº¦é“¾å¼æ“ä½œçš„ç»“æœ
  i = 0
  while i < 1000 {
    let key = create_key("key_" + i.to_string())
    let expected_value = "value_" + i.to_string()
    
    match ctx.get(key) {
      Some(actual_value) => {
        assert_eq(actual_value, expected_value)
      }
      None => @test.fail("Expected Some(value) for key: " + key.name)
    }
    i = i + 1
  }
  
  // æµ‹è¯•è¦†ç›–ç›¸åŒkeyçš„å€¼
  let override_key = create_key("override_key")
  let ctx1 = ctx.with_value(override_key, "original_value")
  let ctx2 = ctx1.with_value(override_key, "overridden_value")
  
  // éªŒè¯å€¼è¢«æ­£ç¡®è¦†ç›–
  match ctx2.get(override_key) {
    Some(value) => {
      assert_eq(value, "overridden_value")
    }
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ç©ºcontextçš„æ“ä½œ
  let empty_ctx = Context::empty()
  let empty_key = create_key("")
  let empty_value = ""
  
  let ctx_with_empty_key = empty_ctx.with_value(empty_key, empty_value)
  
  match ctx_with_empty_key.get(empty_key) {
    Some(value) => {
      assert_eq(value, "")
    }
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„key
  let non_existent_key = create_key("non_existent_key")
  match ctx.get(non_existent_key) {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•contextçš„"æ±¡æŸ“"æƒ…å†µï¼ˆå¤§é‡ä¸åŒçš„key-valueå¯¹ï¼‰
  let mut polluted_ctx = base_ctx
  let mut j = 0
  while j < 100 {
    let key = create_key("polluted_key_" + j.to_string())
    let value = "polluted_value_" + j.to_string() + "_with_extra_long_suffix_to_make_it_longer"
    polluted_ctx = polluted_ctx.with_value(key, value)
    j = j + 1
  }
  
  // éªŒè¯æ±¡æŸ“çš„contextä»ç„¶æ­£å¸¸å·¥ä½œ
  j = 0
  while j < 100 {
    let key = create_key("polluted_key_" + j.to_string())
    let expected_value = "polluted_value_" + j.to_string() + "_with_extra_long_suffix_to_make_it_longer"
    
    match polluted_ctx.get(key) {
      Some(actual_value) => {
        assert_eq(actual_value, expected_value)
      }
      None => @test.fail("Expected Some(value) for polluted key: " + key.name)
    }
    j = j + 1
  }
}