// Contextå¹¶å‘å®‰å…¨æµ‹è¯•
// æµ‹è¯•Contextåœ¨å¹¶å‘ç¯å¢ƒä¸‹çš„æ•°æ®ä¸€è‡´æ€§å’Œå®‰å…¨æ€§

test "context_basic_concurrent_access" {
  // æµ‹è¯•Contextçš„åŸºæœ¬å¹¶å‘è®¿é—®
  
  // åˆ›å»ºåˆå§‹context
  let base_ctx = Context::empty()
  let key1 = create_key("user_id")
  let key2 = create_key("request_id")
  let key3 = create_key("session_id")
  
  // æ¨¡æ‹Ÿå¹¶å‘å†™å…¥æ“ä½œ
  let ctx1 = base_ctx.with_value(key1, "user123")
  let ctx2 = ctx1.with_value(key2, "req456")
  let ctx3 = ctx2.with_value(key3, "sess789")
  
  // éªŒè¯æ•°æ®ä¸€è‡´æ€§
  match ctx3.get(key1) {
    Some(value) => assert_eq(value, "user123")
    None => @test.fail("Test failed")
  }
  
  match ctx3.get(key2) {
    Some(value) => assert_eq(value, "req456")
    None => @test.fail("Test failed")
  }
  
  match ctx3.get(key3) {
    Some(value) => assert_eq(value, "sess789")
    None => @test.fail("Test failed")
  }
}

test "context_isolation_between_operations" {
  // æµ‹è¯•ä¸åŒContextæ“ä½œä¹‹é—´çš„éš”ç¦»æ€§
  
  let base_ctx = Context::empty()
  let key = create_key("operation_id")
  
  // åˆ›å»ºä¸¤ä¸ªç‹¬ç«‹çš„contextåˆ†æ”¯
  let branch_a = base_ctx.with_value(key, "op_a_123")
  let branch_b = base_ctx.with_value(key, "op_b_456")
  
  // æ·»åŠ ä¸åŒçš„é¢å¤–æ•°æ®
  let key_a = create_key("branch_a_data")
  let key_b = create_key("branch_b_data")
  
  let final_branch_a = branch_a.with_value(key_a, "data_a")
  let final_branch_b = branch_b.with_value(key_b, "data_b")
  
  // éªŒè¯åˆ†æ”¯Açš„æ•°æ®
  match final_branch_a.get(key) {
    Some(value) => assert_eq(value, "op_a_123")
    None => @test.fail("Test failed")
  }
  
  match final_branch_a.get(key_a) {
    Some(value) => assert_eq(value, "data_a")
    None => @test.fail("Test failed")
  }
  
  match final_branch_a.get(key_b) {
    Some(_) => @test.fail("Test failed")  // åˆ†æ”¯Aä¸åº”è¯¥æœ‰åˆ†æ”¯Bçš„æ•°æ®
    None => assert_eq(true, true)
  }
  
  // éªŒè¯åˆ†æ”¯Bçš„æ•°æ®
  match final_branch_b.get(key) {
    Some(value) => assert_eq(value, "op_b_456")
    None => @test.fail("Test failed")
  }
  
  match final_branch_b.get(key_b) {
    Some(value) => assert_eq(value, "data_b")
    None => @test.fail("Test failed")
  }
  
  match final_branch_b.get(key_a) {
    Some(_) => @test.fail("Test failed")  // åˆ†æ”¯Bä¸åº”è¯¥æœ‰åˆ†æ”¯Açš„æ•°æ®
    None => assert_eq(true, true)
  }
}

test "context_chained_operations_consistency" {
  // æµ‹è¯•Contexté“¾å¼æ“ä½œçš„ä¸€è‡´æ€§
  
  let base_ctx = Context::empty()
  
  // é“¾å¼æ“ä½œï¼šæ·»åŠ å¤šä¸ªé”®å€¼å¯¹
  let ctx1 = base_ctx.with_value(create_key("step1"), "value1")
  let ctx2 = ctx1.with_value(create_key("step2"), "value2")
  let ctx3 = ctx2.with_value(create_key("step3"), "value3")
  let ctx4 = ctx3.with_value(create_key("step4"), "value4")
  let ctx5 = ctx4.with_value(create_key("step5"), "value5")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨ä¸”æ­£ç¡®
  match ctx5.get(create_key("step1")) {
    Some(value) => assert_eq(value, "value1")
    None => @test.fail("Test failed")
  }
  
  match ctx5.get(create_key("step2")) {
    Some(value) => assert_eq(value, "value2")
    None => @test.fail("Test failed")
  }
  
  match ctx5.get(create_key("step3")) {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Test failed")
  }
  
  match ctx5.get(create_key("step4")) {
    Some(value) => assert_eq(value, "value4")
    None => @test.fail("Test failed")
  }
  
  match ctx5.get(create_key("step5")) {
    Some(value) => assert_eq(value, "value5")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯ä¸­é—´contextçš„çŠ¶æ€
  match ctx3.get(create_key("step3")) {
    Some(value) => assert_eq(value, "value3")
    None => @test.fail("Test failed")
  }
  
  match ctx3.get(create_key("step4")) {
    Some(_) => @test.fail("Test failed")  // ctx3ä¸åº”è¯¥æœ‰step4
    None => assert_eq(true, true)
  }
}

test "context_overwrite_behavior" {
  // æµ‹è¯•Contextè¦†ç›–é”®å€¼çš„è¡Œä¸º
  
  let base_ctx = Context::empty()
  let key = create_key("mutable_key")
  
  // åˆå§‹å€¼
  let ctx1 = base_ctx.with_value(key, "initial_value")
  match ctx1.get(key) {
    Some(value) => assert_eq(value, "initial_value")
    None => @test.fail("Test failed")
  }
  
  // è¦†ç›–å€¼
  let ctx2 = ctx1.with_value(key, "updated_value")
  match ctx2.get(key) {
    Some(value) => assert_eq(value, "updated_value")
    None => @test.fail("Test failed")
  }
  
  // å†æ¬¡è¦†ç›–
  let ctx3 = ctx2.with_value(key, "final_value")
  match ctx3.get(key) {
    Some(value) => assert_eq(value, "final_value")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯åŸå§‹contextä¸å—å½±å“
  match ctx1.get(key) {
    Some(value) => assert_eq(value, "initial_value")  // ctx1åº”è¯¥ä¿æŒåŸå€¼
    None => @test.fail("Test failed")
  }
  
  match ctx2.get(key) {
    Some(value) => assert_eq(value, "updated_value")  // ctx2åº”è¯¥ä¿æŒåŸå€¼
    None => @test.fail("Test failed")
  }
}

test "context_large_dataset_handling" {
  // æµ‹è¯•Contextå¤„ç†å¤§é‡æ•°æ®çš„èƒ½åŠ›
  
  let base_ctx = Context::empty()
  
  // åˆ›å»ºåŒ…å«å¤§é‡é”®å€¼å¯¹çš„context
  let mut ctx = base_ctx
  let mut i = 0
  while i < 100 {
    let key = create_key("key_" + i.to_string())
    ctx = ctx.with_value(key, "value_" + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½æ­£ç¡®å­˜å‚¨
  i = 0
  while i < 100 {
    let key = create_key("key_" + i.to_string())
    match ctx.get(key) {
      Some(value) => assert_eq(value, "value_" + i.to_string())
      None => @test.fail("Test failed at index " + i.to_string())
    }
    i = i + 1
  }
  
  // éªŒè¯ä¸å­˜åœ¨çš„é”®è¿”å›None
  let non_existent_key = create_key("non_existent_key")
  match ctx.get(non_existent_key) {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
}

test "context_complex_value_storage" {
  // æµ‹è¯•Contextå­˜å‚¨å¤æ‚å€¼çš„èƒ½åŠ›
  
  let base_ctx = Context::empty()
  
  // å­˜å‚¨å„ç§å¤æ‚å­—ç¬¦ä¸²å€¼
  let complex_values = [
    ("json_string", "{\"user\":\"admin\",\"permissions\":[\"read\",\"write\",\"execute\"]}"),
    ("xml_data", "<root><item id=\"1\">value1</item><item id=\"2\">value2</item></root>"),
    ("base64_data", "SGVsbG8gV29ybGQgVGhpcyBpcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZw=="),
    ("url_encoded", "name=John+Doe&age=30&city=New+York&active=true"),
    ("csv_data", "id,name,age,active\n1,John,30,true\n2,Jane,25,false\n3,Bob,35,true"),
    ("multiline_text", "Line 1\nLine 2\nLine 3\nSpecial chars: !@#$%^&*()_+-=[]{}|;':\",./<>?"),
    ("unicode_text", "Hello ä¸–ç•Œ ğŸŒ Ã±Ã¡Ã©Ã­Ã³Ãº ä¸­æ–‡ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹"),
    ("empty_string", ""),
    ("spaces_only", "   "),
    ("special_chars", "!@#$%^&*()_+-=[]{}|;':\",./<>?~`")
  ]
  
  let mut ctx = base_ctx
  let mut i = 0
  while i < complex_values.length() {
    let (key_name, value) = complex_values[i]
    let key = create_key(key_name)
    ctx = ctx.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰å¤æ‚å€¼éƒ½æ­£ç¡®å­˜å‚¨
  i = 0
  while i < complex_values.length() {
    let (key_name, expected_value) = complex_values[i]
    let key = create_key(key_name)
    match ctx.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed for key: " + key_name)
    }
    i = i + 1
  }
}

test "context_key_name_edge_cases" {
  // æµ‹è¯•Contexté”®åçš„è¾¹ç•Œæƒ…å†µ
  
  let base_ctx = Context::empty()
  
  // æµ‹è¯•å„ç§é”®å
  let edge_case_keys = [
    ("", "empty_key_value"),  // ç©ºé”®å
    (" ", "space_key_value"),  // ç©ºæ ¼é”®å
    ("a", "single_char_key"),  // å•å­—ç¬¦é”®å
    ("very_long_key_name_that_exceeds_normal_length_expectations_and_tests_system_limits", "long_key_value"),  // é•¿é”®å
    ("key_with_123_numbers", "numeric_key_value"),  // åŒ…å«æ•°å­—çš„é”®å
    ("key-with-dashes", "dash_key_value"),  // åŒ…å«è¿å­—ç¬¦çš„é”®å
    ("key_with_underscores", "underscore_key_value"),  // åŒ…å«ä¸‹åˆ’çº¿çš„é”®å
    ("key.with.dots", "dot_key_value"),  // åŒ…å«ç‚¹çš„é”®å
    ("key/with/slashes", "slash_key_value"),  // åŒ…å«æ–œæ çš„é”®å
    ("key\\with\\backslashes", "backslash_key_value"),  // åŒ…å«åæ–œæ çš„é”®å
    ("key\nwith\nnewlines", "newline_key_value"),  // åŒ…å«æ¢è¡Œç¬¦çš„é”®å
    ("key\twith\ttabs", "tab_key_value"),  // åŒ…å«åˆ¶è¡¨ç¬¦çš„é”®å
    ("é”®åä¸­æ–‡", "chinese_key_value"),  // ä¸­æ–‡é”®å
    ("ĞºĞ»ÑÑ‡_Ñ€ÑƒÑÑĞºĞ¸Ğ¹", "russian_key_value"),  // ä¿„æ–‡é”®å
    ("Ù…ÙØªØ§Ø­_Ø¹Ø±Ø¨ÙŠ", "arabic_key_value")  // é˜¿æ‹‰ä¼¯æ–‡é”®å
  ]
  
  let mut ctx = base_ctx
  let mut i = 0
  while i < edge_case_keys.length() {
    let (key_name, value) = edge_case_keys[i]
    let key = create_key(key_name)
    ctx = ctx.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰è¾¹ç•Œæƒ…å†µé”®åéƒ½æ­£ç¡®å·¥ä½œ
  i = 0
  while i < edge_case_keys.length() {
    let (key_name, expected_value) = edge_case_keys[i]
    let key = create_key(key_name)
    match ctx.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Test failed for key: " + key_name)
    }
    i = i + 1
  }
}

test "context_performance_with_multiple_operations" {
  // æµ‹è¯•Contextåœ¨å¤šæ¬¡æ“ä½œä¸‹çš„æ€§èƒ½è¡¨ç°
  
  let base_ctx = Context::empty()
  
  // æ‰§è¡Œå¤§é‡æ“ä½œ
  let mut ctx = base_ctx
  let mut i = 0
  while i < 1000 {
    let key = create_key("perf_key_" + i.to_string())
    ctx = ctx.with_value(key, "perf_value_" + i.to_string())
    i = i + 1
  }
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  i = 0
  while i < 1000 {
    let key = create_key("perf_key_" + i.to_string())
    match ctx.get(key) {
      Some(value) => assert_eq(value, "perf_value_" + i.to_string())
      None => @test.fail("Test failed at index " + i.to_string())
    }
    i = i + 1
  }
  
  // éªŒè¯éšæœºè®¿é—®
  let test_indices = [0, 99, 500, 999, 123, 777]
  i = 0
  while i < test_indices.length() {
    let index = test_indices[i]
    let key = create_key("perf_key_" + index.to_string())
    match ctx.get(key) {
      Some(value) => assert_eq(value, "perf_value_" + index.to_string())
      None => @test.fail("Test failed for random access at index " + index.to_string())
    }
    i = i + 1
  }
}

test "context_memory_efficiency_validation" {
  // æµ‹è¯•Contextçš„å†…å­˜æ•ˆç‡
  
  let base_ctx = Context::empty()
  
  // åˆ›å»ºå¤šä¸ªç›¸ä¼¼çš„contextï¼Œæµ‹è¯•å†…å­˜ä½¿ç”¨æ¨¡å¼
  let ctx1 = base_ctx.with_value(create_key("common_key"), "common_value")
  let ctx2 = ctx1.with_value(create_key("unique_key_1"), "unique_value_1")
  let ctx3 = ctx1.with_value(create_key("unique_key_2"), "unique_value_2")
  let ctx4 = ctx1.with_value(create_key("unique_key_3"), "unique_value_3")
  
  // éªŒè¯æ¯ä¸ªcontextéƒ½æœ‰æ­£ç¡®çš„æ•°æ®
  match ctx1.get(create_key("common_key")) {
    Some(value) => assert_eq(value, "common_value")
    None => @test.fail("Test failed")
  }
  
  match ctx2.get(create_key("common_key")) {
    Some(value) => assert_eq(value, "common_value")
    None => @test.fail("Test failed")
  }
  
  match ctx2.get(create_key("unique_key_1")) {
    Some(value) => assert_eq(value, "unique_value_1")
    None => @test.fail("Test failed")
  }
  
  match ctx3.get(create_key("unique_key_2")) {
    Some(value) => assert_eq(value, "unique_value_2")
    None => @test.fail("Test failed")
  }
  
  match ctx4.get(create_key("unique_key_3")) {
    Some(value) => assert_eq(value, "unique_value_3")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯éš”ç¦»æ€§
  match ctx2.get(create_key("unique_key_2")) {
    Some(_) => @test.fail("Test failed")  // ctx2ä¸åº”è¯¥æœ‰unique_key_2
    None => assert_eq(true, true)
  }
  
  match ctx3.get(create_key("unique_key_1")) {
    Some(_) => @test.fail("Test failed")  // ctx3ä¸åº”è¯¥æœ‰unique_key_1
    None => assert_eq(true, true)
  }
}