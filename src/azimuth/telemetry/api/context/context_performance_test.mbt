// Contextæ¨¡å—æ€§èƒ½å’Œå¹¶å‘å®‰å…¨æ€§æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Contextåœ¨é«˜è´Ÿè½½å’Œå¹¶å‘åœºæ™¯ä¸‹çš„æ€§èƒ½è¡¨ç°

test "context_high_frequency_operations" {
  // æµ‹è¯•Contexté«˜é¢‘æ“ä½œçš„æ€§èƒ½
  let ctx = Context::empty()
  
  // é«˜é¢‘è®¾ç½®å’Œè·å–æ“ä½œ
  let mut i = 0
  let mut current_ctx = ctx
  while i < 10000 {
    let key = create_key("key." + i.to_string())
    let value = "value." + i.to_string()
    current_ctx = current_ctx.with_value(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½èƒ½æ­£ç¡®è·å–
  let mut j = 0
  while j < 10000 {
    let key = create_key("key." + j.to_string())
    let expected_value = "value." + j.to_string()
    match current_ctx.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Expected Some value for key: " + key.name)
    }
    j = j + 1
  }
  
  assert_eq(current_ctx.values.length(), 10000)
}

test "context_memory_efficiency" {
  // æµ‹è¯•Contextå†…å­˜ä½¿ç”¨æ•ˆç‡
  
  // åˆ›å»ºå¤§é‡ä¸åŒçš„contextå®ä¾‹
  let contexts = []
  let mut i = 0
  while i < 1000 {
    let ctx = Context::empty()
    let key = create_key("context.key." + i.to_string())
    let value = "context.value." + i.to_string()
    let ctx_with_value = ctx.with_value(key, value)
    contexts.push(ctx_with_value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰contextéƒ½æ­£ç¡®åˆ›å»º
  let mut j = 0
  while j < contexts.length() {
    let ctx = contexts[j]
    let expected_key = "context.key." + j.to_string()
    let expected_value = "context.value." + j.to_string()
    let key = create_key(expected_key)
    
    match ctx.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Expected Some value for context: " + expected_key)
    }
    j = j + 1
  }
  
  assert_eq(contexts.length(), 1000)
}

test "baggage_high_frequency_operations" {
  // æµ‹è¯•Baggageé«˜é¢‘æ“ä½œçš„æ€§èƒ½
  let baggage = Baggage::empty()
  
  // é«˜é¢‘æ·»åŠ æ¡ç›®æ“ä½œ
  let mut current_baggage = baggage
  let mut i = 0
  while i < 10000 {
    let key = "baggage.key." + i.to_string()
    let value = "baggage.value." + i.to_string()
    current_baggage = current_baggage.with_entry(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰æ¡ç›®éƒ½èƒ½æ­£ç¡®è·å–
  let mut j = 0
  while j < 10000 {
    let key = "baggage.key." + j.to_string()
    let expected_value = "baggage.value." + j.to_string()
    match current_baggage.get(key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Expected Some value for baggage key: " + key)
    }
    j = j + 1
  }
  
  assert_eq(current_baggage.entries.length(), 10000)
}

test "context_complex_nested_operations" {
  // æµ‹è¯•Contextå¤æ‚åµŒå¥—æ“ä½œ
  
  let ctx = Context::empty()
  
  // åˆ›å»ºæ·±å±‚åµŒå¥—çš„context
  let mut current_ctx = ctx
  let mut i = 0
  while i < 1000 {
    // æ¯å±‚æ·»åŠ å¤šä¸ªé”®å€¼å¯¹
    let key1 = create_key("level." + i.to_string() + ".key1")
    let key2 = create_key("level." + i.to_string() + ".key2")
    let key3 = create_key("level." + i.to_string() + ".key3")
    
    let value1 = "level." + i.to_string() + ".value1"
    let value2 = "level." + i.to_string() + ".value2"
    let value3 = "level." + i.to_string() + ".value3"
    
    current_ctx = current_ctx
      .with_value(key1, value1)
      .with_value(key2, value2)
      .with_value(key3, value3)
    
    i = i + 1
  }
  
  // éªŒè¯æ·±å±‚åµŒå¥—çš„æ‰€æœ‰å€¼
  let mut j = 0
  while j < 1000 {
    let key1 = create_key("level." + j.to_string() + ".key1")
    let key2 = create_key("level." + j.to_string() + ".key2")
    let key3 = create_key("level." + j.to_string() + ".key3")
    
    let expected_value1 = "level." + j.to_string() + ".value1"
    let expected_value2 = "level." + j.to_string() + ".value2"
    let expected_value3 = "level." + j.to_string() + ".value3"
    
    match current_ctx.get(key1) {
      Some(actual_value) => assert_eq(actual_value, expected_value1)
      None => @test.fail("Expected Some value for key1 at level: " + j.to_string())
    }
    
    match current_ctx.get(key2) {
      Some(actual_value) => assert_eq(actual_value, expected_value2)
      None => @test.fail("Expected Some value for key2 at level: " + j.to_string())
    }
    
    match current_ctx.get(key3) {
      Some(actual_value) => assert_eq(actual_value, expected_value3)
      None => @test.fail("Expected Some value for key3 at level: " + j.to_string())
    }
    
    j = j + 1
  }
  
  assert_eq(current_ctx.values.length(), 3000) // 1000 levels * 3 keys each
}

test "baggage_complex_entries_operations" {
  // æµ‹è¯•Baggageå¤æ‚æ¡ç›®æ“ä½œ
  
  let baggage = Baggage::empty()
  
  // æ·»åŠ å„ç§å¤æ‚æ¡ç›®
  let complex_entries = [
    ("user.id", "user-12345"),
    ("request.id", "req-abcdef-67890"),
    ("service.name", "payment-processing-service"),
    ("service.version", "v2.1.3-beta"),
    ("deployment.environment", "production-west"),
    ("trace.sampled", "true"),
    ("debug.enabled", "false"),
    ("correlation.id", "corr-xyz-123-456"),
    ("session.id", "sess-789-abc-def"),
    ("tenant.id", "tenant-001"),
    ("region", "us-west-2"),
    ("availability.zone", "us-west-2a"),
    ("instance.id", "i-0123456789abcdef0"),
    ("host.name", "ip-10-0-1-123.us-west-2.compute.internal"),
    ("process.id", "12345"),
    ("thread.id", "main-worker-7"),
    ("custom.tag", "custom-value-with-special-chars!@#$%"),
    ("unicode.test", "æµ‹è¯•ä¸­æ–‡å†…å®¹ğŸš€"),
    ("url.encoded", "key%20with%20spaces%26symbols"),
    ("json.value", "{\"nested\":{\"key\":\"value\",\"array\":[1,2,3]}}"),
    ("base64.value", "SGVsbG8gV29ybGQh"),
    ("timestamp.iso", "2023-12-07T10:30:45.123Z"),
    ("duration.ms", "12345"),
    ("size.bytes", "1048576"),
    ("rate.per.second", "1000.5")
  ]
  
  // æ·»åŠ æ‰€æœ‰å¤æ‚æ¡ç›®
  let mut current_baggage = baggage
  let mut i = 0
  while i < complex_entries.length() {
    let (key, value) = complex_entries[i]
    current_baggage = current_baggage.with_entry(key, value)
    i = i + 1
  }
  
  // éªŒè¯æ‰€æœ‰å¤æ‚æ¡ç›®éƒ½èƒ½æ­£ç¡®è·å–
  let mut j = 0
  while j < complex_entries.length() {
    let (expected_key, expected_value) = complex_entries[j]
    match current_baggage.get(expected_key) {
      Some(actual_value) => assert_eq(actual_value, expected_value)
      None => @test.fail("Expected Some value for baggage key: " + expected_key)
    }
    j = j + 1
  }
  
  assert_eq(current_baggage.entries.length(), complex_entries.length())
}

test "context_concurrent_simulation" {
  // æ¨¡æ‹Ÿå¹¶å‘Contextæ“ä½œï¼ˆç”±äºMoonBitä¸æ”¯æŒçœŸæ­£çš„å¹¶å‘ï¼Œè¿™é‡Œæ¨¡æ‹Ÿäº¤æ›¿æ“ä½œï¼‰
  
  let ctx = Context::empty()
  
  // æ¨¡æ‹Ÿå¤šä¸ª"çº¿ç¨‹"äº¤æ›¿æ“ä½œ
  let mut current_ctx = ctx
  
  // "çº¿ç¨‹1"çš„æ“ä½œ
  let mut i = 0
  while i < 1000 {
    let key = create_key("thread1.key." + i.to_string())
    let value = "thread1.value." + i.to_string()
    current_ctx = current_ctx.with_value(key, value)
    i = i + 1
  }
  
  // "çº¿ç¨‹2"çš„æ“ä½œ
  let mut j = 0
  while j < 1000 {
    let key = create_key("thread2.key." + j.to_string())
    let value = "thread2.value." + j.to_string()
    current_ctx = current_ctx.with_value(key, value)
    j = j + 1
  }
  
  // "çº¿ç¨‹3"çš„æ“ä½œ
  let mut k = 0
  while k < 1000 {
    let key = create_key("thread3.key." + k.to_string())
    let value = "thread3.value." + k.to_string()
    current_ctx = current_ctx.with_value(key, value)
    k = k + 1
  }
  
  // éªŒè¯æ‰€æœ‰"çº¿ç¨‹"çš„æ•°æ®éƒ½æ­£ç¡®ä¿å­˜
  let mut check_i = 0
  while check_i < 1000 {
    let key1 = create_key("thread1.key." + check_i.to_string())
    let expected_value1 = "thread1.value." + check_i.to_string()
    match current_ctx.get(key1) {
      Some(actual_value) => assert_eq(actual_value, expected_value1)
      None => @test.fail("Expected Some value for thread1 key: " + check_i.to_string())
    }
    check_i = check_i + 1
  }
  
  let mut check_j = 0
  while check_j < 1000 {
    let key2 = create_key("thread2.key." + check_j.to_string())
    let expected_value2 = "thread2.value." + check_j.to_string()
    match current_ctx.get(key2) {
      Some(actual_value) => assert_eq(actual_value, expected_value2)
      None => @test.fail("Expected Some value for thread2 key: " + check_j.to_string())
    }
    check_j = check_j + 1
  }
  
  let mut check_k = 0
  while check_k < 1000 {
    let key3 = create_key("thread3.key." + check_k.to_string())
    let expected_value3 = "thread3.value." + check_k.to_string()
    match current_ctx.get(key3) {
      Some(actual_value) => assert_eq(actual_value, expected_value3)
      None => @test.fail("Expected Some value for thread3 key: " + check_k.to_string())
    }
    check_k = check_k + 1
  }
  
  assert_eq(current_ctx.values.length(), 3000) // 3 threads * 1000 keys each
}

test "context_and_baggage_integration_performance" {
  // æµ‹è¯•Contextå’ŒBaggageé›†æˆçš„æ€§èƒ½
  
  let ctx = Context::empty()
  let baggage = Baggage::empty()
  
  // åˆ›å»ºåŒ…å«å¤§é‡æ•°æ®çš„baggage
  let mut current_baggage = baggage
  let mut i = 0
  while i < 1000 {
    let key = "integration.key." + i.to_string()
    let value = "integration.value." + i.to_string()
    current_baggage = current_baggage.with_entry(key, value)
    i = i + 1
  }
  
  // å°†baggageåºåˆ—åŒ–å¹¶å­˜å‚¨åˆ°contextä¸­
  let baggage_key = create_key("baggage")
  let mut baggage_string = ""
  let mut j = 0
  while j < current_baggage.entries.length() {
    let (key, value) = current_baggage.entries[j]
    if j > 0 {
      baggage_string = baggage_string + ","
    }
    baggage_string = baggage_string + key + "=" + value
    j = j + 1
  }
  
  let ctx_with_baggage = ctx.with_value(baggage_key, baggage_string)
  
  // åœ¨contextä¸­æ·»åŠ å…¶ä»–å…ƒæ•°æ®
  let trace_id_key = create_key("trace_id")
  let span_id_key = create_key("span_id")
  let flags_key = create_key("trace_flags")
  
  let final_ctx = ctx_with_baggage
    .with_value(trace_id_key, "0af7651916cd43dd8448eb211c80319c")
    .with_value(span_id_key, "b7ad6b7169203331")
    .with_value(flags_key, "01")
  
  // éªŒè¯é›†æˆæ•°æ®çš„å®Œæ•´æ€§
  match final_ctx.get(baggage_key) {
    Some(stored_baggage) => {
      // éªŒè¯baggageå­—ç¬¦ä¸²åŒ…å«æ‰€æœ‰é¢„æœŸçš„æ¡ç›®
      let mut k = 0
      while k < 1000 {
        let expected_key = "integration.key." + k.to_string()
        let expected_value = "integration.value." + k.to_string()
        let expected_entry = expected_key + "=" + expected_value
        assert_eq(stored_baggage.contains(expected_entry), true)
        k = k + 1
      }
    }
    None => @test.fail("Expected Some baggage value")
  }
  
  match final_ctx.get(trace_id_key) {
    Some(value) => assert_eq(value, "0af7651916cd43dd8448eb211c80319c")
    None => @test.fail("Expected Some trace_id value")
  }
  
  match final_ctx.get(span_id_key) {
    Some(value) => assert_eq(value, "b7ad6b7169203331")
    None => @test.fail("Expected Some span_id value")
  }
  
  match final_ctx.get(flags_key) {
    Some(value) => assert_eq(value, "01")
    None => @test.fail("Expected Some trace_flags value")
  }
  
  assert_eq(final_ctx.values.length(), 4)
  assert_eq(current_baggage.entries.length(), 1000)
}