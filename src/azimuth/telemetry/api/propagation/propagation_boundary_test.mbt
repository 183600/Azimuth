// Propagationæ¨¡å—è¾¹ç•Œæµ‹è¯•ç”¨ä¾‹
test "propagator_boundary_conditions" {
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  
  let context = Context::empty()
  
  // æµ‹è¯•ç©ºcarrierçš„è¾¹ç•Œæ¡ä»¶
  let empty_carrier = MapCarrier::new()
  
  // injectåˆ°ç©ºcarrier
  trace_propagator.inject(context, empty_carrier)
  baggage_propagator.inject(context, empty_carrier)
  
  match empty_carrier.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Expected traceparent header in empty carrier")
  }
  
  match empty_carrier.get(BAGGAGE_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Expected baggage header in empty carrier")
  }
  
  // extractä»ç©ºcarrier
  let empty_extract_context = trace_propagator.extract(context, empty_carrier)
  let empty_extract_baggage = baggage_propagator.extract(context, empty_carrier)
  
  assert_eq(true, true)  // ç®€åŒ–éªŒè¯ï¼Œç¡®ä¿ä¸å´©æºƒ
  
  // æµ‹è¯•åŒ…å«æŸåæ•°æ®çš„carrier
  let corrupted_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, ""),  // ç©ºtraceparent
    (BAGGAGE_HEADER, ""),       // ç©ºbaggage
    ("malformed.header", "value")
  ])
  
  let corrupted_extract_context = trace_propagator.extract(context, corrupted_carrier)
  let corrupted_extract_baggage = baggage_propagator.extract(context, corrupted_carrier)
  
  assert_eq(true, true)  // ç®€åŒ–éªŒè¯ï¼Œç¡®ä¿ä¸å´©æºƒ
}

test "trace_context_header_parsing_edge_cases" {
  let propagator = W3CTraceContextPropagator::{}
  let context = Context::empty()
  
  // æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µçš„traceparentå¤´
  
  // æ ‡å‡†æ ¼å¼
  let standard_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  ])
  
  let standard_extract = propagator.extract(context, standard_carrier)
  assert_eq(true, true)
  
  // æœ€å°é•¿åº¦
  let minimal_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-00000000000000000000000000000000-0000000000000000-00")
  ])
  
  let minimal_extract = propagator.extract(context, minimal_carrier)
  assert_eq(true, true)
  
  // æœ€å¤§å€¼
  let max_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "ff-ffffffffffffffffffffffffffffffff-ffffffffffffffff-ff")
  ])
  
  let max_extract = propagator.extract(context, max_carrier)
  assert_eq(true, true)
  
  // æ— æ•ˆæ ¼å¼ - å¤ªçŸ­
  let too_short_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331")
  ])
  
  let too_short_extract = propagator.extract(context, too_short_carrier)
  assert_eq(true, true)
  
  // æ— æ•ˆæ ¼å¼ - å¤ªé•¿
  let too_long_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01-extra")
  ])
  
  let too_long_extract = propagator.extract(context, too_long_carrier)
  assert_eq(true, true)
  
  // æ— æ•ˆå­—ç¬¦
  let invalid_chars_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319g-b7ad6b7169203331-01")
  ])
  
  let invalid_chars_extract = propagator.extract(context, invalid_chars_carrier)
  assert_eq(true, true)
}

test "baggage_header_parsing_edge_cases" {
  let propagator = W3CBaggagePropagator::{}
  let context = Context::empty()
  
  // æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µçš„baggageå¤´
  
  // ç©ºbaggage
  let empty_baggage_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "")
  ])
  
  let empty_baggage_extract = propagator.extract(context, empty_baggage_carrier)
  assert_eq(true, true)
  
  // å•ä¸ªæ¡ç›®
  let single_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "key=value")
  ])
  
  let single_extract = propagator.extract(context, single_carrier)
  assert_eq(true, true)
  
  // å¤šä¸ªæ¡ç›®
  let multiple_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "key1=value1,key2=value2,key3=value3")
  ])
  
  let multiple_extract = propagator.extract(context, multiple_carrier)
  assert_eq(true, true)
  
  // ç©ºé”®
  let empty_key_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "=value,key2=value2")
  ])
  
  let empty_key_extract = propagator.extract(context, empty_key_carrier)
  assert_eq(true, true)
  
  // ç©ºå€¼
  let empty_value_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "key1=,key2=value2")
  ])
  
  let empty_value_extract = propagator.extract(context, empty_value_carrier)
  assert_eq(true, true)
  
  // åªæœ‰é€—å·
  let commas_only_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, ",,,")
  ])
  
  let commas_only_extract = propagator.extract(context, commas_only_carrier)
  assert_eq(true, true)
  
  // å¤šä¸ªç­‰å·
  let multiple_equals_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "key=value=with=equals,key2=value2")
  ])
  
  let multiple_equals_extract = propagator.extract(context, multiple_equals_carrier)
  assert_eq(true, true)
  
  // Unicodeå­—ç¬¦
  let unicode_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "ç”¨æˆ·=ç”¨æˆ·123,emoji=ğŸš€")
  ])
  
  let unicode_extract = propagator.extract(context, unicode_carrier)
  assert_eq(true, true)
  
  // ç‰¹æ®Šå­—ç¬¦
  let special_chars_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, "special=!@#$%^&*(),spaces=value with spaces")
  ])
  
  let special_chars_extract = propagator.extract(context, special_chars_carrier)
  assert_eq(true, true)
}

test "composite_propagator_boundary_conditions" {
  // æµ‹è¯•CompositePropagatorçš„è¾¹ç•Œæ¡ä»¶
  
  // ç©ºpropagatoræ•°ç»„
  let empty_composite = CompositePropagator::new([])
  let context = Context::empty()
  let carrier = MapCarrier::new()
  
  empty_composite.inject(context, carrier)
  let empty_extract = empty_composite.extract(context, carrier)
  
  assert_eq(true, true)  // ç¡®ä¿ä¸å´©æºƒ
  
  // å•ä¸ªpropagator
  let single_trace = CompositePropagator::new([W3CTraceContextPropagator::{}])
  let single_baggage = CompositePropagator::new([W3CBaggagePropagator::{}])
  
  single_trace.inject(context, carrier)
  single_baggage.inject(context, carrier)
  
  match carrier.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Expected traceparent from single propagator")
  }
  
  match carrier.get(BAGGAGE_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Expected baggage from single propagator")
  }
  
  // é‡å¤çš„propagatorç±»å‹
  let duplicate_composite = CompositePropagator::new([
    W3CTraceContextPropagator::{},
    W3CTraceContextPropagator::{},
    W3CBaggagePropagator::{},
    W3CBaggagePropagator::{}
  ])
  
  let duplicate_carrier = MapCarrier::new()
  duplicate_composite.inject(context, duplicate_carrier)
  
  match duplicate_carrier.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Expected traceparent from duplicate propagators")
  }
  
  match duplicate_carrier.get(BAGGAGE_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Expected baggage from duplicate propagators")
  }
}

test "map_carrier_boundary_conditions" {
  // æµ‹è¯•MapCarrierçš„è¾¹ç•Œæ¡ä»¶
  
  // ç©ºæ•°æ®
  let empty_carrier = MapCarrier::from_map([])
  
  match empty_carrier.get("any.key") {
    Some(_) => @test.fail("Expected None from empty carrier")
    None => assert_eq(true, true)
  }
  
  let empty_keys = empty_carrier.keys()
  assert_eq(empty_keys.length(), 0)
  
  // å•ä¸ªæ¡ç›®
  let single_carrier = MapCarrier::from_map([("single.key", "single.value")])
  
  match single_carrier.get("single.key") {
    Some(value) => assert_eq(value, "single.value")
    None => @test.fail("Expected value from single entry carrier")
  }
  
  match single_carrier.get("missing.key") {
    Some(_) => @test.fail("Expected None for missing key")
    None => assert_eq(true, true)
  }
  
  let single_keys = single_carrier.keys()
  assert_eq(single_keys.length(), 1)
  assert_eq(single_keys[0], "single.key")
  
  // é‡å¤é”®ï¼ˆåé¢çš„åº”è¯¥è¦†ç›–å‰é¢çš„ï¼‰
  let duplicate_keys_carrier = MapCarrier::from_map([
    ("duplicate.key", "value1"),
    ("duplicate.key", "value2"),
    ("duplicate.key", "value3")
  ])
  
  match duplicate_keys_carrier.get("duplicate.key") {
    Some(value) => assert_eq(value, "value3")  // æœ€åä¸€ä¸ªå€¼
    None => @test.fail("Expected last value for duplicate key")
  }
  
  // ç©ºé”®å’Œç©ºå€¼
  let empty_key_value_carrier = MapCarrier::from_map([
    ("", "empty.key.value"),
    ("empty.value.key", ""),
    ("", "")
  ])
  
  match empty_key_value_carrier.get("") {
    Some(value) => assert_eq(value, "")  // æœ€åä¸€ä¸ªç©ºé”®çš„å€¼
    None => @test.fail("Expected value for empty key")
  }
  
  match empty_key_value_carrier.get("empty.value.key") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Expected empty value")
  }
  
  // é•¿é”®å’Œé•¿å€¼
  let long_key = "a".repeat(1000)
  let long_value = "b".repeat(1000)
  
  let long_carrier = MapCarrier::from_map([
    (long_key, long_value),
    ("normal.key", "normal.value")
  ])
  
  match long_carrier.get(long_key) {
    Some(value) => assert_eq(value, long_value)
    None => @test.fail("Expected long value")
  }
  
  match long_carrier.get("normal.key") {
    Some(value) => assert_eq(value, "normal.value")
    None => @test.fail("Expected normal value")
  }
  
  // Unicodeå’Œç‰¹æ®Šå­—ç¬¦
  let unicode_carrier = MapCarrier::from_map([
    ("Unicodeé”®ğŸš€", "Unicodeå€¼ğŸ”¥"),
    ("special!@#$%", "value!@#$%"),
    ("spaces and\ttabs\n", "value with\tspaces\n")
  ])
  
  match unicode_carrier.get("Unicodeé”®ğŸš€") {
    Some(value) => assert_eq(value, "Unicodeå€¼ğŸ”¥")
    None => @test.fail("Expected unicode value")
  }
  
  match unicode_carrier.get("special!@#$%") {
    Some(value) => assert_eq(value, "value!@#$%")
    None => @test.fail("Expected special characters value")
  }
  
  match unicode_carrier.get("spaces and\ttabs\n") {
    Some(value) => assert_eq(value, "value with\tspaces\n")
    None => @test.fail("Expected value with spaces and tabs")
  }
}

test "propagation_with_extreme_values" {
  // æµ‹è¯•ä¼ æ’­è¿‡ç¨‹ä¸­çš„æå€¼å¤„ç†
  
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  let composite_propagator = CompositePropagator::new([trace_propagator, baggage_propagator])
  
  let context = Context::empty()
  
  // æé•¿çš„headers
  let very_long_traceparent = "00-" + "f".repeat(32) + "-" + "f".repeat(16) + "-01"
  let very_long_baggage = "key1=" + "a".repeat(1000) + ",key2=" + "b".repeat(1000)
  
  let extreme_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, very_long_traceparent),
    (BAGGAGE_HEADER, very_long_baggage)
  ])
  
  let extreme_extract = composite_propagator.extract(context, extreme_carrier)
  assert_eq(true, true)
  
  // åŒ…å«æå¤šæ¡ç›®çš„baggage
  let many_entries = []
  let mut i = 0
  while i < 100 {
    many_entries.push("key" + i.to_string() + "=value" + i.to_string())
    i = i + 1
  }
  let many_baggage = ",".join(many_entries)
  
  let many_entries_carrier = MapCarrier::from_map([
    (BAGGAGE_HEADER, many_baggage)
  ])
  
  let many_extract = baggage_propagator.extract(context, many_entries_carrier)
  assert_eq(true, true)
  
  // åŒ…å«æ‰€æœ‰å¯èƒ½å­—ç¬¦çš„headers
  let all_chars_traceparent = "00-0123456789abcdef0123456789abcdef-0123456789abcdef-01"
  let all_chars_baggage = "key1=value1!@#$%^&*(),key2=value2ä¸­æ–‡ğŸš€,key3=value3\t\n\r"
  
  let all_chars_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, all_chars_traceparent),
    (BAGGAGE_HEADER, all_chars_baggage)
  ])
  
  let all_chars_extract = composite_propagator.extract(context, all_chars_carrier)
  assert_eq(true, true)
}

test "propagation_error_recovery" {
  // æµ‹è¯•ä¼ æ’­è¿‡ç¨‹ä¸­çš„é”™è¯¯æ¢å¤
  
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  let composite_propagator = CompositePropagator::new([trace_propagator, baggage_propagator])
  
  let context = Context::empty()
  
  // éƒ¨åˆ†æŸåçš„headers
  let partially_corrupted_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),  // æœ‰æ•ˆ
    (BAGGAGE_HEADER, "invalid=baggage=format"),  // æ— æ•ˆ
    ("good.header", "good.value")  // æ­£å¸¸
  ])
  
  let partial_extract = composite_propagator.extract(context, partially_corrupted_carrier)
  assert_eq(true, true)
  
  // å®Œå…¨æŸåçš„headers
  let fully_corrupted_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "completely-invalid-format"),
    (BAGGAGE_HEADER, "also///invalid///format"),
    ("another.bad", "header")
  ])
  
  let fully_corrupted_extract = composite_propagator.extract(context, fully_corrupted_carrier)
  assert_eq(true, true)
  
  // æ··åˆæœ‰æ•ˆå’Œæ— æ•ˆçš„propagators
  let mixed_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
    (BAGGAGE_HEADER, "key1=value1,key2=value2"),
    ("custom.header1", "custom.value1"),
    ("custom.header2", "custom.value2")
  ])
  
  // å…ˆinjectï¼Œç„¶åextract
  composite_propagator.inject(context, mixed_carrier)
  let mixed_extract = composite_propagator.extract(context, mixed_carrier)
  
  // éªŒè¯åŸæœ‰headersä»ç„¶å­˜åœ¨
  match mixed_carrier.get("custom.header1") {
    Some(value) => assert_eq(value, "custom.value1")
    None => @test.fail("Expected custom header1 to persist")
  }
  
  match mixed_carrier.get("custom.header2") {
    Some(value) => assert_eq(value, "custom.value2")
    None => @test.fail("Expected custom header2 to persist")
  }
  
  assert_eq(true, true)
}