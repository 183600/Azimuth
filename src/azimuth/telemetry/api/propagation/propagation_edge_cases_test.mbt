// Propagationæ¨¡å—è¾¹ç¼˜æƒ…å†µæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•propagationçš„è¾¹ç¼˜æƒ…å†µå’Œé”™è¯¯å¤„ç†

test "propagation_header_edge_cases" {
  // æµ‹è¯•ä¼ æ’­å¤´çš„è¾¹ç¼˜æƒ…å†µ
  
  // æµ‹è¯•å„ç§ç‰¹æ®Šçš„traceparentå¤´
  let special_traceparent_headers = [
    "",                                                    // ç©ºå¤´
    " ",                                                   // åªæœ‰ç©ºæ ¼
    "invalid-format",                                      // æ— æ•ˆæ ¼å¼
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331", // ç¼ºå°‘trace-flags
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01-extra", // é¢å¤–å­—æ®µ
    "01-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // æ— æ•ˆç‰ˆæœ¬
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b71692033-01",      // æ— æ•ˆspan_idé•¿åº¦
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-0",     // æ— æ•ˆtrace_flagsé•¿åº¦
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01 ",  // å°¾éƒ¨ç©ºæ ¼
    " 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // å‰å¯¼ç©ºæ ¼
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-FF",  // å¤§å†™trace_flags
    "00-GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG-b7ad6b7169203331-01",  // æ— æ•ˆtrace_idå­—ç¬¦
    "00-0af7651916cd43dd8448eb211c80319c-HHHHHHHHHHHHHHHH-01",  // æ— æ•ˆspan_idå­—ç¬¦
    "00-00000000000000000000000000000000-0000000000000000-00",  // å…¨é›¶trace_idå’Œspan_id
    "FF-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",  // ä¿ç•™ç‰ˆæœ¬
  ]
  
  // æµ‹è¯•æ¯ä¸ªç‰¹æ®Šçš„traceparentå¤´
  for header in special_traceparent_headers {
    let carrier = MapCarrier::from_map([
      (TRACE_PARENT_HEADER, header)
    ])
    
    let propagator = W3CTraceContextPropagator::{}
    let ctx = context::Context::empty()
    
    // å°è¯•æå–traceparent
    let extracted_ctx = propagator.extract(ctx, carrier)
    
    // éªŒè¯æå–æ“ä½œä¸ä¼šå´©æºƒ
    assert_eq(extracted_ctx.values.length(), ctx.values.length())
    
    // éªŒè¯å¤´çš„åŸºæœ¬å±žæ€§
    let is_empty = header.length() == 0
    let is_whitespace_only = header.trim().length() == 0 && header.length() > 0
    let has_correct_parts = header.split("-").length() >= 4
    let has_correct_length = header.length() == 55
    let has_valid_format = header.match_regex("^[0-9a-fA-F]{2}-[0-9a-fA-F]{32}-[0-9a-fA-F]{16}-[0-9a-fA-F]{2}$")
    
    if is_empty {
      assert_eq(header, "")
    }
    
    if is_whitespace_only {
      assert_eq(header.trim().length(), 0)
    }
    
    if has_correct_parts {
      assert_eq(header.split("-").length() >= 4, true)
    }
    
    if has_correct_length {
      assert_eq(header.length(), 55)
    }
    
    // æ³¨æ„ï¼šhas_valid_formatåœ¨MoonBitä¸­å¯èƒ½ä¸å¯ç”¨ï¼Œè¿™é‡Œåªæ˜¯ç¤ºä¾‹
  }
}

test "propagation_baggage_edge_cases" {
  // æµ‹è¯•Baggageä¼ æ’­çš„è¾¹ç¼˜æƒ…å†µ
  
  // æµ‹è¯•å„ç§ç‰¹æ®Šçš„baggageå¤´
  let special_baggage_headers = [
    "",                                                    // ç©ºå¤´
    " ",                                                   // åªæœ‰ç©ºæ ¼
    "key=value",                                           // ç®€å•é”®å€¼å¯¹
    "key=value,key2=value2",                               // å¤šä¸ªé”®å€¼å¯¹
    "key=",                                                // ç©ºå€¼
    "=value",                                              // ç©ºé”®
    "key=value,invalid",                                   // æ— æ•ˆæ ¼å¼
    "key=value,key2=",                                     // æ··åˆæœ‰æ•ˆå’Œæ— æ•ˆ
    "key=value,key2=value2,key3=value3,key4=value4,key5=value5", // é•¿åˆ—è¡¨
    "key=value with spaces",                               // å€¼åŒ…å«ç©ºæ ¼
    "key=value,with=equals",                               // å€¼åŒ…å«ç­‰å·
    "key=value,with,commas",                               // å€¼åŒ…å«é€—å·
    "key=value;properties=value",                          // å¸¦å±žæ€§
    "key=value;prop1=val1;prop2=val2",                     // å¤šä¸ªå±žæ€§
    "ä¸­æ–‡é”®=ä¸­æ–‡å€¼",                                        // Unicodeé”®å€¼
    "emoji=ðŸš€",                                            // Emojié”®å€¼
    "key with spaces=value",                               // é”®åŒ…å«ç©ºæ ¼
    "key@with#special=value",                              // é”®åŒ…å«ç‰¹æ®Šå­—ç¬¦
    "key=" + "a".repeat(1000),                             // é•¿å€¼
    "a".repeat(100) + "=" + "b".repeat(100),               // é•¿é”®å’Œå€¼
    "key=value\nwith\nnewlines",                           // åŒ…å«æ¢è¡Œç¬¦
    "key=value\twith\ttabs",                               // åŒ…å«åˆ¶è¡¨ç¬¦
    "key=value\rwith\rcarriage",                           // åŒ…å«å›žè½¦ç¬¦
    "key=value;urlencoded=%20%2C%3B",                      // URLç¼–ç å€¼
    "key=value;invalid=prop",                              // æ— æ•ˆå±žæ€§æ ¼å¼
  ]
  
  // æµ‹è¯•æ¯ä¸ªç‰¹æ®Šçš„baggageå¤´
  for header in special_baggage_headers {
    let carrier = MapCarrier::from_map([
      (BAGGAGE_HEADER, header)
    ])
    
    let propagator = W3CBaggagePropagator::{}
    let ctx = context::Context::empty()
    
    // å°è¯•æå–baggage
    let extracted_ctx = propagator.extract(ctx, carrier)
    
    // éªŒè¯æå–æ“ä½œä¸ä¼šå´©æºƒ
    assert_eq(extracted_ctx.values.length(), ctx.values.length())
    
    // éªŒè¯å¤´çš„åŸºæœ¬å±žæ€§
    let is_empty = header.length() == 0
    let is_whitespace_only = header.trim().length() == 0 && header.length() > 0
    let has_key_value_pairs = header.contains("=")
    let has_multiple_pairs = header.contains(",")
    let has_unicode = header.contains("ä¸­æ–‡") || header.contains("ðŸš€")
    let has_spaces = header.contains(" ")
    let has_special_chars = header.contains("@") || header.contains("#")
    let is_very_long = header.length() > 500
    let has_control_chars = header.contains("\n") || header.contains("\t") || header.contains("\r")
    let has_properties = header.contains(";")
    
    if is_empty {
      assert_eq(header, "")
    }
    
    if is_whitespace_only {
      assert_eq(header.trim().length(), 0)
    }
    
    if has_key_value_pairs {
      assert_eq(header.contains("="), true)
    }
    
    if has_multiple_pairs {
      assert_eq(header.contains(","), true)
    }
    
    if has_unicode {
      assert_eq(header.contains("ä¸­æ–‡") || header.contains("ðŸš€"), true)
    }
    
    if has_spaces {
      assert_eq(header.contains(" "), true)
    }
    
    if has_special_chars {
      assert_eq(header.contains("@") || header.contains("#"), true)
    }
    
    if is_very_long {
      assert_eq(header.length() > 500, true)
    }
    
    if has_control_chars {
      assert_eq(header.contains("\n") || header.contains("\t") || header.contains("\r"), true)
    }
    
    if has_properties {
      assert_eq(header.contains(";"), true)
    }
  }
}

test "propagation_composite_edge_cases" {
  // æµ‹è¯•å¤åˆä¼ æ’­å™¨çš„è¾¹ç¼˜æƒ…å†µ
  
  // åˆ›å»ºç©ºçš„ä¼ æ’­å™¨åˆ—è¡¨
  let empty_propagator = CompositePropagator::new([])
  
  // åˆ›å»ºå•ä¸ªä¼ æ’­å™¨
  let single_trace_propagator = CompositePropagator::new([W3CTraceContextPropagator::{}])
  let single_baggage_propagator = CompositePropagator::new([W3CBaggagePropagator::{}])
  
  // åˆ›å»ºå¤šä¸ªä¼ æ’­å™¨
  let multiple_propagators = CompositePropagator::new([
    W3CTraceContextPropagator::{},
    W3CBaggagePropagator::{}
  ])
  
  // åˆ›å»ºé‡å¤çš„ä¼ æ’­å™¨
  let duplicate_propagators = CompositePropagator::new([
    W3CTraceContextPropagator::{},
    W3CTraceContextPropagator::{},
    W3CBaggagePropagator::{},
    W3CBaggagePropagator::{}
  ])
  
  // æµ‹è¯•æ‰€æœ‰ä¼ æ’­å™¨é…ç½®
  let propagators = [
    empty_propagator,
    single_trace_propagator,
    single_baggage_propagator,
    multiple_propagators,
    duplicate_propagators
  ]
  
  for propagator in propagators {
    let ctx = context::Context::empty()
    let carrier = MapCarrier::from_map([
      (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
      (BAGGAGE_HEADER, "key1=value1,key2=value2")
    ])
    
    // æµ‹è¯•æ³¨å…¥æ“ä½œ
    let empty_carrier = MapCarrier::new()
    propagator.inject(ctx, empty_carrier)
    
    // æ³¨å…¥æ“ä½œåº”è¯¥ä¸ä¼šå´©æºƒ
    assert_eq(true, true)
    
    // æµ‹è¯•æå–æ“ä½œ
    let extracted_ctx = propagator.extract(ctx, carrier)
    
    // æå–æ“ä½œåº”è¯¥ä¸ä¼šå´©æºƒ
    assert_eq(extracted_ctx.values.length() >= 0, true)
  }
  
  // æµ‹è¯•å¸¦æœ‰æ— æ•ˆå¤´çš„carrier
  let invalid_carrier = MapCarrier::from_map([
    ("invalid-header", "invalid-value"),
    (TRACE_PARENT_HEADER, ""),
    (BAGGAGE_HEADER, "invalid"),
    ("another-invalid", "another-value")
  ])
  
  let ctx = context::Context::empty()
  let extracted_ctx = multiple_propagators.extract(ctx, invalid_carrier)
  
  // å³ä½¿æœ‰æ— æ•ˆå¤´ï¼Œæå–æ“ä½œä¹Ÿåº”è¯¥ä¸ä¼šå´©æºƒ
  assert_eq(extracted_ctx.values.length() >= 0, true)
  
  // æµ‹è¯•ç©ºçš„carrier
  let empty_carrier = MapCarrier::new()
  let extracted_from_empty = multiple_propagators.extract(ctx, empty_carrier)
  
  // ä»Žç©ºcarrieræå–åº”è¯¥ä¸ä¼šå´©æºƒ
  assert_eq(extracted_from_empty.values.length() >= 0, true)
  
  // æµ‹è¯•å¤§åž‹carrier
  let mut large_data = []
  let mut i = 0
  while i < 100 {
    let key = "header_" + i.to_string()
    let value = "value_" + i.to_string()
    large_data.push((key, value))
    i = i + 1
  }
  
  // æ·»åŠ æ ‡å‡†çš„ä¼ æ’­å¤´
  large_data.push((TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"))
  large_data.push((BAGGAGE_HEADER, "key1=value1,key2=value2"))
  
  let large_carrier = MapCarrier::from_map(large_data)
  let extracted_from_large = multiple_propagators.extract(ctx, large_carrier)
  
  // ä»Žå¤§åž‹carrieræå–åº”è¯¥ä¸ä¼šå´©æºƒ
  assert_eq(extracted_from_large.values.length() >= 0, true)
}