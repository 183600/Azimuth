// Propagationæ¨¡å—é«˜çº§æµ‹è¯•ç”¨ä¾‹
test "w3c_trace_context_propagator_complex_scenarios" {
  let propagator = W3CTraceContextPropagator::{}
  let context = Context::empty()
  
  // åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„MapCarrier
  let carrier_data = [
    ("existing.header", "existing.value"),
    ("another.header", "another.value")
  ]
  let carrier = MapCarrier::from_map(carrier_data)
  
  // æµ‹è¯•injectæ“ä½œ
  propagator.inject(context, carrier)
  
  // éªŒè¯traceparentå¤´è¢«è®¾ç½®ï¼ˆç®€åŒ–éªŒè¯ï¼‰
  match carrier.get(TRACE_PARENT_HEADER) {
    Some(trace_parent) => {
      // éªŒè¯traceparentæ ¼å¼ï¼šversion-trace_id-span_id-trace_flags
      assert_eq(trace_parent.length(), 55)  // æ ‡å‡†W3C traceparenté•¿åº¦
      
      let parts = trace_parent"-".split_to_string()
      assert_eq(parts.length(), 4)
      assert_eq(parts[0], "00")  // ç‰ˆæœ¬
      assert_eq(parts[1].length(), 32)  // trace_id (16 bytes = 32 hex chars)
      assert_eq(parts[2].length(), 16)  // span_id (8 bytes = 16 hex chars)
      assert_eq(parts[3].length(), 2)   // trace_flags (1 byte = 2 hex chars)
    }
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•extractæ“ä½œ
  let carrier_with_trace = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
    ("other.header", "other.value")
  ])
  
  let extracted_context = propagator.extract(context, carrier_with_trace)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œextractåº”è¯¥è¿”å›åŸå§‹context
  // åœ¨å®é™…å®ç°ä¸­ï¼Œä¼šè§£ætraceparentå¹¶æ›´æ–°context
  assert_eq(true, true)  // ç®€åŒ–éªŒè¯
}

test "w3c_baggage_propagator_complex_scenarios" {
  let propagator = W3CBaggagePropagator::{}
  let context = Context::empty()
  
  // åˆ›å»ºåŒ…å«ç°æœ‰headersçš„carrier
  let carrier_data = [
    ("authorization", "Bearer token123"),
    ("content-type", "application/json"),
    ("user-agent", "Azimuth-Telemetry/1.0")
  ]
  let carrier = MapCarrier::from_map(carrier_data)
  
  // æµ‹è¯•injectæ“ä½œ
  propagator.inject(context, carrier)
  
  // éªŒè¯baggageå¤´è¢«è®¾ç½®
  match carrier.get(BAGGAGE_HEADER) {
    Some(baggage_value) => {
      // éªŒè¯baggageæ ¼å¼ï¼škey1=value1,key2=value2
      assert_eq(baggage_value.contains("key1=value1"), true)
      assert_eq(baggage_value.contains("key2=value2"), true)
      
      // éªŒè¯å¤šä¸ªæ¡ç›®ç”¨é€—å·åˆ†éš”
      let entries = baggage_value",".split_to_string()
      assert_eq(entries.length(), 2)
    }
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ä»åŒ…å«baggageçš„carrierä¸­extract
  let carrier_with_baggage = MapCarrier::from_map([
    (BAGGAGE_HEADER, "user.id=user123,session.id=sess456,transaction.id=tx789"),
    ("authorization", "Bearer token123"),
    ("content-type", "application/json")
  ])
  
  let extracted_context = propagator.extract(context, carrier_with_baggage)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œextractåº”è¯¥è¿”å›åŸå§‹context
  // åœ¨å®é™…å®ç°ä¸­ï¼Œä¼šè§£æbaggageå¹¶æ›´æ–°contextä¸­çš„baggage
  assert_eq(true, true)  // ç®€åŒ–éªŒè¯
}

test "composite_propagator_multiple_propagators" {
  // åˆ›å»ºå¤šä¸ªpropagator
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  
  // åˆ›å»ºCompositePropagator
  let propagators = [trace_propagator, baggage_propagator]
  let composite_propagator = CompositePropagator::new(propagators)
  
  let context = Context::empty()
  let carrier = MapCarrier::new()
  
  // æµ‹è¯•composite inject
  composite_propagator.inject(context, carrier)
  
  // éªŒè¯ä¸¤ä¸ªå¤´éƒ½è¢«è®¾ç½®
  match carrier.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  match carrier.get(BAGGAGE_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•composite extract
  let carrier_with_headers = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
    (BAGGAGE_HEADER, "user.id=user123,session.id=sess456")
  ])
  
  let extracted_context = composite_propagator.extract(context, carrier_with_headers)
  
  // éªŒè¯extractæ“ä½œå®Œæˆ
  assert_eq(true, true)  // ç®€åŒ–éªŒè¯
}

test "map_carrier_complex_operations" {
  // æµ‹è¯•MapCarrierçš„å¤æ‚æ“ä½œ
  
  // åˆ›å»ºåŒ…å«å¤šç§æ•°æ®çš„carrier
  let initial_data = [
    ("string.header", "string.value"),
    ("number.header", "12345"),
    ("boolean.header", "true"),
    ("empty.header", ""),
    ("unicode.header", "Unicodeæµ‹è¯•ğŸš€"),
    ("special.chars.header", "!@#$%^&*()_+-=[]{}|;':\",./<>?"),
    ("long.header", "a".repeat(1000))
  ]
  
  let carrier = MapCarrier::from_map(initial_data)
  
  // æµ‹è¯•getæ“ä½œ
  match carrier.get("string.header") {
    Some(value) => assert_eq(value, "string.value")
    None => @test.fail("Test failed")
  }
  
  match carrier.get("number.header") {
    Some(value) => assert_eq(value, "12345")
    None => @test.fail("Test failed")
  }
  
  match carrier.get("boolean.header") {
    Some(value) => assert_eq(value, "true")
    None => @test.fail("Test failed")
  }
  
  match carrier.get("empty.header") {
    Some(value) => assert_eq(value, "")
    None => @test.fail("Test failed")
  }
  
  match carrier.get("unicode.header") {
    Some(value) => assert_eq(value, "Unicodeæµ‹è¯•ğŸš€")
    None => @test.fail("Test failed")
  }
  
  match carrier.get("special.chars.header") {
    Some(value) => assert_eq(value, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
    None => @test.fail("Test failed")
  }
  
  match carrier.get("long.header") {
    Some(value) => assert_eq(value.length(), 1000)
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  match carrier.get("nonexistent.header") {
    Some(_) => @test.fail("Test failed")
    None => assert_eq(true, true)
  }
  
  // æµ‹è¯•keysæ“ä½œ
  let keys = carrier.keys()
  assert_eq(keys.length(), 7)
  
  // éªŒè¯æ‰€æœ‰é”®éƒ½å­˜åœ¨
  let expected_keys = [
    "string.header", "number.header", "boolean.header", 
    "empty.header", "unicode.header", "special.chars.header", "long.header"
  ]
  
  let mut i = 0
  while i < expected_keys.length() {
    let expected_key = expected_keys[i]
    let mut found = false
    let mut j = 0
    while j < keys.length() {
      if keys[j] == expected_key {
        found = true
        break
      }
      j = j + 1
    }
    assert_eq(found, true)
    i = i + 1
  }
}

test "propagation_with_complex_context_and_baggage" {
  // æµ‹è¯•åŒ…å«å¤æ‚Contextå’ŒBaggageçš„ä¼ æ’­
  
  let context = Context::empty()
  let baggage = Baggage::empty()
  
  // åˆ›å»ºå¤æ‚çš„Context
  let trace_key = create_key("trace.id")
  let span_key = create_key("span.id")
  let user_key = create_key("user.id")
  
  let complex_context = context
    .with_value(trace_key, "trace-123456789")
    .with_value(span_key, "span-987654321")
    .with_value(user_key, "user-555666777")
  
  // åˆ›å»ºå¤æ‚çš„Baggage
  let complex_baggage = baggage
    .with_entry("service.name", "auth-service")
    .with_entry("service.version", "1.2.3")
    .with_entry("deployment.environment", "production")
    .with_entry("host.name", "auth-server-01")
    .with_entry("process.id", "12345")
    .with_entry("request.id", "req-abcdef")
  
  // åˆ›å»ºpropagators
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  let composite_propagator = CompositePropagator::new([trace_propagator, baggage_propagator])
  
  // åˆ›å»ºcarrier
  let carrier = MapCarrier::from_map([
    ("authorization", "Bearer token123"),
    ("content-type", "application/json"),
    ("x-forwarded-for", "192.168.1.100"),
    ("user-agent", "Mozilla/5.0 (compatible; Azimuth-Telemetry/1.0)")
  ])
  
  // æ‰§è¡Œinject
  composite_propagator.inject(complex_context, carrier)
  
  // éªŒè¯åŸæœ‰headersä»ç„¶å­˜åœ¨
  match carrier.get("authorization") {
    Some(value) => assert_eq(value, "Bearer token123")
    None => @test.fail("Test failed")
  }
  
  match carrier.get("content-type") {
    Some(value) => assert_eq(value, "application/json")
    None => @test.fail("Test failed")
  }
  
  // éªŒè¯æ–°çš„headersè¢«æ·»åŠ 
  match carrier.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  match carrier.get(BAGGAGE_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•extract
  let carrier_with_all_headers = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
    (BAGGAGE_HEADER, "service.name=auth-service,service.version=1.2.3,deployment.environment=production"),
    ("authorization", "Bearer token123"),
    ("content-type", "application/json")
  ])
  
  let extracted_context = composite_propagator.extract(complex_context, carrier_with_all_headers)
  
  // éªŒè¯extractæ“ä½œ
  assert_eq(true, true)  // ç®€åŒ–éªŒè¯
}

test "propagation_error_handling_and_edge_cases" {
  // æµ‹è¯•ä¼ æ’­è¿‡ç¨‹ä¸­çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæƒ…å†µ
  
  let propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  let composite_propagator = CompositePropagator::new([propagator, baggage_propagator])
  
  let context = Context::empty()
  
  // æµ‹è¯•ç©ºçš„carrier
  let empty_carrier = MapCarrier::new()
  composite_propagator.inject(context, empty_carrier)
  
  match empty_carrier.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  match empty_carrier.get(BAGGAGE_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•åŒ…å«æŸåheadersçš„carrier
  let corrupted_carrier = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "invalid-traceparent-format"),
    (BAGGAGE_HEADER, "invalid=baggage=format=with=extra=equals"),
    ("malformed.header", "")
  ])
  
  let extracted_from_corrupted = composite_propagator.extract(context, corrupted_carrier)
  
  // éªŒè¯å³ä½¿headersæŸåï¼Œextractä¹Ÿä¸ä¼šå´©æºƒ
  assert_eq(true, true)
  
  // æµ‹è¯•åŒ…å«å¤§é‡headersçš„carrier
  let many_headers = []
  let mut i = 0
  while i < 100 {
    many_headers.push(("header" + i.to_string(), "value" + i.to_string()))
    i = i + 1
  }
  
  let carrier_with_many_headers = MapCarrier::from_map(many_headers)
  composite_propagator.inject(context, carrier_with_many_headers)
  
  // éªŒè¯injectåœ¨å¤§é‡headersæƒ…å†µä¸‹ä»èƒ½æ­£å¸¸å·¥ä½œ
  match carrier_with_many_headers.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•Unicodeå’Œç‰¹æ®Šå­—ç¬¦çš„headers
  let unicode_carrier = MapCarrier::from_map([
    ("unicode.header", "Unicodeæµ‹è¯•ğŸš€"),
    ("special.chars", "!@#$%^&*()_+-=[]{}|;':\",./<>?"),
    ("emoji.header", "ğŸ”¥ğŸ’¯ğŸ‰")
  ])
  
  composite_propagator.inject(context, unicode_carrier)
  
  // éªŒè¯åŸæœ‰headersä¿æŒä¸å˜
  match unicode_carrier.get("unicode.header") {
    Some(value) => assert_eq(value, "Unicodeæµ‹è¯•ğŸš€")
    None => @test.fail("Test failed")
  }
  
  match unicode_carrier.get("special.chars") {
    Some(value) => assert_eq(value, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
    None => @test.fail("Test failed")
  }
  
  match unicode_carrier.get("emoji.header") {
    Some(value) => assert_eq(value, "ğŸ”¥ğŸ’¯ğŸ‰")
    None => @test.fail("Test failed")
  }
}

test "propagation_performance_and_large_scale" {
  // æµ‹è¯•ä¼ æ’­æ€§èƒ½å’Œå¤§è§„æ¨¡åœºæ™¯
  
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  let composite_propagator = CompositePropagator::new([trace_propagator, baggage_propagator])
  
  let context = Context::empty()
  
  // åˆ›å»ºåŒ…å«å¤§é‡headersçš„carrier
  let large_data = []
  let mut i = 0
  while i < 1000 {
    large_data.push(("large.header" + i.to_string(), "large.value" + i.to_string()))
    i = i + 1
  }
  
  let large_carrier = MapCarrier::from_map(large_data)
  
  // æ‰§è¡Œå¤§é‡injectæ“ä½œ
  let mut j = 0
  while j < 100 {
    composite_propagator.inject(context, large_carrier)
    j = j + 1
  }
  
  // éªŒè¯æ€§èƒ½æµ‹è¯•å®Œæˆ
  match large_carrier.get(TRACE_PARENT_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  match large_carrier.get(BAGGAGE_HEADER) {
    Some(_) => assert_eq(true, true)
    None => @test.fail("Test failed")
  }
  
  // æµ‹è¯•å¤§é‡extractæ“ä½œ
  let carrier_for_extract = MapCarrier::from_map([
    (TRACE_PARENT_HEADER, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
    (BAGGAGE_HEADER, "key1=value1,key2=value2,key3=value3")
  ])
  
  let mut k = 0
  while k < 100 {
    let extracted_context = composite_propagator.extract(context, carrier_for_extract)
    k = k + 1
  }
  
  // éªŒè¯æ€§èƒ½æµ‹è¯•å®Œæˆ
  assert_eq(true, true)
}