// Propagationæ¨¡å—é«˜çº§æµ‹è¯•ç”¨ä¾‹

test "composite_propagator_multiple_injectors" {
  // æµ‹è¯•CompositePropagatorä½¿ç”¨å¤šä¸ªæ³¨å…¥å™¨
  
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  
  let composite = CompositePropagator::new([trace_propagator, baggage_propagator])
  
  let carrier = MapCarrier::new()
  let ctx = Context::empty()
  
  // æ‰§è¡Œæ³¨å…¥
  composite.inject(ctx, carrier)
  
  // éªŒè¯carrieråŒ…å«é¢„æœŸçš„keys
  let keys = carrier.keys()
  assert_eq(keys.length(), 0)  // ç®€åŒ–å®ç°ä¸­keysä¸ºç©ºï¼Œå› ä¸ºsetæ˜¯no-op
  
  // æµ‹è¯•æå–
  let extracted_ctx = composite.extract(ctx, carrier)
  assert_eq(extracted_ctx.values.length(), 0)  // ç®€åŒ–å®ç°ä¸­ä¸å®é™…æå–æ•°æ®
}

test "map_carrier_complex_operations" {
  // æµ‹è¯•MapCarrierçš„å¤æ‚æ“ä½œ
  
  // åˆ›å»ºå¸¦æœ‰å¤æ‚æ•°æ®çš„MapCarrier
  let initial_data = [
    ("traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
    ("tracestate", "rojo=00f067aa0ba902b7,congo=t61rcWkgMzE"),
    ("baggage", "key1=value1,key2=value2;prop1=val1"),
    ("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"),
    ("x-custom-header", "custom-value-with-special-chars-!@#$%^&*()"),
    ("x-unicode-header", "Unicodeæµ‹è¯•ğŸš€ğŸŒŸ"),
    ("x-multi-line", "line1\nline2\nline3"),
    ("x-empty-value", ""),
    ("x-number-header", "12345"),
    ("x-json-header", "{\"key\":\"value\",\"number\":42,\"array\":[1,2,3]}")
  ]
  
  let carrier = MapCarrier::from_map(initial_data)
  
  // æµ‹è¯•getæ“ä½œ
  match carrier.get("traceparent") {
    Some(traceparent) => {
      assert_eq(traceparent.length(), 55)  // æ ‡å‡†traceparenté•¿åº¦
      assert_eq(traceparent.contains("00-"), true)
      assert_eq(traceparent.contains("-01"), true)
    }
    None => @test.fail("Expected traceparent header")
  }
  
  match carrier.get("baggage") {
    Some(baggage) => {
      assert_eq(baggage.contains("key1=value1"), true)
      assert_eq(baggage.contains("key2=value2"), true)
      assert_eq(baggage.contains("prop1=val1"), true)
    }
    None => @test.fail("Expected baggage header")
  }
  
  match carrier.get("x-unicode-header") {
    Some(unicode) => {
      assert_eq(unicode.contains("æµ‹è¯•"), true)
      assert_eq(unicode.contains("ğŸš€"), true)
      assert_eq(unicode.contains("ğŸŒŸ"), true)
    }
    None => @test.fail("Expected unicode header")
  }
  
  match carrier.get("x-empty-value") {
    Some(empty) => assert_eq(empty, "")
    None => @test.fail("Expected empty value header")
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„key
  match carrier.get("non-existent-header") {
    Some(_) => @test.fail("Expected None for non-existent header")
    None => assert_eq(true, true)  // æœŸæœ›None
  }
  
  // æµ‹è¯•keysæ–¹æ³•
  let keys = carrier.keys()
  assert_eq(keys.length(), 10)
  
  // éªŒè¯ç‰¹å®šçš„keyså­˜åœ¨
  let mut found_traceparent = false
  let mut found_baggage = false
  let mut found_unicode = false
  
  let mut i = 0
  while i < keys.length() {
    let key = keys[i]
    if key == "traceparent" {
      found_traceparent = true
    }
    if key == "baggage" {
      found_baggage = true
    }
    if key == "x-unicode-header" {
      found_unicode = true
    }
    i = i + 1
  }
  
  assert_eq(found_traceparent, true)
  assert_eq(found_baggage, true)
  assert_eq(found_unicode, true)
  
  // æµ‹è¯•to_mapæ–¹æ³•
  let map_data = carrier.to_map()
  assert_eq(map_data.length(), 10)
  
  // éªŒè¯ç‰¹å®šé”®å€¼å¯¹
  let mut found_user_agent = false
  let mut found_json = false
  
  i = 0
  while i < map_data.length() {
    let (key, value) = map_data[i]
    if key == "user-agent" {
      assert_eq(value.contains("Mozilla"), true)
      assert_eq(value.contains("Windows"), true)
      found_user_agent = true
    }
    if key == "x-json-header" {
      assert_eq(value.contains("key"), true)
      assert_eq(value.contains("value"), true)
      assert_eq(value.contains("42"), true)
      found_json = true
    }
    i = i + 1
  }
  
  assert_eq(found_user_agent, true)
  assert_eq(found_json, true)
}

test "propagation_edge_cases" {
  // æµ‹è¯•ä¼ æ’­çš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºcarrier
  let empty_carrier = MapCarrier::new()
  let ctx = Context::empty()
  
  let trace_propagator = W3CTraceContextPropagator::{}
  let baggage_propagator = W3CBaggagePropagator::{}
  
  // åœ¨ç©ºcarrierä¸Šæ‰§è¡Œæ³¨å…¥
  trace_propagator.inject(ctx, empty_carrier)
  baggage_propagator.inject(ctx, empty_carrier)
  
  // ä»ç©ºcarrieræå–
  let empty_extracted_ctx1 = trace_propagator.extract(ctx, empty_carrier)
  let empty_extracted_ctx2 = baggage_propagator.extract(ctx, empty_carrier)
  
  assert_eq(empty_extracted_ctx1.values.length(), 0)
  assert_eq(empty_extracted_ctx2.values.length(), 0)
  
  // æµ‹è¯•åŒ…å«æ— æ•ˆheaderçš„carrier
  let invalid_data = [
    ("traceparent", "invalid-traceparent-format"),
    ("baggage", "invalid-baggage-format="),
    ("empty-header", ""),
    ("only-key", ""),
    ("special-chars", "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  ]
  
  let invalid_carrier = MapCarrier::from_map(invalid_data)
  
  // ä»åŒ…å«æ— æ•ˆæ•°æ®çš„carrieræå–
  let invalid_extracted_ctx1 = trace_propagator.extract(ctx, invalid_carrier)
  let invalid_extracted_ctx2 = baggage_propagator.extract(ctx, invalid_carrier)
  
  assert_eq(invalid_extracted_ctx1.values.length(), 0)
  assert_eq(invalid_extracted_ctx2.values.length(), 0)
  
  // æµ‹è¯•åªæœ‰éƒ¨åˆ†headerçš„carrier
  let partial_data = [
    ("traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
    // ç¼ºå°‘baggage header
  ]
  
  let partial_carrier = MapCarrier::from_map(partial_data)
  
  let partial_extracted_ctx1 = trace_propagator.extract(ctx, partial_carrier)
  let partial_extracted_ctx2 = baggage_propagator.extract(ctx, partial_carrier)
  
  assert_eq(partial_extracted_ctx1.values.length(), 0)
  assert_eq(partial_extracted_ctx2.values.length(), 0)
}