test "span_context_validation" {
  // æµ‹è¯•SpanContextçš„éªŒè¯é€»è¾‘
  
  // æµ‹è¯•æœ‰æ•ˆçš„trace_idå’Œspan_id
  let valid_trace_id = [1_byte, 2_byte, 3_byte, 4_byte, 5_byte, 6_byte, 7_byte, 8_byte,
                       9_byte, 10_byte, 11_byte, 12_byte, 13_byte, 14_byte, 15_byte, 16_byte]
  let valid_span_id = [1_byte, 2_byte, 3_byte, 4_byte, 5_byte, 6_byte, 7_byte, 8_byte]
  
  assert_eq(valid_trace_id.length(), 16)
  assert_eq(valid_span_id.length(), 8)
  
  // æµ‹è¯•å…¨é›¶çš„trace_idï¼ˆæ— æ•ˆï¼‰
  let zero_trace_id = Array::make(16, 0_byte)
  let is_zero_trace = zero_trace_id.all(fn(x) { x == 0_byte })
  assert_eq(is_zero_trace, true)
  
  // æµ‹è¯•å…¨é›¶çš„span_idï¼ˆæ— æ•ˆï¼‰
  let zero_span_id = Array::make(8, 0_byte)
  let is_zero_span = zero_span_id.all(fn(x) { x == 0_byte })
  assert_eq(is_zero_span, true)
  
  // æµ‹è¯•éžé›¶çš„trace_idå’Œspan_idï¼ˆæœ‰æ•ˆï¼‰
  let non_zero_trace = valid_trace_id.some(fn(x) { x != 0_byte })
  let non_zero_span = valid_span_id.some(fn(x) { x != 0_byte })
  assert_eq(non_zero_trace, true)
  assert_eq(non_zero_span, true)
}

test "span_attributes_edge_cases" {
  // æµ‹è¯•Spanå±žæ€§çš„è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•ç©ºå±žæ€§åˆ—è¡¨
  let empty_attrs : Attributes = []
  assert_eq(empty_attrs.length(), 0)
  
  // æµ‹è¯•å¤§é‡å±žæ€§
  let many_attrs : Attributes = [
    ("attr1", AttributeValue::string("value1")),
    ("attr2", AttributeValue::string("value2")),
    ("attr3", AttributeValue::string("value3")),
    ("attr4", AttributeValue::string("value4")),
    ("attr5", AttributeValue::string("value5"))
  ]
  assert_eq(many_attrs.length(), 5)
  
  // æµ‹è¯•å±žæ€§å€¼çš„ç‰¹æ®Šå­—ç¬¦
  let special_attrs : Attributes = [
    ("empty", AttributeValue::string("")),
    ("spaces", AttributeValue::string("   ")),
    ("unicode", AttributeValue::string("æµ‹è¯•ðŸŒŸ")),
    ("special", AttributeValue::string("!@#$%^&*()")),
    ("null_char", AttributeValue::string("hello\0world"))
  ]
  
  assert_eq(special_attrs.length(), 5)
  
  // éªŒè¯ç©ºå­—ç¬¦ä¸²å±žæ€§
  match special_attrs[0].1 {
    AttributeValue::StringValue(s) => assert_eq(s, "")
    _ => @test.fail("Expected StringValue")
  }
  
  // éªŒè¯Unicodeå±žæ€§
  match special_attrs[2].1 {
    AttributeValue::StringValue(s) => assert_eq(s.contains("æµ‹è¯•"), true)
    _ => @test.fail("Expected StringValue")
  }
}