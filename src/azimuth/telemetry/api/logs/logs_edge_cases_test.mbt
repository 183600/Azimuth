// Logsæ¨¡å—è¾¹ç¼˜æƒ…å†µæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•logsçš„è¾¹ç¼˜æƒ…å†µå’Œé”™è¯¯å¤„ç†

test "logs_severity_edge_cases" {
  // æµ‹è¯•æ—¥å¿—ä¸¥é‡çº§åˆ«çš„è¾¹ç¼˜æƒ…å†µ
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡çº§åˆ«
  let severity_levels = [
    Trace, Debug, Info, Warn, Error, Fatal
  ]
  
  // ä¸ºæ¯ä¸ªä¸¥é‡çº§åˆ«åˆ›å»ºæ—¥å¿—è®°å½•
  for severity in severity_levels {
    let log_record = LogRecord::builder()
      .severity(severity)
      .body("Test message for severity: " + severity.to_string())
      .build()
    
    // éªŒè¯ä¸¥é‡çº§åˆ«è®¾ç½®æ­£ç¡®
    assert_eq(log_record.severity_number, severity)
    
    // éªŒè¯æ—¥å¿—è®°å½•çš„å…¶ä»–å±æ€§
    match log_record.body {
      Some(body) => {
        assert_eq(body.contains("Test message"), true)
      }
      None => @test.fail("Expected Some(body)")
    }
  }
  
  // æµ‹è¯•ä¸¥é‡çº§åˆ«çš„æ•°å€¼æ¯”è¾ƒ
  let trace_val = match Trace { Trace => 0 }
  let debug_val = match Debug { Debug => 1 }
  let info_val = match Info { Info => 2 }
  let warn_val = match Warn { Warn => 3 }
  let error_val = match Error { Error => 4 }
  let fatal_val = match Fatal { Fatal => 5 }
  
  // éªŒè¯ä¸¥é‡çº§åˆ«é¡ºåº
  assert_eq(trace_val < debug_val, true)
  assert_eq(debug_val < info_val, true)
  assert_eq(info_val < warn_val, true)
  assert_eq(warn_val < error_val, true)
  assert_eq(error_val < fatal_val, true)
  
  // æµ‹è¯•ä¸¥é‡çº§åˆ«çš„å­—ç¬¦ä¸²è¡¨ç¤º
  let severity_names = [
    (Trace, "TRACE"),
    (Debug, "DEBUG"),
    (Info, "INFO"),
    (Warn, "WARN"),
    (Error, "ERROR"),
    (Fatal, "FATAL")
  ]
  
  for (severity, name) in severity_names {
    let log_record = LogRecord::builder()
      .severity(severity)
      .severity_text(name)
      .build()
    
    match log_record.severity_text {
      Some(text) => {
        assert_eq(text, name)
      }
      None => @test.fail("Expected Some(severity_text)")
    }
  }
}

test "logs_log_record_edge_cases" {
  // æµ‹è¯•LogRecordçš„è¾¹ç¼˜æƒ…å†µ
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let min_timestamp = -9223372036854775808L  // æœ€å°Int64å€¼
  let max_timestamp = 9223372036854775807L   // æœ€å¤§Int64å€¼
  let zero_timestamp = 0L
  let current_timestamp = 1640995200000000000L
  
  let timestamps = [
    min_timestamp,
    max_timestamp,
    zero_timestamp,
    current_timestamp
  ]
  
  for timestamp in timestamps {
    let log_record = LogRecord::builder()
      .timestamp(timestamp)
      .body("Message with timestamp: " + timestamp.to_string())
      .build()
    
    // éªŒè¯æ—¶é—´æˆ³è®¾ç½®æ­£ç¡®
    assert_eq(log_record.timestamp_unix_nanos, timestamp)
    
    // éªŒè¯æ—¶é—´æˆ³çš„åˆç†æ€§æ£€æŸ¥
    let is_valid_timestamp = timestamp >= 0L  // ç®€åŒ–çš„éªŒè¯é€»è¾‘
    if is_valid_timestamp {
      assert_eq(timestamp >= 0L, true)
    }
  }
  
  // æµ‹è¯•ç‰¹æ®Šçš„æ—¥å¿—æ¶ˆæ¯
  let special_messages = [
    "",                                    // ç©ºæ¶ˆæ¯
    " ",                                   // åªæœ‰ç©ºæ ¼
    "a".repeat(10000),                     // è¶…é•¿æ¶ˆæ¯
    "Message with newlines\nand\ttabs",    // åŒ…å«æ§åˆ¶å­—ç¬¦
    "Message with \"quotes\" and 'apostrophes'", // åŒ…å«å¼•å·
    "Unicodeæµ‹è¯•æ¶ˆæ¯ğŸš€ğŸŒŸğŸ’«",                // Unicodeå’Œemoji
    "Message with <script>alert('xss')</script>", // XSSå°è¯•
    "'; DROP TABLE logs; --",              // SQLæ³¨å…¥å°è¯•
    "Message with back\\slashes",          // åæ–œæ 
    "Message with /forward/slashes",       // æ­£æ–œæ 
    "Message with @special #chars $here",   // ç‰¹æ®Šå­—ç¬¦
    "Message with multiple    spaces",     // å¤šä¸ªç©ºæ ¼
    "Message\nwith\nmultiple\nnewlines",   // å¤šä¸ªæ¢è¡Œç¬¦
    "Message\twith\tmultiple\ttabs",       // å¤šä¸ªåˆ¶è¡¨ç¬¦
  ]
  
  for message in special_messages {
    let log_record = LogRecord::builder()
      .severity(Info)
      .body(message)
      .build()
    
    match log_record.body {
      Some(body) => {
        assert_eq(body, message)
        
        // éªŒè¯æ¶ˆæ¯çš„ç‰¹æ®Šå±æ€§
        let is_empty = body.length() == 0
        let is_whitespace_only = body.trim().length() == 0 && body.length() > 0
        let is_very_long = body.length() > 5000
        let has_control_chars = body.contains("\n") || body.contains("\t")
        let has_quotes = body.contains("\"") || body.contains("'")
        let has_unicode = body.contains("æµ‹è¯•") || body.contains("ğŸš€")
        let has_xss = body.contains("<script") || body.contains("alert(")
        let has_sql_injection = body.contains("DROP TABLE") || body.contains("DELETE")
        let has_special_chars = body.contains("@") || body.contains("#") || body.contains("$")
        
        if is_empty {
          assert_eq(body, "")
        }
        
        if is_whitespace_only {
          assert_eq(body.trim().length(), 0)
        }
        
        if is_very_long {
          assert_eq(body.length() > 5000, true)
        }
        
        if has_control_chars {
          assert_eq(body.contains("\n") || body.contains("\t"), true)
        }
        
        if has_quotes {
          assert_eq(body.contains("\"") || body.contains("'"), true)
        }
        
        if has_unicode {
          assert_eq(body.contains("æµ‹è¯•") || body.contains("ğŸš€"), true)
        }
        
        if has_xss {
          assert_eq(body.contains("<script") || body.contains("alert("), true)
        }
        
        if has_sql_injection {
          assert_eq(body.contains("DROP TABLE") || body.contains("DELETE"), true)
        }
        
        if has_special_chars {
          assert_eq(body.contains("@") || body.contains("#") || body.contains("$"), true)
        }
      }
      None => @test.fail("Expected Some(body)")
    }
  }
  
  // æµ‹è¯•å¤æ‚çš„å±æ€§é›†åˆ
  let mut complex_attributes = []
  let mut i = 0
  while i < 100 {
    let key = "attribute_" + i.to_string()
    let value = if i % 4 == 0 {
      AttributeValue::string("string_value_" + i.to_string())
    } else if i % 4 == 1 {
      AttributeValue::int(i.to_int64())
    } else if i % 4 == 2 {
      AttributeValue::float(i.to_double())
    } else {
      AttributeValue::bool(i % 2 == 0)
    }
    complex_attributes.push((key, value))
    i = i + 1
  }
  
  let complex_log = LogRecord::builder()
    .severity(Info)
    .body("Log with many attributes")
    .build()
  
  // æ‰‹åŠ¨è®¾ç½®å¤æ‚å±æ€§ï¼ˆå› ä¸ºbuilderçš„with_attributeæ–¹æ³•ä¸€æ¬¡åªèƒ½æ·»åŠ ä¸€ä¸ªï¼‰
  let log_with_complex_attrs = LogRecord::{
    timestamp_unix_nanos: complex_log.timestamp_unix_nanos,
    observed_timestamp_unix_nanos: complex_log.observed_timestamp_unix_nanos,
    severity_number: complex_log.severity_number,
    severity_text: complex_log.severity_text,
    body: complex_log.body,
    attributes: complex_attributes,
    trace_id: complex_log.trace_id,
    span_id: complex_log.span_id,
    trace_flags: complex_log.trace_flags,
    resource: complex_log.resource,
    instrumentation_scope: complex_log.instrumentation_scope
  }
  
  // éªŒè¯å¤æ‚å±æ€§
  assert_eq(log_with_complex_attrs.attributes.length(), 100)
  
  // éªŒè¯ä¸åŒç±»å‹çš„å±æ€§
  match log_with_complex_attrs.attributes[0].1 {
    StringValue(value) => assert_eq(value, "string_value_0")
    _ => @test.fail("Expected StringValue")
  }
  
  match log_with_complex_attrs.attributes[1].1 {
    IntValue(value) => assert_eq(value, 1L)
    _ => @test.fail("Expected IntValue")
  }
  
  match log_with_complex_attrs.attributes[2].1 {
    FloatValue(value) => assert_eq(value, 2.0)
    _ => @test.fail("Expected FloatValue")
  }
  
  match log_with_complex_attrs.attributes[3].1 {
    BoolValue(value) => assert_eq(value, false)
    _ => @test.fail("Expected BoolValue")
  }
}

test "logs_logger_edge_cases" {
  // æµ‹è¯•Loggerçš„è¾¹ç¼˜æƒ…å†µ
  
  let logger_provider = NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("edge-case-logger", Some("1.0.0"), Some("https://example.com/schema"))
  
  // æµ‹è¯•å„ç§ç‰¹æ®Šçš„æ—¥å¿—æ¶ˆæ¯å’Œå±æ€§ç»„åˆ
  let edge_cases = [
    ("", []),                                                    // ç©ºæ¶ˆæ¯ï¼Œæ— å±æ€§
    (" ", []),                                                   // åªæœ‰ç©ºæ ¼ï¼Œæ— å±æ€§
    ("Normal message", []),                                      // æ­£å¸¸æ¶ˆæ¯ï¼Œæ— å±æ€§
    ("Message with attributes", [("key", AttributeValue::string("value"))]), // ç®€å•å±æ€§
    ("", [("key", AttributeValue::string("value"))]),            // ç©ºæ¶ˆæ¯ï¼Œæœ‰å±æ€§
    (" ".repeat(100), []),                                       // é•¿ç©ºæ ¼æ¶ˆæ¯
    ("Message".repeat(1000), []),                                // è¶…é•¿æ¶ˆæ¯
    ("Unicodeæµ‹è¯•ğŸš€", []),                                        // Unicodeæ¶ˆæ¯
    ("Message\nwith\nnewlines", []),                             // åŒ…å«æ¢è¡Œç¬¦
    ("Message\twith\ttabs", []),                                 // åŒ…å«åˆ¶è¡¨ç¬¦
    ("Message with \"quotes\"", []),                             // åŒ…å«å¼•å·
    ("Message with 'apostrophes'", []),                          // åŒ…å«æ’‡å·
    ("Message with <script>alert('xss')</script>", []),          // XSSå°è¯•
    ("'; DROP TABLE logs; --", []),                             // SQLæ³¨å…¥å°è¯•
  ]
  
  for (message, attributes) in edge_cases {
    // æµ‹è¯•æ‰€æœ‰æ—¥å¿—çº§åˆ«çš„æ–¹æ³•
    logger.debug(message, attributes)
    logger.info(message, attributes)
    logger.warn(message, attributes)
    logger.error(message, attributes)
    logger.fatal(message, attributes)
    
    // éªŒè¯æ“ä½œä¸ä¼šå´©æºƒ
    assert_eq(true, true)
    
    // éªŒè¯æ¶ˆæ¯çš„åŸºæœ¬å±æ€§
    let is_empty = message.length() == 0
    let is_whitespace_only = message.trim().length() == 0 && message.length() > 0
    let is_very_long = message.length() > 5000
    let has_control_chars = message.contains("\n") || message.contains("\t")
    let has_quotes = message.contains("\"") || message.contains("'")
    let has_unicode = message.contains("æµ‹è¯•") || message.contains("ğŸš€")
    let has_xss = message.contains("<script") || message.contains("alert(")
    let has_sql_injection = message.contains("DROP TABLE") || message.contains("DELETE")
    
    if is_empty {
      assert_eq(message, "")
    }
    
    if is_whitespace_only {
      assert_eq(message.trim().length(), 0)
    }
    
    if is_very_long {
      assert_eq(message.length() > 5000, true)
    }
    
    if has_control_chars {
      assert_eq(message.contains("\n") || message.contains("\t"), true)
    }
    
    if has_quotes {
      assert_eq(message.contains("\"") || message.contains("'"), true)
    }
    
    if has_unicode {
      assert_eq(message.contains("æµ‹è¯•") || message.contains("ğŸš€"), true)
    }
    
    if has_xss {
      assert_eq(message.contains("<script") || message.contains("alert("), true)
    }
    
    if has_sql_injection {
      assert_eq(message.contains("DROP TABLE") || message.contains("DELETE"), true)
    }
  }
  
  // æµ‹è¯•å¤æ‚çš„å±æ€§ç»„åˆ
  let complex_attributes = [
    ("string.key", AttributeValue::string("string value")),
    ("int.key", AttributeValue::int(42L)),
    ("float.key", AttributeValue::float(3.14)),
    ("bool.key", AttributeValue::bool(true)),
    ("array.string", AttributeValue::array_string(["a", "b", "c"])),
    ("array.int", AttributeValue::array_int([1L, 2L, 3L])),
    ("array.float", AttributeValue::array_float([1.1, 2.2, 3.3])),
    ("array.bool", AttributeValue::array_bool([true, false, true])),
    ("empty.string", AttributeValue::string("")),
    ("empty.array", AttributeValue::array_string([])),
    ("unicode.key", AttributeValue::string("Unicodeå€¼ğŸš€")),
    ("special.chars", AttributeValue::string("!@#$%^&*()")),
  ]
  
  // ä½¿ç”¨å¤æ‚å±æ€§æµ‹è¯•æ‰€æœ‰æ—¥å¿—çº§åˆ«
  logger.debug("Debug with complex attributes", complex_attributes)
  logger.info("Info with complex attributes", complex_attributes)
  logger.warn("Warn with complex attributes", complex_attributes)
  logger.error("Error with complex attributes", complex_attributes)
  logger.fatal("Fatal with complex attributes", complex_attributes)
  
  // éªŒè¯æ“ä½œä¸ä¼šå´©æºƒ
  assert_eq(true, true)
  
  // éªŒè¯å¤æ‚å±æ€§çš„åŸºæœ¬å±æ€§
  assert_eq(complex_attributes.length(), 12)
  
  // éªŒè¯ä¸åŒç±»å‹çš„å±æ€§
  match complex_attributes[0].1 {
    StringValue(value) => assert_eq(value, "string value")
    _ => @test.fail("Expected StringValue")
  }
  
  match complex_attributes[1].1 {
    IntValue(value) => assert_eq(value, 42L)
    _ => @test.fail("Expected IntValue")
  }
  
  match complex_attributes[2].1 {
    FloatValue(value) => assert_eq(value, 3.14)
    _ => @test.fail("Expected FloatValue")
  }
  
  match complex_attributes[3].1 {
    BoolValue(value) => assert_eq(value, true)
    _ => @test.fail("Expected BoolValue")
  }
}
