// é”™è¯¯å¤„ç†å’Œå¼‚å¸¸æƒ…å†µæµ‹è¯•
// æµ‹è¯•å„ç§é”™è¯¯åœºæ™¯ã€å¼‚å¸¸å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶

use azimuth.telemetry.api.common
use azimuth.telemetry.api.trace
use azimuth.telemetry.api.metrics
use azimuth.telemetry.api.logs

test "trace_error_handling" {
  // æµ‹è¯•è¿½è¸ªé”™è¯¯å¤„ç†
  
  // æµ‹è¯•æ— æ•ˆçš„SpanContext
  let invalid_trace_id = [] : Array[Byte] // ç©ºtrace_id
  let invalid_span_id = [] : Array[Byte]  // ç©ºspan_id
  
  // åˆ›å»ºæ— æ•ˆçš„SpanContextï¼ˆè¿™åº”è¯¥è¢«å¤„ç†è€Œä¸æ˜¯å´©æºƒï¼‰
  let invalid_context = trace::SpanContext::{
    trace_id: invalid_trace_id,
    span_id: invalid_span_id,
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  // éªŒè¯æ— æ•ˆä¸Šä¸‹æ–‡å¤„ç†
  assert_eq(invalid_context.trace_id.length(), 0)
  assert_eq(invalid_context.span_id.length(), 0)
  
  // æµ‹è¯•å…¨é›¶çš„trace_idå’Œspan_idï¼ˆåœ¨æŸäº›æƒ…å†µä¸‹æ˜¯æ— æ•ˆçš„ï¼‰
  let zero_trace_id = [for i = 0; i < 16; i = i + 1].map(fn(_) { 0_byte })
  let zero_span_id = [for i = 0; i < 8; i = i + 1].map(fn(_) { 0_byte })
  
  let zero_context = trace::SpanContext::{
    trace_id: zero_trace_id,
    span_id: zero_span_id,
    trace_flags: 0_byte,
    trace_state: ""
  }
  
  // éªŒè¯å…¨é›¶ä¸Šä¸‹æ–‡
  let mut all_zero_trace = true
  let mut i = 0
  while i < zero_context.trace_id.length() {
    if zero_context.trace_id[i] != 0_byte {
      all_zero_trace = false
    }
    i = i + 1
  }
  
  let mut all_zero_span = true
  i = 0
  while i < zero_context.span_id.length() {
    if zero_context.span_id[i] != 0_byte {
      all_zero_span = false
    }
    i = i + 1
  }
  
  assert_eq(all_zero_trace, true)
  assert_eq(all_zero_span, true)
  
  // æµ‹è¯•æ— æ•ˆçš„æ—¶é—´æˆ³
  let invalid_timestamp_span = trace::Span::{
    name: "invalid-timestamp-span",
    context: zero_context,
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: -1L, // è´Ÿæ—¶é—´æˆ³
    end_time_unix_nanos: Some(-1L), // è´Ÿç»“æŸæ—¶é—´
    status: trace::Error,
    status_description: Some("Invalid timestamp"),
    attributes: [],
    events: [],
    links: []
  }
  
  // éªŒè¯æ— æ•ˆæ—¶é—´æˆ³å¤„ç†
  assert_eq(invalid_timestamp_span.start_time_unix_nanos, -1L)
  assert_eq(invalid_timestamp_span.end_time_unix_nanos.unwrap(), -1L)
  
  // æµ‹è¯•æ—¶é—´é¡ºåºé”™è¯¯çš„Span
  let wrong_order_span = trace::Span::{
    name: "wrong-order-span",
    context: zero_context,
    kind: trace::Internal,
    parent_span_id: None,
    start_time_unix_nanos: 1640995300L, // å¼€å§‹æ—¶é—´æ™šäºç»“æŸæ—¶é—´
    end_time_unix_nanos: Some(1640995200L),
    status: trace::Error,
    status_description: Some("Wrong time order"),
    attributes: [],
    events: [],
    links: []
  }
  
  // éªŒè¯æ—¶é—´é¡ºåºé”™è¯¯
  assert_eq(wrong_order_span.start_time_unix_nanos > wrong_order_span.end_time_unix_nanos.unwrap(), true)
}

test "metrics_error_handling" {
  // æµ‹è¯•æŒ‡æ ‡é”™è¯¯å¤„ç†
  
  let noop_meter_provider = metrics::NoopMeterProvider::{}
  let meter = noop_meter_provider.get_meter("error-test-meter", "1.0.0")
  
  // æµ‹è¯•ç©ºæŒ‡æ ‡åç§°
  let empty_name_counter = meter.create_counter("", "count", "Empty name counter")
  let empty_name_histogram = meter.create_histogram("", "ms", "Empty name histogram")
  let empty_name_up_down = meter.create_up_down_counter("", "count", "Empty name up-down counter")
  let empty_name_gauge = meter.create_gauge("", "percent", "Empty name gauge")
  
  // æµ‹è¯•ç©ºæŒ‡æ ‡åç§°æ“ä½œï¼ˆåº”è¯¥ä¸å´©æºƒï¼‰
  empty_name_counter.add(1L, [("test", common::AttributeValue::string("empty_name"))])
  empty_name_histogram.record(100.0, [("test", common::AttributeValue::string("empty_name"))])
  empty_name_up_down.add(-1L, [("test", common::AttributeValue::string("empty_name"))])
  empty_name_gauge.record(50.0, [("test", common::AttributeValue::string("empty_name"))])
  
  assert_eq(true, true)
  
  // æµ‹è¯•æé•¿æŒ‡æ ‡åç§°
  let long_name = "metric_" + "x" * 1000
  let long_name_counter = meter.create_counter(long_name, "count", "Very long name counter")
  
  long_name_counter.add(1L, [("test", common::AttributeValue::string("long_name"))])
  
  assert_eq(true, true)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æŒ‡æ ‡åç§°
  let special_names = [
    "metric.with.dots",
    "metric-with-dashes",
    "metric_with_underscores",
    "metric/with/slashes",
    "metric\\with\\backslashes",
    "metric@with@symbols",
    "metric with spaces",
    "æŒ‡æ ‡ä¸­æ–‡åç§°",
    "Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ°-Ñ€ÑƒÑÑĞºĞ¸Ğ¹",
    "mÃ©trique-franÃ§ais"
  ]
  
  let mut i = 0
  while i < special_names.length() {
    let special_counter = meter.create_counter(special_names[i], "count", "Special name counter")
    special_counter.add(1L, [("name", common::AttributeValue::string(special_names[i]))])
    i = i + 1
  }
  
  assert_eq(true, true)
  
  // æµ‹è¯•æ— æ•ˆçš„å±æ€§é”®
  let invalid_keys = [
    "", // ç©ºé”®
    " ", // ç©ºæ ¼é”®
    "key with\nnewline", // åŒ…å«æ¢è¡Œç¬¦
    "key with\ttab", // åŒ…å«åˆ¶è¡¨ç¬¦
    "key\x00with\x00null", // åŒ…å«nullå­—ç¬¦
    "ä¸­æ–‡å­—ç¬¦é”®", // ä¸­æ–‡å­—ç¬¦
    "ĞºĞ»ÑÑ‡-Ñ€ÑƒÑÑĞºĞ¸Ğ¹" // ä¿„æ–‡å­—ç¬¦
  ]
  
  let counter = meter.create_counter("invalid-keys-test", "count", "Invalid keys test")
  
  i = 0
  while i < invalid_keys.length() {
    counter.add(1L, [(invalid_keys[i], common::AttributeValue::string("test"))])
    i = i + 1
  }
  
  assert_eq(true, true)
}

test "logs_error_handling" {
  // æµ‹è¯•æ—¥å¿—é”™è¯¯å¤„ç†
  
  let noop_logger_provider = logs::NoopLoggerProvider::{}
  let logger = noop_logger_provider.get_logger("error-test-logger", "1.0.0")
  
  // æµ‹è¯•ç©ºæ—¥å¿—æ¶ˆæ¯
  logger.debug("", [])
  logger.info("", [])
  logger.warn("", [])
  logger.error("", [])
  logger.fatal("", [])
  
  // æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯
  let long_message = "This is a very long log message " + "x" * 10000
  logger.debug(long_message, [("message_type", common::AttributeValue::string("long"))])
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—æ¶ˆæ¯
  let special_messages = [
    "Message with\nnewlines\nand\nmultiple\nlines",
    "Message with\ttabs\tand\tformatting",
    "Message with\x00null\x00characters",
    "Message with \"quotes\" and 'apostrophes'",
    "Message with <html> &entities;",
    "Message with emojis ğŸš€ğŸ”¥ğŸ’¯",
    "ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯æµ‹è¯•",
    "Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ",
    "Message en franÃ§ais avec accents: Ã©Ã Ã¨Ã¹Ã§",
    "ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ—¥æœ¬èª"
  ]
  
  let mut i = 0
  while i < special_messages.length() {
    logger.info(special_messages[i], [("message_index", common::AttributeValue::int(i.to_int64()))])
    i = i + 1
  }
  
  assert_eq(true, true)
  
  // æµ‹è¯•æ— æ•ˆçš„æ—¥å¿—è®°å½•
  let invalid_log_records = [
    // è´Ÿæ—¶é—´æˆ³
    logs::LogRecord::{
      timestamp_unix_nanos: -1L,
      observed_timestamp_unix_nanos: Some(-1L),
      severity_number: logs::Error,
      severity_text: Some("ERROR"),
      body: Some("Negative timestamp"),
      attributes: [],
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    },
    // è§‚å¯Ÿæ—¶é—´æ—©äºè®°å½•æ—¶é—´
    logs::LogRecord::{
      timestamp_unix_nanos: 1640995300L,
      observed_timestamp_unix_nanos: Some(1640995200L),
      severity_number: logs::Warn,
      severity_text: Some("WARN"),
      body: Some("Observed time earlier than record time"),
      attributes: [],
      trace_id: None,
      span_id: None,
      trace_flags: None,
      resource: None,
      instrumentation_scope: None
    },
    // ç©ºtrace_idä½†éç©ºspan_id
    logs::LogRecord::{
      timestamp_unix_nanos: 1640995200L,
      observed_timestamp_unix_nanos: None,
      severity_number: logs::Info,
      severity_text: Some("INFO"),
      body: Some("Empty trace_id with non-empty span_id"),
      attributes: [],
      trace_id: Some([] : Array[Byte]),
      span_id: Some([for i = 0; i < 8; i = i + 1].map(fn(_) { 1_byte })),
      trace_flags: Some(1_byte),
      resource: None,
      instrumentation_scope: None
    }
  ]
  
  // å‘é€æ— æ•ˆæ—¥å¿—è®°å½•
  i = 0
  while i < invalid_log_records.length() {
    logger.emit(invalid_log_records[i])
    i = i + 1
  }
  
  assert_eq(true, true)
}

test "attribute_value_error_handling" {
  // æµ‹è¯•å±æ€§å€¼é”™è¯¯å¤„ç†
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²å±æ€§
  let very_long_string = "x" * 100000
  let long_string_attr = common::AttributeValue::string(very_long_string)
  
  match long_string_attr {
    StringValue(s) => assert_eq(s.length(), 100000)
    _ => assert_eq(false, true)
  }
  
  // æµ‹è¯•æå¤§æ•´æ•°å±æ€§
  let max_int = 9223372036854775807L
  let min_int = -9223372036854775808L
  let max_int_attr = common::AttributeValue::int(max_int)
  let min_int_attr = common::AttributeValue::int(min_int)
  
  match max_int_attr {
    IntValue(i) => assert_eq(i, max_int)
    _ => assert_eq(false, true)
  }
  
  match min_int_attr {
    IntValue(i) => assert_eq(i, min_int)
    _ => assert_eq(false, true)
  }
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹æ•°å€¼
  let special_floats = [
    1.0/0.0,    // æ­£æ— ç©·
    -1.0/0.0,   // è´Ÿæ— ç©·
    0.0/0.0,    // NaN
    1.7976931348623157e+308, // æœ€å¤§åŒç²¾åº¦
    -1.7976931348623157e+308, // æœ€å°åŒç²¾åº¦
    4.9406564584124654e-324, // æœ€å°æ­£åŒç²¾åº¦
    -4.9406564584124654e-324 // æœ€å°è´ŸåŒç²¾åº¦
  ]
  
  let mut i = 0
  while i < special_floats.length() {
    let float_attr = common::AttributeValue::float(special_floats[i])
    match float_attr {
      FloatValue(f) => {
        if i == 2 { // NaNæµ‹è¯•
          assert_eq(f.is_nan(), true)
        } else if i == 0 || i == 1 { // æ— ç©·æµ‹è¯•
          assert_eq(f.is_infinite(), true)
        } else {
          assert_eq(f, special_floats[i])
        }
      }
      _ => assert_eq(false, true)
    }
    i = i + 1
  }
  
  // æµ‹è¯•æé•¿æ•°ç»„
  let very_long_string_array = [] : Array[String]
  let very_long_int_array = [] : Array[Int64]
  let very_long_float_array = [] : Array[Double]
  let very_long_bool_array = [] : Array[Bool]
  
  let mut i = 0
  while i < 1000 {
    very_long_string_array.push("item_" + i.to_string())
    very_long_int_array.push(i.to_int64())
    very_long_float_array.push(i.to_double())
    very_long_bool_array.push(i % 2 == 0)
    i = i + 1
  }
  
  let long_string_array_attr = common::AttributeValue::array_string(very_long_string_array)
  let long_int_array_attr = common::AttributeValue::array_int(very_long_int_array)
  let long_float_array_attr = common::AttributeValue::array_float(very_long_float_array)
  let long_bool_array_attr = common::AttributeValue::array_bool(very_long_bool_array)
  
  match long_string_array_attr {
    ArrayStringValue(arr) => assert_eq(arr.length(), 1000)
    _ => assert_eq(false, true)
  }
  
  match long_int_array_attr {
    ArrayIntValue(arr) => assert_eq(arr.length(), 1000)
    _ => assert_eq(false, true)
  }
  
  match long_float_array_attr {
    ArrayFloatValue(arr) => assert_eq(arr.length(), 1000)
    _ => assert_eq(false, true)
  }
  
  match long_bool_array_attr {
    ArrayBoolValue(arr) => assert_eq(arr.length(), 1000)
    _ => assert_eq(false, true)
  }
}

test "resource_error_handling" {
  // æµ‹è¯•èµ„æºé”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºæœåŠ¡å
  let empty_service_resource = common::Resource::{
    service_name: "",
    service_version: Some("1.0.0"),
    telemetry_sdk_name: "test-sdk",
    telemetry_sdk_version: "1.0.0",
    attributes: []
  }
  
  assert_eq(empty_service_resource.service_name, "")
  
  // æµ‹è¯•æé•¿æœåŠ¡å
  let very_long_service_name = "service-" + "x" * 10000
  let long_service_resource = common::Resource::{
    service_name: very_long_service_name,
    service_version: None,
    telemetry_sdk_name: "",
    telemetry_sdk_version: "",
    attributes: []
  }
  
  assert_eq(long_service_resource.service_name.length(), 10008)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æœåŠ¡å
  let special_service_names = [
    "service with spaces",
    "service/with/slashes",
    "service\\with\\backslashes",
    "service@with@symbols",
    "æœåŠ¡åç§°",
    "ÑĞµÑ€Ğ²Ğ¸Ñ-Ñ€ÑƒÑÑĞºĞ¸Ğ¹",
    "servicefranÃ§ais"
  ]
  
  let mut i = 0
  while i < special_service_names.length() {
    let special_resource = common::Resource::{
      service_name: special_service_names[i],
      service_version: None,
      telemetry_sdk_name: "test-sdk",
      telemetry_sdk_version: "1.0.0",
      attributes: []
    }
    assert_eq(special_resource.service_name, special_service_names[i])
    i = i + 1
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attributes = [] : Array[(String, common::AttributeValue)]
  let mut i = 0
  
  while i < 10000 {
    many_attributes.push(("attr" + i.to_string(), common::AttributeValue::string("value" + i.to_string())))
    i = i + 1
  }
  
  let many_attrs_resource = common::Resource::{
    service_name: "test-service",
    service_version: None,
    telemetry_sdk_name: "test-sdk",
    telemetry_sdk_version: "1.0.0",
    attributes: many_attributes
  }
  
  assert_eq(many_attrs_resource.attributes.length(), 10000)
}

test "instrumentation_scope_error_handling" {
  // æµ‹è¯•å·¥å…·èŒƒå›´é”™è¯¯å¤„ç†
  
  // æµ‹è¯•ç©ºå·¥å…·èŒƒå›´åç§°
  let empty_scope = common::InstrumentationScope::{
    name: "",
    version: None,
    schema_url: None
  }
  
  assert_eq(empty_scope.name, "")
  
  // æµ‹è¯•æé•¿å·¥å…·èŒƒå›´åç§°
  let very_long_scope_name = "scope-" + "x" * 10000
  let long_scope = common::InstrumentationScope::{
    name: very_long_scope_name,
    version: Some("1.0.0"),
    schema_url: Some("http://example.com/very/long/schema/url/" + "x" * 1000)
  }
  
  assert_eq(long_scope.name.length(), 10006)
  assert_eq(long_scope.version.unwrap(), "1.0.0")
  assert_eq(long_scope.schema_url.unwrap().length(), 1053)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å·¥å…·èŒƒå›´åç§°
  let special_scope_names = [
    "scope with spaces",
    "scope/with/slashes",
    "scope\\with\\backslashes",
    "å·¥å…·èŒƒå›´",
    "Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ-Ñ€ÑƒÑÑĞºĞ¸Ğ¹",
    "portÃ©e-franÃ§ais"
  ]
  
  let mut i = 0
  while i < special_scope_names.length() {
    let special_scope = common::InstrumentationScope::{
      name: special_scope_names[i],
      version: Some("1.0.0"),
      schema_url: Some("http://example.com/schema")
    }
    assert_eq(special_scope.name, special_scope_names[i])
    i = i + 1
  }
  
  // æµ‹è¯•æ— æ•ˆçš„schema URL
  let invalid_schema_urls = [
    "",
    "not-a-url",
    "http://",
    "ftp://invalid.protocol",
    "http://[invalid-ipv6",
    "http://example.com:99999", // æ— æ•ˆç«¯å£
    "http://user:pass@example.com" // åŒ…å«è®¤è¯ä¿¡æ¯
  ]
  
  let mut i = 0
  while i < invalid_schema_urls.length() {
    let invalid_scope = common::InstrumentationScope::{
      name: "test-scope",
      version: None,
      schema_url: Some(invalid_schema_urls[i])
    }
    assert_eq(invalid_scope.schema_url.unwrap(), invalid_schema_urls[i])
    i = i + 1
  }
}

test "concurrent_error_scenarios" {
  // æµ‹è¯•å¹¶å‘é”™è¯¯åœºæ™¯
  
  let noop_meter_provider = metrics::NoopMeterProvider::{}
  let meter = noop_meter_provider.get_meter("concurrent-test-meter", "1.0.0")
  let counter = meter.create_counter("concurrent-counter", "count", "Concurrent test counter")
  
  let noop_logger_provider = logs::NoopLoggerProvider::{}
  let logger = noop_logger_provider.get_logger("concurrent-test-logger", "1.0.0")
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œï¼ˆåœ¨å•çº¿ç¨‹ç¯å¢ƒä¸­æ¨¡æ‹Ÿï¼‰
  let mut i = 0
  
  // å¹¶å‘è®¡æ•°å™¨æ“ä½œ
  while i < 100 {
    counter.add(1L, [
      ("thread.id", common::AttributeValue::int(i.to_int64())),
      ("operation", common::AttributeValue::string("concurrent_add"))
    ])
    i = i + 1
  }
  
  // å¹¶å‘æ—¥å¿—æ“ä½œ
  i = 0
  while i < 100 {
    logger.info("Concurrent log message " + i.to_string(), [
      ("message.id", common::AttributeValue::int(i.to_int64())),
      ("thread", common::AttributeValue::string("thread-" + i.to_string()))
    ])
    i = i + 1
  }
  
  // å¹¶å‘Spanåˆ›å»ºï¼ˆæ¨¡æ‹Ÿï¼‰
  let concurrent_spans = [] : Array[trace::Span]
  i = 0
  while i < 100 {
    let span_context = trace::SpanContext::{
      trace_id: [for j = 0; j < 16; j = j + 1].map(fn(j) { ((i + j) % 256).to_byte() }),
      span_id: [for j = 0; j < 8; j = j + 1].map(fn(j) { ((i + j) % 256).to_byte() }),
      trace_flags: 1_byte,
      trace_state: ""
    }
    
    let span = trace::Span::{
      name: "concurrent-span-" + i.to_string(),
      context: span_context,
      kind: trace::Internal,
      parent_span_id: None,
      start_time_unix_nanos: 1640995200L + i.to_int64(),
      end_time_unix_nanos: Some(1640995300L + i.to_int64()),
      status: trace::Ok,
      status_description: Some("Concurrent span completed"),
      attributes: [
        ("span.id", common::AttributeValue::int(i.to_int64())),
        ("thread", common::AttributeValue::string("thread-" + i.to_string()))
      ],
      events: [],
      links: []
    }
    
    concurrent_spans.push(span)
    i = i + 1
  }
  
  // éªŒè¯å¹¶å‘æ“ä½œç»“æœ
  assert_eq(concurrent_spans.length(), 100)
  
  // éªŒè¯æ‰€æœ‰Spanéƒ½æœ‰å”¯ä¸€çš„ä¸Šä¸‹æ–‡
  i = 0
  while i < concurrent_spans.length() {
    let mut j = i + 1
    while j < concurrent_spans.length() {
      // æ£€æŸ¥span_idæ˜¯å¦å”¯ä¸€
      let mut span_id_equal = true
      let mut k = 0
      while k < concurrent_spans[i].context.span_id.length() {
        if concurrent_spans[i].context.span_id[k] != concurrent_spans[j].context.span_id[k] {
          span_id_equal = false
        }
        k = k + 1
      }
      
      // åœ¨æˆ‘ä»¬çš„æ¨¡æ‹Ÿä¸­ï¼Œspan_idåº”è¯¥æ˜¯å”¯ä¸€çš„
      if i != j {
        assert_eq(span_id_equal, false)
      }
      
      j = j + 1
    }
    i = i + 1
  }
}

test "memory_pressure_scenarios" {
  // æµ‹è¯•å†…å­˜å‹åŠ›åœºæ™¯
  
  let noop_meter_provider = metrics::NoopMeterProvider::{}
  let meter = noop_meter_provider.get_meter("memory-test-meter", "1.0.0")
  
  // åˆ›å»ºå¤§é‡æŒ‡æ ‡
  let many_counters = [] : Array[metrics::Counter]
  let mut i = 0
  
  while i < 1000 {
    let counter = meter.create_counter("counter_" + i.to_string(), "count", "Counter " + i.to_string())
    many_counters.push(counter)
    i = i + 1
  }
  
  // éªŒè¯å¤§é‡æŒ‡æ ‡åˆ›å»º
  assert_eq(many_counters.length(), 1000)
  
  // å¯¹æ¯ä¸ªæŒ‡æ ‡æ‰§è¡Œå¤šæ¬¡æ“ä½œ
  i = 0
  while i < many_counters.length() {
    let mut j = 0
    while j < 10 {
      many_counters[i].add(1L, [
        ("counter.id", common::AttributeValue::int(i.to_int64())),
        ("operation.id", common::AttributeValue::int(j.to_int64()))
      ])
      j = j + 1
    }
    i = i + 1
  }
  
  // åˆ›å»ºå¤§é‡æ—¥å¿—è®°å½•
  let noop_logger_provider = logs::NoopLoggerProvider::{}
  let logger = noop_logger_provider.get_logger("memory-test-logger", "1.0.0")
  
  i = 0
  while i < 1000 {
    let large_attributes = [] : Array[(String, common::AttributeValue)]
    let mut j = 0
    
    while j < 100 {
      large_attributes.push(("attr" + j.to_string(), common::AttributeValue::string("value" + j.to_string())))
      j = j + 1
    }
    
    logger.info("Memory test log message " + i.to_string(), large_attributes)
    i = i + 1
  }
  
  // åˆ›å»ºå¤§é‡Span
  let many_spans = [] : Array[trace::Span]
  i = 0
  
  while i < 1000 {
    let many_events = [] : Array[trace::SpanEvent]
    let mut j = 0
    
    while j < 10 {
      let event = trace::SpanEvent::{
        name: "event" + j.to_string(),
        timestamp_unix_nanos: 1640995200L + i.to_int64() + j.to_int64(),
        attributes: [
          ("event.id", common::AttributeValue::int(j.to_int64())),
          ("data", common::AttributeValue::string("event data " + j.to_string()))
        ]
      }
      many_events.push(event)
      j = j + 1
    }
    
    let span = trace::Span::{
      name: "memory-span-" + i.to_string(),
      context: trace::SpanContext::{
        trace_id: [for j = 0; j < 16; j = j + 1].map(fn(j) { ((i + j) % 256).to_byte() }),
        span_id: [for j = 0; j < 8; j = j + 1].map(fn(j) { ((i + j) % 256).to_byte() }),
        trace_flags: 1_byte,
        trace_state: ""
      },
      kind: trace::Internal,
      parent_span_id: None,
      start_time_unix_nanos: 1640995200L + i.to_int64(),
      end_time_unix_nanos: Some(1640995300L + i.to_int64()),
      status: trace::Ok,
      status_description: Some("Memory test span completed"),
      attributes: [("span.id", common::AttributeValue::int(i.to_int64()))],
      events: many_events,
      links: []
    }
    
    many_spans.push(span)
    i = i + 1
  }
  
  // éªŒè¯å†…å­˜å‹åŠ›åœºæ™¯å¤„ç†
  assert_eq(many_spans.length(), 1000)
  assert_eq(many_spans[0].events.length(), 10)
  assert_eq(many_spans[999].events.length(), 10)
}