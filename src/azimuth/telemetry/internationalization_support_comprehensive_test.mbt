// å›½é™…åŒ–æ”¯æŒç»¼åˆæµ‹è¯•

test "unicode_attribute_values_support" {
  // æµ‹è¯•Unicodeå±æ€§å€¼æ”¯æŒ
  let unicode_attributes = [
    ("chinese", common::AttributeValue::string("ä¸­æ–‡æµ‹è¯•")),
    ("japanese", common::AttributeValue::string("æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ")),
    ("korean", common::AttributeValue::string("í•œêµ­ì–´ í…ŒìŠ¤íŠ¸")),
    ("arabic", common::AttributeValue::string("Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ")),
    ("russian", common::AttributeValue::string("Ğ ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµÑÑ‚")),
    ("emoji", common::AttributeValue::string("ğŸš€ğŸ‰ğŸŒŸ")),
    ("mixed", common::AttributeValue::string("English ä¸­æ–‡ ğŸŒŸ æ—¥æœ¬èª")),
    ("special_chars", common::AttributeValue::string("Ã±Ã¼Ã§Ã¸Ã±ÃŸ")),
    ("math_symbols", common::AttributeValue::string("âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚")),
    ("currency", common::AttributeValue::string("Â¥â‚¬Â£$â‚¹â‚½"))
  ]
  
  // éªŒè¯Unicodeå±æ€§å€¼
  for i = 0; i < unicode_attributes.length; i = i + 1 {
    let (key, value) = unicode_attributes[i]
    
    match value {
      common::StringValue(s) => {
        @assertion.assert_true(s.length > 0)
        @assertion.assert_true(s.contains_unicode())
      }
      _ => @assertion.assert_true(false)
    }
  }
}

test "multilingual_span_names" {
  // æµ‹è¯•å¤šè¯­è¨€Spanåç§°
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("multilingual-tracer")
  
  let multilingual_names = [
    "ä¸­æ–‡æ“ä½œ",
    "æ—¥æœ¬èªæ“ä½œ",
    "í•œêµ­ì–´ ì‘ì—…",
    "Ø¹Ù…Ù„ÙŠØ© Ø¹Ø±Ø¨ÙŠØ©",
    "Ğ ÑƒÑÑĞºĞ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ",
    "OperaciÃ³n en espaÃ±ol",
    "OpÃ©ration franÃ§aise",
    "Deutsch Operation",
    "PortuguÃªs operaÃ§Ã£o",
    "ğŸš€ Rocket Launch ğŸš€",
    "Mixed ä¸­æ–‡ English ğŸŒŸ"
  ]
  
  // åˆ›å»ºå¤šè¯­è¨€Span
  let spans = Array[]::build(fn(push) {
    for i = 0; i < multilingual_names.length; i = i + 1 {
      let name = multilingual_names[i]
      let (ctx, span) = tracer.start_span(
        context::Context::empty(),
        name,
        trace::Internal,
        [("language", common::AttributeValue::string("unicode_support"))]
      )
      push(span)
    }
  })
  
  // éªŒè¯å¤šè¯­è¨€Span
  for i = 0; i < spans.length; i = i + 1 {
    let span = spans[i]
    @assertion.assert_eq(span.name, multilingual_names[i])
    @assertion.assert_eq(span.attributes.length, 1)
    @assertion.assert_true(span.name.contains_unicode())
  }
}

test "localized_error_messages" {
  // æµ‹è¯•æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯
  let error_messages = [
    ("zh", "è¿æ¥è¶…æ—¶"),
    ("ja", "æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"),
    ("ko", "ì—°ê²° ì‹œê°„ ì´ˆê³¼"),
    ("ar", "Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„"),
    ("ru", "Ğ¢Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ñ"),
    ("es", "Tiempo de conexiÃ³n agotado"),
    ("fr", "DÃ©lai de connexion dÃ©passÃ©"),
    ("de", "Verbindungs-Timeout"),
    ("pt", "Tempo limite de conexÃ£o excedido")
  ]
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("error-tracer")
  
  // åˆ›å»ºå¸¦æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯çš„Span
  for i = 0; i < error_messages.length; i = i + 1 {
    let (locale, message) = error_messages[i]
    let (ctx, span) = tracer.start_span(
      context::Context::empty(),
      "error_span",
      trace::Internal,
      [
        ("error_locale", common::AttributeValue::string(locale)),
        ("error_message", common::AttributeValue::string(message))
      ]
    )
    
    // éªŒè¯æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯
    @assertion.assert_eq(span.name, "error_span")
    @assertion.assert_eq(span.attributes.length, 2)
    @assertion.assert_true(message.contains_unicode())
  }
}

test "international_resource_names" {
  // æµ‹è¯•å›½é™…åŒ–èµ„æºåç§°
  let international_resources = [
    common::Resource::default("ä¸­æ–‡æœåŠ¡"),
    common::Resource::default("æ—¥æœ¬èªã‚µãƒ¼ãƒ“ã‚¹"),
    common::Resource::default("í•œêµ­ì–´ ì„œë¹„ìŠ¤"),
    common::Resource::default("Ø®Ø¯Ù…Ø© Ø¹Ø±Ø¨ÙŠØ©"),
    common::Resource::default("Ğ ÑƒÑÑĞºĞ°Ñ ÑĞ»ÑƒĞ¶Ğ±Ğ°"),
    common::Resource::default("Servicio en espaÃ±ol"),
    common::Resource::default("Service franÃ§ais"),
    common::Resource::default("Dienst Deutsch"),
    common::Resource::default("ServiÃ§o portuguÃªs"),
    common::Resource::default("ğŸš€ Rocket Service ğŸš€")
  ]
  
  // éªŒè¯å›½é™…åŒ–èµ„æºåç§°
  for i = 0; i < international_resources.length; i = i + 1 {
    let resource = international_resources[i]
    @assertion.assert_true(resource.service_name.length > 0)
    @assertion.assert_true(resource.service_name.contains_unicode())
    @assertion.assert_eq(resource.telemetry_sdk_name, "azimuth")
    @assertion.assert_eq(resource.telemetry_sdk_version, "0.1.0")
  }
}

test "multilingual_metric_descriptions" {
  // æµ‹è¯•å¤šè¯­è¨€æŒ‡æ ‡æè¿°
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("multilingual-meter")
  
  let metric_configs = [
    ("counter_zh", "è®¡æ•°å™¨", "ä¸­æ–‡è®¡æ•°å™¨æè¿°"),
    ("histogram_ja", "ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ", "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ èª¬æ˜"),
    ("gauge_ko", "ê²Œì´ì§€", "í•œêµ­ì–´ ê²Œì´ì§€ ì„¤ëª…"),
    ("counter_ar", "Ø¹Ø¯Ø§Ø¯", "ÙˆØµÙ Ø§Ù„Ø¹Ø¯Ø§Ø¯ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"),
    ("histogram_ru", "Ğ“Ğ¸ÑÑ‚Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°", "ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ³Ğ¸ÑÑ‚Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼"),
    ("gauge_es", "Indicador", "DescripciÃ³n del indicador en espaÃ±ol"),
    ("counter_fr", "Compteur", "Description du compteur en franÃ§ais"),
    ("histogram_de", "Histogramm", "Histogrammbeschreibung auf Deutsch")
  ]
  
  // åˆ›å»ºå¤šè¯­è¨€æŒ‡æ ‡
  for i = 0; i < metric_configs.length; i = i + 1 {
    let (name, unit, description) = metric_configs[i]
    
    let counter = meter.create_counter(name, unit, description)
    let histogram = meter.create_histogram("${name}_hist", unit, description)
    let gauge = meter.create_gauge("${name}_gauge", unit, description)
    
    // è®°å½•æŒ‡æ ‡ä»¥éªŒè¯å¤šè¯­è¨€æ”¯æŒ
    counter.add(1L, [("metric_language", common::AttributeValue::string("unicode"))])
    histogram.record(1.0, [("description", common::AttributeValue::string(description))])
    gauge.record(1.0, [("unit", common::AttributeValue::string(unit))])
    
    // éªŒè¯å¤šè¯­è¨€æè¿°
    @assertion.assert_true(description.contains_unicode())
    @assertion.assert_true(unit.contains_unicode())
  }
}

test "unicode_array_values" {
  // æµ‹è¯•Unicodeæ•°ç»„å€¼
  let unicode_arrays = [
    common::AttributeValue::array_string(["ä¸­æ–‡", "æ—¥æœ¬èª", "í•œêµ­ì–´"]),
    common::AttributeValue::array_string(["Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", "Ğ ÑƒÑÑĞºĞ¸Ğ¹", "EspaÃ±ol"]),
    common::AttributeValue::array_string(["FranÃ§ais", "Deutsch", "PortuguÃªs"]),
    common::AttributeValue::array_string(["ğŸš€", "ğŸ‰", "ğŸŒŸ", "ğŸ’«"]),
    common::AttributeValue::array_string(["CafÃ©", "RÃ©sumÃ©", "NaÃ¯ve", "PiÃ±ata"]),
    common::AttributeValue::array_string(["åŒ—äº¬", "æ±äº¬", "ì„œìš¸", "Ù…ÙˆØ³ÙƒÙˆ"]),
    common::AttributeValue::array_string(["âˆ‘", "âˆ", "âˆ«", "âˆ†", "âˆ‡", "âˆ‚"]),
    common::AttributeValue::array_string(["Â¥", "â‚¬", "Â£", "$", "â‚¹", "â‚½"])
  ]
  
  // éªŒè¯Unicodeæ•°ç»„
  for i = 0; i < unicode_arrays.length; i = i + 1 {
    let array_value = unicode_arrays[i]
    
    match array_value {
      common::ArrayStringValue(arr) => {
        @assertion.assert_true(arr.length > 0)
        for j = 0; j < arr.length; j = j + 1 {
          @assertion.assert_true(arr[j].contains_unicode())
        }
      }
      _ => @assertion.assert_true(false)
    }
  }
}

test "timezone_aware_timestamps" {
  // æµ‹è¯•æ—¶åŒºæ„ŸçŸ¥æ—¶é—´æˆ³
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("timezone-tracer")
  
  let timezone_configs = [
    ("UTC", "Coordinated Universal Time"),
    ("Asia/Shanghai", "ä¸­å›½æ ‡å‡†æ—¶é—´"),
    ("Asia/Tokyo", "æ—¥æœ¬æ¨™æº–æ™‚"),
    ("Asia/Seoul", "í•œêµ­ í‘œì¤€ì‹œ"),
    ("Europe/London", "Greenwich Mean Time"),
    ("Europe/Paris", "Central European Time"),
    ("America/New_York", "Eastern Standard Time"),
    ("America/Los_Angeles", "Pacific Standard Time")
  ]
  
  // åˆ›å»ºæ—¶åŒºæ„ŸçŸ¥çš„Span
  for i = 0; i < timezone_configs.length; i = i + 1 {
    let (timezone, description) = timezone_configs[i]
    let (ctx, span) = tracer.start_span(
      context::Context::empty(),
      "timezone_aware_span",
      trace::Internal,
      [
        ("timezone", common::AttributeValue::string(timezone)),
        ("timezone_description", common::AttributeValue::string(description)),
        ("timestamp", common::AttributeValue::int(1234567890L))
      ]
    )
    
    // éªŒè¯æ—¶åŒºä¿¡æ¯
    @assertion.assert_eq(span.name, "timezone_aware_span")
    @assertion.assert_eq(span.attributes.length, 3)
    @assertion.assert_true(description.contains_unicode())
  }
}

test "cultural_number_formats" {
  // æµ‹è¯•æ–‡åŒ–æ•°å­—æ ¼å¼
  let cultural_numbers = [
    ("western", "1,234.56"),
    ("european", "1.234,56"),
    ("chinese", "1,234.56"),
    ("arabic", "Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦"),
    ("hindi", "à¥§,à¥¨à¥©à¥ª.à¥«à¥¬"),
    ("bengali", "à§§,à§¨à§©à§ª.à§«à§¬"),
    ("persian", "Û±Ù¬Û²Û³Û´Ù«ÛµÛ¶")
  ]
  
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("cultural-meter")
  
  // åˆ›å»ºæ–‡åŒ–æ ¼å¼æ„ŸçŸ¥çš„æŒ‡æ ‡
  for i = 0; i < cultural_numbers.length; i = i + 1 {
    let (culture, formatted_number) = cultural_numbers[i]
    let gauge = meter.create_gauge("cultural_gauge_${culture}", "value", "Cultural number format")
    
    gauge.record(1234.56, [
      ("culture", common::AttributeValue::string(culture)),
      ("formatted_number", common::AttributeValue::string(formatted_number))
    ])
    
    // éªŒè¯æ–‡åŒ–æ•°å­—æ ¼å¼
    @assertion.assert_true(formatted_number.length > 0)
    @assertion.assert_true(formatted_number.contains_unicode())
  }
}

test "international_character_encoding" {
  // æµ‹è¯•å›½é™…å­—ç¬¦ç¼–ç 
  let encoding_test_strings = [
    "UTF-8: ä¸­æ–‡æµ‹è¯•",
    "UTF-8: æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ",
    "UTF-8: í•œêµ­ì–´ í…ŒìŠ¤íŠ¸",
    "UTF-8: Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ",
    "UTF-8: Ğ ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµÑÑ‚",
    "UTF-8: EspaÃ±ol Ã±Ã¼",
    "UTF-8: FranÃ§ais Ã§Ã©Ã Ã¨",
    "UTF-8: Deutsch Ã¤Ã¶Ã¼ÃŸ",
    "UTF-8: PortuguÃªs Ã£ÃµÃ§",
    "UTF-8: ğŸ‰ Emoji Test ğŸš€"
  ]
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("encoding-tracer")
  
  // åˆ›å»ºç¼–ç æµ‹è¯•Span
  for i = 0; i < encoding_test_strings.length; i = i + 1 {
    let test_string = encoding_test_strings[i]
    let (ctx, span) = tracer.start_span(
      context::Context::empty(),
      "encoding_test",
      trace::Internal,
      [
        ("encoding_test", common::AttributeValue::string(test_string)),
        ("string_length", common::AttributeValue::int(test_string.length.to_int64())),
        ("contains_unicode", common::AttributeValue::bool(test_string.contains_unicode()))
      ]
    )
    
    // éªŒè¯ç¼–ç æµ‹è¯•
    @assertion.assert_eq(span.name, "encoding_test")
    @assertion.assert_eq(span.attributes.length, 3)
    @assertion.assert_true(test_string.contains_unicode())
  }
}

test "multilingual_context_propagation" {
  // æµ‹è¯•å¤šè¯­è¨€ä¸Šä¸‹æ–‡ä¼ æ’­
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("multilingual-context-tracer")
  
  // åˆ›å»ºå¤šè¯­è¨€æ ¹ä¸Šä¸‹æ–‡
  let (root_ctx, root_span) = tracer.start_span(
    context::Context::empty(),
    "æ ¹æ“ä½œ",
    trace::Server,
    [
      ("locale", common::AttributeValue::string("zh-CN")),
      ("user_region", common::AttributeValue::string("äºšå¤ªåœ°åŒº")),
      ("operation_type", common::AttributeValue::string("æ•°æ®åº“æŸ¥è¯¢"))
    ]
  )
  
  // åˆ›å»ºå¤šè¯­è¨€å­æ“ä½œ
  let (child_ctx, child_span) = tracer.start_span(
    root_ctx,
    "å­æ“ä½œ",
    trace::Internal,
    [
      ("sub_operation", common::AttributeValue::string("ç¼“å­˜æ£€æŸ¥")),
      ("component", common::AttributeValue::string("ç¼“å­˜æœåŠ¡"))
    ]
  )
  
  // éªŒè¯å¤šè¯­è¨€ä¸Šä¸‹æ–‡ä¼ æ’­
  @assertion.assert_eq(root_span.name, "æ ¹æ“ä½œ")
  @assertion.assert_eq(child_span.name, "å­æ“ä½œ")
  @assertion.assert_eq(root_span.attributes.length, 3)
  @assertion.assert_eq(child_span.attributes.length, 2)
  
  // éªŒè¯Unicodeå†…å®¹
  @assertion.assert_true(root_span.name.contains_unicode())
  @assertion.assert_true(child_span.name.contains_unicode())
  
  for i = 0; i < root_span.attributes.length; i = i + 1 {
    let (key, value) = root_span.attributes[i]
    match value {
      common::StringValue(s) => @assertion.assert_true(s.contains_unicode())
      _ => @assertion.assert_true(false)
    }
  }
}