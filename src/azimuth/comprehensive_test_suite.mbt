// ç»¼åˆæµ‹è¯•å¥—ä»¶ - æ¶µç›–å„ç§æµ‹è¯•åœºæ™¯

// 1. æ•°å­¦å±žæ€§æµ‹è¯•
test "addition_associative_property" {
  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹ (a + b) + c = a + (b + c)
  let a = 15
  let b = 27
  let c = 42
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  let x = -10
  let y = 20
  let z = -5
  assert_eq(add(add(x, y), z), add(x, add(y, z)))
}

test "multiplication_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ a * (b + c) = a * b + a * c
  let a = 5
  let b = 10
  let c = 15
  assert_eq(multiply(a, add(b, c)), add(multiply(a, b), multiply(a, c)))
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  let x = -3
  let y = 8
  let z = -2
  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))
}

// 2. è¾¹ç•Œå€¼å’Œç‰¹æ®Šæƒ…å†µæµ‹è¯•
test "extreme_boundary_values" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼åŠ æ³•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(max_val, add(max_val, max_val))
  
  // æµ‹è¯•æœ€å°å€¼åŠ æ³•
  assert_eq(min_val, add(min_val, -1))
  assert_eq(min_val, add(min_val, min_val))
  
  // æµ‹è¯•æœ€å¤§å€¼ä¹˜æ³•
  assert_eq(max_val, multiply(max_val, 2))
  assert_eq(min_val, multiply(max_val, -2))
  
  // æµ‹è¯•æœ€å°å€¼ä¹˜æ³•
  assert_eq(min_val, multiply(min_val, 2))
  assert_eq(min_val, multiply(min_val, -1))
}

test "special_value_combinations" {
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å°å€¼ä¸Ž1çš„ä¹˜æ³•
  assert_eq(min_val, multiply(min_val, 1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸Ž-1çš„ä¹˜æ³•ï¼ˆç‰¹æ®Šæƒ…å†µï¼‰
  assert_eq(min_val, multiply(min_val, -1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸Ž0çš„åŠ æ³•
  assert_eq(min_val, add(min_val, 0))
  
  // æµ‹è¯•æœ€å°å€¼ä¸Ž0çš„ä¹˜æ³•
  assert_eq(0, multiply(min_val, 0))
}

// 3. å®žé™…åº”ç”¨åœºæ™¯æµ‹è¯•
test "financial_calculations" {
  // æ¨¡æ‹Ÿé‡‘èžè®¡ç®—ï¼šè®¡ç®—æ€»æŠ•èµ„
  let price_per_share = 157
  let shares = 1000
  let commission = 25
  let total_cost = add(multiply(price_per_share, shares), commission)
  assert_eq(157025, total_cost)
  
  // è®¡ç®—æ”¶ç›Š
  let sell_price = 165
  let proceeds = multiply(sell_price, shares)
  let profit = subtract(proceeds, total_cost)
  assert_eq(7975, profit)
}

test "inventory_management" {
  // åº“å­˜ç®¡ç†åœºæ™¯
  let initial_stock = 500
  let incoming = add(150, 75)  // ä¸¤æ‰¹è¿›è´§
  let outgoing = add(100, 200) // ä¸¤æ‰¹å‡ºè´§
  let final_stock = subtract(add(initial_stock, incoming), outgoing)
  assert_eq(425, final_stock)
}

// 4. å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
test "greet_function_edge_cases" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  assert_eq("Hello, @#$%!", greet("@#$%"))
  assert_eq("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq("Hello, ðŸŒ™!", greet("ðŸŒ™"))
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_name = "This is a very long name that tests the greet function"
  let expected = "Hello, " + long_name + "!"
  assert_eq(expected, greet(long_name))
}

// 5. æ€§èƒ½ç›¸å…³æµ‹è¯•
test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—ï¼ˆä½†ä¸æº¢å‡ºï¼‰
  let large_num = 1000000
  let result1 = add(large_num, large_num)
  assert_eq(2000000, result1)
  
  let result2 = multiply(large_num, 100)
  assert_eq(100000000, result2)
  
  // æµ‹è¯•è¿žç»­è¿ç®—
  let chain_result = add(add(add(1, 2), 3), 4)
  assert_eq(10, chain_result)
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•ï¼ˆç”¨äºŽæµ‹è¯•ï¼‰
fn subtract(a : Int, b : Int) -> Int {
  add(a, multiply(b, -1))
}