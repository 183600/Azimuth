// é¢å¤–å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“
// åŒ…å«é«˜çº§åŠŸèƒ½æµ‹è¯•å’Œå®é™…åº”ç”¨åœºæ™¯

test "mathematical_series_sum" {
  // æµ‹è¯•ç­‰å·®æ•°åˆ—æ±‚å’Œ
  let first_term = 5
  let common_diff = 3
  
  // æ‰‹åŠ¨è®¡ç®—ç­‰å·®æ•°åˆ—å’Œï¼š5 + 8 + 11 + 14 + 17 + 20
  let sum_manual = add(add(add(add(add(first_term, add(first_term, common_diff)), 
    add(first_term, multiply(2, common_diff))), 
    add(first_term, multiply(3, common_diff))), 
    add(add(first_term, multiply(4, common_diff)), add(first_term, multiply(5, common_diff))))
  
  assert_eq(75, sum_manual)
}

test "resource_allocation_optimization" {
  // æµ‹è¯•èµ„æºåˆ†é…ä¼˜åŒ–
  let total_budget = 5000
  let project_a_cost = 1200
  let project_b_cost = 800
  let project_c_cost = 1500
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let allocated = add(add(project_a_cost, project_b_cost), project_c_cost)
  let remaining = add(total_budget, -allocated)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„é¢å¤–å°é¡¹ç›®æ•°é‡
  let small_project_cost = 300
  let additional_projects = divide_with_ceil(remaining, small_project_cost)
  
  assert_eq(3500, allocated)
  assert_eq(1500, remaining)
  assert_eq(5, additional_projects)
}

test "time_zone_conversion" {
  // æµ‹è¯•æ—¶åŒºè½¬æ¢è®¡ç®—
  let local_time = 14  // ä¸‹åˆ2ç‚¹
  let time_difference = 8  // æ—¶å·®8å°æ—¶
  
  // è®¡ç®—ç›®æ ‡æ—¶åŒºæ—¶é—´
  let target_time = add(local_time, time_difference)
  let adjusted_time = target_time - 24 * (target_time / 24)
  
  assert_eq(22, adjusted_time)  // 14 + 8 = 22
}

test "batch_processing_calculation" {
  // æµ‹è¯•æ‰¹å¤„ç†è®¡ç®—
  let items_per_batch = 25
  let total_items = 187
  
  // è®¡ç®—éœ€è¦çš„æ‰¹æ¬¡æ•°
  let batches_needed = divide_with_ceil(total_items, items_per_batch)
  
  // è®¡ç®—æœ€åä¸€æ‰¹çš„å®é™…æ•°é‡
  let remainder = total_items - items_per_batch * (total_items / items_per_batch)
  let last_batch_size = if remainder == 0 {
    items_per_batch
  } else {
    remainder
  }
  
  assert_eq(8, batches_needed)
  assert_eq(12, last_batch_size)
}

test "compound_interest_simplified" {
  // æµ‹è¯•ç®€åŒ–çš„å¤åˆ©è®¡ç®—
  let principal = 1000
  let rate_percent = 5
  
  // ç®€åŒ–å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´å‘ä¸Šå–æ•´ï¼‰
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(1050, year1)
  assert_eq(1103, year2)
  assert_eq(1158, year3)
}

test "inventory_reorder_point" {
  // æµ‹è¯•åº“å­˜é‡è®¢è´§ç‚¹è®¡ç®—
  let daily_demand = 15
  let lead_time_days = 7
  let safety_stock = 20
  
  // è®¡ç®—é‡è®¢è´§ç‚¹
  let lead_time_demand = multiply(daily_demand, lead_time_days)
  let reorder_point = add(lead_time_demand, safety_stock)
  
  // è®¡ç®—å»ºè®®çš„è®¢è´§é‡ï¼ˆåŸºäºç»æµè®¢è´§é‡ç®€åŒ–ï¼‰
  let eoq_rounded = multiply(daily_demand, 30)  // 30å¤©ä¾›åº”
  let order_batches = divide_with_ceil(eoq_rounded, 100)  // æ¯æ‰¹æœ€å¤š100ä»¶
  let suggested_order = multiply(order_batches, 100)
  
  assert_eq(105, lead_time_demand)
  assert_eq(125, reorder_point)
  assert_eq(500, suggested_order)
}

test "unicode_greeting_comprehensive" {
  // æµ‹è¯•å…¨é¢çš„Unicodeé—®å€™åŠŸèƒ½
  let english_name = "Alice"
  let chinese_name = "å°æ˜"
  let emoji_name = "ğŸš€"
  let mixed_name = "John_123"
  let accented_name = "JosÃ©"
  
  let greeting_en = greet(english_name)
  let greeting_cn = greet(chinese_name)
  let greeting_emoji = greet(emoji_name)
  let greeting_mixed = greet(mixed_name)
  let greeting_accented = greet(accented_name)
  
  assert_eq_string("Hello, Alice!", greeting_en)
  assert_eq_string("Hello, å°æ˜!", greeting_cn)
  assert_eq_string("Hello, ğŸš€!", greeting_emoji)
  assert_eq_string("Hello, John_123!", greeting_mixed)
  assert_eq_string("Hello, JosÃ©!", greeting_accented)
}

test "complex_statistical_analysis" {
  // æµ‹è¯•å¤æ‚çš„ç»Ÿè®¡åˆ†æ
  // æ•°æ®ç‚¹ï¼š12, 15, 18, 21, 24, 27, 30
  
  // è®¡ç®—æ€»å’Œï¼ˆæ‰‹åŠ¨è®¡ç®—ï¼‰
  let sum = add(add(add(add(add(add(12, 15), 18), 21), 24), 27), 30)
  
  // è®¡ç®—å¹³å‡å€¼ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let count = 7
  let average = divide_with_ceil(sum, count)
  
  // è®¡ç®—èŒƒå›´
  let min = 12
  let max = 30
  let range = add(max, -min)
  
  // è®¡ç®—ä¸­ä½æ•°è¿‘ä¼¼å€¼
  let median_approx = divide_with_ceil(add(21, 24), 2)
  
  assert_eq(147, sum)
  assert_eq(21, average)
  assert_eq(18, range)
  assert_eq(23, median_approx)
}