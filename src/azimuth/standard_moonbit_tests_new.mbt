// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

test "add_function_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 15
  let b = 27
  assert_eq(add(a, b), add(b, a))
  assert_eq(42, add(15, 27))
  assert_eq(42, add(27, 15))
}

test "multiply_function_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ï¼ša Ã— (b + c) = a Ã— b + a Ã— c
  let a = 5
  let b = 8
  let c = 12
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
  assert_eq(100, left_side)  // 5 Ã— (8 + 12) = 5 Ã— 20 = 100
}

test "divide_with_ceil_fractional_precision" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å°æ•°ç²¾åº¦å¤„ç†
  assert_eq(4, divide_with_ceil(11, 3))   // 11/3 = 3.666... -> 4
  assert_eq(7, divide_with_ceil(20, 3))   // 20/3 = 6.666... -> 7
  assert_eq(2, divide_with_ceil(4, 2))    // 4/2 = 2 -> 2
  assert_eq(1, divide_with_ceil(1, 100))  // 1/100 = 0.01 -> 1
  assert_eq(0, divide_with_ceil(0, 5))    // 0/5 = 0 -> 0
}

test "greet_function_unicode_comprehensive" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å…¨é¢Unicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸ‰ğŸŠ!", greet("ğŸ‰ğŸŠ"))
}

test "complex_business_calculation_scenario" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯ï¼šç”µå•†è®¢å•è®¡ç®—
  let product_price = 89
  let quantity = 4
  let tax_rate = 8
  let shipping_cost = 15
  let discount = 20
  
  // è®¡ç®—å•†å“å°è®¡
  let subtotal = multiply(product_price, quantity)
  // è®¡ç®—ç¨è´¹
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  // è®¡ç®—æ€»ä»·ï¼ˆå«è¿è´¹ï¼‰
  let total_before_discount = add(add(subtotal, tax), shipping_cost)
  // åº”ç”¨æŠ˜æ‰£
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(356, subtotal)
  assert_eq(29, tax)
  assert_eq(400, total_before_discount)
  assert_eq(380, final_total)
}

test "negative_number_operations_comprehensive" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—çš„å…¨é¢æƒ…å†µ
  // è´Ÿæ•°åŠ æ³•
  assert_eq(-10, add(-3, -7))
  assert_eq(-2, add(-5, 3))
  assert_eq(0, add(-8, 8))
  
  // è´Ÿæ•°ä¹˜æ³•
  assert_eq(15, multiply(-3, -5))
  assert_eq(-12, multiply(3, -4))
  assert_eq(0, multiply(-7, 0))
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-9, -3))
  assert_eq(-2, divide_with_ceil(5, -3))
}

test "mathematical_sequence_calculations" {
  // æµ‹è¯•æ•°å­¦åºåˆ—è®¡ç®—
  // ç­‰å·®æ•°åˆ—æ±‚å’Œï¼š1 + 3 + 5 + ... + 19
  let first_term = 1
  let common_diff = 2
  let num_terms = 10
  let last_term = add(first_term, multiply(common_diff, num_terms - 1))
  let arithmetic_sum = divide_with_ceil(multiply(num_terms, add(first_term, last_term)), 2)
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼š2 + 4 + 8 + 16 + 32
  let geo_first = 2
  let geo_ratio = 2
  let geo_terms = 5
  let geometric_sum = multiply(geo_first, divide_with_ceil(multiply(geo_ratio, geo_ratio), geo_ratio - 1))
  
  assert_eq(19, last_term)
  assert_eq(100, arithmetic_sum)  // 10 Ã— (1 + 19) / 2 = 100
  assert_eq(8, geometric_sum)     // 2 Ã— (2^2) / (2-1) = 8
}

test "real_world_packaging_optimization" {
  // æµ‹è¯•ç°å®ä¸–ç•ŒåŒ…è£…ä¼˜åŒ–é—®é¢˜
  let total_products = 157
  let box_capacity_a = 12
  let box_capacity_b = 18
  let box_capacity_c = 25
  
  // è®¡ç®—ä½¿ç”¨ä¸åŒåŒ…è£…ç®±éœ€è¦çš„æ•°é‡
  let boxes_a = divide_with_ceil(total_products, box_capacity_a)
  let boxes_b = divide_with_ceil(total_products, box_capacity_b)
  let boxes_c = divide_with_ceil(total_products, box_capacity_c)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let unused_space_a = multiply(boxes_a, box_capacity_a) - total_products
  let unused_space_b = multiply(boxes_b, box_capacity_b) - total_products
  let unused_space_c = multiply(boxes_c, box_capacity_c) - total_products
  
  assert_eq(14, boxes_a)    // ceil(157/12) = 14
  assert_eq(9, boxes_b)     // ceil(157/18) = 9
  assert_eq(7, boxes_c)     // ceil(157/25) = 7
  assert_eq(11, unused_space_a)  // 14Ã—12 - 157 = 168 - 157 = 11
  assert_eq(5, unused_space_b)   // 9Ã—18 - 157 = 162 - 157 = 5
  assert_eq(18, unused_space_c)  // 7Ã—25 - 157 = 175 - 157 = 18
}

test "string_processing_with_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²å¤„ç†
  let test_cases = [
    ("123", "Hello, 123!"),
    ("abc123", "Hello, abc123!"),
    ("test@example.com", "Hello, test@example.com!"),
    ("A+B=C", "Hello, A+B=C!"),
    ("100%", "Hello, 100%!"),
    ("C++", "Hello, C++!")
  ]
  
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, abc123!", greet("abc123"))
  assert_eq_string("Hello, test@example.com!", greet("test@example.com"))
  assert_eq_string("Hello, A+B=C!", greet("A+B=C"))
  assert_eq_string("Hello, 100%!", greet("100%"))
  assert_eq_string("Hello, C++!", greet("C++"))
}

test "extreme_boundary_value_operations" {
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼è¿ç®—
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æµ‹è¯•æ¥è¿‘æœ€å¤§å€¼çš„è¿ç®—
  assert_eq(2147483646, add(max_int, -1))
  assert_eq(2147483647, multiply(max_int, 1))
  assert_eq(0, multiply(max_int, 0))
  
  // æµ‹è¯•æ¥è¿‘æœ€å°å€¼çš„è¿ç®—
  assert_eq(-2147483647, add(min_int, 1))
  assert_eq(-2147483648, multiply(min_int, 1))
  assert_eq(0, multiply(min_int, 0))
  
  // æµ‹è¯•æç«¯å€¼çš„é™¤æ³•å®‰å…¨æ€§
  assert_eq(0, divide_with_ceil(max_int, 0))
  assert_eq(0, divide_with_ceil(min_int, 0))
  assert_eq(1, divide_with_ceil(max_int, max_int))
  assert_eq(1, divide_with_ceil(min_int, min_int))
}