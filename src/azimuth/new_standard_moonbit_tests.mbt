// æ–°çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

test "add_function_identity_elements" {
  // æµ‹è¯•åŠ æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(42, add(42, 0))
  assert_eq(-17, add(-17, 0))
  assert_eq(0, add(0, 0))
  assert_eq(1000000, add(1000000, 0))
}

test "multiply_function_zero_property" {
  // æµ‹è¯•ä¹˜æ³•çš„é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(7, 0))
  assert_eq(0, multiply(0, 15))
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(-100, 0))
}

test "divide_with_ceil_precision_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(3, divide_with_ceil(8, 3))  // 2.666... -> 3
  assert_eq(7, divide_with_ceil(13, 2)) // 6.5 -> 7
  assert_eq(100, divide_with_ceil(999, 10)) // 99.9 -> 100
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode æ”¯æŒ
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "mathematical_distributive_law" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 5
  let b = 7
  let c = 9
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 5 * (7 + 9) = 5 * 7 + 5 * 9 = 80
}

test "negative_number_division_comprehensive" {
  // å…¨é¢æµ‹è¯•è´Ÿæ•°é™¤æ³•
  assert_eq(-2, divide_with_ceil(-4, 2))   // -4/2 = -2 -> -2
  assert_eq(-1, divide_with_ceil(-3, 2))   // -3/2 = -1.5 -> -1
  assert_eq(-3, divide_with_ceil(-7, 2))   // -7/2 = -3.5 -> -3
  assert_eq(3, divide_with_ceil(-7, -2))   // -7/-2 = 3.5 -> 4
  assert_eq(0, divide_with_ceil(-5, 0))    // é™¤æ•°ä¸º0çš„æƒ…å†µ
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate_percent = 8
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—
  let year1_amount = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2_amount = add(year1_amount, divide_with_ceil(multiply(year1_amount, rate_percent), 100))
  let year3_amount = add(year2_amount, divide_with_ceil(multiply(year2_amount, rate_percent), 100))
  
  assert_eq(10800, year1_amount)
  assert_eq(11664, year2_amount)
  assert_eq(12597, year3_amount)
}

test "inventory_optimization_problem" {
  // åº“å­˜ä¼˜åŒ–é—®é¢˜
  let product_a_qty = 45
  let product_b_qty = 67
  let product_c_qty = 23
  let box_capacity = 20
  
  let total_items = add(add(product_a_qty, product_b_qty), product_c_qty)
  let boxes_needed = divide_with_ceil(total_items, box_capacity)
  
  assert_eq(135, total_items)
  assert_eq(7, boxes_needed)  // ceil(135/20) = 7
}

test "string_greeting_with_special_characters" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²é—®å€™
  assert_eq_string("Hello, C++!", greet("C++"))
  assert_eq_string("Hello, HTML5!", greet("HTML5"))
  assert_eq_string("Hello, API@v2.0!", greet("API@v2.0"))
  assert_eq_string("Hello, a+b=c!", greet("a+b=c"))
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿè®¡ç®—
  let input_size = 1000
  let linear_factor = 3
  let logarithmic_factor = 10
  
  // æ¨¡æ‹Ÿ O(n + n log n) ç®—æ³•çš„å¤æ‚åº¦
  let linear_part = multiply(input_size, linear_factor)
  let log_part = multiply(divide_with_ceil(input_size, 100), logarithmic_factor)
  let total_complexity = add(linear_part, log_part)
  
  assert_eq(3000, linear_part)
  assert_eq(100, log_part)
  assert_eq(3100, total_complexity)
}