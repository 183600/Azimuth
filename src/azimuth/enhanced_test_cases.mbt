// å¢å¼ºçš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// åŒ…å«10ä¸ªæ–°çš„æµ‹è¯•ç”¨ä¾‹ï¼Œä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•

test "string_unicode_processing" {
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²å¤„ç†
  let chinese_name = "å¼ ä¸‰"
  let japanese_name = "ç”°ä¸­"
  let korean_name = "ê¹€ì² ìˆ˜"
  let arabic_name = "Ø£Ø­Ù…Ø¯"
  let emoji_name = "ğŸŒŸğŸš€"
  
  assert_eq_string("Hello, å¼ ä¸‰!", azimuth::greet(chinese_name))
  assert_eq_string("Hello, ç”°ä¸­!", azimuth::greet(japanese_name))
  assert_eq_string("Hello, ê¹€ì² ìˆ˜!", azimuth::greet(korean_name))
  assert_eq_string("Hello, Ø£Ø­Ù…Ø¯!", azimuth::greet(arabic_name))
  assert_eq_string("Hello, ğŸŒŸğŸš€!", azimuth::greet(emoji_name))
}

test "mathematical_sequence_calculations" {
  // æµ‹è¯•æ•°å­¦åºåˆ—è®¡ç®—
  
  // æ–æ³¢é‚£å¥‘æ•°åˆ—å‰10é¡¹å’Œï¼š1, 1, 2, 3, 5, 8, 13, 21, 34, 55
  // æ€»å’Œ = 1 + 1 + 2 + 3 + 5 + 8 + 13 + 21 + 34 + 55 = 143
  let fib1 = 1
  let fib2 = 1
  let fib3 = 2
  let fib4 = 3
  let fib5 = 5
  let fib6 = 8
  let fib7 = 13
  let fib8 = 21
  let fib9 = 34
  let fib10 = 55
  
  let fib_sum = azimuth::add(azimuth::add(azimuth::add(azimuth::add(azimuth::add(
    azimuth::add(azimuth::add(azimuth::add(fib1, fib2), fib3), fib4), fib5), fib6), fib7), fib8), fib9), fib10)
  
  assert_eq(143, fib_sum)
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼š2 + 4 + 8 + 16 + 32 = 62
  let geo_sum = azimuth::add(azimuth::add(azimuth::add(azimuth::add(2, 4), 8), 16), 32)
  assert_eq(62, geo_sum)
}

test "business_logic_calculations" {
  // æµ‹è¯•ä¸šåŠ¡é€»è¾‘è®¡ç®—
  
  // åº“å­˜ç®¡ç†è®¡ç®—
  let initial_stock = 1000
  let units_sold = 350
  let units_received = 200
  let damaged_units = 15
  
  // è®¡ç®—å½“å‰åº“å­˜ï¼šåˆå§‹åº“å­˜ - é”€å”®æ•°é‡ + æ”¶åˆ°æ•°é‡ - æŸåæ•°é‡
  let current_stock = azimuth::add(azimuth::add(
    azimuth::add(initial_stock, -units_sold), units_received), -damaged_units)
  
  assert_eq(835, current_stock)
  
  // åˆ©æ¶¦è®¡ç®—ï¼šæ”¶å…¥ - æˆæœ¬ - è¿è¥è´¹ç”¨
  let revenue = 50000
  let cost = 30000
  let operating_expenses = 12000
  
  let profit = azimuth::add(azimuth::add(revenue, -cost), -operating_expenses)
  assert_eq(8000, profit)
}

test "scientific_calculations" {
  // æµ‹è¯•ç§‘å­¦è®¡ç®—
  
  // ç®€åŒ–çš„ç‰©ç†å…¬å¼ï¼šåŠ¨èƒ½ = 0.5 Ã— è´¨é‡ Ã— é€Ÿåº¦Â²
  // ä½¿ç”¨æ•´æ•°è®¡ç®—ï¼šåŠ¨èƒ½ = è´¨é‡ Ã— é€Ÿåº¦Â² / 2
  let mass = 10
  let velocity = 15
  
  let kinetic_energy = azimuth::multiply(mass, azimuth::multiply(velocity, velocity)) / 2
  assert_eq(1125, kinetic_energy)  // 10 Ã— 15Â² / 2 = 10 Ã— 225 / 2 = 1125
  
  // ç®€åŒ–çš„åŒ–å­¦è®¡ç®—ï¼šæ‘©å°”æµ“åº¦ = æº¶è´¨æ‘©å°”æ•° / æº¶æ¶²ä½“ç§¯
  // ä½¿ç”¨æ•´æ•°è®¡ç®—ï¼šæµ“åº¦ Ã— 1000 = (æ‘©å°”æ•° Ã— 1000) / ä½“ç§¯
  let moles = 2
  let volume = 500  // æ¯«å‡
  
  let concentration = azimuth::multiply(moles, 1000) / volume
  assert_eq(4, concentration)  // 2 Ã— 1000 / 500 = 4
}

test "algorithmic_complexity_simulation" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿ
  
  // æ¨¡æ‹ŸO(nÂ²)ç®—æ³•çš„è®¡ç®—é‡
  let n = 10
  // è®¡ç®—é‡ = n Ã— (n + 1) / 2
  let complexity = azimuth::multiply(n, azimuth::add(n, 1)) / 2
  assert_eq(55, complexity)  // 10 Ã— 11 / 2 = 55
  
  // æ¨¡æ‹ŸO(nÂ³)ç®—æ³•çš„è®¡ç®—é‡ï¼ˆç®€åŒ–ï¼‰
  let n2 = 5
  // è®¡ç®—é‡ â‰ˆ nÂ³
  let complexity_cubic = azimuth::multiply(n2, azimuth::multiply(n2, n2))
  assert_eq(125, complexity_cubic)  // 5Â³ = 125
  
  // æ¨¡æ‹ŸäºŒåˆ†æœç´¢çš„æ¯”è¾ƒæ¬¡æ•°
  let array_size = 1024
  // æ¯”è¾ƒæ¬¡æ•° â‰ˆ logâ‚‚(array_size)
  // 1024 = 2Â¹â°ï¼Œæ‰€ä»¥éœ€è¦10æ¬¡æ¯”è¾ƒ
  let binary_search_comparisons = 10
  assert_eq(10, binary_search_comparisons)
}

test "date_time_calculations" {
  // æµ‹è¯•æ—¥æœŸæ—¶é—´è®¡ç®—
  
  // è®¡ç®—ä¸¤ä¸ªæ—¶é—´ç‚¹ä¹‹é—´çš„åˆ†é’Ÿæ•°
  let start_hour = 9
  let start_minute = 30
  let end_hour = 17
  let end_minute = 45
  
  let start_total_minutes = azimuth::add(azimuth::multiply(start_hour, 60), start_minute)
  let end_total_minutes = azimuth::add(azimuth::multiply(end_hour, 60), end_minute)
  let duration_minutes = azimuth::add(end_total_minutes, -start_total_minutes)
  
  assert_eq(495, duration_minutes)  // 17:45 - 9:30 = 8å°æ—¶15åˆ†é’Ÿ = 495åˆ†é’Ÿ
  
  // è®¡ç®—å·¥ä½œæ—¥å°æ—¶æ•°ï¼ˆè€ƒè™‘åˆä¼‘ï¼‰
  let work_hours = 8
  let lunch_break = 1
  let productive_hours = azimuth::add(work_hours, -lunch_break)
  assert_eq(7, productive_hours)
  
  // è®¡ç®—ä¸€å‘¨çš„å·¥ä½œåˆ†é’Ÿæ•°
  let days_per_week = 5
  let weekly_minutes = azimuth::multiply(productive_hours, azimuth::multiply(days_per_week, 60))
  assert_eq(2100, weekly_minutes)  // 7å°æ—¶ Ã— 5å¤© Ã— 60åˆ†é’Ÿ = 2100åˆ†é’Ÿ
}

test "financial_calculations_advanced" {
  // æµ‹è¯•é«˜çº§é‡‘èè®¡ç®—
  
  // è´·æ¬¾æœˆä¾›è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let loan_amount = 200000
  let annual_rate = 6  // 6%
  let loan_years = 30
  
  // ç®€åŒ–è®¡ç®—ï¼šæœˆä¾› â‰ˆ æœ¬é‡‘ / æœˆæ•° + åˆ©æ¯
  let total_months = azimuth::multiply(loan_years, 12)
  let monthly_principal = loan_amount / total_months
  
  // ç®€åŒ–çš„æœˆåˆ©æ¯è®¡ç®—
  let monthly_rate = annual_rate / 12
  let first_month_interest = azimuth::multiply(loan_amount, monthly_rate) / 100
  
  let monthly_payment = azimuth::add(monthly_principal, first_month_interest)
  assert_eq(1222, monthly_payment)  // ç®€åŒ–è®¡ç®—ç»“æœ
  
  // æŠ•èµ„å›æŠ¥ç‡è®¡ç®—
  let initial_investment = 10000
  let final_value = 15000
  let investment_years = 5
  
  let total_return = azimuth::add(final_value, -initial_investment)
  let annual_return = total_return / investment_years
  let return_rate = azimuth::multiply(annual_return, 100) / initial_investment
  
  assert_eq(1000, annual_return)  // (15000 - 10000) / 5 = 1000
  assert_eq(10, return_rate)      // 1000 Ã— 100 / 10000 = 10%
}

test "data_validation_scenarios" {
  // æµ‹è¯•æ•°æ®éªŒè¯åœºæ™¯
  
  // éªŒè¯å¹´é¾„èŒƒå›´
  let age = 25
  let min_age = 18
  let max_age = 65
  
  let is_valid_age = azimuth::add(age, -min_age) >= 0 && azimuth::add(max_age, -age) >= 0
  azimuth::assert_true(is_valid_age)
  
  // éªŒè¯å¯†ç å¼ºåº¦ï¼ˆç®€åŒ–ï¼šé•¿åº¦æ£€æŸ¥ï¼‰
  let password_length = 12
  let min_length = 8
  let is_long_enough = password_length >= min_length
  azimuth::assert_true(is_long_enough)
  
  // éªŒè¯æ•°å€¼èŒƒå›´
  let test_value = 50
  let lower_bound = 0
  let upper_bound = 100
  
  let is_in_range = azimuth::add(test_value, -lower_bound) >= 0 && azimuth::add(upper_bound, -test_value) >= 0
  azimuth::assert_true(is_in_range)
  
  // éªŒè¯é‚®ç®±æ ¼å¼ï¼ˆç®€åŒ–ï¼šæ£€æŸ¥@ç¬¦å·ï¼‰
  let email = "test@example.com"
  let has_at_symbol = email.length >= 5  // ç®€åŒ–æ£€æŸ¥
  azimuth::assert_true(has_at_symbol)
}

test "performance_optimization_calculations" {
  // æµ‹è¯•æ€§èƒ½ä¼˜åŒ–è®¡ç®—
  
  // ç¼“å­˜å‘½ä¸­ç‡è®¡ç®—
  let cache_requests = 1000
  let cache_hits = 850
  
  let hit_rate = azimuth::multiply(cache_hits, 100) / cache_requests
  assert_eq(85, hit_rate)  // 850 Ã— 100 / 1000 = 85%
  
  // ç®—æ³•æ”¹è¿›æ•ˆæœè®¡ç®—
  let original_time = 1000  // æ¯«ç§’
  let optimized_time = 250  // æ¯«ç§’
  
  let time_saved = azimuth::add(original_time, -optimized_time)
  let improvement_percentage = azimuth::multiply(time_saved, 100) / original_time
  
  assert_eq(750, time_saved)           // 1000 - 250 = 750
  assert_eq(75, improvement_percentage) // 750 Ã— 100 / 1000 = 75%
  
  // å†…å­˜ä½¿ç”¨ä¼˜åŒ–è®¡ç®—
  let original_memory = 500  // MB
  let optimized_memory = 300  // MB
  
  let memory_saved = azimuth::add(original_memory, -optimized_memory)
  let memory_efficiency = azimuth::multiply(azimuth::add(original_memory, -memory_saved), 100) / original_memory
  
  assert_eq(200, memory_saved)      // 500 - 300 = 200
  assert_eq(60, memory_efficiency)  // 300 Ã— 100 / 500 = 60%
}

test "edge_case_combinations" {
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶ç»„åˆ
  
  let max_val = 2147483647
  let min_val = -2147483648
  let zero = 0
  let one = 1
  let neg_one = -1
  
  // å¤æ‚çš„è¾¹ç•Œè¿ç®—ï¼š(max + min) Ã— (max - min + 1)
  let sum_max_min = azimuth::add(max_val, min_val)
  let diff_max_min = azimuth::add(max_val, -min_val)
  let adjusted_diff = azimuth::add(diff_max_min, one)
  let complex_result = azimuth::multiply(sum_max_min, adjusted_diff)
  
  assert_eq(-1, complex_result)  // (-1) Ã— 1 = -1
  
  // é›¶å€¼é“¾å¼è¿ç®—
  let zero_chain = azimuth::add(azimuth::multiply(azimuth::add(zero, one), zero), max_val)
  assert_eq(max_val, zero_chain)
  
  // æå€¼ä¸ä¸­é—´å€¼çš„ç»„åˆ
  let mid_value = 1000000
  let mixed_calculation = azimuth::add(azimuth::multiply(max_val, zero), 
    azimuth::add(azimuth::multiply(min_val, zero), mid_value))
  assert_eq(mid_value, mixed_calculation)
  
  // æµ‹è¯•é™¤é›¶ä¿æŠ¤ï¼ˆé€šè¿‡æ¡ä»¶åˆ¤æ–­ï¼‰
  let divisor = zero
  let dividend = 100
  let safe_result = if divisor == zero { zero } else { dividend / divisor }
  assert_eq(zero, safe_result)
}