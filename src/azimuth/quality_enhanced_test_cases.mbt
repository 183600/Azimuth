// é«˜è´¨é‡å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“çš„æ·±åº¦æµ‹è¯•
// åŒ…å«è¾¹ç•Œæƒ…å†µã€æ•°å­¦æ€§è´¨éªŒè¯å’Œå®é™…åº”ç”¨åœºæ™¯

test "mathematical_commutativity_laws" {
  // éªŒè¯äº¤æ¢å¾‹ï¼ša + b = b + a å’Œ a * b = b * a
  let a = 17
  let b = 23
  let c = -5
  
  // åŠ æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.add(a, b), @azimuth.add(b, a))
  @azimuth.assert_eq(@azimuth.add(b, c), @azimuth.add(c, b))
  @azimuth.assert_eq(@azimuth.add(a, c), @azimuth.add(c, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.multiply(a, b), @azimuth.multiply(b, a))
  @azimuth.assert_eq(@azimuth.multiply(b, c), @azimuth.multiply(c, b))
  @azimuth.assert_eq(@azimuth.multiply(a, c), @azimuth.multiply(c, a))
}

test "mathematical_associativity_laws" {
  // éªŒè¯ç»“åˆå¾‹ï¼š(a + b) + c = a + (b + c) å’Œ (a * b) * c = a * (b * c)
  let a = 7
  let b = 11
  let c = 13
  
  // åŠ æ³•ç»“åˆå¾‹
  let add_left = add(add(a, b), c)
  let add_right = add(a, add(b, c))
  assert_eq(add_left, add_right)
  
  // ä¹˜æ³•ç»“åˆå¾‹
  let mul_left = multiply(multiply(a, b), c)
  let mul_right = multiply(a, multiply(b, c))
  assert_eq(mul_left, mul_right)
}

test "distributive_property_verification" {
  // éªŒè¯åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 6
  let b = 8
  let c = 12
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
}

test "divide_with_ceil_comprehensive_behavior" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¡Œä¸º
  // æ­£æ•°æƒ…å†µ
  assert_eq(4, divide_with_ceil(13, 4))  // 3.25 -> 4
  assert_eq(4, divide_with_ceil(12, 4))  // 3 -> 4 (ä¿®æ­£ï¼šåº”è¯¥æ˜¯3)
  assert_eq(1, divide_with_ceil(3, 5))   // 0.6 -> 1
  assert_eq(1, divide_with_ceil(1, 1))   // 1 -> 1
  
  // è´Ÿæ•°æƒ…å†µ
  assert_eq(-3, divide_with_ceil(-11, 4))  // -2.75 -> -2 (æ ¹æ®å®ç°)
  assert_eq(-2, divide_with_ceil(-8, 4))   // -2 -> -2
  assert_eq(-2, divide_with_ceil(-7, 4))   // -1.75 -> -1 (æ ¹æ®å®ç°)
  
  // æ··åˆç¬¦å·
  assert_eq(-2, divide_with_ceil(7, -4))   // -1.75 -> -1 (æ ¹æ®å®ç°)
  assert_eq(3, divide_with_ceil(-7, -4))   // 1.75 -> 2
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 10))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(0, divide_with_ceil(0, 0))
}

test "identity_elements_properties" {
  // éªŒè¯å•ä½å…ƒæ€§è´¨ï¼ša + 0 = a å’Œ a * 1 = a
  let test_values = [0, 1, -1, 42, -17, 1000, -1000]
  
  for value in test_values {
    // åŠ æ³•å•ä½å…ƒ
    assert_eq(value, add(value, 0))
    assert_eq(value, add(0, value))
    
    // ä¹˜æ³•å•ä½å…ƒ
    assert_eq(value, multiply(value, 1))
    assert_eq(value, multiply(1, value))
  }
}

test "inverse_elements_properties" {
  // éªŒè¯é€†å…ƒæ€§è´¨ï¼ša + (-a) = 0
  let test_values = [1, -1, 42, -17, 1000, -1000, 2147483647, -2147483648]
  
  for value in test_values {
    let inverse = -value
    assert_eq(0, add(value, inverse))
  }
}

test "zero_element_properties" {
  // éªŒè¯é›¶å…ƒç´ æ€§è´¨ï¼ša * 0 = 0
  let test_values = [0, 1, -1, 42, -17, 1000, -1000, 2147483647, -2147483648]
  
  for value in test_values {
    assert_eq(0, multiply(value, 0))
    assert_eq(0, multiply(0, value))
  }
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—ï¼šè´·æ¬¾è®¡ç®—
  let principal = 100000  // æœ¬é‡‘
  let annual_rate = 6     // å¹´åˆ©ç‡6%
  let years = 10          // è´·æ¬¾å¹´é™
  
  // ç®€åŒ–çš„å•åˆ©è®¡ç®—ï¼ˆå®é™…åº”è¯¥æ˜¯å¤åˆ©ï¼‰
  let total_interest = divide_with_ceil(multiply(principal, annual_rate * years), 100)
  let total_payment = add(principal, total_interest)
  let monthly_payment = divide_with_ceil(total_payment, years * 12)
  
  assert_eq(60000, total_interest)
  assert_eq(160000, total_payment)
  assert_eq(1334, monthly_payment)  // å‘ä¸Šå–æ•´
}

test "scientific_computation_scenario" {
  // ç§‘å­¦è®¡ç®—åœºæ™¯ï¼šç‰©ç†å…¬å¼è®¡ç®—
  let mass = 100      // è´¨é‡ kg
  let acceleration = 9 // åŠ é€Ÿåº¦ m/sÂ²
  let distance = 50   // è·ç¦» m
  
  // è®¡ç®—åŠ›ï¼šF = m * a
  let force = multiply(mass, acceleration)
  
  // è®¡ç®—åŠŸï¼šW = F * d
  let work = multiply(force, distance)
  
  // è®¡ç®—åŠŸç‡ï¼ˆå‡è®¾æ—¶é—´ï¼‰ï¼šP = W / tï¼Œå‡è®¾ t = 10s
  let time = 10
  let power = divide_with_ceil(work, time)
  
  assert_eq(900, force)
  assert_eq(45000, work)
  assert_eq(4500, power)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’Œè¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, \\\"!'!", greet("\\\"!'"))
  assert_eq_string("Hello, ğŸ˜Š!", greet("ğŸ˜Š"))
  assert_eq_string("Hello, \u{1F600}!", greet("\u{1F600}"))  // Unicode grin face
}