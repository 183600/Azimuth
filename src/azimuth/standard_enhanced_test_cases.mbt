// æ ‡å‡† MoonBit å¢å¼ºæµ‹è¯•ç”¨ä¾‹
// è¦†ç›– azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…å«å®é™…åº”ç”¨åœºæ™¯

test "divide_with_ceil_practical_scenarios" {
  // å®é™…åœºæ™¯ï¼šè®¡ç®—åŒ…è£…ç®±æ•°é‡
  let items_per_box = 12
  let total_items_1 = 50
  let total_items_2 = 60
  let total_items_3 = 0
  
  let boxes_needed_1 = divide_with_ceil(total_items_1, items_per_box)
  let boxes_needed_2 = divide_with_ceil(total_items_2, items_per_box)
  let boxes_needed_3 = divide_with_ceil(total_items_3, items_per_box)
  
  assert_eq(5, boxes_needed_1)  // ceil(50/12) = 5
  assert_eq(5, boxes_needed_2)  // ceil(60/12) = 5
  assert_eq(0, boxes_needed_3)  // ceil(0/12) = 0
}

test "divide_with_ceil_negative_dividend" {
  // æµ‹è¯•è´Ÿè¢«é™¤æ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(-4, divide_with_ceil(-11, 3))
  assert_eq(-2, divide_with_ceil(-6, 3))
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(0, divide_with_ceil(-1, -1))
}

test "divide_with_ceil_negative_divisor" {
  // æµ‹è¯•è´Ÿé™¤æ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(10, -3))
  assert_eq(-3, divide_with_ceil(11, -3))
  assert_eq(-2, divide_with_ceil(6, -3))
  assert_eq(0, divide_with_ceil(1, -2))
}

test "divide_with_ceil_both_negative" {
  // æµ‹è¯•è´Ÿè¢«é™¤æ•°å’Œè´Ÿé™¤æ•°çš„æƒ…å†µ
  assert_eq(4, divide_with_ceil(-11, -3))
  assert_eq(3, divide_with_ceil(-9, -3))
  assert_eq(2, divide_with_ceil(-6, -3))
  assert_eq(1, divide_with_ceil(-1, -2))
}

test "greet_function_with_whitespace" {
  // æµ‹è¯•åŒ…å«ç©ºç™½å­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \t\n!", greet("\t\n"))
  assert_eq_string("Hello, John Doe!", greet("John Doe"))
  assert_eq_string("Hello,  Leading Space!", greet(" Leading Space"))
  assert_eq_string("Hello, Trailing Space !", greet("Trailing Space "))
}

test "mathematical_sequence_fibonacci_style" {
  // ç±»æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—ï¼ˆä½¿ç”¨ç°æœ‰å‡½æ•°ï¼‰
  let a = 1
  let b = 1
  
  // è®¡ç®—å‰å‡ é¡¹
  let term3 = add(a, b)  // 2
  let term4 = add(b, term3)  // 3
  let term5 = add(term3, term4)  // 5
  let term6 = add(term4, term5)  // 8
  
  assert_eq(2, term3)
  assert_eq(3, term4)
  assert_eq(5, term5)
  assert_eq(8, term6)
  
  // éªŒè¯é»„é‡‘æ¯”ä¾‹è¿‘ä¼¼
  let ratio_approx = multiply(term6, 100) / term5  // 8*100/5 = 160
  assert_eq(160, ratio_approx)  // è¿‘ä¼¼1.6å€
}

test "business_inventory_calculation" {
  // åº“å­˜ç®¡ç†è®¡ç®—
  let product_cost = 45
  let selling_price = 68
  let initial_stock = 120
  let sold_units = 87
  let reorder_threshold = 50
  
  // è®¡ç®—å‰©ä½™åº“å­˜
  let remaining_stock = add(initial_stock, -sold_units)
  assert_eq(33, remaining_stock)
  
  // è®¡ç®—æ€»æ”¶å…¥
  let total_revenue = multiply(selling_price, sold_units)
  assert_eq(5916, total_revenue)
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = multiply(product_cost, sold_units)
  assert_eq(3915, total_cost)
  
  // è®¡ç®—åˆ©æ¶¦
  let profit = add(total_revenue, -total_cost)
  assert_eq(2001, profit)
  
  // åˆ¤æ–­æ˜¯å¦éœ€è¦è¡¥è´§
  let needs_reorder = if remaining_stock < reorder_threshold { 1 } else { 0 }
  assert_eq(1, needs_reorder)
}

test "time_based_calculations" {
  // åŸºäºæ—¶é—´çš„è®¡ç®—
  let hours_per_day = 24
  let days_per_week = 7
  let weeks_per_month = 4
  
  // è®¡ç®—ä¸€ä¸ªæœˆçš„å°æ—¶æ•°
  let hours_per_month = multiply(hours_per_day, multiply(days_per_week, weeks_per_month))
  assert_eq(672, hours_per_month)
  
  // è®¡ç®—å·¥ä½œå®‰æ’
  let work_hours_per_day = 8
  let work_days_per_week = 5
  let weekly_work_hours = multiply(work_hours_per_day, work_days_per_week)
  assert_eq(40, weekly_work_hours)
  
  // è®¡ç®—æœˆå·¥ä½œå°æ—¶
  let monthly_work_hours = multiply(weekly_work_hours, weeks_per_month)
  assert_eq(160, monthly_work_hours)
}

test "geometric_progression_sum" {
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼ˆç®€åŒ–ç‰ˆï¼‰
  let first_term = 3
  let ratio = 2
  
  // æ‰‹åŠ¨è®¡ç®—å„é¡¹
  let term1 = first_term  // 3
  let term2 = multiply(term1, ratio)  // 6
  let term3 = multiply(term2, ratio)  // 12
  let term4 = multiply(term3, ratio)  // 24
  let term5 = multiply(term4, ratio)  // 48
  let term6 = multiply(term5, ratio)  // 96
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(add(term1, term2), term3), term4), term5), term6)
  assert_eq(189, sum)
  
  // éªŒè¯ç­‰æ¯”æ•°åˆ—æ€§è´¨
  let ratio_check = multiply(term3, term3)  // 12*12 = 144
  let product_check = multiply(term2, term4)  // 6*24 = 144
  assert_eq(ratio_check, product_check)
}

test "complex_string_greeting_scenarios" {
  // å¤æ‚å­—ç¬¦ä¸²é—®å€™åœºæ™¯
  // æµ‹è¯•ä¸åŒè¯­è¨€çš„é—®å€™
  let chinese_name = "å¼ ä¸‰"
  let english_name = "John Smith"
  let mixed_name = "JosÃ© GarcÃ­a"
  let emoji_name = "ğŸŒŸStarğŸŒŸ"
  
  assert_eq_string("Hello, å¼ ä¸‰!", greet(chinese_name))
  assert_eq_string("Hello, John Smith!", greet(english_name))
  assert_eq_string("Hello, JosÃ© GarcÃ­a!", greet(mixed_name))
  assert_eq_string("Hello, ğŸŒŸStarğŸŒŸ!", greet(emoji_name))
  
  // æµ‹è¯•åŒ…å«æ•°å­—å’Œç‰¹æ®Šå­—ç¬¦çš„åç§°
  let numeric_name = "User123"
  let special_name = "Test-User_2023"
  
  assert_eq_string("Hello, User123!", greet(numeric_name))
  assert_eq_string("Hello, Test-User_2023!", greet(special_name))
}