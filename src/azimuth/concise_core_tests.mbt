test "add_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„åŠ æ³•åŠŸèƒ½
  let result1 = azimuth::add(2, 3)
  assert_eq(5, result1)
  
  let result2 = azimuth::add(-2, 2)
  assert_eq(0, result2)
  
  let result3 = azimuth::add(-2, -3)
  assert_eq(-5, result3)
}

test "add_zero_handling" {
  // æµ‹è¯•é›¶å€¼å¤„ç†
  let result1 = azimuth::add(5, 0)
  assert_eq(5, result1)
  
  let result2 = azimuth::add(0, 5)
  assert_eq(5, result2)
  
  let result3 = azimuth::add(0, 0)
  assert_eq(0, result3)
}

test "add_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼
  let max_val = 2147483647
  let min_val = -2147483648
  
  let result1 = azimuth::add(max_val, 1)
  assert_eq(max_val, result1)
  
  let result2 = azimuth::add(min_val, -1)
  assert_eq(min_val, result2)
  
  let result3 = azimuth::add(max_val, min_val)
  assert_eq(-1, result3)
}

test "multiply_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„ä¹˜æ³•åŠŸèƒ½
  let result1 = azimuth::multiply(2, 3)
  assert_eq(6, result1)
  
  let result2 = azimuth::multiply(-2, 3)
  assert_eq(-6, result2)
  
  let result3 = azimuth::multiply(-2, -3)
  assert_eq(6, result3)
}

test "multiply_zero_and_one" {
  // æµ‹è¯•é›¶å’Œä¸€çš„ä¹˜æ³•
  let result1 = azimuth::multiply(5, 0)
  assert_eq(0, result1)
  
  let result2 = azimuth::multiply(5, 1)
  assert_eq(5, result2)
  
  let result3 = azimuth::multiply(1, 5)
  assert_eq(5, result3)
}

test "multiply_boundary_values" {
  // æµ‹è¯•ä¹˜æ³•è¾¹ç•Œå€¼
  let max_val = 2147483647
  let min_val = -2147483648
  
  let result1 = azimuth::multiply(max_val, 0)
  assert_eq(0, result1)
  
  let result2 = azimuth::multiply(min_val, -1)
  assert_eq(min_val, result2)
  
  let result3 = azimuth::multiply(max_val, 1)
  assert_eq(max_val, result3)
}

test "greet_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„é—®å€™åŠŸèƒ½
  let result1 = azimuth::greet("World")
  assert_eq_string("Hello, World!", result1)
  
  let result2 = azimuth::greet("MoonBit")
  assert_eq_string("Hello, MoonBit!", result2)
}

test "greet_edge_cases" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  let result1 = azimuth::greet("")
  assert_eq_string("Hello, !", result1)
  
  let result2 = azimuth::greet("A")
  assert_eq_string("Hello, A!", result2)
  
  let result3 = azimuth::greet("123")
  assert_eq_string("Hello, 123!", result3)
}

test "complex_calculation" {
  // æµ‹è¯•å¤åˆè®¡ç®—
  let a = 10
  let b = 20
  let c = 30
  
  // (a + b) * c
  let result1 = azimuth::multiply(azimuth::add(a, b), c)
  assert_eq(900, result1)
  
  // a * b + c
  let result2 = azimuth::add(azimuth::multiply(a, b), c)
  assert_eq(230, result2)
}

test "real_world_scenario" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  // è®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item_price = 199
  let quantity = 3
  let shipping = 20
  
  let subtotal = azimuth::multiply(item_price, quantity)
  let total = azimuth::add(subtotal, shipping)
  
  assert_eq(617, total)
}

test "add_edge_case_max_min_values" {
  // æµ‹è¯•æœ€å¤§å€¼å’Œæœ€å°å€¼ç›¸åŠ çš„è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(max_val, azimuth::add(max_val, 0))
  assert_eq(min_val, azimuth::add(min_val, 0))
  assert_eq(-1, azimuth::add(max_val, min_val))
}

test "add_consecutive_operations" {
  // æµ‹è¯•è¿ç»­åŠ æ³•æ“ä½œ
  let result = azimuth::add(azimuth::add(1, 2), azimuth::add(3, 4))
  assert_eq(10, result)
  
  let result2 = azimuth::add(azimuth::add(-5, 10), azimuth::add(-3, 8))
  assert_eq(10, result2)
}

test "multiply_power_of_two" {
  // æµ‹è¯•2çš„å¹‚æ¬¡æ–¹ä¹˜æ³•
  assert_eq(8, azimuth::multiply(2, 4))
  assert_eq(16, azimuth::multiply(4, 4))
  assert_eq(1024, azimuth::multiply(32, 32))
  assert_eq(-1024, azimuth::multiply(-32, 32))
}

test "multiply_fractional_simulation" {
  // é€šè¿‡æ•´æ•°è¿ç®—æ¨¡æ‹Ÿå°æ•°ä¹˜æ³•ï¼ˆä¾‹å¦‚ï¼šè®¡ç®—ç™¾åˆ†æ¯”ï¼‰
  // 25% of 400 = 400 * 25 / 100
  let value = 400
  let percentage = 25
  let result = azimuth::multiply(value, percentage) / 100
  assert_eq(100, result)
  
  // 75% of 200 = 200 * 75 / 100
  let value2 = 200
  let percentage2 = 75
  let result2 = azimuth::multiply(value2, percentage2) / 100
  assert_eq(150, result2)
}

test "greet_multilingual" {
  // æµ‹è¯•å¤šè¯­è¨€é—®å€™
  assert_eq_string("Hello, ä¸–ç•Œ!", azimuth::greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", azimuth::greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", azimuth::greet("×¢×‘×¨×™×ª"))
}

test "greet_with_special_characters" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, Line1\nLine2!", azimuth::greet("Line1\nLine2"))
  assert_eq_string("Hello, Tab\tSeparated!", azimuth::greet("Tab\tSeparated"))
  assert_eq_string("Hello, EmojiğŸŒ!", azimuth::greet("EmojiğŸŒ"))
}

test "complex_arithmetic_sequence" {
  // æµ‹è¯•å¤æ‚çš„ç®—æœ¯åºåˆ—
  // è®¡ç®—ï¼š1 + 2*3 + 4*5*6
  let term1 = 1
  let term2 = azimuth::multiply(2, 3)
  let term3 = azimuth::multiply(azimuth::multiply(4, 5), 6)
  let result = azimuth::add(azimuth::add(term1, term2), term3)
  assert_eq(127, result)  // 1 + 6 + 120 = 127
}

// æ–°å¢çš„ 10 ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
test "bitwise_operations_simulation" {
  // æ¨¡æ‹Ÿä½è¿ç®—ï¼šä½¿ç”¨åŠ å‡ä¹˜é™¤å®ç°ä½è¿ç®—æ•ˆæœ
  let a = 8
  let b = 3
  
  // å·¦ç§»è¿ç®—æ¨¡æ‹Ÿï¼ša << 1 = a * 2
  let left_shift = azimuth::multiply(a, 2)
  assert_eq(16, left_shift)
  
  // å³ç§»è¿ç®—æ¨¡æ‹Ÿï¼ša >> 1 = a / 2
  let right_shift = a / 2
  assert_eq(4, right_shift)
  
  // ä½æˆ–è¿ç®—æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰ï¼ša | b = a + b
  let bit_or_sim = azimuth::add(a, b)
  assert_eq(11, bit_or_sim)
}

test "currency_conversion_practical" {
  // å®é™…è´§å¸è½¬æ¢åœºæ™¯
  let usd_amount = 100
  let exchange_rate = 7  // 1 USD = 7 CNY (ç®€åŒ–æ±‡ç‡)
  
  // è½¬æ¢ä¸ºäººæ°‘å¸
  let cny_amount = azimuth::multiply(usd_amount, exchange_rate)
  assert_eq(700, cny_amount)
  
  // æ·»åŠ æ‰‹ç»­è´¹ 5%
  let fee = azimuth::multiply(cny_amount, 5) / 100
  let total_with_fee = azimuth::add(cny_amount, fee)
  assert_eq(735, total_with_fee)
}

test "geometry_calculations" {
  // å‡ ä½•è®¡ç®—æµ‹è¯•
  let radius = 5
  
  // åœ†å‘¨é•¿ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼š2 Ã— Ï€ Ã— r â‰ˆ 2 Ã— 3 Ã— r
  let circumference = azimuth::multiply(azimuth::multiply(2, 3), radius)
  assert_eq(30, circumference)
  
  // åœ†é¢ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼šÏ€ Ã— rÂ² â‰ˆ 3 Ã— rÂ²
  let area = azimuth::multiply(3, azimuth::multiply(radius, radius))
  assert_eq(75, area)
}

test "time_calculations" {
  // æ—¶é—´è®¡ç®—æµ‹è¯•
  let hours = 2
  let minutes = 30
  
  // è½¬æ¢ä¸ºæ€»åˆ†é’Ÿæ•°
  let total_minutes = azimuth::add(azimuth::multiply(hours, 60), minutes)
  assert_eq(150, total_minutes)
  
  // è½¬æ¢ä¸ºæ€»ç§’æ•°
  let total_seconds = azimuth::multiply(total_minutes, 60)
  assert_eq(9000, total_seconds)
}

test "statistics_basic" {
  // åŸºç¡€ç»Ÿè®¡è®¡ç®—
  // è®¡ç®—æ€»å’Œ
  let sum = azimuth::add(azimuth::add(azimuth::add(azimuth::add(10, 20), 30), 40), 50)
  assert_eq(150, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let average = sum / 5
  assert_eq(30, average)
}

test "game_score_calculation" {
  // æ¸¸æˆå¾—åˆ†è®¡ç®—æµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let bonus_points = 500
  let penalty = 200
  
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let level_score = azimuth::multiply(base_score, level_multiplier)
  let total_with_bonus = azimuth::add(level_score, bonus_points)
  let final_score = azimuth::add(total_with_bonus, -penalty)
  
  assert_eq(3300, final_score)
  
  // è®¡ç®—æ’åå¾—åˆ†ï¼ˆå‰10%é¢å¤–åŠ åˆ†ï¼‰
  let top_percentage = 10
  let rank_bonus = azimuth::multiply(final_score, top_percentage) / 100
  let rank_total = azimuth::add(final_score, rank_bonus)
  
  assert_eq(3630, rank_total)
}

test "energy_consumption" {
  // èƒ½è€—è®¡ç®—æµ‹è¯•
  let power_rating = 100  // ç“¦ç‰¹
  let hours_used = 24
  let days_used = 30
  let cost_per_kwh = 10  // æ¯åƒç“¦æ—¶è´¹ç”¨ï¼ˆç®€åŒ–ï¼‰
  
  // è®¡ç®—æ€»èƒ½è€—ï¼ˆç“¦æ—¶ï¼‰
  let daily_consumption = azimuth::multiply(power_rating, hours_used)
  let monthly_consumption = azimuth::multiply(daily_consumption, days_used)
  
  // è½¬æ¢ä¸ºåƒç“¦æ—¶
  let kwh_consumption = monthly_consumption / 1000
  assert_eq(72, kwh_consumption)
  
  // è®¡ç®—è´¹ç”¨
  let total_cost = azimuth::multiply(kwh_consumption, cost_per_kwh)
  assert_eq(720, total_cost)
}

test "factorial_calculation" {
  // è®¡ç®—5çš„é˜¶ä¹˜ï¼š5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
  let n = 5
  let result = azimuth::multiply(n, azimuth::multiply(n - 1, azimuth::multiply(n - 2, azimuth::multiply(n - 3, n - 4))))
  assert_eq(120, result)
}

test "power_of_two_calculation" {
  // è®¡ç®—2çš„å¹‚ï¼š2^8 = 256
  // é€šè¿‡è¿ç»­ç›¸ä¹˜å®ç°
  let result = azimuth::multiply(azimuth::multiply(azimuth::multiply(2, 2), azimuth::multiply(2, 2)), azimuth::multiply(azimuth::multiply(2, 2), azimuth::multiply(2, 2)))
  assert_eq(256, result)
}