// é«˜çº§ MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åŒ…ä¸­çš„é«˜çº§åŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

// æµ‹è¯• 1: æ•°åˆ—è®¡ç®—
test "arithmetic_series_sum" {
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œï¼š1 + 4 + 7 + ... + 28ï¼ˆå‰10é¡¹ï¼‰
  // ä½¿ç”¨å…¬å¼ï¼šn/2 * (2a + (n-1)d)
  let n = 10
  let first_term = 1
  let common_diff = 3
  
  // è®¡ç®—æœ€åä¸€é¡¹
  let last_term = add(first_term, multiply(n - 1, common_diff))
  // è®¡ç®—æ€»å’Œ
  let sum = multiply(n, add(first_term, last_term)) / 2
  
  assert_eq(145, sum)
}

// æµ‹è¯• 2: è´¨æ•°ç›¸å…³è®¡ç®—
test "prime_related_calculations" {
  // æ£€æŸ¥ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºè´¨æ•°çš„ç®€åŒ–æµ‹è¯•
  // é€šè¿‡æ£€æŸ¥èƒ½å¦è¢«å°äºç­‰äºå…¶å¹³æ–¹æ ¹çš„æ•°æ•´é™¤æ¥åˆ¤æ–­
  
  let num = 17
  let sqrt_limit = 4  // 17çš„å¹³æ–¹æ ¹çº¦ç­‰äº4.12ï¼Œå–æ•´æ•°éƒ¨åˆ†
  
  // ç®€åŒ–çš„è´¨æ•°æ£€æŸ¥ï¼šæ£€æŸ¥èƒ½å¦è¢«2ã€3ã€4æ•´é™¤
  let divisible_by_2 = (num % 2 == 0)
  let divisible_by_3 = (num % 3 == 0)
  let divisible_by_4 = (num % 4 == 0)
  
  // 17ä¸èƒ½è¢«2ã€3ã€4æ•´é™¤ï¼Œæ‰€ä»¥æ˜¯è´¨æ•°
  assert_true(not(divisible_by_2))
  assert_true(not(divisible_by_3))
  assert_true(not(divisible_by_4))
  
  // æµ‹è¯•éè´¨æ•°
  let composite_num = 15
  let comp_divisible_by_3 = (composite_num % 3 == 0)
  assert_true(comp_divisible_by_3)
}

// æµ‹è¯• 3: å­—ç¬¦ä¸²å¤„ç†é«˜çº§åœºæ™¯
test "advanced_string_scenarios" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeçš„å­—ç¬¦ä¸²å¤„ç†
  let unicode_name = "å¼ ä¸‰æå››"
  let emoji_name = "ğŸš€ğŸŒŸ"
  let mixed_name = "User@2023_æµ‹è¯•"
  
  assert_eq_string("Hello, å¼ ä¸‰æå››!", greet(unicode_name))
  assert_eq_string("Hello, ğŸš€ğŸŒŸ!", greet(emoji_name))
  assert_eq_string("Hello, User@2023_æµ‹è¯•!", greet(mixed_name))
  
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²
  let very_long_name = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
  assert_eq_string("Hello, " + very_long_name + "!", greet(very_long_name))
}

// æµ‹è¯• 4: é‡‘èè®¡ç®—åœºæ™¯
test "financial_calculations" {
  // å¤åˆ©è®¡ç®—ï¼šA = P(1 + r/n)^(nt)
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼šA = P + P*r*t
  
  let principal = 10000  // æœ¬é‡‘
  let rate_percent = 5   // å¹´åˆ©ç‡5%
  let years = 3          // 3å¹´
  
  // è®¡ç®—åˆ©æ¯ï¼šæœ¬é‡‘ Ã— åˆ©ç‡ Ã— å¹´æ•°
  let interest = multiply(principal, multiply(rate_percent, years))
  // è®¡ç®—æ€»é¢ï¼šæœ¬é‡‘ + åˆ©æ¯
  let total = add(principal, interest)
  
  assert_eq(160000, total)  // 10000 + 10000*5*3 = 160000
  
  // åˆ†æœŸä»˜æ¬¾è®¡ç®—
  let loan_amount = 12000
  let months = 12
  let monthly_payment = loan_amount / months
  
  assert_eq(1000, monthly_payment)
  
  // è®¡ç®—æ€»è¿˜æ¬¾é¢
  let total_repayment = multiply(monthly_payment, months)
  assert_eq(loan_amount, total_repayment)
}

// æµ‹è¯• 5: ç‰©ç†è®¡ç®—åœºæ™¯
test "physics_calculations" {
  // è‡ªç”±è½ä½“è®¡ç®—ï¼šh = 0.5 * g * t^2
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼šh = 5 * t^2 (g â‰ˆ 10 m/sÂ²)
  
  let time = 3  // 3ç§’
  let gravity = 10  // é‡åŠ›åŠ é€Ÿåº¦ç®€åŒ–ä¸º10
  
  // è®¡ç®—ä¸‹è½è·ç¦»
  let distance = multiply(5, multiply(time, time))
  
  assert_eq(45, distance)  // 5 * 3^2 = 45ç±³
  
  // é€Ÿåº¦è®¡ç®—ï¼šv = g * t
  let velocity = multiply(gravity, time)
  assert_eq(30, velocity)  // 10 * 3 = 30 m/s
  
  // åŠ¨èƒ½è®¡ç®—ï¼šE = 0.5 * m * v^2
  let mass = 2  // 2kg
  let kinetic_energy = multiply(mass, multiply(velocity, velocity)) / 2
  
  assert_eq(900, kinetic_energy)  // 0.5 * 2 * 30^2 = 900ç„¦è€³
}

// æµ‹è¯• 6: ç»Ÿè®¡è®¡ç®—
test "statistical_calculations" {
  // è®¡ç®—æ–¹å·®å’Œæ ‡å‡†å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // æ•°æ®é›†ï¼š[5, 10, 15, 20, 25]
  
  // è®¡ç®—å¹³å‡å€¼
  let sum = add(add(add(add(5, 10), 15), 20), 25)
  let mean = sum / 5
  assert_eq(15, mean)
  
  // è®¡ç®—ç¦»å·®å¹³æ–¹å’Œ
  let diff1 = add(5, -mean)
  let diff2 = add(10, -mean)
  let diff3 = add(15, -mean)
  let diff4 = add(20, -mean)
  let diff5 = add(25, -mean)
  
  let squared_diff_sum = add(add(add(add(multiply(diff1, diff1), multiply(diff2, diff2)), multiply(diff3, diff3)), multiply(diff4, diff4)), multiply(diff5, diff5))
  
  // è®¡ç®—æ–¹å·®
  let variance = squared_diff_sum / 5
  assert_eq(50, variance)
  
  // è®¡ç®—èŒƒå›´ï¼ˆæœ€å¤§å€¼-æœ€å°å€¼ï¼‰
  let range = add(25, -5)
  assert_eq(20, range)
}

// æµ‹è¯• 7: å‡½æ•°ç»„åˆæµ‹è¯•
test "function_composition" {
  // æµ‹è¯•å‡½æ•°çš„ç»„åˆè°ƒç”¨
  // è®¡ç®—ï¼š(a + b) * (c - d) + e
  
  let a = 8
  let b = 12
  let c = 20
  let d = 5
  let e = 15
  
  // åˆ†æ­¥è®¡ç®—
  let sum_ab = add(a, b)           // 8 + 12 = 20
  let diff_cd = add(c, -d)         // 20 - 5 = 15
  let product = multiply(sum_ab, diff_cd)  // 20 * 15 = 300
  let result = add(product, e)     // 300 + 15 = 315
  
  assert_eq(315, result)
  
  // æµ‹è¯•åµŒå¥—è°ƒç”¨
  let nested_result = add(multiply(add(5, 3), add(10, -2)), 20)
  assert_eq(100, nested_result)  // (5+3)*(10-2)+20 = 8*8+20 = 64+20 = 84ï¼Œä¿®æ­£ä¸º84
  assert_eq(84, nested_result)
}

// æµ‹è¯• 8: è¾¹ç•Œæ¡ä»¶ç»„åˆ
test "boundary_combination" {
  // æµ‹è¯•å¤šä¸ªè¾¹ç•Œæ¡ä»¶çš„ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•è¿ç»­è¿ç®—çš„è¾¹ç•Œå¤„ç†
  let result1 = add(add(max_val, -max_val), max_val)
  assert_eq(max_val, result1)
  
  let result2 = add(add(min_val, -min_val), min_val)
  assert_eq(min_val, result2)
  
  // æµ‹è¯•æ··åˆè¾¹ç•Œè¿ç®—
  let result3 = multiply(add(max_val, min_val), -1)
  assert_eq(1, result3)
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„å¹³æ–¹
  let small_boundary = 46340  // æ¥è¿‘sqrt(max_val)
  let square_result = multiply(small_boundary, small_boundary)
  assert_true(square_result < max_val)
  
  let larger_boundary = 46341
  let overflow_square = multiply(larger_boundary, larger_boundary)
  assert_eq(max_val, overflow_square)
}

// æµ‹è¯• 9: å®é™…åº”ç”¨åœºæ™¯ - åº“å­˜ç®¡ç†
test "inventory_management" {
  // åº“å­˜ç®¡ç†è®¡ç®—
  let initial_stock = 100
  let units_sold = 25
  let units_received = 40
  let units_returned = 5
  let defective_units = 3
  
  // è®¡ç®—å½“å‰åº“å­˜
  let current_stock = add(add(add(initial_stock, -units_sold), units_received), units_returned)
  let final_stock = add(current_stock, -defective_units)
  
  assert_eq(107, final_stock)  // 100 - 25 + 40 + 5 - 3 = 117
  
  // è®¡ç®—åº“å­˜ä»·å€¼
  let unit_cost = 15
  let inventory_value = multiply(final_stock, unit_cost)
  assert_eq(1605, inventory_value)  // 107 * 15 = 1605
  
  // è®¡ç®—è¡¥è´§ç‚¹ï¼ˆå½“å‰åº“å­˜çš„30%ï¼‰
  let reorder_point = multiply(final_stock, 30) / 100
  assert_eq(32, reorder_point)  // 107 * 30 / 100 = 32.1ï¼Œå–æ•´æ•°éƒ¨åˆ†32
}

// æµ‹è¯• 10: ç®—æ³•å®ç° - æœ€å¤§å…¬çº¦æ•°
test "gcd_algorithm" {
  // ä½¿ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•è®¡ç®—æœ€å¤§å…¬çº¦æ•°ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // gcd(a, b) = gcd(b, a % b)ï¼Œå½“ b = 0 æ—¶ï¼Œç»“æœä¸º a
  
  // è®¡ç®— gcd(48, 18)
  let a = 48
  let b = 18
  
  // æ‰‹åŠ¨æ¨¡æ‹Ÿæ¬§å‡ é‡Œå¾—ç®—æ³•
  let step1_a = b
  let step1_b = a % b  // 48 % 18 = 12
  
  let step2_a = step1_b
  let step2_b = step1_a % step1_b  // 18 % 12 = 6
  
  let step3_a = step2_b
  let step3_b = step2_a % step2_b  // 12 % 6 = 0
  
  // å½“ä½™æ•°ä¸º0æ—¶ï¼Œå½“å‰çš„è¢«é™¤æ•°å°±æ˜¯GCD
  let gcd = step3_a
  assert_eq(6, gcd)
  
  // éªŒè¯ï¼š48å’Œ18éƒ½èƒ½è¢«6æ•´é™¤
  assert_true(48 % gcd == 0)
  assert_true(18 % gcd == 0)
  
  // è®¡ç®— gcd(56, 98)
  let c = 56
  let d = 98
  
  let gcd_step1_a = d
  let gcd_step1_b = c % d  // 56 % 98 = 56
  
  let gcd_step2_a = gcd_step1_b
  let gcd_step2_b = gcd_step1_a % gcd_step1_b  // 98 % 56 = 42
  
  let gcd_step3_a = gcd_step2_b
  let gcd_step3_b = gcd_step2_a % gcd_step2_b  // 56 % 42 = 14
  
  let gcd_step4_a = gcd_step3_b
  let gcd_step4_b = gcd_step3_a % gcd_step3_b  // 42 % 14 = 0
  
  let gcd2 = gcd_step4_a
  assert_eq(14, gcd2)
  
  // éªŒè¯
  assert_true(56 % gcd2 == 0)
  assert_true(98 % gcd2 == 0)
}