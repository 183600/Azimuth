// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“æ ¸å¿ƒåŠŸèƒ½çš„é«˜è´¨é‡æµ‹è¯•

test "add_function_edge_cases" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  azimuth::assert_eq(1000000, azimuth::add(500000, 500000))
  azimuth::assert_eq(-1000000, azimuth::add(-500000, -500000))
  azimuth::assert_eq(0, azimuth::add(1000000, -1000000))
  azimuth::assert_eq(1, azimuth::add(2147483647, -2147483646))
}

test "multiply_function_precision" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„ç²¾åº¦
  azimuth::assert_eq(1000000, azimuth::multiply(1000, 1000))
  azimuth::assert_eq(-1000000, azimuth::multiply(1000, -1000))
  azimuth::assert_eq(0, azimuth::multiply(2147483647, 0))
  azimuth::assert_eq(2147483647, azimuth::multiply(1, 2147483647))
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  azimuth::assert_eq(4, azimuth::divide_with_ceil(11, 3))  // 11/3 = 3.666... -> 4
  azimuth::assert_eq(3, azimuth::divide_with_ceil(9, 3))   // 9/3 = 3 -> 3
  azimuth::assert_eq(1, azimuth::divide_with_ceil(1, 100)) // 1/100 = 0.01 -> 1
  azimuth::assert_eq(-3, azimuth::divide_with_ceil(-10, 3)) // -10/3 = -3.333... -> -3
  azimuth::assert_eq(4, azimuth::divide_with_ceil(-11, -3)) // -11/-3 = 3.666... -> 4
  azimuth::assert_eq(0, azimuth::divide_with_ceil(100, 0))  // é™¤æ•°ä¸º0çš„å®‰å…¨å¤„ç†
}

test "greet_function_internationalization" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…åŒ–æ”¯æŒ
  azimuth::assert_eq_string("Hello, ä¸–ç•Œ!", azimuth::greet("ä¸–ç•Œ"))
  azimuth::assert_eq_string("Hello, ğŸŒ!", azimuth::greet("ğŸŒ"))
  azimuth::assert_eq_string("Hello, EspaÃ±ol!", azimuth::greet("EspaÃ±ol"))
  azimuth::assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", azimuth::greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  azimuth::assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", azimuth::greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "complex_business_workflow" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµæµ‹è¯•
  let product_cost = 120
  let quantity = 15
  let tax_rate = 8
  let shipping_cost_per_item = 5
  let discount_threshold = 1000
  let discount_amount = 50
  
  // è®¡ç®—å°è®¡
  let subtotal = azimuth::multiply(product_cost, quantity)
  
  // è®¡ç®—è¿è´¹
  let total_shipping = azimuth::multiply(shipping_cost_per_item, quantity)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = azimuth::divide_with_ceil(azimuth::multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æŠ˜æ‰£å‰æ€»ä»·
  let pre_discount_total = azimuth::add(azimuth::add(subtotal, total_shipping), tax_amount)
  
  // åº”ç”¨æŠ˜æ‰£
  let final_total = if pre_discount_total > discount_threshold {
    azimuth::add(pre_discount_total, -discount_amount)
  } else {
    pre_discount_total
  }
  
  azimuth::assert_eq(1800, subtotal)
  azimuth::assert_eq(75, total_shipping)
  azimuth::assert_eq(144, tax_amount)
  azimuth::assert_eq(2019, pre_discount_total)
  azimuth::assert_eq(1969, final_total)
}

test "mathematical_composition" {
  // æµ‹è¯•æ•°å­¦å‡½æ•°çš„ç»„åˆ
  let x = 12
  let y = 8
  let z = 5
  
  // æµ‹è¯•åˆ†é…å¾‹: x * (y + z) = x * y + x * z
  let distributive_left = azimuth::multiply(x, azimuth::add(y, z))
  let distributive_right = azimuth::add(azimuth::multiply(x, y), azimuth::multiply(x, z))
  azimuth::assert_eq(distributive_left, distributive_right)
  
  // æµ‹è¯•ç»“åˆå¾‹: (x + y) + z = x + (y + z)
  let associative_left = azimuth::add(azimuth::add(x, y), z)
  let associative_right = azimuth::add(x, azimuth::add(y, z))
  azimuth::assert_eq(associative_left, associative_right)
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯æµ‹è¯•
  let principal = 1000
  let rate_percent = 5
  let _years = 3  // æœªä½¿ç”¨çš„å˜é‡
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let amount_after_year1 = azimuth::add(principal, azimuth::divide_with_ceil(azimuth::multiply(principal, rate_percent), 100))
  let amount_after_year2 = azimuth::add(amount_after_year1, azimuth::divide_with_ceil(azimuth::multiply(amount_after_year1, rate_percent), 100))
  let amount_after_year3 = azimuth::add(amount_after_year2, azimuth::divide_with_ceil(azimuth::multiply(amount_after_year2, rate_percent), 100))
  
  azimuth::assert_eq(1050, amount_after_year1)
  azimuth::assert_eq(1103, amount_after_year2)
  azimuth::assert_eq(1158, amount_after_year3)
}

test "inventory_management_system" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯•
  let initial_stock = 500
  let daily_sales = 25
  let weekly_restock = 200
  let days_to_simulate = 14
  
  // è®¡ç®—æ€»é”€å”®é‡
  let total_sold = azimuth::multiply(daily_sales, days_to_simulate)
  
  // è®¡ç®—è¡¥è´§æ¬¡æ•°ï¼ˆæ¯7å¤©è¡¥è´§ä¸€æ¬¡ï¼‰
  let restock_times = azimuth::divide_with_ceil(days_to_simulate, 7)
  
  // è®¡ç®—æ€»è¡¥è´§é‡
  let total_restocked = azimuth::multiply(weekly_restock, restock_times)
  
  // è®¡ç®—æœ€ç»ˆåº“å­˜
  let final_stock = azimuth::add(azimuth::add(initial_stock, -total_sold), total_restocked)
  
  azimuth::assert_eq(350, total_sold)
  azimuth::assert_eq(2, restock_times)
  azimuth::assert_eq(400, total_restocked)
  azimuth::assert_eq(550, final_stock)
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†ç®¡é“æµ‹è¯•
  let raw_data_points = 1000
  let valid_data_ratio = 85
  let processing_batches = 20
  let error_rate = 3
  
  // è®¡ç®—æœ‰æ•ˆæ•°æ®ç‚¹
  let valid_data = azimuth::divide_with_ceil(azimuth::multiply(raw_data_points, valid_data_ratio), 100)
  
  // è®¡ç®—æ¯æ‰¹å¤„ç†çš„æ•°æ®ç‚¹
  let batch_size = azimuth::divide_with_ceil(valid_data, processing_batches)
  
  // è®¡ç®—é¢„æœŸé”™è¯¯æ•°
  let expected_errors = azimuth::divide_with_ceil(azimuth::multiply(valid_data, error_rate), 100)
  
  // è®¡ç®—æˆåŠŸå¤„ç†çš„æ•°æ®ç‚¹
  let successful_data = azimuth::add(valid_data, -expected_errors)
  
  azimuth::assert_eq(850, valid_data)
  azimuth::assert_eq(43, batch_size)
  azimuth::assert_eq(26, expected_errors)
  azimuth::assert_eq(824, successful_data)
}

test "performance_benchmark_simulation" {
  // æ€§èƒ½åŸºå‡†æµ‹è¯•æ¨¡æ‹Ÿ
  let base_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 15
  let concurrent_threads = 4
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ“ä½œæ•°
  let optimized_operations = azimuth::multiply(base_operations, optimization_factor)
  
  // è®¡ç®—å¼€é”€
  let overhead = azimuth::divide_with_ceil(azimuth::multiply(optimized_operations, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = azimuth::add(optimized_operations, -overhead)
  
  // è®¡ç®—æ¯çº¿ç¨‹æ“ä½œæ•°
  let operations_per_thread = azimuth::divide_with_ceil(actual_performance, concurrent_threads)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_improvement = azimuth::divide_with_ceil(actual_performance, base_operations)
  
  azimuth::assert_eq(3000, optimized_operations)
  azimuth::assert_eq(450, overhead)
  azimuth::assert_eq(2550, actual_performance)
  azimuth::assert_eq(638, operations_per_thread)
  azimuth::assert_eq(3, performance_improvement)
}