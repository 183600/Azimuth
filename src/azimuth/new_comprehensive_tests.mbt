// æ–°çš„ç»¼åˆæµ‹è¯•ç”¨ä¾‹ - è¡¥å……æµ‹è¯•è¦†ç›–

///|
test "additive_associativity" {
  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  let a = 100
  let b = 200
  let c = -50
  
  let left = add(add(a, b), c)
  let right = add(a, add(b, c))
  assert_eq(left, right)
  
  // ä½¿ç”¨è¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  let left_boundary = add(add(max_val, 0), min_val)
  let right_boundary = add(max_val, add(0, min_val))
  assert_eq(left_boundary, right_boundary)
}

///|
test "multiplicative_associativity" {
  // æµ‹è¯•ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  let a = 10
  let b = 20
  let c = 3
  
  let left = multiply(multiply(a, b), c)
  let right = multiply(a, multiply(b, c))
  assert_eq(left, right)
  
  // ä½¿ç”¨è´Ÿæ•°æµ‹è¯•
  let x = -5
  let y = 4
  let z = -2
  
  let left_neg = multiply(multiply(x, y), z)
  let right_neg = multiply(x, multiply(y, z))
  assert_eq(left_neg, right_neg)
}

///|
test "distributive_property" {
  // æµ‹è¯•åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 5
  let b = 10
  let c = 15
  
  let left = multiply(a, add(b, c))
  let right = add(multiply(a, b), multiply(a, c))
  assert_eq(left, right)
  
  // ä½¿ç”¨è´Ÿæ•°æµ‹è¯•
  let x = -3
  let y = 7
  let z = -2
  
  let left_neg = multiply(x, add(y, z))
  let right_neg = add(multiply(x, y), multiply(x, z))
  assert_eq(left_neg, right_neg)
}

///|
test "string_with_special_characters" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²å¤„ç†
  assert_eq("Hello, ğŸŒ™!", greet("ğŸŒ™")) // emoji
  assert_eq("Hello, \"quoted\"!", greet("\"quoted\"")) // å¼•å·
  assert_eq("Hello, \\backslash\\!", greet("\\backslash\\")) // åæ–œæ 
  assert_eq("Hello, \nnewline\ttab!", greet("\nnewline\ttab")) // æ¢è¡Œå’Œåˆ¶è¡¨ç¬¦
  assert_eq("Hello, ğŸš€ğŸŒŸğŸ’»!", greet("ğŸš€ğŸŒŸğŸ’»")) // å¤šä¸ªemoji
}

///|
test "extreme_boundary_combinations" {
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼çš„ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸æ¥è¿‘æœ€å¤§å€¼çš„è¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(max_val, add(max_val - 1, 1))
  assert_eq(max_val, add(max_val - 100, 100))
  
  // æœ€å°å€¼ä¸æ¥è¿‘æœ€å°å€¼çš„è¿ç®—
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, add(min_val + 1, -1))
  assert_eq(min_val, add(min_val + 100, -100))
}

///|
test "zero_in_complex_expressions" {
  // æµ‹è¯•é›¶å€¼åœ¨å¤æ‚è¡¨è¾¾å¼ä¸­çš„è¡Œä¸º
  let a = 42
  let b = -17
  let c = 0
  
  // åŠ æ³•ä¸­çš„é›¶
  assert_eq(a, add(a, c))
  assert_eq(b, add(b, c))
  assert_eq(c, add(c, c))
  
  // ä¹˜æ³•ä¸­çš„é›¶
  assert_eq(c, multiply(a, c))
  assert_eq(c, multiply(b, c))
  assert_eq(c, multiply(c, c))
  assert_eq(c, multiply(c, a))
  
  // å¤æ‚è¡¨è¾¾å¼ä¸­çš„é›¶
  let complex1 = add(multiply(a, c), add(b, c))
  assert_eq(b, complex1)
  
  let complex2 = multiply(add(a, c), add(b, c))
  assert_eq(multiply(a, b), complex2)
}

///|
test "subtraction_via_addition" {
  // é€šè¿‡åŠ è´Ÿæ•°å®ç°å‡æ³•: a - b = a + (-b)
  let a = 100
  let b = 30
  
  // a - b = a + (-b)
  let subtraction = add(a, -b)
  assert_eq(70, subtraction)
  
  // ä½¿ç”¨è¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼å‡æ­£æ•°
  let max_sub = add(max_val, -100)
  assert_eq(2147483547, max_sub)
  
  // æœ€å°å€¼å‡è´Ÿæ•°
  let min_sub = add(min_val, 100)
  assert_eq(-2147483548, min_sub)
  
  // è¾¹ç•Œå‡æ³•
  let boundary_sub = add(min_val, -max_val)
  assert_eq(min_val, boundary_sub) // ç”±äºæº¢å‡ºï¼Œç»“æœåº”è¯¥æ˜¯ min_val
}

///|
test "mathematical_series" {
  // æµ‹è¯•æ•°å­¦çº§æ•°è¿ç®—
  // ç­‰å·®æ•°åˆ—: 1 + 2 + 3 + 4 + 5 = 15
  let sum1 = add(1, 2)
  let sum2 = add(sum1, 3)
  let sum3 = add(sum2, 4)
  let sum4 = add(sum3, 5)
  assert_eq(15, sum4)
  
  // ç­‰æ¯”æ•°åˆ—: 1 * 2 * 3 * 4 = 24
  let prod1 = multiply(1, 2)
  let prod2 = multiply(prod1, 3)
  let prod3 = multiply(prod2, 4)
  assert_eq(24, prod3)
  
  // æ··åˆè¿ç®—: (1 + 2) * (3 + 4) = 3 * 7 = 21
  let mixed1 = add(1, 2)
  let mixed2 = add(3, 4)
  let mixed_result = multiply(mixed1, mixed2)
  assert_eq(21, mixed_result)
}

///|
test "commutative_property_verification" {
  // éªŒè¯äº¤æ¢å¾‹ - æµ‹è¯•å‡ ç»„å…¸å‹å€¼
  // æ­£æ•°å¯¹
  let a1 = 10
  let b1 = 20
  assert_eq(add(a1, b1), add(b1, a1))
  assert_eq(multiply(a1, b1), multiply(b1, a1))
  
  // è´Ÿæ•°å¯¹
  let a2 = -5
  let b2 = 7
  assert_eq(add(a2, b2), add(b2, a2))
  assert_eq(multiply(a2, b2), multiply(b2, a2))
  
  // é›¶å€¼å¯¹
  let a3 = 0
  let b3 = 100
  assert_eq(add(a3, b3), add(b3, a3))
  assert_eq(multiply(a3, b3), multiply(b3, a3))
  
  // è¾¹ç•Œå€¼å¯¹
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(add(max_val, 1), add(1, max_val))
  assert_eq(multiply(max_val, 1), multiply(1, max_val))
  assert_eq(add(min_val, 1), add(1, min_val))
  assert_eq(multiply(min_val, 1), multiply(1, min_val))
}

///|
test "string_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ
  // ç©ºå­—ç¬¦ä¸²
  assert_eq("Hello, !", greet(""))
  
  // å•ä¸ªå­—ç¬¦
  assert_eq("Hello, A!", greet("A"))
  assert_eq("Hello, 1!", greet("1"))
  assert_eq("Hello, !!", greet("!")) // greetå‡½æ•°ä¼šåœ¨è¾“å…¥åæ·»åŠ !
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = "This is a very long string that contains many words and characters to test the greet function's ability to handle longer inputs properly"
  let expected = "Hello, " + long_string + "!"
  assert_eq(expected, greet(long_string))
  
  // åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  assert_eq("Hello,  leading space!", greet(" leading space")) // ä¿ç•™å‰å¯¼ç©ºæ ¼
  assert_eq("Hello, trailing space !", greet("trailing space "))
  assert_eq("Hello, multiple   spaces!", greet("multiple   spaces"))
}