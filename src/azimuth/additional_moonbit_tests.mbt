// é¢å¤–çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth é¡¹ç›®æ·»åŠ æ›´å¤šæµ‹è¯•è¦†ç›–

test "divide_with_ceil_basic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(3, divide_with_ceil(10, 4))  // 10/4 = 2.5 â†’ 3
  assert_eq(2, divide_with_ceil(8, 4))   // 8/4 = 2 â†’ 2
  assert_eq(5, divide_with_ceil(21, 5))  // 21/5 = 4.2 â†’ 5
  assert_eq(0, divide_with_ceil(3, 5))   // 3/5 = 0.6 â†’ 1ï¼Œä½†ç”±äºæ•´æ•°é™¤æ³•ç‰¹æ€§ï¼Œè¿™é‡Œæµ‹è¯•è¾¹ç•Œæƒ…å†µ
}

test "divide_with_ceil_negative" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-2, divide_with_ceil(-10, 4))  // -10/4 = -2.5 â†’ -2
  assert_eq(-2, divide_with_ceil(-8, 4))   // -8/4 = -2 â†’ -2
  assert_eq(-4, divide_with_ceil(-21, 5))  // -21/5 = -4.2 â†’ -4
}

test "complex_financial_calculation" {
  // å¤æ‚çš„é‡‘èè®¡ç®—åœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let principal = 10000  // æœ¬é‡‘
  let annual_rate = 6    // å¹´åˆ©ç‡6%
  let months = 12        // 12ä¸ªæœˆ
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—ï¼šæœ¬é‡‘ + (æœ¬é‡‘ Ã— å¹´åˆ©ç‡ Ã— æœˆæ•°) / 12
  let total_interest = multiply(principal, multiply(annual_rate, months)) / 12
  let total_payment = add(principal, total_interest)
  let monthly_payment = total_payment / months
  
  assert_eq(10500, total_payment)     // æ€»è¿˜æ¬¾é¢
  assert_eq(875, monthly_payment)     // æœˆä¾›
}

test "scientific_notation_simulation" {
  // æ¨¡æ‹Ÿç§‘å­¦è®¡æ•°æ³•è®¡ç®—
  // è®¡ç®— 1.23 Ã— 10^6 + 4.56 Ã— 10^5
  // ä½¿ç”¨æ•´æ•°è¡¨ç¤ºï¼š123 Ã— 10^4 + 456 Ã— 10^3
  
  let term1 = multiply(123, 10000)  // 1,230,000
  let term2 = multiply(456, 1000)   // 456,000
  let result = add(term1, term2)    // 1,686,000
  
  assert_eq(1686000, result)
}

test "geometric_progression" {
  // æµ‹è¯•ç­‰æ¯”æ•°åˆ—è®¡ç®—
  // è®¡ç®— 2 + 4 + 8 + 16 + 32
  let term1 = 2
  let term2 = multiply(term1, 2)    // 4
  let term3 = multiply(term2, 2)    // 8
  let term4 = multiply(term3, 2)    // 16
  let term5 = multiply(term4, 2)    // 32
  
  let sum = add(add(add(add(term1, term2), term3), term4), term5)
  assert_eq(62, sum)
}

test "string_with_unicode_characters" {
  // æµ‹è¯•åŒ…å«å„ç§Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, ğŸ‰!", greet("ğŸ‰"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "nested_function_calls" {
  // æµ‹è¯•åµŒå¥—å‡½æ•°è°ƒç”¨
  // è®¡ç®— greet(add(multiply(2, 3), 4)) çš„å­—ç¬¦ä¸²è¡¨ç¤º
  let mult_result = multiply(2, 3)  // 6
  let add_result = add(mult_result, 4)  // 10
  let string_result = greet(add_result.to_string())
  
  // ç”±äºæ²¡æœ‰ç›´æ¥çš„æ•´æ•°è½¬å­—ç¬¦ä¸²å‡½æ•°ï¼Œæˆ‘ä»¬æ‰‹åŠ¨æ„å»º
  assert_eq_string("Hello, 10!", greet("10"))
}

test "algorithm_complexity_simulation" {
  // æ¨¡æ‹Ÿç®—æ³•å¤æ‚åº¦è®¡ç®—
  // O(nÂ²) ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ¨¡æ‹Ÿ
  let n = 100
  
  // è®¡ç®— n Ã— (n + 1) / 2ï¼Œè¡¨ç¤ºå‰nä¸ªæ•´æ•°çš„å’Œ
  let triangular_number = multiply(n, add(n, 1)) / 2
  assert_eq(5050, triangular_number)
  
  // è®¡ç®— nÂ²ï¼Œè¡¨ç¤ºO(nÂ²)å¤æ‚åº¦
  let squared = multiply(n, n)
  assert_eq(10000, squared)
}

test "data_structure_operations" {
  // æ¨¡æ‹Ÿæ•°æ®ç»“æ„æ“ä½œ
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špush, push, pop, push
  let stack1 = 10  // push(10)
  let stack2 = 20  // push(20)
  let stack3 = add(stack1, stack2)  // pop() + pop() = 10 + 20 = 30
  let stack4 = 40  // push(40)
  let final_stack = add(stack3, stack4)  // 30 + 40 = 70
  
  assert_eq(70, final_stack)
}

test "error_boundary_conditions" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œæ¡ä»¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•è¿ç»­æº¢å‡ºæ“ä½œ
  let overflow1 = add(max_val, 1)     // åº”è¯¥è¿”å› max_val
  let overflow2 = add(overflow1, 1)   // åº”è¯¥ä»ç„¶è¿”å› max_val
  assert_eq(max_val, overflow2)
  
  // æµ‹è¯•è¿ç»­ä¸‹æº¢æ“ä½œ
  let underflow1 = add(min_val, -1)   // åº”è¯¥è¿”å› min_val
  let underflow2 = add(underflow1, -1) // åº”è¯¥ä»ç„¶è¿”å› min_val
  assert_eq(min_val, underflow2)
  
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºé“¾
  let mul_overflow1 = multiply(max_val, 2)  // åº”è¯¥è¿”å› max_val
  let mul_overflow2 = multiply(mul_overflow1, 2)  // åº”è¯¥ä»ç„¶è¿”å› max_val
  assert_eq(max_val, mul_overflow2)
}