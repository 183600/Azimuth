// æ–°å¢žçš„é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

// å¯¼å…¥ azimuth åº“
use "azimuth"

// æ–­è¨€å‡½æ•°
fn assert_true(condition : Bool) -> Unit {
  if condition {
    ()
  } else {
    let _ = "Assertion failed"
  }
  ()
}

test "advanced_mathematical_operations" {
  // é«˜çº§æ•°å­¦è¿ç®—æµ‹è¯•
  let x = 15
  let y = 7
  let z = 3
  
  // æµ‹è¯•å¤åˆè¿ç®—ï¼š(x + y) * z - x / y
  let compound_result = add(multiply(add(x, y), z), -divide_with_ceil(x, y))
  assert_eq(63, compound_result)  // (15 + 7) * 3 - ceil(15/7) = 22 * 3 - 3 = 66 - 3 = 63
  
  // æµ‹è¯•åˆ†é…å¾‹ï¼šx * (y + z) = x * y + x * z
  let distributive_left = multiply(x, add(y, z))
  let distributive_right = add(multiply(x, y), multiply(x, z))
  assert_eq(distributive_left, distributive_right)  // 15 * (7 + 3) = 15 * 7 + 15 * 3 = 150
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \t\n\r!", greet("\t\n\r"))
  assert_eq_string("Hello, ðŸŒ™ðŸŒŸ!", greet("ðŸŒ™ðŸŒŸ"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "financial_calculation_scenarios" {
  // é‡‘èžè®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè®¡ç®—è´·æ¬¾åˆ†æœŸ
  let loan_amount = 10000
  let monthly_payment = 450
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(23, months_needed)  // ceil(10000/450) = 23
  
  // åœºæ™¯2ï¼šè®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let principal = 5000
  let rate_percent = 6
  let years = 2
  
  let year1_amount = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2_amount = add(year1_amount, divide_with_ceil(multiply(year1_amount, rate_percent), 100))
  
  assert_eq(5300, year1_amount)  // 5000 + ceil(5000*6/100) = 5000 + 300 = 5300
  assert_eq(5618, year2_amount)  // 5300 + ceil(5300*6/100) = 5300 + 318 = 5618
}

test "resource_optimization_problems" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // åœºæ™¯ï¼šä»“åº“å­˜å‚¨ä¼˜åŒ–
  let items = [
    (120, 25),  // (æ•°é‡, æ¯ç®±å®¹é‡)
    (85, 20),
    (200, 45),
    (67, 15)
  ]
  
  // è®¡ç®—æ¯ç§ç‰©å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_1 = divide_with_ceil(items[0].0, items[0].1)  // ceil(120/25) = 5
  let boxes_2 = divide_with_ceil(items[1].0, items[1].1)  // ceil(85/20) = 5
  let boxes_3 = divide_with_ceil(items[2].0, items[2].1)  // ceil(200/45) = 5
  let boxes_4 = divide_with_ceil(items[3].0, items[3].1)  // ceil(67/15) = 5
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  let total_capacity = add(
    multiply(boxes_1, items[0].1),
    add(multiply(boxes_2, items[1].1), add(multiply(boxes_3, items[2].1), multiply(boxes_4, items[3].1)))
  )
  
  assert_eq(20, total_boxes)
  assert_eq(525, total_capacity)  // 5*25 + 5*20 + 5*45 + 5*15 = 125 + 100 + 225 + 75 = 525
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  let input_sizes = [50, 100, 200]
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_50 = multiply(input_sizes[0], 3)
  let linear_100 = multiply(input_sizes[1], 3)
  let linear_200 = multiply(input_sizes[2], 3)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  let log_50 = divide_with_ceil(input_sizes[0], 10)
  let log_100 = divide_with_ceil(input_sizes[1], 10)
  let log_200 = divide_with_ceil(input_sizes[2], 10)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(150, linear_50)
  assert_eq(300, linear_100)
  assert_eq(600, linear_200)
  
  assert_eq(5, log_50)
  assert_eq(10, log_100)
  assert_eq(20, log_200)
  
  // éªŒè¯çº¿æ€§å¢žé•¿çŽ‡
  assert_eq(multiply(2, linear_50), linear_100)
  assert_eq(multiply(2, linear_100), linear_200)
}

test "data_structure_operations_simulation" {
  // æ•°æ®ç»“æž„æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_capacity = 10
  let stack_items = 7
  let remaining_capacity = subtract(stack_capacity, stack_items)
  let can_push_more = remaining_capacity > 0
  
  assert_eq(3, remaining_capacity)
  assert_true(can_push_more)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_size = 0
  let enqueue_operations = 5
  let dequeue_operations = 2
  let final_queue_size = add(add(queue_size, enqueue_operations), -dequeue_operations)
  
  assert_eq(3, final_queue_size)
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•é™¤é›¶é”™è¯¯çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æµ‹è¯•æžå€¼æƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  let large_num = 1000000
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(1000000000000, multiply(large_num, large_num))
}

test "real_world_application_scenarios" {
  // çœŸå®žä¸–ç•Œåº”ç”¨åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè®¡ç®—æ´»åŠ¨å®‰æŽ’
  let participants = 156
  let tables = 12
  let chairs_per_table = 15
  
  let total_chairs = multiply(tables, chairs_per_table)
  let chairs_needed = divide_with_ceil(participants, chairs_per_table)
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  
  assert_eq(180, total_chairs)
  assert_eq(11, chairs_needed)  // ceil(156/15) = 11
  assert_eq(11, tables_needed)  // ceil(156/15) = 11
  
  // åœºæ™¯2ï¼šè®¡ç®—é¡¹ç›®èµ„æºåˆ†é…
  let total_budget = 50000
  let team_members = 8
  let base_budget_per_member = 5000
  let remaining_budget = subtract(total_budget, multiply(team_members, base_budget_per_member))
  
  assert_eq(10000, remaining_budget)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„é¢å¤–é¡¹ç›®
  let project_costs = [2000, 3000, 1500, 4000]
  let affordable_projects = 0
  
  // ç®€åŒ–çš„é¡¹ç›®è®¡ç®—ï¼ˆç”±äºŽMoonBitè¯­æ³•é™åˆ¶ï¼Œä½¿ç”¨å›ºå®šè®¡ç®—ï¼‰
  let total_project_cost = add(add(add(project_costs[0], project_costs[1]), project_costs[2]), project_costs[3])
  let max_projects = divide_with_ceil(remaining_budget, divide_with_ceil(total_project_cost, 4))
  
  assert_eq(2, max_projects)  // å¯ä»¥æ”¯æŒ2ä¸ªå¹³å‡æˆæœ¬çš„é¡¹ç›®
}

test "performance_and_efficiency_calculations" {
  // æ€§èƒ½å’Œæ•ˆçŽ‡è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šç®—æ³•æ€§èƒ½æ¯”è¾ƒ
  let dataset_size = 10000
  
  // ç®—æ³•Aï¼šO(n)å¤æ‚åº¦
  let algorithm_a_time = multiply(dataset_size, 2)
  
  // ç®—æ³•Bï¼šO(n log n)å¤æ‚åº¦ï¼ˆç®€åŒ–ï¼‰
  let algorithm_b_time = multiply(dataset_size, divide_with_ceil(100, 10))
  
  // ç®—æ³•Cï¼šO(nÂ²)å¤æ‚åº¦ï¼ˆç®€åŒ–ï¼‰
  let algorithm_c_time = divide_with_ceil(multiply(dataset_size, dataset_size), 1000)
  
  // éªŒè¯æ€§èƒ½ç‰¹å¾
  assert_eq(20000, algorithm_a_time)
  assert_eq(100000, algorithm_b_time)
  assert_eq(100000, algorithm_c_time)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let improvement_b_over_a = divide_with_ceil(algorithm_b_time, algorithm_a_time)
  let improvement_c_over_a = divide_with_ceil(algorithm_c_time, algorithm_a_time)
  
  assert_eq(5, improvement_b_over_a)
  assert_eq(5, improvement_c_over_a)
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}