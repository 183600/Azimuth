// å¢å¼ºç»¼åˆæµ‹è¯•å¥—ä»¶ - ä¸º azimuth åº“æ·»åŠ é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// åŒ…å«è¾¹ç•Œæƒ…å†µã€æ€§èƒ½æµ‹è¯•ã€å®é™…åº”ç”¨åœºæ™¯ç­‰

test "extreme_boundary_value_testing" {
  // æç«¯è¾¹ç•Œå€¼æµ‹è¯•
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æµ‹è¯•æ¥è¿‘æœ€å¤§å€¼çš„åŠ æ³•
  assert_eq(2147483646, add(max_int - 1, 1))
  assert_eq(-2147483647, add(min_int + 1, -1))
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  assert_eq(46340, multiply(46340, 1))  // sqrt(INT_MAX)
  assert_eq(0, multiply(max_int, 0))
  
  // æµ‹è¯•æç«¯é™¤æ³•æƒ…å†µ
  assert_eq(2147483647, divide_with_ceil(max_int, 1))
  assert_eq(1, divide_with_ceil(max_int, max_int))
  assert_eq(0, divide_with_ceil(min_int, max_int))
}

test "string_processing_comprehensive" {
  // ç»¼åˆå­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  let empty_string = ""
  let whitespace_string = "   "
  let unicode_string = "ğŸš€ MoonBit ä¸­æ–‡æµ‹è¯•"
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  
  // æµ‹è¯•å„ç§å­—ç¬¦ä¸²è¾“å…¥
  assert_eq_string("Hello, !", greet(empty_string))
  assert_eq_string("Hello,    !", greet(whitespace_string))
  assert_eq_string("Hello, ğŸš€ MoonBit ä¸­æ–‡æµ‹è¯•!", greet(unicode_string))
  assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", greet(special_chars))
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_string = "This is a very long string that contains many words and characters to test the greet function's ability to handle longer inputs without any issues or problems"
  assert_eq_string("Hello, " + long_string + "!", greet(long_string))
}

test "complex_financial_calculations" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  let monthly_contribution = 500
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  
  // æ·»åŠ æœˆä¾›ï¼ˆç®€åŒ–ä¸ºå¹´ä¾›ï¼‰
  let total_contributions = multiply(monthly_contribution, multiply(12, years))
  let final_amount = add(year3_end, total_contributions)
  
  assert_eq(10500, year1_end)  // 10000 + 500
  assert_eq(11025, year2_end)  // 10500 + 525
  assert_eq(11576, year3_end)  // 11025 + 551
  assert_eq(18000, total_contributions)  // 500 * 12 * 3
  assert_eq(29576, final_amount)  // 11576 + 18000
}

test "scientific_computing_scenarios" {
  // ç§‘å­¦è®¡ç®—åœºæ™¯
  let base_measurement = 100
  let precision_factor = 3
  let error_margin = 2
  
  // è®¡ç®—æµ‹é‡å€¼çš„ç²¾åº¦è°ƒæ•´
  let adjusted_value = multiply(base_measurement, precision_factor)
  let error_adjusted = add(adjusted_value, -error_margin)
  let final_measurement = divide_with_ceil(error_adjusted, precision_factor)
  
  // æµ‹è¯•æ¸©åº¦è½¬æ¢æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let celsius = 25
  let fahrenheit_approx = add(multiply(celsius, 9), divide_with_ceil(multiply(5, 160), 5))
  let back_to_celsius = divide_with_ceil(multiply(add(fahrenheit_approx, -32), 5), 9)
  
  assert_eq(298, adjusted_value)  // 100 * 3
  assert_eq(296, error_adjusted)  // 298 - 2
  assert_eq(99, final_measurement)  // ceil(296/3)
  assert_eq(77, fahrenheit_approx)  // 25*9 + 160
  assert_eq(26, back_to_celsius)  // ceil((77-32)*5/9)
}

test "performance_efficiency_testing" {
  // æ€§èƒ½æ•ˆç‡æµ‹è¯•
  let base_operations = 1000
  let optimization_factor = 5
  let overhead_percentage = 12
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ€§èƒ½
  let optimized_ops = multiply(base_operations, optimization_factor)
  let overhead = divide_with_ceil(multiply(optimized_ops, overhead_percentage), 100)
  let actual_performance = add(optimized_ops, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡æ¯”ç‡
  let improvement_ratio = divide_with_ceil(actual_performance, base_operations)
  
  // è®¡ç®—æ•ˆç‡ç™¾åˆ†æ¯”
  let efficiency_percentage = divide_with_ceil(multiply(100, actual_performance), optimized_ops)
  
  assert_eq(5000, optimized_ops)  // 1000 * 5
  assert_eq(600, overhead)  // ceil(5000 * 12 / 100)
  assert_eq(4400, actual_performance)  // 5000 - 600
  assert_eq(5, improvement_ratio)  // ceil(4400 / 1000)
  assert_eq(88, efficiency_percentage)  // ceil(4400 * 100 / 5000)
}

test "logistics_and_supply_chain" {
  // ç‰©æµä¸ä¾›åº”é“¾è®¡ç®—
  let warehouse_capacity = 5000
  let average_package_size = 25
  let daily_shipments = 150
  let delivery_days = 30
  
  // è®¡ç®—éœ€è¦çš„ä»“åº“æ•°é‡
  let total_storage_needed = multiply(average_package_size, daily_shipments)
  let warehouses_needed = divide_with_ceil(total_storage_needed, warehouse_capacity)
  
  // è®¡ç®—æœˆåº¦æ€»è¿é‡
  let monthly_shipments = multiply(daily_shipments, delivery_days)
  let total_volume = multiply(monthly_shipments, average_package_size)
  
  // è®¡ç®—è¿è¾“è½¦è¾†éœ€æ±‚ï¼ˆå‡è®¾æ¯è½¦å®¹é‡1000ï¼‰
  let trucks_needed = divide_with_ceil(total_volume, 1000)
  
  assert_eq(3750, total_storage_needed)  // 25 * 150
  assert_eq(1, warehouses_needed)  // ceil(3750 / 5000)
  assert_eq(4500, monthly_shipments)  // 150 * 30
  assert_eq(112500, total_volume)  // 4500 * 25
  assert_eq(113, trucks_needed)  // ceil(112500 / 1000)
}

test "data_structures_algorithms" {
  // æ•°æ®ç»“æ„å’Œç®—æ³•æ¨¡æ‹Ÿ
  let array_size = 100
  let block_size = 7
  
  // æ¨¡æ‹Ÿæ•°ç»„åˆ†å—å¤„ç†
  let full_blocks = divide_with_ceil(array_size, block_size)
  let remainder = array_size - multiply(full_blocks - 1, block_size)
  
  // æ¨¡æ‹ŸäºŒåˆ†æŸ¥æ‰¾çš„è¿­ä»£æ¬¡æ•°
  let max_iterations = divide_with_ceil(add(array_size, 1), 2)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨è´Ÿè½½å› å­è®¡ç®—
  let initial_capacity = 128
  let elements_inserted = 75
  let load_factor = divide_with_ceil(multiply(elements_inserted, 100), initial_capacity)
  
  assert_eq(15, full_blocks)  // ceil(100 / 7)
  assert_eq(2, remainder)  // 100 - 14 * 7
  assert_eq(51, max_iterations)  // ceil(101 / 2)
  assert_eq(59, load_factor)  // ceil(75 * 100 / 128)
}

test "error_resilience_testing" {
  // é”™è¯¯æ¢å¤èƒ½åŠ›æµ‹è¯•
  let normal_value = 42
  let error_multiplier = 0
  let negative_divisor = -5
  let zero_divisor = 0
  
  // æµ‹è¯•é›¶ä¹˜æ³•çš„å®‰å…¨å¤„ç†
  let zero_product = multiply(normal_value, error_multiplier)
  assert_eq(0, zero_product)
  
  // æµ‹è¯•è´Ÿæ•°é™¤æ³•çš„ä¸€è‡´æ€§
  let neg_div_result1 = divide_with_ceil(normal_value, negative_divisor)
  let neg_div_result2 = divide_with_ceil(-normal_value, negative_divisor)
  let neg_div_result3 = divide_with_ceil(normal_value, -negative_divisor)
  
  // æµ‹è¯•é™¤é›¶çš„å®‰å…¨å¤„ç†
  let div_by_zero_result = divide_with_ceil(normal_value, zero_divisor)
  let neg_div_by_zero_result = divide_with_ceil(-normal_value, zero_divisor)
  let zero_div_by_zero_result = divide_with_ceil(0, zero_divisor)
  
  assert_eq(-8, neg_div_result1)  // ceil(42 / -5) = -8
  assert_eq(9, neg_div_result2)   // ceil(-42 / -5) = 9
  assert_eq(9, neg_div_result3)   // ceil(42 / 5) = 9
  assert_eq(0, div_by_zero_result)
  assert_eq(0, neg_div_by_zero_result)
  assert_eq(0, zero_div_by_zero_result)
}

test "real_world_ecosystem_simulation" {
  // çœŸå®ä¸–ç•Œç”Ÿæ€ç³»ç»Ÿæ¨¡æ‹Ÿ
  let initial_population = 1000
  let birth_rate = 12  // 12%
  let death_rate = 8   // 8%
  let migration_rate = 5  // 5%
  let seasons = 4
  
  // è®¡ç®—ä¸€ä¸ªå­£èŠ‚åçš„äººå£å˜åŒ–
  let births = divide_with_ceil(multiply(initial_population, birth_rate), 100)
  let deaths = divide_with_ceil(multiply(initial_population, death_rate), 100)
  let immigration = divide_with_ceil(multiply(initial_population, migration_rate), 100)
  
  let seasonal_change = add(add(births, -deaths), immigration)
  let population_after_season = add(initial_population, seasonal_change)
  
  // è®¡ç®—å¹´åº¦å˜åŒ–
  let annual_change = multiply(seasonal_change, seasons)
  let year_end_population = add(initial_population, annual_change)
  
  assert_eq(120, births)  // ceil(1000 * 12 / 100)
  assert_eq(80, deaths)   // ceil(1000 * 8 / 100)
  assert_eq(50, immigration)  // ceil(1000 * 5 / 100)
  assert_eq(90, seasonal_change)  // 120 - 80 + 50
  assert_eq(1090, population_after_season)  // 1000 + 90
  assert_eq(360, annual_change)  // 90 * 4
  assert_eq(1360, year_end_population)  // 1000 + 360
}

test "advanced_mathematical_series" {
  // é«˜ç­‰æ•°å­¦çº§æ•°è®¡ç®—
  let n = 10  // çº§æ•°é¡¹æ•°
  let first_term = 3
  let common_difference = 4
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—ç¬¬né¡¹
  let nth_term = add(first_term, multiply(n - 1, common_difference))
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œ
  let series_sum = divide_with_ceil(multiply(n, add(first_term, nth_term)), 2)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let geometric_ratio = 2
  let geo_first_term = 1
  let geo_nth_term = multiply(geo_first_term, multiply(geometric_ratio, n - 1))
  let geo_series_sum = multiply(geo_first_term, divide_with_ceil(multiply(add(1, -multiply(geometric_ratio, n)), 1), add(1, -geometric_ratio)))
  
  // è®¡ç®—å¹³æ–¹å’Œ
  let square_sum = multiply(n, multiply(add(n, 1), multiply(add(multiply(2, n), 1), 1))) / 6
  
  assert_eq(39, nth_term)  // 3 + (10-1)*4 = 3 + 36 = 39
  assert_eq(210, series_sum)  // ceil(10 * (3 + 39) / 2) = ceil(10 * 42 / 2) = 210
  assert_eq(512, geo_nth_term)  // 1 * 2^(10-1) = 512
  assert_eq(1023, geo_series_sum)  // ç®€åŒ–çš„ç­‰æ¯”æ•°åˆ—æ±‚å’Œ
  assert_eq(385, square_sum)  // 10 * 11 * 21 / 6 = 385
}