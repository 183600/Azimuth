// æ–°çš„ç»¼åˆæµ‹è¯•ç”¨ä¾‹ - æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œå…¨é¢æµ‹è¯•

test "addition_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 42
  let b = 17
  assert_eq(add(a, b), add(b, a))
  assert_eq(59, add(a, b))
}

test "multiplication_identity_element" {
  // æµ‹è¯•ä¹˜æ³•å•ä½å…ƒï¼ša * 1 = a
  assert_eq(0, multiply(0, 1))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(-1, 1))
  assert_eq(5, multiply(5, 1))
  assert_eq(10, multiply(10, 1))
  assert_eq(100, multiply(100, 1))
}

test "divide_with_ceil_precision_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  assert_eq(4, divide_with_ceil(11, 3))  // 11/3 = 3.666... -> 4
  assert_eq(3, divide_with_ceil(9, 3))   // 9/3 = 3 -> 3
  assert_eq(1, divide_with_ceil(1, 100)) // 1/100 = 0.01 -> 1
  assert_eq(0, divide_with_ceil(0, 5))   // 0/5 = 0 -> 0
  assert_eq(0, divide_with_ceil(10, 0))  // é™¤æ•°ä¸º0çš„å®‰å…¨å¤„ç†
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ðŸŒŸ!", greet("ðŸŒŸ"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ÐœÐ¾ÑÐºÐ²Ð°!", greet("ÐœÐ¾ÑÐºÐ²Ð°"))
}

test "complex_arithmetic_expression" {
  // æµ‹è¯•å¤æ‚ç®—æœ¯è¡¨è¾¾å¼
  // è®¡ç®—ï¼š(a + b) * c - d / e
  let a = 10
  let b = 15
  let c = 4
  let d = 20
  let e = 3
  
  let result = add(multiply(add(a, b), c), -divide_with_ceil(d, e))
  assert_eq(93, result)  // (10 + 15) * 4 - ceil(20/3) = 25 * 4 - 7 = 100 - 7 = 93
}

test "financial_calculation_scenario" {
  // æµ‹è¯•é‡‘èžè®¡ç®—åœºæ™¯
  let principal = 1000
  let interest_rate = 5  // 5%
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—
  let year1 = add(principal, divide_with_ceil(multiply(principal, interest_rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, interest_rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, interest_rate), 100))
  
  assert_eq(1050, year1)  // 1000 + 50
  assert_eq(1103, year2)  // 1050 + 53
  assert_eq(1158, year3)  // 1103 + 55
}

test "inventory_management_calculation" {
  // æµ‹è¯•åº“å­˜ç®¡ç†è®¡ç®—
  let items_per_box = 24
  let total_items = 100
  
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  let remaining_space = add(multiply(boxes_needed, items_per_box), -total_items)
  
  assert_eq(5, boxes_needed)      // ceil(100/24) = 5
  assert_eq(20, remaining_space) // 5*24 - 100 = 120 - 100 = 20
}

test "string_concatenation_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¿žæŽ¥è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 1234567890!", greet("1234567890"))
}

test "negative_number_division_behavior" {
  // æµ‹è¯•è´Ÿæ•°é™¤æ³•è¡Œä¸º
  assert_eq(-3, divide_with_ceil(-10, 3))   // -10/3 = -3.333... -> -3
  assert_eq(-4, divide_with_ceil(-11, 3))   // -11/3 = -3.666... -> -4
  assert_eq(4, divide_with_ceil(-10, -3))   // -10/-3 = 3.666... -> 4
  assert_eq(3, divide_with_ceil(-9, -3))    // -9/-3 = 3 -> 3
}

test "performance_optimization_calculation" {
  // æµ‹è¯•æ€§èƒ½ä¼˜åŒ–è®¡ç®—
  let base_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 15
  
  let optimized_ops = multiply(base_operations, optimization_factor)
  let overhead = divide_with_ceil(multiply(optimized_ops, overhead_percentage), 100)
  let actual_performance = add(optimized_ops, -overhead)
  
  assert_eq(3000, optimized_ops)
  assert_eq(450, overhead)
  assert_eq(2550, actual_performance)
}