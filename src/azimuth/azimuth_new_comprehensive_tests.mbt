// æ–°å¢çš„é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„ç»¼åˆæµ‹è¯•ï¼ŒåŒ…å«åŸºç¡€åŠŸèƒ½ã€è¾¹ç•Œæƒ…å†µå’Œå®é™…åº”ç”¨åœºæ™¯

test "add_function_edge_cases" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, add(2147483647, -2147483647))  // æœ€å¤§å€¼ä¸æœ€å°å€¼ç›¸åŠ 
  assert_eq(1, add(2147483646, 1))            // æ¥è¿‘æœ€å¤§å€¼
  assert_eq(-1, add(-2147483647, 1))           // æ¥è¿‘æœ€å°å€¼
  assert_eq(0, add(1000, -1000))               // ç›¸åæ•°ç›¸åŠ 
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, multiply(2147483647, 0))        // æœ€å¤§å€¼ä¹˜é›¶
  assert_eq(-2147483647, multiply(-1, 2147483647))  // è´Ÿä¸€ä¹˜æœ€å¤§å€¼
  assert_eq(1, multiply(-1, -1))               // è´Ÿæ•°ç›¸ä¹˜å¾—æ­£
  assert_eq(1000000, multiply(1000, 1000))     // å¤§æ•°ç›¸ä¹˜
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(1, divide_with_ceil(1, 100))       // è¢«é™¤æ•°å°äºé™¤æ•°
  assert_eq(100, divide_with_ceil(9999, 100))  // æ¥è¿‘æ•´é™¤
  assert_eq(-3, divide_with_ceil(-10, 3))      // è´Ÿæ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(-11, -3))      // è´Ÿæ•°é™¤è´Ÿæ•°
  assert_eq(0, divide_with_ceil(0, 100))       // é›¶é™¤æ³•
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode æ”¯æŒ
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", greet("Î±Î²Î³Î´Îµ"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let a = 12
  let b = 8
  let c = 5
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  // åˆ†é…å¾‹
  assert_eq(multiply(a, add(b, c)), add(multiply(a, b), multiply(a, c)))
}

test "real_world_shopping_cart" {
  // çœŸå®è´­ç‰©è½¦è®¡ç®—åœºæ™¯
  let item1_price = 29
  let item1_quantity = 2
  let item2_price = 15
  let item2_quantity = 3
  let shipping_fee = 12
  let discount = 20
  
  let subtotal = add(multiply(item1_price, item1_quantity), multiply(item2_price, item2_quantity))
  let total_before_discount = add(subtotal, shipping_fee)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(115, final_total)  // 29*2 + 15*3 + 12 - 20 = 58 + 45 + 12 - 20 = 95
}

test "inventory_packaging_optimization" {
  // åº“å­˜åŒ…è£…ä¼˜åŒ–è®¡ç®—
  let total_products = 127
  let box_capacity = 15
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let total_capacity = multiply(boxes_needed, box_capacity)
  let unused_space = add(total_capacity, -total_products)
  
  assert_eq(9, boxes_needed)      // ceil(127/15) = 9
  assert_eq(8, unused_space)      // 9*15 - 127 = 135 - 127 = 8
}

test "time_management_calculation" {
  // æ—¶é—´ç®¡ç†è®¡ç®—
  let daily_tasks = 6
  let total_tasks = 47
  let work_days_needed = divide_with_ceil(total_tasks, daily_tasks)
  
  // è®¡ç®—æ€»å·¥ä½œå°æ—¶æ•°ï¼ˆæ¯å¤©8å°æ—¶ï¼‰
  let total_work_hours = multiply(work_days_needed, 8)
  
  assert_eq(8, work_days_needed)    // ceil(47/6) = 8
  assert_eq(64, total_work_hours)   // 8 * 8 = 64
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—
  let principal = 1000
  let interest_rate = 5
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year1 = add(principal, divide_with_ceil(multiply(principal, interest_rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, interest_rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, interest_rate), 100))
  
  assert_eq(1050, year1)   // 1000 + ceil(1000*5/100) = 1000 + 50 = 1050
  assert_eq(1103, year2)   // 1050 + ceil(1050*5/100) = 1050 + 53 = 1103
  assert_eq(1158, year3)   // 1103 + ceil(1103*5/100) = 1103 + 55 = 1158
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†ç®¡é“æ¨¡æ‹Ÿ
  let input_data = 1000
  let error_rate = 2  // 2% é”™è¯¯ç‡
  
  // æ¨¡æ‹Ÿå¤„ç†æ­¥éª¤
  let step1_result = add(input_data, -divide_with_ceil(multiply(input_data, error_rate), 100))
  let step2_result = add(step1_result, -divide_with_ceil(multiply(step1_result, error_rate), 100))
  let final_result = add(step2_result, -divide_with_ceil(multiply(step2_result, error_rate), 100))
  
  assert_eq(980, step1_result)     // 1000 - ceil(1000*2/100) = 1000 - 20 = 980
  assert_eq(960, step2_result)     // 980 - ceil(980*2/100) = 980 - 20 = 960
  assert_eq(941, final_result)     // 960 - ceil(960*2/100) = 960 - 19 = 941
}