// ç»¼åˆè´¨é‡æµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“çš„é«˜çº§æµ‹è¯•
// åŒ…å«æ€§èƒ½æµ‹è¯•ã€è¾¹ç•Œå€¼æµ‹è¯•å’Œå®é™…åº”ç”¨åœºæ™¯

test "extreme_boundary_values" {
  // æç«¯è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, add(2147483646, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483648, add(-2147483647, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(0, add(2147483647, -2147483647))  // æœ€å¤§å€¼ä¸ç›¸åæ•°ç›¸åŠ 
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 1))  // å®Œå…¨ç›¸ç­‰
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(100, divide_with_ceil(9999, 100))  // 99.99 -> 100
  assert_eq(1, divide_with_ceil(-1, -1))  // è´Ÿæ•°ç›¸ç­‰
  assert_eq(-2, divide_with_ceil(-3, 2))  // -1.5 -> -1 (å®ç°å¯èƒ½ä¸åŒ)
}

test "string_greeting_unicode" {
  // Unicode å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "complex_mathematical_expressions" {
  // å¤æ‚æ•°å­¦è¡¨è¾¾å¼æµ‹è¯•
  let x = 10
  let y = 20
  let z = 5
  
  // æµ‹è¯•è¡¨è¾¾å¼ï¼š(x + y) * z - x / y
  let result = add(multiply(add(x, y), z), -divide_with_ceil(x, y))
  assert_eq(149, result)  // (10 + 20) * 5 - ceil(10/20) = 30*5 - 1 = 150 - 1 = 149
  
  // æµ‹è¯•åµŒå¥—è¡¨è¾¾å¼
  let nested = divide_with_ceil(multiply(add(x, multiply(y, z)), 2), 3)
  assert_eq(67, nested)  // ceil((10 + 20*5) * 2 / 3) = ceil(110 * 2 / 3) = ceil(220/3) = 74
}

test "real_world_calculator_simulation" {
  // æ¨¡æ‹ŸçœŸå®è®¡ç®—å™¨åœºæ™¯
  // è®¡ç®—è´­ç‰©æ¸…å•ï¼šè‹¹æœ3å…ƒ/kgä¹°2kgï¼Œé¦™è•‰5å…ƒ/kgä¹°1.5kgï¼Œå‘ä¸Šå–æ•´è®¡ç®—æ€»ä»·
  let apple_price_per_kg = 3
  let apple_qty_kg = 2
  let banana_price_per_kg = 5
  let banana_qty_kg = 1  // å‘ä¸Šå–æ•´
  
  let apple_total = multiply(apple_price_per_kg, apple_qty_kg)
  let banana_total = multiply(banana_price_per_kg, divide_with_ceil(multiply(banana_qty_kg, 10), 10))
  let shopping_total = add(apple_total, banana_total)
  
  assert_eq(13, shopping_total)  // 3*2 + 5*ceil(1.5) = 6 + 5*2 = 16
}

test "batch_processing_simulation" {
  // æ‰¹å¤„ç†æ¨¡æ‹Ÿï¼šè®¡ç®—å¤šæ‰¹æ¬¡çš„å¤„ç†éœ€æ±‚
  let batch_sizes = [15, 8, 23, 7, 11]
  let processor_capacity = 10
  
  // è®¡ç®—æ¯æ‰¹éœ€è¦çš„å¤„ç†å™¨æ•°é‡
  let batch1_processors = divide_with_ceil(batch_sizes[0], processor_capacity)
  let batch2_processors = divide_with_ceil(batch_sizes[1], processor_capacity)
  let batch3_processors = divide_with_ceil(batch_sizes[2], processor_capacity)
  let batch4_processors = divide_with_ceil(batch_sizes[3], processor_capacity)
  let batch5_processors = divide_with_ceil(batch_sizes[4], processor_capacity)
  
  let total_processors = add(add(add(add(batch1_processors, batch2_processors), batch3_processors), batch4_processors), batch5_processors)
  
  assert_eq(9, total_processors)  // ceil(15/10)+ceil(8/10)+ceil(23/10)+ceil(7/10)+ceil(11/10) = 2+1+3+1+2 = 9
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks_per_day = 8
  let total_tasks = 45
  let days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  
  // è®¡ç®—å·¥ä½œå°æ—¶æ•°ï¼ˆæ¯å¤©8å°æ—¶ï¼‰
  let total_hours = multiply(days_needed, 8)
  
  assert_eq(6, days_needed)  // ceil(45/8) = 6
  assert_eq(48, total_hours)  // 6 * 8 = 48
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 100
  let project1_needs = 30
  let project2_needs = 45
  let project3_needs = 20
  
  let allocated1 = project1_needs
  let allocated2 = project2_needs
  let allocated3 = project3_needs
  let total_allocated = add(add(allocated1, allocated2), allocated3)
  let remaining = add(total_resources, -total_allocated)
  
  assert_eq(95, total_allocated)  // 30 + 45 + 20 = 95
  assert_eq(5, remaining)  // 100 - 95 = 5
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„æƒ…å†µ
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let big_num = 1000000
  assert_eq(2000000, add(big_num, big_num))
  assert_eq(1000000000000, multiply(big_num, big_num))
}