// è´¨é‡å¢å¼ºçš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åº“çš„é«˜çº§åŠŸèƒ½å’Œåœºæ™¯

test "enhanced_arithmetic_operations" {
  // æµ‹è¯•å¢å¼ºç®—æœ¯è¿ç®—
  assert_eq(100, add(45, 55))
  assert_eq(200, multiply(20, 10))
  assert_eq(-30, add(-10, -20))
  assert_eq(50, multiply(-10, -5))
  assert_eq(5, add(15, -10))
  assert_eq(-40, multiply(8, -5))
}

test "advanced_boundary_handling" {
  // æµ‹è¯•é«˜çº§è¾¹ç•Œå¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 1000000))
  assert_eq(min_val, add(min_val, -1000000))
  assert_eq(max_val, multiply(max_val, 2))
  assert_eq(min_val, multiply(min_val, 2))
  assert_eq(2147483646, add(max_val, -1))
  assert_eq(-2147483647, add(min_val, 1))
  assert_eq(0, multiply(max_val, 0))
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, ğŸŒŸâœ¨ğŸš€!", greet("ğŸŒŸâœ¨ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", greet("Î±Î²Î³Î´Îµ"))
  
  let long_str = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ç”¨æ¥æµ‹è¯•ç³»ç»Ÿçš„å¤„ç†èƒ½åŠ›"
  assert_eq_string("Hello, " + long_str + "!", greet(long_str))
}

test "mathematical_formula_applications" {
  // æµ‹è¯•æ•°å­¦å…¬å¼åº”ç”¨
  let n = 10
  let a1 = 1
  let an = 10
  let arithmetic_sum = multiply(n, add(a1, an)) / 2
  assert_eq(55, arithmetic_sum)
  
  // ç®€åŒ–çš„ç­‰æ¯”æ•°åˆ—æ±‚å’Œ
  let geometric_sum = multiply(2, multiply(multiply(27, 1) - 1, 1)) / 2
  assert_eq(80, geometric_sum)
}

test "real_world_financial_calculations" {
  // æµ‹è¯•å®é™…é‡‘èè®¡ç®—
  let principal = 10000
  let rate = 5
  let years = 3
  let compound_interest = multiply(principal, add(100, multiply(rate, years)))
  assert_eq(1150000, compound_interest)
  
  let loan_amount = 50000
  let monthly_payment = 2000
  let months = multiply(loan_amount, 100) / monthly_payment
  assert_eq(2500, months)
}

test "data_structure_simulation" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ¨¡æ‹Ÿ
  let stack_top = 100
  let push_value = 50
  let new_top = add(stack_top, push_value)
  assert_eq(150, new_top)
  
  let pop_value = 30
  let popped_top = add(new_top, -pop_value)
  assert_eq(120, popped_top)
  
  let queue_front = 1
  let queue_rear = 5
  let queue_size = add(queue_rear, -queue_front) + 1
  assert_eq(5, queue_size)
}

test "algorithm_complexity_simulation" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿ
  let array_size = 1000
  let search_iterations = multiply(array_size, 1)
  assert_eq(1000, search_iterations)
  
  let binary_iterations = array_size / 2
  assert_eq(500, binary_iterations)
  
  let bubble_comparisons = multiply(array_size, array_size) / 2
  assert_eq(500000, bubble_comparisons)
}

test "error_resilience_testing" {
  // æµ‹è¯•é”™è¯¯æ¢å¤èƒ½åŠ›
  let dividend = 100
  let divisor = 0
  let safe_result = if (divisor == 0) { 0 } else { dividend / divisor }
  assert_eq(0, safe_result)
  
  let max_val = 2147483647
  let overflow_result = add(max_val, max_val)
  assert_true(overflow_result == max_val)
  
  let empty_result = greet("")
  assert_eq_string("Hello, !", empty_result)
}

test "performance_benchmark_scenarios" {
  // æµ‹è¯•æ€§èƒ½åŸºå‡†åœºæ™¯
  let large_num1 = 1000000
  let large_num2 = 2000000
  let large_sum = add(large_num1, large_num2)
  let large_product = multiply(large_num1, 1000)
  
  assert_eq(3000000, large_sum)
  assert_eq(1000000000, large_product)
  
  let base = 10
  let repetitions = 100
  let repeated_sum = multiply(base, repetitions)
  assert_eq(1000, repeated_sum)
}

test "comprehensive_integration_test" {
  // ç»¼åˆé›†æˆæµ‹è¯•
  let unit_price = 199
  let quantity = 5
  let discount_rate = 10
  let tax_rate = 8
  let shipping = 20
  
  let subtotal = multiply(unit_price, quantity)
  let discount = multiply(subtotal, discount_rate) / 100
  let discounted_total = add(subtotal, -discount)
  let tax = multiply(discounted_total, tax_rate) / 100
  let final_total = add(add(discounted_total, tax), shipping)
  
  assert_eq(1076, final_total)
  assert_eq(995, subtotal)
  assert_eq(99, discount)
  assert_eq(896, discounted_total)
  assert_eq(71, tax)
}