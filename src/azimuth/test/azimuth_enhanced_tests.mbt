// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹
// æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•ï¼Œä¸ºé¡¹ç›®æä¾›é¢å¤–çš„æµ‹è¯•è¦†ç›–

// å®šä¹‰å¿…è¦çš„æµ‹è¯•å‡½æ•°
fn assert_eq(lhs : Int, rhs : Int) -> Unit {
  if lhs != rhs {
    @builtin.abort("Assertion failed")
  } else {
    ()
  }
}

fn assert_eq_string(lhs : String, rhs : String) -> Unit {
  if lhs != rhs {
    @builtin.abort("String assertion failed")
  } else {
    ()
  }
}

// å®šä¹‰æ ¸å¿ƒåŠŸèƒ½å‡½æ•°
fn add(a : Int, b : Int) -> Int {
  a + b
}

fn multiply(a : Int, b : Int) -> Int {
  a * b
}

fn subtract(a : Int, b : Int) -> Int {
  a - b
}

fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

test "subtract_function_comprehensive" {
  // å…¨é¢æµ‹è¯•å‡æ³•åŠŸèƒ½
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
  assert_eq(0, subtract(5, 5))
  assert_eq(10, subtract(0, -10))
  assert_eq(-10, subtract(-5, 5))
  assert_eq(0, subtract(0, 0))
}

test "complex_mathematical_precision" {
  // æµ‹è¯•å¤æ‚æ•°å­¦è¿ç®—çš„ç²¾åº¦
  let a = 100
  let b = 3
  
  // æµ‹è¯• ((a / b) * b) + (a % b) çš„ç²¾åº¦ä¿æŒ
  let quotient = divide_with_ceil(a, b)
  let product = multiply(quotient, b)
  let remainder = a % b
  let result = add(product, remainder)
  
  assert_eq(34, quotient)  // ceil(100/3) = 34
  assert_eq(102, product)  // 34 * 3 = 102
  assert_eq(1, remainder)  // 100 % 3 = 1
  assert_eq(103, result)   // 102 + 1 = 103
}

test "boundary_condition_handling" {
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶çš„å¤„ç†
  // æµ‹è¯•æ¥è¿‘æ•´æ•°æé™çš„è¿ç®—
  let near_max = 2147483640
  let near_min = -2147483640
  
  assert_eq(2147483641, add(near_max, 1))
  assert_eq(-2147483641, add(near_min, -1))
  assert_eq(0, multiply(near_max, 0))
  assert_eq(1, divide_with_ceil(near_max, near_max))
}

test "real_world_financial_calculation" {
  // çœŸå®ä¸–ç•Œé‡‘èè®¡ç®—åœºæ™¯
  // è®¡ç®—è´·æ¬¾åˆ†æœŸä»˜æ¬¾
  let principal = 50000
  let annual_rate = 6  // 6%
  let loan_term_years = 5
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—
  let total_months = multiply(loan_term_years, 12)
  let total_interest = divide_with_ceil(multiply(principal, annual_rate * loan_term_years), 100)
  let total_payment = add(principal, total_interest)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  
  assert_eq(60, total_months)
  assert_eq(15000, total_interest)
  assert_eq(65000, total_payment)
  assert_eq(1084, monthly_payment)  // ceil(65000/60)
}

test "error_resilience_validation" {
  // é”™è¯¯æ¢å¤å’ŒéªŒè¯æµ‹è¯•
  // æµ‹è¯•å„ç§å¼‚å¸¸è¾“å…¥çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æµ‹è¯•å­—ç¬¦ä¸²å‡½æ•°çš„ç©ºå€¼å¤„ç†
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, !", greet(""))
}

test "performance_benchmark_operations" {
  // æ€§èƒ½åŸºå‡†è¿ç®—æµ‹è¯•
  // æ¨¡æ‹Ÿå¤§æ•°æ®é›†çš„å¤„ç†
  let dataset_size = 10000
  let operations_per_item = 5
  
  // è®¡ç®—æ€»æ“ä½œæ•°
  let total_operations = multiply(dataset_size, operations_per_item)
  
  // è®¡ç®—å¤„ç†æ‰¹æ¬¡ï¼ˆæ¯æ‰¹1000ä¸ªæ“ä½œï¼‰
  let batch_size = 1000
  let batches_needed = divide_with_ceil(total_operations, batch_size)
  
  // è®¡ç®—é¢„ä¼°å¤„ç†æ—¶é—´ï¼ˆæ¯æ‰¹2ç§’ï¼‰
  let estimated_time = multiply(batches_needed, 2)
  
  assert_eq(50000, total_operations)
  assert_eq(50, batches_needed)
  assert_eq(100, estimated_time)
}

test "data_type_conversion_simulation" {
  // æ•°æ®ç±»å‹è½¬æ¢æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæµ®ç‚¹æ•°è¿ç®—çš„æ•´æ•°è¿‘ä¼¼
  
  // ä½¿ç”¨æ•´æ•°è¿ç®—æ¨¡æ‹Ÿæµ®ç‚¹è¿ç®—
  let scaled_1 = multiply(37, 10)  // 3.7 * 10
  let scaled_2 = multiply(23, 10)  // 2.3 * 10
  let scaled_sum = add(scaled_1, scaled_2)
  let result = divide_with_ceil(scaled_sum, 10)
  
  assert_eq(370, scaled_1)
  assert_eq(230, scaled_2)
  assert_eq(600, scaled_sum)
  assert_eq(60, result)  // ceil(600/10) = 60
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦
  let input_size = 1000
  
  // O(1) å¸¸æ•°æ—¶é—´
  let constant_time = 1
  
  // O(log n) å¯¹æ•°æ—¶é—´ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let log_time = divide_with_ceil(input_size, 100)
  
  // O(n) çº¿æ€§æ—¶é—´
  let linear_time = input_size
  
  // O(n log n) çº¿æ€§å¯¹æ•°æ—¶é—´
  let linear_log_time = multiply(input_size, divide_with_ceil(input_size, 1000))
  
  // O(nÂ²) å¹³æ–¹æ—¶é—´
  let quadratic_time = multiply(input_size, input_size)
  
  assert_eq(1, constant_time)
  assert_eq(10, log_time)
  assert_eq(1000, linear_time)
  assert_eq(10000, linear_log_time)
  assert_eq(1000000, quadratic_time)
}

test "international_character_processing" {
  // å›½é™…åŒ–å­—ç¬¦å¤„ç†æµ‹è¯•
  // æµ‹è¯•å„ç§Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
  assert_eq_string("Hello, à¤¹à¤¿à¤¨à¥à¤¦à¥€!", greet("à¤¹à¤¿à¤¨à¥à¤¦à¥€"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, ÎµÎ»Î»Î·Î½Î¹ÎºÎ¬!", greet("ÎµÎ»Î»Î·Î½Î¹ÎºÎ¬"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "concurrent_scenario_simulation" {
  // å¹¶å‘åœºæ™¯æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿå¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„è®¡ç®—
  let thread_count = 8
  let tasks_per_thread = 125
  let total_tasks = multiply(thread_count, tasks_per_thread)
  
  // æ¨¡æ‹Ÿä»»åŠ¡åˆ†é…
  let base_tasks_per_thread = divide_with_ceil(total_tasks, thread_count)
  let remaining_tasks = subtract(total_tasks, multiply(base_tasks_per_thread, thread_count))
  
  // è®¡ç®—å®é™…å¤„ç†æ—¶é—´ï¼ˆæ¯çº¿ç¨‹å¤„ç†æ—¶é—´ï¼‰
  let processing_time_per_thread = base_tasks_per_thread
  let total_processing_time = multiply(processing_time_per_thread, thread_count)
  
  assert_eq(1000, total_tasks)
  assert_eq(125, base_tasks_per_thread)
  assert_eq(0, remaining_tasks)
  assert_eq(1000, total_processing_time)
}