// å¢å¼ºå•å…ƒæµ‹è¯• - 10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½è¿›è¡Œæ·±åº¦æµ‹è¯•

test "mathematical_associative_laws" {
  // æµ‹è¯•æ•°å­¦ç»“åˆå¾‹
  let a = 5
  let b = 8
  let c = 12
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "boundary_value_analysis" {
  // è¾¹ç•Œå€¼åˆ†ææµ‹è¯•
  // æµ‹è¯•æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„å€¼
  assert_eq(2147483646, add(2147483645, 1))
  assert_eq(-2147483647, add(-2147483646, -1))
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(0, divide_with_ceil(1, 2147483647))
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—è´·æ¬¾åˆ†æœŸå’Œæ€»åˆ©æ¯
  let principal = 50000
  let monthly_payment = 2200
  let months_needed = divide_with_ceil(principal, monthly_payment)
  
  assert_eq(23, months_needed)  // ceil(50000/2200) = 23
  
  // è®¡ç®—å®é™…æ€»æ”¯ä»˜
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(50600, total_payment)
  
  // è®¡ç®—æ€»åˆ©æ¯
  let total_interest = add(total_payment, -principal)
  assert_eq(600, total_interest)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
  assert_eq_string("Hello, \"quotes\"!", greet("\"quotes\""))
  assert_eq_string("Hello, 'single'!", greet("'single'"))
  assert_eq_string("Hello, \\backslash!", greet("\\backslash"))
  assert_eq_string("Hello, emoji ğŸ‰ğŸš€!", greet("emoji ğŸ‰ğŸš€"))
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨å†…å­˜åˆ†é…ä¼˜åŒ–
  let total_memory = 32768  // GB
  let servers = 7
  let base_memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(4682, base_memory_per_server)  // ceil(32768/7)
  
  // è®¡ç®—å®é™…åˆ†é…å’Œæµªè´¹
  let total_allocated = multiply(base_memory_per_server, servers)
  let memory_waste = add(total_allocated, -total_memory)
  
  assert_eq(32774, total_allocated)
  assert_eq(6, memory_waste)
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  let input_sizes = [50, 500, 5000]
  
  // æ¨¡æ‹ŸO(n)çº¿æ€§ç®—æ³•
  let linear_50 = multiply(input_sizes[0], 3)
  let linear_500 = multiply(input_sizes[1], 3)
  let linear_5000 = multiply(input_sizes[2], 3)
  
  // æ¨¡æ‹ŸO(log n)å¯¹æ•°ç®—æ³•ï¼ˆç®€åŒ–ï¼‰
  let log_50 = divide_with_ceil(input_sizes[0], 10)
  let log_500 = divide_with_ceil(input_sizes[1], 10)
  let log_5000 = divide_with_ceil(input_sizes[2], 10)
  
  assert_eq(150, linear_50)
  assert_eq(1500, linear_500)
  assert_eq(15000, linear_5000)
  
  assert_eq(5, log_50)
  assert_eq(50, log_500)
  assert_eq(500, log_5000)
}

test "error_recovery_scenarios" {
  // é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // æµ‹è¯•å„ç§é™¤é›¶é”™è¯¯çš„å®‰å…¨å¤„ç†
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æµ‹è¯•æå°é™¤æ•°æƒ…å†µ
  assert_eq(1000000, divide_with_ceil(999999, 1))
  assert_eq(-999999, divide_with_ceil(-999999, 1))
}

test "data_structure_operations_simulation" {
  // æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let push_operations = 5
  let pop_operations = 3
  
  let final_stack_size = add(stack_size, add(push_operations, -pop_operations))
  assert_eq(2, final_stack_size)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 20
  let queue_items = 15
  let remaining_capacity = add(queue_capacity, -queue_items)
  let can_add_more = remaining_capacity > 0
  
  assert_eq(5, remaining_capacity)
  assert_true(can_add_more)
  
  // è®¡ç®—åˆ©ç”¨ç‡
  let utilization_rate = divide_with_ceil(multiply(queue_items, 100), queue_capacity)
  assert_eq(75, utilization_rate)
}

test "advanced_mathematical_properties" {
  // é«˜çº§æ•°å­¦æ€§è´¨æµ‹è¯•
  let x = 24
  let y = 18
  let z = 6
  
  // æµ‹è¯•æœ€å¤§å…¬çº¦æ•°æ€§è´¨ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let gcd_xy = 6  // gcd(24, 18) = 6
  assert_eq(6, gcd_xy)
  
  // æµ‹è¯•æœ€å°å…¬å€æ•°æ€§è´¨ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let lcm_xy = multiply(x, y) / gcd_xy  // lcm(24, 18) = 72
  assert_eq(72, lcm_xy)
  
  // æµ‹è¯•åˆ†é…å¾‹çš„å¤æ‚å½¢å¼
  let distributive_complex = add(
    multiply(x, add(y, z)),
    multiply(y, add(x, z))
  )
  let expected = add(
    add(multiply(x, y), multiply(x, z)),
    add(multiply(y, x), multiply(y, z))
  )
  assert_eq(distributive_complex, expected)
}

test "real_world_logistics_calculation" {
  // çœŸå®ä¸–ç•Œç‰©æµè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šä»“åº“è´§ç‰©è£…è½½ä¼˜åŒ–
  let shipments = [
    (120, 25),  // (è´§ç‰©æ•°é‡, æ¯ç®±å®¹é‡)
    (85, 20),
    (200, 30),
    (45, 15)
  ]
  
  // è®¡ç®—æ¯ç§è´§ç‰©éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_1 = divide_with_ceil(shipments[0].0, shipments[0].1)  // ceil(120/25) = 5
  let boxes_2 = divide_with_ceil(shipments[1].0, shipments[1].1)  // ceil(85/20) = 5
  let boxes_3 = divide_with_ceil(shipments[2].0, shipments[2].1)  // ceil(200/30) = 7
  let boxes_4 = divide_with_ceil(shipments[3].0, shipments[3].1)  // ceil(45/15) = 3
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(20, total_boxes)
  
  let total_items = add(add(shipments[0].0, shipments[1].0), add(shipments[2].0, shipments[3].0))
  assert_eq(450, total_items)
  
  // è®¡ç®—ç©ºé—´åˆ©ç”¨ç‡
  let total_capacity = add(
    add(multiply(boxes_1, shipments[0].1), multiply(boxes_2, shipments[1].1)),
    add(multiply(boxes_3, shipments[2].1), multiply(boxes_4, shipments[3].1))
  )
  assert_eq(470, total_capacity)
  
  let utilization_rate = divide_with_ceil(multiply(total_items, 100), total_capacity)
  assert_eq(96, utilization_rate)  // ceil(45000/470) = 96%
}