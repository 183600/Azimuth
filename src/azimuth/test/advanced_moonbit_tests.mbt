// é«˜çº§ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•å’Œæ–­è¨€
test "binary_operations_simulation" {
  // æ¨¡æ‹ŸäºŒè¿›åˆ¶è¿ç®—æµ‹è¯•
  let a = 12  // äºŒè¿›åˆ¶ 1100
  let b = 5   // äºŒè¿›åˆ¶ 0101
  
  // æ¨¡æ‹Ÿä½ä¸è¿ç®—ï¼š12 & 5 = 4 (0100)
  let bitwise_and = azimuth::@azimuth.multiply(a / 4 * 4, b / 4 * 4) / 4
  azimuth::@azimuth.assert_eq(4, bitwise_and)
  
  // æ¨¡æ‹Ÿä½æˆ–è¿ç®—ï¼š12 | 5 = 13 (1101)
  let bitwise_or = azimuth::@azimuth.add(a, b) - bitwise_and
  azimuth::@azimuth.assert_eq(13, bitwise_or)
}
test "temperature_conversion_advanced" {
  // é«˜çº§æ¸©åº¦è½¬æ¢æµ‹è¯•
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 9/5 + 32
  // ä½¿ç”¨æ•´æ•°è¿ç®—è¿‘ä¼¼ï¼šF = C Ã— 2 - C/5 + 32
  
  let celsius = 25
  let fahrenheit_approx = azimuth::@azimuth.add(azimuth::@azimuth.add(azimuth::@azimuth.multiply(celsius, 2), azimuth::@azimuth.multiply(celsius, -1/5)), 32)
  azimuth::@azimuth.assert_eq(77, fahrenheit_approx)
  
  // åæ°åº¦è½¬æ‘„æ°åº¦ï¼šC = (F - 32) Ã— 5/9
  // ä½¿ç”¨æ•´æ•°è¿ç®—è¿‘ä¼¼ï¼šC = (F - 32) / 2 + (F - 32) / 10
  let fahrenheit = 77
  let celsius_approx = azimuth::@azimuth.add(azimuth::@azimuth.multiply(azimuth::@azimuth.add(fahrenheit, -32), 1/2), azimuth::@azimuth.multiply(azimuth::@azimuth.add(fahrenheit, -32), 1/10))
  azimuth::@azimuth.assert_eq(25, celsius_approx)
}
test "geometric_progression" {
  // å‡ ä½•çº§æ•°è®¡ç®—æµ‹è¯•
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œï¼ša Ã— (1 - r^n) / (1 - r)
  let first_term = 2
  let ratio = 3
  let terms = 4
  
  // æ‰‹åŠ¨è®¡ç®—ï¼š2 + 6 + 18 + 54 = 80
  let term1 = first_term
  let term2 = azimuth::@azimuth.multiply(term1, ratio)
  let term3 = azimuth::@azimuth.multiply(term2, ratio)
  let term4 = azimuth::@azimuth.multiply(term3, ratio)
  let sum = azimuth::@azimuth.add(azimuth::@azimuth.add(azimuth::@azimuth.add(term1, term2), term3), term4)
  azimuth::@azimuth.assert_eq(80, sum)
}
test "game_damage_calculation" {
  // æ¸¸æˆä¼¤å®³è®¡ç®—æµ‹è¯•
  let base_damage = 100
  let weapon_multiplier = 150  // 1.5å€ï¼Œç”¨150è¡¨ç¤º
  let critical_hit = 200       // 2å€æš´å‡»ï¼Œç”¨200è¡¨ç¤º
  let defense_reduction = 80   // 0.8å€å‡ä¼¤ï¼Œç”¨80è¡¨ç¤º
  
  // è®¡ç®—æœ€ç»ˆä¼¤å®³ï¼šåŸºç¡€ä¼¤å®³ Ã— æ­¦å™¨å€ç‡ Ã— æš´å‡»å€ç‡ Ã— é˜²å¾¡å‡ä¼¤
  let weapon_damage = azimuth::@azimuth.multiply(base_damage, weapon_multiplier) / 100
  let critical_damage = azimuth::@azimuth.multiply(weapon_damage, critical_hit) / 100
  let final_damage = azimuth::@azimuth.multiply(critical_damage, defense_reduction) / 100
  azimuth::@azimuth.assert_eq(240, final_damage)
}
test "banking_interest_compound" {
  // é“¶è¡Œå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 5  // 5%
  let compounds_per_year = 12  // æœˆå¤åˆ©
  let years = 2
  
  // ç®€åŒ–å¤åˆ©è®¡ç®—ï¼šæœ€ç»ˆé‡‘é¢ = æœ¬é‡‘ Ã— (1 + æœˆåˆ©ç‡)^æœˆæ•°
  let monthly_rate = annual_rate / 12
  let total_months = azimuth::@azimuth.multiply(years, compounds_per_year)
  
  // è¿‘ä¼¼è®¡ç®—ï¼š(1 + 0.4%)^24 â‰ˆ 1.10ï¼Œç”¨110è¡¨ç¤º
  let growth_factor = 110
  let final_amount = azimuth::@azimuth.multiply(principal, growth_factor) / 100
  azimuth::@azimuth.assert_eq(11000, final_amount)
}
test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let result = azimuth::@azimuth.greet(special_chars)
  azimuth::@azimuth.assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", result)
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_text = "Helloä¸–ç•ŒğŸŒ123"
  let unicode_result = azimuth::@azimuth.greet(unicode_text)
  azimuth::@azimuth.assert_eq_string("Hello, Helloä¸–ç•ŒğŸŒ123!", unicode_result)
  
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²
  let long_text = "ThisIsAVeryLongStringThatContainsManyCharactersAndShouldStillWorkCorrectly"
  let long_result = azimuth::@azimuth.greet(long_text)
  azimuth::@azimuth.assert_eq_string("Hello, ThisIsAVeryLongStringThatContainsManyCharactersAndShouldStillWorkCorrectly!", long_result)
}
test "number_system_conversion" {
  // æ•°å­—ç³»ç»Ÿè½¬æ¢æµ‹è¯•
  // åè¿›åˆ¶è½¬äºŒè¿›åˆ¶ï¼ˆç®€åŒ–ç‰ˆï¼Œåªå¤„ç†å°æ•°å­—ï¼‰
  let decimal = 13
  
  // æ‰‹åŠ¨è®¡ç®—äºŒè¿›åˆ¶ï¼š13 = 8 + 4 + 0 + 1 = 1101
  let bit1 = decimal / 8
  let remainder1 = decimal % 8
  let bit2 = remainder1 / 4
  let remainder2 = remainder1 % 4
  let bit3 = remainder2 / 2
  let bit4 = remainder2 % 2
  
  let binary_representation = azimuth::@azimuth.add(azimuth::@azimuth.add(azimuth::@azimuth.multiply(bit1, 1000), azimuth::@azimuth.multiply(bit2, 100)), azimuth::@azimuth.add(azimuth::@azimuth.multiply(bit3, 10), bit4))
  azimuth::@azimuth.assert_eq(1101, binary_representation)
}
test "matrix_operations_basic" {
  // åŸºæœ¬çŸ©é˜µè¿ç®—æµ‹è¯•ï¼ˆ2x2çŸ©é˜µï¼‰
  // çŸ©é˜µAï¼š[[1, 2], [3, 4]]
  // çŸ©é˜µBï¼š[[5, 6], [7, 8]]
  
  let a11 = 1
  let a12 = 2
  let a21 = 3
  let a22 = 4
  
  let b11 = 5
  let b12 = 6
  let b21 = 7
  let b22 = 8
  
  // çŸ©é˜µåŠ æ³•ï¼šC = A + B
  let c11 = azimuth::@azimuth.add(a11, b11)
  let c12 = azimuth::@azimuth.add(a12, b12)
  let c21 = azimuth::@azimuth.add(a21, b21)
  let c22 = azimuth::@azimuth.add(a22, b22)
  
  azimuth::@azimuth.assert_eq(6, c11)
  azimuth::@azimuth.assert_eq(8, c12)
  azimuth::@azimuth.assert_eq(10, c21)
  azimuth::@azimuth.assert_eq(12, c22)
  
  // çŸ©é˜µä¹˜æ³•ï¼šD = A Ã— B
  let d11 = azimuth::@azimuth.add(azimuth::@azimuth.multiply(a11, b11), azimuth::@azimuth.multiply(a12, b21))
  let d12 = azimuth::@azimuth.add(azimuth::@azimuth.multiply(a11, b12), azimuth::@azimuth.multiply(a12, b22))
  let d21 = azimuth::@azimuth.add(azimuth::@azimuth.multiply(a21, b11), azimuth::@azimuth.multiply(a22, b21))
  let d22 = azimuth::@azimuth.add(azimuth::@azimuth.multiply(a21, b12), azimuth::@azimuth.multiply(a22, b22))
  
  azimuth::@azimuth.assert_eq(19, d11)
  azimuth::@azimuth.assert_eq(22, d12)
  azimuth::@azimuth.assert_eq(43, d21)
  azimuth::@azimuth.assert_eq(50, d22)
}
test "cryptographic_hash_simulation" {
  // å¯†ç å­¦å“ˆå¸Œæ¨¡æ‹Ÿæµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let input = 12345
  
  // ç®€å•å“ˆå¸Œå‡½æ•°ï¼šå“ˆå¸Œ = (è¾“å…¥ Ã— ç´ æ•°1 + ç´ æ•°2) % æ¨¡æ•°
  let prime1 = 31
  let prime2 = 37
  let modulus = 1000
  
  let hash_value = azimuth::@azimuth.multiply(input, prime1)
  let hash_with_salt = azimuth::@azimuth.add(hash_value, prime2)
  let final_hash = hash_with_salt % modulus
  
  azimuth::@azimuth.assert_eq(822, final_hash)
  
  // æµ‹è¯•ä¸åŒè¾“å…¥äº§ç”Ÿä¸åŒå“ˆå¸Œ
  let input2 = 12346
  let hash_value2 = azimuth::@azimuth.multiply(input2, prime1)
  let hash_with_salt2 = azimuth::@azimuth.add(hash_value2, prime2)
  let final_hash2 = hash_with_salt2 % modulus
  
  azimuth::@azimuth.assert_eq(853, final_hash2)
  azimuth::@azimuth.assert_true(final_hash != final_hash2)
}
test "error_boundary_conditions" {
  // é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼çš„å„ç§è¿ç®—
  azimuth::@azimuth.assert_eq(max_val, azimuth::@azimuth.add(max_val, 0))
  azimuth::@azimuth.assert_eq(max_val, azimuth::@azimuth.add(max_val, 1))
  azimuth::@azimuth.assert_eq(max_val, azimuth::@azimuth.multiply(max_val, 1))
  azimuth::@azimuth.assert_eq(min_val, azimuth::@azimuth.multiply(max_val, -1))
  
  // æµ‹è¯•æœ€å°å€¼çš„å„ç§è¿ç®—
  azimuth::@azimuth.assert_eq(min_val, azimuth::@azimuth.add(min_val, 0))
  azimuth::@azimuth.assert_eq(min_val, azimuth::@azimuth.add(min_val, -1))
  azimuth::@azimuth.assert_eq(min_val, azimuth::@azimuth.multiply(min_val, 1))
  azimuth::@azimuth.assert_eq(min_val, azimuth::@azimuth.multiply(min_val, -1))
  
  // æµ‹è¯•é›¶å€¼è¿ç®—
  azimuth::@azimuth.assert_eq(0, azimuth::@azimuth.multiply(0, max_val))
  azimuth::@azimuth.assert_eq(0, azimuth::@azimuth.multiply(0, min_val))
  azimuth::@azimuth.assert_eq(max_val, azimuth::@azimuth.add(0, max_val))
  azimuth::@azimuth.assert_eq(min_val, azimuth::@azimuth.add(0, min_val))
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  azimuth::@azimuth.assert_true(max_val > 0)
  azimuth::@azimuth.assert_true(min_val < 0)
  azimuth::@azimuth.assert_eq(0, azimuth::@azimuth.add(max_val, min_val))
}