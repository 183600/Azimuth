// æ–°å¢çš„ 10 ä¸ª MoonBit æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•ï¼Œæµ‹è¯• azimuth åŒ…çš„æ ¸å¿ƒåŠŸèƒ½

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­è¿ç®—
  let a = 10
  let b = 20
  let c = 30
  
  // (a + b) + c
  let sum1 = azimuth::add(azimuth::add(a, b), c)
  // a + (b + c)
  let sum2 = azimuth::add(a, azimuth::add(b, c))
  
  // éªŒè¯åŠ æ³•ç»“åˆå¾‹
  assert_eq(sum1, sum2)
  assert_eq(60, sum1)
  
  // (a * b) * c
  let product1 = azimuth::multiply(azimuth::multiply(a, b), c)
  // a * (b * c)
  let product2 = azimuth::multiply(a, azimuth::multiply(b, c))
  
  // éªŒè¯ä¹˜æ³•ç»“åˆå¾‹
  assert_eq(product1, product2)
  assert_eq(6000, product1)
}

test "mixed_operations" {
  // æµ‹è¯•æ··åˆè¿ç®—
  let x = 15
  let y = 4
  let z = 6
  
  // (x + y) * z
  let result1 = azimuth::multiply(azimuth::add(x, y), z)
  // x * z + y * z
  let result2 = azimuth::add(azimuth::multiply(x, z), azimuth::multiply(y, z))
  
  // éªŒè¯åˆ†é…å¾‹
  assert_eq(result1, result2)
  assert_eq(114, result1)
}

test "boundary_value_operations" {
  // æµ‹è¯•è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼è¿ç®—
  assert_eq(max_val, azimuth::add(max_val, 0))
  assert_eq(max_val, azimuth::add(max_val, 1))
  assert_eq(max_val, azimuth::multiply(max_val, 1))
  assert_eq(min_val, azimuth::multiply(max_val, -1))
  
  // æœ€å°å€¼è¿ç®—
  assert_eq(min_val, azimuth::add(min_val, 0))
  assert_eq(min_val, azimuth::add(min_val, -1))
  assert_eq(min_val, azimuth::multiply(min_val, 1))
  assert_eq(min_val, azimuth::multiply(min_val, -1))
  
  // æå€¼ç»„åˆ
  assert_eq(-1, azimuth::add(max_val, min_val))
  assert_eq(0, azimuth::multiply(max_val, 0))
  assert_eq(0, azimuth::multiply(min_val, 0))
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºå­—ç¬¦ä¸²
  assert_eq_string("Hello, !", azimuth::greet(""))
  
  // å•å­—ç¬¦
  assert_eq_string("Hello, A!", azimuth::greet("A"))
  
  // é•¿å­—ç¬¦ä¸²
  let long_name = "ThisIsAVeryLongNameForTestingPurposes"
  assert_eq_string("Hello, ThisIsAVeryLongNameForTestingPurposes!", azimuth::greet(long_name))
  
  // åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, John Doe!", azimuth::greet("John Doe"))
  
  // ç‰¹æ®Šå­—ç¬¦å’Œç¬¦å·
  assert_eq_string("Hello, test@example.com!", azimuth::greet("test@example.com"))
  assert_eq_string("Hello, User_123!", azimuth::greet("User_123"))
  
  // Unicodeå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", azimuth::greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒ!", azimuth::greet("ğŸŒ"))
}

test "mathematical_formulas" {
  // æµ‹è¯•æ•°å­¦å…¬å¼è®¡ç®—
  
  // å¹³æ–¹å·®å…¬å¼: (a + b) * (a - b) = aÂ² - bÂ²
  let a = 10
  let b = 3
  
  let sum = azimuth::add(a, b)
  let diff = azimuth::add(a, -b)
  let left_side = azimuth::multiply(sum, diff)
  
  let a_squared = azimuth::multiply(a, a)
  let b_squared = azimuth::multiply(b, b)
  let right_side = azimuth::add(a_squared, -b_squared)
  
  assert_eq(left_side, right_side)
  assert_eq(91, left_side)
  
  // ç«‹æ–¹å’Œå…¬å¼: aÂ³ + bÂ³ = (a + b) * (aÂ² - a*b + bÂ²)
  let a_cubed = azimuth::multiply(a_squared, a)
  let b_cubed = azimuth::multiply(b_squared, b)
  let sum_of_cubes = azimuth::add(a_cubed, b_cubed)
  
  let a_times_b = azimuth::multiply(a, b)
  let second_factor = azimuth::add(azimuth::add(a_squared, -a_times_b), b_squared)
  let formula_result = azimuth::multiply(sum, second_factor)
  
  assert_eq(sum_of_cubes, formula_result)
}

test "real_world_scenarios" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  
  // åœºæ™¯1: è®¡ç®—æŠ˜æ‰£ä»·æ ¼
  let original_price = 1000
  let discount_rate = 20  // 20%æŠ˜æ‰£
  let tax_rate = 8        // 8%ç¨ç‡
  
  let discount_amount = azimuth::multiply(original_price, discount_rate) / 100
  let discounted_price = azimuth::add(original_price, -discount_amount)
  let tax_amount = azimuth::multiply(discounted_price, tax_rate) / 100
  let final_price = azimuth::add(discounted_price, tax_amount)
  
  assert_eq(864, final_price)  // 1000 - 200 + 64 = 864
  
  // åœºæ™¯2: è®¡ç®—å¹³å‡åˆ†
  let math_score = 85
  let english_score = 78
  let science_score = 92
  let history_score = 88
  
  let total_score = azimuth::add(azimuth::add(azimuth::add(math_score, english_score), science_score), history_score)
  let average_score = total_score / 4
  
  assert_eq(85, average_score)
  
  // åœºæ™¯3: è®¡ç®—çŸ©å½¢å‘¨é•¿å’Œé¢ç§¯
  let length = 12
  let width = 8
  
  let perimeter = azimuth::add(azimuth::multiply(2, length), azimuth::multiply(2, width))
  let area = azimuth::multiply(length, width)
  
  assert_eq(40, perimeter)
  assert_eq(96, area)
}

test "error_handling_and_validation" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’ŒéªŒè¯
  
  // éªŒè¯æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  let min_val = -2147483648
  
  // åŠ æ³•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, azimuth::add(max_val, 1))
  assert_eq(max_val, azimuth::add(max_val, max_val))
  assert_eq(min_val, azimuth::add(min_val, -1))
  assert_eq(min_val, azimuth::add(min_val, min_val))
  
  // ä¹˜æ³•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, azimuth::multiply(max_val, 2))
  assert_eq(min_val, azimuth::multiply(min_val, 2))
  assert_eq(min_val, azimuth::multiply(min_val, -1))
  
  // ç‰¹æ®Šå€¼å¤„ç†
  assert_eq(0, azimuth::multiply(0, max_val))
  assert_eq(0, azimuth::multiply(0, min_val))
  assert_eq(max_val, azimuth::multiply(max_val, 1))
  assert_eq(min_val, azimuth::multiply(min_val, 1))
}

test "performance_related_operations" {
  // æµ‹è¯•æ€§èƒ½ç›¸å…³çš„è¿ç®—
  
  // å¤§æ•°è¿ç®—
  let large_num1 = 1000000
  let large_num2 = 2000000
  
  assert_eq(3000000, azimuth::add(large_num1, large_num2))
  assert_eq(2000000000000, azimuth::multiply(large_num1, large_num2))
  
  // è¿ç»­è¿ç®—
  let base = 100
  let result = azimuth::multiply(azimuth::add(azimuth::multiply(base, 2), 50), 3)
  assert_eq(750, result)  // (100*2 + 50)*3 = 250*3 = 750
  
  // åµŒå¥—è¿ç®—
  let nested_result = azimuth::add(
    azimuth::multiply(10, 20),
    azimuth::multiply(azimuth::add(5, 3), 15)
  )
  assert_eq(320, nested_result)  // 200 + (8*15) = 200 + 120 = 320
}

test "conditional_logic_scenarios" {
  // æµ‹è¯•æ¡ä»¶é€»è¾‘åœºæ™¯
  
  // åŸºäºæ¯”è¾ƒç»“æœçš„æ¡ä»¶è¿ç®—
  let x = 25
  let y = 30
  let z = 15
  
  // å¦‚æœ x < yï¼Œåˆ™è®¡ç®— x + zï¼Œå¦åˆ™è®¡ç®— x * z
  let condition1 = x < y
  let result1 = if condition1 { azimuth::add(x, z) } else { azimuth::multiply(x, z) }
  assert_eq(40, result1)  // 25 < 30 ä¸ºçœŸï¼Œæ‰€ä»¥ 25 + 15 = 40
  
  // å¦‚æœ y > zï¼Œåˆ™è®¡ç®— y * zï¼Œå¦åˆ™è®¡ç®— y + z
  let condition2 = y > z
  let result2 = if condition2 { azimuth::multiply(y, z) } else { azimuth::add(y, z) }
  assert_eq(450, result2)  // 30 > 15 ä¸ºçœŸï¼Œæ‰€ä»¥ 30 * 15 = 450
  
  // å¤æ‚æ¡ä»¶
  let complex_condition = azimuth::add(x, y) > azimuth::multiply(z, 3)
  let complex_result = if complex_condition { azimuth::multiply(x, y) } else { azimuth::add(x, y) }
  assert_eq(750, complex_result)  // 25 + 30 > 15*3 (55 > 45) ä¸ºçœŸï¼Œæ‰€ä»¥ 25 * 30 = 750
}

test "data_conversion_and_formatting" {
  // æµ‹è¯•æ•°æ®è½¬æ¢å’Œæ ¼å¼åŒ–
  
  // æ•°å­—å­—ç¬¦ä¸²å¤„ç†
  let number_str = "2023"
  let year_greeting = azimuth::greet(number_str)
  assert_eq_string("Hello, 2023!", year_greeting)
  
  // å¸ƒå°”å€¼å­—ç¬¦ä¸²å¤„ç†
  let true_str = "true"
  let false_str = "false"
  
  assert_eq_string("Hello, true!", azimuth::greet(true_str))
  assert_eq_string("Hello, false!", azimuth::greet(false_str))
  
  // ç‰¹æ®Šæ ¼å¼å­—ç¬¦ä¸²
  let date_str = "2023-12-25"
  let time_str = "14:30:00"
  let phone_str = "+86-138-0013-8000"
  
  assert_eq_string("Hello, 2023-12-25!", azimuth::greet(date_str))
  assert_eq_string("Hello, 14:30:00!", azimuth::greet(time_str))
  assert_eq_string("Hello, +86-138-0013-8000!", azimuth::greet(phone_str))
  
  // æ··åˆå†…å®¹å­—ç¬¦ä¸²
  let mixed_str = "User123_Admin"
  assert_eq_string("Hello, User123_Admin!", azimuth::greet(mixed_str))
}

test "algorithm_implementation" {
  // æµ‹è¯•ç®€å•ç®—æ³•å®ç°
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œ: n * (a1 + an) / 2
  let n = 10
  let first_term = 1
  let last_term = 19
  
  let arithmetic_sum = azimuth::multiply(n, azimuth::add(first_term, last_term)) / 2
  assert_eq(100, arithmetic_sum)  // 10 * (1 + 19) / 2 = 100
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„å’Œ: a1 * (1 - r^n) / (1 - r)
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—: 1 + 2 + 4 + 8 + 16 = 31
  let geo_sum = azimuth::add(azimuth::add(azimuth::add(azimuth::add(1, 2), 4), 8), 16)
  assert_eq(31, geo_sum)
  
  // è®¡ç®—å¹³æ–¹å’Œ: 1Â² + 2Â² + 3Â² + 4Â² + 5Â² = 55
  let square_sum = azimuth::add(
    azimuth::add(
      azimuth::add(
        azimuth::add(azimuth::multiply(1, 1), azimuth::multiply(2, 2)),
        azimuth::multiply(3, 3)
      ),
      azimuth::multiply(4, 4)
    ),
    azimuth::multiply(5, 5)
  )
  assert_eq(55, square_sum)
  
  // è®¡ç®—é˜¶ä¹˜: 5! = 5 * 4 * 3 * 2 * 1 = 120
  let factorial = azimuth::multiply(
    azimuth::multiply(
      azimuth::multiply(
        azimuth::multiply(5, 4),
        3
      ),
      2
    ),
    1
  )
  assert_eq(120, factorial)
}