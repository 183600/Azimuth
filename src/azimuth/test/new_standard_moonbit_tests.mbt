// æ–°å¢žçš„ MoonBit æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

// æµ‹è¯•å¤§æ•°è¿ç®—
test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°ç›¸åŠ 
  let large_sum = @azimuth.add(1000000, 2000000)
  @azimuth.assert_eq(3000000, large_sum)
  
  // æµ‹è¯•å¤§æ•°ç›¸ä¹˜
  let large_product = @azimuth.multiply(10000, 10000)
  @azimuth.assert_eq(100000000, large_product)
  
  // æµ‹è¯•å¤§è´Ÿæ•°è¿ç®—
  let large_neg_sum = @azimuth.add(-1000000, -2000000)
  @azimuth.assert_eq(-3000000, large_neg_sum)
}

// æµ‹è¯•è¿žç»­è¿ç®—
test "sequential_operations" {
  // æµ‹è¯•è¿žç»­åŠ æ³•ï¼š(a + b) + c
  let a = 10
  let b = 20
  let c = 30
  
  let step1 = @azimuth.add(a, b)  // 30
  let result = @azimuth.add(step1, c)  // 60
  @azimuth.assert_eq(60, result)
  
  // æµ‹è¯•è¿žç»­ä¹˜æ³•ï¼š(a * b) * c
  let x = 2
  let y = 3
  let z = 4
  
  let step2 = @azimuth.multiply(x, y)  // 6
  let result2 = @azimuth.multiply(step2, z)  // 24
  @azimuth.assert_eq(24, result2)
}

// æµ‹è¯•æ··åˆè¿ç®—
test "mixed_operations" {
  // æµ‹è¯• (a * b) + (c * d)
  let a = 5
  let b = 6
  let c = 7
  let d = 8
  
  let product1 = @azimuth.multiply(a, b)  // 30
  let product2 = @azimuth.multiply(c, d)  // 56
  let result = @azimuth.add(product1, product2)  // 86
  @azimuth.assert_eq(86, result)
  
  // æµ‹è¯• (a + b) * (c + d)
  let sum1 = @azimuth.add(a, b)  // 11
  let sum2 = @azimuth.add(c, d)  // 15
  let result2 = @azimuth.multiply(sum1, sum2)  // 165
  @azimuth.assert_eq(165, result2)
}

// æµ‹è¯•æžå€¼è¾¹ç•Œæƒ…å†µ
test "extreme_boundary_values" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸Žæœ€å°å€¼çš„è¿ç®—
  @azimuth.assert_eq(-1, @azimuth.add(max_val, min_val))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, -1))
  
  // æµ‹è¯•æŽ¥è¿‘è¾¹ç•Œçš„å€¼
  @azimuth.assert_eq(2147483646, @azimuth.add(max_val, -1))
  @azimuth.assert_eq(-2147483647, @azimuth.add(min_val, 1))
  
  // æµ‹è¯•è¾¹ç•Œå€¼ä¸Ž0çš„è¿ç®—
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 0))
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(max_val, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(min_val, 0))
}

// æµ‹è¯•å­—ç¬¦ä¸²ç‰¹æ®Šæƒ…å†µ
test "special_string_cases" {
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, John Doe!", @azimuth.greet("John Doe"))
  
  // æµ‹è¯•åŒ…å«æ•°å­—çš„å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, User123!", @azimuth.greet("User123"))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šç¬¦å·çš„å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, test@example.com!", @azimuth.greet("test@example.com"))
  
  // æµ‹è¯•åŒ…å«Unicodeè¡¨æƒ…çš„å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, ðŸŒŸ!", @azimuth.greet("ðŸŒŸ"))
  
  // æµ‹è¯•åŒ…å«å¼•å·çš„å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, \"John\"!", @azimuth.greet("\"John\""))
}

// æµ‹è¯•æ•°å­¦æ’ç­‰å¼
test "mathematical_identities" {
  let x = 15
  let y = 25
  let z = 10
  
  // æµ‹è¯•åŠ æ³•æ’ç­‰å¼ï¼ša + 0 = a
  @azimuth.assert_eq(x, @azimuth.add(x, 0))
  @azimuth.assert_eq(y, @azimuth.add(0, y))
  
  // æµ‹è¯•ä¹˜æ³•æ’ç­‰å¼ï¼ša * 1 = a
  @azimuth.assert_eq(x, @azimuth.multiply(x, 1))
  @azimuth.assert_eq(y, @azimuth.multiply(1, y))
  
  // æµ‹è¯•ä¹˜æ³•é›¶å¾‹ï¼ša * 0 = 0
  @azimuth.assert_eq(0, @azimuth.multiply(x, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(0, y))
  
  // æµ‹è¯•åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let left = @azimuth.multiply(x, @azimuth.add(y, z))
  let right = @azimuth.add(@azimuth.multiply(x, y), @azimuth.multiply(x, z))
  @azimuth.assert_eq(left, right)
}

// æµ‹è¯•å®žé™…åº”ç”¨åœºæ™¯
test "practical_application_scenarios" {
  // åœºæ™¯1ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1_price = 199
  let item1_quantity = 2
  let item2_price = 299
  let item2_quantity = 1
  
  let subtotal1 = @azimuth.multiply(item1_price, item1_quantity)  // 398
  let subtotal2 = @azimuth.multiply(item2_price, item2_quantity)  // 299
  let total = @azimuth.add(subtotal1, subtotal2)  // 697
  @azimuth.assert_eq(697, total)
  
  // åœºæ™¯2ï¼šè®¡ç®—çŸ©å½¢é¢ç§¯å’Œå‘¨é•¿
  let length = 12
  let width = 8
  
  let area = @azimuth.multiply(length, width)  // 96
  let perimeter = @azimuth.multiply(2, @azimuth.add(length, width))  // 40
  @azimuth.assert_eq(96, area)
  @azimuth.assert_eq(40, perimeter)
  
  // åœºæ™¯3ï¼šæ¸©åº¦è½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼šF = C * 2 + 30
  let celsius = 25
  let fahrenheit = @azimuth.add(@azimuth.multiply(celsius, 2), 30)
  @azimuth.assert_eq(80, fahrenheit)
}

// æµ‹è¯•é”™è¯¯å¤„ç†å’Œè¾¹ç•Œä¿æŠ¤
test "error_handling_and_protection" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•åŠ æ³•æº¢å‡ºä¿æŠ¤
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 100))
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, max_val))
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, -100))
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, min_val))
  
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºä¿æŠ¤
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, 2))
  @azimuth.assert_eq(max_val, @azimuth.multiply(46341, 46341))  // sqrt(max_val)çš„å¹³æ–¹
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 2))
  @azimuth.assert_eq(min_val, @azimuth.multiply(-46341, 46341))
  
  // æµ‹è¯•ç‰¹æ®Šå€¼å¤„ç†
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, -1))  // æœ€å°å€¼ä¹˜-1çš„ç‰¹æ®Šæƒ…å†µ
}

// æµ‹è¯•æ€§èƒ½ç›¸å…³çš„å¤§è§„æ¨¡è¿ç®—
test "performance_large_scale_operations" {
  // æµ‹è¯•å¤§é‡é‡å¤è¿ç®—çš„ç´¯åŠ 
  let base = 1000
  let count = 100
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šbase * count * (count + 1) / 2
  let sum_formula = @azimuth.multiply(base, @azimuth.multiply(count, @azimuth.add(count, 1)) / 2)
  @azimuth.assert_eq(5050000, sum_formula)
  
  // æµ‹è¯•æŒ‡æ•°å¢žé•¿è®¡ç®—
  let initial = 2
  let power_result = @azimuth.multiply(@azimuth.multiply(@azimuth.multiply(initial, 2), 2), 2)  // 2 * 2^3 = 16
  @azimuth.assert_eq(16, power_result)
  
  // æµ‹è¯•å¤§æ•°é˜¶ä¹˜çš„ç®€åŒ–è®¡ç®—
  let factorial_5 = @azimuth.multiply(5, @azimuth.multiply(4, @azimuth.multiply(3, @azimuth.multiply(2, 1))))
  @azimuth.assert_eq(120, factorial_5)
}

// æµ‹è¯•å¤æ‚ä¸šåŠ¡é€»è¾‘
test "complex_business_logic" {
  // åœºæ™¯1ï¼šé“¶è¡Œåˆ©æ¯è®¡ç®—
  let principal = 10000
  let rate_percent = 5
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼šæœ¬é‡‘ + æœ¬é‡‘ * åˆ©çŽ‡ * å¹´æ•°
  let interest = @azimuth.multiply(principal, @azimuth.multiply(rate_percent, years))
  let total = @azimuth.add(principal, interest)
  @azimuth.assert_eq(160000, total)  // 10000 + 10000*5*3 = 160000
  
  // åœºæ™¯2ï¼šæŠ˜æ‰£è®¡ç®—
  let original_price = 500
  let discount1 = 10  // ç¬¬ä¸€é˜¶æ®µæŠ˜æ‰£
  let discount2 = 5   // ç¬¬äºŒé˜¶æ®µæŠ˜æ‰£
  
  let price_after_first = @azimuth.add(original_price, -@azimuth.multiply(original_price, discount1) / 100)  // 450
  let final_price = @azimuth.add(price_after_first, -@azimuth.multiply(price_after_first, discount2) / 100)  // 427.5 -> 427 (æ•´æ•°é™¤æ³•)
  @azimuth.assert_eq(427, final_price)
  
  // åœºæ™¯3ï¼šåˆ†æ•°è®¡ç®—ï¼ˆç®€åŒ–ä¸ºæ•´æ•°ï¼‰
  let numerator = 22
  let denominator = 7
  let whole_part = numerator / denominator  // 3
  let remainder = numerator % denominator  // 1
  let decimal_approx = @azimuth.multiply(remainder, 10) / denominator  // 1
  
  @azimuth.assert_eq(3, whole_part)
  @azimuth.assert_eq(1, remainder)
  @azimuth.assert_eq(1, decimal_approx)
}