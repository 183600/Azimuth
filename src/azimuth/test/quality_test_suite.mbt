// é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•

test "numeric_overflow_boundary" {
  // æµ‹è¯•æ•°å€¼æº¢å‡ºè¾¹ç•Œæƒ…å†µ
  let max_safe = 2147483647 / 2
  let result = @azimuth.add(max_safe, max_safe)
  @azimuth.assert_eq(2147483646, result)
}

test "divide_with_ceil_decimal_precision" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å°æ•°ç²¾åº¦å¤„ç†
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(1, 2))  // 0.5 -> 1
  @azimuth.assert_eq(2, @azimuth.divide_with_ceil(3, 2))  // 1.5 -> 2
  @azimuth.assert_eq(4, @azimuth.divide_with_ceil(7, 2))  // 3.5 -> 4
  @azimuth.assert_eq(34, @azimuth.divide_with_ceil(100, 3))  // 33.33... -> 34
}

test "greet_function_unicode_validation" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode å­—ç¬¦å¤„ç†
  @azimuth.assert_eq_string("Hello, ğŸŒ™!", @azimuth.greet("ğŸŒ™"))
  @azimuth.assert_eq_string("Hello, ğŸš€!", @azimuth.greet("ğŸš€"))
  @azimuth.assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", @azimuth.greet("Î±Î²Î³Î´Îµ"))
  @azimuth.assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", @azimuth.greet("ä¸­æ–‡æµ‹è¯•"))
}

test "compound_financial_calculation" {
  // æµ‹è¯•å¤åˆé‡‘èè®¡ç®—åœºæ™¯
  let principal = 1000
  let rate1 = 5
  let rate2 = 3
  let rate3 = 4
  
  // è®¡ç®—ä¸‰å¹´å¤åˆ©
  let year1 = @azimuth.add(principal, @azimuth.divide_with_ceil(@azimuth.multiply(principal, rate1), 100))
  let year2 = @azimuth.add(year1, @azimuth.divide_with_ceil(@azimuth.multiply(year1, rate2), 100))
  let year3 = @azimuth.add(year2, @azimuth.divide_with_ceil(@azimuth.multiply(year2, rate3), 100))
  
  @azimuth.assert_eq(1050, year1)  // 1000 + 5% = 1050
  @azimuth.assert_eq(1082, year2)  // 1050 + 3% = 1081.5 -> 1082
  @azimuth.assert_eq(1126, year3)  // 1082 + 4% = 1125.28 -> 1126
}

test "inventory_optimization_problem" {
  // æµ‹è¯•åº“å­˜ä¼˜åŒ–é—®é¢˜
  let demand_forecast = 157
  let batch_size = 25
  let safety_stock = 20
  
  // è®¡ç®—è®¢è´§æ•°é‡ï¼ˆå‘ä¸Šå–æ•´åˆ°æœ€è¿‘çš„æ‰¹æ¬¡ï¼‰
  let base_orders = @azimuth.divide_with_ceil(demand_forecast, batch_size)
  let total_order_quantity = @azimuth.multiply(base_orders, batch_size)
  let final_inventory = @azimuth.add(total_order_quantity, safety_stock)
  
  @azimuth.assert_eq(7, base_orders)  // ceil(157/25) = 7
  @azimuth.assert_eq(175, total_order_quantity)  // 7 * 25 = 175
  @azimuth.assert_eq(195, final_inventory)  // 175 + 20 = 195
}

test "string_concatenation_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¿æ¥çš„è¾¹ç•Œæƒ…å†µ
  @azimuth.assert_eq_string("Hello, !", @azimuth.greet(""))
  @azimuth.assert_eq_string("Hello,   !", @azimuth.greet("  "))
  @azimuth.assert_eq_string("Hello, a!", @azimuth.greet("a"))
  @azimuth.assert_eq_string("Hello, ABC123!", @azimuth.greet("ABC123"))
  @azimuth.assert_eq_string("Hello, special@chars#123!", @azimuth.greet("special@chars#123"))
}

test "mathematical_sequence_calculation" {
  // æµ‹è¯•æ•°å­¦åºåˆ—è®¡ç®—
  // è®¡ç®—ç­‰å·®æ•°åˆ—ï¼š3, 7, 11, 15, 19 çš„å’Œ
  let term1 = 3
  let difference = 4
  let num_terms = 5
  
  let sum = @azimuth.multiply(num_terms, @azimuth.add(term1, @azimuth.multiply(num_terms - 1, difference))) / 2
  @azimuth.assert_eq(55, sum)  // 5 * (3 + 16) / 2 = 55
}

test "resource_allocation_algorithm" {
  // æµ‹è¯•èµ„æºåˆ†é…ç®—æ³•
  let total_resources = 100
  let project1_needs = 23
  let project2_needs = 31
  let project3_needs = 19
  
  let allocated1 = project1_needs
  let allocated2 = project2_needs
  let allocated3 = project3_needs
  let total_allocated = @azimuth.add(@azimuth.add(allocated1, allocated2), allocated3)
  let remaining = @azimuth.add(total_resources, -total_allocated)
  
  @azimuth.assert_eq(73, total_allocated)  // 23 + 31 + 19 = 73
  @azimuth.assert_eq(27, remaining)  // 100 - 73 = 27
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„æ–°é¡¹ç›®æ•°é‡ï¼ˆæ¯ä¸ªéœ€è¦10ä¸ªèµ„æºï¼‰
  let new_projects = @azimuth.divide_with_ceil(remaining, 10)
  @azimuth.assert_eq(3, new_projects)  // ceil(27/10) = 3
}

test "error_handling_robustness" {
  // æµ‹è¯•é”™è¯¯å¤„ç†çš„å¥å£®æ€§
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„å„ç§æƒ…å†µ
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(100, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(-100, 0))
  
  // æµ‹è¯•æå€¼è¿ç®—
  @azimuth.assert_eq(0, @azimuth.add(2147483647, -2147483647))
  @azimuth.assert_eq(1, @azimuth.add(2147483646, -2147483645))
}

test "performance_benchmark_simulation" {
  // æµ‹è¯•æ€§èƒ½åŸºå‡†æ¨¡æ‹Ÿ
  let base_operations = 1000
  let optimization_factor = 3
  let overhead_percent = 15
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ€§èƒ½
  let optimized_ops = @azimuth.multiply(base_operations, optimization_factor)
  let overhead = @azimuth.divide_with_ceil(@azimuth.multiply(optimized_ops, overhead_percent), 100)
  let actual_performance = @azimuth.add(optimized_ops, -overhead)
  
  @azimuth.assert_eq(3000, optimized_ops)
  @azimuth.assert_eq(450, overhead)  // ceil(3000 * 15 / 100) = 450
  @azimuth.assert_eq(2550, actual_performance)  // 3000 - 450 = 2550
}