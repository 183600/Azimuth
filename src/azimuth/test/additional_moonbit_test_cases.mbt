// é¢å¤–çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•æ ¸å¿ƒåŠŸèƒ½çš„å„ç§åœºæ™¯å’Œè¾¹ç•Œæƒ…å†µ

test "arithmetics_series_sum" {
  // æµ‹è¯•ç­‰å·®æ•°åˆ—æ±‚å’Œï¼š1 + 2 + 3 + ... + 10 = 55
  let n = 10
  let sum = multiply(n, add(n, 1)) / 2
  assert_eq(55, sum)
}

test "geometric_progression" {
  // æµ‹è¯•ç­‰æ¯”æ•°åˆ—ï¼š2 + 4 + 8 + 16 = 30
  let term1 = 2
  let term2 = multiply(term1, 2)
  let term3 = multiply(term2, 2)
  let term4 = multiply(term3, 2)
  let sum = add(add(add(term1, term2), term3), term4)
  assert_eq(30, sum)
}

test "string_concatenation_with_numbers" {
  // æµ‹è¯•åŒ…å«æ•°å­—çš„å­—ç¬¦ä¸²æ‹¼æ¥
  let year = "2024"
  let month = "01"
  let day = "15"
  let date_string = year + "-" + month + "-" + day
  let result = greet(date_string)
  assert_eq_string("Hello, 2024-01-15!", result)
}

test "complex_business_calculation" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—ï¼šè®¢å•æ€»ä»·è®¡ç®—
  let unit_price = 199
  let quantity = 5
  let discount_rate = 10  // 10%æŠ˜æ‰£
  let tax_rate = 8        // 8%ç¨ç‡
  let shipping = 25       // è¿è´¹
  
  // è®¡ç®—å°è®¡
  let subtotal = multiply(unit_price, quantity)
  // è®¡ç®—æŠ˜æ‰£
  let discount = multiply(subtotal, discount_rate) / 100
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_price = add(subtotal, -discount)
  // è®¡ç®—ç¨è´¹
  let tax = multiply(discounted_price, tax_rate) / 100
  // è®¡ç®—æ€»ä»·
  let total = add(add(discounted_price, tax), shipping)
  
  assert_eq(966, total)
}

test "temperature_conversion_formula" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢å…¬å¼ï¼šåæ°åº¦è½¬æ‘„æ°åº¦ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // C = (F - 32) Ã— 5/9ï¼Œç®€åŒ–ä¸º C = (F - 30) / 2
  let fahrenheit = 86
  let celsius = add(fahrenheit, -30) / 2
  assert_eq(28, celsius)
  
  // åå‘éªŒè¯ï¼šæ‘„æ°åº¦è½¬åæ°åº¦
  let back_to_fahrenheit = add(multiply(celsius, 2), 30)
  assert_eq(86, back_to_fahrenheit)
}

test "mathematical_identity_verification" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼éªŒè¯
  let x = 7
  let y = 13
  
  // éªŒè¯å¹³æ–¹å’Œå…¬å¼ï¼š(x + y)Â² = xÂ² + 2xy + yÂ²
  let left_side = multiply(add(x, y), add(x, y))
  let right_side = add(add(multiply(x, x), multiply(2, multiply(x, y))), multiply(y, y))
  assert_eq(left_side, right_side)
  
  // éªŒè¯å¹³æ–¹å·®å…¬å¼ï¼š(x + y)(x - y) = xÂ² - yÂ²
  let diff_left = multiply(add(x, y), add(x, -y))
  let diff_right = add(multiply(x, x), multiply(-y, y))
  assert_eq(diff_left, diff_right)
}

test "edge_case_string_processing" {
  // æµ‹è¯•è¾¹ç¼˜æƒ…å†µçš„å­—ç¬¦ä¸²å¤„ç†
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let result = greet(special_chars)
  assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", result)
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_string = "æµ‹è¯•ğŸŒŸMoonBit"
  let unicode_result = greet(unicode_string)
  assert_eq_string("Hello, æµ‹è¯•ğŸŒŸMoonBit!", unicode_result)
}

test "performance_calculation_simulation" {
  // æµ‹è¯•æ€§èƒ½è®¡ç®—æ¨¡æ‹Ÿ
  let base_score = 1000
  let performance_factor = 15  // æ€§èƒ½ç³»æ•°
  let bonus_multiplier = 3     // å¥–åŠ±å€æ•°
  
  // è®¡ç®—åŸºç¡€å¾—åˆ†
  let base_total = multiply(base_score, performance_factor)
  // è®¡ç®—å¥–åŠ±å¾—åˆ†
  let bonus_total = multiply(base_total, bonus_multiplier)
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let final_score = add(base_total, bonus_total)
  
  assert_eq(60000, final_score)
}

test "divide_with_ceil_functionality" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°
  // æ­£å¸¸æƒ…å†µ
  assert_eq(3, divide_with_ceil(10, 4))
  assert_eq(3, divide_with_ceil(12, 4))
  assert_eq(4, divide_with_ceil(13, 4))
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(-2, divide_with_ceil(-7, 4))
}