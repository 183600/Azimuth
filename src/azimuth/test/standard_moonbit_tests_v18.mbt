// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ v18
// ä¸º azimuth åº“æ·»åŠ çš„10ä¸ªæ–°æµ‹è¯•ç”¨ä¾‹

test "integer_division_simulation" {
  // æ¨¡æ‹Ÿæ•´æ•°é™¤æ³•è¿ç®—ï¼Œé€šè¿‡ä¹˜æ³•å’Œå‡æ³•å®ç°
  let dividend = 27
  let divisor = 5
  
  // è®¡ç®—å•†å’Œä½™æ•°
  let quotient = dividend / divisor
  let remainder = dividend % divisor
  
  // éªŒè¯ç»“æœï¼š27 = 5 * 5 + 2
  assert_eq(5, quotient)
  assert_eq(2, remainder)
  
  // éªŒè¯é™¤æ³•æ’ç­‰å¼ï¼šdividend = divisor * quotient + remainder
  let reconstructed = add(multiply(divisor, quotient), remainder)
  assert_eq(dividend, reconstructed)
}

test "percentage_calculation_practical" {
  // å®é™…ç™¾åˆ†æ¯”è®¡ç®—åœºæ™¯
  let original_price = 200
  let discount_percent = 15
  let tax_percent = 8
  
  // è®¡ç®—æŠ˜æ‰£é‡‘é¢
  let discount_amount = multiply(original_price, discount_percent) / 100
  let discounted_price = add(original_price, -discount_amount)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = multiply(discounted_price, tax_percent) / 100
  let final_price = add(discounted_price, tax_amount)
  
  // éªŒè¯ç»“æœï¼š200 - 15% + 8% = 200 - 30 + 13.6 â‰ˆ 183.6ï¼Œå–æ•´ä¸º183
  assert_eq(183, final_price)
}

test "temperature_conversion_formula" {
  // æ¸©åº¦è½¬æ¢å…¬å¼æµ‹è¯•ï¼ˆç²¾ç¡®ç‰ˆï¼‰
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 9/5 + 32
  // ä½¿ç”¨æ•´æ•°è¿ç®—ï¼šF = C Ã— 9 + 160) / 5
  
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 9), 160) / 5
  assert_eq(77, fahrenheit)  // (25 Ã— 9 + 160) / 5 = 385 / 5 = 77
  
  // æµ‹è¯•å†°ç‚¹
  let freezing_celsius = 0
  let freezing_fahrenheit = add(multiply(freezing_celsius, 9), 160) / 5
  assert_eq(32, freezing_fahrenheit)  // (0 Ã— 9 + 160) / 5 = 160 / 5 = 32
  
  // æµ‹è¯•æ²¸ç‚¹
  let boiling_celsius = 100
  let boiling_fahrenheit = add(multiply(boiling_celsius, 9), 160) / 5
  assert_eq(212, boiling_fahrenheit)  // (100 Ã— 9 + 160) / 5 = 1060 / 5 = 212
}

test "compound_interest_precise_calculation" {
  // ç²¾ç¡®å¤åˆ©è®¡ç®—ï¼ˆæ•´æ•°ç‰ˆæœ¬ï¼‰
  // å…¬å¼ï¼šA = P Ã— (1 + r/n)^(nÃ—t)
  // ç®€åŒ–ä¸ºæ•´æ•°ï¼šA = P Ã— (100 + r)^t / 100^t
  
  let principal = 10000  // æœ¬é‡‘
  let rate = 5           // å¹´åˆ©ç‡5%
  let times = 3          // 3å¹´
  
  // è®¡ç®—å¢é•¿å› å­ï¼š(100 + 5)^3 = 105^3
  let growth_factor = multiply(multiply(105, 105), 105)
  let total = multiply(principal, growth_factor) / multiply(multiply(100, 100), 100)
  
  assert_eq(11576, total)  // 10000 Ã— 1157625 / 1000000 â‰ˆ 11576
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  let first_name = "John"
  let last_name = "Doe"
  let age = "30"
  
  // æµ‹è¯•å¤šéƒ¨åˆ†å­—ç¬¦ä¸²æ‹¼æ¥
  let full_greeting = greet(first_name + " " + last_name + " (" + age + ")")
  assert_eq_string("Hello, John Doe (30)!", full_greeting)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å¤æ‚å­—ç¬¦ä¸²
  let complex_string = "User@2023#Project$Alpha"
  let complex_greeting = greet(complex_string)
  assert_eq_string("Hello, User@2023#Project$Alpha!", complex_greeting)
  
  // æµ‹è¯•Unicodeå­—ç¬¦ç»„åˆ
  let unicode_string = "ğŸŒğŸš€MoonBit"
  let unicode_greeting = greet(unicode_string)
  assert_eq_string("Hello, ğŸŒğŸš€MoonBit!", unicode_greeting)
}

test "mathematical_series_summation" {
  // æ•°å­¦çº§æ•°æ±‚å’Œæµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—ï¼š2 + 5 + 8 + ... + 29 (10é¡¹)
  // å…¬å¼ï¼šS = n Ã— (2a + (n-1)d) / 2
  
  let n = 10          // é¡¹æ•°
  let a = 2           // é¦–é¡¹
  let d = 3           // å…¬å·®
  
  let sum = multiply(n, add(multiply(2, a), multiply(n - 1, d))) / 2
  assert_eq(155, sum)  // 10 Ã— (4 + 27) / 2 = 155
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—ï¼š3 + 6 + 12 + 24 + 48 (5é¡¹)
  // å…¬å¼ï¼šS = a Ã— (r^n - 1) / (r - 1)
  let geo_a = 3       // é¦–é¡¹
  let r = 2           // å…¬æ¯”
  let geo_n = 5       // é¡¹æ•°
  
  let geo_sum = multiply(geo_a, multiply(multiply(multiply(multiply(2, 2), 2), 2) - 1, 1)) / (r - 1)
  assert_eq(93, geo_sum)  // 3 Ã— (32 - 1) / 1 = 93
}

test "business_logic_calculation" {
  // ä¸šåŠ¡é€»è¾‘è®¡ç®—æµ‹è¯•
  let unit_price = 50
  let quantity = 15
  let bulk_discount_threshold = 10
  let bulk_discount_rate = 10
  let loyalty_discount = 5
  let shipping_cost = 25
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(unit_price, quantity)
  
  // è®¡ç®—æ‰¹é‡æŠ˜æ‰£
  let bulk_discount = if (quantity > bulk_discount_threshold) {
    multiply(subtotal, bulk_discount_rate) / 100
  } else {
    0
  }
  
  // è®¡ç®—æŠ˜æ‰£åä»·æ ¼
  let after_bulk_discount = add(subtotal, -bulk_discount)
  
  // è®¡ç®—å¿ è¯šåº¦æŠ˜æ‰£
  let loyalty_discount_amount = multiply(after_bulk_discount, loyalty_discount) / 100
  let after_loyalty_discount = add(after_bulk_discount, -loyalty_discount_amount)
  
  // è®¡ç®—æœ€ç»ˆä»·æ ¼
  let final_price = add(after_loyalty_discount, shipping_cost)
  
  assert_eq(747, final_price)  // (750 - 75 - 33) + 25 = 747
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  let n = 100
  
  // æ¨¡æ‹ŸO(n)å¤æ‚åº¦ï¼šçº¿æ€§æ±‚å’Œ
  let linear_sum = multiply(n, add(n, 1)) / 2  // 1 + 2 + ... + n
  assert_eq(5050, linear_sum)
  
  // æ¨¡æ‹ŸO(nÂ²)å¤æ‚åº¦ï¼šå¹³æ–¹å’Œ
  let square_sum = multiply(n, multiply(add(n, 1), add(multiply(2, n), 1))) / 6
  assert_eq(338350, square_sum)
  
  // æ¨¡æ‹ŸO(log n)å¤æ‚åº¦ï¼šå¯¹æ•°è¿ç®—ï¼ˆç®€åŒ–ï¼‰
  let log_approx = 0
  let temp = n
  let log_result = if (temp >= 128) { 7 } else if (temp >= 64) { 6 } else if (temp >= 32) { 5 } else if (temp >= 16) { 4 } else if (temp >= 8) { 3 } else if (temp >= 4) { 2 } else if (temp >= 2) { 1 } else { 0 }
  assert_eq(6, log_result)  // logâ‚‚(100) â‰ˆ 6.64ï¼Œå‘ä¸‹å–æ•´ä¸º6
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špushå’Œpop
  let stack_size = 10
  let push_operations = 5
  let pop_operations = 3
  
  let final_stack_size = add(stack_size, push_operations - pop_operations)
  assert_eq(12, final_stack_size)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼šenqueueå’Œdequeue
  let queue_size = 8
  let enqueue_operations = 6
  let dequeue_operations = 4
  
  let final_queue_size = add(queue_size, enqueue_operations - dequeue_operations)
  assert_eq(10, final_queue_size)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨è´Ÿè½½å› å­è®¡ç®—
  let table_capacity = 16
  let occupied_slots = 12
  let load_factor = multiply(occupied_slots, 100) / table_capacity
  assert_eq(75, load_factor)  // 12/16 Ã— 100% = 75%
}

test "scientific_calculation_scenario" {
  // ç§‘å­¦è®¡ç®—åœºæ™¯æµ‹è¯•
  // è®¡ç®—è‡ªç”±è½ä½“è·ç¦»ï¼šs = 0.5 Ã— g Ã— tÂ²
  // ä½¿ç”¨æ•´æ•°è¿ç®—ï¼šs = g Ã— tÂ² / 2
  
  let gravity = 98  // 9.8 m/sÂ² æ”¾å¤§10å€
  let time = 5      // 5ç§’
  
  let distance = multiply(gravity, multiply(time, time)) / 20  // é™¤ä»¥20å› ä¸ºgravityæ”¾å¤§äº†10å€ä¸”å…¬å¼ä¸­æœ‰0.5
  assert_eq(122, distance)  // 98 Ã— 25 / 20 = 122.5ï¼Œå–æ•´ä¸º122
  
  // è®¡ç®—åŠ¨èƒ½ï¼šE = 0.5 Ã— m Ã— vÂ²
  let mass = 10      // 10kg
  let velocity = 15  // 15m/s
  
  let kinetic_energy = multiply(mass, multiply(velocity, velocity)) / 2
  assert_eq(1125, kinetic_energy)  // 10 Ã— 225 / 2 = 1125
  
  // è®¡ç®—åŠ¿èƒ½ï¼šE = m Ã— g Ã— h
  let height = 20    // 20ç±³
  
  let potential_energy = multiply(mass, multiply(gravity, height)) / 10  // é™¤ä»¥10å› ä¸ºgravityæ”¾å¤§äº†10å€
  assert_eq(1960, potential_energy)  // 10 Ã— 98 Ã— 20 / 10 = 1960
}