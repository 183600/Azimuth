// MoonBit æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// è¿™äº›æµ‹è¯•ç”¨ä¾‹ä¸“æ³¨äºéªŒè¯ azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "boundary_value_combinations" {
  // æµ‹è¯•å¤šä¸ªè¾¹ç•Œæ¡ä»¶çš„å¤æ‚ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¾¹ç•Œå€¼é“¾å¼è¿ç®—
  let chain_result = @azimuth.add(@azimuth.multiply(max_val, 0), min_val)
  @azimuth.assert_eq(min_val, chain_result)
  
  // è¾¹ç•Œå€¼æ··åˆè¿ç®—
  let mixed_result = @azimuth.add(@azimuth.multiply(max_val, 1), @azimuth.multiply(min_val, 0))
  @azimuth.assert_eq(max_val, mixed_result)
  
  // è¾¹ç•Œå€¼ç‰¹æ®Šå¤„ç†
  let special_result = @azimuth.multiply(@azimuth.add(min_val, 1), -1)
  @azimuth.assert_eq(2147483647, special_result)
}

test "performance_calculation" {
  // æ€§èƒ½ç›¸å…³æµ‹è¯•ï¼šå¤§é‡æ•°æ®çš„è®¡ç®—
  let base = 1000
  let multiplier = 100
  
  // æ¨¡æ‹Ÿç´¯åŠ è®¡ç®—ï¼šbase + base*2 + ... + base*multiplier
  // ä½¿ç”¨å…¬å¼ï¼šbase * (1 + 2 + ... + multiplier) = base * multiplier * (multiplier + 1) / 2
  let sum_result = @azimuth.multiply(base, @azimuth.multiply(multiplier, @azimuth.add(multiplier, 1)) / 2)
  @azimuth.assert_eq(5050000, sum_result)
  
  // æ¨¡æ‹ŸæŒ‡æ•°å¢é•¿è®¡ç®—
  let growth_base = 2
  let exponential_result = @azimuth.multiply(@azimuth.multiply(@azimuth.multiply(growth_base, growth_base), 
                                                  @azimuth.multiply(growth_base, growth_base)), 
                                                  @azimuth.multiply(@azimuth.multiply(growth_base, growth_base), 
                                                  @azimuth.multiply(growth_base, growth_base)))
  @azimuth.assert_eq(256, exponential_result)
}

test "business_calculation_scenario" {
  // å®é™…ä¸šåŠ¡åœºæ™¯ï¼šç”µå•†è®¢å•è®¡ç®—
  let product_price = 199
  let quantity = 3
  let discount_rate = 10
  let tax_rate = 8
  let shipping = 15
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = @azimuth.multiply(product_price, quantity)
  
  // è®¡ç®—æŠ˜æ‰£ï¼ˆè¶…è¿‡500å…ƒäº«å—æŠ˜æ‰£ï¼‰
  let discount = if (subtotal > 500) {
    @azimuth.multiply(subtotal, discount_rate) / 100
  } else {
    0
  }
  
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_total = @azimuth.add(subtotal, -discount)
  
  // è®¡ç®—ç¨è´¹
  let tax = @azimuth.multiply(discounted_total, tax_rate) / 100
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·
  let final_total = @azimuth.add(@azimuth.add(discounted_total, tax), shipping)
  
  @azimuth.assert_eq(674, final_total)
}

test "mathematical_identities" {
  // éªŒè¯åŸºæœ¬çš„æ•°å­¦æ’ç­‰å¼
  let a = 12
  let b = 8
  let c = 5
  
  // éªŒè¯åˆ†é…å¾‹ï¼ša Ã— (b + c) = a Ã— b + a Ã— c
  let distributive_left = @azimuth.multiply(a, @azimuth.add(b, c))
  let distributive_right = @azimuth.add(@azimuth.multiply(a, b), @azimuth.multiply(a, c))
  @azimuth.assert_eq(distributive_left, distributive_right)
  
  // éªŒè¯ç»“åˆå¾‹ï¼š(a + b) + c = a + (b + c)
  let associative_left = @azimuth.add(@azimuth.add(a, b), c)
  let associative_right = @azimuth.add(a, @azimuth.add(b, c))
  @azimuth.assert_eq(associative_left, associative_right)
  
  // éªŒè¯äº¤æ¢å¾‹ï¼ša Ã— b = b Ã— a
  let commutative_left = @azimuth.multiply(a, b)
  let commutative_right = @azimuth.multiply(b, a)
  @azimuth.assert_eq(commutative_left, commutative_right)
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å„ç§ç‰¹æ®Šçš„å­—ç¬¦ä¸²å¤„ç†æƒ…å†µ
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let result1 = @azimuth.greet(special_chars)
  @azimuth.assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?! ", result1)
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_chars = "ğŸŒğŸŒğŸŒğŸŒğŸ—ºï¸"
  let result2 = @azimuth.greet(unicode_chars)
  @azimuth.assert_eq_string("Hello, ğŸŒğŸŒğŸŒğŸŒğŸ—ºï¸!", result2)
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼å’Œåˆ¶è¡¨ç¬¦çš„å­—ç¬¦ä¸²
  let whitespace_chars = "  \t\n  "
  let result3 = @azimuth.greet(whitespace_chars)
  @azimuth.assert_eq_string("Hello,  	  	  !", result3)
  
  // æµ‹è¯•æ•°å­—å’Œå­—æ¯æ··åˆçš„å­—ç¬¦ä¸²
  let alphanumeric = "ABC123xyz456"
  let result4 = @azimuth.greet(alphanumeric)
  @azimuth.assert_eq_string("Hello, ABC123xyz456!", result4)
}

test "function_composition" {
  // æµ‹è¯•å¤šä¸ªå‡½æ•°çš„ç»„åˆä½¿ç”¨
  // è®¡ç®—ï¼š(a + b) Ã— (c - d) + e
  let a = 10
  let b = 5
  let c = 20
  let d = 8
  let e = 15
  
  let sum_ab = @azimuth.add(a, b)
  let diff_cd = @azimuth.add(c, -d)
  let product = @azimuth.multiply(sum_ab, diff_cd)
  let result = @azimuth.add(product, e)
  
  @azimuth.assert_eq(105, result)
  
  // æµ‹è¯•åµŒå¥—å‡½æ•°è°ƒç”¨
  let nested_result = @azimuth.add(@azimuth.multiply(@azimuth.add(3, 4), @azimuth.add(5, 2)), 10)
  @azimuth.assert_eq(67, nested_result)
}

test "conditional_logic_calculation" {
  // æµ‹è¯•åŸºäºæ¡ä»¶è®¡ç®—çš„é€»è¾‘
  let x = 25
  let y = 30
  let z = 15
  
  // æ¡ä»¶1ï¼šå¦‚æœ x + y > zï¼Œåˆ™è®¡ç®— (x + y) Ã— zï¼Œå¦åˆ™è®¡ç®— x + y + z
  let condition1 = @azimuth.add(x, y) > z
  let result1 = if condition1 {
    @azimuth.multiply(@azimuth.add(x, y), z)
  } else {
    @azimuth.add(@azimuth.add(x, y), z)
  }
  @azimuth.assert_eq(825, result1)
  
  // æ¡ä»¶2ï¼šå¦‚æœ x Ã— y < 1000ï¼Œåˆ™è®¡ç®— x + yï¼Œå¦åˆ™è®¡ç®— x Ã— y
  let condition2 = @azimuth.multiply(x, y) < 1000
  let result2 = if condition2 {
    @azimuth.add(x, y)
  } else {
    @azimuth.multiply(x, y)
  }
  @azimuth.assert_eq(55, result2)
}

test "data_conversion_scenarios" {
  // æµ‹è¯•ä¸åŒæ•°æ®ç±»å‹çš„è½¬æ¢åœºæ™¯
  // æ¨¡æ‹Ÿæ•´æ•°åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢éªŒè¯
  let year_str = "2024"
  let greeting1 = @azimuth.greet(year_str)
  @azimuth.assert_eq_string("Hello, 2024!", greeting1)
  
  // æ¨¡æ‹Ÿå¸ƒå°”å€¼åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢
  let bool_true_str = "true"
  let bool_false_str = "false"
  let greeting2 = @azimuth.greet(bool_true_str)
  let greeting3 = @azimuth.greet(bool_false_str)
  @azimuth.assert_eq_string("Hello, true!", greeting2)
  @azimuth.assert_eq_string("Hello, false!", greeting3)
  
  // æ¨¡æ‹Ÿæµ®ç‚¹æ•°çš„å­—ç¬¦ä¸²è¡¨ç¤º
  let pi_str = "3.14159"
  let greeting4 = @azimuth.greet(pi_str)
  @azimuth.assert_eq_string("Hello, 3.14159!", greeting4)
  
  // æ¨¡æ‹Ÿæ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²
  let datetime_str = "2024-01-15T10:30:00"
  let greeting5 = @azimuth.greet(datetime_str)
  @azimuth.assert_eq_string("Hello, 2024-01-15T10:30:00!", greeting5)
}

test "error_recovery_mechanisms" {
  // æµ‹è¯•é”™è¯¯æƒ…å†µçš„å¤„ç†å’Œæ¢å¤
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•åŠ æ³•æº¢å‡ºä¿æŠ¤
  let overflow_add = @azimuth.add(max_val, 1000)
  @azimuth.assert_eq(max_val, overflow_add)
  
  // æµ‹è¯•å‡æ³•æº¢å‡ºä¿æŠ¤
  let underflow_add = @azimuth.add(min_val, -1000)
  @azimuth.assert_eq(min_val, underflow_add)
  
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºä¿æŠ¤
  let overflow_mul = @azimuth.multiply(max_val, 100)
  @azimuth.assert_eq(max_val, overflow_mul)
  
  // æµ‹è¯•æœ€å°å€¼ç‰¹æ®Šå¤„ç†
  let min_val_special = @azimuth.multiply(min_val, -1)
  @azimuth.assert_eq(min_val, min_val_special)
  
  // éªŒè¯æ­£å¸¸è¿ç®—ä»ç„¶æœ‰æ•ˆ
  @azimuth.assert_eq(100, @azimuth.add(50, 50))
  @azimuth.assert_eq(100, @azimuth.multiply(10, 10))
}

test "comprehensive_application" {
  // ç»¼åˆæ€§åº”ç”¨æµ‹è¯•ï¼šæ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„è®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—ä¸€ä¸ªé¡¹ç›®çš„æ€»æˆæœ¬ï¼ŒåŒ…æ‹¬ææ–™ã€äººå·¥ã€ç®¡ç†è´¹ç”¨å’Œç¨è´¹
  
  let material_cost = 5000
  let labor_cost = 3000
  let management_rate = 15  // ç®¡ç†è´¹ç‡15%
  let tax_rate = 10         // ç¨ç‡10%
  
  // è®¡ç®—ç›´æ¥æˆæœ¬
  let direct_cost = @azimuth.add(material_cost, labor_cost)
  
  // è®¡ç®—ç®¡ç†è´¹ç”¨
  let management_cost = @azimuth.multiply(direct_cost, management_rate) / 100
  
  // è®¡ç®—å°è®¡ï¼ˆç›´æ¥æˆæœ¬ + ç®¡ç†è´¹ç”¨ï¼‰
  let subtotal = @azimuth.add(direct_cost, management_cost)
  
  // è®¡ç®—ç¨è´¹
  let tax = @azimuth.multiply(subtotal, tax_rate) / 100
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = @azimuth.add(subtotal, tax)
  
  // éªŒè¯è®¡ç®—ç»“æœ
  @azimuth.assert_eq(8000, direct_cost)      // 5000 + 3000 = 8000
  @azimuth.assert_eq(1200, management_cost)  // 8000 * 15% = 1200
  @azimuth.assert_eq(9200, subtotal)         // 8000 + 1200 = 9200
  @azimuth.assert_eq(920, tax)               // 9200 * 10% = 920
  @azimuth.assert_eq(10120, total_cost)      // 9200 + 920 = 10120
}