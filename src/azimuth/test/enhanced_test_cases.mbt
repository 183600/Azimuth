// å¢å¼ºçš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›–æ›´å¤šè¾¹ç•Œæƒ…å†µå’Œå®é™…åº”ç”¨åœºæ™¯

test "complex_arithmetic_operations" {
  // æµ‹è¯•å¤åˆç®—æœ¯è¿ç®—ï¼š(a + b) * c - d
  let a = 15
  let b = 25
  let c = 4
  let d = 30
  
  let sum_ab = azimuth::add(a, b)
  let product = azimuth::multiply(sum_ab, c)
  let result = azimuth::add(product, -d)
  
  azimuth::assert_eq(130, result)
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  azimuth::assert_eq_string("Hello, !", azimuth::greet(""))
  azimuth::assert_eq_string("Hello, A!", azimuth::greet("A"))
  azimuth::assert_eq_string("Hello, 123!", azimuth::greet("123"))
  azimuth::assert_eq_string("Hello, ğŸŒŸ!", azimuth::greet("ğŸŒŸ"))
}

test "mathematical_series_calculations" {
  // æµ‹è¯•æ•°å­¦æ•°åˆ—è®¡ç®—
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼šn * (first + last) / 2
  let n = 10
  let first = 1
  let last = 10
  
  let sum = azimuth::multiply(n, azimuth::add(first, last)) / 2
  azimuth::assert_eq(55, sum)
}

test "overflow_protection_mechanisms" {
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤æœºåˆ¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•åŠ æ³•æº¢å‡ºä¿æŠ¤
  azimuth::assert_eq(max_val, azimuth::add(max_val, 1000))
  azimuth::assert_eq(min_val, azimuth::add(min_val, -1000))
  
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºä¿æŠ¤
  azimuth::assert_eq(max_val, azimuth::multiply(max_val, 2))
  azimuth::assert_eq(min_val, azimuth::multiply(min_val, 2))
}

test "real_world_financial_calculations" {
  // æµ‹è¯•å®é™…é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate = 5
  let years = 3
  
  // ç®€å•åˆ©æ¯è®¡ç®—ï¼šæœ¬é‡‘ + æœ¬é‡‘ * åˆ©ç‡ * å¹´æ•°
  let interest = azimuth::multiply(principal, azimuth::multiply(rate, years))
  let total = azimuth::add(principal, interest)
  
  azimuth::assert_eq(160000, total)
}

test "geometric_calculations" {
  // æµ‹è¯•å‡ ä½•è®¡ç®—
  let length = 12
  let width = 8
  
  // è®¡ç®—çŸ©å½¢é¢ç§¯
  let area = azimuth::multiply(length, width)
  azimuth::assert_eq(96, area)
  
  // è®¡ç®—çŸ©å½¢å‘¨é•¿ï¼š2 * (length + width)
  let perimeter = azimuth::multiply(2, azimuth::add(length, width))
  azimuth::assert_eq(40, perimeter)
}

test "temperature_conversion_scenarios" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢åœºæ™¯
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼ˆç®€åŒ–å…¬å¼ï¼‰ï¼šF = C * 2 + 30
  let celsius = 25
  let fahrenheit = azimuth::add(azimuth::multiply(celsius, 2), 30)
  azimuth::assert_eq(80, fahrenheit)
  
  // æµ‹è¯•å†°ç‚¹
  let freezing = azimuth::add(azimuth::multiply(0, 2), 30)
  azimuth::assert_eq(30, freezing)
  
  // æµ‹è¯•æ²¸ç‚¹
  let boiling = azimuth::add(azimuth::multiply(100, 2), 30)
  azimuth::assert_eq(230, boiling)
}

test "error_boundary_conditions" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œæ¡ä»¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„æ­£ç¡®æ€§
  azimuth::assert_true(true)
  azimuth::assert_false(false)
  azimuth::assert_eq(42, 42)
  azimuth::assert_eq_string("test", "test")
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„æ­£ç¡®å¤„ç†
  azimuth::assert_true(azimuth::add(max_val, 1) == max_val)
  azimuth::assert_true(azimuth::add(min_val, -1) == min_val)
}

test "performance_related_operations" {
  // æµ‹è¯•æ€§èƒ½ç›¸å…³çš„æ“ä½œ
  let base = 100
  let multiplier = 1000
  
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_result = azimuth::multiply(base, multiplier)
  azimuth::assert_eq(100000, large_result)
  
  // æµ‹è¯•è¿ç»­è¿ç®—
  let consecutive_result = azimuth::add(azimuth::multiply(10, 20), azimuth::multiply(30, 40))
  azimuth::assert_eq(1400, consecutive_result)
}

test "data_validation_scenarios" {
  // æµ‹è¯•æ•°æ®éªŒè¯åœºæ™¯
  // æµ‹è¯•è¾“å…¥éªŒè¯
  let valid_inputs = [0, 1, -1, 100, -100, 2147483647, -2147483648]
  
  // éªŒè¯æ¯ä¸ªè¾“å…¥ä¸0çš„åŠ æ³•
  azimuth::assert_eq(0, azimuth::add(0, 0))
  azimuth::assert_eq(1, azimuth::add(1, 0))
  azimuth::assert_eq(-1, azimuth::add(-1, 0))
  azimuth::assert_eq(100, azimuth::add(100, 0))
  azimuth::assert_eq(-100, azimuth::add(-100, 0))
  azimuth::assert_eq(2147483647, azimuth::add(2147483647, 0))
  azimuth::assert_eq(-2147483648, azimuth::add(-2147483648, 0))
  
  // éªŒè¯æ¯ä¸ªè¾“å…¥ä¸1çš„ä¹˜æ³•
  azimuth::assert_eq(0, azimuth::multiply(0, 1))
  azimuth::assert_eq(1, azimuth::multiply(1, 1))
  azimuth::assert_eq(-1, azimuth::multiply(-1, 1))
  azimuth::assert_eq(100, azimuth::multiply(100, 1))
  azimuth::assert_eq(-100, azimuth::multiply(-100, 1))
  azimuth::assert_eq(2147483647, azimuth::multiply(2147483647, 1))
  azimuth::assert_eq(-2147483648, azimuth::multiply(-2147483648, 1))
}// ç»¼åˆ MoonBit æµ‹è¯•ç”¨ä¾‹ - è¦†ç›–æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ
// å¯¼å…¥ azimuth åŒ…ä»¥ä½¿ç”¨å…¶ä¸­çš„å‡½æ•°

test "addition_comprehensive_test" {
  // æµ‹è¯•åŠ æ³•çš„å„ç§æƒ…å†µ
  // åŸºæœ¬åŠ æ³•
  assert_eq(10, azimuth::add(7, 3))
  assert_eq(0, azimuth::add(5, -5))
  assert_eq(-10, azimuth::add(-7, -3))
  
  // ä¸0ç›¸åŠ 
  assert_eq(5, azimuth::add(5, 0))
  assert_eq(5, azimuth::add(0, 5))
  assert_eq(0, azimuth::add(0, 0))
  
  // å¤§æ•°ç›¸åŠ 
  assert_eq(2000000, azimuth::add(1000000, 1000000))
  assert_eq(-2000000, azimuth::add(-1000000, -1000000))
}

test "multiplication_comprehensive_test" {
  // æµ‹è¯•ä¹˜æ³•çš„å„ç§æƒ…å†µ
  // åŸºæœ¬ä¹˜æ³•
  assert_eq(15, azimuth::multiply(3, 5))
  assert_eq(-12, azimuth::multiply(-3, 4))
  assert_eq(12, azimuth::multiply(-3, -4))
  
  // ä¸0å’Œ1ç›¸ä¹˜
  assert_eq(0, azimuth::multiply(8, 0))
  assert_eq(8, azimuth::multiply(8, 1))
  assert_eq(8, azimuth::multiply(1, 8))
  
  // å¤§æ•°ç›¸ä¹˜
  assert_eq(1000000, azimuth::multiply(1000, 1000))
  assert_eq(-1000000, azimuth::multiply(-1000, 1000))
}

test "boundary_value_test" {
  // æµ‹è¯•è¾¹ç•Œå€¼å¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼è¿ç®—
  assert_eq(max_val, azimuth::add(max_val, 0))
  assert_eq(max_val, azimuth::multiply(max_val, 1))
  assert_eq(min_val, azimuth::multiply(max_val, -1))
  
  // æœ€å°å€¼è¿ç®—
  assert_eq(min_val, azimuth::add(min_val, 0))
  assert_eq(min_val, azimuth::multiply(min_val, 1))
  assert_eq(min_val, azimuth::multiply(min_val, -1))
  
  // æå€¼ç›¸åŠ 
  assert_eq(-1, azimuth::add(max_val, min_val))
}

test "overflow_protection_test" {
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  let min_val = -2147483648
  
  // åŠ æ³•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, azimuth::add(max_val, 1))
  assert_eq(max_val, azimuth::add(max_val, 100))
  assert_eq(max_val, azimuth::add(max_val, max_val))
  
  assert_eq(min_val, azimuth::add(min_val, -1))
  assert_eq(min_val, azimuth::add(min_val, -100))
  assert_eq(min_val, azimuth::add(min_val, min_val))
  
  // ä¹˜æ³•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, azimuth::multiply(max_val, 2))
  assert_eq(min_val, azimuth::multiply(min_val, 2))
  assert_eq(max_val, azimuth::multiply(46341, 46341))  // sqrt(max_val)çš„å¹³æ–¹
}

test "string_processing_test" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†
  // åŸºæœ¬å­—ç¬¦ä¸²
  assert_eq_string("Hello, World!", azimuth::greet("World"))
  assert_eq_string("Hello, MoonBit!", azimuth::greet("MoonBit"))
  
  // ç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, @#$%!", azimuth::greet("@#$%"))
  assert_eq_string("Hello, 123!", azimuth::greet("123"))
  
  // Unicodeå­—ç¬¦
  assert_eq_string("Hello, æµ‹è¯•!", azimuth::greet("æµ‹è¯•"))
  assert_eq_string("Hello, ğŸŒ!", azimuth::greet("ğŸŒ"))
  
  // ç©ºå­—ç¬¦ä¸²å’Œç©ºæ ¼
  assert_eq_string("Hello, !", azimuth::greet(""))
  assert_eq_string("Hello,  !", azimuth::greet(" "))
}

test "function_composition_test" {
  // æµ‹è¯•å‡½æ•°ç»„åˆ
  // å¤åˆè®¡ç®—ï¼š(a+b)Ã—(c-d)
  let a = 8
  let b = 2
  let c = 15
  let d = 5
  
  let sum_ab = azimuth::add(a, b)
  let diff_cd = azimuth::add(c, -d)
  let result = azimuth::multiply(sum_ab, diff_cd)
  
  assert_eq(100, result)  // (8+2)Ã—(15-5) = 10Ã—10 = 100
  
  // é“¾å¼è®¡ç®—ï¼šaÃ—b + cÃ—d
  let e = 3
  let f = 4
  let g = 5
  let h = 6
  
  let product1 = azimuth::multiply(e, f)
  let product2 = azimuth::multiply(g, h)
  let sum_result = azimuth::add(product1, product2)
  
  assert_eq(42, sum_result)  // 3Ã—4 + 5Ã—6 = 12 + 30 = 42
}

test "real_world_application_test" {
  // æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
  // è´­ç‰©è½¦è®¡ç®—
  let item1_price = 199
  let item1_quantity = 2
  let item2_price = 299
  let item2_quantity = 1
  
  let total1 = azimuth::multiply(item1_price, item1_quantity)
  let total2 = azimuth::multiply(item2_price, item2_quantity)
  let cart_total = azimuth::add(total1, total2)
  
  assert_eq(697, cart_total)  // 199Ã—2 + 299Ã—1 = 398 + 299 = 697
  
  // é¢ç§¯è®¡ç®—
  let length = 12
  let width = 8
  let area = azimuth::multiply(length, width)
  
  assert_eq(96, area)  // 12Ã—8 = 96
  
  // å‘¨é•¿è®¡ç®—
  let perimeter = azimuth::multiply(azimuth::add(length, width), 2)
  assert_eq(40, perimeter)  // (12+8)Ã—2 = 40
}

test "conditional_logic_test" {
  // æµ‹è¯•æ¡ä»¶é€»è¾‘
  let x = 15
  let y = 20
  
  // æ¡ä»¶ï¼šå¦‚æœx<yåˆ™ç›¸åŠ ï¼Œå¦åˆ™ç›¸ä¹˜
  let condition = x < y
  let result = if condition { azimuth::add(x, y) } else { azimuth::multiply(x, y) }
  assert_eq(35, result)  // 15<20ä¸ºçœŸï¼Œæ‰€ä»¥15+20=35
  
  // åå‘æ¡ä»¶
  let result2 = if x > y { azimuth::add(x, y) } else { azimuth::multiply(x, y) }
  assert_eq(300, result2)  // 15>20ä¸ºå‡ï¼Œæ‰€ä»¥15Ã—20=300
  
  // åµŒå¥—æ¡ä»¶
  let z = 10
  let complex_result = 
    if x < y {
      if y < z { azimuth::add(x, azimuth::add(y, z)) } 
      else { azimuth::multiply(x, azimuth::add(y, z)) }
    } else {
      azimuth::add(azimuth::multiply(x, y), z)
    }
  
  assert_eq(350, complex_result)  // 15<20ä¸ºçœŸï¼Œ20<10ä¸ºå‡ï¼Œæ‰€ä»¥15Ã—(20+10)=15Ã—30=450
}

test "mathematical_series_test" {
  // æµ‹è¯•æ•°å­¦æ•°åˆ—
  // ç­‰å·®æ•°åˆ—å‰5é¡¹å’Œï¼š2+4+6+8+10 = 30
  let sum1 = azimuth::add(azimuth::add(2, 4), azimuth::add(6, azimuth::add(8, 10)))
  assert_eq(30, sum1)
  
  // ç­‰æ¯”æ•°åˆ—å‰4é¡¹ç§¯ï¼š2Ã—4Ã—8Ã—16 = 1024
  let product1 = azimuth::multiply(2, azimuth::multiply(4, azimuth::multiply(8, 16)))
  assert_eq(1024, product1)
  
  // å¹³æ–¹å’Œï¼š1Â²+2Â²+3Â²+4Â² = 1+4+9+16 = 30
  let square1 = azimuth::multiply(1, 1)
  let square2 = azimuth::multiply(2, 2)
  let square3 = azimuth::multiply(3, 3)
  let square4 = azimuth::multiply(4, 4)
  let sum_of_squares = azimuth::add(azimuth::add(azimuth::add(square1, square2), square3), square4)
  assert_eq(30, sum_of_squares)
}

test "performance_test" {
  // æµ‹è¯•æ€§èƒ½ç›¸å…³çš„å¤§æ•°è¿ç®—
  // å¤§æ•°åŠ æ³•
  let large1 = 1000000
  let large2 = 2000000
  let large3 = 3000000
  
  assert_eq(6000000, azimuth::add(azimuth::add(large1, large2), large3))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(6000000000000000, azimuth::multiply(large1, azimuth::multiply(large2, large3)))
  
  // é‡å¤è¿ç®—é“¾
  let chain_result = azimuth::add(1, 1)
  chain_result = azimuth::add(chain_result, 2)
  chain_result = azimuth::add(chain_result, 3)
  chain_result = azimuth::add(chain_result, 4)
  chain_result = azimuth::add(chain_result, 5)
  
  assert_eq(16, chain_result)  // 1+1+2+3+4+5 = 16
  
  // åµŒå¥—è¿ç®—
  let nested_result = azimuth::multiply(
    azimuth::add(100, 200), 
    azimuth::add(azimuth::multiply(3, 4), azimuth::multiply(5, 6))
  )
  assert_eq(12600, nested_result)  // (100+200)Ã—(3Ã—4+5Ã—6) = 300Ã—(12+30) = 300Ã—42 = 12600
}