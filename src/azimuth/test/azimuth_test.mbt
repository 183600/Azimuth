// Azimuth é¡¹ç›® MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•åŸºæœ¬æ•°å­¦è¿ç®—å’Œå­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½

test "string_with_special_characters" {
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²å¤„ç†
  @azimuth.assert_eq_string("Hello, @#$%^&*()!", @azimuth.greet("@#$%^&*()"))
  @azimuth.assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", @azimuth.greet("ä¸­æ–‡æµ‹è¯•"))
  @azimuth.assert_eq_string("Hello, Ã©mojiğŸš€!", @azimuth.greet("Ã©mojiğŸš€"))
  @azimuth.assert_eq_string("Hello,   spaced   !", @azimuth.greet("  spaced   "))
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰æ€§è´¨
  let a = 42
  let b = 17
  
  // åŠ æ³•æ’ç­‰å¼
  @azimuth.assert_eq(a, @azimuth.add(a, 0))
  @azimuth.assert_eq(a, @azimuth.add(0, a))
  
  // ä¹˜æ³•æ’ç­‰å¼
  @azimuth.assert_eq(a, @azimuth.multiply(a, 1))
  @azimuth.assert_eq(a, @azimuth.multiply(1, a))
  @azimuth.assert_eq(0, @azimuth.multiply(a, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(0, a))
}

test "complex_calculation_scenarios" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯
  // åœºæ™¯1ï¼šè®¡ç®—äºŒæ¬¡æ–¹ç¨‹ axÂ² + bx + c
  let x = 5
  let a = 2
  let b = 3
  let c = 7
  
  let x_squared = @azimuth.multiply(x, x)  // xÂ² = 25
  let ax_squared = @azimuth.multiply(a, x_squared)  // axÂ² = 50
  let bx = @azimuth.multiply(b, x)  // bx = 15
  let result = @azimuth.add(@azimuth.add(ax_squared, bx), c)  // axÂ² + bx + c = 72
  
  @azimuth.assert_eq(72, result)
}

test "financial_calculation_compound_interest" {
  // æµ‹è¯•å¤åˆ©è®¡ç®—åœºæ™¯
  let principal = 10000  // æœ¬é‡‘
  let rate = 5  // åˆ©ç‡ç™¾åˆ†æ¯”
  let years = 3  // å¹´æ•°
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼šæœ€ç»ˆé‡‘é¢ = æœ¬é‡‘ Ã— (1 + åˆ©ç‡ Ã— å¹´æ•°)
  let growth_factor = @azimuth.add(1, @azimuth.multiply(rate, years))  // 1 + 5Ã—3 = 16
  let final_amount = @azimuth.multiply(principal, growth_factor)  // 10000 Ã— 16 = 160000
  
  @azimuth.assert_eq(160000, final_amount)
}

test "geometry_calculations_rectangle" {
  // æµ‹è¯•å‡ ä½•è®¡ç®—ï¼šçŸ©å½¢
  let length = 12
  let width = 8
  
  // è®¡ç®—é¢ç§¯
  let area = @azimuth.multiply(length, width)
  @azimuth.assert_eq(96, area)
  
  // è®¡ç®—å‘¨é•¿
  let perimeter = @azimuth.add(@azimuth.multiply(2, length), @azimuth.multiply(2, width))
  @azimuth.assert_eq(40, perimeter)
  
  // è®¡ç®—å¯¹è§’çº¿é•¿åº¦ï¼ˆç®€åŒ–è®¡ç®—ï¼Œä¸ä½¿ç”¨å¹³æ–¹æ ¹ï¼‰
  let length_squared = @azimuth.multiply(length, length)  // 144
  let width_squared = @azimuth.multiply(width, width)    // 64
  let diagonal_squared = @azimuth.add(length_squared, width_squared)  // 208
  
  @azimuth.assert_eq(208, diagonal_squared)
}

test "temperature_conversion_celsius_fahrenheit" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢ï¼šæ‘„æ°åº¦è½¬åæ°åº¦
  // ç®€åŒ–å…¬å¼ï¼šF = C Ã— 2 + 30ï¼ˆé¿å…å°æ•°ï¼‰
  
  // æµ‹è¯•å¸¸è§æ¸©åº¦ç‚¹
  let freezing_celsius = 0    // å†°ç‚¹
  let freezing_fahrenheit = @azimuth.add(@azimuth.multiply(freezing_celsius, 2), 30)
  @azimuth.assert_eq(30, freezing_fahrenheit)
  
  let room_celsius = 20       // å®¤æ¸©
  let room_fahrenheit = @azimuth.add(@azimuth.multiply(room_celsius, 2), 30)
  @azimuth.assert_eq(70, room_fahrenheit)
  
  let boiling_celsius = 100   // æ²¸ç‚¹
  let boiling_fahrenheit = @azimuth.add(@azimuth.multiply(boiling_celsius, 2), 30)
  @azimuth.assert_eq(230, boiling_fahrenheit)
}

test "shopping_cart_total_calculation" {
  // æµ‹è¯•è´­ç‰©è½¦æ€»ä»·è®¡ç®—
  let item1_price = 299
  let item1_quantity = 2
  let item2_price = 199
  let item2_quantity = 3
  let item3_price = 99
  let item3_quantity = 1
  let shipping_fee = 15
  let discount = 50
  
  // è®¡ç®—æ¯ç§å•†å“æ€»ä»·
  let total1 = @azimuth.multiply(item1_price, item1_quantity)  // 598
  let total2 = @azimuth.multiply(item2_price, item2_quantity)  // 597
  let total3 = @azimuth.multiply(item3_price, item3_quantity)  // 99
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = @azimuth.add(@azimuth.add(total1, total2), total3)  // 1294
  
  // åº”ç”¨æŠ˜æ‰£å’Œè¿è´¹
  let final_total = @azimuth.add(@azimuth.add(subtotal, -discount), shipping_fee)  // 1259
  
  @azimuth.assert_eq(1259, final_total)
}

test "statistical_calculations_mean_median" {
  // æµ‹è¯•ç»Ÿè®¡è®¡ç®—ï¼šå¹³å‡å€¼å’Œä¸­ä½æ•°
  // æ•°æ®é›†ï¼š10, 20, 30, 40, 50, 60, 70
  
  // è®¡ç®—æ€»å’Œ
  let sum = @azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(10, 20), 30), 40), 50), 60), 70)
  @azimuth.assert_eq(280, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let count = 7
  let mean = sum / count
  @azimuth.assert_eq(40, mean)
  
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆå·²æ’åºæ•°æ®é›†çš„ä¸­é—´å€¼ï¼‰
  let median = 40
  @azimuth.assert_eq(median, median)
  
  // è®¡ç®—èŒƒå›´ï¼ˆæœ€å¤§å€¼ - æœ€å°å€¼ï¼‰
  let range = @azimuth.add(70, -10)
  @azimuth.assert_eq(60, range)
}

test "time_calculations_duration" {
  // æµ‹è¯•æ—¶é—´è®¡ç®—ï¼šæŒç»­æ—¶é—´
  let start_hour = 9   // 9:00 AM
  let start_minute = 30
  let end_hour = 14     // 2:00 PM
  let end_minute = 45
  
  // è½¬æ¢ä¸ºåˆ†é’Ÿæ•°
  let start_total = @azimuth.add(@azimuth.multiply(start_hour, 60), start_minute)  // 570
  let end_total = @azimuth.add(@azimuth.multiply(end_hour, 60), end_minute)        // 885
  
  // è®¡ç®—æŒç»­æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
  let duration = @azimuth.add(end_total, -start_total)  // 315åˆ†é’Ÿ = 5å°æ—¶15åˆ†é’Ÿ
  
  @azimuth.assert_eq(315, duration)
  
  // è½¬æ¢å›å°æ—¶å’Œåˆ†é’Ÿ
  let duration_hours = duration / 60  // 5
  let duration_minutes = duration % 60  // 15
  
  @azimuth.assert_eq(5, duration_hours)
  @azimuth.assert_eq(15, duration_minutes)
}

test "game_score_calculation_complex" {
  // æµ‹è¯•æ¸¸æˆå¾—åˆ†è®¡ç®—ï¼šå¤æ‚åœºæ™¯
  let base_score = 1000
  let level = 5
  let combo_multiplier = 3
  let time_bonus = 500
  let accuracy_penalty = 200
  let difficulty_bonus = 300
  
  // è®¡ç®—ç­‰çº§å¾—åˆ†
  let level_score = @azimuth.multiply(base_score, level)  // 5000
  
  // åº”ç”¨è¿å‡»å€æ•°
  let combo_score = @azimuth.multiply(level_score, combo_multiplier)  // 15000
  
  // åŠ æˆå’Œå‡åˆ†
  let with_time_bonus = @azimuth.add(combo_score, time_bonus)  // 15500
  let with_accuracy_penalty = @azimuth.add(with_time_bonus, -accuracy_penalty)  // 15300
  let final_score = @azimuth.add(with_accuracy_penalty, difficulty_bonus)  // 15600
  
  @azimuth.assert_eq(15600, final_score)
  
  // è®¡ç®—æ’åï¼ˆæ¯1000åˆ†ä¸€ä¸ªç­‰çº§ï¼‰
  let rank_level = final_score / 1000  // 15
  @azimuth.assert_eq(15, rank_level)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num1 = 1000000
  let large_num2 = 2000000
  
  // å¤§æ•°ç›¸åŠ 
  let sum_result = @azimuth.add(large_num1, large_num2)
  @azimuth.assert_eq(3000000, sum_result)
  
  // å¤§æ•°ç›¸ä¹˜
  let product_result = @azimuth.multiply(1000, 2000)
  @azimuth.assert_eq(2000000, product_result)
  
  // å¤§æ•°ä¸è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let large_sum = @azimuth.add(max_val, 1000000)
  @azimuth.assert_eq(max_val, large_sum)  // åº”è¯¥è¢«é™åˆ¶åœ¨æœ€å¤§å€¼
}

test "negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  let neg_num1 = -100
  let neg_num2 = -200
  let pos_num = 150
  
  // è´Ÿæ•°ç›¸åŠ 
  let neg_sum = @azimuth.add(neg_num1, neg_num2)
  @azimuth.assert_eq(-300, neg_sum)
  
  // æ­£è´Ÿæ•°ç›¸åŠ 
  let mixed_sum = @azimuth.add(neg_num1, pos_num)
  @azimuth.assert_eq(50, mixed_sum)
  
  // è´Ÿæ•°ç›¸ä¹˜
  let neg_product = @azimuth.multiply(neg_num1, neg_num2)
  @azimuth.assert_eq(20000, neg_product)
  
  // æ­£è´Ÿæ•°ç›¸ä¹˜
  let mixed_product = @azimuth.multiply(neg_num1, pos_num)
  @azimuth.assert_eq(-15000, mixed_product)
}

test "boundary_value_operations" {
  // æµ‹è¯•è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼è¿ç®—
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 1))
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, 2))
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, max_val))
  
  // æœ€å°å€¼è¿ç®—
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, -1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 2))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, -1))
  
  // è¾¹ç•Œå€¼ç»„åˆ
  @azimuth.assert_eq(-1, @azimuth.add(max_val, min_val))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 1))
}

test "string_processing_extreme" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„æç«¯æƒ…å†µ
  // ç©ºå­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, !", @azimuth.greet(""))
  
  // å•ä¸ªå­—ç¬¦
  @azimuth.assert_eq_string("Hello, A!", @azimuth.greet("A"))
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = "ThisIsAVeryLongStringThatContainsManyCharactersAndShouldStillWorkProperly"
  @azimuth.assert_eq_string("Hello, " + long_string + "!", @azimuth.greet(long_string))
  
  // åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  @azimuth.assert_eq_string("Hello, " + special_chars + "!", @azimuth.greet(special_chars))
  
  // åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_string = "æµ‹è¯•ä¸­æ–‡ğŸŒŸEmoji"
  @azimuth.assert_eq_string("Hello, " + unicode_string + "!", @azimuth.greet(unicode_string))
}

test "mathematical_properties_validation" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨éªŒè¯
  let a = 12
  let b = 8
  let c = 5
  
  // åŠ æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.add(a, b), @azimuth.add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.multiply(a, b), @azimuth.multiply(b, a))
  
  // åŠ æ³•ç»“åˆå¾‹
  @azimuth.assert_eq(@azimuth.add(@azimuth.add(a, b), c), @azimuth.add(a, @azimuth.add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹
  @azimuth.assert_eq(@azimuth.multiply(@azimuth.multiply(a, b), c), @azimuth.multiply(a, @azimuth.multiply(b, c)))
  
  // åˆ†é…å¾‹
  @azimuth.assert_eq(@azimuth.multiply(a, @azimuth.add(b, c)), @azimuth.add(@azimuth.multiply(a, b), @azimuth.multiply(a, c)))
}

test "real_world_currency_conversion" {
  // æµ‹è¯•å®é™…åº”ç”¨ï¼šè´§å¸è½¬æ¢
  let usd_amount = 100
  let exchange_rate = 7  // 1 USD = 7 CNY (ç®€åŒ–æ±‡ç‡)
  let fee_rate = 2  // 2% æ‰‹ç»­è´¹
  
  // è½¬æ¢ä¸ºäººæ°‘å¸
  let cny_amount = @azimuth.multiply(usd_amount, exchange_rate)
  @azimuth.assert_eq(700, cny_amount)
  
  // è®¡ç®—æ‰‹ç»­è´¹
  let fee = @azimuth.multiply(cny_amount, fee_rate) / 100
  @azimuth.assert_eq(14, fee)
  
  // è®¡ç®—æœ€ç»ˆé‡‘é¢
  let final_amount = @azimuth.add(cny_amount, -fee)
  @azimuth.assert_eq(686, final_amount)
  
  // åå‘è®¡ç®—éªŒè¯
  let reverse_usd = final_amount / exchange_rate
  @azimuth.assert_eq(98, reverse_usd)  // æ•´æ•°é™¤æ³•ï¼Œèˆå»å°æ•°éƒ¨åˆ†
}

test "error_boundary_handling" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œå¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let overflow_add = @azimuth.add(max_val, max_val)
  @azimuth.assert_eq(max_val, overflow_add)
  
  let underflow_add = @azimuth.add(min_val, min_val)
  @azimuth.assert_eq(min_val, underflow_add)
  
  let overflow_mul = @azimuth.multiply(max_val, max_val)
  @azimuth.assert_eq(max_val, overflow_mul)
  
  // æµ‹è¯•é™¤é›¶ä¿æŠ¤ï¼ˆé€šè¿‡æ¨¡æ‹Ÿï¼‰
  // ç”±äºæ²¡æœ‰é™¤æ³•å‡½æ•°ï¼Œæˆ‘ä»¬é€šè¿‡å…¶ä»–æ–¹å¼æµ‹è¯•é”™è¯¯å¤„ç†
  let zero_result = @azimuth.multiply(0, max_val)
  @azimuth.assert_eq(0, zero_result)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µä¸‹çš„ç‰¹æ®Šå¤„ç†
  let special_case = @azimuth.multiply(min_val, -1)
  @azimuth.assert_eq(min_val, special_case)
}

test "performance_calculation_patterns" {
  // æµ‹è¯•æ€§èƒ½è®¡ç®—æ¨¡å¼
  let base_value = 100
  let multiplier = 2
  let iterations = 10
  
  // æ¨¡æ‹Ÿå¾ªç¯ç´¯åŠ ï¼šbase_value + base_value*multiplier + ... + base_value*multiplier^iterations
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šbase_value * (multiplier^(iterations+1) - 1) / (multiplier - 1)
  
  // æ‰‹åŠ¨è®¡ç®—å‰å‡ é¡¹éªŒè¯
  let term1 = base_value  // 100
  let term2 = @azimuth.multiply(base_value, multiplier)  // 200
  let term3 = @azimuth.multiply(term2, multiplier)  // 400
  let term4 = @azimuth.multiply(term3, multiplier)  // 800
  
  let sum_first_4 = @azimuth.add(@azimuth.add(@azimuth.add(term1, term2), term3), term4)
  @azimuth.assert_eq(1500, sum_first_4)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„å’Œï¼ˆç®€åŒ–ç‰ˆï¼‰
  let power_of_2 = @azimuth.multiply(@azimuth.multiply(@azimuth.multiply(2, 2), 2), 2)  // 2^4 = 16
  let geometric_sum = @azimuth.multiply(base_value, power_of_2)
  @azimuth.assert_eq(1600, geometric_sum)
}

test "complex_formula_evaluation" {
  // æµ‹è¯•å¤æ‚å…¬å¼è¯„ä¼°
  // è®¡ç®—äºŒæ¬¡æ–¹ç¨‹ axÂ² + bx + c çš„å€¼
  let x = 7
  let a = 3
  let b = 5
  let c = 2
  
  // è®¡ç®— xÂ²
  let x_squared = @azimuth.multiply(x, x)  // 49
  
  // è®¡ç®— axÂ²
  let ax_squared = @azimuth.multiply(a, x_squared)  // 147
  
  // è®¡ç®— bx
  let bx = @azimuth.multiply(b, x)  // 35
  
  // è®¡ç®—æœ€ç»ˆç»“æœ
  let result = @azimuth.add(@azimuth.add(ax_squared, bx), c)  // 147 + 35 + 2 = 184
  @azimuth.assert_eq(184, result)
  
  // è®¡ç®—å¯¼æ•°å€¼ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š2ax + b
  let derivative = @azimuth.add(@azimuth.multiply(@azimuth.multiply(2, a), x), b)  // 2*3*7 + 5 = 47
  @azimuth.assert_eq(47, derivative)
}

test "data_type_boundary_simulation" {
  // æµ‹è¯•æ•°æ®ç±»å‹è¾¹ç•Œæ¨¡æ‹Ÿ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æ¨¡æ‹Ÿæœ‰ç¬¦å·æ•´æ•°æº¢å‡ºè¡Œä¸º
  let positive_to_negative = @azimuth.add(max_val, 1)
  @azimuth.assert_eq(max_val, positive_to_negative)  // åº”è¯¥è¢«é™åˆ¶
  
  let negative_to_positive = @azimuth.add(min_val, 1)
  @azimuth.assert_eq(-2147483647, negative_to_positive)
  
  // æ¨¡æ‹Ÿæ— ç¬¦å·æ•´æ•°è¡Œä¸ºï¼ˆé€šè¿‡åç§»ï¼‰
  let offset = 2147483647  // æœ€å¤§å€¼
  let unsigned_value = 100
  let signed_representation = @azimuth.add(unsigned_value, -offset)
  @azimuth.assert_eq(-2147483547, signed_representation)
  
  // æµ‹è¯•å­—ç¬¦ä¸²åˆ°æ•°å­—çš„æ¨¡æ‹Ÿè½¬æ¢
  let digit_string = "123"
  let simulated_number = @azimuth.add(@azimuth.add(100, 20), 3)  // æ¨¡æ‹Ÿ "123" è½¬æ¢ä¸ºæ•°å­—
  @azimuth.assert_eq(123, simulated_number)
}

// æ–°å¢çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "mathematical_commutativity_laws" {
  // éªŒè¯äº¤æ¢å¾‹ï¼ša + b = b + a å’Œ a * b = b * a
  let a = 17
  let b = 23
  let c = -5
  
  // åŠ æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.add(a, b), @azimuth.add(b, a))
  @azimuth.assert_eq(@azimuth.add(b, c), @azimuth.add(c, b))
  @azimuth.assert_eq(@azimuth.add(a, c), @azimuth.add(c, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.multiply(a, b), @azimuth.multiply(b, a))
  @azimuth.assert_eq(@azimuth.multiply(b, c), @azimuth.multiply(c, b))
  @azimuth.assert_eq(@azimuth.multiply(a, c), @azimuth.multiply(c, a))
}

test "mathematical_associativity_laws" {
  // éªŒè¯ç»“åˆå¾‹ï¼š(a + b) + c = a + (b + c) å’Œ (a * b) * c = a * (b * c)
  let a = 7
  let b = 11
  let c = 13
  
  // åŠ æ³•ç»“åˆå¾‹
  let add_left = @azimuth.add(@azimuth.add(a, b), c)
  let add_right = @azimuth.add(a, @azimuth.add(b, c))
  @azimuth.assert_eq(add_left, add_right)
  
  // ä¹˜æ³•ç»“åˆå¾‹
  let mul_left = @azimuth.multiply(@azimuth.multiply(a, b), c)
  let mul_right = @azimuth.multiply(a, @azimuth.multiply(b, c))
  @azimuth.assert_eq(mul_left, mul_right)
}

test "distributive_property_verification" {
  // éªŒè¯åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 6
  let b = 8
  let c = 12
  
  let left_side = @azimuth.multiply(a, @azimuth.add(b, c))
  let right_side = @azimuth.add(@azimuth.multiply(a, b), @azimuth.multiply(a, c))
  @azimuth.assert_eq(left_side, right_side)
}

test "divide_with_ceil_comprehensive_behavior" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¡Œä¸º
  // æ­£æ•°æƒ…å†µ
  @azimuth.assert_eq(4, @azimuth.divide_with_ceil(13, 4))  // 3.25 -> 4
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(12, 4))  // 3 -> 3
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(3, 5))   // 0.6 -> 1
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(1, 1))   // 1 -> 1
  
  // è´Ÿæ•°æƒ…å†µ
  @azimuth.assert_eq(-3, @azimuth.divide_with_ceil(-11, 4))  // -2.75 -> -3
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(-8, 4))   // -2 -> -2
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(-7, 4))   // -1.75 -> -2
  
  // æ··åˆç¬¦å·
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(7, -4))   // -1.75 -> -2
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(-7, -4))   // 1.75 -> 2
  
  // è¾¹ç•Œæƒ…å†µ
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 10))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(5, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 0))
}

test "identity_elements_properties" {
  // éªŒè¯å•ä½å…ƒæ€§è´¨ï¼ša + 0 = a å’Œ a * 1 = a
  let test_values = [0, 1, -1, 42, -17, 1000, -1000]
  
  for value in test_values {
    // åŠ æ³•å•ä½å…ƒ
    @azimuth.assert_eq(value, @azimuth.add(value, 0))
    @azimuth.assert_eq(value, @azimuth.add(0, value))
    
    // ä¹˜æ³•å•ä½å…ƒ
    @azimuth.assert_eq(value, @azimuth.multiply(value, 1))
    @azimuth.assert_eq(value, @azimuth.multiply(1, value))
  }
}

test "inverse_elements_properties" {
  // éªŒè¯é€†å…ƒæ€§è´¨ï¼ša + (-a) = 0
  let test_values = [1, -1, 42, -17, 1000, -1000, 2147483647, -2147483648]
  
  for value in test_values {
    let inverse = -value
    @azimuth.assert_eq(0, @azimuth.add(value, inverse))
  }
}

test "zero_element_properties" {
  // éªŒè¯é›¶å…ƒç´ æ€§è´¨ï¼ša * 0 = 0
  let test_values = [0, 1, -1, 42, -17, 1000, -1000, 2147483647, -2147483648]
  
  for value in test_values {
    @azimuth.assert_eq(0, @azimuth.multiply(value, 0))
    @azimuth.assert_eq(0, @azimuth.multiply(0, value))
  }
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—ï¼šè´·æ¬¾è®¡ç®—
  let principal = 100000  // æœ¬é‡‘
  let annual_rate = 6     // å¹´åˆ©ç‡6%
  let years = 10          // è´·æ¬¾å¹´é™
  
  // ç®€åŒ–çš„å•åˆ©è®¡ç®—ï¼ˆå®é™…åº”è¯¥æ˜¯å¤åˆ©ï¼‰
  let total_interest = @azimuth.divide_with_ceil(@azimuth.multiply(principal, annual_rate * years), 100)
  let total_payment = @azimuth.add(principal, total_interest)
  let monthly_payment = @azimuth.divide_with_ceil(total_payment, years * 12)
  
  @azimuth.assert_eq(60000, total_interest)
  @azimuth.assert_eq(160000, total_payment)
  @azimuth.assert_eq(1334, monthly_payment)  // å‘ä¸Šå–æ•´
}

test "scientific_computation_scenario" {
  // ç§‘å­¦è®¡ç®—åœºæ™¯ï¼šç‰©ç†å…¬å¼è®¡ç®—
  let mass = 100      // è´¨é‡ kg
  let acceleration = 9 // åŠ é€Ÿåº¦ m/sÂ²
  let distance = 50   // è·ç¦» m
  
  // è®¡ç®—åŠ›ï¼šF = m * a
  let force = @azimuth.multiply(mass, acceleration)
  
  // è®¡ç®—åŠŸï¼šW = F * d
  let work = @azimuth.multiply(force, distance)
  
  // è®¡ç®—åŠŸç‡ï¼ˆå‡è®¾æ—¶é—´ï¼‰ï¼šP = W / tï¼Œå‡è®¾ t = 10s
  let time = 10
  let power = @azimuth.divide_with_ceil(work, time)
  
  @azimuth.assert_eq(900, force)
  @azimuth.assert_eq(45000, work)
  @azimuth.assert_eq(4500, power)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’Œè¾¹ç•Œæƒ…å†µ
  @azimuth.assert_eq_string("Hello, !", @azimuth.greet(""))
  @azimuth.assert_eq_string("Hello,   !", @azimuth.greet("  "))
  @azimuth.assert_eq_string("Hello, \n\t\r!", @azimuth.greet("\n\t\r"))
  @azimuth.assert_eq_string("Hello, \\\"!'!", @azimuth.greet("\\\"!'"))
  @azimuth.assert_eq_string("Hello, ğŸ˜Š!", @azimuth.greet("ğŸ˜Š"))
  @azimuth.assert_eq_string("Hello, \u{1F600}!", @azimuth.greet("\u{1F600}"))  // Unicode grin face
  @azimuth.assert_eq_string("Hello, Î±Î²Î³!", @azimuth.greet("Î±Î²Î³"))
  @azimuth.assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", @azimuth.greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  @azimuth.assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", @azimuth.greet("ğŸŒğŸŒğŸŒ"))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit è´¨é‡æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•1: åŸºæœ¬ç®—æœ¯è¿ç®—çš„ç»„åˆæµ‹è¯•
test "quality_arithmetic_combination_operations" {
  // æµ‹è¯•å¤šç§ç®—æœ¯è¿ç®—çš„ç»„åˆä½¿ç”¨
  let x = 12
  let y = 8
  let z = 5
  
  // è®¡ç®— (x + y) * z
  let result1 = @azimuth.multiply(@azimuth.add(x, y), z)
  @azimuth.assert_eq(100, result1)  // (12 + 8) * 5 = 20 * 5 = 100
  
  // è®¡ç®— x * y + z
  let result2 = @azimuth.add(@azimuth.multiply(x, y), z)
  @azimuth.assert_eq(101, result2)  // 12 * 8 + 5 = 96 + 5 = 101
  
  // è®¡ç®— (x - y) * z (ä½¿ç”¨ add å®ç°å‡æ³•)
  let result3 = @azimuth.multiply(@azimuth.add(x, -y), z)
  @azimuth.assert_eq(20, result3)  // (12 - 8) * 5 = 4 * 5 = 20
}

// æµ‹è¯•2: å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
test "quality_divide_with_ceil_boundary_conditions" {
  // æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶ä¸‹çš„å‘ä¸Šå–æ•´é™¤æ³•
  
  // è¢«é™¤æ•°å°äºé™¤æ•°
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(3, 5))   // 3/5 = 0.6 -> 1
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(1, 100)) // 1/100 = 0.01 -> 1
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(99, 100)) // 99/100 = 0.99 -> 1
  
  // è¢«é™¤æ•°ç­‰äºé™¤æ•°
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(7, 7))
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(1, 1))
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(1000, 1000))
  
  // è¢«é™¤æ•°æ˜¯é™¤æ•°çš„å€æ•°
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(15, 5))   // 15/5 = 3 -> 3
  @azimuth.assert_eq(10, @azimuth.divide_with_ceil(100, 10)) // 100/10 = 10 -> 10
  @azimuth.assert_eq(7, @azimuth.divide_with_ceil(49, 7))   // 49/7 = 7 -> 7
}

// æµ‹è¯•3: è´Ÿæ•°è¿ç®—çš„å…¨é¢æµ‹è¯•
test "quality_comprehensive_negative_operations" {
  // æµ‹è¯•è´Ÿæ•°çš„å„ç§è¿ç®—æƒ…å†µ
  
  // è´Ÿæ•°åŠ æ³•
  @azimuth.assert_eq(-10, @azimuth.add(-3, -7))
  @azimuth.assert_eq(-5, @azimuth.add(-8, 3))
  @azimuth.assert_eq(0, @azimuth.add(-5, 5))
  @azimuth.assert_eq(5, @azimuth.add(-10, 15))
  
  // è´Ÿæ•°ä¹˜æ³•
  @azimuth.assert_eq(15, @azimuth.multiply(-3, -5))  // è´Ÿè´Ÿå¾—æ­£
  @azimuth.assert_eq(-15, @azimuth.multiply(3, -5))  // ä¸€è´Ÿä¸€è´Ÿå¾—è´Ÿ
  @azimuth.assert_eq(0, @azimuth.multiply(-5, 0))    // ä¹˜ä»¥é›¶
  
  // è´Ÿæ•°é™¤æ³•å‘ä¸Šå–æ•´
  @azimuth.assert_eq(-3, @azimuth.divide_with_ceil(-10, 3))   // -10/3 = -3.333... -> -3
  @azimuth.assert_eq(-4, @azimuth.divide_with_ceil(-11, 3))   // -11/3 = -3.666... -> -4
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(-9, -3))    // -9/-3 = 3 -> 3
  @azimuth.assert_eq(4, @azimuth.divide_with_ceil(-10, -3))   // -10/-3 = 3.333... -> 4
}

// æµ‹è¯•4: å­—ç¬¦ä¸²é—®å€™çš„å¤šè¯­è¨€æ”¯æŒ
test "quality_multilingual_greeting_support" {
  // æµ‹è¯•å¤šç§è¯­è¨€çš„é—®å€™åŠŸèƒ½
  
  // ä¸­æ–‡æµ‹è¯•
  @azimuth.assert_eq_string("Hello, ä¸–ç•Œ!", @azimuth.greet("ä¸–ç•Œ"))
  @azimuth.assert_eq_string("Hello, ä¸­å›½!", @azimuth.greet("ä¸­å›½"))
  @azimuth.assert_eq_string("Hello, åŒ—äº¬!", @azimuth.greet("åŒ—äº¬"))
  
  // æ¬§æ´²è¯­è¨€æµ‹è¯•
  @azimuth.assert_eq_string("Hello, EspaÃ±ol!", @azimuth.greet("EspaÃ±ol"))
  @azimuth.assert_eq_string("Hello, FranÃ§ais!", @azimuth.greet("FranÃ§ais"))
  @azimuth.assert_eq_string("Hello, Deutsch!", @azimuth.greet("Deutsch"))
  @azimuth.assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", @azimuth.greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  
  // ç‰¹æ®Šå­—ç¬¦å’Œç¬¦å·
  @azimuth.assert_eq_string("Hello, 123!", @azimuth.greet("123"))
  @azimuth.assert_eq_string("Hello, test@example.com!", @azimuth.greet("test@example.com"))
  @azimuth.assert_eq_string("Hello, A+B=C!", @azimuth.greet("A+B=C"))
  @azimuth.assert_eq_string("Hello, ğŸš€!", @azimuth.greet("ğŸš€"))
}

// æµ‹è¯•5: å®é™…ä¸šåŠ¡åœºæ™¯ - è®¢å•è®¡ç®—
test "quality_business_order_calculation" {
  // æ¨¡æ‹Ÿç”µå•†è®¢å•è®¡ç®—åœºæ™¯
  
  let product_price = 89
  let quantity = 4
  let tax_rate = 8  // 8%
  let shipping_cost = 15
  let discount = 20
  
  // è®¡ç®—å•†å“å°è®¡
  let subtotal = @azimuth.multiply(product_price, quantity)
  @azimuth.assert_eq(356, subtotal)  // 89 * 4 = 356
  
  // è®¡ç®—ç¨è´¹ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let tax = @azimuth.divide_with_ceil(@azimuth.multiply(subtotal, tax_rate), 100)
  @azimuth.assert_eq(29, tax)  // ceil(356 * 8 / 100) = ceil(28.48) = 29
  
  // è®¡ç®—æ€»ä»·ï¼ˆå«ç¨å’Œè¿è´¹ï¼‰
  let total_before_discount = @azimuth.add(@azimuth.add(subtotal, tax), shipping_cost)
  @azimuth.assert_eq(400, total_before_discount)  // 356 + 29 + 15 = 400
  
  // åº”ç”¨æŠ˜æ‰£
  let final_total = @azimuth.add(total_before_discount, -discount)
  @azimuth.assert_eq(380, final_total)  // 400 - 20 = 380
}

// æµ‹è¯•6: æ•°å­¦æ€§è´¨éªŒè¯
test "quality_mathematical_properties_verification" {
  // éªŒè¯åŸºæœ¬çš„æ•°å­¦æ€§è´¨
  
  let a = 7
  let b = 13
  let c = 5
  
  // åŠ æ³•äº¤æ¢å¾‹: a + b = b + a
  @azimuth.assert_eq(@azimuth.add(a, b), @azimuth.add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹: a * b = b * a
  @azimuth.assert_eq(@azimuth.multiply(a, b), @azimuth.multiply(b, a))
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  @azimuth.assert_eq(@azimuth.add(@azimuth.add(a, b), c), @azimuth.add(a, @azimuth.add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  @azimuth.assert_eq(@azimuth.multiply(@azimuth.multiply(a, b), c), @azimuth.multiply(a, @azimuth.multiply(b, c)))
  
  // åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let distributive_left = @azimuth.multiply(a, @azimuth.add(b, c))
  let distributive_right = @azimuth.add(@azimuth.multiply(a, b), @azimuth.multiply(a, c))
  @azimuth.assert_eq(distributive_left, distributive_right)
  
  // é›¶å…ƒç´ æ€§è´¨
  @azimuth.assert_eq(0, @azimuth.multiply(a, 0))  // a * 0 = 0
  @azimuth.assert_eq(a, @azimuth.add(a, 0))       // a + 0 = a
}

// æµ‹è¯•7: å¤§æ•°è¿ç®—æµ‹è¯•
test "quality_large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„ç¨³å®šæ€§å’Œå‡†ç¡®æ€§
  
  // å¤§æ•°åŠ æ³•
  let big_num1 = 1000000
  let big_num2 = 500000
  @azimuth.assert_eq(1500000, @azimuth.add(big_num1, big_num2))
  
  // å¤§æ•°ä¹˜æ³•
  let big_factor1 = 10000
  let big_factor2 = 100
  @azimuth.assert_eq(1000000, @azimuth.multiply(big_factor1, big_factor2))
  
  // å¤§æ•°é™¤æ³•å‘ä¸Šå–æ•´
  let large_dividend = 1000000
  let large_divisor = 3
  @azimuth.assert_eq(333334, @azimuth.divide_with_ceil(large_dividend, large_divisor))
  
  // ç»„åˆå¤§æ•°è¿ç®—
  let complex_result = @azimuth.add(@azimuth.multiply(1000, 1000), @azimuth.divide_with_ceil(999999, 1000))
  @azimuth.assert_eq(1001000, complex_result)  // 1000000 + 1000 = 1001000
}

// æµ‹è¯•8: é›¶å€¼å’Œç‰¹æ®Šæƒ…å†µå¤„ç†
test "quality_zero_and_special_cases_handling" {
  // æµ‹è¯•é›¶å€¼å’Œç‰¹æ®Šæƒ…å†µçš„å¤„ç†
  
  // ä¸é›¶çš„åŠ æ³•
  @azimuth.assert_eq(5, @azimuth.add(5, 0))
  @azimuth.assert_eq(-5, @azimuth.add(-5, 0))
  @azimuth.assert_eq(0, @azimuth.add(0, 0))
  
  // ä¸é›¶çš„ä¹˜æ³•
  @azimuth.assert_eq(0, @azimuth.multiply(5, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(0, 5))
  @azimuth.assert_eq(0, @azimuth.multiply(0, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(-5, 0))
  
  // é™¤æ•°ä¸ºé›¶çš„å®‰å…¨å¤„ç†
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(100, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(-100, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 0))
  
  // é›¶ä½œä¸ºè¢«é™¤æ•°
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 5))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 1))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 100))
}

// æµ‹è¯•9: å®é™…åº”ç”¨åœºæ™¯ - åŒ…è£…å’Œç‰©æµè®¡ç®—
test "quality_packaging_logistics_calculation" {
  // æ¨¡æ‹ŸåŒ…è£…å’Œç‰©æµè®¡ç®—åœºæ™¯
  
  // åœºæ™¯1: è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let total_items = 127
  let items_per_box = 15
  let boxes_needed = @azimuth.divide_with_ceil(total_items, items_per_box)
  @azimuth.assert_eq(9, boxes_needed)  // ceil(127/15) = ceil(8.466...) = 9
  
  // åœºæ™¯2: è®¡ç®—è¿è¾“è½¦è¾†éœ€æ±‚
  let total_weight = 2500
  let vehicle_capacity = 800
  let vehicles_needed = @azimuth.divide_with_ceil(total_weight, vehicle_capacity)
  @azimuth.assert_eq(4, vehicles_needed)  // ceil(2500/800) = ceil(3.125) = 4
  
  // åœºæ™¯3: è®¡ç®—ä»“åº“ç©ºé—´éœ€æ±‚
  let boxes_per_pallet = 4
  let total_pallets_needed = @azimuth.divide_with_ceil(boxes_needed, boxes_per_pallet)
  @azimuth.assert_eq(3, total_pallets_needed)  // ceil(9/4) = ceil(2.25) = 3
  
  // åœºæ™¯4: è®¡ç®—æ€»æˆæœ¬
  let box_cost = 5
  let vehicle_cost = 50
  let pallet_cost = 20
  let total_cost = @azimuth.add(@azimuth.add(@azimuth.multiply(boxes_needed, box_cost), 
                          @azimuth.multiply(vehicles_needed, vehicle_cost)),
                       @azimuth.multiply(total_pallets_needed, pallet_cost))
  @azimuth.assert_eq(305, total_cost)  // 9*5 + 4*50 + 3*20 = 45 + 200 + 60 = 305
}

// æµ‹è¯•10: å¤æ‚æ•°å­¦è¡¨è¾¾å¼è®¡ç®—
test "quality_complex_mathematical_expressions" {
  // æµ‹è¯•å¤æ‚æ•°å­¦è¡¨è¾¾å¼çš„è®¡ç®—
  
  let x = 10
  let y = 15
  let z = 8
  
  // è¡¨è¾¾å¼1: (x + y) * z - x / y
  let expr1 = @azimuth.add(@azimuth.multiply(@azimuth.add(x, y), z), -@azimuth.divide_with_ceil(x, y))
  @azimuth.assert_eq(199, expr1)  // (10 + 15) * 8 - ceil(10/15) = 25*8 - 1 = 200 - 1 = 199
  
  // è¡¨è¾¾å¼2: x * y + y * z - z * x
  let expr2 = @azimuth.add(@azimuth.add(@azimuth.multiply(x, y), @azimuth.multiply(y, z)), -@azimuth.multiply(z, x))
  @azimuth.assert_eq(190, expr2)  // 10*15 + 15*8 - 8*10 = 150 + 120 - 80 = 190
  
  // è¡¨è¾¾å¼3: (x + y + z) * 2
  let expr3 = @azimuth.multiply(@azimuth.add(@azimuth.add(x, y), z), 2)
  @azimuth.assert_eq(66, expr3)  // (10 + 15 + 8) * 2 = 33 * 2 = 66
  
  // è¡¨è¾¾å¼4: ceil(x * y / z) + ceil(y * z / x)
  let expr4 = @azimuth.add(@azimuth.divide_with_ceil(@azimuth.multiply(x, y), z), 
                  @azimuth.divide_with_ceil(@azimuth.multiply(y, z), x))
  @azimuth.assert_eq(31, expr4)  // ceil(10*15/8) + ceil(15*8/10) = ceil(150/8) + ceil(120/10) = 19 + 12 = 31
  
  // è¡¨è¾¾å¼5: å¤æ‚åµŒå¥—è¡¨è¾¾å¼
  let expr5 = @azimuth.divide_with_ceil(@azimuth.multiply(@azimuth.add(x, @azimuth.multiply(y, 2)), 3), 4)
  @azimuth.assert_eq(30, expr5)  // ceil((10 + 15*2) * 3 / 4) = ceil((10 + 30) * 3 / 4) = ceil(40*3/4) = ceil(120/4) = 30
}