// Azimuth é¡¹ç›® MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•åŸºæœ¬æ•°å­¦è¿ç®—å’Œå­—ç¬¦ä¸²å¤„ç†åŠŸèƒ½

test "string_with_special_characters" {
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²å¤„ç†
  @azimuth.assert_eq_string("Hello, @#$%^&*()!", @azimuth.greet("@#$%^&*()"))
  @azimuth.assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", @azimuth.greet("ä¸­æ–‡æµ‹è¯•"))
  @azimuth.assert_eq_string("Hello, Ã©mojiğŸš€!", @azimuth.greet("Ã©mojiğŸš€"))
  @azimuth.assert_eq_string("Hello,   spaced   !", @azimuth.greet("  spaced   "))
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰æ€§è´¨
  let a = 42
  let b = 17
  
  // åŠ æ³•æ’ç­‰å¼
  @azimuth.assert_eq(a, @azimuth.add(a, 0))
  @azimuth.assert_eq(a, @azimuth.add(0, a))
  
  // ä¹˜æ³•æ’ç­‰å¼
  @azimuth.assert_eq(a, @azimuth.multiply(a, 1))
  @azimuth.assert_eq(a, @azimuth.multiply(1, a))
  @azimuth.assert_eq(0, @azimuth.multiply(a, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(0, a))
}

test "complex_calculation_scenarios" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯
  // åœºæ™¯1ï¼šè®¡ç®—äºŒæ¬¡æ–¹ç¨‹ axÂ² + bx + c
  let x = 5
  let a = 2
  let b = 3
  let c = 7
  
  let x_squared = @azimuth.multiply(x, x)  // xÂ² = 25
  let ax_squared = @azimuth.multiply(a, x_squared)  // axÂ² = 50
  let bx = @azimuth.multiply(b, x)  // bx = 15
  let result = @azimuth.add(@azimuth.add(ax_squared, bx), c)  // axÂ² + bx + c = 72
  
  @azimuth.assert_eq(72, result)
}

test "financial_calculation_compound_interest" {
  // æµ‹è¯•å¤åˆ©è®¡ç®—åœºæ™¯
  let principal = 10000  // æœ¬é‡‘
  let rate = 5  // åˆ©ç‡ç™¾åˆ†æ¯”
  let years = 3  // å¹´æ•°
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼šæœ€ç»ˆé‡‘é¢ = æœ¬é‡‘ Ã— (1 + åˆ©ç‡ Ã— å¹´æ•°)
  let growth_factor = @azimuth.add(1, @azimuth.multiply(rate, years))  // 1 + 5Ã—3 = 16
  let final_amount = @azimuth.multiply(principal, growth_factor)  // 10000 Ã— 16 = 160000
  
  @azimuth.assert_eq(160000, final_amount)
}

test "geometry_calculations_rectangle" {
  // æµ‹è¯•å‡ ä½•è®¡ç®—ï¼šçŸ©å½¢
  let length = 12
  let width = 8
  
  // è®¡ç®—é¢ç§¯
  let area = @azimuth.multiply(length, width)
  @azimuth.assert_eq(96, area)
  
  // è®¡ç®—å‘¨é•¿
  let perimeter = @azimuth.add(@azimuth.multiply(2, length), @azimuth.multiply(2, width))
  @azimuth.assert_eq(40, perimeter)
  
  // è®¡ç®—å¯¹è§’çº¿é•¿åº¦ï¼ˆç®€åŒ–è®¡ç®—ï¼Œä¸ä½¿ç”¨å¹³æ–¹æ ¹ï¼‰
  let length_squared = @azimuth.multiply(length, length)  // 144
  let width_squared = @azimuth.multiply(width, width)    // 64
  let diagonal_squared = @azimuth.add(length_squared, width_squared)  // 208
  
  @azimuth.assert_eq(208, diagonal_squared)
}

test "temperature_conversion_celsius_fahrenheit" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢ï¼šæ‘„æ°åº¦è½¬åæ°åº¦
  // ç®€åŒ–å…¬å¼ï¼šF = C Ã— 2 + 30ï¼ˆé¿å…å°æ•°ï¼‰
  
  // æµ‹è¯•å¸¸è§æ¸©åº¦ç‚¹
  let freezing_celsius = 0    // å†°ç‚¹
  let freezing_fahrenheit = @azimuth.add(@azimuth.multiply(freezing_celsius, 2), 30)
  @azimuth.assert_eq(30, freezing_fahrenheit)
  
  let room_celsius = 20       // å®¤æ¸©
  let room_fahrenheit = @azimuth.add(@azimuth.multiply(room_celsius, 2), 30)
  @azimuth.assert_eq(70, room_fahrenheit)
  
  let boiling_celsius = 100   // æ²¸ç‚¹
  let boiling_fahrenheit = @azimuth.add(@azimuth.multiply(boiling_celsius, 2), 30)
  @azimuth.assert_eq(230, boiling_fahrenheit)
}

test "shopping_cart_total_calculation" {
  // æµ‹è¯•è´­ç‰©è½¦æ€»ä»·è®¡ç®—
  let item1_price = 299
  let item1_quantity = 2
  let item2_price = 199
  let item2_quantity = 3
  let item3_price = 99
  let item3_quantity = 1
  let shipping_fee = 15
  let discount = 50
  
  // è®¡ç®—æ¯ç§å•†å“æ€»ä»·
  let total1 = @azimuth.multiply(item1_price, item1_quantity)  // 598
  let total2 = @azimuth.multiply(item2_price, item2_quantity)  // 597
  let total3 = @azimuth.multiply(item3_price, item3_quantity)  // 99
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = @azimuth.add(@azimuth.add(total1, total2), total3)  // 1294
  
  // åº”ç”¨æŠ˜æ‰£å’Œè¿è´¹
  let final_total = @azimuth.add(@azimuth.add(subtotal, -discount), shipping_fee)  // 1259
  
  @azimuth.assert_eq(1259, final_total)
}

test "statistical_calculations_mean_median" {
  // æµ‹è¯•ç»Ÿè®¡è®¡ç®—ï¼šå¹³å‡å€¼å’Œä¸­ä½æ•°
  // æ•°æ®é›†ï¼š10, 20, 30, 40, 50, 60, 70
  
  // è®¡ç®—æ€»å’Œ
  let sum = @azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(10, 20), 30), 40), 50), 60), 70)
  @azimuth.assert_eq(280, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let count = 7
  let mean = sum / count
  @azimuth.assert_eq(40, mean)
  
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆå·²æ’åºæ•°æ®é›†çš„ä¸­é—´å€¼ï¼‰
  let median = 40
  @azimuth.assert_eq(median, median)
  
  // è®¡ç®—èŒƒå›´ï¼ˆæœ€å¤§å€¼ - æœ€å°å€¼ï¼‰
  let range = @azimuth.add(70, -10)
  @azimuth.assert_eq(60, range)
}

test "time_calculations_duration" {
  // æµ‹è¯•æ—¶é—´è®¡ç®—ï¼šæŒç»­æ—¶é—´
  let start_hour = 9   // 9:00 AM
  let start_minute = 30
  let end_hour = 14     // 2:00 PM
  let end_minute = 45
  
  // è½¬æ¢ä¸ºåˆ†é’Ÿæ•°
  let start_total = @azimuth.add(@azimuth.multiply(start_hour, 60), start_minute)  // 570
  let end_total = @azimuth.add(@azimuth.multiply(end_hour, 60), end_minute)        // 885
  
  // è®¡ç®—æŒç»­æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
  let duration = @azimuth.add(end_total, -start_total)  // 315åˆ†é’Ÿ = 5å°æ—¶15åˆ†é’Ÿ
  
  @azimuth.assert_eq(315, duration)
  
  // è½¬æ¢å›å°æ—¶å’Œåˆ†é’Ÿ
  let duration_hours = duration / 60  // 5
  let duration_minutes = duration % 60  // 15
  
  @azimuth.assert_eq(5, duration_hours)
  @azimuth.assert_eq(15, duration_minutes)
}

test "game_score_calculation_complex" {
  // æµ‹è¯•æ¸¸æˆå¾—åˆ†è®¡ç®—ï¼šå¤æ‚åœºæ™¯
  let base_score = 1000
  let level = 5
  let combo_multiplier = 3
  let time_bonus = 500
  let accuracy_penalty = 200
  let difficulty_bonus = 300
  
  // è®¡ç®—ç­‰çº§å¾—åˆ†
  let level_score = @azimuth.multiply(base_score, level)  // 5000
  
  // åº”ç”¨è¿å‡»å€æ•°
  let combo_score = @azimuth.multiply(level_score, combo_multiplier)  // 15000
  
  // åŠ æˆå’Œå‡åˆ†
  let with_time_bonus = @azimuth.add(combo_score, time_bonus)  // 15500
  let with_accuracy_penalty = @azimuth.add(with_time_bonus, -accuracy_penalty)  // 15300
  let final_score = @azimuth.add(with_accuracy_penalty, difficulty_bonus)  // 15600
  
  @azimuth.assert_eq(15600, final_score)
  
  // è®¡ç®—æ’åï¼ˆæ¯1000åˆ†ä¸€ä¸ªç­‰çº§ï¼‰
  let rank_level = final_score / 1000  // 15
  @azimuth.assert_eq(15, rank_level)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num1 = 1000000
  let large_num2 = 2000000
  
  // å¤§æ•°ç›¸åŠ 
  let sum_result = @azimuth.add(large_num1, large_num2)
  @azimuth.assert_eq(3000000, sum_result)
  
  // å¤§æ•°ç›¸ä¹˜
  let product_result = @azimuth.multiply(1000, 2000)
  @azimuth.assert_eq(2000000, product_result)
  
  // å¤§æ•°ä¸è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let large_sum = @azimuth.add(max_val, 1000000)
  @azimuth.assert_eq(max_val, large_sum)  // åº”è¯¥è¢«é™åˆ¶åœ¨æœ€å¤§å€¼
}

test "negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  let neg_num1 = -100
  let neg_num2 = -200
  let pos_num = 150
  
  // è´Ÿæ•°ç›¸åŠ 
  let neg_sum = @azimuth.add(neg_num1, neg_num2)
  @azimuth.assert_eq(-300, neg_sum)
  
  // æ­£è´Ÿæ•°ç›¸åŠ 
  let mixed_sum = @azimuth.add(neg_num1, pos_num)
  @azimuth.assert_eq(50, mixed_sum)
  
  // è´Ÿæ•°ç›¸ä¹˜
  let neg_product = @azimuth.multiply(neg_num1, neg_num2)
  @azimuth.assert_eq(20000, neg_product)
  
  // æ­£è´Ÿæ•°ç›¸ä¹˜
  let mixed_product = @azimuth.multiply(neg_num1, pos_num)
  @azimuth.assert_eq(-15000, mixed_product)
}

test "boundary_value_operations" {
  // æµ‹è¯•è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼è¿ç®—
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 1))
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, 2))
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, max_val))
  
  // æœ€å°å€¼è¿ç®—
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, -1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 2))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, -1))
  
  // è¾¹ç•Œå€¼ç»„åˆ
  @azimuth.assert_eq(-1, @azimuth.add(max_val, min_val))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 1))
}

test "string_processing_extreme" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„æç«¯æƒ…å†µ
  // ç©ºå­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, !", @azimuth.greet(""))
  
  // å•ä¸ªå­—ç¬¦
  @azimuth.assert_eq_string("Hello, A!", @azimuth.greet("A"))
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = "ThisIsAVeryLongStringThatContainsManyCharactersAndShouldStillWorkProperly"
  @azimuth.assert_eq_string("Hello, " + long_string + "!", @azimuth.greet(long_string))
  
  // åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  @azimuth.assert_eq_string("Hello, " + special_chars + "!", @azimuth.greet(special_chars))
  
  // åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_string = "æµ‹è¯•ä¸­æ–‡ğŸŒŸEmoji"
  @azimuth.assert_eq_string("Hello, " + unicode_string + "!", @azimuth.greet(unicode_string))
}

test "mathematical_properties_validation" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨éªŒè¯
  let a = 12
  let b = 8
  let c = 5
  
  // åŠ æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.add(a, b), @azimuth.add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.multiply(a, b), @azimuth.multiply(b, a))
  
  // åŠ æ³•ç»“åˆå¾‹
  @azimuth.assert_eq(@azimuth.add(@azimuth.add(a, b), c), @azimuth.add(a, @azimuth.add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹
  @azimuth.assert_eq(@azimuth.multiply(@azimuth.multiply(a, b), c), @azimuth.multiply(a, @azimuth.multiply(b, c)))
  
  // åˆ†é…å¾‹
  @azimuth.assert_eq(@azimuth.multiply(a, @azimuth.add(b, c)), @azimuth.add(@azimuth.multiply(a, b), @azimuth.multiply(a, c)))
}

test "real_world_currency_conversion" {
  // æµ‹è¯•å®é™…åº”ç”¨ï¼šè´§å¸è½¬æ¢
  let usd_amount = 100
  let exchange_rate = 7  // 1 USD = 7 CNY (ç®€åŒ–æ±‡ç‡)
  let fee_rate = 2  // 2% æ‰‹ç»­è´¹
  
  // è½¬æ¢ä¸ºäººæ°‘å¸
  let cny_amount = @azimuth.multiply(usd_amount, exchange_rate)
  @azimuth.assert_eq(700, cny_amount)
  
  // è®¡ç®—æ‰‹ç»­è´¹
  let fee = @azimuth.multiply(cny_amount, fee_rate) / 100
  @azimuth.assert_eq(14, fee)
  
  // è®¡ç®—æœ€ç»ˆé‡‘é¢
  let final_amount = @azimuth.add(cny_amount, -fee)
  @azimuth.assert_eq(686, final_amount)
  
  // åå‘è®¡ç®—éªŒè¯
  let reverse_usd = final_amount / exchange_rate
  @azimuth.assert_eq(98, reverse_usd)  // æ•´æ•°é™¤æ³•ï¼Œèˆå»å°æ•°éƒ¨åˆ†
}

test "error_boundary_handling" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œå¤„ç†
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let overflow_add = @azimuth.add(max_val, max_val)
  @azimuth.assert_eq(max_val, overflow_add)
  
  let underflow_add = @azimuth.add(min_val, min_val)
  @azimuth.assert_eq(min_val, underflow_add)
  
  let overflow_mul = @azimuth.multiply(max_val, max_val)
  @azimuth.assert_eq(max_val, overflow_mul)
  
  // æµ‹è¯•é™¤é›¶ä¿æŠ¤ï¼ˆé€šè¿‡æ¨¡æ‹Ÿï¼‰
  // ç”±äºæ²¡æœ‰é™¤æ³•å‡½æ•°ï¼Œæˆ‘ä»¬é€šè¿‡å…¶ä»–æ–¹å¼æµ‹è¯•é”™è¯¯å¤„ç†
  let zero_result = @azimuth.multiply(0, max_val)
  @azimuth.assert_eq(0, zero_result)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µä¸‹çš„ç‰¹æ®Šå¤„ç†
  let special_case = @azimuth.multiply(min_val, -1)
  @azimuth.assert_eq(min_val, special_case)
}

test "performance_calculation_patterns" {
  // æµ‹è¯•æ€§èƒ½è®¡ç®—æ¨¡å¼
  let base_value = 100
  let multiplier = 2
  let iterations = 10
  
  // æ¨¡æ‹Ÿå¾ªç¯ç´¯åŠ ï¼šbase_value + base_value*multiplier + ... + base_value*multiplier^iterations
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šbase_value * (multiplier^(iterations+1) - 1) / (multiplier - 1)
  
  // æ‰‹åŠ¨è®¡ç®—å‰å‡ é¡¹éªŒè¯
  let term1 = base_value  // 100
  let term2 = @azimuth.multiply(base_value, multiplier)  // 200
  let term3 = @azimuth.multiply(term2, multiplier)  // 400
  let term4 = @azimuth.multiply(term3, multiplier)  // 800
  
  let sum_first_4 = @azimuth.add(@azimuth.add(@azimuth.add(term1, term2), term3), term4)
  @azimuth.assert_eq(1500, sum_first_4)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„å’Œï¼ˆç®€åŒ–ç‰ˆï¼‰
  let power_of_2 = @azimuth.multiply(@azimuth.multiply(@azimuth.multiply(2, 2), 2), 2)  // 2^4 = 16
  let geometric_sum = @azimuth.multiply(base_value, power_of_2)
  @azimuth.assert_eq(1600, geometric_sum)
}

test "complex_formula_evaluation" {
  // æµ‹è¯•å¤æ‚å…¬å¼è¯„ä¼°
  // è®¡ç®—äºŒæ¬¡æ–¹ç¨‹ axÂ² + bx + c çš„å€¼
  let x = 7
  let a = 3
  let b = 5
  let c = 2
  
  // è®¡ç®— xÂ²
  let x_squared = @azimuth.multiply(x, x)  // 49
  
  // è®¡ç®— axÂ²
  let ax_squared = @azimuth.multiply(a, x_squared)  // 147
  
  // è®¡ç®— bx
  let bx = @azimuth.multiply(b, x)  // 35
  
  // è®¡ç®—æœ€ç»ˆç»“æœ
  let result = @azimuth.add(@azimuth.add(ax_squared, bx), c)  // 147 + 35 + 2 = 184
  @azimuth.assert_eq(184, result)
  
  // è®¡ç®—å¯¼æ•°å€¼ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š2ax + b
  let derivative = @azimuth.add(@azimuth.multiply(@azimuth.multiply(2, a), x), b)  // 2*3*7 + 5 = 47
  @azimuth.assert_eq(47, derivative)
}

test "data_type_boundary_simulation" {
  // æµ‹è¯•æ•°æ®ç±»å‹è¾¹ç•Œæ¨¡æ‹Ÿ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æ¨¡æ‹Ÿæœ‰ç¬¦å·æ•´æ•°æº¢å‡ºè¡Œä¸º
  let positive_to_negative = @azimuth.add(max_val, 1)
  @azimuth.assert_eq(max_val, positive_to_negative)  // åº”è¯¥è¢«é™åˆ¶
  
  let negative_to_positive = @azimuth.add(min_val, 1)
  @azimuth.assert_eq(-2147483647, negative_to_positive)
  
  // æ¨¡æ‹Ÿæ— ç¬¦å·æ•´æ•°è¡Œä¸ºï¼ˆé€šè¿‡åç§»ï¼‰
  let offset = 2147483647  // æœ€å¤§å€¼
  let unsigned_value = 100
  let signed_representation = @azimuth.add(unsigned_value, -offset)
  @azimuth.assert_eq(-2147483547, signed_representation)
  
  // æµ‹è¯•å­—ç¬¦ä¸²åˆ°æ•°å­—çš„æ¨¡æ‹Ÿè½¬æ¢
  let digit_string = "123"
  let simulated_number = @azimuth.add(@azimuth.add(100, 20), 3)  // æ¨¡æ‹Ÿ "123" è½¬æ¢ä¸ºæ•°å­—
  @azimuth.assert_eq(123, simulated_number)
}

// æ–°å¢çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "mathematical_commutativity_laws" {
  // éªŒè¯äº¤æ¢å¾‹ï¼ša + b = b + a å’Œ a * b = b * a
  let a = 17
  let b = 23
  let c = -5
  
  // åŠ æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.add(a, b), @azimuth.add(b, a))
  @azimuth.assert_eq(@azimuth.add(b, c), @azimuth.add(c, b))
  @azimuth.assert_eq(@azimuth.add(a, c), @azimuth.add(c, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  @azimuth.assert_eq(@azimuth.multiply(a, b), @azimuth.multiply(b, a))
  @azimuth.assert_eq(@azimuth.multiply(b, c), @azimuth.multiply(c, b))
  @azimuth.assert_eq(@azimuth.multiply(a, c), @azimuth.multiply(c, a))
}

test "mathematical_associativity_laws" {
  // éªŒè¯ç»“åˆå¾‹ï¼š(a + b) + c = a + (b + c) å’Œ (a * b) * c = a * (b * c)
  let a = 7
  let b = 11
  let c = 13
  
  // åŠ æ³•ç»“åˆå¾‹
  let add_left = @azimuth.add(@azimuth.add(a, b), c)
  let add_right = @azimuth.add(a, @azimuth.add(b, c))
  @azimuth.assert_eq(add_left, add_right)
  
  // ä¹˜æ³•ç»“åˆå¾‹
  let mul_left = @azimuth.multiply(@azimuth.multiply(a, b), c)
  let mul_right = @azimuth.multiply(a, @azimuth.multiply(b, c))
  @azimuth.assert_eq(mul_left, mul_right)
}

test "distributive_property_verification" {
  // éªŒè¯åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c
  let a = 6
  let b = 8
  let c = 12
  
  let left_side = @azimuth.multiply(a, @azimuth.add(b, c))
  let right_side = @azimuth.add(@azimuth.multiply(a, b), @azimuth.multiply(a, c))
  @azimuth.assert_eq(left_side, right_side)
}

test "divide_with_ceil_comprehensive_behavior" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¡Œä¸º
  // æ­£æ•°æƒ…å†µ
  @azimuth.assert_eq(4, @azimuth.divide_with_ceil(13, 4))  // 3.25 -> 4
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(12, 4))  // 3 -> 3
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(3, 5))   // 0.6 -> 1
  @azimuth.assert_eq(1, @azimuth.divide_with_ceil(1, 1))   // 1 -> 1
  
  // è´Ÿæ•°æƒ…å†µ
  @azimuth.assert_eq(-3, @azimuth.divide_with_ceil(-11, 4))  // -2.75 -> -3
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(-8, 4))   // -2 -> -2
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(-7, 4))   // -1.75 -> -2
  
  // æ··åˆç¬¦å·
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(7, -4))   // -1.75 -> -2
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(-7, -4))   // 1.75 -> 2
  
  // è¾¹ç•Œæƒ…å†µ
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 10))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(5, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 0))
}

test "identity_elements_properties" {
  // éªŒè¯å•ä½å…ƒæ€§è´¨ï¼ša + 0 = a å’Œ a * 1 = a
  let test_values = [0, 1, -1, 42, -17, 1000, -1000]
  
  for value in test_values {
    // åŠ æ³•å•ä½å…ƒ
    @azimuth.assert_eq(value, @azimuth.add(value, 0))
    @azimuth.assert_eq(value, @azimuth.add(0, value))
    
    // ä¹˜æ³•å•ä½å…ƒ
    @azimuth.assert_eq(value, @azimuth.multiply(value, 1))
    @azimuth.assert_eq(value, @azimuth.multiply(1, value))
  }
}

test "inverse_elements_properties" {
  // éªŒè¯é€†å…ƒæ€§è´¨ï¼ša + (-a) = 0
  let test_values = [1, -1, 42, -17, 1000, -1000, 2147483647, -2147483648]
  
  for value in test_values {
    let inverse = -value
    @azimuth.assert_eq(0, @azimuth.add(value, inverse))
  }
}

test "zero_element_properties" {
  // éªŒè¯é›¶å…ƒç´ æ€§è´¨ï¼ša * 0 = 0
  let test_values = [0, 1, -1, 42, -17, 1000, -1000, 2147483647, -2147483648]
  
  for value in test_values {
    @azimuth.assert_eq(0, @azimuth.multiply(value, 0))
    @azimuth.assert_eq(0, @azimuth.multiply(0, value))
  }
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—ï¼šè´·æ¬¾è®¡ç®—
  let principal = 100000  // æœ¬é‡‘
  let annual_rate = 6     // å¹´åˆ©ç‡6%
  let years = 10          // è´·æ¬¾å¹´é™
  
  // ç®€åŒ–çš„å•åˆ©è®¡ç®—ï¼ˆå®é™…åº”è¯¥æ˜¯å¤åˆ©ï¼‰
  let total_interest = @azimuth.divide_with_ceil(@azimuth.multiply(principal, annual_rate * years), 100)
  let total_payment = @azimuth.add(principal, total_interest)
  let monthly_payment = @azimuth.divide_with_ceil(total_payment, years * 12)
  
  @azimuth.assert_eq(60000, total_interest)
  @azimuth.assert_eq(160000, total_payment)
  @azimuth.assert_eq(1334, monthly_payment)  // å‘ä¸Šå–æ•´
}

test "scientific_computation_scenario" {
  // ç§‘å­¦è®¡ç®—åœºæ™¯ï¼šç‰©ç†å…¬å¼è®¡ç®—
  let mass = 100      // è´¨é‡ kg
  let acceleration = 9 // åŠ é€Ÿåº¦ m/sÂ²
  let distance = 50   // è·ç¦» m
  
  // è®¡ç®—åŠ›ï¼šF = m * a
  let force = @azimuth.multiply(mass, acceleration)
  
  // è®¡ç®—åŠŸï¼šW = F * d
  let work = @azimuth.multiply(force, distance)
  
  // è®¡ç®—åŠŸç‡ï¼ˆå‡è®¾æ—¶é—´ï¼‰ï¼šP = W / tï¼Œå‡è®¾ t = 10s
  let time = 10
  let power = @azimuth.divide_with_ceil(work, time)
  
  @azimuth.assert_eq(900, force)
  @azimuth.assert_eq(45000, work)
  @azimuth.assert_eq(4500, power)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’Œè¾¹ç•Œæƒ…å†µ
  @azimuth.assert_eq_string("Hello, !", @azimuth.greet(""))
  @azimuth.assert_eq_string("Hello,   !", @azimuth.greet("  "))
  @azimuth.assert_eq_string("Hello, \n\t\r!", @azimuth.greet("\n\t\r"))
  @azimuth.assert_eq_string("Hello, \\\"!'!", @azimuth.greet("\\\"!'"))
  @azimuth.assert_eq_string("Hello, ğŸ˜Š!", @azimuth.greet("ğŸ˜Š"))
  @azimuth.assert_eq_string("Hello, \u{1F600}!", @azimuth.greet("\u{1F600}"))  // Unicode grin face
  @azimuth.assert_eq_string("Hello, Î±Î²Î³!", @azimuth.greet("Î±Î²Î³"))
  @azimuth.assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", @azimuth.greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  @azimuth.assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", @azimuth.greet("ğŸŒğŸŒğŸŒ"))
}