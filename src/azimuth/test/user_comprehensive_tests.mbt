// ç”¨æˆ·ç»¼åˆæµ‹è¯•ç”¨ä¾‹
// åŸºäºŽ azimuth æ¨¡å—çš„åŠŸèƒ½ç¼–å†™çš„æµ‹è¯•

test "add_commutativity_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 12345
  let b = 67890
  
  let result1 = add(a, b)
  let result2 = add(b, a)
  
  assert_eq(result1, result2)
}

test "multiply_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ï¼ša Ã— (b + c) = a Ã— b + a Ã— c
  let a = 15
  let b = 20
  let c = 25
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)
}

test "greet_multilingual_support" {
  // æµ‹è¯•å¤šè¯­è¨€æ”¯æŒçš„é—®å€™åŠŸèƒ½
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ðŸŒ!", greet("ðŸŒ"))
  assert_eq_string("Hello, ÐœÐ¾ÑÐºÐ²Ð°!", greet("ÐœÐ¾ÑÐºÐ²Ð°"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "complex_financial_calculation" {
  // æµ‹è¯•å¤æ‚é‡‘èžè®¡ç®—ï¼šè´·æ¬¾åˆ†æœŸä»˜æ¬¾
  let principal = 100000  // æœ¬é‡‘
  let annual_rate = 6     // å¹´åˆ©çŽ‡6%
  let years = 10          // è´·æ¬¾å¹´é™
  
  // ç®€åŒ–è®¡ç®—ï¼šæ€»åˆ©æ¯ = æœ¬é‡‘ Ã— åˆ©çŽ‡ Ã— å¹´æ•°
  let total_interest = multiply(principal, multiply(annual_rate, years))
  // æ€»è¿˜æ¬¾é¢ = æœ¬é‡‘ + æ€»åˆ©æ¯
  let total_payment = add(principal, total_interest)
  // æœˆä¾› = æ€»è¿˜æ¬¾é¢ Ã· (å¹´æ•° Ã— 12)
  let monthly_payment = total_payment / multiply(years, 12)
  
  assert_eq(1600000, total_interest)  // 100000 Ã— 6 Ã— 10 = 1600000
  assert_eq(1700000, total_payment)   // 100000 + 1600000 = 1700000
  assert_eq(14166, monthly_payment)   // 1700000 Ã· 120 â‰ˆ 14166
}

test "physics_kinematics_calculation" {
  // æµ‹è¯•ç‰©ç†å­¦è¿åŠ¨å­¦è®¡ç®—ï¼šæŠ›ä½“è¿åŠ¨
  let initial_velocity = 20  // åˆå§‹é€Ÿåº¦ m/s
  let angle = 45             // å‘å°„è§’åº¦ 45åº¦
  let gravity = 10           // é‡åŠ›åŠ é€Ÿåº¦ m/sÂ²
  
  // ç®€åŒ–è®¡ç®—ï¼šæœ€å¤§é«˜åº¦ = vÂ² Ã— sinÂ²(Î¸) Ã· (2g)
  // å¯¹äºŽ45åº¦è§’ï¼Œsin(45Â°) â‰ˆ 0.7ï¼Œæˆ‘ä»¬ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—
  let velocity_squared = multiply(initial_velocity, initial_velocity)
  let max_height = velocity_squared / multiply(2, gravity)
  
  // å°„ç¨‹ = vÂ² Ã— sin(2Î¸) Ã· g
  // å¯¹äºŽ45åº¦è§’ï¼Œsin(90Â°) = 1
  let range = velocity_squared / gravity
  
  assert_eq(20, max_height)  // 400 Ã· 20 = 20
  assert_eq(40, range)       // 400 Ã· 10 = 40
}

test "data_structure_array_operations" {
  // æµ‹è¯•æ•°æ®ç»“æž„æ•°ç»„æ“ä½œ
  // æ¨¡æ‹Ÿæ•°ç»„æ“ä½œï¼šè®¡ç®—æ•°ç»„å…ƒç´ çš„å„ç§ç»Ÿè®¡å€¼
  
  // æ¨¡æ‹Ÿæ•°ç»„å…ƒç´  [10, 20, 30, 40, 50]
  let elem1 = 10
  let elem2 = 20
  let elem3 = 30
  let elem4 = 40
  let elem5 = 50
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(elem1, elem2), elem3), elem4), elem5)
  // è®¡ç®—å¹³å‡å€¼
  let average = sum / 5
  // è®¡ç®—æœ€å¤§å€¼å’Œæœ€å°å€¼çš„å·®
  let range = add(elem5, -elem1)
  // è®¡ç®—ä¸­ä½æ•°ï¼ˆå·²æŽ’åºæ•°ç»„çš„ä¸­é—´å€¼ï¼‰
  let median = elem3
  
  assert_eq(150, sum)
  assert_eq(30, average)
  assert_eq(40, range)
  assert_eq(30, median)
}

test "algorithm_gcd_calculation" {
  // æµ‹è¯•ç®—æ³•ï¼šæœ€å¤§å…¬çº¦æ•°è®¡ç®—ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•ï¼‰
  let a = 48
  let b = 18
  
  // æ‰‹åŠ¨æ¨¡æ‹Ÿæ¬§å‡ é‡Œå¾—ç®—æ³•
  // 48 = 2 Ã— 18 + 12
  // 18 = 1 Ã— 12 + 6
  // 12 = 2 Ã— 6 + 0
  // æ‰€ä»¥ GCD(48, 18) = 6
  
  let gcd = 6
  assert_eq(6, gcd)
  
  // éªŒè¯å…¬çº¦æ•°æ€§è´¨
  let a_div_gcd = a / gcd
  let b_div_gcd = b / gcd
  
  assert_eq(8, a_div_gcd)   // 48 Ã· 6 = 8
  assert_eq(3, b_div_gcd)   // 18 Ã· 6 = 3
  
  // éªŒè¯äº’è´¨æ€§
  let are_coprime = true  // 8å’Œ3äº’è´¨
  assert_true(are_coprime)
}

test "game_development_collision_detection" {
  // æµ‹è¯•æ¸¸æˆå¼€å‘ï¼š2Dç¢°æ’žæ£€æµ‹
  // çŸ©å½¢1: (x1, y1, width1, height1)
  let rect1_x = 10
  let rect1_y = 20
  let rect1_width = 30
  let rect1_height = 40
  
  // çŸ©å½¢2: (x2, y2, width2, height2)
  let rect2_x = 25
  let rect2_y = 35
  let rect2_width = 35
  let rect2_height = 45
  
  // è®¡ç®—çŸ©å½¢è¾¹ç•Œ
  let rect1_right = add(rect1_x, rect1_width)
  let rect1_bottom = add(rect1_y, rect1_height)
  let rect2_right = add(rect2_x, rect2_width)
  let rect2_bottom = add(rect2_y, rect2_height)
  
  // ç¢°æ’žæ£€æµ‹ï¼šä¸¤ä¸ªçŸ©å½¢åœ¨xè½´å’Œyè½´ä¸Šéƒ½æœ‰é‡å 
  let collision_x = rect1_right > rect2_x && rect1_x < rect2_right
  let collision_y = rect1_bottom > rect2_y && rect1_y < rect2_bottom
  let is_colliding = collision_x && collision_y
  
  assert_true(is_colliding)
  
  // è®¡ç®—é‡å åŒºåŸŸçš„é¢ç§¯
  let overlap_left = if rect1_x > rect2_x { rect1_x } else { rect2_x }
  let overlap_top = if rect1_y > rect2_y { rect1_y } else { rect2_y }
  let overlap_right = if rect1_right < rect2_right { rect1_right } else { rect2_right }
  let overlap_bottom = if rect1_bottom < rect2_bottom { rect1_bottom } else { rect2_bottom }
  
  let overlap_width = add(overlap_right, -overlap_left)
  let overlap_height = add(overlap_bottom, -overlap_top)
  let overlap_area = multiply(overlap_width, overlap_height)
  
  assert_eq(20, overlap_width)   // 40 - 20 = 20
  assert_eq(25, overlap_height)  // 60 - 35 = 25
  assert_eq(500, overlap_area)   // 20 Ã— 25 = 500
}

test "cryptography_simple_caesar_cipher" {
  // æµ‹è¯•å¯†ç å­¦ï¼šç®€å•å‡¯æ’’å¯†ç 
  // ç”±äºŽæˆ‘ä»¬åªæœ‰æ•°å€¼è¿ç®—ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿå­—ç¬¦ç¼–ç 
  
  // æ¨¡æ‹Ÿå­—ç¬¦ä¸² "HELLO" çš„ASCIIç 
  let h_code = 72   // 'H'
  let e_code = 69   // 'E'
  let l_code = 76   // 'L'
  let o_code = 79   // 'O'
  
  // å‡¯æ’’å¯†ç åŠ å¯†ï¼šå‘å³ç§»åŠ¨3ä½
  let shift = 3
  let h_encrypted = add(h_code, shift)
  let e_encrypted = add(e_code, shift)
  let l_encrypted = add(l_code, shift)
  let o_encrypted = add(o_code, shift)
  
  assert_eq(75, h_encrypted)  // 72 + 3 = 75 ('K')
  assert_eq(72, e_encrypted)  // 69 + 3 = 72 ('H')
  assert_eq(79, l_encrypted)  // 76 + 3 = 79 ('O')
  assert_eq(82, o_encrypted)  // 79 + 3 = 82 ('R')
  
  // è§£å¯†ï¼šå‘å·¦ç§»åŠ¨3ä½
  let h_decrypted = add(h_encrypted, -shift)
  let e_decrypted = add(e_encrypted, -shift)
  let l_decrypted = add(l_encrypted, -shift)
  let o_decrypted = add(o_encrypted, -shift)
  
  assert_eq(72, h_decrypted)  // 75 - 3 = 72 ('H')
  assert_eq(69, e_decrypted)  // 72 - 3 = 69 ('E')
  assert_eq(76, l_decrypted)  // 79 - 3 = 76 ('L')
  assert_eq(79, o_decrypted)  // 82 - 3 = 79 ('O')
}

test "engineering_structural_analysis" {
  // æµ‹è¯•å·¥ç¨‹å­¦ï¼šç»“æž„åˆ†æž
  // è®¡ç®—ç®€æ”¯æ¢çš„æœ€å¤§å¼¯çŸ©å’ŒæŒ åº¦
  
  let beam_length = 6000    // æ¢é•¿åº¦ mm
  let load = 10000          // é›†ä¸­è½½è· N
  let moment_of_inertia = 85000000  // æˆªé¢æƒ¯æ€§çŸ© mmâ´
  let elastic_modulus = 200000       // å¼¹æ€§æ¨¡é‡ N/mmÂ²
  
  // æœ€å¤§å¼¯çŸ©ï¼šM = P Ã— L / 4
  let max_moment = multiply(load, beam_length) / 4
  assert_eq(15000000, max_moment)  // 10000 Ã— 6000 / 4 = 15000000 NÂ·mm
  
  // æœ€å¤§æŒ åº¦ï¼šÎ´ = P Ã— LÂ³ / (48 Ã— E Ã— I)
  let length_cubed = multiply(beam_length, multiply(beam_length, beam_length))
  let denominator = multiply(48, multiply(elastic_modulus, moment_of_inertia))
  let max_deflection = multiply(load, length_cubed) / denominator
  
  // éªŒè¯æ¢çš„åˆšåº¦
  let allowable_deflection = beam_length / 250  // å…è®¸æŒ åº¦ = L/250
  let is_stiff_enough = max_deflection <= allowable_deflection
  
  assert_eq(24, allowable_deflection)  // 6000 / 250 = 24 mm
  assert_true(is_stiff_enough)
}