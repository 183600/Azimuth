// ç”¨æˆ·è‡ªå®šä¹‰ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º Azimuth é¡¹ç›®æ·»åŠ çš„8ä¸ªæ ‡å‡†æµ‹è¯•ç”¨ä¾‹

test "sequential_calculation_chain" {
  // æµ‹è¯•è¿ç»­è®¡ç®—é“¾ï¼š((a + b) * c - d) / e
  let a = 8
  let b = 12
  let c = 3
  let d = 15
  let e = 5
  
  // é€æ­¥è®¡ç®—
  let sum_ab = @azimuth.add(a, b)  // 8 + 12 = 20
  let product = @azimuth.multiply(sum_ab, c)  // 20 * 3 = 60
  let difference = @azimuth.add(product, -d)  // 60 - 15 = 45
  let result = difference / e  // 45 / 5 = 9
  
  @azimuth.assert_eq(9, result)
}

test "string_processing_with_unicode" {
  // æµ‹è¯•åŒ…å« Unicode å­—ç¬¦çš„å­—ç¬¦ä¸²å¤„ç†
  let chinese_name = "ææ˜"
  let japanese_name = "ç”°ä¸­"
  let emoji_name = "ğŸš€"
  let mixed_name = "User2023@æµ‹è¯•"
  
  @azimuth.assert_eq_string("Hello, ææ˜!", @azimuth.greet(chinese_name))
  @azimuth.assert_eq_string("Hello, ç”°ä¸­!", @azimuth.greet(japanese_name))
  @azimuth.assert_eq_string("Hello, ğŸš€!", @azimuth.greet(emoji_name))
  @azimuth.assert_eq_string("Hello, User2023@æµ‹è¯•!", @azimuth.greet(mixed_name))
}

test "mathematical_series_calculations" {
  // æµ‹è¯•æ•°å­¦çº§æ•°è®¡ç®—
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—å‰10é¡¹çš„å’Œï¼š1, 1, 2, 3, 5, 8, 13, 21, 34, 55
  let fib1 = 1
  let fib2 = 1
  let fib3 = 2
  let fib4 = 3
  let fib5 = 5
  let fib6 = 8
  let fib7 = 13
  let fib8 = 21
  let fib9 = 34
  let fib10 = 55
  
  let fib_sum = @azimuth.add(
    @azimuth.add(
      @azimuth.add(
        @azimuth.add(
          @azimuth.add(fib1, fib2),
          @azimuth.add(fib3, fib4)
        ),
        @azimuth.add(fib5, fib6)
      ),
      @azimuth.add(fib7, fib8)
    ),
    @azimuth.add(fib9, fib10)
  )
  
  @azimuth.assert_eq(143, fib_sum)
}

test "business_calculation_scenario" {
  // æµ‹è¯•ä¸šåŠ¡è®¡ç®—åœºæ™¯ï¼šè®¢å•æŠ˜æ‰£è®¡ç®—
  let item_price = 199
  let quantity = 5
  let discount_threshold = 500
  let discount_rate = 15
  let tax_rate = 8
  let shipping = 25
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = @azimuth.multiply(item_price, quantity)
  
  // è®¡ç®—æŠ˜æ‰£ï¼ˆå¦‚æœè¶…è¿‡é˜ˆå€¼ï¼‰
  let discount = if (subtotal > discount_threshold) {
    @azimuth.multiply(subtotal, discount_rate) / 100
  } else {
    0
  }
  
  // è®¡ç®—æŠ˜åä»·æ ¼
  let discounted_total = @azimuth.add(subtotal, -discount)
  
  // è®¡ç®—ç¨è´¹
  let tax = @azimuth.multiply(discounted_total, tax_rate) / 100
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·
  let final_total = @azimuth.add(@azimuth.add(discounted_total, tax), shipping)
  
  @azimuth.assert_eq(976, final_total)
}

test "extreme_boundary_combinations" {
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸æœ€å°å€¼çš„å„ç§è¿ç®—ç»„åˆ
  @azimuth.assert_eq(-1, @azimuth.add(max_val, min_val))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, -1))
  @azimuth.assert_eq(0, @azimuth.multiply(max_val, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(min_val, 0))
  
  // æµ‹è¯•è¿ç»­è¾¹ç•Œè¿ç®—
  let chain1 = @azimuth.add(@azimuth.multiply(max_val, 1), min_val)
  @azimuth.assert_eq(-1, chain1)
  
  let chain2 = @azimuth.multiply(@azimuth.add(min_val, 1), -1)
  @azimuth.assert_eq(2147483647, chain2)
}

test "scientific_calculations" {
  // æµ‹è¯•ç§‘å­¦è®¡ç®—åœºæ™¯
  // è®¡ç®—åŠ¨èƒ½ï¼šE = 1/2 * m * v^2
  let mass = 10
  let velocity = 15
  let kinetic_energy = @azimuth.multiply(mass, @azimuth.multiply(velocity, velocity)) / 2
  @azimuth.assert_eq(1125, kinetic_energy)
  
  // è®¡ç®—åŠ¿èƒ½ï¼šE = m * g * h (g ç®€åŒ–ä¸º 10)
  let height = 20
  let gravity = 10
  let potential_energy = @azimuth.multiply(@azimuth.multiply(mass, gravity), height)
  @azimuth.assert_eq(2000, potential_energy)
  
  // è®¡ç®—æ€»èƒ½é‡
  let total_energy = @azimuth.add(kinetic_energy, potential_energy)
  @azimuth.assert_eq(3125, total_energy)
}

test "data_structure_simulation" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ¨¡æ‹Ÿï¼šæ ˆæ“ä½œ
  // æ¨¡æ‹Ÿæ ˆçš„ push å’Œ pop æ“ä½œ
  let stack1 = 10
  let stack2 = @azimuth.add(stack1, 20)  // push 20
  let stack3 = @azimuth.add(stack2, 30)  // push 30
  let stack4 = @azimuth.add(stack3, 40)  // push 40
  
  // æ¨¡æ‹Ÿ pop æ“ä½œï¼ˆé€šè¿‡å‡æ³•ï¼‰
  let popped1 = @azimuth.add(stack4, -40)  // pop 40
  let popped2 = @azimuth.add(popped1, -30)  // pop 30
  let popped3 = @azimuth.add(popped2, -20)  // pop 20
  
  @azimuth.assert_eq(10, popped3)  // æœ€ç»ˆå‰©ä¸‹åˆå§‹å€¼
  
  // æµ‹è¯•é˜Ÿåˆ—æ“ä½œæ¨¡æ‹Ÿ
  let queue_front = 5
  let queue_rear = @azimuth.add(queue_front, 15)  // enqueue 15
  let queue_rear2 = @azimuth.add(queue_rear, 25)  // enqueue 25
  
  // æ¨¡æ‹Ÿ dequeue æ“ä½œ
  let dequeued = queue_front  // dequeue 5
  let new_front = @azimuth.add(queue_front, 15)  // æ–°çš„é˜Ÿå¤´
  
  @azimuth.assert_eq(20, new_front)
}

test "error_boundary_validation" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•ŒéªŒè¯
  let max_val = 2147483647
  let min_val = -2147483648
  
  // éªŒè¯æ–­è¨€å‡½æ•°çš„æ­£ç¡®æ€§
  @azimuth.assert_true(true)
  @azimuth.assert_false(false)
  @azimuth.assert_eq(100, 100)
  @azimuth.assert_eq_string("test", "test")
  
  // éªŒè¯æº¢å‡ºä¿æŠ¤æœºåˆ¶
  @azimuth.assert_true(@azimuth.add(max_val, 1) == max_val)
  @azimuth.assert_true(@azimuth.add(min_val, -1) == min_val)
  @azimuth.assert_true(@azimuth.multiply(max_val, 2) == max_val)
  @azimuth.assert_true(@azimuth.multiply(min_val, 2) == min_val)
  
  // éªŒè¯ divide_with_ceil å‡½æ•°
  @azimuth.assert_eq(5, @azimuth.divide_with_ceil(17, 4))
  @azimuth.assert_eq(4, @azimuth.divide_with_ceil(16, 4))
  @azimuth.assert_eq(-4, @azimuth.divide_with_ceil(-16, 4))
  @azimuth.assert_eq(-3, @azimuth.divide_with_ceil(-11, 4))
}