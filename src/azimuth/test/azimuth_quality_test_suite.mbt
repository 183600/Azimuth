// é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“æ ¸å¿ƒåŠŸèƒ½çš„æ ‡å‡†æµ‹è¯•

// å†…ç½®æµ‹è¯•å‡½æ•°
fn assert_eq(lhs : Int, rhs : Int) -> Unit {
  if lhs != rhs {
    @builtin.abort("Assertion failed")
  } else {
    ()
  }
}

fn assert_eq_string(lhs : String, rhs : String) -> Unit {
  if lhs != rhs {
    @builtin.abort("String assertion failed")
  } else {
    ()
  }
}

// æµ‹è¯•ç”¨çš„å‡½æ•°å®žçŽ°
fn add(a : Int, b : Int) -> Int {
  a + b
}

fn multiply(a : Int, b : Int) -> Int {
  a * b
}

fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

test "azimuth_core_addition_commutative" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  let a = 15
  let b = 27
  assert_eq(add(a, b), add(b, a))
  assert_eq(42, add(15, 27))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-3, -7))
}

test "azimuth_core_multiplication_identity" {
  // æµ‹è¯•ä¹˜æ³•å•ä½å…ƒå’Œäº¤æ¢å¾‹
  assert_eq(25, multiply(25, 1))
  assert_eq(0, multiply(100, 0))
  assert_eq(36, multiply(6, 6))
  assert_eq(-18, multiply(-3, 6))
  assert_eq(multiply(12, 8), multiply(8, 12))
}

test "azimuth_core_divide_ceil_precision" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(-3, divide_with_ceil(-10, 3))
}

test "azimuth_core_greet_functionality" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å„ç§æƒ…å†µ
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, User123!", greet("User123"))
  assert_eq_string("Hello, ðŸš€!", greet("ðŸš€"))
}

test "azimuth_core_business_calculation" {
  // æµ‹è¯•å®žé™…ä¸šåŠ¡è®¡ç®—åœºæ™¯
  let unit_price = 45
  let quantity = 8
  let shipping = 15
  let discount = 20
  
  let subtotal = multiply(unit_price, quantity)
  let total_before_discount = add(subtotal, shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(360, subtotal)
  assert_eq(375, total_before_discount)
  assert_eq(355, final_total)
}

test "azimuth_core_packaging_optimization" {
  // æµ‹è¯•åŒ…è£…ä¼˜åŒ–è®¡ç®—
  let total_items = 47
  let items_per_box = 12
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  
  assert_eq(4, boxes_needed)
  
  // æµ‹è¯•å‰©ä½™ç©ºé—´
  let total_capacity = multiply(boxes_needed, items_per_box)
  let unused_space = add(total_capacity, -total_items)
  assert_eq(1, unused_space)
}

test "azimuth_core_financial_projection" {
  // æµ‹è¯•è´¢åŠ¡é¢„æµ‹è®¡ç®—
  let monthly_revenue = 15000
  let growth_rate = 8
  let months = 6
  
  let total_revenue = multiply(monthly_revenue, months)
  let projected_growth = divide_with_ceil(multiply(total_revenue, growth_rate), 100)
  let projected_total = add(total_revenue, projected_growth)
  
  assert_eq(90000, total_revenue)
  assert_eq(7200, projected_growth)
  assert_eq(97200, projected_total)
}

test "azimuth_core_time_management" {
  // æµ‹è¯•æ—¶é—´ç®¡ç†è®¡ç®—
  let total_tasks = 67
  let tasks_per_day = 8
  let workdays_needed = divide_with_ceil(total_tasks, tasks_per_day)
  let total_hours = multiply(workdays_needed, 8)
  
  assert_eq(9, workdays_needed)
  assert_eq(72, total_hours)
}

test "azimuth_core_complex_expression" {
  // æµ‹è¯•å¤æ‚è¡¨è¾¾å¼è®¡ç®—
  let x = 12
  let y = 8
  let z = 5
  
  // è®¡ç®—ï¼š(x + y) * z - x / y
  let result = add(multiply(add(x, y), z), -divide_with_ceil(x, y))
  assert_eq(98, result)  // (12 + 8) * 5 - ceil(12/8) = 20 * 5 - 2 = 100 - 2 = 98
  
  // è®¡ç®—åµŒå¥—è¡¨è¾¾å¼
  let nested = divide_with_ceil(multiply(add(x, multiply(y, z)), 3), 4)
  assert_eq(39, nested)  // ceil((12 + 8*5) * 3 / 4) = ceil(52 * 3 / 4) = ceil(156/4) = 39
}