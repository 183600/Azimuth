// é¢å¤–çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•

// æµ‹è¯•ç”¨ä¾‹1: åŠ æ³•ç»“åˆå¾‹éªŒè¯
test "addition_associativity_law" {
  // éªŒè¯åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  let a = 123
  let b = 456
  let c = 789
  
  let left_assoc = @azimuth.add(@azimuth.add(a, b), c)
  let right_assoc = @azimuth.add(a, @azimuth.add(b, c))
  
  @azimuth.assert_eq(left_assoc, right_assoc)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„æƒ…å†µ
  let d = -100
  let e = 200
  let f = -150
  
  let left_assoc_neg = @azimuth.add(@azimuth.add(d, e), f)
  let right_assoc_neg = @azimuth.add(d, @azimuth.add(e, f))
  
  @azimuth.assert_eq(left_assoc_neg, right_assoc_neg)
}

// æµ‹è¯•ç”¨ä¾‹2: ä¹˜æ³•äº¤æ¢å¾‹éªŒè¯
test "multiplication_commutativity_law" {
  // éªŒè¯ä¹˜æ³•äº¤æ¢å¾‹: a * b = b * a
  let a = 24
  let b = 36
  
  let product_ab = @azimuth.multiply(a, b)
  let product_ba = @azimuth.multiply(b, a)
  
  @azimuth.assert_eq(product_ab, product_ba)
  
  // æµ‹è¯•åŒ…å«é›¶çš„æƒ…å†µ
  let c = 0
  let d = 12345
  
  let product_zero1 = @azimuth.multiply(c, d)
  let product_zero2 = @azimuth.multiply(d, c)
  
  @azimuth.assert_eq(product_zero1, product_zero2)
  @azimuth.assert_eq(0, product_zero1)
}

// æµ‹è¯•ç”¨ä¾‹3: å­—ç¬¦ä¸²å¤„ç†å¤šæ ·æ€§æµ‹è¯•
test "string_processing_diversity" {
  // æµ‹è¯•å„ç§å­—ç¬¦ä¸²å¤„ç†æƒ…å†µ
  // æµ‹è¯•æ•°å­—å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, 2023!", @azimuth.greet("2023"))
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, John Doe!", @azimuth.greet("John Doe"))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šç¬¦å·çš„å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, test@example.com!", @azimuth.greet("test@example.com"))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  @azimuth.assert_eq_string("Hello, ğŸŒ™!", @azimuth.greet("ğŸŒ™"))
  
  // æµ‹è¯•æ··åˆè¯­è¨€
  @azimuth.assert_eq_string("Hello, MoonBitæµ‹è¯•!", @azimuth.greet("MoonBitæµ‹è¯•"))
}

// æµ‹è¯•ç”¨ä¾‹4: æ•°å­¦è¿ç®—æ€§è´¨éªŒè¯
test "mathematical_operations_properties" {
  // éªŒè¯åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 7
  let b = 12
  let c = 8
  
  let left_side = @azimuth.multiply(a, @azimuth.add(b, c))
  let right_side = @azimuth.add(@azimuth.multiply(a, b), @azimuth.multiply(a, c))
  
  @azimuth.assert_eq(left_side, right_side)
  
  // éªŒè¯é›¶å…ƒç´ æ€§è´¨
  @azimuth.assert_eq(0, @azimuth.multiply(0, 99999))
  @azimuth.assert_eq(99999, @azimuth.add(0, 99999))
  
  // éªŒè¯å•ä½å…ƒç´ æ€§è´¨
  @azimuth.assert_eq(99999, @azimuth.multiply(1, 99999))
  @azimuth.assert_eq(99999, @azimuth.multiply(99999, 1))
}

// æµ‹è¯•ç”¨ä¾‹5: è¾¹ç•Œå€¼ç»¼åˆæµ‹è¯•
test "boundary_value_comprehensive" {
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•è¾¹ç•Œå€¼ä¸æ™®é€šå€¼çš„è¿ç®—
  @azimuth.assert_eq(2147483646, @azimuth.add(max_val, -1))
  @azimuth.assert_eq(-2147483647, @azimuth.add(min_val, 1))
  
  // æµ‹è¯•è¾¹ç•Œå€¼ä¹˜æ³•
  @azimuth.assert_eq(0, @azimuth.multiply(max_val, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(min_val, 0))
  
  // æµ‹è¯•è¾¹ç•Œå€¼ä¸1çš„è¿ç®—
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, 1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 1))
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 100))
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, -100))
  @azimuth.assert_eq(max_val, @azimuth.multiply(100000, 30000))
}

// æµ‹è¯•ç”¨ä¾‹6: å®é™…åº”ç”¨åœºæ™¯æµ‹è¯•
test "real_world_scenarios" {
  // åœºæ™¯1: è®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1_price = 299
  let item1_qty = 2
  let item2_price = 199
  let item2_qty = 3
  
  let subtotal1 = @azimuth.multiply(item1_price, item1_qty)
  let subtotal2 = @azimuth.multiply(item2_price, item2_qty)
  let total = @azimuth.add(subtotal1, subtotal2)
  
  @azimuth.assert_eq(1195, total)  // 299*2 + 199*3 = 598 + 597 = 1195
  
  // åœºæ™¯2: è®¡ç®—çŸ©å½¢å‘¨é•¿å’Œé¢ç§¯
  let length = 15
  let width = 8
  
  let perimeter = @azimuth.add(@azimuth.multiply(2, length), @azimuth.multiply(2, width))
  let area = @azimuth.multiply(length, width)
  
  @azimuth.assert_eq(46, perimeter)  // 2*(15+8) = 46
  @azimuth.assert_eq(120, area)      // 15*8 = 120
}

// æµ‹è¯•ç”¨ä¾‹7: é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
test "error_handling_and_edge_cases" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°
  @azimuth.assert_true(true)
  @azimuth.assert_false(false)
  
  // æµ‹è¯•æå€¼è¿ç®—çš„å®‰å…¨æ€§
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ç¡®ä¿æº¢å‡ºè¢«æ­£ç¡®å¤„ç†
  @azimuth.assert_true(@azimuth.add(max_val, 1) == max_val)
  @azimuth.assert_true(@azimuth.add(min_val, -1) == min_val)
  @azimuth.assert_true(@azimuth.multiply(max_val, 2) == max_val)
  @azimuth.assert_true(@azimuth.multiply(min_val, -1) == min_val)
  
  // æµ‹è¯•ç‰¹æ®Šå€¼çš„å¤„ç†
  @azimuth.assert_eq(0, @azimuth.multiply(0, min_val))
  @azimuth.assert_eq(0, @azimuth.multiply(0, max_val))
}

// æµ‹è¯•ç”¨ä¾‹8: å¤æ‚æ•°å­¦è®¡ç®—åœºæ™¯
test "complex_mathematical_calculations" {
  // è®¡ç®—: (a + b) * (c + d) - e * f
  let a = 10
  let b = 20
  let c = 5
  let d = 15
  let e = 8
  let f = 12
  
  let sum_ab = @azimuth.add(a, b)  // 30
  let sum_cd = @azimuth.add(c, d)  // 20
  let product_sums = @azimuth.multiply(sum_ab, sum_cd)  // 600
  let product_ef = @azimuth.multiply(e, f)  // 96
  let result = @azimuth.add(product_sums, -product_ef)  // 504
  
  @azimuth.assert_eq(504, result)
  
  // è®¡ç®—å¹³æ–¹å’Œ: aÂ² + bÂ²
  let x = 7
  let y = 24
  
  let x_squared = @azimuth.multiply(x, x)  // 49
  let y_squared = @azimuth.multiply(y, y)  // 576
  let sum_of_squares = @azimuth.add(x_squared, y_squared)  // 625
  
  @azimuth.assert_eq(625, sum_of_squares)
}

// æµ‹è¯•ç”¨ä¾‹9: æ€§èƒ½ç›¸å…³è®¡ç®—æµ‹è¯•
test "performance_related_calculations" {
  // æ¨¡æ‹Ÿå¤§é‡æ•°æ®çš„ç´¯åŠ è®¡ç®—
  // ä½¿ç”¨å…¬å¼: 1 + 2 + ... + n = n * (n + 1) / 2
  let n = 1000
  let expected_sum = @azimuth.multiply(n, @azimuth.add(n, 1)) / 2
  
  @azimuth.assert_eq(500500, expected_sum)
  
  // æ¨¡æ‹Ÿç­‰æ¯”æ•°åˆ—æ±‚å’Œ: a * (r^n - 1) / (r - 1)
  // ç®€åŒ–è®¡ç®—: 1 + 2 + 4 + 8 + 16 = 31
  let a = 1
  let r = 2
  let terms = 5
  
  let power_of_2 = @azimuth.multiply(@azimuth.multiply(2, 2), @azimuth.multiply(2, 2))  // 2^4 = 16
  let geometric_sum = @azimuth.add(a, power_of_2)  // ç®€åŒ–ä¸º 1 + 16 = 17
  
  // æ‰‹åŠ¨éªŒè¯å‰å‡ é¡¹
  let manual_sum = @azimuth.add(@azimuth.add(@azimuth.add(@azimuth.add(1, 2), 4), 8), 16)
  @azimuth.assert_eq(31, manual_sum)
}

// æµ‹è¯•ç”¨ä¾‹10: æ•°æ®ç±»å‹è½¬æ¢å’Œæ ¼å¼åŒ–
test "data_type_conversion_and_formatting" {
  // æ¨¡æ‹Ÿå„ç§æ•°æ®ç±»å‹çš„å­—ç¬¦ä¸²è¡¨ç¤º
  // æ¨¡æ‹Ÿæ•´æ•°åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢
  let year = 2024
  let year_str = "2024"
  
  @azimuth.assert_eq_string("Hello, 2024!", @azimuth.greet(year_str))
  
  // æ¨¡æ‹Ÿå¸ƒå°”å€¼çš„å­—ç¬¦ä¸²è¡¨ç¤º
  let bool_true_str = "true"
  let bool_false_str = "false"
  
  @azimuth.assert_eq_string("Hello, true!", @azimuth.greet(bool_true_str))
  @azimuth.assert_eq_string("Hello, false!", @azimuth.greet(bool_false_str))
  
  // æ¨¡æ‹Ÿæµ®ç‚¹æ•°çš„å­—ç¬¦ä¸²è¡¨ç¤ºï¼ˆç®€åŒ–ï¼‰
  let pi_str = "3.14159"
  let e_str = "2.71828"
  
  @azimuth.assert_eq_string("Hello, 3.14159!", @azimuth.greet(pi_str))
  @azimuth.assert_eq_string("Hello, 2.71828!", @azimuth.greet(e_str))
  
  // æ¨¡æ‹Ÿæ—¥æœŸæ—¶é—´çš„å­—ç¬¦ä¸²è¡¨ç¤º
  let date_time_str = "2024-01-15 14:30:00"
  
  @azimuth.assert_eq_string("Hello, 2024-01-15 14:30:00!", @azimuth.greet(date_time_str))
}