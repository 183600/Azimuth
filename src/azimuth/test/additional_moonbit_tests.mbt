// é¢å¤–çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth æ¨¡å—çš„æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

// å‡½æ•°å®šä¹‰
pub fn add(a : Int, b : Int) -> Int {
  // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœæœ‰ä¸€ä¸ªæ˜¯0ï¼Œç›´æ¥è¿”å›å¦ä¸€ä¸ª
  if a == 0 {
    return b
  }
  if b == 0 {
    return a
  }

  // å¤„ç†æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼ˆInt32çš„æœ€å°å€¼ï¼‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†ä¸€ä¸ªæ“ä½œæ•°æ˜¯æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ + è´Ÿæ•° = å¯èƒ½æº¢å‡º
    if b < 0 {
      return min_val
    }
    // æœ€å°å€¼ + éè´Ÿæ•° = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }
  if b == min_val {
    // è´Ÿæ•° + æœ€å°å€¼ = å¯èƒ½æº¢å‡º
    if a < 0 {
      return min_val
    }
    // éè´Ÿæ•° + æœ€å°å€¼ = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }

  // æ­£æ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥
  if a > 0 && b > 0 {
    // å¦‚æœ a > max_val - bï¼Œåˆ™ a + b ä¼šæº¢å‡º
    if a > max_val - b {
      return max_val
    }
  }

  // è´Ÿæ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥ï¼ˆæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼ï¼‰
  if a < 0 && b < 0 {
    // ä½¿ç”¨å‡æ³•æ£€æŸ¥ï¼ša < min_val - b
    // ç”±äºbæ˜¯è´Ÿæ•°ï¼Œmin_val - b = min_val + abs(b)
    if a < min_val - b {
      return min_val
    }
  }

  // å®‰å…¨åœ°è¿›è¡ŒåŠ æ³•è¿ç®—
  return a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  // å¸¸é‡å®šä¹‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†0çš„æƒ…å†µ
  if a == 0 || b == 0 {
    return 0
  }

  // å¤„ç†1çš„æƒ…å†µ
  if a == 1 {
    return b
  }
  if b == 1 {
    return a
  }

  // å¤„ç†-1çš„æƒ…å†µï¼ˆåŒ…æ‹¬æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼‰
  if a == -1 {
    // -2147483648 * -1 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if b == min_val { min_val } else { -b }
  }
  if b == -1 {
    // -1 * -2147483648 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if a == min_val { min_val } else { -a }
  }

  // å¤„ç†æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if b > 1 || b < -1 { min_val } else { a * b }
  }
  if b == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if a > 1 || a < -1 { min_val } else { a * b }
  }

  // æ£€æŸ¥æ­£è´Ÿå·
  let sign = if (a > 0 && b > 0) || (a < 0 && b < 0) { 1 } else { -1 }

  // å®‰å…¨åœ°è®¡ç®—ç»å¯¹å€¼ï¼Œæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼
  let abs_a = if a < 0 { -a } else { a }
  let abs_b = if b < 0 { -b } else { b }

  // ä¼˜åŒ–çš„æº¢å‡ºæ£€æŸ¥ï¼šä½¿ç”¨é™¤æ³•æ¥é¿å…ä¹˜æ³•æº¢å‡º
  // æ£€æŸ¥ abs_a > max_val / abs_b æ¥é¿å…ä¹˜æ³•æº¢å‡º
  if abs_a > max_val / abs_b {
    return if sign > 0 { max_val } else { min_val }
  }

  // å®‰å…¨åœ°è¿›è¡Œä¹˜æ³•è¿ç®—
  return a * b
}

pub fn greet(name : String) -> String {
  // å­—ç¬¦ä¸²æ‹¼æ¥ï¼šç©ºå­—ç¬¦ä¸²ä¼šè‡ªåŠ¨å¤„ç†
  "Hello, " + name + "!"
}

// è¾…åŠ©æ–­è¨€å‡½æ•°
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  if (expected == actual) {
    ()
  } else {
    let _ = 1 / 0
    ()
  }
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  if (expected == actual) {
    ()
  } else {
    let _ = 1 / 0
    ()
  }
}

pub fn assert_true(condition : Bool) -> Unit {
  if (condition) {
    ()
  } else {
    let _ = 1 / 0
    ()
  }
}

pub fn assert_false(condition : Bool) -> Unit {
  if (condition) {
    let _ = 1 / 0
    ()
  } else {
    ()
  }
}

test "add_function_commutativity" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 123
  let b = 456
  
  assert_eq(add(a, b), add(b, a))
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  let c = -789
  let d = 321
  
  assert_eq(add(c, d), add(d, c))
}

test "multiply_function_associativity" {
  // æµ‹è¯•ä¹˜æ³•ç»“åˆå¾‹ï¼š(a * b) * c = a * (b * c)
  let a = 2
  let b = 3
  let c = 4
  
  let result1 = multiply(multiply(a, b), c)
  let result2 = multiply(a, multiply(b, c))
  
  assert_eq(result1, result2)
}

test "mixed_operations" {
  // æµ‹è¯•æ··åˆè¿ç®—
  let a = 10
  let b = 5
  let c = 3
  
  // (a + b) * c
  let result1 = multiply(add(a, b), c)
  assert_eq(45, result1)
  
  // a * b + c
  let result2 = add(multiply(a, b), c)
  assert_eq(53, result2)
}

test "boundary_value_operations" {
  // æµ‹è¯•è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¾¹ç•Œå€¼ä¸1çš„è¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(min_val, add(min_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(min_val, multiply(min_val, 1))
  
  // è¾¹ç•Œå€¼ä¸-1çš„è¿ç®—
  assert_eq(2147483646, add(max_val, -1))
  assert_eq(min_val, multiply(min_val, -1))
}

test "string_with_unicode" {
  // æµ‹è¯•åŒ…å« Unicode å­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, ğŸ‰!", greet("ğŸ‰"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "financial_calculations" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000  // æœ¬é‡‘
  let rate = 5           // åˆ©ç‡ 5%
  let years = 3          // å¹´æ•°
  
  // ç®€å•åˆ©æ¯ï¼šæœ¬é‡‘ + (æœ¬é‡‘ * åˆ©ç‡ * å¹´æ•°)
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  
  assert_eq(160000, total)  // 10000 + (10000 * 5 * 3) = 160000
  
  // å¤åˆ©è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let compound_total = multiply(principal, add(1, multiply(rate, years)))
  assert_eq(160000, compound_total)
}

test "geometry_calculations" {
  // æµ‹è¯•å‡ ä½•è®¡ç®—
  let radius = 5
  
  // åœ†å‘¨é•¿ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š2 * Ï€ * r â‰ˆ 2 * 3 * r
  let circumference = multiply(multiply(2, 3), radius)
  assert_eq(30, circumference)
  
  // åœ†é¢ç§¯ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼šÏ€ * rÂ² â‰ˆ 3 * rÂ²
  let area = multiply(3, multiply(radius, radius))
  assert_eq(75, area)
  
  // çƒä½“ä½“ç§¯ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼š4/3 * Ï€ * rÂ³ â‰ˆ 4 * rÂ³
  let volume = multiply(4, multiply(radius, multiply(radius, radius)))
  assert_eq(500, volume)
}

test "temperature_conversion" {
  // æµ‹è¯•æ¸©åº¦è½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C * 9/5 + 32ï¼Œç®€åŒ–ä¸º F = C * 2 + 30
  
  // å†°ç‚¹ï¼š0Â°C = 30Â°Fï¼ˆç®€åŒ–ç‰ˆï¼‰
  let freezing_c = 0
  let freezing_f = add(multiply(freezing_c, 2), 30)
  assert_eq(30, freezing_f)
  
  // æ²¸ç‚¹ï¼š100Â°C = 230Â°Fï¼ˆç®€åŒ–ç‰ˆï¼‰
  let boiling_c = 100
  let boiling_f = add(multiply(boiling_c, 2), 30)
  assert_eq(230, boiling_f)
  
  // å®¤æ¸©ï¼š25Â°C = 80Â°Fï¼ˆç®€åŒ–ç‰ˆï¼‰
  let room_c = 25
  let room_f = add(multiply(room_c, 2), 30)
  assert_eq(80, room_f)
}

test "array_index_calculation" {
  // æµ‹è¯•æ•°ç»„ç´¢å¼•è®¡ç®—
  let row = 3
  let col = 4
  let width = 10
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•ï¼šindex = row * width + col
  let index = add(multiply(row, width), col)
  assert_eq(34, index)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let first_index = add(multiply(0, width), 0)
  assert_eq(0, first_index)
  
  let last_index = add(multiply(9, width), 9)
  assert_eq(99, last_index)
}

test "error_handling" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  assert_eq(max_val, add(max_val, 1))
  assert_eq(max_val, add(max_val, max_val))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(min_val, add(min_val, min_val))
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq_string("test", "test")
}