// Azimuth é¡¹ç›®æ–°å¢ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ï¼Œè¦†ç›–æ ¸å¿ƒåŠŸèƒ½å’Œæ–°çš„æµ‹è¯•åœºæ™¯

test "boundary_value_comprehensive" {
  // è¾¹ç•Œå€¼ç»¼åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸å„ç§å€¼çš„ç»„åˆ
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 0))
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, 1))
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, 1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(max_val, -1))
  
  // æµ‹è¯•æœ€å°å€¼ä¸å„ç§å€¼çš„ç»„åˆ
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, 0))
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, -1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 1))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, -1))
  
  // æµ‹è¯•æå€¼ä¹‹é—´çš„è¿ç®—
  @azimuth.assert_eq(-1, @azimuth.add(max_val, min_val))
  @azimuth.assert_eq(0, @azimuth.multiply(max_val, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(min_val, 0))
}

test "string_edge_cases" {
  // å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µæµ‹è¯•
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, !", @azimuth.greet(""))
  
  // æµ‹è¯•å•å­—ç¬¦
  @azimuth.assert_eq_string("Hello, A!", @azimuth.greet("A"))
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_string = "ThisIsAVeryLongStringForTestingPurposesWithVariousCharacters1234567890"
  @azimuth.assert_eq_string("Hello, " + long_string + "!", @azimuth.greet(long_string))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  @azimuth.assert_eq_string("Hello, @#$%^&*()!", @azimuth.greet("@#$%^&*()"))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  @azimuth.assert_eq_string("Hello, ğŸš€ğŸŒŸ!", @azimuth.greet("ğŸš€ğŸŒŸ"))
}

test "mathematical_series" {
  // æ•°å­¦çº§æ•°æµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼š1 + 2 + 3 + ... + n = n Ã— (n + 1) / 2
  let n = 100
  let arithmetic_sum = azimuth.multiply(n, azimuth.add(n, 1)) / 2
  @azimuth.assert_eq(5050, arithmetic_sum)?
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œï¼š1 + 2 + 4 + 8 + ... + 2^(n-1) = 2^n - 1
  // è®¡ç®—1 + 2 + 4 + 8 + 16 = 31
  let geometric_sum = azimuth.add(azimuth.add(azimuth.add(azimuth.add(1, 2), 4), 8), 16)
  @assertion.assert_eq(31, geometric_sum)?
  
  // è®¡ç®—å¹³æ–¹å’Œï¼š1Â² + 2Â² + 3Â² + ... + nÂ²
  // è®¡ç®—1Â² + 2Â² + 3Â² + 4Â² + 5Â² = 1 + 4 + 9 + 16 + 25 = 55
  let sum_of_squares = azimuth.add(azimuth.add(azimuth.add(azimuth.add(
    azimuth.multiply(1, 1), 
    azimuth.multiply(2, 2)), 
    azimuth.multiply(3, 3)), 
    azimuth.add(azimuth.multiply(4, 4), azimuth.multiply(5, 5)))
  @assertion.assert_eq(55, sum_of_squares)?
}

test "physics_simulation" {
  // ç‰©ç†æ¨¡æ‹Ÿæµ‹è¯•
  // è‡ªç”±è½ä½“è¿åŠ¨ï¼šh = vâ‚€t + 0.5gtÂ²ï¼ˆç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼‰
  let initial_velocity = 10  // åˆå§‹é€Ÿåº¦ m/s
  let time = 5              // æ—¶é—´ s
  let gravity = 10          // é‡åŠ›åŠ é€Ÿåº¦ m/sÂ²ï¼ˆç®€åŒ–ä¸º10ï¼‰
  
  // è®¡ç®—ä½ç§»ï¼šh = 10Ã—5 + 0.5Ã—10Ã—5Â² = 50 + 125 = 175
  let displacement = azimuth.add(
    azimuth.multiply(initial_velocity, time),
    azimuth.multiply(azimuth.multiply(5, gravity), azimuth.multiply(time, time)) / 10
  )
  @assertion.assert_eq(175, displacement)?
  
  // åŠ¨èƒ½è®¡ç®—ï¼šE = 0.5mvÂ²ï¼ˆç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼‰
  let mass = 10  // è´¨é‡ kg
  let velocity = 15  // é€Ÿåº¦ m/s
  
  // è®¡ç®—åŠ¨èƒ½ï¼šE = 0.5Ã—10Ã—15Â² = 5Ã—225 = 1125
  let kinetic_energy = azimuth.multiply(azimuth.multiply(mass, 5), azimuth.multiply(velocity, velocity)) / 10
  @assertion.assert_eq(1125, kinetic_energy)?
}

test "algorithm_complexity" {
  // ç®—æ³•å¤æ‚åº¦æµ‹è¯•
  // çº¿æ€§å¤æ‚åº¦ï¼šO(n) = n
  let n = 1000
  let linear_operations = n
  @assertion.assert_eq(1000, linear_operations)?
  
  // å¹³æ–¹å¤æ‚åº¦ï¼šO(nÂ²) = n Ã— n
  let quadratic_operations = azimuth.multiply(n, n)
  @assertion.assert_eq(1000000, quadratic_operations)?
  
  // å¯¹æ•°å¤æ‚åº¦ï¼ˆç®€åŒ–ï¼‰ï¼šO(log n) ä½¿ç”¨æ•´æ•°é™¤æ³•æ¨¡æ‹Ÿ
  let log_operations = 0
  let temp_n = n
  // ç®€åŒ–çš„å¯¹æ•°è®¡ç®—ï¼š1000 â†’ 500 â†’ 250 â†’ 125 â†’ 62 â†’ 31 â†’ 15 â†’ 7 â†’ 3 â†’ 1ï¼ˆçº¦10æ¬¡ï¼‰
  let log_approx = 10
  @assertion.assert_eq(10, log_approx)?
  
  // ç»„åˆå¤æ‚åº¦ï¼šO(n + nÂ²) = n + nÂ²
  let combined_operations = azimuth.add(n, azimuth.multiply(n, n))
  @assertion.assert_eq(1001000, combined_operations)?
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ•°ç»„ç´¢å¼•è®¡ç®—ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•
  let row = 3
  let col = 4
  let width = 10
  
  // è®¡ç®—ä¸€ç»´ç´¢å¼•ï¼šindex = row Ã— width + col
  let index = azimuth.add(azimuth.multiply(row, width), col)
  @assertion.assert_eq(34, index)?
  
  // é“¾è¡¨é•¿åº¦è®¡ç®—ï¼ˆç®€åŒ–ï¼‰
  let node_count = 5
  let list_length = node_count
  @assertion.assert_eq(5, list_length)?
  
  // æ ‘çš„é«˜åº¦è®¡ç®—ï¼ˆç®€åŒ–ï¼šå®Œå…¨äºŒå‰æ ‘ï¼‰
  let node_count_tree = 15
  // é«˜åº¦ = floor(log2(n)) + 1ï¼Œå¯¹äº15ä¸ªèŠ‚ç‚¹çš„å®Œå…¨äºŒå‰æ ‘ï¼Œé«˜åº¦ä¸º4
  let tree_height = 4
  @assertion.assert_eq(4, tree_height)?
  
  // å“ˆå¸Œè¡¨å®¹é‡è®¡ç®—ï¼ˆç®€åŒ–ï¼‰
  let load_factor = 75  // 75%
  let expected_elements = 100
  // å®¹é‡ = å…ƒç´ æ•°é‡ / è´Ÿè½½å› å­ Ã— 100
  let capacity = azimuth.multiply(expected_elements, 100) / load_factor
  @assertion.assert_eq(133, capacity)?
}

test "cryptography_simulation" {
  // å¯†ç å­¦æ¨¡æ‹Ÿæµ‹è¯•ï¼ˆç®€åŒ–ï¼‰
  // å‡¯æ’’å¯†ç ï¼šä½ç§»åŠ å¯†
  let plaintext = "HELLO"
  let shift = 3
  
  // ç®€åŒ–çš„å‡¯æ’’å¯†ç ï¼ˆä»…å¤„ç†å­—æ¯Hï¼‰
  let H_code = 72  // ASCIIç 
  let encrypted_H = azimuth.add(H_code, shift)
  @assertion.assert_eq(75, encrypted_H)?  // 'K'çš„ASCIIç 
  
  // ç®€å•çš„å“ˆå¸Œå‡½æ•°æ¨¡æ‹Ÿï¼šæ•°å­—æ±‚å’Œ
  let data1 = 123
  let data2 = 456
  let data3 = 789
  
  // è®¡ç®—æ•°å­—å„ä½ä¹‹å’Œ
  let sum1 = azimuth.add(azimuth.add(data1 / 100, (data1 / 10) % 10), data1 % 10)
  let sum2 = azimuth.add(azimuth.add(data2 / 100, (data2 / 10) % 10), data2 % 10)
  let sum3 = azimuth.add(azimuth.add(data3 / 100, (data3 / 10) % 10), data3 % 10)
  
  @assertion.assert_eq(6, sum1)?  // 1 + 2 + 3 = 6
  @assertion.assert_eq(15, sum2)? // 4 + 5 + 6 = 15
  @assertion.assert_eq(24, sum3)? // 7 + 8 + 9 = 24
  
  // ç»„åˆå“ˆå¸Œå€¼
  let combined_hash = azimuth.add(azimuth.add(sum1, sum2), sum3)
  @assertion.assert_eq(45, combined_hash)?
}

test "network_calculations" {
  // ç½‘ç»œè®¡ç®—æµ‹è¯•
  // å¸¦å®½è®¡ç®—ï¼šæ–‡ä»¶å¤§å° / ä¼ è¾“æ—¶é—´
  let file_size = 1048576  // 1MB = 1048576å­—èŠ‚
  let transfer_time = 10   // 10ç§’
  
  // è®¡ç®—å¸¦å®½ï¼š1048576 / 10 = 104857.6 å­—èŠ‚/ç§’ï¼ˆç®€åŒ–ä¸ºæ•´æ•°ï¼‰
  let bandwidth = file_size / transfer_time
  @assertion.assert_eq(104857, bandwidth)?
  
  // ç½‘ç»œå»¶è¿Ÿè®¡ç®—ï¼šä¼ æ’­æ—¶é—´ + å¤„ç†æ—¶é—´ + æ’é˜Ÿæ—¶é—´
  let propagation_time = 50   // 50ms
  let processing_time = 20    // 20ms
  let queueing_time = 30      // 30ms
  
  let total_latency = azimuth.add(azimuth.add(propagation_time, processing_time), queueing_time)
  @assertion.assert_eq(100, total_latency)?
  
  // æ•°æ®åŒ…ä¼ è¾“è®¡ç®—ï¼šæ•°æ®å¤§å° / åŒ…å¤§å°
  let data_size = 5000  // 5000å­—èŠ‚
  let packet_size = 1500  // 1500å­—èŠ‚/åŒ…
  
  // éœ€è¦çš„æ•°æ®åŒ…æ•°é‡ï¼š5000 / 1500 = 3.33ï¼ˆå‘ä¸Šå–æ•´ä¸º4ï¼‰
  let packet_count = azimuth.divide_with_ceil(data_size, packet_size)
  @assertion.assert_eq(4, packet_count)?
}

test "machine_learning_basics" {
  // æœºå™¨å­¦ä¹ åŸºç¡€æµ‹è¯•
  // çº¿æ€§å›å½’ï¼šy = wx + b
  let w = 2  // æƒé‡
  let x = 5  // è¾“å…¥
  let b = 3  // åç½®
  
  // è®¡ç®—è¾“å‡ºï¼šy = 2Ã—5 + 3 = 13
  let y = azimuth.add(azimuth.multiply(w, x), b)
  @assertion.assert_eq(13, y)?
  
  // å‡æ–¹è¯¯å·®è®¡ç®—ï¼šMSE = (1/n) Ã— Î£(y_pred - y_actual)Â²
  let y_pred1 = 10
  let y_actual1 = 12
  let y_pred2 = 15
  let y_actual2 = 14
  let y_pred3 = 20
  let y_actual3 = 18
  
  // è®¡ç®—è¯¯å·®å¹³æ–¹å’Œï¼š(10-12)Â² + (15-14)Â² + (20-18)Â² = 4 + 1 + 4 = 9
  let error1 = azimuth.multiply(azimuth.add(y_pred1, -y_actual1), azimuth.add(y_pred1, -y_actual1))
  let error2 = azimuth.multiply(azimuth.add(y_pred2, -y_actual2), azimuth.add(y_pred2, -y_actual2))
  let error3 = azimuth.multiply(azimuth.add(y_pred3, -y_actual3), azimuth.add(y_pred3, -y_actual3))
  let sum_squared_errors = azimuth.add(azimuth.add(error1, error2), error3)
  
  // è®¡ç®—å‡æ–¹è¯¯å·®ï¼š9 / 3 = 3
  let mse = sum_squared_errors / 3
  @assertion.assert_eq(3, mse)?
  
  // æ¢¯åº¦ä¸‹é™æ›´æ–°ï¼šw_new = w_old - learning_rate Ã— gradient
  let w_old = 5
  let learning_rate = 1
  let gradient = 2
  
  let w_new = azimuth.add(w_old, azimuth.multiply(-learning_rate, gradient))
  @assertion.assert_eq(3, w_new)?
}