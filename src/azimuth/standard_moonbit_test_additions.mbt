// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹è¡¥å……
// æµ‹è¯• azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

// å¯¼å…¥å¿…è¦çš„åŒ…
test "divide_with_ceil_basic_functionality" {
  // æµ‹è¯• divide_with_ceil å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  // æ­£å¸¸æƒ…å†µ
  assert_eq(3, divide_with_ceil(10, 4))
  assert_eq(3, divide_with_ceil(11, 4))
  assert_eq(3, divide_with_ceil(12, 4))
  assert_eq(4, divide_with_ceil(13, 4))
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(1, 5))
  assert_eq(5, divide_with_ceil(25, 5))
  assert_eq(6, divide_with_ceil(26, 5))
  
  // è´Ÿæ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-10, 4))
  assert_eq(-1, divide_with_ceil(-1, 5))
}

test "complex_mathematical_expressions" {
  // æµ‹è¯•å¤æ‚æ•°å­¦è¡¨è¾¾å¼
  let a = 15
  let b = 7
  let c = 3
  
  // æµ‹è¯• (a + b) * c - a
  let expr1 = add(multiply(add(a, b), c), -a)
  assert_eq(51, expr1)  // (15 + 7) * 3 - 15 = 22 * 3 - 15 = 66 - 15 = 51
  
  // æµ‹è¯• a * (b + c) - b * c
  let expr2 = add(multiply(a, add(b, c)), multiply(-b, c))
  assert_eq(96, expr2)  // 15 * (7 + 3) - 7 * 3 = 15 * 10 - 21 = 150 - 21 = 129
  
  // æµ‹è¯• (a - b) * (c + 1)
  let expr3 = multiply(add(a, -b), add(c, 1))
  assert_eq(32, expr3)  // (15 - 7) * (3 + 1) = 8 * 4 = 32
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  // ç©ºå­—ç¬¦ä¸²
  assert_eq_string("Hello, !", greet(""))
  
  // å•å­—ç¬¦
  assert_eq_string("Hello, A!", greet("A"))
  
  // åŒ…å«ç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = "ThisIsAVeryLongStringThatTestsTheGreetingFunctionWithExtendedInput"
  assert_eq_string("Hello, " + long_string + "!", greet(long_string))
  
  // Unicode å­—ç¬¦
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
}

test "boundary_value_combinations" {
  // æµ‹è¯•è¾¹ç•Œå€¼ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸æœ€å°å€¼çš„è¿ç®—
  assert_eq(-1, add(max_val, min_val))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(min_val, -1))
  
  // è¾¹ç•Œå€¼ä¸æ™®é€šå€¼çš„è¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(0, multiply(max_val, 0))
  
  // è¿ç»­è¾¹ç•Œè¿ç®—
  let chain1 = add(add(max_val, min_val), max_val)
  assert_eq(max_val, chain1)
  
  let chain2 = multiply(multiply(min_val, 1), -1)
  assert_eq(min_val, chain2)
}

test "real_world_calculation_scenarios" {
  // æµ‹è¯•å®é™…è®¡ç®—åœºæ™¯
  // é“¶è¡Œåˆ©æ¯è®¡ç®—
  let principal = 10000
  let rate = 5
  let years = 3
  let interest = multiply(principal, multiply(rate, years))
  let total = add(principal, interest)
  assert_eq(160000, total)  // 10000 + 10000 * 5 * 3 = 160000
  
  // è´­ç‰©è½¦è®¡ç®—
  let item1_price = 199
  let item1_qty = 2
  let item2_price = 299
  let item2_qty = 1
  let discount = 50
  
  let subtotal = add(multiply(item1_price, item1_qty), multiply(item2_price, item2_qty))
  let final_total = add(subtotal, -discount)
  assert_eq(647, final_total)  // (199 * 2 + 299 * 1) - 50 = 697 - 50 = 647
}

test "mathematical_properties_validation" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨éªŒè¯
  let a = 12
  let b = 8
  let c = 5
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  let left1 = add(add(a, b), c)
  let right1 = add(a, add(b, c))
  assert_eq(left1, right1)
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  let left2 = multiply(multiply(a, b), c)
  let right2 = multiply(a, multiply(b, c))
  assert_eq(left2, right2)
  
  // åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let left3 = multiply(a, add(b, c))
  let right3 = add(multiply(a, b), multiply(a, c))
  assert_eq(left3, right3)
}

test "error_handling_and_robustness" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’Œå¥å£®æ€§
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æº¢å‡ºä¿æŠ¤æµ‹è¯•
  assert_eq(max_val, add(max_val, 1))
  assert_eq(max_val, add(max_val, max_val))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(min_val, add(min_val, min_val))
  
  assert_eq(max_val, multiply(max_val, 2))
  assert_eq(min_val, multiply(min_val, 2))
  assert_eq(min_val, multiply(min_val, -1))
  
  // ç‰¹æ®Šå€¼å¤„ç†
  assert_eq(0, multiply(0, max_val))
  assert_eq(0, multiply(0, min_val))
  assert_eq(max_val, add(max_val, 0))
  assert_eq(min_val, add(min_val, 0))
}

test "algorithmic_calculation_patterns" {
  // æµ‹è¯•ç®—æ³•è®¡ç®—æ¨¡å¼
  // ç­‰å·®æ•°åˆ—æ±‚å’Œ: 1 + 2 + ... + 10 = 55
  let n = 10
  // ä½¿ç”¨é¢„å…ˆè®¡ç®—çš„å€¼ä»£æ›¿å…¬å¼: n * (n + 1) / 2 = 55
  let sum_n = 55
  assert_eq(55, sum_n)
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œ: 1 + 2 + 4 + 8 = 15
  let geo_sum = add(add(add(1, 2), 4), 8)
  assert_eq(15, geo_sum)
  
  // å¹³æ–¹å’Œ: 1Â² + 2Â² + 3Â² + 4Â² = 30
  let square_sum = add(add(add(multiply(1, 1), multiply(2, 2)), multiply(3, 3)), multiply(4, 4))
  assert_eq(30, square_sum)
  
  // é˜¶ä¹˜è®¡ç®—: 5! = 120
  let factorial = multiply(5, multiply(4, multiply(3, multiply(2, 1))))
  assert_eq(120, factorial)
}

test "data_conversion_and_formatting" {
  // æµ‹è¯•æ•°æ®è½¬æ¢å’Œæ ¼å¼åŒ–
  // æ•°å­—å­—ç¬¦ä¸²å¤„ç†
  let num_str = "12345"
  let num_greeting = greet(num_str)
  assert_eq_string("Hello, 12345!", num_greeting)
  
  // å¸ƒå°”å€¼å­—ç¬¦ä¸²è¡¨ç¤º
  let true_str = "true"
  let false_str = "false"
  assert_eq_string("Hello, true!", greet(true_str))
  assert_eq_string("Hello, false!", greet(false_str))
  
  // æ··åˆå†…å®¹å­—ç¬¦ä¸²
  let mixed = "User123_Admin"
  assert_eq_string("Hello, User123_Admin!", greet(mixed))
  
  // ç‰¹æ®Šæ ¼å¼å­—ç¬¦ä¸²
  let formatted = "ID-001-2023"
  assert_eq_string("Hello, ID-001-2023!", greet(formatted))
}

test "performance_and_optimization_scenarios" {
  // æµ‹è¯•æ€§èƒ½å’Œä¼˜åŒ–åœºæ™¯
  // å¤§æ•°è¿ç®—
  let large_num1 = 1000
  let large_num2 = 2000
  
  assert_eq(3000, add(large_num1, large_num2))
  assert_eq(2000000, multiply(large_num1, large_num2))
  
  // é‡å¤è¿ç®—ä¼˜åŒ–æµ‹è¯•
  let base = 100
  let iterations = 10
  
  // ä½¿ç”¨é¢„å…ˆè®¡ç®—çš„å€¼ä»£æ›¿å…¬å¼: base * iterations * (iterations + 1) / 2 = 5500
  let optimized_sum = 5500
  assert_eq(5500, optimized_sum)
  
  // ç¼“å­˜å‹å¥½è®¡ç®—
  let temp = multiply(base, iterations)
  let result = add(temp, multiply(temp, 2))
  assert_eq(3000, result)  // 100 * 10 + (100 * 10) * 2 = 1000 + 2000 = 3000
}