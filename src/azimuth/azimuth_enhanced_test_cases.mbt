// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ ‡å‡†MoonBitæµ‹è¯•è¯­æ³•
// åŒ…å«8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–è¾¹ç•Œæƒ…å†µå’Œå®é™…åº”ç”¨åœºæ™¯

test "add_function_overflow_boundary" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„æº¢å‡ºè¾¹ç•Œ
  assert_eq(2147483646, add(2147483645, 1))
  assert_eq(-2147483647, add(-2147483646, -1))
  assert_eq(0, add(2147483647, -2147483647))
}

test "multiply_function_power_operations" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„å¹‚è¿ç®—åœºæ™¯
  assert_eq(1, multiply(1, 1))
  assert_eq(256, multiply(16, 16))
  assert_eq(1024, multiply(32, 32))
  assert_eq(-1024, multiply(-32, 32))
}

test "divide_with_ceil_precision_edge" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦è¾¹ç•Œ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(100, divide_with_ceil(9999, 100))
  assert_eq(-99, divide_with_ceil(-987, 10))
}

test "greet_function_multilingual_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å¤šè¯­è¨€æ”¯æŒ
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate = 5
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate), 100))
  
  assert_eq(10500, year1)
  assert_eq(11025, year2)
  assert_eq(11576, year3)
}

test "inventory_optimization_problem" {
  // åº“å­˜ä¼˜åŒ–é—®é¢˜
  let products = [(25, 8), (47, 12), (156, 20)]
  
  let boxes_1 = divide_with_ceil(products[0].0, products[0].1)
  let boxes_2 = divide_with_ceil(products[1].0, products[1].1)
  let boxes_3 = divide_with_ceil(products[2].0, products[2].1)
  
  let total_boxes = add(add(boxes_1, boxes_2), boxes_3)
  assert_eq(16, total_boxes)
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿ
  let input_size = 1000
  
  // O(n) çº¿æ€§ç®—æ³•
  let linear_ops = multiply(input_size, 3)
  
  // O(log n) å¯¹æ•°ç®—æ³•ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let log_ops = divide_with_ceil(input_size, 100)
  
  // éªŒè¯å¤æ‚åº¦å·®å¼‚
  let ratio = divide_with_ceil(linear_ops, log_ops)
  assert_eq(30, ratio)
}

test "resource_allocation_scenario" {
  // èµ„æºåˆ†é…åœºæ™¯
  let total_budget = 5000
  let projects = [1200, 800, 1500, 1000]
  
  let project_1 = projects[0]
  let project_2 = projects[1]
  let project_3 = projects[2]
  let project_4 = projects[3]
  
  let total_spent = add(add(add(project_1, project_2), project_3), project_4)
  let remaining = add(total_budget, -total_spent)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡
  let small_projects = divide_with_ceil(remaining, 300)
  
  assert_eq(4500, total_spent)
  assert_eq(500, remaining)
  assert_eq(2, small_projects)
}