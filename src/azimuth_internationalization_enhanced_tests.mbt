// Azimuth Telemetry System - Enhanced Internationalization Tests
// This file contains test cases for internationalization and localization support

// Test 1: Multi-language Error Messages
test "multi-language error message support" {
  // Create an internationalization manager
  let i18n = I18nManager::new()
  
  // Add translations for different languages
  I18nManager::add_translation(i18n, "en", "error.connection_failed", "Connection failed")
  I18nManager::add_translation(i18n, "zh", "error.connection_failed", "è¿æ¥å¤±è´¥")
  I18nManager::add_translation(i18n, "es", "error.connection_failed", "ConexiÃ³n fallida")
  I18nManager::add_translation(i18n, "fr", "error.connection_failed", "Connexion Ã©chouÃ©e")
  
  // Test English translation
  let en_message = I18nManager::get_message(i18n, "en", "error.connection_failed")
  match en_message {
    Some(msg) => assert_eq(msg, "Connection failed")
    None => assert_true(false)
  }
  
  // Test Chinese translation
  let zh_message = I18nManager::get_message(i18n, "zh", "error.connection_failed")
  match zh_message {
    Some(msg) => assert_eq(msg, "è¿æ¥å¤±è´¥")
    None => assert_true(false)
  }
  
  // Test Spanish translation
  let es_message = I18nManager::get_message(i18n, "es", "error.connection_failed")
  match es_message {
    Some(msg) => assert_eq(msg, "ConexiÃ³n fallida")
    None => assert_true(false)
  }
  
  // Test French translation
  let fr_message = I18nManager::get_message(i18n, "fr", "error.connection_failed")
  match fr_message {
    Some(msg) => assert_eq(msg, "Connexion Ã©chouÃ©e")
    None => assert_true(false)
  }
  
  // Test fallback to default language for missing translation
  let missing_message = I18nManager::get_message(i18n, "de", "error.connection_failed")
  match missing_message {
    Some(msg) => assert_eq(msg, "Connection failed") // Should fallback to English
    None => assert_true(false)
  }
}

// Test 2: Localized Date and Time Formatting
test "localized date and time formatting" {
  // Create a date formatter
  let formatter = DateFormatter::new()
  
  // Test timestamp
  let timestamp = 1609459200L // 2021-01-01 00:00:00 UTC
  
  // Test different locale formats
  let us_format = DateFormatter::format(formatter, timestamp, "en-US")
  assert_eq(us_format, "01/01/2021, 12:00:00 AM")
  
  let uk_format = DateFormatter::format(formatter, timestamp, "en-GB")
  assert_eq(uk_format, "01/01/2021, 00:00:00")
  
  let chinese_format = DateFormatter::format(formatter, timestamp, "zh-CN")
  assert_eq(chinese_format, "2021/01/01 00:00:00")
  
  let german_format = DateFormatter::format(formatter, timestamp, "de-DE")
  assert_eq(german_format, "01.01.2021, 00:00:00")
}

// Test 3: Unicode and Special Character Handling
test "unicode and special character handling in telemetry" {
  // Create telemetry data with unicode characters
  let attrs = Attributes::new()
  
  // Test various unicode characters
  Attributes::set(attrs, "chinese", StringValue("æµ‹è¯•æ•°æ®"))
  Attributes::set(attrs, "arabic", StringValue("Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±"))
  Attributes::set(attrs, "russian", StringValue("Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ"))
  Attributes::set(attrs, "emoji", StringValue("ğŸ”ğŸ“ŠğŸ“ˆ"))
  Attributes::set(attrs, "math", StringValue("âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚"))
  
  // Verify unicode attributes are stored and retrieved correctly
  let chinese_value = Attributes::get(attrs, "chinese")
  match chinese_value {
    Some(StringValue(v)) => assert_eq(v, "æµ‹è¯•æ•°æ®")
    _ => assert_true(false)
  }
  
  let arabic_value = Attributes::get(attrs, "arabic")
  match arabic_value {
    Some(StringValue(v)) => assert_eq(v, "Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±")
    _ => assert_true(false)
  }
  
  let russian_value = Attributes::get(attrs, "russian")
  match russian_value {
    Some(StringValue(v)) => assert_eq(v, "Ñ‚ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ")
    _ => assert_true(false)
  }
  
  let emoji_value = Attributes::get(attrs, "emoji")
  match emoji_value {
    Some(StringValue(v)) => assert_eq(v, "ğŸ”ğŸ“ŠğŸ“ˆ")
    _ => assert_true(false)
  }
  
  let math_value = Attributes::get(attrs, "math")
  match math_value {
    Some(StringValue(v)) => assert_eq(v, "âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚")
    _ => assert_true(false)
  }
}