// Azimuth Attributes Operations Test Suite
// æµ‹è¯•å±žæ€§æ“ä½œçš„é«˜çº§åŠŸèƒ½ï¼ŒåŒ…æ‹¬åˆå¹¶ã€è¿‡æ»¤ã€è½¬æ¢ç­‰

test "å±žæ€§åˆ›å»ºå’ŒåŸºæœ¬æ“ä½œ" {
  // åˆ›å»ºå•ä¸ªå±žæ€§
  let string_attr = ("service.name", azimuth::AttributeValue::StringValue("payment-service"))
  let int_attr = ("service.port", azimuth::AttributeValue::IntValue(8080))
  let bool_attr = ("service.enabled", azimuth::AttributeValue::BoolValue(true))
  
  // éªŒè¯å±žæ€§é”®å€¼å¯¹
  assert_eq(string_attr.0, "service.name")
  match string_attr.1 {
    azimuth::AttributeValue::StringValue(name) => assert_eq(name, "payment-service")
    _ => assert_true(false)
  }
  
  assert_eq(int_attr.0, "service.port")
  match int_attr.1 {
    azimuth::AttributeValue::IntValue(port) => assert_eq(port, 8080)
    _ => assert_true(false)
  }
  
  assert_eq(bool_attr.0, "service.enabled")
  match bool_attr.1 {
    azimuth::AttributeValue::BoolValue(enabled) => assert_true(enabled)
    _ => assert_true(false)
  }
}

test "å±žæ€§é›†åˆåˆ›å»ºå’Œè®¿é—®" {
  // åˆ›å»ºå±žæ€§é›†åˆ
  let attrs = azimuth::Attributes {
    values: [
      ("service.name", azimuth::AttributeValue::StringValue("order-service")),
      ("service.version", azimuth::AttributeValue::StringValue("2.1.0")),
      ("service.instance.id", azimuth::AttributeValue::StringValue("instance-001")),
      ("deployment.environment", azimuth::AttributeValue::StringValue("production"))
    ]
  }
  
  assert_eq(attrs.values.length(), 4)
  
  // æŒ‰ç´¢å¼•è®¿é—®å±žæ€§
  let (key1, value1) = attrs.values[0]
  assert_eq(key1, "service.name")
  match value1 {
    azimuth::AttributeValue::StringValue(name) => assert_eq(name, "order-service")
    _ => assert_true(false)
  }
  
  // éåŽ†æ‰€æœ‰å±žæ€§
  let mut found_keys = []
  for (key, _) in attrs.values {
    found_keys = found_keys + [key]
  }
  
  assert_eq(found_keys.length(), 4)
  assert_true(found_keys.contains("service.name"))
  assert_true(found_keys.contains("service.version"))
  assert_true(found_keys.contains("service.instance.id"))
  assert_true(found_keys.contains("deployment.environment"))
}

test "å±žæ€§ç±»åž‹è½¬æ¢æµ‹è¯•" {
  // åˆ›å»ºä¸åŒç±»åž‹çš„å±žæ€§
  let attrs = azimuth::Attributes {
    values: [
      ("string.value", azimuth::AttributeValue::StringValue("test")),
      ("int.value", azimuth::AttributeValue::IntValue(42)),
      ("float.value", azimuth::AttributeValue::FloatValue(3.14159)),
      ("bool.value", azimuth::AttributeValue::BoolValue(true)),
      ("array.string", azimuth::AttributeValue::ArrayStringValue(["a", "b", "c"])),
      ("array.int", azimuth::AttributeValue::ArrayIntValue([1, 2, 3, 4, 5]))
    ]
  }
  
  // éªŒè¯ç±»åž‹è½¬æ¢
  for (key, value) in attrs.values {
    match key {
      "string.value" => {
        match value {
          azimuth::AttributeValue::StringValue(s) => assert_eq(s, "test")
          _ => assert_true(false)
        }
      }
      "int.value" => {
        match value {
          azimuth::AttributeValue::IntValue(i) => assert_eq(i, 42)
          _ => assert_true(false)
        }
      }
      "float.value" => {
        match value {
          azimuth::AttributeValue::FloatValue(f) => assert_true(f > 3.14 && f < 3.142)
          _ => assert_true(false)
        }
      }
      "bool.value" => {
        match value {
          azimuth::AttributeValue::BoolValue(b) => assert_true(b)
          _ => assert_true(false)
        }
      }
      "array.string" => {
        match value {
          azimuth::AttributeValue::ArrayStringValue(arr) => {
            assert_eq(arr.length(), 3)
            assert_eq(arr[0], "a")
            assert_eq(arr[1], "b")
            assert_eq(arr[2], "c")
          }
          _ => assert_true(false)
        }
      }
      "array.int" => {
        match value {
          azimuth::AttributeValue::ArrayIntValue(arr) => {
            assert_eq(arr.length(), 5)
            assert_eq(arr[0], 1)
            assert_eq(arr[4], 5)
          }
          _ => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
}

test "å±žæ€§åˆå¹¶æ“ä½œæµ‹è¯•" {
  // åˆ›å»ºç¬¬ä¸€ä¸ªå±žæ€§é›†åˆ
  let attrs1 = azimuth::Attributes {
    values: [
      ("service.name", azimuth::AttributeValue::StringValue("user-service")),
      ("service.version", azimuth::AttributeValue::StringValue("1.0.0")),
      ("host.name", azimuth::AttributeValue::StringValue("host-001"))
    ]
  }
  
  // åˆ›å»ºç¬¬äºŒä¸ªå±žæ€§é›†åˆ
  let attrs2 = azimuth::Attributes {
    values: [
      ("service.version", azimuth::AttributeValue::StringValue("1.1.0")), // è¦†ç›–ç‰ˆæœ¬
      ("deployment.environment", azimuth::AttributeValue::StringValue("staging")),
      ("region", azimuth::AttributeValue::StringValue("us-west-2"))
    ]
  }
  
  // æ¨¡æ‹Ÿåˆå¹¶æ“ä½œï¼šç¬¬ä¸€ä¸ªé›†åˆçš„å±žæ€§ä¼˜å…ˆ
  let mut merged_values = attrs1.values
  
  // æ·»åŠ ç¬¬äºŒä¸ªé›†åˆä¸­ä¸å­˜åœ¨çš„å±žæ€§
  for (key2, value2) in attrs2.values {
    let mut found = false
    for (key1, _) in attrs1.values {
      if key1 == key2 {
        found = true
        break
      }
    }
    
    if not found {
      merged_values = merged_values + [(key2, value2)]
    }
  }
  
  let merged_attrs = azimuth::Attributes { values: merged_values }
  
  // éªŒè¯åˆå¹¶ç»“æžœ
  assert_eq(merged_attrs.values.length(), 5)
  
  // éªŒè¯service.versionä¿æŒåŽŸå€¼
  let mut found_version = false
  for (key, value) in merged_attrs.values {
    if key == "service.version" {
      found_version = true
      match value {
        azimuth::AttributeValue::StringValue(v) => assert_eq(v, "1.0.0") // ä¿æŒåŽŸå€¼
        _ => assert_true(false)
      }
    }
  }
  assert_true(found_version)
  
  // éªŒè¯æ–°æ·»åŠ çš„å±žæ€§
  let mut found_env = false
  let mut found_region = false
  for (key, value) in merged_attrs.values {
    if key == "deployment.environment" {
      found_env = true
      match value {
        azimuth::AttributeValue::StringValue(env) => assert_eq(env, "staging")
        _ => assert_true(false)
      }
    } else if key == "region" {
      found_region = true
      match value {
        azimuth::AttributeValue::StringValue(r) => assert_eq(r, "us-west-2")
        _ => assert_true(false)
      }
    }
  }
  assert_true(found_env)
  assert_true(found_region)
}

test "å±žæ€§è¿‡æ»¤æ“ä½œæµ‹è¯•" {
  // åˆ›å»ºå®Œæ•´çš„å±žæ€§é›†åˆ
  let attrs = azimuth::Attributes {
    values: [
      ("service.name", azimuth::AttributeValue::StringValue("api-gateway")),
      ("service.version", azimuth::AttributeValue::StringValue("3.2.1")),
      ("service.instance.id", azimuth::AttributeValue::StringValue("instance-123")),
      ("host.name", azimuth::AttributeValue::StringValue("api-host-01")),
      ("host.ip", azimuth::AttributeValue::StringValue("10.0.1.100")),
      ("deployment.environment", azimuth::AttributeValue::StringValue("production")),
      ("region", azimuth::AttributeValue::StringValue("eu-central-1")),
      ("zone", azimuth::AttributeValue::StringValue("eu-central-1a"))
    ]
  }
  
  // è¿‡æ»¤ä»¥"service."å¼€å¤´çš„å±žæ€§
  let mut service_attrs = []
  for (key, value) in attrs.values {
    if key.starts_with("service.") {
      service_attrs = service_attrs + [(key, value)]
    }
  }
  
  assert_eq(service_attrs.length(), 3)
  
  // éªŒè¯è¿‡æ»¤ç»“æžœ
  let service_attr_keys = ["service.name", "service.version", "service.instance.id"]
  for (key, _) in service_attrs {
    assert_true(service_attr_keys.contains(key))
  }
  
  // è¿‡æ»¤ä»¥"host."å¼€å¤´çš„å±žæ€§
  let mut host_attrs = []
  for (key, value) in attrs.values {
    if key.starts_with("host.") {
      host_attrs = host_attrs + [(key, value)]
    }
  }
  
  assert_eq(host_attrs.length(), 2)
  
  // éªŒè¯è¿‡æ»¤ç»“æžœ
  let host_attr_keys = ["host.name", "host.ip"]
  for (key, _) in host_attrs {
    assert_true(host_attr_keys.contains(key))
  }
}

test "å±žæ€§å€¼è½¬æ¢æ“ä½œæµ‹è¯•" {
  // åˆ›å»ºåŒ…å«å„ç§ç±»åž‹çš„å±žæ€§
  let attrs = azimuth::Attributes {
    values: [
      ("string.number", azimuth::AttributeValue::StringValue("123")),
      ("string.float", azimuth::AttributeValue::StringValue("45.67")),
      ("string.bool", azimuth::AttributeValue::StringValue("true")),
      ("int.value", azimuth::AttributeValue::IntValue(999)),
      ("float.value", azimuth::AttributeValue::FloatValue(78.9)),
      ("bool.value", azimuth::AttributeValue::BoolValue(false))
    ]
  }
  
  // æ¨¡æ‹Ÿå­—ç¬¦ä¸²åˆ°æ•°å­—çš„è½¬æ¢
  for (key, value) in attrs.values {
    match key {
      "string.number" => {
        match value {
          azimuth::AttributeValue::StringValue(s) => {
            // æ¨¡æ‹Ÿå­—ç¬¦ä¸²è½¬æ•´æ•°
            let converted_int = 123 // ç®€åŒ–çš„è½¬æ¢é€»è¾‘
            assert_eq(converted_int, 123)
          }
          _ => assert_true(false)
        }
      }
      "string.float" => {
        match value {
          azimuth::AttributeValue::StringValue(s) => {
            // æ¨¡æ‹Ÿå­—ç¬¦ä¸²è½¬æµ®ç‚¹æ•°
            let converted_float = 45.67 // ç®€åŒ–çš„è½¬æ¢é€»è¾‘
            assert_true(converted_float > 45.66 && converted_float < 45.68)
          }
          _ => assert_true(false)
        }
      }
      "string.bool" => {
        match value {
          azimuth::AttributeValue::StringValue(s) => {
            // æ¨¡æ‹Ÿå­—ç¬¦ä¸²è½¬å¸ƒå°”å€¼
            let converted_bool = true // ç®€åŒ–çš„è½¬æ¢é€»è¾‘
            assert_true(converted_bool)
          }
          _ => assert_true(false)
        }
      }
      _ => () // å…¶ä»–ç±»åž‹ä¸éœ€è¦è½¬æ¢
    }
  }
}

test "åµŒå¥—å±žæ€§æ“ä½œæµ‹è¯•" {
  // åˆ›å»ºæ¨¡æ‹ŸåµŒå¥—ç»“æž„çš„å±žæ€§
  let nested_attrs = azimuth::Attributes {
    values: [
      ("service.name", azimuth::AttributeValue::StringValue("auth-service")),
      ("service.config.database.host", azimuth::AttributeValue::StringValue("db-primary")),
      ("service.config.database.port", azimuth::AttributeValue::IntValue(5432)),
      ("service.config.cache.redis.host", azimuth::AttributeValue::StringValue("redis-cluster")),
      ("service.config.cache.redis.port", azimuth::AttributeValue::IntValue(6379)),
      ("service.endpoints.health", azimuth::AttributeValue::StringValue("/health")),
      ("service.endpoints.metrics", azimuth::AttributeValue::StringValue("/metrics"))
    ]
  }
  
  // æå–æ•°æ®åº“é…ç½®
  let mut db_config = []
  for (key, value) in nested_attrs.values {
    if key.starts_with("service.config.database.") {
      db_config = db_config + [(key, value)]
    }
  }
  
  assert_eq(db_config.length(), 2)
  
  // æå–ç¼“å­˜é…ç½®
  let mut cache_config = []
  for (key, value) in nested_attrs.values {
    if key.starts_with("service.config.cache.") {
      cache_config = cache_config + [(key, value)]
    }
  }
  
  assert_eq(cache_config.length(), 2)
  
  // æå–ç«¯ç‚¹é…ç½®
  let mut endpoints = []
  for (key, value) in nested_attrs.values {
    if key.starts_with("service.endpoints.") {
      endpoints = endpoints + [(key, value)]
    }
  }
  
  assert_eq(endpoints.length(), 2)
}

test "å±žæ€§æ•°ç»„æ“ä½œæµ‹è¯•" {
  // åˆ›å»ºåŒ…å«æ•°ç»„å±žæ€§çš„é›†åˆ
  let array_attrs = azimuth::Attributes {
    values: [
      ("string.array", azimuth::AttributeValue::ArrayStringValue(["tag1", "tag2", "tag3"])),
      ("int.array", azimuth::AttributeValue::ArrayIntValue([10, 20, 30, 40, 50])),
      ("mixed.attrs", azimuth::AttributeValue::StringValue("single-value"))
    ]
  }
  
  // å¤„ç†æ•°ç»„å±žæ€§
  for (key, value) in array_attrs.values {
    match key {
      "string.array" => {
        match value {
          azimuth::AttributeValue::ArrayStringValue(arr) => {
            assert_eq(arr.length(), 3)
            
            // éªŒè¯æ•°ç»„å…ƒç´ 
            assert_eq(arr[0], "tag1")
            assert_eq(arr[1], "tag2")
            assert_eq(arr[2], "tag3")
            
            // æ¨¡æ‹Ÿæ•°ç»„æ“ä½œï¼šæŸ¥æ‰¾å…ƒç´ 
            let mut found_tag2 = false
            for element in arr {
              if element == "tag2" {
                found_tag2 = true
                break
              }
            }
            assert_true(found_tag2)
          }
          _ => assert_true(false)
        }
      }
      "int.array" => {
        match value {
          azimuth::AttributeValue::ArrayIntValue(arr) => {
            assert_eq(arr.length(), 5)
            
            // éªŒè¯æ•°ç»„å…ƒç´ 
            assert_eq(arr[0], 10)
            assert_eq(arr[4], 50)
            
            // æ¨¡æ‹Ÿæ•°ç»„æ“ä½œï¼šè®¡ç®—æ€»å’Œ
            let mut sum = 0
            for element in arr {
              sum = sum + element
            }
            assert_eq(sum, 150)
          }
          _ => assert_true(false)
        }
      }
      "mixed.attrs" => {
        match value {
          azimuth::AttributeValue::StringValue(s) => assert_eq(s, "single-value")
          _ => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
}

test "å±žæ€§è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå±žæ€§é›†åˆ
  let empty_attrs = azimuth::Attributes { values: [] }
  assert_eq(empty_attrs.values.length(), 0)
  
  // æµ‹è¯•åŒ…å«ç©ºå€¼çš„å±žæ€§
  let nullish_attrs = azimuth::Attributes {
    values: [
      ("empty.string", azimuth::AttributeValue::StringValue("")),
      ("zero.int", azimuth::AttributeValue::IntValue(0)),
      ("zero.float", azimuth::AttributeValue::FloatValue(0.0)),
      ("false.bool", azimuth::AttributeValue::BoolValue(false)),
      ("empty.string.array", azimuth::AttributeValue::ArrayStringValue([])),
      ("empty.int.array", azimuth::AttributeValue::ArrayIntValue([]))
    ]
  }
  
  // éªŒè¯ç©ºå€¼å±žæ€§
  for (key, value) in nullish_attrs.values {
    match key {
      "empty.string" => {
        match value {
          azimuth::AttributeValue::StringValue(s) => assert_eq(s, "")
          _ => assert_true(false)
        }
      }
      "zero.int" => {
        match value {
          azimuth::AttributeValue::IntValue(i) => assert_eq(i, 0)
          _ => assert_true(false)
        }
      }
      "zero.float" => {
        match value {
          azimuth::AttributeValue::FloatValue(f) => assert_true(f == 0.0)
          _ => assert_true(false)
        }
      }
      "false.bool" => {
        match value {
          azimuth::AttributeValue::BoolValue(b) => assert_false(b)
          _ => assert_true(false)
        }
      }
      "empty.string.array" => {
        match value {
          azimuth::AttributeValue::ArrayStringValue(arr) => assert_eq(arr.length(), 0)
          _ => assert_true(false)
        }
      }
      "empty.int.array" => {
        match value {
          azimuth::AttributeValue::ArrayIntValue(arr) => assert_eq(arr.length(), 0)
          _ => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’Œé•¿å­—ç¬¦ä¸²
  let special_attrs = azimuth::Attributes {
    values: [
      ("special.chars", azimuth::AttributeValue::StringValue("!@#$%^&*()_+-={}[]|\\:;\"'<>?,./")),
      ("unicode.chars", azimuth::AttributeValue::StringValue("æµ‹è¯•ä¸­æ–‡ðŸš€emoji")),
      ("very.long.key.name.that.exceeds.normal.expectations.and.tests.boundary.conditions", 
       azimuth::AttributeValue::StringValue("long-key-value"))
    ]
  }
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å¤„ç†
  for (key, value) in special_attrs.values {
    match value {
      azimuth::AttributeValue::StringValue(s) => {
        assert_true(s.length() > 0)
        // éªŒè¯å­—ç¬¦ä¸²å†…å®¹ä¸ä¸ºç©º
        assert_false(s == "")
      }
      _ => assert_true(false)
    }
  }
}