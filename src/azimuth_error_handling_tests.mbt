// Azimuth Error Handling and Boundary Conditions Test Suite
// æµ‹è¯•é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„ç¨³å®šæ€§å’Œæ­£ç¡®æ€§

test "ç©ºå€¼å’ŒNoneå¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å±æ€§
  let empty_string_attr = azimuth::AttributeValue::StringValue("")
  match empty_string_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "")
      assert_eq(s.length(), 0)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é›¶å€¼å±æ€§
  let zero_int_attr = azimuth::AttributeValue::IntValue(0)
  match zero_int_attr {
    azimuth::AttributeValue::IntValue(i) => assert_eq(i, 0)
    _ => assert_true(false)
  }
  
  let zero_float_attr = azimuth::AttributeValue::FloatValue(0.0)
  match zero_float_attr {
    azimuth::AttributeValue::FloatValue(f) => assert_true(f == 0.0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•falseå¸ƒå°”å€¼
  let false_bool_attr = azimuth::AttributeValue::BoolValue(false)
  match false_bool_attr {
    azimuth::AttributeValue::BoolValue(b) => assert_false(b)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = azimuth::AttributeValue::ArrayStringValue([])
  match empty_string_array {
    azimuth::AttributeValue::ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => assert_true(false)
  }
  
  let empty_int_array = azimuth::AttributeValue::ArrayIntValue([])
  match empty_int_array {
    azimuth::AttributeValue::ArrayIntValue(arr) => assert_eq(arr.length(), 0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•Noneé€‰é¡¹å€¼
  let none_version = None[String]
  match none_version {
    Some(v) => assert_true(false) // ä¸åº”è¯¥æœ‰å€¼
    None => assert_true(true) // åº”è¯¥ä¸ºNone
  }
  
  let some_version = Some("1.0.0")
  match some_version {
    Some(v) => assert_eq(v, "1.0.0")
    None => assert_true(false)
  }
}

test "ä¸Šä¸‹æ–‡Noneå¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_context = azimuth::Context { data: None }
  match empty_context.data {
    Some((key, value)) => assert_true(false) // ä¸åº”è¯¥æœ‰æ•°æ®
    None => assert_true(true) // åº”è¯¥ä¸ºNone
  }
  
  // æµ‹è¯•æœ‰æ•°æ®çš„ä¸Šä¸‹æ–‡
  let data_context = azimuth::Context { 
    data: Some(("trace.id", "12345")) 
  }
  
  match data_context.data {
    Some((key, value)) => {
      assert_eq(key, "trace.id")
      assert_eq(value, "12345")
    }
    None => assert_true(false) // åº”è¯¥æœ‰æ•°æ®
  }
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡æ•°æ®çš„å®‰å…¨è®¿é—®
  let safe_access_context = azimuth::Context { data: None }
  let safe_value = match safe_access_context.data {
    Some((_, value)) => value,
    None => "default-value" // æä¾›é»˜è®¤å€¼
  }
  assert_eq(safe_value, "default-value")
}

test "è·¨åº¦ä¸Šä¸‹æ–‡è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²çš„è·¨åº¦ä¸Šä¸‹æ–‡
  let empty_trace_context = azimuth::SpanContext {
    trace_id: "",
    span_id: "",
    sampled: false,
    trace_state: ""
  }
  
  assert_eq(empty_trace_context.trace_id, "")
  assert_eq(empty_trace_context.span_id, "")
  assert_false(empty_trace_context.sampled)
  assert_eq(empty_trace_context.trace_state, "")
  
  // æµ‹è¯•æ— æ•ˆé•¿åº¦çš„ID
  let short_trace_id = "abc" // é•¿åº¦ä¸è¶³
  let short_span_context = azimuth::SpanContext {
    trace_id: short_trace_id,
    span_id: "123",
    sampled: true,
    trace_state: ""
  }
  
  assert_eq(short_span_context.trace_id, "abc")
  assert_eq(short_span_context.span_id, "123")
  
  // æµ‹è¯•è¶…é•¿ID
  let long_trace_id = "a".repeat(1000)
  let long_span_context = azimuth::SpanContext {
    trace_id: long_trace_id,
    span_id: "b".repeat(1000),
    sampled: true,
    trace_state: "c".repeat(1000)
  }
  
  assert_eq(long_span_context.trace_id.length(), 1000)
  assert_eq(long_span_context.span_id.length(), 1000)
  assert_eq(long_span_context.trace_state.length(), 1000)
}

test "å±æ€§å’Œèµ„æºè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå±æ€§é›†åˆ
  let empty_attrs = azimuth::Attributes { values: [] }
  assert_eq(empty_attrs.values.length(), 0)
  
  // æµ‹è¯•åŒ…å«ç©ºé”®çš„å±æ€§ï¼ˆè¾¹ç•Œæƒ…å†µï¼‰
  let empty_key_attrs = azimuth::Attributes {
    values: [
      ("", azimuth::AttributeValue::StringValue("empty-key-value")),
      ("normal.key", azimuth::AttributeValue::StringValue("normal-value"))
    ]
  }
  
  assert_eq(empty_key_attrs.values.length(), 2)
  
  // éªŒè¯ç©ºé”®å±æ€§
  let (empty_key, empty_key_value) = empty_key_attrs.values[0]
  assert_eq(empty_key, "")
  match empty_key_value {
    azimuth::AttributeValue::StringValue(s) => assert_eq(s, "empty-key-value")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºèµ„æº
  let empty_resource = azimuth::Resource { attributes: [] }
  assert_eq(empty_resource.attributes.length(), 0)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®
  let special_key_resource = azimuth::Resource {
    attributes: [
      ("special.key!@#$%", azimuth::AttributeValue::StringValue("special-value")),
      ("key with spaces", azimuth::AttributeValue::StringValue("space-value")),
      ("key\twith\ttabs", azimuth::AttributeValue::StringValue("tab-value")),
      ("key\nwith\nnewlines", azimuth::AttributeValue::StringValue("newline-value"))
    ]
  }
  
  assert_eq(special_key_resource.attributes.length(), 4)
}

test "è¡Œæå’Œè½½ä½“è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºè¡Œæ
  let empty_baggage = azimuth::Baggage { entries: [] }
  assert_eq(empty_baggage.entries.length(), 0)
  
  // æµ‹è¯•åŒ…å«ç©ºé”®å’Œç©ºå€¼çš„è¡Œæ
  let empty_key_value_baggage = azimuth::Baggage {
    entries: [
      ("", "empty-key-value"),
      ("empty-value-key", ""),
      ("", "")
    ]
  }
  
  assert_eq(empty_key_value_baggage.entries.length(), 3)
  
  // éªŒè¯ç©ºé”®å’Œç©ºå€¼
  let (empty_key, empty_key_value) = empty_key_value_baggage.entries[0]
  assert_eq(empty_key, "")
  assert_eq(empty_key_value, "empty-key-value")
  
  let (empty_value_key, empty_value) = empty_key_value_baggage.entries[1]
  assert_eq(empty_value_key, "empty-value-key")
  assert_eq(empty_value, "")
  
  // æµ‹è¯•ç©ºè½½ä½“
  let empty_carrier = azimuth::TextMapCarrier { headers: [] }
  assert_eq(empty_carrier.headers.length(), 0)
  
  // æµ‹è¯•åŒ…å«ç©ºé”®å’Œç©ºå€¼çš„è½½ä½“
  let empty_key_value_carrier = azimuth::TextMapCarrier {
    headers: [
      ("", "empty-header-value"),
      ("empty-header-key", ""),
      ("", "")
    ]
  }
  
  assert_eq(empty_key_value_carrier.headers.length(), 3)
}

test "æ•°å€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æœ€å¤§æ•´æ•°å€¼
  let max_int = 2147483647 // 32ä½æœ‰ç¬¦å·æ•´æ•°æœ€å¤§å€¼
  let max_int_attr = azimuth::AttributeValue::IntValue(max_int)
  match max_int_attr {
    azimuth::AttributeValue::IntValue(i) => assert_eq(i, 2147483647)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æœ€å°æ•´æ•°å€¼
  let min_int = -2147483648 // 32ä½æœ‰ç¬¦å·æ•´æ•°æœ€å°å€¼
  let min_int_attr = azimuth::AttributeValue::IntValue(min_int)
  match min_int_attr {
    azimuth::AttributeValue::IntValue(i) => assert_eq(i, -2147483648)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æœ€å¤§æµ®ç‚¹æ•°å€¼
  let max_float = 1.7976931348623157e+308 // åŒç²¾åº¦æµ®ç‚¹æ•°æœ€å¤§å€¼
  let max_float_attr = azimuth::AttributeValue::FloatValue(max_float)
  match max_float_attr {
    azimuth::AttributeValue::FloatValue(f) => assert_true(f > 1.0e+308)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æœ€å°æ­£æµ®ç‚¹æ•°å€¼
  let min_positive_float = 2.2250738585072014e-308 // åŒç²¾åº¦æµ®ç‚¹æ•°æœ€å°æ­£æ•°
  let min_positive_float_attr = azimuth::AttributeValue::FloatValue(min_positive_float)
  match min_positive_float_attr {
    azimuth::AttributeValue::FloatValue(f) => assert_true(f > 0.0 && f < 1.0e-307)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•è´Ÿæ— ç©·å¤§ï¼ˆé€šè¿‡æå¤§è´Ÿæ•°æ¨¡æ‹Ÿï¼‰
  let large_negative_float = -1.7976931348623157e+308
  let large_negative_float_attr = azimuth::AttributeValue::FloatValue(large_negative_float)
  match large_negative_float_attr {
    azimuth::AttributeValue::FloatValue(f) => assert_true(f < -1.0e+308)
    _ => assert_true(false)
  }
}

test "å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_string = ""
  let empty_string_attr = azimuth::AttributeValue::StringValue(empty_string)
  match empty_string_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "")
      assert_eq(s.length(), 0)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å•å­—ç¬¦å­—ç¬¦ä¸²
  let single_char_string = "a"
  let single_char_string_attr = azimuth::AttributeValue::StringValue(single_char_string)
  match single_char_string_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "a")
      assert_eq(s.length(), 1)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_string = "a".repeat(10000)
  let long_string_attr = azimuth::AttributeValue::StringValue(long_string)
  match long_string_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s.length(), 10000)
      assert_eq(s[0], 'a')
      assert_eq(s[9999], 'a')
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars_string = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./\n\t\r"
  let special_chars_string_attr = azimuth::AttributeValue::StringValue(special_chars_string)
  match special_chars_string_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_true(s.contains("!@#$%^&*()"))
      assert_true(s.contains("\n"))
      assert_true(s.contains("\t"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²
  let unicode_string = "æµ‹è¯•ä¸­æ–‡ğŸš€emojiÃ¡Ã©Ã­Ã³ÃºÃ±Ã¼"
  let unicode_string_attr = azimuth::AttributeValue::StringValue(unicode_string)
  match unicode_string_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_true(s.contains("æµ‹è¯•ä¸­æ–‡"))
      assert_true(s.contains("ğŸš€"))
      assert_true(s.contains("Ã¡Ã©Ã­Ã³Ãº"))
    }
    _ => assert_true(false)
  }
}

test "æ•°ç»„è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = azimuth::AttributeValue::ArrayStringValue([])
  match empty_string_array {
    azimuth::AttributeValue::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 0)
    }
    _ => assert_true(false)
  }
  
  let empty_int_array = azimuth::AttributeValue::ArrayIntValue([])
  match empty_int_array {
    azimuth::AttributeValue::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 0)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_string_array = azimuth::AttributeValue::ArrayStringValue(["single"])
  match single_string_array {
    azimuth::AttributeValue::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], "single")
    }
    _ => assert_true(false)
  }
  
  let single_int_array = azimuth::AttributeValue::ArrayIntValue([42])
  match single_int_array {
    azimuth::AttributeValue::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], 42)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç©ºå­—ç¬¦ä¸²çš„æ•°ç»„
  let empty_string_elements_array = azimuth::AttributeValue::ArrayStringValue(["", "normal", ""])
  match empty_string_elements_array {
    azimuth::AttributeValue::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], "")
      assert_eq(arr[1], "normal")
      assert_eq(arr[2], "")
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«é›¶å€¼çš„æ•°ç»„
  let zero_elements_array = azimuth::AttributeValue::ArrayIntValue([0, 1, 0, 2, 0])
  match zero_elements_array {
    azimuth::AttributeValue::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 5)
      assert_eq(arr[0], 0)
      assert_eq(arr[1], 1)
      assert_eq(arr[2], 0)
      assert_eq(arr[3], 2)
      assert_eq(arr[4], 0)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¤§æ•°ç»„
  let large_string_array = azimuth::AttributeValue::ArrayStringValue(["item"].repeat(1000))
  match large_string_array {
    azimuth::AttributeValue::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 1000)
      assert_eq(arr[0], "item")
      assert_eq(arr[999], "item")
    }
    _ => assert_true(false)
  }
}

test "é”™è¯¯æ¢å¤å’Œå®¹é”™æµ‹è¯•" {
  // æµ‹è¯•å±æ€§è®¿é—®çš„å®‰å…¨å¤„ç†
  let attrs = azimuth::Attributes {
    values: [
      ("valid.key", azimuth::AttributeValue::StringValue("valid-value")),
      ("invalid.key", azimuth::AttributeValue::StringValue(""))
    ]
  }
  
  // å®‰å…¨è®¿é—®å±æ€§ï¼Œæä¾›é»˜è®¤å€¼
  let safe_get_value = |key: String| -> String {
    for (k, v) in attrs.values {
      if k == key {
        match v {
          azimuth::AttributeValue::StringValue(s) => {
            if s.length() > 0 {
              return s
            } else {
              return "default-for-empty"
            }
          }
          _ => return "default-for-wrong-type"
        }
      }
    }
    "default-for-missing-key"
  }
  
  assert_eq(safe_get_value("valid.key"), "valid-value")
  assert_eq(safe_get_value("invalid.key"), "default-for-empty")
  assert_eq(safe_get_value("missing.key"), "default-for-missing-key")
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡æ•°æ®çš„å®‰å…¨å¤„ç†
  let context = azimuth::Context { data: None }
  let safe_context_value = match context.data {
    Some((_, value)) => value,
    None => "no-context-data"
  }
  assert_eq(safe_context_value, "no-context-data")
  
  // æµ‹è¯•è·¨åº¦ä¸Šä¸‹æ–‡çš„å®‰å…¨å¤„ç†
  let span_context = azimuth::SpanContext {
    trace_id: "",
    span_id: "",
    sampled: false,
    trace_state: ""
  }
  
  // å®‰å…¨çš„trace_idéªŒè¯
  let is_valid_trace_id = span_context.trace_id.length() > 0
  assert_false(is_valid_trace_id)
  
  // æµ‹è¯•è¡Œææ¡ç›®çš„å®‰å…¨å¤„ç†
  let baggage = azimuth::Baggage {
    entries: [
      ("valid.entry", "valid-value"),
      ("empty.value", ""),
      ("", "empty-key")
    ]
  }
  
  // å®‰å…¨è·å–è¡Œæå€¼
  let safe_get_baggage_value = |key: String| -> String {
    for (k, v) in baggage.entries {
      if k == key && v.length() > 0 {
        return v
      }
    }
    "no-valid-baggage-entry"
  }
  
  assert_eq(safe_get_baggage_value("valid.entry"), "valid-value")
  assert_eq(safe_get_baggage_value("empty.value"), "no-valid-baggage-entry")
  assert_eq(safe_get_baggage_value("missing.entry"), "no-valid-baggage-entry")
}

test "å¼‚å¸¸è¾“å…¥å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•åŒ…å«æ§åˆ¶å­—ç¬¦çš„å­—ç¬¦ä¸²
  let control_chars_string = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x0B\x0C\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x7F"
  let control_chars_attr = azimuth::AttributeValue::StringValue(control_chars_string)
  match control_chars_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s.length(), 32)
      // éªŒè¯æ§åˆ¶å­—ç¬¦å­˜åœ¨
      assert_true(s.contains("\x00"))
      assert_true(s.contains("\x7F"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«HTMLç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let html_chars_string = "<script>alert('xss')</script>&quot;&apos;&lt;&gt;&amp;"
  let html_chars_attr = azimuth::AttributeValue::StringValue(html_chars_string)
  match html_chars_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_true(s.contains("<script>"))
      assert_true(s.contains("&quot;"))
      assert_true(s.contains("&amp;"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«JSONç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let json_chars_string = "{\"key\":\"value\",\"array\":[1,2,3],\"nested\":{\"inner\":\"value\"}}"
  let json_chars_attr = azimuth::AttributeValue::StringValue(json_chars_string)
  match json_chars_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_true(s.contains("{\"key\""))
      assert_true(s.contains("\"array\""))
      assert_true(s.contains("\"nested\""))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«SQLç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let sql_chars_string = "SELECT * FROM users WHERE name = 'O'Reilly' AND password = \"x\"; DROP TABLE users; --"
  let sql_chars_attr = azimuth::AttributeValue::StringValue(sql_chars_string)
  match sql_chars_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_true(s.contains("SELECT * FROM"))
      assert_true(s.contains("O'Reilly"))
      assert_true(s.contains("DROP TABLE"))
    }
    _ => assert_true(false)
  }
}