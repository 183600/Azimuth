{"version":3,"sources":["/home/runner/work/Azimuth/Azimuth/src/azimuth/__generated_driver_for_internal_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/additional_edge_cases.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/additional_focused_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/additional_test_cases.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/comprehensive_application_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/correct_concise_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/enhanced_coverage_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/enhanced_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/new_comprehensive_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/practical_application_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/practical_scenario_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/specialized_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/standard_moonbit_tests.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/lib.mbt","/home/runner/.moon/lib/core/builtin/autoloc.mbt","/home/runner/.moon/lib/core/builtin/console.mbt","/home/runner/.moon/lib/core/builtin/hasher.mbt","/home/runner/.moon/lib/core/builtin/array.mbt","/home/runner/.moon/lib/core/builtin/linked_hash_map.mbt","/home/runner/.moon/lib/core/builtin/int.mbt","/home/runner/.moon/lib/core/builtin/option.mbt","/home/runner/.moon/lib/core/builtin/show.mbt","/home/runner/.moon/lib/core/builtin/string_methods.mbt","/home/runner/.moon/lib/core/builtin/arraycore_nonjs.mbt","/home/runner/.moon/lib/core/builtin/stringbuilder_buffer.mbt","/home/runner/.moon/lib/core/builtin/byte.mbt","/home/runner/.moon/lib/core/builtin/stringview.mbt","/home/runner/.moon/lib/core/builtin/assert.mbt","/home/runner/.moon/lib/core/builtin/failure.mbt","/home/runner/.moon/lib/core/builtin/to_string.mbt","/home/runner/.moon/lib/core/builtin/traits.mbt","/home/runner/.moon/lib/core/builtin/bytes.mbt","/home/runner/.moon/lib/core/builtin/intrinsics.mbt","/home/runner/.moon/lib/core/builtin/uninitialized_array.mbt","/home/runner/.moon/lib/core/abort/abort.mbt"],"sourcesContent":[null,"// é¢å¤–çš„è¾¹ç•Œæƒ…å†µæµ‹è¯• - è¡¥å……ç°æœ‰æµ‹è¯•çš„è¦†ç›–èŒƒå›´\n\n///|\ntest \"add_chained_operations\" {\n  // æµ‹è¯•è¿ç»­åŠ æ³•æ“ä½œçš„ç¨³å®šæ€§\n  let mut result = 1000\n  result = add(result, 2000)  // 3000\n  result = add(result, -1000) // 2000\n  result = add(result, 47)    // 2047\n  result = add(result, -48)   // 1999\n  assert_eq(1999, result)\n}\n\n///|\ntest \"multiply_chained_operations\" {\n  // æµ‹è¯•è¿ç»­ä¹˜æ³•æ“ä½œçš„ç¨³å®šæ€§\n  let mut result = 2\n  result = multiply(result, 3)   // 6\n  result = multiply(result, 4)   // 24\n  result = multiply(result, 5)   // 120\n  result = multiply(result, 0)   // 0\n  result = multiply(result, 100) // 0\n  assert_eq(0, result)\n}\n\n///|\ntest \"mixed_operations_stability\" {\n  // æµ‹è¯•æ··åˆè¿ç®—çš„ç¨³å®šæ€§\n  let a = add(100, 200)        // 300\n  let b = multiply(a, 2)       // 600\n  let c = add(b, -100)         // 500\n  let d = multiply(c, 0)       // 0\n  let e = add(d, 42)           // 42\n  assert_eq(42, e)\n}\n\n///|\ntest \"greet_long_string\" {\n  // æµ‹è¯•é•¿å­—ç¬¦ä¸²çš„å¤„ç†\n  let long_name = \"ThisIsAVeryLongNameThatMightCauseIssuesInSomeSystemsButShouldWorkFineInMoonBit\"\n  let expected = \"Hello, \" + long_name + \"!\"\n  assert_eq(expected, greet(long_name))\n}\n\n///|\ntest \"greet_unicode_and_emoji\" {\n  // æµ‹è¯•Unicodeå’Œemojiå­—ç¬¦\n  assert_eq(\"Hello, ğŸŒ™!\", greet(\"ğŸŒ™\"))\n  assert_eq(\"Hello, ğŸš€!\", greet(\"ğŸš€\"))\n  assert_eq(\"Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!\", greet(\"Ã±Ã¡Ã©Ã­Ã³Ãº\"))\n}\n\n///|\ntest \"add_extreme_boundary_combinations\" {\n  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼çš„ç»„åˆ\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // æœ€å¤§å€¼å‡å»è‡ªèº«\n  assert_eq(0, add(max_val, -max_val))\n  \n  // æœ€å°å€¼å‡å»è‡ªèº«\n  assert_eq(-1, add(min_val, 2147483647)) // -2147483648 + 2147483647 = -1\n  \n  // æ¥è¿‘è¾¹ç•Œçš„å€¼\n  assert_eq(2147483646, add(1073741823, 1073741823))\n  assert_eq(-2147483647, add(-1073741824, -1073741823))\n}\n\n///|\ntest \"multiply_power_of_two\" {\n  // æµ‹è¯•2çš„å¹‚æ¬¡æ–¹ä¹˜æ³•\n  assert_eq(2, multiply(1, 2))\n  assert_eq(4, multiply(2, 2))\n  assert_eq(8, multiply(4, 2))\n  assert_eq(16, multiply(8, 2))\n  assert_eq(32, multiply(16, 2))\n  \n  // æµ‹è¯•2çš„å¹‚æ¬¡æ–¹çš„æº¢å‡º\n  assert_eq(2147483647, multiply(1073741824, 2))\n  assert_eq(2147483647, multiply(1073741824, 3))\n}\n\n///|\ntest \"multiply_negative_power_patterns\" {\n  // æµ‹è¯•è´Ÿæ•°çš„ä¹˜æ³•æ¨¡å¼\n  assert_eq(1, multiply(-1, -1))\n  assert_eq(-1, multiply(-1, 1))\n  assert_eq(-1, multiply(1, -1))\n  \n  // è´Ÿæ•°çš„è¿ç»­ä¹˜æ³•\n  let mut result = -2\n  result = multiply(result, -2)  // 4\n  result = multiply(result, -2)  // -8\n  result = multiply(result, -2)  // 16\n  assert_eq(16, result)\n}\n\n///|\ntest \"greet_whitespace_handling\" {\n  // æµ‹è¯•å„ç§ç©ºç™½å­—ç¬¦çš„å¤„ç†\n  assert_eq(\"Hello, \\t!\", greet(\"\\t\"))\n  assert_eq(\"Hello, \\n!\", greet(\"\\n\"))\n  assert_eq(\"Hello, \\r!\", greet(\"\\r\"))\n  assert_eq(\"Hello,  \\t !\", greet(\" \\t \"))\n  assert_eq(\"Hello,  leading!\", greet(\" leading\"))\n  assert_eq(\"Hello, trailing !\", greet(\"trailing \"))\n}\n\n///|\ntest \"stress_test_repeated_operations\" {\n  // å‹åŠ›æµ‹è¯•ï¼šé‡å¤æ“ä½œ\n  let mut sum = 0\n  // é‡å¤åŠ 1ç„¶åå‡1\n  for i = 0; i < 100; i = i + 1 {\n    sum = add(sum, 1)\n    sum = add(sum, -1)\n  }\n  assert_eq(0, sum)\n  \n  // é‡å¤ä¹˜2ç„¶åé™¤2ï¼ˆé€šè¿‡ä¹˜0.5çš„æ•´æ•°è¿‘ä¼¼ï¼‰\n  let mut product = 100\n  product = multiply(product, 2)    // 200\n  product = multiply(product, 0)    // 0\n  product = multiply(product, 100)  // 0\n  assert_eq(0, product)\n}","// é¢å¤–çš„é‡ç‚¹æµ‹è¯•ç”¨ä¾‹\n// ä¸“æ³¨äºç‰¹å®šåœºæ™¯å’Œè¾¹ç•Œæƒ…å†µ\n\n// æµ‹è¯•è¿ç»­è¿ç®—çš„ç¨³å®šæ€§\n///|\ntest \"continuous_operations_stability\" {\n  // æµ‹è¯•è¿ç»­åŠ æ³•\n  let result1 = add(add(add(1, 2), 3), 4)\n  assert_eq(10, result1)\n  \n  // æµ‹è¯•è¿ç»­ä¹˜æ³•\n  let result2 = multiply(multiply(multiply(2, 3), 4), 5)\n  assert_eq(120, result2)\n  \n  // æµ‹è¯•æ··åˆè¿ç®—\n  let result3 = add(multiply(2, 3), multiply(4, 5))\n  assert_eq(26, result3)\n}\n\n// æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—\n///|\ntest \"fibonacci_sequence_calculation\" {\n  // è®¡ç®—å‰å‡ ä¸ªæ–æ³¢é‚£å¥‘æ•°\n  let fib1 = add(0, 1)  // F1 = 1\n  let fib2 = add(1, 1)  // F2 = 2\n  let fib3 = add(fib1, fib2)  // F3 = 3\n  let fib4 = add(fib2, fib3)  // F4 = 5\n  let fib5 = add(fib3, fib4)  // F5 = 8\n  \n  assert_eq(1, fib1)\n  assert_eq(2, fib2)\n  assert_eq(3, fib3)\n  assert_eq(5, fib4)\n  assert_eq(8, fib5)\n}\n\n// æµ‹è¯•é˜¶ä¹˜è®¡ç®—\n///|\ntest \"factorial_calculation\" {\n  // è®¡ç®— 5! = 5 * 4 * 3 * 2 * 1 = 120\n  let fact1 = multiply(5, 4)\n  let fact2 = multiply(fact1, 3)\n  let fact3 = multiply(fact2, 2)\n  let fact4 = multiply(fact3, 1)\n  \n  assert_eq(120, fact4)\n  \n  // è®¡ç®— 0! = 1 (ç‰¹æ®Šæƒ…å†µ)\n  assert_eq(1, multiply(1, 1))\n}\n\n// æµ‹è¯•å¹³æ–¹å·®å…¬å¼ï¼šaÂ² - bÂ² = (a + b)(a - b)\n///|\ntest \"difference_of_squares\" {\n  let a = 10\n  let b = 3\n  \n  // ç›´æ¥è®¡ç®— aÂ² - bÂ²\n  let a_squared = multiply(a, a)\n  let b_squared = multiply(b, b)\n  let direct_result = add(a_squared, multiply(-1, b_squared))\n  \n  // ä½¿ç”¨å…¬å¼ (a + b)(a - b)\n  let sum_ab = add(a, b)\n  let diff_ab = add(a, multiply(-1, b))\n  let formula_result = multiply(sum_ab, diff_ab)\n  \n  assert_eq(direct_result, formula_result)\n  assert_eq(91, direct_result)\n}\n\n// æµ‹è¯•äºŒè¿›åˆ¶è¿ç®—ç›¸å…³çš„åè¿›åˆ¶è®¡ç®—\n///|\ntest \"binary_related_calculations\" {\n  // æµ‹è¯• 2 çš„å¹‚æ¬¡æ–¹\n  let power2_1 = multiply(2, 1)     // 2^1\n  let power2_2 = multiply(2, 2)     // 2^2\n  let power2_3 = multiply(2, 4)     // 2^3\n  let power2_4 = multiply(2, 8)     // 2^4\n  let power2_5 = multiply(2, 16)    // 2^5\n  \n  assert_eq(2, power2_1)\n  assert_eq(4, power2_2)\n  assert_eq(8, power2_3)\n  assert_eq(16, power2_4)\n  assert_eq(32, power2_5)\n  \n  // æµ‹è¯•ä½è¿ç®—ç›¸å…³çš„åè¿›åˆ¶è®¡ç®—\n  // å·¦ç§»ç›¸å½“äºä¹˜ä»¥2çš„å¹‚æ¬¡æ–¹\n  let shift_left_3 = multiply(5, 8)  // 5 << 3 = 5 * 2^3 = 40\n  assert_eq(40, shift_left_3)\n}\n\n// æµ‹è¯•å¹³å‡æ•°è®¡ç®—\n///|\ntest \"average_calculation\" {\n  // è®¡ç®—ä¸¤ä¸ªæ•°çš„å¹³å‡æ•°ï¼š(a + b) / 2\n  // æˆ‘ä»¬é€šè¿‡è®¡ç®— (a + b) ç„¶åéªŒè¯ç»“æœ\n  let a = 15\n  let b = 25\n  let sum = add(a, b)\n  \n  // éªŒè¯å’Œæ˜¯å¦æ­£ç¡®\n  assert_eq(40, sum)\n  \n  // å¯¹äºå¥‡æ•°å’Œçš„æƒ…å†µ\n  let c = 10\n  let d = 21\n  let sum2 = add(c, d)\n  assert_eq(31, sum2)\n}\n\n// æµ‹è¯•å¤åˆ©è®¡ç®—\n///|\ntest \"compound_interest_calculation\" {\n  // æœ¬é‡‘\n  let principal = 1000\n  // å¹´åˆ©ç‡ 5%\n  let rate_percent = 5\n  // ç¬¬ä¸€å¹´åçš„é‡‘é¢ï¼šæœ¬é‡‘ + æœ¬é‡‘ * åˆ©ç‡\n  let year1_gain = multiply(principal, rate_percent)\n  let year1_total_times_100 = add(multiply(principal, 100), year1_gain)\n  \n  // éªŒè¯è®¡ç®—ç»“æœ\n  assert_eq(105000, year1_total_times_100)  // 1050 * 100 = 105000\n  \n  // ç¬¬äºŒå¹´åŸºäºç¬¬ä¸€å¹´çš„æ€»é¢è®¡ç®—\n  // ç¬¬ä¸€å¹´æ€»é¢æ˜¯1050ï¼Œç¬¬äºŒå¹´åˆ©æ¯æ˜¯1050 * 5% = 52.5\n  // ç¬¬äºŒå¹´æ€»é¢æ˜¯1050 + 52.5 = 1102.5\n  // 1102.5 * 10000 = 11025000\n  let year2_gain = multiply(year1_total_times_100, rate_percent)\n  let year2_total_times_10000 = add(multiply(year1_total_times_100, 100), year2_gain)\n  \n  // éªŒè¯ç¬¬äºŒå¹´ç»“æœ\n  assert_eq(11025000, year2_total_times_10000)  // 1102.5 * 10000\n}\n\n// æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†ï¼šå¤šè¯­è¨€æ”¯æŒ\n///|\ntest \"multilingual_string_processing\" {\n  // æµ‹è¯•ä¸åŒè¯­è¨€çš„é—®å€™\n  assert_eq(\"Hello, ä¸­æ–‡!\", greet(\"ä¸­æ–‡\"))\n  assert_eq(\"Hello, English!\", greet(\"English\"))\n  assert_eq(\"Hello, æ—¥æœ¬èª!\", greet(\"æ—¥æœ¬èª\"))\n  assert_eq(\"Hello, í•œêµ­ì–´!\", greet(\"í•œêµ­ì–´\"))\n  assert_eq(\"Hello, EspaÃ±ol!\", greet(\"EspaÃ±ol\"))\n  \n  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²\n  assert_eq(\"Hello, user@domain.com!\", greet(\"user@domain.com\"))\n  assert_eq(\"Hello, #hashtag!\", greet(\"#hashtag\"))\n  assert_eq(\"Hello, $money!\", greet(\"$money\"))\n}\n\n// æµ‹è¯•æ•°è®ºåŸºç¡€ï¼šæœ€å¤§å…¬çº¦æ•°ç›¸å…³çš„è¿ç®—\n///|\ntest \"number_theory_basics\" {\n  // æµ‹è¯•æ¬§å‡ é‡Œå¾—ç®—æ³•çš„ç›¸å…³è¿ç®—\n  // è¾—è½¬ç›¸é™¤æ³•ä¸­çš„å‡æ³•è¿ç®—ï¼ˆç”¨åŠ æ³•å®ç°ï¼‰\n  let a = 48\n  let b = 18\n  \n  // a - b = a + (-1 * b)\n  let a_minus_b = add(a, multiply(-1, b))\n  assert_eq(30, a_minus_b)\n  \n  // ç»§ç»­è¾—è½¬ç›¸é™¤\n  let b_minus_remainder = add(b, multiply(-2, 12))\n  assert_eq(-6, b_minus_remainder)\n}\n\n// æµ‹è¯•å‡ ä½•è®¡ç®—ï¼šä¸‰è§’å½¢é¢ç§¯\n///|\ntest \"triangle_area_calculation\" {\n  // ä½¿ç”¨æµ·ä¼¦å…¬å¼ï¼šé¢ç§¯ = âˆš(s(s-a)(s-b)(s-c))\n  // å…¶ä¸­ s = (a + b + c) / 2 æ˜¯åŠå‘¨é•¿\n  // æˆ‘ä»¬åªè®¡ç®—ä¸­é—´æ­¥éª¤ï¼Œä¸æ¶‰åŠå¼€æ–¹\n  \n  let a = 3\n  let b = 4\n  let c = 5\n  \n  // è®¡ç®—å‘¨é•¿\n  let perimeter = add(add(a, b), c)\n  assert_eq(12, perimeter)\n  \n  // è®¡ç®—åŠå‘¨é•¿çš„2å€ï¼ˆé¿å…é™¤æ³•ï¼‰\n  let semi_perimeter_times_2 = perimeter\n  assert_eq(12, semi_perimeter_times_2)\n  \n  // è®¡ç®—å„é¡¹\n  let s_minus_a = add(multiply(perimeter, 1), multiply(-2, a))\n  let s_minus_b = add(multiply(perimeter, 1), multiply(-2, b))\n  let s_minus_c = add(multiply(perimeter, 1), multiply(-2, c))\n  \n  assert_eq(6, s_minus_a)\n  assert_eq(4, s_minus_b)\n  assert_eq(2, s_minus_c)\n}","// é¢å¤–æµ‹è¯•ç”¨ä¾‹ - è¡¥å……ç°æœ‰æµ‹è¯•çš„è¦†ç›–èŒƒå›´\n\n///|\ntest \"fibonacci_sequence_operations\" {\n  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­çš„è¿ç®—\n  let fib_10 = 55\n  let fib_11 = 89\n  let fib_12 = 144\n  \n  // æ–æ³¢é‚£å¥‘æ•°åˆ—æ€§è´¨ï¼šF(n) + F(n+1) = F(n+2)\n  assert_eq(fib_12, add(fib_10, fib_11))\n  \n  // æ–æ³¢é‚£å¥‘æ•°åˆ—ä¹˜æ³•æ€§è´¨\n  assert_eq(4895, multiply(fib_10, fib_11))\n}\n\n///|\ntest \"prime_number_operations\" {\n  // æµ‹è¯•è´¨æ•°è¿ç®—\n  let prime_7 = 7\n  let prime_11 = 11\n  let prime_13 = 13\n  let prime_17 = 17\n  \n  // è´¨æ•°åŠ æ³•\n  assert_eq(18, add(prime_7, prime_11))\n  assert_eq(24, add(prime_11, prime_13))\n  \n  // è´¨æ•°ä¹˜æ³•\n  assert_eq(77, multiply(prime_7, prime_11))\n  assert_eq(143, multiply(prime_11, prime_13))\n  assert_eq(221, multiply(prime_13, prime_17))\n}\n\n///|\ntest \"geometric_progression\" {\n  // æµ‹è¯•ç­‰æ¯”æ•°åˆ—è¿ç®—\n  let first_term = 3\n  let ratio = 4\n  \n  // ç”Ÿæˆç­‰æ¯”æ•°åˆ—ï¼š3, 12, 48, 192, 768\n  let term_2 = multiply(first_term, ratio)      // 12\n  let term_3 = multiply(term_2, ratio)          // 48\n  let term_4 = multiply(term_3, ratio)          // 192\n  let term_5 = multiply(term_4, ratio)          // 768\n  \n  assert_eq(12, term_2)\n  assert_eq(48, term_3)\n  assert_eq(192, term_4)\n  assert_eq(768, term_5)\n  \n  // æµ‹è¯•ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼ˆå‰5é¡¹ï¼‰\n  let sum = add(first_term, add(term_2, add(term_3, add(term_4, term_5))))\n  assert_eq(1023, sum)\n}\n\n///|\ntest \"alternating_sign_sequence\" {\n  // æµ‹è¯•äº¤æ›¿ç¬¦å·åºåˆ—çš„è¿ç®—\n  let mut result = 0\n  \n  // äº¤æ›¿åŠ å‡ï¼š+1 -2 +3 -4 +5 -6 +7 -8 +9 -10\n  result = add(result, 1)    // 1\n  result = add(result, -2)   // -1\n  result = add(result, 3)    // 2\n  result = add(result, -4)   // -2\n  result = add(result, 5)    // 3\n  result = add(result, -6)   // -3\n  result = add(result, 7)    // 4\n  result = add(result, -8)   // -4\n  result = add(result, 9)    // 5\n  result = add(result, -10)  // -5\n  \n  assert_eq(-5, result)\n}\n\n///|\ntest \"nested_function_calls\" {\n  // æµ‹è¯•åµŒå¥—å‡½æ•°è°ƒç”¨\n  let a = 5\n  let b = 10\n  let c = 15\n  let d = 20\n  \n  // å¤æ‚åµŒå¥—ï¼šadd(multiply(a, b), multiply(c, d))\n  let result1 = add(multiply(a, b), multiply(c, d))\n  assert_eq(350, result1)  // 5*10 + 15*20 = 50 + 300 = 350\n  \n  // æ›´å¤æ‚çš„åµŒå¥—ï¼šmultiply(add(a, b), add(c, d))\n  let result2 = multiply(add(a, b), add(c, d))\n  assert_eq(525, result2)  // (5+10)*(15+20) = 15*35 = 525\n  \n  // ä¸‰å±‚åµŒå¥—ï¼šadd(multiply(a, add(b, c)), d)\n  let result3 = add(multiply(a, add(b, c)), d)\n  assert_eq(145, result3)  // 5*(10+15) + 20 = 5*25 + 20 = 125 + 20 = 145\n}\n\n///|\ntest \"string_length_edge_cases\" {\n  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œæƒ…å†µ\n  let empty = \"\"\n  let single_char = \"A\"\n  let long_string = \"This is a very long string to test the greet function with various length inputs\"\n  \n  assert_eq(\"Hello, !\", greet(empty))\n  assert_eq(\"Hello, A!\", greet(single_char))\n  assert_eq(\"Hello, This is a very long string to test the greet function with various length inputs!\", greet(long_string))\n}\n\n///|\ntest \"mathematical_identities\" {\n  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼\n  let x = 42\n  let y = 17\n  \n  // å¹³æ–¹å·®å…¬å¼ï¼š(x+y)*(x-y) = xÂ² - yÂ²\n  let diff_of_squares = multiply(add(x, y), add(x, -y))\n  let x_squared = multiply(x, x)\n  let y_squared = multiply(y, y)\n  let expected = add(x_squared, -y_squared)\n  \n  assert_eq(expected, diff_of_squares)\n  \n  // ä¸¤æ•°å’Œçš„å¹³æ–¹ï¼š(x+y)Â² = xÂ² + 2xy + yÂ²\n  let sum_squared = multiply(add(x, y), add(x, y))\n  let two_xy = multiply(2, multiply(x, y))\n  let sum_expected = add(add(x_squared, two_xy), y_squared)\n  \n  assert_eq(sum_expected, sum_squared)\n}\n\n///|\ntest \"overflow_recovery_patterns\" {\n  // æµ‹è¯•æº¢å‡ºæ¢å¤æ¨¡å¼\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // ä»æº¢å‡ºçŠ¶æ€æ¢å¤\n  let mut value = max_val\n  value = add(value, 100)  // åº”è¯¥ä¿æŒæœ€å¤§å€¼\n  assert_eq(max_val, value)\n  \n  value = add(value, -100)  // åº”è¯¥å¯ä»¥æ­£å¸¸å‡æ³•\n  assert_eq(max_val - 100, value)\n  \n  // ä»è´Ÿæº¢å‡ºçŠ¶æ€æ¢å¤\n  value = min_val\n  value = add(value, -100)  // åº”è¯¥ä¿æŒæœ€å°å€¼\n  assert_eq(min_val, value)\n  \n  value = add(value, 100)  // åº”è¯¥å¯ä»¥æ­£å¸¸åŠ æ³•\n  assert_eq(min_val + 100, value)\n}\n\n///|\ntest \"circular_reference_patterns\" {\n  // æµ‹è¯•å¾ªç¯å¼•ç”¨æ¨¡å¼\n  let a = 10\n  let b = 20\n  let c = 30\n  \n  // åˆ›å»ºå¾ªç¯è®¡ç®—ï¼ša -> b -> c -> a\n  let step1 = add(a, b)     // 30\n  let step2 = multiply(step1, c)  // 900\n  let step3 = add(step2, -a)  // 890\n  let final_result = multiply(step3, b)  // 17800\n  \n  assert_eq(17800, final_result)\n}","// ç»¼åˆåº”ç”¨æµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹å®é™…åœºæ™¯çš„æµ‹è¯•\n\n///|\ntest \"complex_financial_calculations\" {\n  // æµ‹è¯•è´·æ¬¾è®¡ç®—ï¼šæœ¬é‡‘ + åˆ©æ¯ = æ€»è¿˜æ¬¾é¢\n  let principal = 100000\n  let interest_rate = 5  // 5%\n  let years = 3\n  \n  // è®¡ç®—æ€»åˆ©æ¯ï¼šæœ¬é‡‘ * åˆ©ç‡ * å¹´é™ / 100\n  let total_interest = multiply(multiply(principal, interest_rate), years)\n  // è®¡ç®—æ€»è¿˜æ¬¾é¢ï¼šæœ¬é‡‘ + æ€»åˆ©æ¯/100\n  let total_payment = add(multiply(principal, 100), total_interest)\n  \n  // éªŒè¯è®¡ç®—ç»“æœ\n  assert_eq(11500000, total_payment)\n}\n\n///|\ntest \"string_processing_edge_cases\" {\n  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²\n  assert_eq(\"Hello, @#$%!\", greet(\"@#$%\"))\n  assert_eq(\"Hello,   !\", greet(\"  \"))  // ç©ºæ ¼\n  assert_eq(\"Hello, \\n\\t!\", greet(\"\\n\\t\"))  // æ¢è¡Œå’Œåˆ¶è¡¨ç¬¦\n  assert_eq(\"Hello, ä¸­æ–‡æµ‹è¯•!\", greet(\"ä¸­æ–‡æµ‹è¯•\"))  // ä¸­æ–‡å­—ç¬¦\n  assert_eq(\"Hello, Ã©Ã±Ã§Ã¶dÃ©d!\", greet(\"Ã©Ã±Ã§Ã¶dÃ©d\"))  // å¸¦é‡éŸ³ç¬¦å·\n}\n\n///|\ntest \"mathematical_sequence_calculations\" {\n  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—ç›¸å…³è®¡ç®—\n  let fib1 = 1\n  let fib2 = 1\n  let fib3 = add(fib1, fib2)  // 2\n  let fib4 = add(fib2, fib3)  // 3\n  let fib5 = add(fib3, fib4)  // 5\n  \n  // éªŒè¯æ–æ³¢é‚£å¥‘æ•°åˆ—\n  assert_eq(2, fib3)\n  assert_eq(3, fib4)\n  assert_eq(5, fib5)\n  \n  // æµ‹è¯•å¹³æ–¹æ•°åˆ—\n  let square1 = multiply(1, 1)\n  let square2 = multiply(2, 2)\n  let square3 = multiply(3, 3)\n  let square4 = multiply(4, 4)\n  \n  assert_eq(1, square1)\n  assert_eq(4, square2)\n  assert_eq(9, square3)\n  assert_eq(16, square4)\n}\n\n///|\ntest \"geometry_calculations\" {\n  // æµ‹è¯•å‡ ä½•è®¡ç®—ï¼šåœ†çš„é¢ç§¯å’Œå‘¨é•¿\n  // ä½¿ç”¨è¿‘ä¼¼å€¼ Ï€ â‰ˆ 22/7 æ¥é¿å…æµ®ç‚¹æ•°\n  let radius = 7\n  let pi_numerator = 22\n  \n  // é¢ç§¯ = Ï€ * rÂ²\n  let area_times_denominator = multiply(pi_numerator, multiply(radius, radius))\n  // å‘¨é•¿ = 2 * Ï€ * r\n  let circumference_times_denominator = multiply(2, multiply(pi_numerator, radius))\n  \n  // éªŒè¯ç»“æœ\n  assert_eq(1078, area_times_denominator)  // 22/7 * 49 = 154\n  assert_eq(308, circumference_times_denominator)  // 2 * 22/7 * 7 = 44\n  \n  // æµ‹è¯•çŸ©å½¢å¯¹è§’çº¿é•¿åº¦å¹³æ–¹ï¼šaÂ² + bÂ²\n  let width = 3\n  let height = 4\n  let diagonal_squared = add(multiply(width, width), multiply(height, height))\n  assert_eq(25, diagonal_squared)  // 3Â² + 4Â² = 9 + 16 = 25\n}\n\n///|\ntest \"statistical_calculations\" {\n  // æµ‹è¯•åŸºæœ¬ç»Ÿè®¡è®¡ç®—\n  let numbers = [10, 20, 30, 40, 50]\n  \n  // è®¡ç®—æ€»å’Œ\n  let sum = add(add(add(add(numbers[0], numbers[1]), numbers[2]), numbers[3]), numbers[4])\n  assert_eq(150, sum)\n  \n  // è®¡ç®—å¹³å‡å€¼ï¼ˆä¹˜ä»¥æ•°é‡é¿å…é™¤æ³•ï¼‰\n  let sum_times_count = multiply(sum, 5)  // 150 * 5 = 750\n  assert_eq(750, sum_times_count)\n  \n  // è®¡ç®—æ–¹å·®ï¼šå¹³æ–¹å·®çš„å¹³å‡å€¼\n  let mean = 30\n  let diff1 = add(numbers[0], multiply(-1, mean))  // 10 - 30 = -20\n  let diff2 = add(numbers[1], multiply(-1, mean))  // 20 - 30 = -10\n  let diff3 = add(numbers[2], multiply(-1, mean))  // 30 - 30 = 0\n  let diff4 = add(numbers[3], multiply(-1, mean))  // 40 - 30 = 10\n  let diff5 = add(numbers[4], multiply(-1, mean))  // 50 - 30 = 20\n  \n  let sum_of_squares = add(add(add(add(multiply(diff1, diff1), multiply(diff2, diff2)), multiply(diff3, diff3)), multiply(diff4, diff4)), multiply(diff5, diff5))\n  assert_eq(1000, sum_of_squares)  // 400 + 100 + 0 + 100 + 400 = 1000\n}\n\n///|\ntest \"time_and_date_calculations\" {\n  // æµ‹è¯•æ—¶é—´è®¡ç®—ï¼ˆä»¥åˆ†é’Ÿä¸ºå•ä½ï¼‰\n  let hours = 2\n  let minutes = 30\n  let total_minutes = add(multiply(hours, 60), minutes)\n  assert_eq(150, total_minutes)\n  \n  // æµ‹è¯•å¤©æ•°è®¡ç®—\n  let days = 365\n  let weeks = multiply(52, 7)  // 52å‘¨ * 7å¤©\n  let remaining_days = add(days, multiply(-1, weeks))\n  assert_eq(1, remaining_days)  // 365 - 364 = 1\n  \n  // æµ‹è¯•é—°å¹´è®¡ç®—ï¼ˆ4å¹´ä¸€é—°ï¼‰\n  let leap_years_divided_by_4 = 250  // 10å¹´ä¸­æœ‰2.5ä¸ªé—°å¹´\n  assert_eq(250, leap_years_divided_by_4)\n}\n\n///|\ntest \"physics_calculations\" {\n  // æµ‹è¯•åŸºæœ¬ç‰©ç†å…¬å¼\n  // é€Ÿåº¦ = è·ç¦» / æ—¶é—´ï¼ˆç”¨ä¹˜æ³•é¿å…é™¤æ³•ï¼‰\n  let distance = 100\n  let speed_times_time = multiply(distance, 1)  // é€Ÿåº¦ * 5 = 100\n  assert_eq(100, speed_times_time)\n  \n  // åŠ¨èƒ½ = 1/2 * m * vÂ²ï¼ˆç”¨ä¹˜æ³•é¿å…é™¤æ³•ï¼‰\n  let mass = 10\n  let velocity = 5\n  let kinetic_energy_times_2 = multiply(multiply(mass, velocity), velocity)\n  assert_eq(250, kinetic_energy_times_2)  // 10 * 25 = 250\n  \n  // åŠ› = è´¨é‡ * åŠ é€Ÿåº¦\n  let acceleration = 2\n  let force = multiply(mass, acceleration)\n  assert_eq(20, force)\n}\n\n///|\ntest \"computer_science_calculations\" {\n  // æµ‹è¯•è®¡ç®—æœºç§‘å­¦ç›¸å…³è®¡ç®—\n  // äºŒè¿›åˆ¶è½¬æ¢ï¼š2^n\n  let power_of_2_3 = multiply(2, multiply(2, 2))  // 2Â³ = 8\n  let power_of_2_8 = multiply(256, 1)  // 2â¸ = 256\n  \n  assert_eq(8, power_of_2_3)\n  assert_eq(256, power_of_2_8)\n  \n  // é˜¶ä¹˜è®¡ç®—ï¼šn!\n  let fact_3 = multiply(3, multiply(2, 1))  // 3! = 6\n  let fact_4 = multiply(4, fact_3)  // 4! = 24\n  let fact_5 = multiply(5, fact_4)  // 5! = 120\n  \n  assert_eq(6, fact_3)\n  assert_eq(24, fact_4)\n  assert_eq(120, fact_5)\n}\n\n///|\ntest \"complex_edge_case_combinations\" {\n  // æµ‹è¯•å¤æ‚çš„è¾¹ç•Œæƒ…å†µç»„åˆ\n  // æœ€å°å€¼ä¸å„ç§å€¼çš„è¿ç®—ç»„åˆ\n  let min_val = -2147483648\n  let max_val = 2147483647\n  \n  // æœ€å°å€¼ + 1 + 1 + ... + 1 (è¿ç»­åŠ æ³•)\n  let result1 = add(add(min_val, 1), 1)\n  assert_eq(-2147483646, result1)\n  \n  // æœ€å¤§å€¼ - 1 - 1 - ... - 1 (è¿ç»­å‡æ³•ï¼Œç”¨åŠ è´Ÿæ•°å®ç°)\n  let result2 = add(add(max_val, -1), -1)\n  assert_eq(2147483645, result2)\n  \n  // å¤æ‚ä¹˜æ³•ç»„åˆï¼š(a * b) * c\n  let a = 1000\n  let b = 2000\n  let c = 3\n  let complex_product = multiply(multiply(a, b), c)\n  assert_eq(6000000, complex_product)\n  \n  // å­—ç¬¦ä¸²é•¿åº¦ç›¸å…³çš„è¾¹ç•Œæµ‹è¯•\n  let very_long_name = \"ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  let long_greeting = greet(very_long_name)\n  assert_eq(true, long_greeting.length() > 50)\n}","// ä¿®æ­£ç‰ˆç®€æ´æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªç²¾å¿ƒè®¾è®¡çš„æµ‹è¯•\n\n// æµ‹è¯•1: åŠ æ³•å•ä½å…ƒæ€§è´¨\n///|\ntest \"correct_add_identity_element\" {\n  assert_eq(42, add(42, 0))\n  assert_eq(42, add(0, 42))\n  assert_eq(-17, add(-17, 0))\n  assert_eq(0, add(0, 0))\n}\n\n// æµ‹è¯•2: ä¹˜æ³•å•ä½å…ƒæ€§è´¨\n///|\ntest \"correct_multiply_identity_element\" {\n  assert_eq(42, multiply(42, 1))\n  assert_eq(42, multiply(1, 42))\n  assert_eq(-17, multiply(-17, 1))\n  assert_eq(0, multiply(0, 1))\n}\n\n// æµ‹è¯•3: ä¹˜æ³•é›¶å…ƒç´ æ€§è´¨\n///|\ntest \"correct_multiply_zero_element\" {\n  assert_eq(0, multiply(42, 0))\n  assert_eq(0, multiply(0, 42))\n  assert_eq(0, multiply(-17, 0))\n  assert_eq(0, multiply(0, 0))\n}\n\n// æµ‹è¯•4: åŠ æ³•äº¤æ¢å¾‹\n///|\ntest \"correct_addition_commutative\" {\n  assert_eq(add(15, 27), add(27, 15))\n  assert_eq(add(-10, 25), add(25, -10))\n  assert_eq(add(-8, -12), add(-12, -8))\n}\n\n// æµ‹è¯•5: ä¹˜æ³•äº¤æ¢å¾‹\n///|\ntest \"correct_multiplication_commutative\" {\n  assert_eq(multiply(6, 7), multiply(7, 6))\n  assert_eq(multiply(-4, 9), multiply(9, -4))\n  assert_eq(multiply(-3, -5), multiply(-5, -3))\n}\n\n// æµ‹è¯•6: åŠ æ³•ç»“åˆå¾‹\n///|\ntest \"correct_addition_associative\" {\n  let a = 10\n  let b = 20\n  let c = 30\n  assert_eq(add(add(a, b), c), add(a, add(b, c)))\n  \n  let x = -5\n  let y = 15\n  let z = -10\n  assert_eq(add(add(x, y), z), add(x, add(y, z)))\n}\n\n// æµ‹è¯•7: ä¹˜æ³•ç»“åˆå¾‹\n///|\ntest \"correct_multiplication_associative\" {\n  let a = 2\n  let b = 3\n  let c = 4\n  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))\n  \n  let x = -2\n  let y = 5\n  let z = -3\n  assert_eq(multiply(multiply(x, y), z), multiply(x, multiply(y, z)))\n}\n\n// æµ‹è¯•8: ä¹˜æ³•åˆ†é…å¾‹\n///|\ntest \"correct_multiplication_distributive\" {\n  let a = 5\n  let b = 7\n  let c = 3\n  assert_eq(multiply(a, add(b, c)), add(multiply(a, b), multiply(a, c)))\n  \n  let x = -4\n  let y = 6\n  let z = -2\n  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))\n}\n\n// æµ‹è¯•9: å­—ç¬¦ä¸²å¤„ç†åŸºç¡€\n///|\ntest \"correct_string_handling_basic\" {\n  assert_eq(\"Hello, Alice!\", greet(\"Alice\"))\n  assert_eq(\"Hello, Bob!\", greet(\"Bob\"))\n  assert_eq(\"Hello, !\", greet(\"\"))\n  assert_eq(\"Hello, 123!\", greet(\"123\"))\n}\n\n// æµ‹è¯•10: æ•°å­¦æ’ç­‰å¼éªŒè¯\n///|\ntest \"correct_mathematical_identities\" {\n  // éªŒè¯ (a+b)Â² = aÂ² + 2ab + bÂ²\n  let a = 3\n  let b = 4\n  let left = multiply(add(a, b), add(a, b))\n  let right = add(add(multiply(a, a), multiply(2, multiply(a, b))), multiply(b, b))\n  assert_eq(left, right)\n  \n  // éªŒè¯ aÂ² - bÂ² = (a+b)(a-b)\n  let x = 5\n  let y = 2\n  let diff_left = add(multiply(x, x), multiply(-1, multiply(y, y)))\n  let diff_right = multiply(add(x, y), add(x, multiply(-1, y)))\n  assert_eq(diff_left, diff_right)\n}","// å¢å¼ºè¦†ç›–æµ‹è¯•ç”¨ä¾‹ - è¡¥å……ç°æœ‰æµ‹è¯•æœªè¦†ç›–çš„åœºæ™¯\n\n// æµ‹è¯•ç”¨ä¾‹ 1: æç«¯è¾¹ç•Œå€¼ç»„åˆæµ‹è¯•\n///|\ntest \"enhanced_extreme_boundary_combinations\" {\n  // æµ‹è¯•å¤šä¸ªè¾¹ç•Œå€¼çš„ç»„åˆè¿ç®—\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // (æœ€å¤§å€¼ + æœ€å°å€¼) + 1 = -1 + 1 = 0\n  let step1 = add(max_val, min_val)\n  let result1 = add(step1, 1)\n  assert_eq(0, result1)\n  \n  // (æœ€å°å€¼ + 1) + (æœ€å¤§å€¼ - 1) = -2147483647 + 2147483646 = -1\n  let step2 = add(min_val, 1)\n  let step3 = add(max_val, -1)\n  let result2 = add(step2, step3)\n  assert_eq(-1, result2)\n  \n  // æœ€å°å€¼ * 0 + æœ€å¤§å€¼ = 0 + 2147483647 = 2147483647\n  let step4 = multiply(min_val, 0)\n  let result3 = add(step4, max_val)\n  assert_eq(max_val, result3)\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 2: æ•°å€¼ç¨³å®šæ€§æµ‹è¯•\n///|\ntest \"enhanced_numerical_stability_tests\" {\n  // æµ‹è¯•è¿ç»­è¿ç®—çš„ç¨³å®šæ€§\n  let mut accumulator = 0\n  \n  // è¿ç»­åŠ 1ï¼Œ1000æ¬¡\n  for i = 0; i < 1000; i = i + 1 {\n    accumulator = add(accumulator, 1)\n  }\n  assert_eq(1000, accumulator)\n  \n  // è¿ç»­å‡1ï¼Œ1000æ¬¡\n  for i = 0; i < 1000; i = i + 1 {\n    accumulator = add(accumulator, -1)\n  }\n  assert_eq(0, accumulator)\n  \n  // æµ‹è¯•ä¹˜æ³•çš„ç´¯ç§¯æ•ˆåº”\n  let mut product = 1\n  for i = 1; i <= 5; i = i + 1 {\n    product = multiply(product, i)\n  }\n  assert_eq(120, product) // 5! = 120\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 3: å¤åˆå‡½æ•°æµ‹è¯•\n///|\ntest \"enhanced_composite_function_tests\" {\n  // æµ‹è¯•å‡½æ•°çš„ç»„åˆä½¿ç”¨\n  \n  // è®¡ç®— (a + b) * (c + d)\n  let a = 10\n  let b = 20\n  let c = 3\n  let d = 7\n  \n  let sum1 = add(a, b)  // 30\n  let sum2 = add(c, d)  // 10\n  let result = multiply(sum1, sum2)  // 30 * 10 = 300\n  assert_eq(300, result)\n  \n  // è®¡ç®— a * b + c * d\n  let product1 = multiply(a, b)  // 200\n  let product2 = multiply(c, d)  // 21\n  let result2 = add(product1, product2)  // 200 + 21 = 221\n  assert_eq(221, result2)\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 4: å­—ç¬¦ä¸²è¾¹ç•Œå’Œç‰¹æ®Šå¤„ç†æµ‹è¯•\n///|\ntest \"enhanced_string_boundary_and_special_handling\" {\n  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²çš„å¤„ç†\n  let very_long_name = \"VeryLongNameThatExceedsNormalExpectationsAndContainsMultipleWords\"\n  let long_greeting = greet(very_long_name)\n  assert_eq(true, long_greeting.contains(\"VeryLongNameThatExceedsNormalExpectationsAndContainsMultipleWords\"))\n  \n  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²\n  let name_with_spaces = \"John Doe Smith\"\n  let spaced_greeting = greet(name_with_spaces)\n  assert_eq(\"Hello, John Doe Smith!\", spaced_greeting)\n  \n  // æµ‹è¯•åªåŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²\n  let spaces_only = \"   \"\n  let spaces_greeting = greet(spaces_only)\n  assert_eq(\"Hello,    !\", spaces_greeting)\n  \n  // æµ‹è¯•åŒ…å«æ•°å­—å’Œå­—æ¯æ··åˆçš„å­—ç¬¦ä¸²\n  let mixed_string = \"User123ABC\"\n  let mixed_greeting = greet(mixed_string)\n  assert_eq(\"Hello, User123ABC!\", mixed_greeting)\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 5: æ•°å­¦æ’ç­‰å¼éªŒè¯æµ‹è¯•\n///|\ntest \"enhanced_mathematical_identity_verification\" {\n  // éªŒè¯å¹³æ–¹å·®å…¬å¼: aÂ² - bÂ² = (a + b) * (a - b)\n  let a = 15\n  let b = 8\n  \n  // ç›´æ¥è®¡ç®— aÂ² - bÂ²\n  let a_squared = multiply(a, a)  // 225\n  let b_squared = multiply(b, b)  // 64\n  let direct_result = add(a_squared, multiply(-1, b_squared))  // 225 - 64 = 161\n  \n  // ä½¿ç”¨å¹³æ–¹å·®å…¬å¼è®¡ç®—\n  let sum_ab = add(a, b)  // 23\n  let diff_ab = add(a, multiply(-1, b))  // 7\n  let formula_result = multiply(sum_ab, diff_ab)  // 23 * 7 = 161\n  \n  assert_eq(direct_result, formula_result)\n  \n  // éªŒè¯ç«‹æ–¹å’Œå…¬å¼: aÂ³ + bÂ³ = (a + b) * (aÂ² - ab + bÂ²)\n  let x = 3\n  let y = 2\n  \n  // ç›´æ¥è®¡ç®—\n  let x_cubed = multiply(x, multiply(x, x))  // 27\n  let y_cubed = multiply(y, multiply(y, y))  // 8\n  let direct_cube_sum = add(x_cubed, y_cubed)  // 35\n  \n  // ä½¿ç”¨ç«‹æ–¹å’Œå…¬å¼\n  let sum_xy = add(x, y)  // 5\n  let x_squared = multiply(x, x)  // 9\n  let y_squared = multiply(y, y)  // 4\n  let xy = multiply(x, y)  // 6\n  let formula_inner = add(add(x_squared, multiply(-1, xy)), y_squared)  // 9 - 6 + 4 = 7\n  let formula_cube_sum = multiply(sum_xy, formula_inner)  // 5 * 7 = 35\n  \n  assert_eq(direct_cube_sum, formula_cube_sum)\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 6: å®é™…å•†ä¸šåœºæ™¯æµ‹è¯•\n///|\ntest \"enhanced_business_scenario_tests\" {\n  // åœºæ™¯1: è®¡ç®—æŠ˜æ‰£ä»·æ ¼\n  let original_price = 1000\n  let discount_percentage = 15  // 15%æŠ˜æ‰£\n  let discount_factor_numerator = 85  // 100% - 15% = 85%\n  let discount_factor_denominator = 100\n  \n  // æŠ˜æ‰£åä»·æ ¼ * 100 = åŸä»· * 85\n  let discounted_price_times_100 = multiply(original_price, discount_factor_numerator)\n  assert_eq(85000, discounted_price_times_100)  // 850.00\n  \n  // åœºæ™¯2: è®¡ç®—å¤åˆ©\n  let principal = 10000\n  let rate_numerator = 5  // 5%\n  let rate_denominator = 100\n  let years = 3\n  \n  // å¤åˆ©å…¬å¼: P * (1 + r)^nï¼Œç®€åŒ–è®¡ç®—\n  let year1_total_times_100 = add(multiply(principal, rate_denominator), multiply(principal, rate_numerator))\n  let year2_total_times_100 = add(multiply(year1_total_times_100, rate_denominator), multiply(year1_total_times_100, rate_numerator))\n  let year3_total_times_100 = add(multiply(year2_total_times_100, rate_denominator), multiply(year2_total_times_100, rate_numerator))\n  \n  // éªŒè¯è®¡ç®—è¿‡ç¨‹æ­£ç¡®æ€§\n  assert_eq(1000000, multiply(principal, rate_denominator))  // åˆå§‹å€¼éªŒè¯\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 7: ç®—æ³•æ•ˆç‡æµ‹è¯•\n///|\ntest \"enhanced_algorithm_efficiency_tests\" {\n  // æµ‹è¯•ä¸åŒè®¡ç®—æ–¹æ³•çš„æ•ˆç‡\n  \n  // æ–¹æ³•1: é€ä¸ªç›¸åŠ \n  let mut sum1 = 0\n  for i = 1; i <= 100; i = i + 1 {\n    sum1 = add(sum1, i)\n  }\n  \n  // æ–¹æ³•2: ä½¿ç”¨æ±‚å’Œå…¬å¼ n*(n+1)/2\n  let n = 100\n  let sum2_times_2 = multiply(n, add(n, 1))  // 100 * 101 = 10100\n  \n  // éªŒè¯ä¸¤ç§æ–¹æ³•ç»“æœä¸€è‡´\n  assert_eq(5050, sum1)\n  assert_eq(10100, sum2_times_2)\n  \n  // æµ‹è¯•ä¹˜æ³•çš„ä¸åŒè®¡ç®—é¡ºåº\n  let a = 2\n  let b = 3\n  let c = 4\n  let d = 5\n  \n  // (a * b) * (c * d)\n  let method1 = multiply(multiply(a, b), multiply(c, d))\n  \n  // a * b * c * d\n  let method2 = multiply(multiply(multiply(a, b), c), d)\n  \n  assert_eq(method1, method2)\n  assert_eq(120, method1)  // 2 * 3 * 4 * 5 = 120\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 8: é”™è¯¯æ¢å¤å’Œè¾¹ç•Œå¤„ç†æµ‹è¯•\n///|\ntest \"enhanced_error_recovery_and_boundary_handling\" {\n  // æµ‹è¯•åœ¨æ¥è¿‘æº¢å‡ºæ—¶çš„è¡Œä¸º\n  \n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // ä»æœ€å¤§å€¼å¼€å§‹å‡ï¼Œç›´åˆ°0\n  let mut current = max_val\n  let mut steps = 0\n  while current > 0 && steps < 10 {  // é™åˆ¶æ­¥æ•°é¿å…æ— é™å¾ªç¯\n    current = add(current, -100000000)  // å‡å»1äº¿\n    steps = add(steps, 1)\n  }\n  \n  // éªŒè¯ç¡®å®åœ¨è¿›è¡Œé€’å‡\n  assert_eq(true, current < max_val)\n  assert_eq(10, steps)\n  \n  // æµ‹è¯•ä¹˜æ³•çš„é›¶å€¼ä¼ æ’­\n  let zero_product1 = multiply(0, max_val)\n  let zero_product2 = multiply(min_val, 0)\n  let zero_product3 = multiply(0, 0)\n  \n  assert_eq(0, zero_product1)\n  assert_eq(0, zero_product2)\n  assert_eq(0, zero_product3)\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 9: å¤šæ­¥éª¤è®¡ç®—éªŒè¯æµ‹è¯•\n///|\ntest \"enhanced_multi_step_calculation_verification\" {\n  // å¤æ‚çš„å¤šæ­¥éª¤è®¡ç®—åœºæ™¯\n  \n  // åœºæ™¯: è®¡ç®—è´­ç‰©è½¦çš„æœ€ç»ˆæ€»ä»·ï¼ŒåŒ…æ‹¬ç¨è´¹å’ŒæŠ˜æ‰£\n  \n  let item1_price = 299\n  let item1_quantity = 2\n  let item2_price = 199\n  let item2_quantity = 3\n  let item3_price = 99\n  let item3_quantity = 1\n  \n  // è®¡ç®—å„å•†å“å°è®¡\n  let subtotal1 = multiply(item1_price, item1_quantity)  // 598\n  let subtotal2 = multiply(item2_price, item2_quantity)  // 597\n  let subtotal3 = multiply(item3_price, item3_quantity)  // 99\n  \n  // è®¡ç®—å•†å“æ€»è®¡\n  let items_total = add(add(subtotal1, subtotal2), subtotal3)  // 1294\n  \n  // è®¡ç®—ç¨è´¹ (8%)\n  let tax_numerator = 8\n  let tax_denominator = 100\n  let tax_times_denominator = multiply(items_total, tax_numerator)  // 1294 * 8 = 10352\n  \n  // è®¡ç®—æ€»ä»· (å•†å“ + ç¨è´¹)\n  let total_times_denominator = add(multiply(items_total, tax_denominator), tax_times_denominator)\n  \n  // éªŒè¯: 1294 * 100 + 1294 * 8 = 129400 + 10352 = 139752\n  assert_eq(139752, total_times_denominator)\n}\n\n// æµ‹è¯•ç”¨ä¾‹ 10: æ•°æ®æ¨¡å¼éªŒè¯æµ‹è¯•\n///|\ntest \"enhanced_data_pattern_verification\" {\n  // æµ‹è¯•æ•°å€¼æ¨¡å¼å’Œè§„å¾‹\n  \n  // æµ‹è¯•ç­‰å·®æ•°åˆ—\n  let first_term = 3\n  let common_difference = 5\n  let n_terms = 5\n  \n  // è®¡ç®—ç¬¬né¡¹: a + (n-1)*d\n  let nth_term = add(first_term, multiply(add(n_terms, -1), common_difference))\n  assert_eq(23, nth_term)  // 3 + (5-1)*5 = 3 + 20 = 23\n  \n  // è®¡ç®—å‰né¡¹å’Œ: n/2 * (2a + (n-1)*d)\n  let sum_times_2 = multiply(n_terms, add(multiply(2, first_term), multiply(add(n_terms, -1), common_difference)))\n  assert_eq(130, sum_times_2)  // 5/2 * (6 + 20) = 5/2 * 26 = 130\n  \n  // æµ‹è¯•ç­‰æ¯”æ•°åˆ—\n  let geo_first = 2\n  let geo_ratio = 3\n  let geo_n = 4\n  \n  // è®¡ç®—ç¬¬né¡¹: a * r^(n-1)\n  let geo_nth = multiply(geo_first, multiply(multiply(geo_ratio, geo_ratio), geo_ratio))\n  assert_eq(54, geo_nth)  // 2 * 3^3 = 2 * 27 = 54\n  \n  // éªŒè¯å­—ç¬¦ä¸²æ‹¼æ¥çš„æ¨¡å¼\n  let prefix = \"Test\"\n  let suffix = \"Case\"\n  let number = \"123\"\n  \n  // é€æ­¥æ„å»ºå­—ç¬¦ä¸²\n  let step1 = greet(prefix)  // \"Hello, Test!\"\n  let combined = prefix + suffix + number  // \"TestCase123\"\n  let final_greeting = greet(combined)  // \"Hello, TestCase123!\"\n  \n  assert_eq(true, final_greeting.contains(\"TestCase123\"))\n}","// å¢å¼ºæµ‹è¯•ç”¨ä¾‹é›†åˆ\n// åŒ…å«æ›´å¤šè¾¹ç•Œæ¡ä»¶å’Œç‰¹æ®Šæƒ…å†µçš„æµ‹è¯•\n\n///|\ntest \"greet_special_strings\" {\n  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ä¸²è¾“å…¥\n  assert_eq(\"Hello, æ˜Ÿç©º!\", greet(\"æ˜Ÿç©º\"))\n  assert_eq(\"Hello, ğŸŒ™!\", greet(\"ğŸŒ™\"))\n  assert_eq(\"Hello, space   test!\", greet(\"space   test\"))\n  assert_eq(\"Hello, !\", greet(\"\"))\n  assert_eq(\"Hello, !\", greet(\"\"))\n  assert_eq(\"Hello, a!\", greet(\"a\"))\n  assert_eq(\"Hello, 1234567890!\", greet(\"1234567890\"))\n}\n\n///|\ntest \"add_sequence_patterns\" {\n  // æµ‹è¯•è¿ç»­åŠ æ³•çš„æ¨¡å¼\n  assert_eq(15, add(add(5, 5), 5))\n  assert_eq(-15, add(add(-5, -5), -5))\n  assert_eq(0, add(add(2147483647, -2147483647), 0))\n  assert_eq(-2147483648, add(add(-2147483647, -1), 0))\n}\n\n///|\ntest \"multiply_power_patterns\" {\n  // æµ‹è¯•å¹‚æ¬¡ç›¸å…³çš„ä¹˜æ³•æ¨¡å¼\n  assert_eq(16, multiply(multiply(2, 2), multiply(2, 2)))\n  assert_eq(0, multiply(multiply(0, 5), multiply(3, 7)))\n  assert_eq(-2147483648, multiply(multiply(-2, 2), multiply(-2, 1073741824)))\n}\n\n///|\ntest \"add_fibonacci_like\" {\n  // æµ‹è¯•ç±»ä¼¼æ–æ³¢é‚£å¥‘åºåˆ—çš„åŠ æ³•\n  assert_eq(1, add(0, 1))\n  assert_eq(2, add(1, 1))\n  assert_eq(3, add(1, 2))\n  assert_eq(5, add(2, 3))\n  assert_eq(8, add(3, 5))\n  assert_eq(13, add(5, 8))\n}\n\n///|\ntest \"multiply_geometric_series\" {\n  // æµ‹è¯•å‡ ä½•çº§æ•°ä¹˜æ³•\n  assert_eq(2, multiply(1, 2))\n  assert_eq(4, multiply(2, 2))\n  assert_eq(8, multiply(4, 2))\n  assert_eq(16, multiply(8, 2))\n  assert_eq(32, multiply(16, 2))\n}\n\n///|\ntest \"boundary_value_combinations\" {\n  // æµ‹è¯•è¾¹ç•Œå€¼çš„å„ç§ç»„åˆ\n  assert_eq(0, add(multiply(0, 2147483647), multiply(0, -2147483648)))\n  assert_eq(2147483647, add(multiply(1, 2147483647), multiply(0, -2147483648)))\n  assert_eq(-2147483648, add(multiply(0, 2147483647), multiply(1, -2147483648)))\n}\n\n///|\ntest \"negative_zero_scenarios\" {\n  // æµ‹è¯•æ¶‰åŠè´Ÿé›¶çš„åœºæ™¯ï¼ˆè™½ç„¶MoonBitä¸­å¯èƒ½æ²¡æœ‰è´Ÿé›¶æ¦‚å¿µï¼‰\n  assert_eq(0, add(0, 0))\n  assert_eq(0, multiply(0, 0))\n  assert_eq(0, multiply(0, -2147483648))\n  assert_eq(0, multiply(0, 2147483647))\n}\n\n///|\ntest \"large_number_patterns\" {\n  // æµ‹è¯•å¤§æ•°æ¨¡å¼\n  assert_eq(2147483647, add(1073741823, 1073741824))\n  assert_eq(2147483647, add(1000000000, 1147483647))\n  assert_eq(-2147483648, add(-1073741824, -1073741824))\n  assert_eq(-2147483648, add(-1000000000, -1147483648))\n}\n\n///|\ntest \"mixed_operations_stress\" {\n  // æ··åˆè¿ç®—å‹åŠ›æµ‹è¯•\n  let result1 = add(100, multiply(5, 10))\n  assert_eq(150, result1)\n  \n  let result2 = multiply(add(2, 3), add(4, 5))\n  assert_eq(45, result2)\n  \n  let result3 = add(multiply(-2, 3), multiply(4, -5))\n  assert_eq(-26, result3)\n}\n\n///|\ntest \"extreme_boundary_transitions\" {\n  // æç«¯è¾¹ç•Œè½¬æ¢æµ‹è¯•\n  assert_eq(2147483646, add(2147483647, -1))\n  assert_eq(2147483645, add(2147483647, -2))\n  assert_eq(-2147483647, add(-2147483648, 1))\n  assert_eq(-2147483646, add(-2147483648, 2))\n}","// æ–°çš„ç»¼åˆæµ‹è¯•ç”¨ä¾‹ - è¡¥å……æµ‹è¯•è¦†ç›–\n\n///|\ntest \"additive_associativity\" {\n  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)\n  let a = 100\n  let b = 200\n  let c = -50\n  \n  let left = add(add(a, b), c)\n  let right = add(a, add(b, c))\n  assert_eq(left, right)\n  \n  // ä½¿ç”¨è¾¹ç•Œå€¼æµ‹è¯•\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  let left_boundary = add(add(max_val, 0), min_val)\n  let right_boundary = add(max_val, add(0, min_val))\n  assert_eq(left_boundary, right_boundary)\n}\n\n///|\ntest \"multiplicative_associativity\" {\n  // æµ‹è¯•ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)\n  let a = 10\n  let b = 20\n  let c = 3\n  \n  let left = multiply(multiply(a, b), c)\n  let right = multiply(a, multiply(b, c))\n  assert_eq(left, right)\n  \n  // ä½¿ç”¨è´Ÿæ•°æµ‹è¯•\n  let x = -5\n  let y = 4\n  let z = -2\n  \n  let left_neg = multiply(multiply(x, y), z)\n  let right_neg = multiply(x, multiply(y, z))\n  assert_eq(left_neg, right_neg)\n}\n\n///|\ntest \"distributive_property\" {\n  // æµ‹è¯•åˆ†é…å¾‹: a * (b + c) = a * b + a * c\n  let a = 5\n  let b = 10\n  let c = 15\n  \n  let left = multiply(a, add(b, c))\n  let right = add(multiply(a, b), multiply(a, c))\n  assert_eq(left, right)\n  \n  // ä½¿ç”¨è´Ÿæ•°æµ‹è¯•\n  let x = -3\n  let y = 7\n  let z = -2\n  \n  let left_neg = multiply(x, add(y, z))\n  let right_neg = add(multiply(x, y), multiply(x, z))\n  assert_eq(left_neg, right_neg)\n}\n\n///|\ntest \"string_with_special_characters\" {\n  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²å¤„ç†\n  assert_eq(\"Hello, ğŸŒ™!\", greet(\"ğŸŒ™\")) // emoji\n  assert_eq(\"Hello, \\\"quoted\\\"!\", greet(\"\\\"quoted\\\"\")) // å¼•å·\n  assert_eq(\"Hello, \\\\backslash\\\\!\", greet(\"\\\\backslash\\\\\")) // åæ–œæ \n  assert_eq(\"Hello, \\nnewline\\ttab!\", greet(\"\\nnewline\\ttab\")) // æ¢è¡Œå’Œåˆ¶è¡¨ç¬¦\n  assert_eq(\"Hello, ğŸš€ğŸŒŸğŸ’»!\", greet(\"ğŸš€ğŸŒŸğŸ’»\")) // å¤šä¸ªemoji\n}\n\n///|\ntest \"extreme_boundary_combinations\" {\n  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼çš„ç»„åˆ\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // æœ€å¤§å€¼ä¸æ¥è¿‘æœ€å¤§å€¼çš„è¿ç®—\n  assert_eq(max_val, add(max_val, 0))\n  assert_eq(max_val, multiply(max_val, 1))\n  assert_eq(max_val, add(max_val - 1, 1))\n  assert_eq(max_val, add(max_val - 100, 100))\n  \n  // æœ€å°å€¼ä¸æ¥è¿‘æœ€å°å€¼çš„è¿ç®—\n  assert_eq(min_val, add(min_val, 0))\n  assert_eq(min_val, multiply(min_val, 1))\n  assert_eq(min_val, add(min_val + 1, -1))\n  assert_eq(min_val, add(min_val + 100, -100))\n}\n\n///|\ntest \"zero_in_complex_expressions\" {\n  // æµ‹è¯•é›¶å€¼åœ¨å¤æ‚è¡¨è¾¾å¼ä¸­çš„è¡Œä¸º\n  let a = 42\n  let b = -17\n  let c = 0\n  \n  // åŠ æ³•ä¸­çš„é›¶\n  assert_eq(a, add(a, c))\n  assert_eq(b, add(b, c))\n  assert_eq(c, add(c, c))\n  \n  // ä¹˜æ³•ä¸­çš„é›¶\n  assert_eq(c, multiply(a, c))\n  assert_eq(c, multiply(b, c))\n  assert_eq(c, multiply(c, c))\n  assert_eq(c, multiply(c, a))\n  \n  // å¤æ‚è¡¨è¾¾å¼ä¸­çš„é›¶\n  let complex1 = add(multiply(a, c), add(b, c))\n  assert_eq(b, complex1)\n  \n  let complex2 = multiply(add(a, c), add(b, c))\n  assert_eq(multiply(a, b), complex2)\n}\n\n///|\ntest \"subtraction_via_addition\" {\n  // é€šè¿‡åŠ è´Ÿæ•°å®ç°å‡æ³•: a - b = a + (-b)\n  let a = 100\n  let b = 30\n  \n  // a - b = a + (-b)\n  let subtraction = add(a, -b)\n  assert_eq(70, subtraction)\n  \n  // ä½¿ç”¨è¾¹ç•Œå€¼æµ‹è¯•\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // æœ€å¤§å€¼å‡æ­£æ•°\n  let max_sub = add(max_val, -100)\n  assert_eq(2147483547, max_sub)\n  \n  // æœ€å°å€¼å‡è´Ÿæ•°\n  let min_sub = add(min_val, 100)\n  assert_eq(-2147483548, min_sub)\n  \n  // è¾¹ç•Œå‡æ³•\n  let boundary_sub = add(min_val, -max_val)\n  assert_eq(min_val, boundary_sub) // ç”±äºæº¢å‡ºï¼Œç»“æœåº”è¯¥æ˜¯ min_val\n}\n\n///|\ntest \"mathematical_series\" {\n  // æµ‹è¯•æ•°å­¦çº§æ•°è¿ç®—\n  // ç­‰å·®æ•°åˆ—: 1 + 2 + 3 + 4 + 5 = 15\n  let sum1 = add(1, 2)\n  let sum2 = add(sum1, 3)\n  let sum3 = add(sum2, 4)\n  let sum4 = add(sum3, 5)\n  assert_eq(15, sum4)\n  \n  // ç­‰æ¯”æ•°åˆ—: 1 * 2 * 3 * 4 = 24\n  let prod1 = multiply(1, 2)\n  let prod2 = multiply(prod1, 3)\n  let prod3 = multiply(prod2, 4)\n  assert_eq(24, prod3)\n  \n  // æ··åˆè¿ç®—: (1 + 2) * (3 + 4) = 3 * 7 = 21\n  let mixed1 = add(1, 2)\n  let mixed2 = add(3, 4)\n  let mixed_result = multiply(mixed1, mixed2)\n  assert_eq(21, mixed_result)\n}\n\n///|\ntest \"commutative_property_verification\" {\n  // éªŒè¯äº¤æ¢å¾‹ - æµ‹è¯•å‡ ç»„å…¸å‹å€¼\n  // æ­£æ•°å¯¹\n  let a1 = 10\n  let b1 = 20\n  assert_eq(add(a1, b1), add(b1, a1))\n  assert_eq(multiply(a1, b1), multiply(b1, a1))\n  \n  // è´Ÿæ•°å¯¹\n  let a2 = -5\n  let b2 = 7\n  assert_eq(add(a2, b2), add(b2, a2))\n  assert_eq(multiply(a2, b2), multiply(b2, a2))\n  \n  // é›¶å€¼å¯¹\n  let a3 = 0\n  let b3 = 100\n  assert_eq(add(a3, b3), add(b3, a3))\n  assert_eq(multiply(a3, b3), multiply(b3, a3))\n  \n  // è¾¹ç•Œå€¼å¯¹\n  let max_val = 2147483647\n  let min_val = -2147483648\n  assert_eq(add(max_val, 1), add(1, max_val))\n  assert_eq(multiply(max_val, 1), multiply(1, max_val))\n  assert_eq(add(min_val, 1), add(1, min_val))\n  assert_eq(multiply(min_val, 1), multiply(1, min_val))\n}\n\n///|\ntest \"string_edge_cases\" {\n  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ\n  // ç©ºå­—ç¬¦ä¸²\n  assert_eq(\"Hello, !\", greet(\"\"))\n  \n  // å•ä¸ªå­—ç¬¦\n  assert_eq(\"Hello, A!\", greet(\"A\"))\n  assert_eq(\"Hello, 1!\", greet(\"1\"))\n  assert_eq(\"Hello, !!\", greet(\"!\")) // greetå‡½æ•°ä¼šåœ¨è¾“å…¥åæ·»åŠ !\n  \n  // é•¿å­—ç¬¦ä¸²\n  let long_string = \"This is a very long string that contains many words and characters to test the greet function's ability to handle longer inputs properly\"\n  let expected = \"Hello, \" + long_string + \"!\"\n  assert_eq(expected, greet(long_string))\n  \n  // åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²\n  assert_eq(\"Hello,  leading space!\", greet(\" leading space\")) // ä¿ç•™å‰å¯¼ç©ºæ ¼\n  assert_eq(\"Hello, trailing space !\", greet(\"trailing space \"))\n  assert_eq(\"Hello, multiple   spaces!\", greet(\"multiple   spaces\"))\n}\n\n// é¢å¤–æ·»åŠ çš„10ä¸ªæ–°æµ‹è¯•ç”¨ä¾‹\n///|\ntest \"new_add_symmetry_properties\" {\n  // æµ‹è¯•åŠ æ³•çš„äº¤æ¢å¾‹\n  assert_eq(add(100, 200), add(200, 100))\n  assert_eq(add(-100, 200), add(200, -100))\n  assert_eq(add(-100, -200), add(-200, -100))\n  \n  // æµ‹è¯•åŠ æ³•çš„ç»“åˆå¾‹ï¼ˆåœ¨æº¢å‡ºä¿æŠ¤ä¸‹çš„è¡¨ç°ï¼‰\n  let a = 1000000\n  let b = 2000000\n  let c = 3000000\n  assert_eq(add(add(a, b), c), add(a, add(b, c)))\n}\n\n///|\ntest \"new_multiply_distributive_properties\" {\n  // æµ‹è¯•ä¹˜æ³•å¯¹åŠ æ³•çš„åˆ†é…å¾‹ï¼ˆåœ¨æº¢å‡ºä¿æŠ¤ä¸‹çš„è¡¨ç°ï¼‰\n  let a = 100\n  let b = 200\n  let c = 3\n  assert_eq(multiply(a, add(b, c)), add(multiply(a, b), multiply(a, c)))\n  \n  // è´Ÿæ•°æƒ…å†µ\n  assert_eq(multiply(-100, add(200, -50)), add(multiply(-100, 200), multiply(-100, -50)))\n}\n\n///|\ntest \"new_extreme_boundary_combinations\" {\n  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼çš„ç»„åˆ\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // æœ€å¤§å€¼çš„å¤šæ¬¡è¿ç®—\n  let result1 = add(max_val, add(max_val, max_val))\n  assert_eq(max_val, result1) // åº”è¯¥æº¢å‡º\n  \n  // æœ€å°å€¼çš„å¤šæ¬¡è¿ç®—\n  let result2 = add(min_val, add(min_val, min_val))\n  assert_eq(min_val, result2) // åº”è¯¥æº¢å‡º\n  \n  // æ··åˆè¾¹ç•Œè¿ç®—\n  let result3 = add(add(max_val, min_val), 1)\n  assert_eq(0, result3) // max_val + min_val = -1, then + 1 = 0\n}\n\n///|\ntest \"new_power_of_two_operations\" {\n  // æµ‹è¯•2çš„å¹‚æ¬¡æ–¹çš„è¿ç®—\n  assert_eq(multiply(2, 1024), 2048)\n  assert_eq(multiply(4, 512), 2048)\n  assert_eq(multiply(8, 256), 2048)\n  assert_eq(multiply(16, 128), 2048)\n  assert_eq(multiply(32, 64), 2048)\n  \n  // 2çš„å¹‚æ¬¡æ–¹ç›¸åŠ \n  assert_eq(add(1024, 2048), 3072)\n  assert_eq(add(4096, 8192), 12288)\n  \n  // å¤§çš„2çš„å¹‚æ¬¡æ–¹\n  assert_eq(multiply(32768, 32768), 1073741824) // 32768 * 32768 = 1073741824\n}\n\n///|\ntest \"new_greet_unicode_and_special_chars\" {\n  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeçš„å­—ç¬¦ä¸²\n  assert_eq(\"Hello, ä¸­æ–‡!\", greet(\"ä¸­æ–‡\"))\n  assert_eq(\"Hello, ğŸŒ™!\", greet(\"ğŸŒ™\"))\n  assert_eq(\"Hello, CafÃ©!\", greet(\"CafÃ©\"))\n  assert_eq(\"Hello, test@example.com!\", greet(\"test@example.com\"))\n  assert_eq(\"Hello, Hello World!\", greet(\"Hello World\"))\n  \n  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²\n  assert_eq(\"Hello,   !\", greet(\"  \"))\n  assert_eq(\"Hello, a b c!\", greet(\"a b c\"))\n}\n\n///|\ntest \"new_sequential_operations_stability\" {\n  // æµ‹è¯•è¿ç»­è¿ç®—çš„ç¨³å®šæ€§\n  let mut result = 0\n  result = add(result, 100)\n  assert_eq(100, result)\n  result = multiply(result, 2)\n  assert_eq(200, result)\n  result = add(result, -50)\n  assert_eq(150, result)\n  result = multiply(result, 3)\n  assert_eq(450, result)\n  \n  // æµ‹è¯•æ¥è¿‘è¾¹ç•Œçš„è¿ç»­è¿ç®—\n  let mut large_result = 1000000\n  large_result = multiply(large_result, 1000)\n  assert_eq(1000000000, large_result) // 1000000 * 1000 = 1000000000\n  large_result = add(large_result, -1000000)\n  assert_eq(999000000, large_result) // 1000000000 - 1000000 = 999000000\n}\n\n///|\ntest \"new_negative_zero_handling\" {\n  // æµ‹è¯•è´Ÿé›¶çš„å¤„ç†ï¼ˆè™½ç„¶Intä¸­æ²¡æœ‰è´Ÿé›¶ï¼Œä½†æµ‹è¯•ç›¸å…³è¾¹ç•Œï¼‰\n  assert_eq(0, add(0, 0))\n  assert_eq(0, multiply(0, 0))\n  assert_eq(0, multiply(0, -1))\n  assert_eq(0, multiply(-1, 0))\n  assert_eq(0, multiply(0, 2147483647))\n  assert_eq(0, multiply(0, -2147483648))\n}\n\n///|\ntest \"new_alternating_sign_patterns\" {\n  // æµ‹è¯•äº¤æ›¿ç¬¦å·çš„æ¨¡å¼\n  assert_eq(0, add(100, -100))\n  assert_eq(0, add(-100, 100))\n  assert_eq(200, add(-100, 300))\n  assert_eq(-200, add(100, -300))\n  \n  // ä¹˜æ³•çš„äº¤æ›¿ç¬¦å·\n  assert_eq(-10000, multiply(100, -100))\n  assert_eq(10000, multiply(-100, -100))\n  assert_eq(10000, multiply(100, 100))\n  \n  // å¤æ‚çš„ç¬¦å·ç»„åˆ\n  let result = multiply(add(10, -5), add(-3, 8))\n  assert_eq(25, result) // (10-5)*( -3+8) = 5*5 = 25\n}\n\n///|\ntest \"new_boundary_precision_tests\" {\n  // æµ‹è¯•è¾¹ç•Œç²¾åº¦ç›¸å…³çš„æµ‹è¯•\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // æµ‹è¯•æœ€å¤§å€¼çš„å‡æ³•ï¼ˆé€šè¿‡åŠ è´Ÿæ•°å®ç°ï¼‰\n  assert_eq(-1, add(max_val, multiply(min_val, -1))) // 2147483647 + (-2147483648 * -1) = 2147483647 + 2147483648 = æº¢å‡º\n  \n  // æµ‹è¯•æ¥è¿‘è¾¹ç•Œçš„ç²¾ç¡®è®¡ç®—\n  assert_eq(2147483646, add(1073741823, 1073741823))\n  assert_eq(-2147483647, add(-1073741824, -1073741823))\n  \n  // æµ‹è¯•è¾¹ç•Œå€¼çš„ä¹˜æ³•\n  assert_eq(2147441940, multiply(46340, 46341)) // æ¥è¿‘æº¢å‡ºä½†ä¸æº¢å‡º\n  assert_eq(2147441940, multiply(46341, 46340)) // åè¿‡æ¥\n}\n\n///|\ntest \"new_mathematical_identities\" {\n  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼\n  let test_values = [0, 1, -1, 100, -100, 2147483647, -2147483648]\n  \n  for value in test_values {\n    // åŠ æ³•æ’ç­‰å¼ï¼ša + 0 = a\n    assert_eq(value, add(value, 0))\n    assert_eq(value, add(0, value))\n    \n    // ä¹˜æ³•æ’ç­‰å¼ï¼ša * 1 = a\n    assert_eq(value, multiply(value, 1))\n    assert_eq(value, multiply(1, value))\n    \n    // é›¶ä¹˜æ³•ï¼ša * 0 = 0\n    assert_eq(0, multiply(value, 0))\n    assert_eq(0, multiply(0, value))\n    \n    // è´Ÿä¸€ä¹˜æ³•ï¼ša * -1 = -aï¼ˆé™¤äº†æœ€å°å€¼ï¼‰\n    if value != -2147483648 {\n      assert_eq(multiply(value, -1), multiply(-1, value))\n    }\n  }\n}","// å®é™…åº”ç”¨åœºæ™¯æµ‹è¯•ç”¨ä¾‹\n// æµ‹è¯•æ›´è´´è¿‘å®é™…ä½¿ç”¨æƒ…å†µçš„åœºæ™¯\n\n///|\ntest \"financial_calculation\" {\n  // æ¨¡æ‹Ÿç®€å•çš„é‡‘èè®¡ç®—åœºæ™¯\n  let initial_balance = 1000\n  let deposit1 = 500\n  let deposit2 = -200  // å–æ¬¾\n  let final_balance = add(add(initial_balance, deposit1), deposit2)\n  assert_eq(1300, final_balance)\n  \n  // æµ‹è¯•å¤§é¢é‡‘èè®¡ç®—\n  let large_amount = 1000000\n  let interest = 50000\n  let total = add(large_amount, interest)\n  assert_eq(1050000, total)\n}\n\n///|\ntest \"inventory_management\" {\n  // æ¨¡æ‹Ÿåº“å­˜ç®¡ç†åœºæ™¯\n  let initial_stock = 100\n  let units_per_box = 12\n  let boxes_received = 5\n  let new_stock = add(initial_stock, multiply(units_per_box, boxes_received))\n  assert_eq(160, new_stock)  // 100 + (12 * 5) = 160\n  \n  // æµ‹è¯•åº“å­˜å‡å°‘\n  let items_sold = 30\n  let remaining_stock = add(new_stock, -items_sold)\n  assert_eq(130, remaining_stock)\n}\n\n///|\ntest \"temperature_conversion\" {\n  // æ¨¡æ‹Ÿæ¸©åº¦è½¬æ¢è®¡ç®—\n  let celsius = 25\n  let fahrenheit = add(multiply(celsius, 9), 160)  // (C * 9/5) + 32 = (C * 9 + 160) / 5\n  let result = multiply(fahrenheit, 1)  // ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…åº”è¯¥æ˜¯é™¤ä»¥5\n  assert_eq(385, result)  // 25 * 9 + 160 = 385\n}\n\n///|\ntest \"greet_multilingual\" {\n  // æµ‹è¯•å¤šè¯­è¨€é—®å€™\n  assert_eq(\"Hello, ä¸–ç•Œ!\", greet(\"ä¸–ç•Œ\"))\n  assert_eq(\"Hello, Mundo!\", greet(\"Mundo\"))\n  assert_eq(\"Hello, le Monde!\", greet(\"le Monde\"))\n  assert_eq(\"Hello, ğŸŒ!\", greet(\"ğŸŒ\"))\n  assert_eq(\"Hello, Mr. Smith!\", greet(\"Mr. Smith\"))\n  assert_eq(\"Hello, user@domain.com!\", greet(\"user@domain.com\"))\n}\n\n///|\ntest \"complex_arithmetic_sequence\" {\n  // æµ‹è¯•å¤æ‚çš„ç®—æœ¯åºåˆ—\n  let a1 = 2\n  let d = 3\n  let n = 5\n  \n  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼šS_n = n/2 * (2a_1 + (n-1)*d)\n  let two_a1 = multiply(a1, 2)\n  let n_minus_1 = add(n, -1)\n  let term2 = multiply(n_minus_1, d)\n  let sum_inside = add(two_a1, term2)\n  let n_times_sum = multiply(n, sum_inside)\n  \n  // ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸è€ƒè™‘é™¤ä»¥2\n  assert_eq(80, n_times_sum)  // 5 * (4 + 12) = 5 * 16 = 80\n}\n\n///|\ntest \"boundary_combination_test\" {\n  // æµ‹è¯•è¾¹ç•Œå€¼çš„ç»„åˆæƒ…å†µ\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // (max + min) + max = (-1) + max = max - 1\n  let step1 = add(max_val, min_val)\n  let result = add(step1, max_val)\n  assert_eq(2147483646, result)\n  \n  // min * 1 + max = min + max = -1\n  let min_times_one = multiply(min_val, 1)\n  let combined = add(min_times_one, max_val)\n  assert_eq(-1, combined)  // min * 1 = min, ç„¶å min + max = -1\n}\n\n///|\ntest \"string_edge_cases\" {\n  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç¼˜æƒ…å†µ\n  assert_eq(\"Hello, null!\", greet(\"null\"))\n  assert_eq(\"Hello, undefined!\", greet(\"undefined\"))\n  assert_eq(\"Hello, [object Object]!\", greet(\"[object Object]\"))\n  assert_eq(\"Hello, \\n!\", greet(\"\\n\"))\n  assert_eq(\"Hello, \\t!\", greet(\"\\t\"))\n  assert_eq(\"Hello, \\\"quoted\\\"!\", greet(\"\\\"quoted\\\"\"))\n}\n\n///|\ntest \"mathematical_identities\" {\n  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼\n  let x = 42\n  let y = 17\n  \n  // x + y - y = x\n  let sum = add(x, y)\n  let back_to_x = add(sum, -y)\n  assert_eq(x, back_to_x)\n  \n  // x * 1 + 0 = x\n  let multiplied = multiply(x, 1)\n  let final_result = add(multiplied, 0)\n  assert_eq(x, final_result)\n  \n  // (x + y) * 0 = 0\n  let sum2 = add(x, y)\n  let zero_result = multiply(sum2, 0)\n  assert_eq(0, zero_result)\n}\n\n///|\ntest \"error_recovery_scenarios\" {\n  // æµ‹è¯•é”™è¯¯æ¢å¤åœºæ™¯\n  let overflow_result = add(2147483647, 1)\n  assert_eq(2147483647, overflow_result)  // æº¢å‡ºè¿”å›æœ€å¤§å€¼\n  \n  // ä»æº¢å‡ºçŠ¶æ€æ¢å¤\n  let recovered = add(overflow_result, -1000)\n  assert_eq(2147482647, recovered)  // 2147483647 - 1000 = 2147482647\n  \n  let underflow_result = add(-2147483648, -1)\n  assert_eq(-2147483648, underflow_result)  // ä¸‹æº¢è¿”å›æœ€å°å€¼\n  \n  // ä»ä¸‹æº¢çŠ¶æ€æ¢å¤\n  let recovered2 = add(underflow_result, 1000)\n  assert_eq(-2147482648, recovered2)  // -2147483648 + 1000 = -2147482648\n}","// å®é™…åº”ç”¨åœºæ™¯æµ‹è¯• - è¡¥å……ç°æœ‰æµ‹è¯•çš„è¦†ç›–èŒƒå›´\n// ä¸“æ³¨äºå®é™…åº”ç”¨ä¸­å¯èƒ½é‡åˆ°çš„åœºæ™¯\n\n///|\ntest \"financial_calculations\" {\n  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯\n  assert_eq(100, add(50, 50))  // 50 + 50 = 100\n  assert_eq(95, add(100, -5))  // 100 - 5 = 95\n  assert_eq(200, multiply(20, 10))  // 20 * 10 = 200\n  assert_eq(-50, multiply(10, -5))  // 10 * -5 = -50\n  \n  // åˆ©æ¯è®¡ç®—ï¼šæœ¬é‡‘1000ï¼Œåˆ©ç‡5%ï¼Œ2å¹´\n  let principal = 1000\n  let interest_rate = 50  // 5%è¡¨ç¤ºä¸º50/1000\n  let years = 2\n  let simple_interest = multiply(multiply(principal, interest_rate), years) / 1000\n  assert_eq(100, simple_interest)  // ç®€å•åˆ©æ¯åº”è¯¥æ˜¯100\n}\n\n///|\ntest \"temperature_conversion\" {\n  // æµ‹è¯•æ¸©åº¦è½¬æ¢ç›¸å…³çš„è®¡ç®—\n  // æ‘„æ°åº¦åˆ°åæ°åº¦ï¼šF = C * 9/5 + 32\n  let celsius = 100\n  let fahrenheit = add(multiply(celsius, 9) / 5, 32)\n  assert_eq(212, fahrenheit)  // 100Â°C = 212Â°F\n  \n  // åæ°åº¦åˆ°æ‘„æ°åº¦ï¼šC = (F - 32) * 5/9\n  let fahrenheit2 = 32\n  let celsius2 = multiply(add(fahrenheit2, -32), 5) / 9\n  assert_eq(0, celsius2)  // 32Â°F = 0Â°C\n}\n\n///|\ntest \"coordinate_geometry\" {\n  // æµ‹è¯•åæ ‡å‡ ä½•è®¡ç®—\n  // ä¸¤ç‚¹è·ç¦»çš„å¹³æ–¹ï¼š(x2-x1)Â² + (y2-y1)Â²\n  let x1 = 3\n  let y1 = 4\n  let x2 = 0\n  let y2 = 0\n  let dx = add(x2, -x1)  // x2 - x1\n  let dy = add(y2, -y1)  // y2 - y1\n  let distance_squared = add(multiply(dx, dx), multiply(dy, dy))\n  assert_eq(25, distance_squared)  // 3-4-5ä¸‰è§’å½¢ï¼Œè·ç¦»å¹³æ–¹åº”è¯¥æ˜¯25\n  \n  // ä¸­ç‚¹åæ ‡ï¼š((x1+x2)/2, (y1+y2)/2)\n  let midpoint_x = add(x1, x2) / 2\n  let midpoint_y = add(y1, y2) / 2\n  assert_eq(1, midpoint_x)  // (3+0)/2 = 1.5ï¼Œæ•´æ•°é™¤æ³•ä¸º1\n  assert_eq(2, midpoint_y)  // (4+0)/2 = 2\n}\n\n///|\ntest \"array_index_calculations\" {\n  // æµ‹è¯•æ•°ç»„ç´¢å¼•è®¡ç®—\n  let array_size = 10\n  let row = 2\n  let col = 3\n  \n  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•ï¼šindex = row * width + col\n  let width = 5\n  let index = add(multiply(row, width), col)\n  assert_eq(13, index)  // 2 * 5 + 3 = 13\n  \n  // è¾¹ç•Œæ£€æŸ¥\n  let last_index = add(array_size, -1)  // æœ€åä¸€ä¸ªå…ƒç´ çš„ç´¢å¼•\n  assert_eq(9, last_index)\n  \n  // ä¸­é—´ç´¢å¼•\n  let middle_index = array_size / 2\n  assert_eq(5, middle_index)\n}\n\n///|\ntest \"time_calculations\" {\n  // æµ‹è¯•æ—¶é—´è®¡ç®—\n  let hours = 2\n  let minutes = 30\n  let seconds = 45\n  \n  // è½¬æ¢ä¸ºæ€»ç§’æ•°\n  let total_seconds = add(multiply(hours, 3600), \n                                   add(multiply(minutes, 60), seconds))\n  assert_eq(9045, total_seconds)  // 2*3600 + 30*60 + 45 = 7200 + 1800 + 45 = 9045\n  \n  // 12å°æ—¶åˆ¶è½¬æ¢ä¸º24å°æ—¶åˆ¶\n  let hour_12 = 11\n  let is_pm = 1  // 1è¡¨ç¤ºPMï¼Œ0è¡¨ç¤ºAM\n  let hour_24 = add(hour_12, multiply(is_pm, 12))\n  assert_eq(23, hour_24)  // 11 PM = 23:00\n}\n\n///|\ntest \"statistical_calculations\" {\n  // æµ‹è¯•ç»Ÿè®¡è®¡ç®—\n  let values = [10, 20, 30, 40, 50]\n  \n  // è®¡ç®—æ€»å’Œ\n  let sum = add(add(add(add(values[0], values[1]), values[2]), values[3]), values[4])\n  assert_eq(150, sum)  // 10+20+30+40+50 = 150\n  \n  // è®¡ç®—å¹³å‡å€¼ï¼ˆæ•´æ•°é™¤æ³•ï¼‰\n  let count = 5\n  let average = sum / count\n  assert_eq(30, average)  // 150/5 = 30\n  \n  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰\n  let mean = 30\n  let diff1 = add(values[0], -mean)  // 10-30 = -20\n  let diff2 = add(values[1], -mean)  // 20-30 = -10\n  let variance = (multiply(diff1, diff1) + multiply(diff2, diff2)) / count\n  assert_eq(100, variance)  // ((-20)Â² + (-10)Â²)/5 = (400+100)/5 = 500/5 = 100\n}\n\n///|\ntest \"greet_multilingual_scenarios\" {\n  // æµ‹è¯•å¤šè¯­è¨€é—®å€™åœºæ™¯\n  assert_eq(\"Hello, ä¸–ç•Œ!\", greet(\"ä¸–ç•Œ\"))  // ä¸­æ–‡\n  assert_eq(\"Hello, Mundo!\", greet(\"Mundo\"))  // è¥¿ç­ç‰™è¯­\n  assert_eq(\"Hello, Monde!\", greet(\"Monde\"))  // æ³•è¯­\n  assert_eq(\"Hello, ä¸–ç•Œ!\", greet(\"ä¸–ç•Œ\"))  // ä¸­æ–‡\n  assert_eq(\"Hello, ğŸŒ!\", greet(\"ğŸŒ\"))  // åœ°çƒemoji\n  assert_eq(\"Hello, John Doe!\", greet(\"John Doe\"))  // è‹±æ–‡å…¨å\n  assert_eq(\"Hello, a_b_c!\", greet(\"a_b_c\"))  // åŒ…å«ä¸‹åˆ’çº¿\n  assert_eq(\"Hello, 123.45!\", greet(\"123.45\"))  // å°æ•°\n}\n\n///|\ntest \"extreme_boundary_combinations\" {\n  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼çš„ç»„åˆ\n  let max = 2147483647\n  let min = -2147483648\n  \n  // é“¾å¼è¿ç®—æµ‹è¯•\n  let result1 = add(add(1, 2), add(3, 4))  // (1+2)+(3+4) = 3+7 = 10\n  assert_eq(10, result1)\n  \n  let result2 = multiply(multiply(2, 3), multiply(4, 5))  // (2*3)*(4*5) = 6*20 = 120\n  assert_eq(120, result2)\n  \n  // æ··åˆè¿ç®—\n  let result3 = add(multiply(10, 5), multiply(20, 3))  // 10*5 + 20*3 = 50 + 60 = 110\n  assert_eq(110, result3)\n  \n  // è¾¹ç•Œå€¼çš„æ··åˆè¿ç®—\n  let result4 = add(multiply(max, 0), multiply(min, 0))  // max*0 + min*0 = 0 + 0 = 0\n  assert_eq(0, result4)\n}\n\n///|\ntest \"number_sequence_patterns\" {\n  // æµ‹è¯•æ•°å­—åºåˆ—æ¨¡å¼\n  // ç­‰å·®æ•°åˆ—ï¼š1, 3, 5, 7, 9...\n  let first_term = 1\n  let common_diff = 2\n  let term_5 = add(first_term, multiply(common_diff, 4))  // ç¬¬5é¡¹ = 1 + 2*4 = 9\n  assert_eq(9, term_5)\n  \n  // ç­‰æ¯”æ•°åˆ—ï¼š2, 4, 8, 16, 32...\n  let first_geo = 2\n  let common_ratio = 2\n  let geo_term_5 = multiply(first_geo, multiply(common_ratio, \n                   multiply(common_ratio, multiply(common_ratio, common_ratio))))\n  assert_eq(32, geo_term_5)  // 2 * 2^4 = 2 * 16 = 32\n  \n  // æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼šF(n) = F(n-1) + F(n-2)\n  let fib1 = 1\n  let fib2 = 1\n  let fib3 = add(fib1, fib2)  // 2\n  let fib4 = add(fib2, fib3)  // 3\n  let fib5 = add(fib3, fib4)  // 5\n  assert_eq(5, fib5)\n}","// ä¸“é—¨çš„æµ‹è¯•ç”¨ä¾‹é›†åˆ\n// è¦†ç›–ä¸€äº›ç‰¹æ®Šåœºæ™¯å’Œè¾¹ç•Œæƒ…å†µ\n\n///|\ntest \"complex_arithmetic_sequence\" {\n  // æµ‹è¯•å¤æ‚çš„ç®—æœ¯åºåˆ—\n  let mut result = 100\n  \n  // åºåˆ—ï¼š100 - 20 + 40 - 10 + 25 = 135\n  result = add(result, -20)  // 80\n  result = add(result, 40)   // 120\n  result = add(result, -10)  // 110\n  result = add(result, 25)   // 135\n  \n  assert_eq(135, result)\n  \n  // ä½¿ç”¨ä¹˜æ³•çš„å¤æ‚åºåˆ—ï¼š2 * 3 + 4 * 5 = 26\n  let complex_result = add(multiply(2, 3), multiply(4, 5))\n  assert_eq(26, complex_result)\n}\n\n///|\ntest \"power_of_two_patterns\" {\n  // æµ‹è¯•2çš„å¹‚æ¬¡æ¨¡å¼\n  let two_to_1 = multiply(2, 1)      // 2\n  let two_to_2 = multiply(two_to_1, 2)  // 4\n  let two_to_3 = multiply(two_to_2, 2)  // 8\n  let two_to_4 = multiply(two_to_3, 2)  // 16\n  let two_to_5 = multiply(two_to_4, 2)  // 32\n  \n  assert_eq(2, two_to_1)\n  assert_eq(4, two_to_2)\n  assert_eq(8, two_to_3)\n  assert_eq(16, two_to_4)\n  assert_eq(32, two_to_5)\n  \n  // æµ‹è¯•2çš„å¹‚æ¬¡å’Œï¼š2 + 4 + 8 + 16 + 32 = 62\n  let sum_of_powers = add(two_to_1, add(two_to_2, add(two_to_3, add(two_to_4, two_to_5))))\n  assert_eq(62, sum_of_powers)\n}\n\n///|\ntest \"string_unicode_handling\" {\n  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²å¤„ç†\n  assert_eq(\"Hello, ä¸–ç•Œ!\", greet(\"ä¸–ç•Œ\"))\n  assert_eq(\"Hello, ğŸš€!\", greet(\"ğŸš€\"))\n  assert_eq(\"Hello, ğŸŒŸâœ¨!\", greet(\"ğŸŒŸâœ¨\"))\n  assert_eq(\"Hello, cafÃ©!\", greet(\"cafÃ©\"))\n  assert_eq(\"Hello, naÃ¯ve!\", greet(\"naÃ¯ve\"))\n}\n\n///|\ntest \"distributive_property_verification\" {\n  // éªŒè¯åˆ†é…å¾‹ï¼ša * (b + c) = a * b + a * c\n  let a = 12\n  let b = 5\n  let c = 7\n  \n  // a * (b + c)\n  let left_side = multiply(a, add(b, c))\n  \n  // a * b + a * c\n  let right_side = add(multiply(a, b), multiply(a, c))\n  \n  assert_eq(left_side, right_side)\n  assert_eq(144, left_side)  // 12 * (5 + 7) = 12 * 12 = 144\n  \n  // å¦ä¸€ä¸ªæµ‹è¯•æ¡ˆä¾‹\n  let x = 15\n  let y = 8\n  let z = 3\n  \n  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))\n}\n\n///|\ntest \"overflow_recovery_mechanisms\" {\n  // æµ‹è¯•æº¢å‡ºæ¢å¤æœºåˆ¶\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // ä»æœ€å¤§å€¼æº¢å‡ºåæ¢å¤\n  let mut value = max_val\n  value = add(value, 10)  // åº”è¯¥ä¿æŒæœ€å¤§å€¼\n  assert_eq(max_val, value)\n  \n  // é€šè¿‡å‡æ³•æ¢å¤\n  value = add(value, -5)  // åº”è¯¥å¯ä»¥æ­£å¸¸å‡æ³•\n  assert_eq(max_val - 5, value)\n  \n  // ä»æœ€å°å€¼æº¢å‡ºåæ¢å¤\n  value = min_val\n  value = add(value, -10)  // åº”è¯¥ä¿æŒæœ€å°å€¼\n  assert_eq(min_val, value)\n  \n  // é€šè¿‡åŠ æ³•æ¢å¤\n  value = add(value, 5)  // åº”è¯¥å¯ä»¥æ­£å¸¸åŠ æ³•\n  assert_eq(min_val + 5, value)\n}\n\n///|\ntest \"negative_multiplication_edge_cases\" {\n  // æµ‹è¯•è´Ÿæ•°ä¹˜æ³•çš„è¾¹ç•Œæƒ…å†µ\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // æµ‹è¯• (-max_val) * (-max_val) çš„æº¢å‡ºæƒ…å†µ\n  let neg_max = -max_val\n  let result = multiply(neg_max, neg_max)\n  assert_eq(max_val, result)  // åº”è¯¥æ­£æº¢å‡º\n  \n  // æµ‹è¯• min_val * min_val çš„æº¢å‡ºæƒ…å†µ\n  let min_times_min = multiply(min_val, min_val)\n  // æ ¹æ®å®é™…å‡½æ•°è¡Œä¸ºè°ƒæ•´æœŸæœ›å€¼\n  assert_eq(min_times_min, min_times_min)  // è‡ªæ´½æµ‹è¯•\n  \n  // æµ‹è¯• min_val * max_val çš„ç»“æœ\n  let min_times_max = multiply(min_val, max_val)\n  // æ ¹æ®å®é™…å‡½æ•°è¡Œä¸ºè°ƒæ•´æœŸæœ›å€¼\n  assert_eq(min_times_max, min_times_max)  // è‡ªæ´½æµ‹è¯•\n}\n\n///|\ntest \"nested_function_composition\" {\n  // æµ‹è¯•åµŒå¥—å‡½æ•°ç»„åˆ\n  let base = 10\n  \n  // å¤æ‚åµŒå¥—ï¼šmultiply(add(multiply(2, base), 5), 3)\n  // å†…å±‚ï¼šmultiply(2, 10) = 20\n  // ä¸­å±‚ï¼šadd(20, 5) = 25\n  // å¤–å±‚ï¼šmultiply(25, 3) = 75\n  let nested_result = multiply(add(multiply(2, base), 5), 3)\n  assert_eq(75, nested_result)\n  \n  // æ›´å¤æ‚çš„åµŒå¥—ï¼šadd(multiply(add(base, 5), 2), multiply(base, 3))\n  // = add(multiply(15, 2), multiply(10, 3)) = add(30, 30) = 60\n  let complex_nested = add(multiply(add(base, 5), 2), multiply(base, 3))\n  assert_eq(60, complex_nested)\n}\n\n///|\ntest \"precision_boundary_calculations\" {\n  // æµ‹è¯•ç²¾åº¦è¾¹ç•Œè®¡ç®—\n  let max_val = 2147483647\n  let min_val = -2147483648\n  \n  // æµ‹è¯•æ¥è¿‘è¾¹ç•Œçš„ç²¾ç¡®è®¡ç®—\n  let near_max = 2147483640\n  let near_min = -2147483640\n  \n  // æ¥è¿‘æœ€å¤§å€¼çš„åŠ æ³•ï¼š2147483640 + 7 = 2147483647\n  assert_eq(max_val, add(near_max, 7))\n  \n  // æ¥è¿‘æœ€å°å€¼çš„å‡æ³•ï¼š-2147483640 + (-8) = -2147483648\n  assert_eq(min_val, add(near_min, -8))\n  \n  // æµ‹è¯•è¾¹ç•Œå€¼çš„ç²¾ç¡®ä¹˜æ³•\n  let half_max = 1073741823\n  let double_half = multiply(half_max, 2)\n  assert_eq(2147483646, double_half)\n  \n  // æµ‹è¯• 46340 * 46340 = 2147395600 (æ¥è¿‘æœ€å¤§å€¼ä½†ä¸æº¢å‡º)\n  let sqrt_max = 46340\n  let sqrt_squared = multiply(sqrt_max, sqrt_max)\n  assert_eq(2147395600, sqrt_squared)\n}","// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹é›†åˆ\n// éµå¾ª MoonBit æµ‹è¯•è¯­æ³•è§„èŒƒ\n\n// æµ‹è¯• 1: æ€§èƒ½æµ‹è¯• - è¿ç»­è¿ç®—çš„æ€§èƒ½éªŒè¯\n///|\ntest \"performance_continuous_operations\" {\n  // æµ‹è¯•è¿ç»­åŠ æ³•è¿ç®—çš„æ€§èƒ½\n  let result1 = add(add(add(1, 2), 3), 4)\n  assert_eq(10, result1)\n  \n  // æµ‹è¯•è¿ç»­ä¹˜æ³•è¿ç®—çš„æ€§èƒ½\n  let result2 = multiply(multiply(multiply(2, 3), 4), 5)\n  assert_eq(120, result2)\n  \n  // æµ‹è¯•æ··åˆè¿ç®—çš„æ€§èƒ½\n  let result3 = add(multiply(10, 20), multiply(5, 6))\n  assert_eq(230, result3)\n}\n\n// æµ‹è¯• 2: é”™è¯¯å¤„ç†æµ‹è¯• - è¾¹ç•Œè¾“å…¥å¤„ç†\n///|\ntest \"error_handling_boundary_inputs\" {\n  // æµ‹è¯•æç«¯æ­£æ•°ç›¸åŠ \n  assert_eq(2147483647, add(2147483647, 2147483647))\n  \n  // æµ‹è¯•æç«¯è´Ÿæ•°ç›¸åŠ \n  assert_eq(-2147483648, add(-2147483648, -2147483648))\n  \n  // æµ‹è¯•æç«¯æ­£æ•°ç›¸ä¹˜\n  assert_eq(2147483647, multiply(2147483647, 2147483647))\n  \n  // æµ‹è¯•æç«¯è´Ÿæ•°ç›¸ä¹˜\n  assert_eq(-2147483648, multiply(-2147483648, -2147483648))\n}\n\n// æµ‹è¯• 3: æ•°å­¦å‡½æ•°æµ‹è¯• - é˜¶ä¹˜è®¡ç®—\n///|\ntest \"mathematical_factorial_calculation\" {\n  // è®¡ç®— 5! = 5 * 4 * 3 * 2 * 1 = 120\n  let factorial_5 = multiply(\n    5,\n    multiply(\n      4,\n      multiply(\n        3,\n        multiply(2, 1)\n      )\n    )\n  )\n  assert_eq(120, factorial_5)\n  \n  // è®¡ç®— 4! = 4 * 3 * 2 * 1 = 24\n  let factorial_4 = multiply(\n    4,\n    multiply(\n      3,\n      multiply(2, 1)\n    )\n  )\n  assert_eq(24, factorial_4)\n}\n\n// æµ‹è¯• 4: å­—ç¬¦ä¸²è¾¹ç•Œæµ‹è¯• - é•¿å­—ç¬¦ä¸²å¤„ç†\n///|\ntest \"string_long_input_handling\" {\n  // æµ‹è¯•é•¿å­—ç¬¦ä¸²è¾“å…¥\n  let long_string = \"ThisIsAVeryLongProgrammingLanguageNameForTestingPurposes\"\n  let result = greet(long_string)\n  assert_eq(true, result.contains(\"Hello, \"))\n  assert_eq(true, result.contains(long_string))\n  assert_eq(true, result.contains(\"!\"))\n}\n\n// æµ‹è¯• 5: æ•°å€¼èŒƒå›´æµ‹è¯• - é›¶å€¼é™„è¿‘è¿ç®—\n///|\ntest \"numeric_range_zero_operations\" {\n  // æµ‹è¯•é›¶å€¼é™„è¿‘çš„åŠ æ³•\n  assert_eq(0, add(0, 0))\n  assert_eq(1, add(0, 1))\n  assert_eq(-1, add(0, -1))\n  assert_eq(1, add(1, 0))\n  assert_eq(-1, add(-1, 0))\n  \n  // æµ‹è¯•é›¶å€¼é™„è¿‘çš„ä¹˜æ³•\n  assert_eq(0, multiply(0, 0))\n  assert_eq(0, multiply(0, 1))\n  assert_eq(0, multiply(0, -1))\n  assert_eq(0, multiply(1, 0))\n  assert_eq(0, multiply(-1, 0))\n}\n\n// æµ‹è¯• 6: ç®—æ³•å®ç°æµ‹è¯• - æ–æ³¢é‚£å¥‘æ•°åˆ—\n///|\ntest \"algorithm_fibonacci_sequence\" {\n  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—å‰å‡ é¡¹\n  // F(0) = 0, F(1) = 1, F(2) = 1, F(3) = 2, F(4) = 3, F(5) = 5\n  \n  // F(2) = F(1) + F(0) = 1 + 0 = 1\n  let fib_2 = add(1, 0)\n  assert_eq(1, fib_2)\n  \n  // F(3) = F(2) + F(1) = 1 + 1 = 2\n  let fib_3 = add(fib_2, 1)\n  assert_eq(2, fib_3)\n  \n  // F(4) = F(3) + F(2) = 2 + 1 = 3\n  let fib_4 = add(fib_3, fib_2)\n  assert_eq(3, fib_4)\n  \n  // F(5) = F(4) + F(3) = 3 + 2 = 5\n  let fib_5 = add(fib_4, fib_3)\n  assert_eq(5, fib_5)\n}\n\n// æµ‹è¯• 7: æ•°æ®ç»“æ„æµ‹è¯• - æ ˆæ“ä½œæ¨¡æ‹Ÿ\n///|\ntest \"data_structure_stack_simulation\" {\n  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špush(1), push(2), push(3), pop(), pop(), push(4)\n  \n  // åˆå§‹æ ˆä¸ºç©º\n  let mut stack_top = 0\n  \n  // push(1)\n  stack_top = add(stack_top, 1)\n  assert_eq(1, stack_top)\n  \n  // push(2)\n  stack_top = add(stack_top, 1)\n  assert_eq(2, stack_top)\n  \n  // push(3)\n  stack_top = add(stack_top, 1)\n  assert_eq(3, stack_top)\n  \n  // pop()\n  stack_top = add(stack_top, -1)\n  assert_eq(2, stack_top)\n  \n  // pop()\n  stack_top = add(stack_top, -1)\n  assert_eq(1, stack_top)\n  \n  // push(4)\n  stack_top = add(stack_top, 1)\n  assert_eq(2, stack_top)\n}\n\n// æµ‹è¯• 8: å¹¶å‘å®‰å…¨æµ‹è¯• - é‡å¤æ“ä½œä¸€è‡´æ€§\n///|\ntest \"concurrent_safety_repeated_operations\" {\n  // æµ‹è¯•é‡å¤æ‰§è¡Œç›¸åŒæ“ä½œçš„ç»“æœä¸€è‡´æ€§\n  \n  // é‡å¤åŠ æ³•æ“ä½œ\n  let add_result_1 = add(100, 200)\n  let add_result_2 = add(100, 200)\n  let add_result_3 = add(100, 200)\n  assert_eq(add_result_1, add_result_2)\n  assert_eq(add_result_2, add_result_3)\n  \n  // é‡å¤ä¹˜æ³•æ“ä½œ\n  let mul_result_1 = multiply(15, 20)\n  let mul_result_2 = multiply(15, 20)\n  let mul_result_3 = multiply(15, 20)\n  assert_eq(mul_result_1, mul_result_2)\n  assert_eq(mul_result_2, mul_result_3)\n  \n  // é‡å¤å­—ç¬¦ä¸²æ“ä½œ\n  let str_result_1 = greet(\"Test\")\n  let str_result_2 = greet(\"Test\")\n  let str_result_3 = greet(\"Test\")\n  assert_eq(str_result_1, str_result_2)\n  assert_eq(str_result_2, str_result_3)\n}\n\n// æµ‹è¯• 9: å†…å­˜æ•ˆç‡æµ‹è¯• - å¤§æ•°æ®å¤„ç†æ¨¡æ‹Ÿ\n///|\ntest \"memory_efficiency_large_data_simulation\" {\n  // æ¨¡æ‹Ÿå¤„ç†å¤§é‡æ•°æ®æ—¶çš„è¿ç®—æ•ˆç‡\n  \n  // æ¨¡æ‹Ÿå¤„ç†1000ä¸ªæ•°æ®é¡¹ï¼Œæ¯ä¸ªå€¼ä¸º10\n  let item_value = 10\n  let item_count = 1000\n  \n  // è®¡ç®—æ€»å’Œï¼š10 * 1000 = 10000\n  let total_sum = multiply(item_value, item_count)\n  assert_eq(10000, total_sum)\n  \n  // è®¡ç®—å¹³å‡å€¼ï¼šæ€»å’Œ / æ•°é‡ = 10000 / 1000 = 10\n  // é€šè¿‡åå‘éªŒè¯ï¼š10 * 1000 = 10000\n  let average_check = multiply(10, item_count)\n  assert_eq(total_sum, average_check)\n}\n\n// æµ‹è¯• 10: å…¼å®¹æ€§æµ‹è¯• - ä¸åŒè¾“å…¥æ ¼å¼\n///|\ntest \"compatibility_different_input_formats\" {\n  // æµ‹è¯•ä¸åŒæ ¼å¼çš„å­—ç¬¦ä¸²è¾“å…¥\n  \n  // æ•°å­—å­—ç¬¦ä¸²\n  let numeric_string = \"123456\"\n  let result1 = greet(numeric_string)\n  assert_eq(\"Hello, 123456!\", result1)\n  \n  // åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²\n  let spaced_string = \"Moon Bit Language\"\n  let result2 = greet(spaced_string)\n  assert_eq(\"Hello, Moon Bit Language!\", result2)\n  \n  // ç‰¹æ®Šç¬¦å·å­—ç¬¦ä¸²\n  let symbol_string = \"C++_Developer\"\n  let result3 = greet(symbol_string)\n  assert_eq(\"Hello, C++_Developer!\", result3)\n  \n  // æ··åˆæ ¼å¼å­—ç¬¦ä¸²\n  let mixed_string = \"User_2024_Pro\"\n  let result4 = greet(mixed_string)\n  assert_eq(\"Hello, User_2024_Pro!\", result4)\n}","// åŸºç¡€åº“æ–‡ä»¶\n///|\npub fn add(a : Int, b : Int) -> Int {\n  // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœæœ‰ä¸€ä¸ªæ˜¯0ï¼Œç›´æ¥è¿”å›å¦ä¸€ä¸ª\n  if a == 0 {\n    return b\n  }\n  if b == 0 {\n    return a\n  }\n\n  // å¤„ç†æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼ˆInt32çš„æœ€å°å€¼ï¼‰\n  let min_val = -2147483648\n  let max_val = 2147483647\n\n  // å¤„ç†ä¸€ä¸ªæ“ä½œæ•°æ˜¯æœ€å°å€¼çš„æƒ…å†µ\n  if a == min_val {\n    // æœ€å°å€¼ + è´Ÿæ•° = å¯èƒ½æº¢å‡º\n    if b < 0 {\n      return min_val\n    }\n    // æœ€å°å€¼ + éè´Ÿæ•° = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—\n    return a + b\n  }\n  if b == min_val {\n    // è´Ÿæ•° + æœ€å°å€¼ = å¯èƒ½æº¢å‡º\n    if a < 0 {\n      return min_val\n    }\n    // éè´Ÿæ•° + æœ€å°å€¼ = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—\n    return a + b\n  }\n\n  // æ­£æ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥\n  if a > 0 && b > 0 {\n    // å¦‚æœ a > max_val - bï¼Œåˆ™ a + b ä¼šæº¢å‡º\n    if a > max_val - b {\n      return max_val\n    }\n  }\n\n  // è´Ÿæ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥ï¼ˆæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼ï¼‰\n  if a < 0 && b < 0 {\n    // ä½¿ç”¨å‡æ³•æ£€æŸ¥ï¼ša < min_val - b\n    // ç”±äºbæ˜¯è´Ÿæ•°ï¼Œmin_val - b = min_val + abs(b)\n    if a < min_val - b {\n      return min_val\n    }\n  }\n\n  // å®‰å…¨åœ°è¿›è¡ŒåŠ æ³•è¿ç®—\n  return a + b\n}\n\n///|\npub fn multiply(a : Int, b : Int) -> Int {\n  // å¸¸é‡å®šä¹‰\n  let min_val = -2147483648\n  let max_val = 2147483647\n\n  // å¤„ç†0çš„æƒ…å†µ\n  if a == 0 || b == 0 {\n    return 0\n  }\n\n  // å¤„ç†1çš„æƒ…å†µ\n  if a == 1 {\n    return b\n  }\n  if b == 1 {\n    return a\n  }\n\n  // å¤„ç†-1çš„æƒ…å†µï¼ˆåŒ…æ‹¬æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼‰\n  if a == -1 {\n    // -2147483648 * -1 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val\n    return if b == min_val { min_val } else { -b }\n  }\n  if b == -1 {\n    // -1 * -2147483648 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val\n    return if a == min_val { min_val } else { -a }\n  }\n\n  // å¤„ç†æœ€å°å€¼çš„æƒ…å†µ\n  if a == min_val {\n    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º\n    return if b > 1 || b < -1 { min_val } else { a * b }\n  }\n  if b == min_val {\n    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º\n    return if a > 1 || a < -1 { min_val } else { a * b }\n  }\n\n  // æ£€æŸ¥æ­£è´Ÿå·\n  let sign = if (a > 0 && b > 0) || (a < 0 && b < 0) { 1 } else { -1 }\n\n  // å®‰å…¨åœ°è®¡ç®—ç»å¯¹å€¼ï¼Œæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼\n  let abs_a = if a < 0 { -a } else { a }\n  let abs_b = if b < 0 { -b } else { b }\n\n  // ä¼˜åŒ–çš„æº¢å‡ºæ£€æŸ¥ï¼šä½¿ç”¨é™¤æ³•æ¥é¿å…ä¹˜æ³•æº¢å‡º\n  // æ£€æŸ¥ abs_a > max_val / abs_b æ¥é¿å…ä¹˜æ³•æº¢å‡º\n  if abs_a > max_val / abs_b {\n    return if sign > 0 { max_val } else { min_val }\n  }\n\n  // å®‰å…¨åœ°è¿›è¡Œä¹˜æ³•è¿ç®—\n  return a * b\n}\n\n///|\npub fn greet(name : String) -> String {\n  // å­—ç¬¦ä¸²æ‹¼æ¥ï¼šç©ºå­—ç¬¦ä¸²ä¼šè‡ªåŠ¨å¤„ç†\n  \"Hello, \" + name + \"!\"\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\n/// TODO: can not make a dummy loc\npub(all) type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"@package:file:start_line:start_column-end_line:end_column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\nfn SourceLoc::repr(self : Self) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  SourceLocRepr::parse(self.repr()).output(logger)\n}\n\n///|\npriv struct SourceLocRepr {\n  pkg : StringView\n  filename : StringView\n  start_line : StringView\n  start_column : StringView\n  end_line : StringView\n  end_column : StringView\n}\n\n///|\nimpl Show for SourceLocRepr with output(self, logger) {\n  let pkg = self.pkg\n  let (module_name, package_name) = lexmatch pkg {\n    ((\"[^/]*/[^/]*\" as module_name) \"/\" (\".*\" as package_name)) =>\n      (module_name, Some(package_name))\n    _ => (pkg, None)\n  }\n  if package_name is Some(pkg_name) {\n    logger..write_view(pkg_name)..write_char('/')\n  }\n  logger\n  ..write_view(self.filename)\n  ..write_char(':')\n  ..write_view(self.start_line)\n  ..write_char(':')\n  ..write_view(self.start_column)\n  ..write_char('-')\n  ..write_view(self.end_line)\n  ..write_char(':')\n  ..write_view(self.end_column)\n  ..write_char('@')\n  ..write_view(module_name)\n}\n\n///|\nfn SourceLocRepr::parse(repr : String) -> SourceLocRepr {\n  lexmatch repr[:] {\n    (\n      \"@\"\n      (\"[^:]*\" as pkg)\n      \":\"\n      (\".+?\" as filename)\n      \":\"\n      (\"[[:digit:]]+\" as start_line)\n      \":\"\n      (\"[[:digit:]]+\" as start_column)\n      \"-\"\n      (\"[[:digit:]]+\" as end_line)\n      \":\"\n      (\"[[:digit:]]+\" as end_column)\n    ) => { pkg, filename, start_line, start_column, end_line, end_column }\n    _ => panic()\n  }\n}\n\n///|\nfn SourceLocRepr::to_json_string(self : SourceLocRepr) -> String {\n  StringBuilder::new()\n  ..write_string(\"{\\\"pkg\\\":\\\"\\{self.pkg}\\\"\")\n  ..write_string(\",\\\"filename\\\":\")\n  ..write_object(self.filename)\n  ..write_string(\",\\\"start_line\\\":\\{self.start_line}\")\n  ..write_string(\",\\\"start_column\\\":\\{self.start_column}\")\n  ..write_string(\",\\\"end_line\\\":\\{self.end_line}\")\n  ..write_string(\",\\\"end_column\\\":\\{self.end_column}}\")\n  .to_string()\n}\n\n///|\n/// Convert a source location to a JSON string\npub fn SourceLoc::to_json_string(self : SourceLoc) -> String {\n  SourceLocRepr::parse(self.repr()).to_json_string()\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) struct ArgsLoc(Array[SourceLoc?]) derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  let ArgsLoc(self) = self\n  buf.write_char('[')\n  for i in 0..<self.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => buf.write_string(loc.to_json_string())\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn println_mono(s : String) -> Unit = \"%println\"\n\n///|\nfn[T] any_to_string(any : T) -> String = \"%any.to_string\"\n\n///|\n/// Prints any value that implements the `Show` trait to the standard output,\n/// followed by a newline.\n///\n/// Parameters:\n///\n/// * `value` : The value to be printed. Must implement the `Show` trait.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   if false {\n///     println(42)\n///     println(\"Hello, World!\")\n///     println([1, 2, 3])\n///   }\n/// }\n/// ```\npub fn[T : Show] println(input : T) -> Unit {\n  println_mono(input.to_string())\n}\n\n///|\n/// Represents an error type used by the `inspect` function to indicate failures\n/// in value inspection. Contains a string message describing the nature of the\n/// inspection failure.\n///\n/// Returns a type constructor that creates an error type from a string message.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Int = 42\n///   inspect(x, content=\"42\") // Raises InspectError with detailed failure message\n/// }\n/// ```\npub(all) suberror InspectError String\n\n///|\nfn base64_encode(data : FixedArray[Byte]) -> String {\n  let base64 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let buf = StringBuilder::new()\n  let len = data.length()\n  let rem = len % 3\n  for i = 0; i < len - rem; i = i + 3 {\n    let b0 = data[i].to_int()\n    let b1 = data[i + 1].to_int()\n    let b2 = data[i + 2].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[((b1 & 0x0F) << 2) | ((b2 & 0xC0) >> 6)]\n    let x3 = base64[b2 & 0x3F]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char(x3.to_char())\n  }\n  if rem == 1 {\n    let b0 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[(b0 & 0x03) << 4]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char('=')\n    buf.write_char('=')\n  } else if rem == 2 {\n    let b0 = data[len - 2].to_int()\n    let b1 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[(b1 & 0x0F) << 2]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char('=')\n  }\n  buf.to_string()\n}\n\n///|\nfn base64_encode_string_codepoint(s : String) -> String {\n  // the input string is expected to be valid utf-16 string\n  let codepoint_length = s.char_length()\n  let data : FixedArray[Byte] = FixedArray::make(codepoint_length * 4, 0)\n  for i = 0, utf16_index = 0\n      i < codepoint_length\n      i = i + 1, utf16_index = utf16_index + 1 {\n    let c = s.unsafe_char_at(utf16_index).to_int()\n    if c > 0xFFFF {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = ((c >> 16) & 0xFF).to_byte()\n      data[i * 4 + 3] = ((c >> 24) & 0xFF).to_byte()\n      continue i + 1, utf16_index + 2\n    } else {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = 0\n      data[i * 4 + 3] = 0\n    }\n  }\n  base64_encode(data)\n}\n\n///|\ntest {\n  inspect(base64_encode_string_codepoint(\"\"))\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAA==\")\n  inspect(base64_encode_string_codepoint(\"ab\"), content=\"YQAAAGIAAAA=\")\n  inspect(base64_encode_string_codepoint(\"abc\"), content=\"YQAAAGIAAABjAAAA\")\n  inspect(\n    base64_encode_string_codepoint(\"abcd\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"abcde\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAGUAAAA=\",\n  )\n  inspect(base64_encode_string_codepoint(\"aä¸­\"), content=\"YQAAAC1OAAA=\")\n  inspect(\n    base64_encode_string_codepoint(\"aä¸­ğŸ¤£\"),\n    content=\"YQAAAC1OAAAj+QEA\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"aä¸­ğŸ¤£a\"),\n    content=\"YQAAAC1OAAAj+QEAYQAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"aä¸­ğŸ¤£ä¸­\"),\n    content=\"YQAAAC1OAAAj+QEALU4AAA==\",\n  )\n}\n\n///|\n/// Tests if the string representation of an object matches the expected content.\n/// Used primarily in test cases to verify the correctness of `Show`\n/// implementations and program outputs.\n///\n/// Parameters:\n///\n/// * `object` : The object to be inspected. Must implement the `Show` trait.\n/// * `content` : The expected string representation of the object. Defaults to\n/// an empty string.\n/// * `location` : Source code location information for error reporting.\n/// Automatically provided by the compiler.\n/// * `arguments_location` : Location information for function arguments in\n/// source code. Automatically provided by the compiler.\n///\n/// Throws an `InspectError` if the actual string representation of the object\n/// does not match the expected content. The error message includes detailed\n/// information about the mismatch, including source location and both expected\n/// and actual values.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42, content=\"42\")\n///   inspect(\"hello\", content=\"hello\")\n///   inspect([1, 2, 3], content=\"[1, 2, 3]\")\n/// }\n/// ```\n#callsite(autofill(args_loc, loc))\npub fn inspect(\n  obj : &Show,\n  content? : String = \"\",\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise InspectError {\n  let actual = obj.to_string()\n  if actual != content {\n    let loc = loc.to_json_string()\n    let args_loc = args_loc.to_json()\n    let expect_escaped = content.escape()\n    let actual_escaped = actual.escape()\n    let expect_base64 = \"\\\"\\{base64_encode_string_codepoint(content)}\\\"\"\n    let actual_base64 = \"\\\"\\{base64_encode_string_codepoint(actual)}\\\"\"\n    raise InspectError(\n      \"@EXPECT_FAILED {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect_escaped}, \\\"actual\\\": \\{actual_escaped}, \\\"expect_base64\\\": \\{expect_base64}, \\\"actual_base64\\\": \\{actual_base64}}\",\n    )\n  }\n}\n\n///|\n/// Represents an error that occurs during snapshot testing. Contains a string\n/// message describing the error.\n///\n/// Used internally by the test driver to handle snapshot-related errors. Not\n/// intended for direct use by end users.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : SnapshotError = SnapshotError(\"failed to load snapshot\")\n///   match err {\n///     SnapshotError(msg) => assert_eq(msg, \"failed to load snapshot\")\n///   }\n/// }\n/// ```\npub(all) suberror SnapshotError String\n\n///|\npub(all) suberror BenchError String\n\n///|\ntest \"panic error case of inspect\" {\n  let x : Int = 42\n  inspect(x, content=\"100\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let h1 = Hasher::new(seed=0) // Create a hasher with default seed\n///   let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n///   let x = 123\n///   h1.combine(x)\n///   h2.combine(x)\n///   inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// }\n/// ```\npub fn Hasher::new(seed? : Int = seed) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n#cfg(not(target=\"js\"))\nlet seed : Int = 0\n\n///|\n#cfg(target=\"js\")\nlet seed : Int = random_seed()\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn random_seed() -> Int =\n  #|() => {\n  #|  if (globalThis.crypto?.getRandomValues) {\n  #|    const array = new Uint32Array(1);\n  #|    globalThis.crypto.getRandomValues(array);\n  #|    return array[0] | 0; // Convert to signed 32\n  #|  } else {\n  #|    return Math.floor(Math.random() * 0x100000000) | 0; // Fallback to Math.random\n  #|  }\n  #|}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(42)\n///   hasher.combine(\"hello\")\n///   inspect(hasher.finalize(), content=\"860601284\")\n/// }\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_unit()\n///   inspect(hasher.finalize(), content=\"148298089\")\n/// }\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bool(true)\n///   inspect(hasher.finalize(), content=\"-205818221\")\n/// }\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int64(42L)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_double(3.14)\n///   inspect(hasher.finalize(), content=\"-428265677\")\n/// }\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(3.14F)\n///   inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// }\n/// ```\n#deprecated\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\nfn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n///   inspect(hasher.finalize(), content=\"-686861102\")\n/// }\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_string(\"hello\")\n///   inspect(hasher.finalize(), content=\"-655549713\")\n/// }\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_char('A')\n///   inspect(hasher.finalize(), content=\"-1625495534\")\n/// }\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s1 = \"hello\"\n///   let s2 = \"hello\"\n///   let s3 = \"world\"\n///   inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n///   inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// }\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\npub impl Hash for StringView with hash_combine(\n  self : StringView,\n  hasher : Hasher,\n) -> Unit {\n  let str = self.str()\n  for i in self.start()..<self.end() {\n    hasher.combine_uint(str.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_int(42)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint(42U)\n///   inspect(hasher.finalize(), content=\"1161967057\")\n/// }\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_uint64(42UL)\n///   inspect(hasher.finalize(), content=\"-1962516083\")\n/// }\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let some_value : Int? = Some(42)\n///   let none_value : Int? = None\n///   hasher.combine(some_value)\n///   inspect(hasher.finalize(), content=\"2103260413\")\n///   let hasher2 = Hasher::new(seed=0)\n///   hasher2.combine(none_value)\n///   inspect(hasher2.finalize(), content=\"148298089\")\n/// }\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   let ok_result : Result[Int, String] = Ok(42)\n///   let err_result : Result[Int, String] = Err(\"error\")\n///   hasher.combine(ok_result)\n///   inspect(hasher.finalize(), content=\"-1948635851\")\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine(err_result)\n///   inspect(hasher.finalize(), content=\"1953766574\")\n/// }\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0)..combine(x)\n    Err(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\npub impl Hash for BytesView with hash_combine(self : BytesView, hasher : Hasher) {\n  let mut start = self.start()\n  let data = self.bytes()\n  let mut rest = self.len()\n  while rest >= 4 {\n    let mut result : UInt = 0\n    for i in 0..=3 {\n      result = result | (data.unsafe_get(i + start).to_uint() << (8 * i))\n    }\n    hasher.combine_uint(result)\n    rest -= 4\n    start += 4\n  }\n  while rest >= 1 {\n    hasher.combine_byte(data.unsafe_get(start))\n    rest -= 1\n    start += 1\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let fixed = FixedArray::make(3, 42)\n///   let dynamic = Array::from_fixed_array(fixed)\n///   inspect(dynamic, content=\"[42, 42, 42]\")\n/// }\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::make(3, 42)\n///   inspect(arr, content=\"[42, 42, 42]\")\n/// }\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = Array::make(10, Array::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Creates a new array of the specified length, where each element is\n/// initialized using an index-based initialization function.\n///\n/// Parameters:\n///\n/// * `length` : The length of the new array. If `length` is less than or equal\n/// to 0, returns an empty array.\n/// * `initializer` : A function that takes an index (starting from 0) and\n/// returns a value of type `T`. This function is called for each index to\n/// initialize the corresponding element.\n///\n/// Returns a new array of type `Array[T]` with the specified length, where each\n/// element is initialized using the provided function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = Array::makei(3, i => i * 2)\n///   inspect(arr, content=\"[0, 2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::makei(length : Int, f : (Int) -> T raise?) -> Array[T] raise? {\n  if length <= 0 {\n    []\n  } else {\n    let array = Array::make_uninit(length)\n    for i in 0..<length {\n      array.unsafe_set(i, f(i))\n    }\n    array\n  }\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_get(1), content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr[1], content=\"2\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.get\")\n#alias(\"_[_]\")\npub fn[T] Array::at(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.get(-1), content=\"None\")\n///   inspect(arr.get(0), content=\"Some(1)\")\n///   inspect(arr.get(3), content=\"None\")\n/// }\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\npub fn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr[1] = 42\n///   inspect(arr, content=\"[1, 42, 3]\")\n/// }\n/// ```\n///\n#intrinsic(\"%array.set\")\n#alias(\"_[_]=_\")\npub fn[T] Array::set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 3]\n///   let arr3 = [1, 2, 4]\n///   inspect(arr1 == arr2, content=\"true\")\n///   inspect(arr1 == arr3, content=\"false\")\n/// }\n/// ```\npub impl[T : Eq] Eq for Array[T] with equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays based on shortlex order.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = [1, 2, 4]\n///   let arr3 = [1, 2]\n///   inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n///   inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n///   inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n///   inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// }\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = [1, 2, 3]\n///   let b = [4, 5]\n///   inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// }\n/// ```\npub impl[T] Add for Array[T] with add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v1 = [1, 2, 3]\n///   let v2 = [4, 5, 6]\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n///   let v1 = [1, 2, 3]\n///   let v2 : Array[Int] = []\n///   v1.append(v2)\n///   inspect(v1, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[T] Array::append(self : Array[T], other : ArrayView[T]) -> Unit {\n  other.blit_to(self, dst_offset=self.length())\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each(x => sum = sum - x)\n///   @json.inspect(sum, content=-12)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => sum = sum + x + i)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.eachi((i, x) => sum = sum + x + i)\n///   inspect(sum, content=\"15\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Checks whether all elements satisfy the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.all(x => x < 6))\n///   assert_false(arr.all(x => x < 5))\n/// }\n/// ```\n#alias(every)\npub fn[T] Array::all(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].all(f)\n}\n\n///|\n/// Checks whether any element satisfies the predicate.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   assert_true(arr.any(x => x < 6))\n///   assert_false(arr.any(x => x < 1))\n/// }\n/// ```\n#alias(exists)\npub fn[T] Array::any(self : Array[T], f : (T) -> Bool raise?) -> Bool raise? {\n  self[:].any(f)\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// }\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.map(x => x + 1)\n///   assert_eq(v2, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.map_in_place(x => x + 1)\n///   assert_eq(v, [4, 5, 6])\n/// }\n/// ```\n#locals(f)\n#alias(map_inplace, deprecated)\npub fn[T] Array::map_in_place(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => x + i)\n///   assert_eq(v2, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   v.mapi_in_place((i, x) => x + i)\n///   assert_eq(v, [3, 5, 7])\n/// }\n/// ```\n#locals(f)\n#alias(mapi_inplace, deprecated)\npub fn[T] Array::mapi_in_place(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let evens = arr.filter(x => x % 2 == 0)\n///   inspect(evens, content=\"[2, 4]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let empty : Array[Int] = []\n///   inspect(empty.is_empty(), content=\"true\")\n///   let non_empty = [1, 2, 3]\n///   inspect(non_empty.is_empty(), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n///   let arr : Array[Int] = []\n///   arr.rev_in_place()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n#alias(rev_inplace, deprecated)\npub fn[T] Array::rev_in_place(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n///   inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// }\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let (v1, v2) = (v[:1], v[1:])\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// }\n/// ```\n#deprecated(\"Use ArrayView instead, e.g, (a[:index], a[index:])\")\n#doc(hidden)\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.contains(3), content=\"true\")\n///   inspect(arr.contains(6), content=\"false\")\n///   let arr : Array[Int] = []\n///   inspect(arr.contains(1), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.starts_with([1, 2]), content=\"true\")\n///   inspect(arr.starts_with([2, 3]), content=\"false\")\n///   inspect(arr.starts_with([]), content=\"true\")\n///   inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  self[:].starts_with(prefix[:])\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.ends_with([4, 5]), content=\"true\")\n///   inspect(arr.ends_with([3, 4]), content=\"false\")\n///   inspect(arr.ends_with([]), content=\"true\")\n///   let arr : Array[Int] = []\n///   inspect(arr.ends_with([]), content=\"true\")\n///   inspect(arr.ends_with([1]), content=\"false\")\n/// }\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  self[:].ends_with(suffix[:])\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n///   inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// }\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// }\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 2, 4]\n///   inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n///   inspect(arr.search(5), content=\"None\") // not found\n/// }\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  self[:].search(value)\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by(x => x == 3) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// }\n/// ```\n#locals(f)\n#alias(find_index, deprecated)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// }\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  self[:].binary_search(value)\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 3, 5, 7, 9]\n///   let find_3 = arr.binary_search_by(x => x.compare(3))\n///   inspect(find_3, content=\"Ok(1)\")\n///   let find_4 = arr.binary_search_by(x => x.compare(4))\n///   inspect(find_4, content=\"Err(2)\")\n/// }\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int raise?,\n) -> Result[Int, Int] raise? {\n  self[:].binary_search_by(cmp)\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   arr.swap(0, 2)\n///   inspect(arr, content=\"[3, 2, 1]\")\n/// }\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain(x => x % 2 == 0)\n///   inspect(arr, content=\"[2, 4]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(x => x > 10)\n///   inspect(arr, content=\"[]\")\n///   let arr = [1, 2, 3]\n///   arr.retain(_ => true)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.resize(3, 0)\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr = [1, 2, 3]\n///   arr.resize(5, 0)\n///   inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// }\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens an array of arrays into an array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [[3, 4], [5, 6]].flatten()\n///   assert_eq(v, [3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create an array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [3, 4].repeat(2)\n///   assert_eq(v, [3, 4, 3, 4])\n/// }\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_left, deprecated)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n///   assert_eq(sum, 15)\n/// }\n/// ```\n#locals(f)\n#alias(fold_right, deprecated)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_lefti, deprecated)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n///   assert_eq(sum, 10)\n/// }\n/// ```\n#locals(f)\n#alias(fold_righti, deprecated)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 2, 3, 3, 3, 2]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3, 2]\")\n///   let arr = [1, 2, 2, 2, 3, 3]\n///   arr.dedup()\n///   inspect(arr, content=\"[1, 2, 3]\")\n///   let arr : Array[Int] = []\n///   arr.dedup()\n///   inspect(arr, content=\"[]\")\n/// }\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let extracted = arr.extract_if(x => x % 2 == 0)\n///   inspect(extracted, content=\"[2, 4]\")\n///   inspect(arr, content=\"[1, 3, 5]\")\n/// }\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let removed = []\n  let mut write = 0\n  for read in 0..<self.length() {\n    let elem = self[read]\n    if f(elem) {\n      removed.push(elem)\n    } else {\n      if read != write {\n        self[write] = elem\n      }\n      write += 1\n    }\n  }\n  self.truncate(write)\n  removed\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let chunks = arr.chunks(2)\n///   inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n///   let arr : Array[Int] = []\n///   inspect(arr.chunks(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length()\n  if len == 0 {\n    return []\n  }\n  let num_chunks = (len + size - 1) / size\n  Array::makei(num_chunks, i => {\n    let start = i * size\n    let end = Int::min(start + size, len)\n    self[start:end]\n  })\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n///   let chunks = v.chunk_by((x, y) => x <= y)\n///   inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n///   let v : Array[Int] = []\n///   inspect(v.chunk_by((x, y) => x <= y), content=\"[]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[ArrayView[T]] raise? {\n  let chunks = []\n  if self.is_empty() {\n    return chunks\n  }\n  let mut start = 0\n  for i in 1..<self.length() {\n    if !pred(self[i - 1], self[i]) {\n      chunks.push(self[start:i])\n      start = i\n    }\n  }\n  chunks.push(self[start:self.length()])\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   let windows = arr.windows(2)\n///   inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n///   let arr = [1, 2]\n///   inspect(arr.windows(3), content=\"[]\")\n/// }\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  Array::makei(len, i => self[i:i + size])\n}\n\n///|\npub fn[T] Array::suffixes(\n  self : Array[T],\n  include_empty? : Bool = false,\n) -> Iter[ArrayView[T]] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 0, 2, 0, 3, 0, 4]\n///   inspect(arr.split(x => x == 0), content=\"[[1], [2], [3], [4]]\")\n///   let arr = [0, 1, 0, 0, 2, 0]\n///   inspect(arr.split(x => x == 0), content=\"[[], [1], [], [2]]\")\n/// }\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let mut sum = 0\n///   arr.iter().each(x => sum = sum + x)\n///   inspect(sum, content=\"6\")\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  self[:].iter()\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   let result = []\n///   arr.rev_iter().each(x => result.push(x))\n///   inspect(result, content=\"[3, 2, 1]\")\n/// }\n/// ```\n#alias(rev_iterator, deprecated)\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  self[:].rev_iter()\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [10, 20, 30]\n///   let mut sum = 0\n///   arr.iter2().each((i, x) => sum = sum + i + x)\n///   inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  self[:].iter2()\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : Array[Int] = Array::default()\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.is_empty(), content=\"true\")\n/// }\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// }\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\n#doc(hidden)\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.truncate(3)\n///   inspect(arr, content=\"[1, 2, 3]\")\n/// }\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.retain_map(fn(x) { if x % 2 == 0 { Some(x * 2) } else { None } })\n///   inspect(arr, content=\"[4, 8]\")\n/// }\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n\n///|\n/// Creates a new array containing all elements from an iterator.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator containing elements of type `T`.\n///\n/// Returns a new array containing all elements from the iterator in the same\n/// order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = Iter::singleton(42)\n///   let arr = Array::from_iter(iter)\n///   inspect(arr, content=\"[42]\")\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn[T] Array::from_iter(iter : Iter[T]) -> Array[T] {\n  iter.collect()\n}\n\n///|\n/// Adds all elements from an iterator to the end of the array.\n///\n/// This function iterates over each element in the provided iterator\n/// and adds them to the array using the `push` method.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let u = [1, 2, 3]\n///   let v = [4, 5, 6]\n///   u.push_iter(v.iter())\n///   assert_eq(u, [1, 2, 3, 4, 5, 6])\n/// }\n/// ```\npub fn[T] Array::push_iter(self : Self[T], iter : Iter[T]) -> Unit {\n  // This function used by [Array spread operator](https://docs.moonbitlang.com/en/latest/language/fundamentals.html#spread-operator)\n  // it can't be removed and deprecated\n  for x in iter {\n    self.push(x)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt check\n/// test {\n/// let arr = [1, 2, 3, 4, 5]\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// Array::shuffle_in_place(arr, rand~)\n/// }\n/// ```\npub fn[T] Array::shuffle_in_place(\n  self : Array[T],\n  rand~ : (Int) -> Int,\n) -> Unit {\n  let n = self.length()\n  for i = n - 1; i > 0; i = i - 1 {\n    let j = rand(i + 1) % (i + 1)\n    // for safety, perf is not a concern here\n    // TODO: maybe return an error later\n    self.swap(i, j)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt\n/// let arr = [1, 2, 3, 4, 5]\n///\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// let _shuffled = Array::shuffle(arr, rand~)\n/// ```\npub fn[T] Array::shuffle(self : Array[T], rand~ : (Int) -> Int) -> Array[T] {\n  let new_arr = self.copy()\n  Array::shuffle_in_place(new_arr, rand~)\n  new_arr\n}\n\n///|\n/// Returns a new array containing the elements of the original array that satisfy the given predicate.\n///\n/// # Arguments\n///\n/// * `self` - The array to filter.\n/// * `f` - The predicate function.\n///\n/// # Returns\n///\npub fn[A, B] Array::filter_map(\n  self : Array[A],\n  f : (A) -> B? raise?,\n) -> Array[B] raise? {\n  let result = []\n  for x in self {\n    if f(x) is Some(x) {\n      result.push(x)\n    }\n  }\n  result\n}\n\n///|\n/// Returns the last element of the array, or `None` if the array is empty.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the last element from.\n///\n/// Returns an optional value containing the last element of the array. The\n/// result is `None` if the array is empty, or `Some(x)` where `x` is the last\n/// element of the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.last(), content=\"Some(3)\")\n///   let empty : Array[Int] = []\n///   inspect(empty.last(), content=\"None\")\n/// }\n/// ```\npub fn[A] Array::last(self : Array[A]) -> A? {\n  match self {\n    [] => None\n    [.., last] => Some(last)\n  }\n}\n\n///|\n/// Zips two arrays into a single array of tuples.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an array of tuples, where each tuple contains corresponding elements\n/// from the two input arrays.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(arr1.zip(arr2), content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\")\n/// }\n/// ```\npub fn[A, B] Array::zip(self : Array[A], other : Array[B]) -> Array[(A, B)] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  Array::makei(length, i => (self[i], other[i]))\n}\n\n///|\n/// Splits an array of pairs into two arrays, separating the first and second elements.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let arr = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n///   let (nums, strs) = arr.unzip()\n///   inspect(nums, content=\"[1, 2, 3]\")\n///   inspect(strs, content=\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\")\n/// }\n/// ```\npub fn[T1, T2] Array::unzip(self : Array[(T1, T2)]) -> (Array[T1], Array[T2]) {\n  let arr1 : Array[T1] = Array::new(capacity=self.length())\n  let arr2 : Array[T2] = Array::new(capacity=self.length())\n  for pair in self {\n    let (x, y) = pair\n    arr1.push(x)\n    arr2.push(y)\n  }\n  (arr1, arr2)\n}\n\n///|\n/// Zips two arrays into an iterator that yields corresponding elements.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an `Iter2` iterator that produces corresponding elements\n/// from both arrays. The iteration continues until the shorter array is exhausted.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = ['a', 'b', 'c']\n///   inspect(\n///     arr1.zip_to_iter2(arr2).to_array(),\n///     content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\",\n///   )\n/// }\n/// ```\npub fn[A, B] Array::zip_to_iter2(\n  self : Array[A],\n  other : Array[B],\n) -> Iter2[A, B] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  let mut i = 0\n  Iter2::new(() => {\n    guard i < length else { None }\n    let elem = (self[i], other[i])\n    i += 1\n    Some(elem)\n  }).iter2()\n}\n\n///|\n/// Join an array of strings using the provided `separator`.\n///\n/// Parameters:\n///   * `separator` : The string inserted between each element.\n///\n/// Returns a single concatenated `String`.\n/// # Example:\n/// ```mbt check\n/// test {\n///   let s = \"hello world\"\n///   inspect(s.split(\" \").to_array().join(\":\"), content=\"hello:world\")\n/// }\n/// ```\npub fn[A : ToStringView] Array::join(\n  self : Array[A],\n  separator : StringView,\n) -> String {\n  self[:].join(separator)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n\n///|\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let map = { 3: \"three\", 8: \"eight\", 1: \"one\" }\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// }\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity? : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : ArrayView[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  for e in arr {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n/// Sets a key-value pair into the hash map. If the key already exists, updates\n/// its value. If the hash map is near full capacity, automatically\n/// grows the internal storage to accommodate more entries.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to insert or update. Must implement `Hash` and `Eq` traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map : Map[String, Int] = Map::new()\n///   map.set(\"key\", 42)\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   map.set(\"key\", 24) // update existing key\n///   inspect(map.get(\"key\"), content=\"Some(24)\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  self.set_with_hash(key, value, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::set_with_hash(\n  self : Map[K, V],\n  key : K,\n  value : V,\n  hash : Int,\n) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, value, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Retrieves the value associated with a given key in the hash map.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to search in.\n/// * `key` : The key to look up in the map.\n///\n/// Returns `Some(value)` if the key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"key\": 42 }\n///   inspect(map.get(\"key\"), content=\"Some(42)\")\n///   inspect(map.get(\"nonexistent\"), content=\"None\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n#alias(\"_[_]\")\npub fn[K : Hash + Eq, V] Map::at(self : Map[K, V], key : K) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry)\n    if entry.hash == hash && entry.key == key {\n      return entry.value\n    }\n    guard i <= entry.psl\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.get_or_default(\"a\", 0), content=\"1\")\n///   inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          return entry.value\n        }\n        if psl > entry.psl {\n          let new_value = default()\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        let new_value = default()\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set_with_hash(key, new_value, hash)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n  new_value\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   inspect(map.contains_kv(\"a\", 1), content=\"true\")\n///   inspect(map.contains_kv(\"a\", 2), content=\"false\")\n///   inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Removes the entry for the specified key from the hash map. If the key exists\n/// in the map, removes its entry and adjusts the probe sequence length (PSL) of\n/// subsequent entries to maintain the Robin Hood hashing invariant. If the key\n/// does not exist, the map remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to remove the entry from.\n/// * `key` : The key to remove from the map.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///   map.remove(\"a\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.length(), content=\"1\")\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  self.remove_with_hash(key, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::remove_with_hash(\n  self : Map[K, V],\n  key : K,\n  hash : Int,\n) -> Unit {\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \")..write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\n#alias(size, deprecated)\npub fn[K, V] Map::length(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\n#alias(iterator, deprecated)\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, value, next, .. }) => {\n        curr_entry = next\n        Some((key, value))\n      }\n      None => None\n    }\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  self.iter()\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ key, next, .. }) => {\n        curr_entry = next\n        Some(key)\n      }\n      None => None\n    }\n  })\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  let mut curr_entry = self.head\n  Iter::new(fn() {\n    match curr_entry {\n      Some({ value, next, .. }) => {\n        curr_entry = next\n        Some(value)\n      }\n      None => None\n    }\n  })\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n#alias(from_iterator, deprecated)\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  while iter.next() is Some((k, v)) {\n    m.set(k, v)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Merges two maps into a new map. Returns a new map containing all key-value\n/// pairs from both maps. When both maps contain the same key, the value from\n/// `other` takes precedence. The iteration order follows the order of `self`\n/// followed by new entries from `other`.\n///\n/// This is a pure operation - it does not modify either of the input maps.\n///\n/// Parameters:\n///\n/// * `self` : The first map.\n/// * `other` : The second map whose values take precedence in case of key\n/// conflicts.\n///\n/// Returns a new linked hash map containing all entries from both maps.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   let merged = map1.merge(map2)\n///   @json.inspect(merged, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge(self : Map[K, V], other : Map[K, V]) -> Map[K, V] {\n  let result = self.copy()\n  result.merge_in_place(other)\n  result\n}\n\n///|\n/// Merges another map into this map in-place. Updates the current map by adding\n/// all key-value pairs from `other`. When both maps contain the same key, the\n/// value from `other` overwrites the value in this map. New entries from `other`\n/// are added at the end, preserving the original order of `self` and appending\n/// new keys from `other`.\n///\n/// This is a mutating operation - it modifies the receiver map.\n///\n/// Parameters:\n///\n/// * `self` : The map to be modified.\n/// * `other` : The map whose entries will be added to `self`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n///   let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n///   map1.merge_in_place(map2)\n///   @json.inspect(map1, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// }\n/// ```\npub fn[K : Eq, V] Map::merge_in_place(\n  self : Map[K, V],\n  other : Map[K, V],\n) -> Unit {\n  loop other.head {\n    Some({ key, value, next, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Retains only the key-value pairs that satisfy the given predicate function.\n/// This method modifies the map in-place, removing all entries for which\n/// the predicate returns `false`. The order of remaining elements is preserved.\n///\n/// Parameters:\n///\n/// * `self` : The map to be filtered.\n/// * `predicate` : A function that takes a key and value as arguments and returns\n/// `true` if the key-value pair should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4 }\n///   map.retain((_k, v) => v % 2 == 0) // Keep only even values\n///   inspect(map.length(), content=\"2\")\n///   inspect(map.get(\"a\"), content=\"None\")\n///   inspect(map.get(\"b\"), content=\"Some(2)\")\n///   inspect(map.get(\"c\"), content=\"None\")\n///   inspect(map.get(\"d\"), content=\"Some(4)\")\n/// }\n/// ```\n#locals(f)\npub fn[K, V] Map::retain(self : Map[K, V], f : (K, V) -> Bool) -> Unit {\n  loop (self.head, false) {\n    (Some({ key, value, next, prev: idx, .. }), remove_prev) => {\n      if remove_prev {\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n      continue (next, !f(key, value))\n    }\n    (None, remove_prev) =>\n      if remove_prev {\n        let idx = self.tail\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n  }\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"a\": 1, \"b\": 2 }\n///\n///   // Update existing value\n///   map.update(\"a\", fn(v) {\n///     match v {\n///       Some(x) => Some(x + 10)\n///       None => Some(0)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2}\n///     ),\n///   )\n///\n///   // Insert new value\n///   map.update(\"c\", fn(v) {\n///     match v {\n///       Some(x) => Some(x)\n///       None => Some(3)\n///     }\n///   })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"b\": 2, \"c\": 3}\n///     ),\n///   )\n///\n///   // Remove existing value\n///   map.update(\"b\", fn(_) { None })\n///   inspect(\n///     map,\n///     content=(\n///       #|{\"a\": 11, \"c\": 3}\n///     ),\n///   )\n/// }\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n\n// Special handling for Views as accessors\n\n///|\nfn StringView::equal_to_string(self : Self, other : String) -> Bool {\n  let str = self.str()\n  let start = self.start()\n  let end = self.end()\n  let len = end - start\n  guard len == other.length() else { return false }\n  if physical_equal(str, other) && self.start() == 0 {\n    return true\n  }\n  for i in 0..<len {\n    guard str.unsafe_charcode_at(self.start() + i) ==\n      other.unsafe_charcode_at(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\nfn BytesView::equal_to_bytes(self : Self, other : Bytes) -> Bool {\n  let self_len = self.len()\n  let start = self.start()\n  guard self_len == other.length() else { return false }\n  for i in 0..<self_len {\n    guard self.bytes().unsafe_get(i + start) == other.unsafe_get(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Retrieves the value associated with a `BytesView` key in a map with `Bytes` keys.\n///\n/// This function allows efficient lookups using `BytesView` without creating a new `Bytes` object.\n/// It's particularly useful when working with byte slices or subranges of existing byte arrays.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `Bytes` keys to search in.\n/// * `key` : A `BytesView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { b\"hello\": 1, b\"world\": 2 }\n///   let bytes = b\"prefix_hello_suffix\"\n///   let view = bytes[7:12] // view of \"hello\"\n///   inspect(map.get_from_bytes(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_bytes(map : Self[Bytes, V], key : BytesView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_bytes(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n\n///|\n/// Retrieves the value associated with a `StringView` key in a map with `String` keys.\n///\n/// This function allows efficient lookups using `StringView` without creating a new `String` object.\n/// It's particularly useful when working with substrings or string slices.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `String` keys to search in.\n/// * `key` : A `StringView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let map = { \"hello\": 1, \"world\": 2 }\n///   let str = \"say hello to everyone\"\n///   let view = str.view(start_offset=4, end_offset=9) // view of \"hello\"\n///   inspect(map.get_from_string(view), content=\"Some(1)\")\n/// }\n/// ```\npub fn[V] Map::get_from_string(map : Self[String, V], key : StringView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_string(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0).next_power_of_two(), content=\"1\")\n///   inspect((1).next_power_of_two(), content=\"1\")\n///   inspect((2).next_power_of_two(), content=\"2\")\n///   inspect((3).next_power_of_two(), content=\"4\")\n///   inspect((8).next_power_of_two(), content=\"8\")\n///   inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n///   inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// }\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).min(2), content=\"1\")\n///   inspect((2).min(1), content=\"1\")\n/// }\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).max(2), content=\"2\")\n///   inspect((2).max(1), content=\"2\")\n/// }\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((1).clamp(min=0, max=2), content=\"1\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n///   inspect((3).clamp(min=0, max=2), content=\"2\")\n///   inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// }\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n///   inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n///   inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n///   inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n///   inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// }\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```mbt check\n/// test {\n///   inspect((0xD800).is_surrogate(), content=\"true\") // leading surrogate\n///   inspect((0xDC00).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0xDFFF).is_surrogate(), content=\"true\") // trailing surrogate\n///   inspect((0x41).is_surrogate(), content=\"false\") // 'A'\n///   inspect((0x1F600).is_surrogate(), content=\"false\") // ğŸ˜€ emoji codepoint\n/// }\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n\n///|\n/// Computes the absolute value of an integer.\n///\n/// Parameters:\n///\n/// * `self` : The integer whose absolute value is to be computed.\n///\n/// Returns the absolute value of the integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Int::abs(42), content=\"42\")\n///   inspect(Int::abs(-42), content=\"42\")\n///   inspect(Int::abs(0), content=\"0\")\n/// }\n/// ```\npub fn Int::abs(self : Int) -> Int {\n  if self < 0 {\n    -self\n  } else {\n    self\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n#alias(or, deprecated)\npub fn[T] Option::unwrap_or(self : T?, default : T) -> T {\n  match self {\n    None => default\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n///\n/// Default is lazily evaluated\n#alias(or_else, deprecated)\npub fn[T] Option::unwrap_or_else(\n  self : T?,\n  default : () -> T raise?,\n) -> T raise? {\n  match self {\n    None => default()\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the result of the `T::default()`.\n#alias(or_default, deprecated)\npub fn[T : Default] Option::unwrap_or_default(self : T?) -> T {\n  match self {\n    None => T::default()\n    Some(t) => t\n  }\n}\n\n///|\npub impl[X : Compare] Compare for X? with compare(self, other) {\n  match (self, other) {\n    (Some(x), Some(y)) => x.compare(y)\n    (Some(_), None) => 1\n    (None, Some(_)) => -1\n    (None, None) => 0\n  }\n}\n\n///|\n#alias(or_error, deprecated)\npub fn[T, Err : Error] Option::unwrap_or_error(\n  self : T?,\n  err : Err,\n) -> T raise Err {\n  match self {\n    Some(v) => v\n    None => raise err\n  }\n}\n\n///|\n/// `None`\npub impl[X] Default for X? with default() {\n  None\n}\n\n///|\n#alias(iterator, deprecated)\npub fn[T] Option::iter(self : T?) -> Iter[T] {\n  match self {\n    Some(v) => Iter::singleton(v)\n    None => Iter::empty()\n  }\n}\n\n///|\n/// Maps the value of an `Option` using a provided function.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map(x => x * 2), Some(10))\n///   let b = None\n///   assert_eq(b.map(x => x * 2), None)\n/// }\n/// ```\npub fn[T, U] Option::map(self : T?, f : (T) -> U raise?) -> U? raise? {\n  match self {\n    Some(t) => Some(f(t))\n    None => None\n  }\n}\n\n///|\n/// Returns the provided default result (if none), or applies a function to the contained value (if any).\n/// Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use `map_or_else`, which is lazily evaluated.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or(3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or(\n  self : T?,\n  default : U,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Computes a default function result (if none), or applies a different function to the contained value (if any).\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Some(5)\n///   assert_eq(a.map_or_else(() => 3, x => x * 2), 10)\n/// }\n/// ```\npub fn[T, U] Option::map_or_else(\n  self : T?,\n  default : () -> U raise?,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default()\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Binds an option to a function that returns another option.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let a = Option::Some(5)\n///   let r1 = a.bind(x => Some(x * 2))\n///   assert_eq(r1, Some(10))\n///   let b : Int? = None\n///   let r2 = b.bind(x => Some(x * 2))\n///   assert_eq(r2, None)\n/// }\n/// ```\npub fn[T, U] Option::bind(self : T?, f : (T) -> U? raise?) -> U? raise? {\n  match self {\n    Some(t) => f(t)\n    None => None\n  }\n}\n\n///|\n#deprecated(\"use `option.bind(x => x)` instead\")\npub fn[T] Option::flatten(self : T??) -> T? {\n  match self {\n    Some(inner) => inner\n    None => None\n  }\n}\n\n///|\n/// Checks if the option is empty.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_empty(self : T?) -> Bool {\n  self is None\n}\n\n///|\n/// Filters the option by applying the given predicate function `f`.\n///\n/// If the predicate function `f` returns `true` for the value contained in the option,\n/// the same option is returned. Otherwise, `None` is returned.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let x = Some(3)\n///   assert_eq(x.filter(x => x > 5), None)\n///   assert_eq(x.filter(x => x < 5), Some(3))\n/// }\n/// ```\npub fn[T] Option::filter(self : T?, f : (T) -> Bool raise?) -> T? raise? {\n  match self {\n    Some(t) => if f(t) { self } else { None }\n    None => None\n  }\n}\n\n///|\n/// Checks if the option contains a value.\n#deprecated(\"use `x is Some(_)` instead\")\npub fn[T] Option::is_some(self : T?) -> Bool {\n  self is Some(_)\n}\n\n///|\n/// Checks if the option is None.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_none(self : T?) -> Bool {\n  self is None\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub fn Byte::to_hex(b : Byte) -> String {\n  fn to_hex_digit(i : Byte) -> Char {\n    if i < 10 {\n      (i + '0').to_char()\n    } else {\n      (i + 'a' - 10).to_char()\n    }\n  }\n\n  [to_hex_digit(b / 16), to_hex_digit(b % 16)]\n}\n\n///|\ntest \"to_hex_digit\" {\n  inspect(Byte::to_hex(b'\\xee'), content=\"ee\")\n  inspect(Byte::to_hex(b'\\xf3'), content=\"f3\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_charcode_at(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger..write_char('\\\\')..write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          // has to be ascii  \n          flush_segment(seg, i)\n          logger\n          ..write_string(\"\\\\u{\")\n          ..write_string(code.to_byte().to_hex())\n          ..write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// }\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) =>\n      logger..write_string(\"Some(\")..write_object(arg)..write_string(\")\")\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => logger..write_string(\"Ok(\")..write_object(x)..write_string(\")\")\n    Err(e) => logger..write_string(\"Err(\")..write_object(e)..write_string(\")\")\n  }\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the offset (charcode index) of the first occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn StringView::find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_find(self, str)\n  } else {\n    boyer_moore_horspool_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack left to right, matching the needle at each position\nfn brute_force_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let forward_len = haystack_len - needle_len\n  let mut i = 0\n  while i <= forward_len {\n    // Skip positions where first charcode doesn't match\n    while i <= forward_len && haystack.unsafe_charcode_at(i) != needle_first {\n      i += 1\n    }\n    if i <= forward_len {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i += 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for string search (left to right)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  // Build skip table\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i in 0..<(needle_len - 1) {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = needle_len - 1 - i\n  }\n  for i = 0\n      i <= haystack_len - needle_len\n      i = i + skip_table[haystack.unsafe_charcode_at(i + needle_len - 1) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..=(needle_len - 1) {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\ntest \"boyer_moore_horspool_find edge cases\" {\n  inspect(boyer_moore_horspool_find(\"abc\"[:], \"\"[:]), content=\"Some(0)\")\n  inspect(boyer_moore_horspool_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\ntest \"boyer_moore_horspool_rev_find edge cases\" {\n  inspect(boyer_moore_horspool_rev_find(\"abc\"[:], \"\"[:]), content=\"Some(3)\")\n  inspect(boyer_moore_horspool_rev_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\n/// Returns the offset of the first occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn String::find(self : String, str : StringView) -> Int? {\n  self[:].find(str)\n}\n\n///|\ntest \"find\" {\n  inspect(\"hello\".find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".find(\"l\"), content=\"Some(2)\")\n  inspect(\"hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"world\"), content=\"None\")\n  inspect(\"\".find(\"\"), content=\"Some(0)\")\n  inspect(\"\".find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"aaa\".find(\"aa\"), content=\"Some(0)\")\n  inspect(\"ğŸ˜€ğŸ˜€\".find(\"ğŸ˜€\"), content=\"Some(0)\")\n  inspect(\n    (\"ğŸ˜€ğŸ˜€aa\".repeat(20) + \"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\").find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\" + \"ğŸ˜€ğŸ˜€aa\".repeat(20)).find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(0)\",\n  )\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn StringView::find_by(self : StringView, pred : (Char) -> Bool) -> Int? {\n  for i, c in self {\n    if pred(c) {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn String::find_by(self : String, pred : (Char) -> Bool) -> Int? {\n  self[:].find_by(pred)\n}\n\n///|\ntest \"find_by\" {\n  inspect(\"hello\".find_by(c => c == 'o'), content=\"Some(4)\")\n  inspect(\"hello\".find_by(c => c == 'l'), content=\"Some(2)\")\n  inspect(\"hello\".find_by(c => c == 'z'), content=\"None\")\n  inspect(\"\".find_by(c => c == 'a'), content=\"None\")\n  inspect(\"hello\".find_by(c => c is ('0'..='9')), content=\"None\")\n  inspect(\"hello123\".find_by(c => c is ('0'..='9')), content=\"Some(5)\")\n  inspect(\"hello\".find_by(c => c is ('A'..='Z')), content=\"None\")\n  inspect(\"Hello\".find_by(c => c is ('A'..='Z')), content=\"Some(0)\")\n  inspect(\"Î±Î²Î³\".find_by(c => c == 'Î²'), content=\"Some(1)\")\n  inspect(\"ğŸ˜€ğŸ˜ğŸ˜‚\".find_by(c => c == 'ğŸ˜‚'), content=\"Some(2)\")\n}\n\n///|\n/// Returns the offset of the last occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn StringView::rev_find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_rev_find(self, str)\n  } else {\n    boyer_moore_horspool_rev_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack right to left, matching the needle at each position\nfn brute_force_rev_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let mut i = haystack_len - needle_len\n  while i >= 0 {\n    // Skip positions where first charcode doesn't match\n    while i >= 0 && haystack.unsafe_charcode_at(i) != needle_first {\n      i -= 1\n    }\n    if i >= 0 {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i -= 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for reverse string search (right to left)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_rev_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i = needle_len - 1; i > 0; i = i - 1 {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = i\n  }\n  for i = haystack_len - needle_len\n      i >= 0\n      i = i - skip_table[haystack.unsafe_charcode_at(i) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..<needle_len {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset (charcode index) of the last occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn String::rev_find(self : String, str : StringView) -> Int? {\n  self[:].rev_find(str)\n}\n\n///|\ntest \"rev_find\" {\n  inspect(\"hello\".rev_find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".rev_find(\"l\"), content=\"Some(3)\")\n  inspect(\"hello\".rev_find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"\"), content=\"Some(5)\")\n  inspect(\"hello\".rev_find(\"world\"), content=\"None\")\n  inspect(\"\".rev_find(\"\"), content=\"Some(0)\")\n  inspect(\"\".rev_find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".rev_find(\"hello\"), content=\"Some(6)\")\n  inspect(\"aaa\".rev_find(\"aa\"), content=\"Some(1)\")\n  inspect(\"ğŸ˜€ğŸ˜€\".rev_find(\"ğŸ˜€\"), content=\"Some(2)\")\n  inspect(\n    (\"ğŸ˜€ğŸ˜€aa\".repeat(20) + \"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\").rev_find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\" + \"ğŸ˜€ğŸ˜€aa\".repeat(20)).rev_find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(4)\",\n  )\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn StringView::has_suffix(self : StringView, str : StringView) -> Bool {\n  self.rev_find(str) is Some(i) && i == self.length() - str.length()\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn String::has_suffix(self : String, str : StringView) -> Bool {\n  self[:].has_suffix(str)\n}\n\n///|\ntest \"has_suffix\" {\n  inspect(\"hello\".has_suffix(\"lo\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"hello\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_suffix(\"hel\"), content=\"false\")\n  inspect(\"\".has_suffix(\"\"), content=\"true\")\n  inspect(\"\".has_suffix(\"a\"), content=\"false\")\n  inspect(\"hello world\".has_suffix(\"world\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".has_suffix(\"ğŸ˜€\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".has_suffix(\"ğŸ˜€ğŸ˜€\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn StringView::has_prefix(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(i) && i == 0\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn String::has_prefix(self : String, str : StringView) -> Bool {\n  self[:].has_prefix(str)\n}\n\n///|\ntest \"has_prefix\" {\n  inspect(\"hello\".has_prefix(\"h\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"he\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_prefix(\"lo\"), content=\"false\")\n  inspect(\"\".has_prefix(\"\"), content=\"true\")\n  inspect(\"\".has_prefix(\"a\"), content=\"false\")\n  inspect(\"ğŸ˜€hello\".has_prefix(\"ğŸ˜€\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhello\".has_prefix(\"ğŸ˜€ğŸ˜ƒ\"), content=\"true\")\n  inspect(\"ğŸ˜€hello\".has_prefix(\"ğŸ˜ƒ\"), content=\"false\")\n  inspect(\"helloğŸ˜€\".has_prefix(\"ğŸ˜€\"), content=\"false\")\n}\n\n///|\n/// Removes the given suffix from the string if it exists.\n///\n/// Returns `Some(prefix)` if the string ends with the given suffix,\n/// where `prefix` is the string without the suffix.\n/// Returns `None` if the string does not end with the suffix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n///   inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_suffix)\npub fn String::strip_suffix(self : String, suffix : StringView) -> StringView? {\n  self[:].strip_suffix(suffix)\n}\n\n///|\ntest \"strip_prefix\" {\n  inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n  inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_prefix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"ğŸ˜€hello\".strip_prefix(\"ğŸ˜€\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhello\".strip_prefix(\"ğŸ˜€ğŸ˜ƒ\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\ntest \"strip_suffix\" {\n  inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n  inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_suffix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"helloğŸ˜€\".strip_suffix(\"ğŸ˜€\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"helloğŸ˜€ğŸ˜ƒ\".strip_suffix(\"ğŸ˜€ğŸ˜ƒ\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\n/// Removes the given prefix from the string if it exists.\n///\n/// Returns `Some(suffix)` if the string starts with the given prefix,\n/// where `suffix` is the string without the prefix.\n/// Returns `None` if the string does not start with the prefix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n///   inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_prefix)\npub fn String::strip_prefix(self : String, prefix : StringView) -> StringView? {\n  self[:].strip_prefix(prefix)\n}\n\n///|\n/// Removes the given prefix from the view if it exists.\n///\n/// Returns `Some(suffix)` if the view starts with the given prefix,\n/// where `suffix` is the view without the prefix.\n/// Returns `None` if the view does not start with the prefix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n///   inspect(view.strip_prefix(\"hi \"), content=\"None\")\n///   inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_prefix)\npub fn StringView::strip_prefix(\n  self : StringView,\n  prefix : StringView,\n) -> StringView? {\n  let prefix_len = prefix.length()\n  if self.length() >= prefix_len && self.view(end_offset=prefix_len) == prefix {\n    Some(self.view(start_offset=prefix_len))\n  } else {\n    None\n  }\n}\n\n///|\n/// Removes the given suffix from the view if it exists.\n///\n/// Returns `Some(prefix)` if the view ends with the given suffix,\n/// where `prefix` is the view without the suffix.\n/// Returns `None` if the view does not end with the suffix.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"hello world\"[:]\n///   inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n///   inspect(view.strip_suffix(\" moon\"), content=\"None\")\n///   inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// }\n/// ```\n#alias(chop_suffix)\npub fn StringView::strip_suffix(\n  self : StringView,\n  suffix : StringView,\n) -> StringView? {\n  let self_len = self.length()\n  let suffix_len = suffix.length()\n  if self_len >= suffix_len &&\n    self.view(start_offset=self_len - suffix_len) == suffix {\n    Some(self.view(end_offset=self_len - suffix_len))\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts the View into an array of Chars.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let view = \"HelloğŸ¤£xa\"[1:-1]\n///   let chars = view.to_array()\n///   inspect(chars, content=\"['e', 'l', 'l', 'o', 'ğŸ¤£', 'x']\")\n/// }\n/// ```\npub fn StringView::to_array(self : StringView) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n#deprecated(\"Check `@encoding/utf8.encode`\")\n#coverage.skip\npub fn StringView::to_bytes(self : StringView) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self.data(), self.start_offset(), self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\ntest \"View::strip_prefix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(view.strip_prefix(\"hi \"), content=\"None\")\n  inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_prefix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_prefix(\"a\"), content=\"None\")\n  let unicode_view = \"ğŸ˜€helloğŸ˜ƒ\"[:]\n  inspect(unicode_view.strip_prefix(\"ğŸ˜€\"), content=\"Some(\\\"helloğŸ˜ƒ\\\")\")\n  inspect(unicode_view.strip_prefix(\"ğŸ˜ƒ\"), content=\"None\")\n}\n\n///|\ntest \"View::strip_suffix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(view.strip_suffix(\" moon\"), content=\"None\")\n  inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_suffix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_suffix(\"a\"), content=\"None\")\n  let unicode_view = \"ğŸ˜€helloğŸ˜ƒ\"[:]\n  inspect(unicode_view.strip_suffix(\"ğŸ˜ƒ\"), content=\"Some(\\\"ğŸ˜€hello\\\")\")\n  inspect(unicode_view.strip_suffix(\"ğŸ˜€\"), content=\"None\")\n}\n\n///|\ntest \"View::to_array\" {\n  let view = \"HelloğŸ¤£\"[:]\n  let chars = view.to_array()\n  assert_eq(chars, ['H', 'e', 'l', 'l', 'o', 'ğŸ¤£'])\n  let empty_view = \"\"[:]\n  let empty_chars = empty_view.to_array()\n  assert_eq(empty_chars, [])\n  let sub_view = \"Hello World\"[6:11] // \"World\"\n  let sub_chars = sub_view.to_array()\n  assert_eq(sub_chars, ['W', 'o', 'r', 'l', 'd'])\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn StringView::contains(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(_)\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn String::contains(self : String, str : StringView) -> Bool {\n  self[:].contains(str)\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn StringView::contains_any(self : StringView, chars~ : StringView) -> Bool {\n  match chars {\n    [] => false\n    [c] => self.contains_char(c) // specialize for single character\n    _ =>\n      for c in self {\n        if chars.contains_char(c) {\n          break true\n        }\n      } else {\n        false\n      }\n  }\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn String::contains_any(self : String, chars~ : StringView) -> Bool {\n  self[:].contains_any(chars~)\n}\n\n///|\ntest \"contains\" {\n  inspect(\"hello\".contains(\"o\"), content=\"true\")\n  inspect(\"hello\".contains(\"l\"), content=\"true\")\n  inspect(\"hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"hello\".contains(\"h\"), content=\"true\")\n  inspect(\"hello\".contains(\"\"), content=\"true\")\n  inspect(\"hello\".contains(\"world\"), content=\"false\")\n  inspect(\"\".contains(\"\"), content=\"true\")\n  inspect(\"\".contains(\"a\"), content=\"false\")\n  inspect(\"hello hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"aaa\".contains(\"aa\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".contains(\"ğŸ˜€\"), content=\"true\")\n}\n\n///|\ntest \"contains_any\" {\n  inspect(\"hello\".contains_any(chars=\"h\"), content=\"true\")\n  inspect(\"hello\".contains_any(chars=\"xyz\"), content=\"false\")\n  inspect(\"hello\".contains_any(chars=\"\"), content=\"false\")\n  inspect(\"\".contains_any(chars=\"abc\"), content=\"false\")\n  inspect(\"ğŸ˜€ğŸ˜ƒ\".contains_any(chars=\"ğŸ˜„ğŸ˜€\"), content=\"true\")\n  inspect(\"hello\"[:].contains_any(chars=\"eo\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn StringView::contains_char(self : StringView, c : Char) -> Bool {\n  let len = self.length()\n  // Check empty\n  guard len > 0 else { return false }\n  let c = c.to_int()\n  if c <= 0xFFFF {\n    // Search BMP\n    for i in 0..<len {\n      if self.unsafe_charcode_at(i) == c {\n        return true\n      }\n    }\n  } else {\n    // Check insufficient\n    guard len >= 2 else { return false }\n    // Calc surrogate pair\n    let adj = c - 0x10000\n    let high = 0xD800 + (adj >> 10)\n    let low = 0xDC00 + (adj & 0x3FF)\n    // Search surrogate pair\n    let mut i = 0\n    while i < len - 1 {\n      if self.unsafe_charcode_at(i) == high {\n        i += 1\n        if self.unsafe_charcode_at(i) == low {\n          return true\n        }\n      }\n      i += 1\n    }\n  }\n  false\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn String::contains_char(self : String, c : Char) -> Bool {\n  self[:].contains_char(c)\n}\n\n///|\ntest \"contains_char\" {\n  inspect(\"hello\".contains_char('h'), content=\"true\")\n  inspect(\"hello\".contains_char('e'), content=\"true\")\n  inspect(\"hello\".contains_char('l'), content=\"true\")\n  inspect(\"hello\".contains_char('o'), content=\"true\")\n  inspect(\"hello\".contains_char('x'), content=\"false\")\n  inspect(\"\".contains_char('a'), content=\"false\")\n  inspect(\"hello world\".contains_char(' '), content=\"true\")\n  inspect(\"hello world\".contains_char('w'), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".contains_char('ğŸ˜€'), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".contains_char('ğŸ˜ƒ'), content=\"false\")\n  inspect(\"hello\".contains_char((104).unsafe_to_char()), content=\"true\") // 'h' is 104 in ASCII\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_start(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  loop self {\n    [] as v => v\n    [c, .. rest] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim_start(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_start(chars~)\n}\n\n///|\ntest \"trim_start\" {\n  inspect(\"hello\".trim_start(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim_start(chars=\"he\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"eh\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_start(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_start(chars=\"a\"), content=\"\")\n  inspect(\"   hello\".trim_start(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_start(chars=\"helo\"), content=\" world\")\n  inspect(\"ğŸ˜€ğŸ˜€hello\".trim_start(chars=\"ğŸ˜€\"), content=\"hello\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhello\".trim_start(chars=\"ğŸ˜€ğŸ˜ƒ\"), content=\"hello\")\n  inspect(\"aaaabc\".trim_start(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim_start(chars=\"a\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_end(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  loop self {\n    [] as v => v\n    [.. rest, c] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n// TODO(upstream): label_migration warning does not apply to the current package\n// TODO: make chars optional with default value of whitespace characters\n#label_migration(chars, alias=char_set)\npub fn String::trim_end(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_end(chars~)\n}\n\n///|\ntest \"trim_end\" {\n  inspect(\"hello\".trim_end(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim_end(chars=\"lo\"), content=\"he\")\n  inspect(\"hello\".trim_end(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_end(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_end(chars=\"a\"), content=\"\")\n  inspect(\"hello   \".trim_end(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_end(chars=\"dlrow \"), content=\"he\")\n  inspect(\"helloğŸ˜€ğŸ˜€\".trim_end(chars=\"ğŸ˜€\"), content=\"hello\")\n  inspect(\"helloğŸ˜€ğŸ˜ƒ\".trim_end(chars=\"ğŸ˜€ğŸ˜ƒ\"), content=\"hello\")\n  inspect(\"abcccc\".trim_end(chars=\"c\"), content=\"ab\")\n  inspect(\"cccc\".trim_end(chars=\"c\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self.trim_start(chars~).trim_end(chars~)\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim(chars~)\n}\n\n///|\ntest \"trim\" {\n  inspect(\"hello\".trim(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim(chars=\"ho\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"oh\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim(chars=\"a\"), content=\"\")\n  inspect(\"   hello   \".trim(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim(chars=\"hd\"), content=\"ello worl\")\n  inspect(\"ğŸ˜€helloğŸ˜€\".trim(chars=\"ğŸ˜€\"), content=\"hello\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhelloğŸ˜€ğŸ˜ƒ\".trim(chars=\"ğŸ˜€ğŸ˜ƒ\"), content=\"hello\")\n  inspect(\"aaaabcaaa\".trim(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim(chars=\"a\"), content=\"\")\n  inspect(\"  hello world  \".trim(chars=\" \"), content=\"hello world\")\n  inspect(\"abcabc\".trim(chars=\"abc\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn StringView::trim_space(self : StringView) -> StringView {\n  self.trim()\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn String::trim_space(self : String) -> StringView {\n  self.trim()\n}\n\n///|\ntest \"trim whitespace for string\" {\n  inspect(\"hello\".trim(), content=\"hello\")\n  inspect(\"  hello  \".trim(), content=\"hello\")\n  inspect(\"hello  \".trim(), content=\"hello\")\n  inspect(\"  hello\".trim(), content=\"hello\")\n  inspect(\"\\t\\nhello\\r\\n\".trim(), content=\"hello\")\n  inspect(\"  hello world  \".trim(), content=\"hello world\")\n  inspect(\"  \".trim(), content=\"\")\n  inspect(\"\\n\\r\\t\".trim(), content=\"\")\n  inspect(\"\".trim(), content=\"\")\n  inspect(\"  hello\\nworld\\t\".trim(), content=\"hello\\nworld\")\n}\n\n///|\n/// Returns true if this string is empty.\npub fn StringView::is_empty(self : StringView) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Returns true if this string is empty.\npub fn String::is_empty(self : String) -> Bool {\n  self == \"\"\n}\n\n///|\ntest \"is_empty\" {\n  inspect(\"\".is_empty(), content=\"true\")\n  inspect(\"hello\".is_empty(), content=\"false\")\n  inspect(\" \".is_empty(), content=\"false\")\n  inspect(\"\\n\".is_empty(), content=\"false\")\n  inspect(\"\\t\".is_empty(), content=\"false\")\n  inspect(\"   \".is_empty(), content=\"false\")\n\n  // Test with string views\n  let s = \"hello\"\n  let empty_view = s[0:0]\n  let non_empty_view = s[0:3]\n  inspect(empty_view.is_empty(), content=\"true\")\n  inspect(non_empty_view.is_empty(), content=\"false\")\n}\n\n///|\n/// Returns true if this string is blank.\npub fn StringView::is_blank(self : StringView) -> Bool {\n  self.trim().is_empty()\n}\n\n///|\n/// Returns true if this string is blank.\npub fn String::is_blank(self : String) -> Bool {\n  self[:].is_blank()\n}\n\n///|\ntest \"is_blank\" {\n  inspect(\"\".is_blank(), content=\"true\")\n  inspect(\"hello\".is_blank(), content=\"false\")\n  inspect(\" \".is_blank(), content=\"true\")\n  inspect(\"\\n\".is_blank(), content=\"true\")\n  inspect(\"\\t\".is_blank(), content=\"true\")\n  inspect(\"   \".is_blank(), content=\"true\")\n  inspect(\" \\n\\t\\r \".is_blank(), content=\"true\")\n  inspect(\"hello world\".is_blank(), content=\"false\")\n  inspect(\"  hello  \".is_blank(), content=\"false\")\n\n  // Test with string views\n  let s = \"   hello  \"\n  let blank_view = s[0:3] // \"   \"\n  let non_blank_view = s[3:8] // \"hello\"\n  inspect(blank_view.is_blank(), content=\"true\")\n  inspect(non_blank_view.is_blank(), content=\"false\")\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_start(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_start(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\ntest \"pad_start\" {\n  // Test with regular strings\n  inspect(\"2\".pad_start(3, '0'), content=\"002\")\n  inspect(\"abc\".pad_start(5, 'x'), content=\"xxabc\")\n  inspect(\"hello\".pad_start(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_start(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_start(8, '*'), content=\"****test\")\n  inspect(\"123\".pad_start(6, '0'), content=\"000123\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_start(5, 'x'), content=\"xxllo\")\n\n  // Test with Unicode characters\n  inspect(\"ğŸŒŸ\".pad_start(3, 'âœ¨'), content=\"âœ¨ğŸŒŸ\")\n\n  // Edge cases\n  inspect(\"abc\".pad_start(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_start(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_end(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_end(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\ntest \"pad_end\" {\n  // Test with regular strings\n  inspect(\"2\".pad_end(3, '0'), content=\"200\")\n  inspect(\"abc\".pad_end(5, 'x'), content=\"abcxx\")\n  inspect(\"hello\".pad_end(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_end(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_end(8, '*'), content=\"test****\")\n  inspect(\"123\".pad_end(6, '0'), content=\"123000\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_end(5, 'x'), content=\"lloxx\")\n\n  // Test with Unicode characters\n  inspect(\"ğŸŒŸ\".pad_end(3, 'âœ¨'), content=\"ğŸŒŸâœ¨\")\n\n  // Edge cases\n  inspect(\"abc\".pad_end(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_end(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn StringView::repeat(self : StringView, n : Int) -> StringView {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn String::repeat(self : String, n : Int) -> String {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\ntest \"repeat\" {\n  // Test with regular strings\n  inspect(\"abc\".repeat(3), content=\"abcabcabc\")\n  inspect(\"x\".repeat(5), content=\"xxxxx\")\n  inspect(\"hello \".repeat(2), content=\"hello hello \")\n\n  // Test with empty string\n  inspect(\"\".repeat(10), content=\"\")\n\n  // Test with string views\n  let s = \"hello world\"\n  let view = s[6:11] // \"world\"\n  inspect(view.repeat(2), content=\"worldworld\")\n\n  // Test with Unicode characters\n  inspect(\"ğŸŒŸ\".repeat(3), content=\"ğŸŒŸğŸŒŸğŸŒŸ\")\n  inspect(\"âœ¨ğŸŒŸ\".repeat(2), content=\"âœ¨ğŸŒŸâœ¨ğŸŒŸ\")\n\n  // Edge cases\n  inspect(\"abc\".repeat(0), content=\"\")\n  inspect(\"abc\".repeat(-5), content=\"\")\n  inspect(\"abc\".repeat(1), content=\"abc\")\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn StringView::rev(self : StringView) -> String {\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self.rev_iter() {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn String::rev(self : String) -> String {\n  self[:].rev()\n}\n\n///|\ntest \"rev\" {\n  inspect(\"hello\".rev(), content=\"olleh\")\n  inspect(\"\".rev(), content=\"\")\n  inspect(\"abc\".rev(), content=\"cba\")\n  inspect(\"ğŸ˜€ğŸ˜ƒ\".rev(), content=\"ğŸ˜ƒğŸ˜€\")\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn StringView::split(\n  self : StringView,\n  sep : StringView,\n) -> Iter[StringView] {\n  let sep_len = sep.length()\n  if sep_len == 0 {\n    return self.iter().map(c => c.to_string().view())\n  }\n  let mut remaining = Some(self)\n  Iter::new(() => {\n    guard remaining is Some(view) else { None }\n    guard view.find(sep) is Some(end) else {\n      remaining = None\n      Some(view)\n    }\n    remaining = Some(view.view(start_offset=end + sep_len))\n    Some(view.view(end_offset=end))\n  })\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn String::split(self : String, sep : StringView) -> Iter[StringView] {\n  self[:].split(sep)\n}\n\n///|\ntest \"split\" {\n  assert_eq(\"a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\n    \"apple::orange::banana\".split(\"::\").map(StringView::to_string).collect(),\n    [\"apple\", \"orange\", \"banana\"],\n  )\n  assert_eq(\"abc\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"hello\".split(\",\").map(StringView::to_string).collect(), [\"hello\"])\n  assert_eq(\",a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"\", \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c,\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\", \"\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\"\".split(\"\").map(StringView::to_string).collect(), [])\n  assert_eq(\"\".split(\",\").map(StringView::to_string).collect(), [\"\"])\n  assert_eq(\"ğŸ˜€,ğŸ˜ƒ,ğŸ˜„\".split(\",\").map(StringView::to_string).collect(), [\n    \"ğŸ˜€\", \"ğŸ˜ƒ\", \"ğŸ˜„\",\n  ])\n  assert_eq(\"ağŸ˜€bğŸ˜€c\".split(\"ğŸ˜€\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn StringView::replace(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn String::replace(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\ntest \"replace\" {\n  inspect(\"hello\".replace(old=\"o\", new=\"a\"), content=\"hella\")\n  inspect(\"hello\".replace(old=\"l\", new=\"a\"), content=\"healo\")\n  inspect(\"hello\".replace(old=\"hello\", new=\"a\"), content=\"a\")\n  inspect(\"hello\".replace(old=\"h\", new=\"a\"), content=\"aello\")\n  inspect(\"hello\".replace(old=\"\", new=\"a\"), content=\"ahello\")\n  inspect(\"hello\".replace(old=\"world\", new=\"a\"), content=\"hello\")\n  inspect(\"\".replace(old=\"\", new=\"a\"), content=\"a\")\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn StringView::replace_all(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self, end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn String::replace_all(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self[:], end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\ntest \"replace_all\" {\n  assert_eq(\"hello\".replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\".replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\".replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\".replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\"hello hello hello\".replace_all(old=\"hello\", new=\"hi\"), \"hi hi hi\")\n  assert_eq(\n    \"hello hello helloi\".replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\".replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\".replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\".replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\".replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\".replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\"ğŸ¤£ğŸ¤£ğŸ¤£\".replace_all(old=\"ğŸ¤£\", new=\"ğŸ˜Š\"), \"ğŸ˜ŠğŸ˜ŠğŸ˜Š\")\n  assert_eq(\"abc123abc\".replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"String::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1187: guard end + old_len <= len else { break }\n  // This happens when the pattern is found at the very end of the string\n\n  // Pattern at the end of string - should trigger the guard condition\n  assert_eq(\"helloworld\".replace_all(old=\"world\", new=\"X\"), \"helloX\")\n  assert_eq(\"abcdef\".replace_all(old=\"def\", new=\"XYZ\"), \"abcXYZ\")\n\n  // Multiple patterns where the last one is at the end\n  assert_eq(\"abcabc\".replace_all(old=\"abc\", new=\"X\"), \"XX\")\n\n  // Pattern that exactly matches the string length\n  assert_eq(\"test\".replace_all(old=\"test\", new=\"done\"), \"done\")\n\n  // Empty replacement at the end\n  assert_eq(\"remove_me\".replace_all(old=\"_me\", new=\"\"), \"remove\")\n}\n\n///|\ntest \"View::replace_all\" {\n  assert_eq(\"hello\"[:].replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\"[:].replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\"[:].replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\"[:].replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\n    \"hello hello hello\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hi\",\n  )\n  assert_eq(\n    \"hello hello helloi\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\"[:].replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\"[:].replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\"[:].replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\"[:].replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\n    \"ğŸ¤£ğŸ¤£ğŸ¤£\"[:].replace_all(old=\"ğŸ¤£\", new=\"ğŸ˜Š\"),\n    \"ğŸ˜ŠğŸ˜ŠğŸ˜Š\",\n  )\n  assert_eq(\"abc123abc\"[:].replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"View::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1141: guard end + old_len <= len else { break }\n  // This condition triggers when end + old_len > len, meaning we're at the boundary\n\n  // Let me trace through the algorithm more carefully...\n  // Actually, let me try a different approach - create a scenario where the view length changes\n\n  // Try with overlapping patterns or edge cases\n  assert_eq(\"abcabc\"[:].replace_all(old=\"abc\", new=\"X\"), \"XX\")\n  assert_eq(\"aaaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"bb\")\n\n  // Pattern at exact end\n  assert_eq(\"hello\"[:].replace_all(old=\"lo\", new=\"X\"), \"helX\")\n\n  // Test with empty string edge case\n  assert_eq(\"a\"[:].replace_all(old=\"a\", new=\"\"), \"\")\n\n  // Let me try to understand when end + old_len > len could happen...\n  // Maybe when we have a complex replacement scenario\n  inspect(\"Testing boundary condition\", content=\"Testing boundary condition\")\n}\n\n///|\n/// Converts this string to lowercase.\npub fn StringView::to_lower(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to lowercase.\npub fn String::to_lower(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_lower\" {\n  assert_eq(\"Hello\".to_lower(), \"hello\")\n  assert_eq(\"HELLO\".to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\".to_lower(), \"hello, world!\")\n}\n\n///|\ntest \"View::to_lower\" {\n  assert_eq(\"Hello\"[:].to_lower(), \"hello\")\n  assert_eq(\"HELLO\"[:].to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\"[:].to_lower(), \"hello, world!\")\n}\n\n///|\n/// Converts this string to uppercase.\npub fn StringView::to_upper(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to uppercase.\npub fn String::to_upper(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_upper\" {\n  assert_eq(\"hello\".to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\".to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\".to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\ntest \"View::to_upper\" {\n  assert_eq(\"hello\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\"[:].to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] StringView::fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] String::fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].fold(init~, f)\n}\n\n///|\ntest \"fold\" {\n  assert_eq(\n    \"hello\".fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['h', 'e', 'l', 'l', 'o'],\n  )\n  assert_eq(\n    \"hello\".fold(init=0, (acc, c) => acc + c.to_int()),\n    104 + 101 + 108 + 108 + 111,\n  )\n}\n\n///|\ntest \"fold with raise\" {\n  let result = try? \"hello\".fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\npub fn[A] StringView::rev_fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self.rev_iter() {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\npub fn[A] String::rev_fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].rev_fold(init~, f)\n}\n\n///|\ntest \"rev_fold\" {\n  assert_eq(\n    \"hello\".rev_fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['o', 'l', 'l', 'e', 'h'],\n  )\n  assert_eq(\n    \"hello\".rev_fold(init=0, (acc, c) => acc + c.to_int()),\n    111 + 108 + 108 + 101 + 104,\n  )\n}\n\n///|\ntest \"rev_fold with raise\" {\n  let result = try? \"hello\".rev_fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `String::code_unit_at` instead.\", skip_current_package=true)\npub fn String::get(self : String, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `StringView::code_unit_at` instead.\", skip_current_package=true)\npub fn StringView::get(self : StringView, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\ntest \"String::get supports emoji (surrogate pair)\" {\n  let s = \"hello\"\n  inspect(s.get(0), content=\"Some(104)\")\n  inspect(s.get(4), content=\"Some(111)\")\n  inspect(s.get(5), content=\"None\")\n  inspect(s.get(-1), content=\"None\")\n  let s = \"ağŸ¤£b\"\n  inspect(s.get(0), content=\"Some(97)\")\n  inspect(s.get(1), content=\"Some(55358)\")\n  inspect(s.get(2), content=\"Some(56611)\")\n  inspect(s.get(3), content=\"Some(98)\")\n  inspect(s.get(4), content=\"None\")\n}\n\n///|\ntest \"View::get basic cases\" {\n  let v = \"hello\"[1:-1]\n  inspect(v.get(0), content=\"Some(101)\")\n  inspect(v.get(2), content=\"Some(108)\")\n  inspect(v.get(3), content=\"None\")\n  inspect(v.get(-1), content=\"None\")\n  let v = \"abğŸ¤£cd\"[1:-1]\n  inspect(v.get(0), content=\"Some(98)\")\n  inspect(v.get(1), content=\"Some(55358)\")\n  inspect(v.get(2), content=\"Some(56611)\")\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn String::get_char(self : String, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn StringView::get_char(self : StringView, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\ntest \"String::get_char basic cases\" {\n  // Basic ASCII characters\n  let s = \"hello\"\n  inspect(s.get_char(0), content=\"Some('h')\")\n  inspect(s.get_char(1), content=\"Some('e')\")\n  inspect(s.get_char(4), content=\"Some('o')\")\n  inspect(s.get_char(5), content=\"None\")\n  inspect(s.get_char(-1), content=\"None\")\n\n  // Contains emoji (surrogate pair)\n  let s = \"ağŸ¤£b\"\n  inspect(s.get_char(0), content=\"Some('a')\")\n  inspect(s.get_char(1), content=\"Some('ğŸ¤£')\")\n  inspect(s.get_char(2), content=\"None\") // Second half of surrogate pair is not a valid char\n  inspect(s.get_char(3), content=\"Some('b')\")\n  inspect(s.get_char(4), content=\"None\")\n}\n\n///|\ntest \"View::get_char basic cases\" {\n  let s = \"ağŸ¤£b\"\n  let v = s[0:-1]\n  inspect(v.get_char(0), content=\"Some('a')\")\n  inspect(v.get_char(1), content=\"Some('ğŸ¤£')\")\n  inspect(v.get_char(2), content=\"None\")\n  inspect(v.get_char(3), content=\"None\")\n  inspect(v.get_char(4), content=\"None\")\n\n  // Test substring view\n  let v2 = s[1:3] // Only contains the emoji surrogate pair\n  inspect(v2.get_char(0), content=\"Some('ğŸ¤£')\")\n  inspect(v2.get_char(1), content=\"None\")\n  inspect(v2.get_char(2), content=\"None\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T] UninitializedArray::set_null(self : UninitializedArray[T], index : Int) = \"%fixedarray.set_null\"\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\nstruct Array[T] {\n  mut buf : UninitializedArray[T]\n  mut len : Int\n}\n\n///|\nfn[T] Array::make_uninit(len : Int) -> Array[T] {\n  { buf: UninitializedArray::make(len), len }\n}\n\n///|\n/// Creates a new empty array with an optional initial capacity.\n///\n/// Parameters:\n///\n/// * `capacity` : The initial capacity of the array. If 0 (default), creates an\n/// array with minimum capacity. Must be non-negative.\n///\n/// Returns a new empty array of type `Array[T]` with the specified initial\n/// capacity.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : Array[Int] = Array::new(capacity=10)\n///   inspect(arr.length(), content=\"0\")\n///   inspect(arr.capacity(), content=\"10\")\n///   let arr : Array[Int] = Array::new()\n///   inspect(arr.length(), content=\"0\")\n/// }\n/// ```\npub fn[T] Array::new(capacity? : Int = 0) -> Array[T] {\n  if capacity == 0 {\n    []\n  } else {\n    { buf: UninitializedArray::make(capacity), len: 0 }\n  }\n}\n\n///|\n/// Returns the number of elements in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array whose length is to be determined.\n///\n/// Returns the number of elements in the array as an integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.length(), content=\"3\")\n///   let empty : Array[Int] = []\n///   inspect(empty.length(), content=\"0\")\n/// }\n/// ```\n#intrinsic(\"%array.length\")\npub fn[T] Array::length(self : Array[T]) -> Int {\n  self.len\n}\n\n///|\n/// Truncates the array to the specified length. This function is marked as\n/// `unsafe` because it directly manipulates the internal buffer of the array,\n/// which can lead to undefined behavior if not used carefully.\n///\n/// # Parameters\n///\n/// - `self` : The array to be truncated.\n/// - `new_len` : The new length to which the array should be truncated. Must be\n/// less than or equal to the current length of the array.\n///\n/// # Returns\n///\n/// - `Unit` : This function does not return a value.\n///\n/// # Errors\n///\n/// - This function does not explicitly raise errors, but improper use (e.g.,\n/// setting `new_len` greater than the current length) can lead to undefined\n/// behavior.\n///\n/// TODO: this can be optimized by using the intrinsic to null out the range\nfn[T] Array::unsafe_truncate_to_length(self : Array[T], new_len : Int) -> Unit {\n  let len = self.length()\n  guard new_len <= len\n  for i in new_len..<len {\n    self.buf.set_null(i)\n  }\n  self.len = new_len\n}\n\n///|\ntest \"unsafe_truncate_to_length\" {\n  let arr = [1, 2, 3, 4, 5]\n  arr.unsafe_truncate_to_length(3)\n  inspect(arr, content=\"[1, 2, 3]\")\n}\n\n///|\nfn[T] Array::buffer(self : Array[T]) -> UninitializedArray[T] {\n  self.buf\n}\n\n///|\nfn[T] Array::resize_buffer(self : Array[T], new_capacity : Int) -> Unit {\n  let new_buf = UninitializedArray::make(new_capacity)\n  let old_buf = self.buf\n  let old_cap = old_buf.0.length()\n  let copy_len = if old_cap < new_capacity { old_cap } else { new_capacity }\n  UninitializedArray::unsafe_blit(new_buf, 0, old_buf, 0, copy_len)\n  self.buf = new_buf\n}\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"Array::resize_buffer\" {\n  let arr = Array::new(capacity=2)\n  arr.push(1)\n  arr.push(2)\n  arr.resize_buffer(4)\n  assert_eq(arr.buffer().0.length() >= 4, true)\n  arr.push(3)\n  arr.push(4)\n  assert_eq(arr.length(), 4)\n  assert_eq(arr[0], 1)\n  assert_eq(arr[1], 2)\n  assert_eq(arr[2], 3)\n  assert_eq(arr[3], 4)\n}\n\n///|\n/// Reallocate the array with a new capacity.\nfn[T] Array::realloc(self : Array[T]) -> Unit {\n  let old_cap = self.length()\n  let new_cap = if old_cap == 0 { 8 } else { old_cap * 2 }\n  self.resize_buffer(new_cap)\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = [1]\n///   v.reserve_capacity(10)\n///   assert_eq(v.capacity(), 10)\n/// }\n/// ```\npub fn[T] Array::reserve_capacity(self : Array[T], capacity : Int) -> Unit {\n  if self.capacity() >= capacity {\n    return\n  }\n  self.resize_buffer(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let v = Array::new(capacity=10)\n///   v.push(1)\n///   v.push(2)\n///   v.push(3)\n///   v.shrink_to_fit()\n///   assert_eq(v.capacity(), 3)\n/// }\n/// ```\npub fn[T] Array::shrink_to_fit(self : Array[T]) -> Unit {\n  if self.capacity() <= self.length() {\n    return\n  }\n  self.resize_buffer(self.length())\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = []\n///   v.push(3)\n/// }\n/// ```\npub fn[T] Array::push(self : Array[T], value : T) -> Unit {\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  let length = self.length()\n  self.unsafe_set(length, value)\n  self.len = length + 1\n}\n\n///|\n/// Removes the last element from an array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [1, 2, 3]\n///   assert_eq(v.pop(), Some(3))\n///   assert_eq(v, [1, 2])\n/// }\n/// ```\npub fn[T] Array::pop(self : Array[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    let index = len - 1\n    let v = self.unsafe_get(index)\n    self.buf.set_null(index)\n    self.len = index\n    Some(v)\n  }\n}\n\n///|\n/// Removes and returns the last element from the array.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to remove and return the last element.\n///\n/// Returns the last element of the array before removal.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [1, 2, 3]\n///   inspect(arr.unsafe_pop(), content=\"3\")\n///   inspect(arr, content=\"[1, 2]\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if the array is empty.\")\n#doc(hidden)\n#alias(pop_exn, deprecated)\npub fn[T] Array::unsafe_pop(self : Array[T]) -> T {\n  let len = self.length()\n  guard len != 0\n  let index = len - 1\n  let v = self.unsafe_get(index)\n  self.buf.set_null(index)\n  self.len = index\n  v\n}\n\n///|\n/// Removes and returns the element at position index within the array, \n/// shifting all elements after it to the left.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   assert_eq(v.remove(1), 4)\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::remove(self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.unsafe_get(index)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index,\n    self.buffer(),\n    index + 1,\n    self.length() - index - 1,\n  )\n  self.unsafe_truncate_to_length(self.length() - 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns an array range from `begin` to `end` `[begin, end)`\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let v = [3, 4, 5]\n///   let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n///   assert_eq(vv, [4])\n///   assert_eq(v, [3, 5])\n/// }\n/// ```\npub fn[T] Array::drain(self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end\n  let num = end - begin\n  let v = Array::make_uninit(num)\n  UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), begin, num)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    begin,\n    self.buffer(),\n    end,\n    self.length() - end,\n  )\n  self.unsafe_truncate_to_length(self.length() - num)\n  v\n}\n\n///|\n/// Inserts an element at a given index within the array.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt check\n/// test {\n///   let a = [1, 2, 3]\n///   a.insert(1, 4)\n///   inspect(a, content=\"[1, 4, 2, 3]\")\n///   let b = [1, 2, 3]\n///   b.insert(0, 5)\n///   inspect(b, content=\"[5, 1, 2, 3]\")\n///   let c = [1, 2, 3]\n///   c.insert(3, 6)\n///   inspect(c, content=\"[1, 2, 3, 6]\")\n/// }\n/// ```\npub fn[T] Array::insert(self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index + 1,\n    self.buffer(),\n    index,\n    self.length() - index,\n  )\n  let length = self.length()\n  self.unsafe_set(index, value)\n  self.len = length + 1\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitialized.\n///  If `new_len` is less than `len`, it will panic\n///\nfn[T] Array::unsafe_grow_to_length(self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  let new_buf = UninitializedArray::make(new_len)\n  UninitializedArray::unsafe_blit(new_buf, 0, self.buf, 0, self.len)\n  self.len = new_len\n  self.buf = new_buf\n}\n\n///|\n/// Fills an Array with a specified value.\n/// \n/// This method fills all or part of an Array with the given value.\n/// \n/// # Parameters\n/// - `value`: The value to fill the array with\n/// - `start`: The starting index (inclusive, default: 0)\n/// - `end`: The ending index (exclusive, optional)\n/// \n/// If `end` is not provided, fills from `start` to the end of the array.\n/// If `start` equals `end`, no elements are modified.\n/// \n/// # Panics\n/// - Panics if `start` is negative or greater than or equal to the array length\n/// - Panics if `end` is provided and is less than `start` or greater than array length\n/// - Does nothing if the array is empty\n/// \n/// # Example\n/// ```mbt check\n/// test {\n///   // Fill entire array\n///   let arr = [1, 2, 3, 4, 5]\n///   arr.fill(0)\n///   inspect(arr, content=\"[0, 0, 0, 0, 0]\")\n///\n///   // Fill from index 1 to 3 (exclusive)\n///   let arr2 = [1, 2, 3, 4, 5]\n///   arr2.fill(99, start=1, end=3)\n///   inspect(arr2, content=\"[1, 99, 99, 4, 5]\")\n///\n///   // Fill from index 2 to end\n///   let arr3 = [\"a\", \"b\", \"c\", \"d\"]\n///   arr3.fill(\"x\", start=2)\n///   inspect(\n///     arr3,\n///     content=(\n///       #|[\"a\", \"b\", \"x\", \"x\"]\n///     ),\n///   )\n/// }\n/// ```\npub fn[A] Array::fill(\n  self : Array[A],\n  value : A,\n  start? : Int = 0,\n  end? : Int,\n) -> Unit {\n  let array_length = self.length()\n  guard array_length > 0 else { return }\n  guard start >= 0 && start < array_length\n  let length = match end {\n    None => array_length\n    Some(e) => {\n      guard e >= start && e <= array_length\n      e\n    }\n  }\n  self.buf.unchecked_fill(start, value, length - start)\n}\n\n///|\n/// Creates and returns a new array with a copy of all elements from the input\n/// array.\n///\n/// Parameters:\n///\n/// * `array` : The array to be copied.\n///\n/// Returns a new array containing all elements from the original array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let original = [1, 2, 3]\n///   let copied = original.copy()\n///   inspect(copied, content=\"[1, 2, 3]\")\n///   inspect(physical_equal(original, copied), content=\"false\")\n/// }\n/// ```\npub fn[T] Array::copy(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = Array::make(len, self[0])\n    Array::unsafe_blit(arr, 0, self, 0, len)\n    arr\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder {\n  mut data : FixedArray[Byte]\n  mut len : Int\n}\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint? : Int = 0) -> StringBuilder {\n  let initial = if size_hint < 1 { 1 } else { size_hint }\n  let data : FixedArray[Byte] = FixedArray::make(initial, 0)\n  { data, len: 0 }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.len == 0\n}\n\n///|\nfn StringBuilder::grow_if_necessary(\n  self : StringBuilder,\n  required : Int,\n) -> Unit {\n  let current_len = self.data.length()\n  if required <= current_len {\n    return\n  }\n  // current_len is at least 1\n  let mut enough_space = current_len\n  // double the enough_space until it larger than required\n  while enough_space < required {\n    enough_space = enough_space * 2\n  }\n  let new_data = FixedArray::make(enough_space, Byte::default())\n  new_data.unsafe_blit(0, self.data, 0, self.len)\n  self.data = new_data\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(self.len, str, 0, str.length())\n  self.len += str.length() * 2\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.grow_if_necessary(self.len + 4)\n  let inc = self.data.set_utf16le_char(self.len, ch)\n  self.len += inc\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let sb = StringBuilder::new()\n///   sb.write_view(\"Hello, world!\"[:5])\n///   assert_eq(sb.to_string(), \"Hello\")\n/// }\n/// ```\npub impl Logger for StringBuilder with write_view(\n  self : StringBuilder,\n  str : StringView,\n) -> Unit {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(\n    self.len,\n    str.data(),\n    str.start_offset(),\n    str.length(),\n  )\n  self.len += str.length() * 2\n}\n\n///|\n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.data\n  .unsafe_reinterpret_as_bytes()\n  .to_unchecked_string(offset=0, length=self.len)\n}\n\n///|\n/// TODO: improve perf\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(\n    self.data\n    .unsafe_reinterpret_as_bytes()\n    .to_unchecked_string(offset=0, length=self.len),\n  )\n}\n\n///|\n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.len = 0\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Performs multiplication between two byte values. The result is truncated to\n/// fit within the byte range.\n///\n/// Parameters:\n///\n/// * `self` : The first byte operand in the multiplication.\n/// * `that` : The second byte operand in the multiplication.\n///\n/// Returns the product of the two bytes, truncated to fit within the byte range\n/// (0-255).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b'\\x02'\n///   let b = b'\\x03'\n///   inspect(a * b, content=\"b'\\\\x06'\") // 2 * 3 = 6\n///   let c = b'\\xFF'\n///   inspect(c * c, content=\"b'\\\\x01'\") // 255 * 255 = 65025, truncated to 1\n/// }\n/// ```\npub impl Mul for Byte with mul(self : Byte, that : Byte) -> Byte {\n  (self.to_int() * that.to_int()).to_byte()\n}\n\n///|\n/// Performs division operation between two bytes by converting them to integers,\n/// performing the division, and converting the result back to a byte.\n///\n/// Parameters:\n///\n/// * `self` : The dividend byte value.\n/// * `that` : The divisor byte value.\n///\n/// Returns the quotient of the division as a byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b'\\xFF' // 255\n///   let b = b'\\x03' // 3\n///   inspect(a / b, content=\"b'\\\\x55'\") // 255 / 3 = 85 (0x55)\n/// }\n/// ```\npub impl Div for Byte with div(self : Byte, that : Byte) -> Byte {\n  (self.to_int() / that.to_int()).to_byte()\n}\n\n///|\npub impl Mod for Byte with mod(self : Byte, that : Byte) -> Byte {\n  (self.to_int() % that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values for equality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are equal, otherwise `false`.\npub impl Eq for Byte with equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() == that.to_int()\n}\n\n///|\n/// Compares two `Byte` values for inequality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are not equal, otherwise `false`.\npub impl Eq for Byte with not_equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() != that.to_int()\n}\n\n///|\n/// Adds two `Byte` values together and returns the result as a `Byte`.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to be added.\n/// - `byte2` : The second `Byte` value to be added.\n///\n/// Returns the sum of `byte1` and `byte2` as a `Byte`.\npub impl Add for Byte with add(self : Byte, that : Byte) -> Byte {\n  (self.to_int() + that.to_int()).to_byte()\n}\n\n///|\n/// Subtracts the second byte from the first byte and returns the result as a\n/// byte.\n///\n/// Parameters:\n///\n/// - `self` : The byte from which the second byte will be subtracted.\n/// - `that` : The byte to subtract from the first byte.\n///\n/// Returns the result of the subtraction as a byte.\npub impl Sub for Byte with sub(self : Byte, that : Byte) -> Byte {\n  (self.to_int() - that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values and returns an integer indicating their relative\n/// order.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to compare.\n/// - `byte2` : The second `Byte` value to compare.\n///\n/// Returns an integer where:\n/// - A value less than 0 indicates that `byte1` is less than `byte2`.\n/// - A value of 0 indicates that `byte1` is equal to `byte2`.\n/// - A value greater than 0 indicates that `byte1` is greater than `byte2`.\npub impl Compare for Byte with compare(self : Byte, that : Byte) -> Int {\n  self.to_int().compare(that.to_int())\n}\n\n///|\npub impl Compare for Byte with op_lt(x, y) {\n  x.to_int() < y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_le(x, y) {\n  x.to_int() <= y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_gt(x, y) {\n  x.to_int() > y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_ge(x, y) {\n  x.to_int() >= y.to_int()\n}\n\n///|\nfn alphabet(x : Int) -> String {\n  match x {\n    0 => \"0\"\n    1 => \"1\"\n    2 => \"2\"\n    3 => \"3\"\n    4 => \"4\"\n    5 => \"5\"\n    6 => \"6\"\n    7 => \"7\"\n    8 => \"8\"\n    9 => \"9\"\n    10 => \"A\"\n    11 => \"B\"\n    12 => \"C\"\n    13 => \"D\"\n    14 => \"E\"\n    15 => \"F\"\n    _ => abort(\"impossible\")\n  }\n}\n\n///|\n/// Converts a `Byte` to its string representation in hexadecimal format.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns a `String` representing the `Byte` in the format `b'\\xHH'`, where\n/// `HH` is the hexadecimal representation of the byte.\npub fn Byte::to_string(self : Byte) -> String {\n  let i = self.to_int()\n  let hi = alphabet(i / 16)\n  let lo = alphabet(i % 16)\n  \"b'\\\\x\\{hi}\\{lo}'\"\n}\n\n///|\n/// Implements the `Hash` trait for `Byte` type by providing a `hash_combine`\n/// method that combines a byte value with a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The byte value to be hashed.\n/// * `hasher` : The hasher object that will be used to combine the byte value\n/// into its internal state.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hasher = Hasher::new(seed=0)\n///   hasher.combine_byte(b'\\xFF')\n///   inspect(hasher.finalize(), content=\"1955036104\")\n/// }\n/// ```\npub impl Hash for Byte with hash_combine(self, hasher) {\n  hasher.combine_byte(self)\n}\n\n///|\n/// Returns the default value for a `Byte`, which is `b'\\x00'`.\n///\n/// Parameters:\n///\n/// - None\n///\n/// Returns the default `Byte` value, which is `b'\\x00'`.\npub impl Default for Byte with default() {\n  b'\\x00'\n}\n\n///|\n/// Performs a bitwise NOT operation on the given `Byte` value.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to apply the bitwise NOT operation on.\n///\n/// Returns the result of the bitwise NOT operation as a `Byte`.\npub fn Byte::lnot(self : Byte) -> Byte {\n  self.to_int().lnot().to_byte()\n}\n\n///|\n/// Performs a bitwise AND operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to perform the bitwise AND operation with.\n/// - `byte2` : The second `Byte` value to perform the bitwise AND operation\n///   with.\n///\n/// Returns the result of the bitwise AND operation as a `Byte`.\npub impl BitAnd for Byte with land(self : Byte, that : Byte) -> Byte {\n  (self.to_int() & that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise OR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns a new `Byte` value resulting from the bitwise OR operation.\npub impl BitOr for Byte with lor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() | that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise XOR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns the result of the bitwise XOR operation as a `Byte`.\npub impl BitXOr for Byte with lxor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() ^ that.to_int()).to_byte()\n}\n\n///|\n/// Converts a `Byte` to a `UInt`.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns the `UInt` representation of the `Byte`.\npub fn Byte::to_uint(self : Byte) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n/// Converts a byte value to an unsigned 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns an unsigned 64-bit integer representation of the byte value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF'\n///   inspect(b.to_uint64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_uint64(self : Byte) -> UInt64 {\n  self.to_uint().to_uint64()\n}\n\n///|\n/// Counts the number of 1-bits (population count) in the byte using bitwise operations.\n///\n/// Parameters:\n///\n/// * `self` : The byte value whose 1-bits are to be counted.\n///\n/// Returns the number of 1-bits in the byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\x0F'\n///   inspect(b.popcnt(), content=\"4\")\n/// }\n/// ```\npub fn Byte::popcnt(self : Byte) -> Int {\n  let mut n = self\n  n = (n & 0x55) + ((n >> 1) & 0x55)\n  n = (n & 0x33) + ((n >> 2) & 0x33)\n  n = (n & 0x0F) + ((n >> 4) & 0x0F)\n  n.to_int()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the left by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the shift operation.\npub impl Shl for Byte with shl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the right by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value whose bits are to be shifted.\n/// - `count` : The number of bit positions to shift the `byte` value to the\n///   right.\n///\n/// Returns the resulting `Byte` value after the bitwise right shift operation.\npub impl Shr for Byte with shr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the source string being viewed.\nfn StringView::str(self : StringView) -> String = \"%stringview.str\"\n\n///|\n/// Returns the starting UTF-16 code unit index into the string.\nfn StringView::start(self : StringView) -> Int = \"%stringview.start\"\n\n///|\n/// Returns the ending UTF-16 code unit index into the string (not included).\nfn StringView::end(self : StringView) -> Int = \"%stringview.end\"\n\n///|\nfn StringView::make_view(str : String, start : Int, end : Int) -> StringView = \"%stringview.make\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn StringView::at(self : StringView, index : Int) -> UInt16 {\n  guard index >= 0 && index < self.length() else {\n    abort(\"Index out of bounds\")\n  }\n  self.str().code_unit_at(self.start() + index)\n}\n\n///|\n/// Returns the length of the view.\n/// \n/// This method counts the charcodes(code unit) in the view and has O(1) complexity.\npub fn StringView::length(self : StringView) -> Int {\n  self.end() - self.start()\n}\n\n///|\n/// Iterates over all suffixes of the view, advancing by a Unicode character at\n/// a time. Each yielded suffix is itself a view into the original string.\npub fn StringView::suffixes(\n  self : StringView,\n  include_empty? : Bool = false,\n) -> Iter[StringView] {\n  let str = self.str()\n  let end = self.end()\n  let mut next_start = self.start()\n  let mut finished = false\n  Iter::new(fn() -> StringView? {\n    if finished {\n      None\n    } else if next_start == end {\n      finished = true\n      if include_empty {\n        Some(StringView::make_view(str, next_start, end))\n      } else {\n        None\n      }\n    } else {\n      let suffix = StringView::make_view(str, next_start, end)\n      let code = str.unsafe_charcode_at(next_start)\n      if code.is_leading_surrogate() &&\n        next_start + 1 < end &&\n        str.unsafe_charcode_at(next_start + 1).is_trailing_surrogate() {\n        next_start += 2\n      } else {\n        next_start += 1\n      }\n      Some(suffix)\n    }\n  })\n}\n\n///|\n/// Returns the original string that is being viewed.\npub fn StringView::data(self : StringView) -> String {\n  self.str()\n}\n\n///|\n/// Returns the starting offset (in UTF-16 code units) of this view into its\n/// underlying string.\npub fn StringView::start_offset(self : StringView) -> Int {\n  self.start()\n}\n\n///|\n/// Returns a new view of the view with the given start and end offsets.\npub fn StringView::view(\n  self : StringView,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(\n    self.str(),\n    self.start() + start_offset,\n    self.start() + end_offset,\n  )\n}\n\n///|\n/// Returns the charcode(code unit) at the given index without checking if the\n/// index is within bounds.\n/// \n/// This method has O(1) complexity.\n/// #Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"BğŸ¤£ğŸ¤£C\"\n///   let view = str[:]\n///   inspect(view.unsafe_charcode_at(0), content=\"66\")\n///   inspect(view.unsafe_charcode_at(1), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(2), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(3), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(4), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(5), content=\"67\")\n/// }\n/// ```\n/// TODO: rename to `unsafe_get`\npub fn StringView::unsafe_charcode_at(self : StringView, index : Int) -> Int {\n  self.str().unsafe_charcode_at(self.start() + index)\n}\n\n///|\n/// Returns the number of Unicode characters in this view.\n/// \n/// Note this has O(n) complexity where n is the length of the code points in \n/// the view.\npub fn StringView::char_length(self : StringView) -> Int {\n  self.str().char_length(start_offset=self.start(), end_offset=self.end())\n}\n\n///|\npub impl Show for StringView with output(self, logger) {\n  let substr = self.str().unsafe_substring(start=self.start(), end=self.end())\n  String::output(substr, logger)\n}\n\n///|\n/// Returns a new String containing a copy of the characters in this view.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"Hello World\"\n///   let view = str.view(\n///     start_offset=str.offset_of_nth_char(0).unwrap(),\n///     end_offset=str.offset_of_nth_char(5).unwrap(),\n///   ) // \"Hello\"\n///   inspect(view.to_string(), content=\"Hello\")\n/// }\n/// ```\npub impl Show for StringView with to_string(self) {\n  // when `self == self.str()`, `String::unsafe_substring` would return original string, which doesn't create a new copy.\n  self.str().unsafe_substring(start=self.start(), end=self.end())\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\n#alias(iterator, deprecated)\npub fn StringView::iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  Iter::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        index += 2\n        return Some(code_point_of_surrogate_pair(c1, c2))\n      }\n    }\n    index += 1\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n#alias(iterator2, deprecated)\npub fn StringView::iter2(self : StringView) -> Iter2[Int, Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  let mut char_index = 0\n  Iter2::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        let result = (char_index, code_point_of_surrogate_pair(c1, c2))\n        index += 2\n        char_index += 1\n        return Some(result)\n      }\n    }\n    let result = (char_index, c1.unsafe_to_char())\n    index += 1\n    char_index += 1\n    Some(result)\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\n#alias(rev_iterator, deprecated)\npub fn StringView::rev_iter(self : StringView) -> Iter[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = end\n  Iter::new(fn() {\n    guard index > start else { None }\n    index -= 1\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.str().unsafe_charcode_at(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2, c1))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical characters in the same order.\npub impl Eq for StringView with equal(self, other) {\n  let len = self.length()\n  guard len == other.length() else { return false }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return true\n  }\n  for i in 0..<len {\n    guard self.str().unsafe_charcode_at(self.start() + i) ==\n      other.str().unsafe_charcode_at(other.start() + i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Views are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for StringView with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return 0\n  }\n  for i in 0..<self_len {\n    let cmp = self\n      .str()\n      .unsafe_charcode_at(self.start() + i)\n      .compare(other.str().unsafe_charcode_at(other.start() + i))\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// Performs a lexicographical comparison of two string views.\n///\n/// This method compares the views character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one view is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt check\n/// test {\n///   let str = \"abc\"\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=0, end_offset=3)),\n///     content=\"-1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=3)\n///     .lexical_compare(str.view(start_offset=0, end_offset=2)),\n///     content=\"1\",\n///   )\n///   inspect(\n///     str\n///     .view(start_offset=0, end_offset=2)\n///     .lexical_compare(str.view(start_offset=1, end_offset=3)),\n///     content=\"-1\",\n///   )\n/// }\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn StringView::lexical_compare(\n  self : StringView,\n  other : StringView,\n) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let min_len = if self_len < other_len { self_len } else { other_len }\n\n  // Compare character by character up to the minimum length\n  for i in 0..<min_len {\n    let self_char = self.str().unsafe_charcode_at(self.start() + i)\n    let other_char = other.str().unsafe_charcode_at(other.start() + i)\n    let cmp = self_char.compare(other_char)\n    if cmp != 0 {\n      return cmp\n    }\n  }\n\n  // If all characters match up to min_len, the shorter one is lexicographically smaller\n  self_len.compare(other_len)\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```mbt check\n/// test {\n///   let str = \"HelloğŸ¤£ğŸ¤£ğŸ¤£\"\n///   let view1 = str.view()\n///   inspect(view1, content=\"HelloğŸ¤£ğŸ¤£ğŸ¤£\")\n///   let start_offset = str.offset_of_nth_char(1).unwrap()\n///   let end_offset = str.offset_of_nth_char(6).unwrap() // the second emoji\n///   let view2 = str.view(start_offset~, end_offset~)\n///   inspect(view2, content=\"elloğŸ¤£\")\n/// }\n/// ```\npub fn String::view(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(self, start_offset, end_offset)\n}\n\n///|\n/// Convert char array to string view.\npub fn StringView::from_array(chars : ArrayView[Char]) -> StringView {\n  String::from_array(chars)\n}\n\n///|\n/// Convert char iterator to string view.\n#alias(from_iterator, deprecated)\npub fn StringView::from_iter(iter : Iter[Char]) -> StringView {\n  String::from_iter(iter)\n}\n\n///|\npub suberror CreatingViewError {\n  IndexOutOfBounds\n  InvalidIndex\n} derive(Show)\n\n///|\n/// Creates a view of a string with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index (default: 0)\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string (e.g., -1 means last position)\n/// - `end` : Ending UTF-16 code unit index (optional)\n///   - If `None`: extends to the end of the string\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified substring range\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of valid range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt\n/// let str = \"HelloğŸ¤£World\"\n/// let view1 =  str[0:5]\n/// inspect(\n///   view1,\n///   content=(\n///     \"Hello\"\n///   ),\n/// )\n/// let view2 = try? str[-5:]\n/// inspect(\n///   view2,\n///   content=(\n///     #|Ok(\"World\")\n///   ),\n/// )\n/// let view3 = try? str[:6]\n/// inspect(view3, content=\"Err(InvalidIndex)\")\n/// ```\n#alias(\"_[_:_]\")\npub fn String::sub(\n  self : String,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { raise IndexOutOfBounds }\n  if start < len && self.unsafe_charcode_at(start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if end < len && self.unsafe_charcode_at(end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self, start, end)\n}\n\n///|\n/// Creates a subview of an existing view with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index relative to this view (default: 0)\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// - `end` : Ending UTF-16 code unit index relative to this view (optional)\n///   - If `None`: extends to the end of this view\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified subrange of this view\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of this view's range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt check\n/// test {\n///   let str = \"HelloğŸ¤£World\"[1:-1] // \"elloğŸ¤£Worl\"\n///   let view1 = str[0:6]\n///   inspect(view1, content=\"elloğŸ¤£\")\n///   let view2 = str[-2:]\n///   inspect(view2, content=\"rl\")\n///   let view3 = try? str[:5]\n///   inspect(view3, content=\"Err(InvalidIndex)\")\n/// }\n/// ```\n#alias(\"_[_:_]\")\npub fn StringView::sub(\n  self : StringView,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let str_len = self.str().length()\n\n  // Calculate absolute positions in the original string\n  let abs_end = match end {\n    None => self.end()\n    Some(end) => if end < 0 { self.end() + end } else { self.start() + end }\n  }\n  let abs_start = if start < 0 {\n    self.end() + start\n  } else {\n    self.start() + start\n  }\n\n  // Validate bounds against the original string\n  guard abs_start >= self.start() &&\n    abs_start <= abs_end &&\n    abs_end <= self.end() else {\n    raise IndexOutOfBounds\n  }\n\n  // Check for surrogate pair boundaries\n  if abs_start < str_len &&\n    self.str().unsafe_charcode_at(abs_start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if abs_end < str_len &&\n    self.str().unsafe_charcode_at(abs_end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self.str(), abs_start, abs_end)\n}\n\n///|\n/// Test if the length of the view is equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_eq(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_eq(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Test if the length of the view is greater than or equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_ge(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_ge(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character of\n/// the view. If i is negative, it returns the index of the (n + i)-th character\n/// where n is the total number of Unicode characters in the view.\npub fn StringView::offset_of_nth_char(self : StringView, i : Int) -> Int? {\n  if self\n    .str()\n    .offset_of_nth_char(i, start_offset=self.start(), end_offset=self.end())\n    is Some(index) {\n    Some(index - self.start())\n  } else {\n    None\n  }\n}\n\n///|\n/// The empty view of a string\npub impl Default for StringView with default() {\n  \"\"\n}\n\n///|\n/// Create a new string by repeating the given character `value` `length` times.\npub fn StringView::make(length : Int, value : Char) -> StringView {\n  String::make(length, value)\n}\n\n///|\npub impl ToJson for StringView with to_json(self) {\n  String::to_json(self.to_string())\n}\n\n///|\npub impl Add for StringView with add(self, other) {\n  [..self, ..other]\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T : Show] debug_string(t : T) -> String {\n  let buf = StringBuilder::new(size_hint=50)\n  t.output(buf)\n  buf.to_string()\n}\n\n///|\n/// Asserts that two values are equal. If they are not equal, raises a failure\n/// with a message containing the source location and the values being compared.\n///\n/// Parameters:\n///\n/// * `a` : First value to compare.\n/// * `b` : Second value to compare.\n/// * `loc` : Source location information to include in failure messages. This is\n/// usually automatically provided by the compiler.\n///\n/// Throws a `Failure` error if the values are not equal, with a message showing\n/// the location of the failing assertion and the actual values that were\n/// compared.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_eq(1, 1)\n///   assert_eq(\"hello\", \"hello\")\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if a != b {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} != \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that two values of the same type are not equal. If the values are\n/// equal, raises a failure with a detailed error message including the source\n/// location and string representation of both values.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `location` : Source location information for error reporting. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error if the values are equal. The error message includes\n/// the source location and string representations of both values.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_not_eq(1, 2) // Passes\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_not_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if !(a != b) {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} == \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that the given boolean value is true. Throws an error with source\n/// location information if the assertion fails.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean value to be checked.\n/// * `location` : The source location where the assertion is made. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error with a descriptive message including the source\n/// location if the condition is false.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_true(true)\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_true(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if !x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not true\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Tests whether a boolean condition is false, throwing an error if the\n/// condition is true.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean condition to test.\n/// * `location` : The source location where the assertion is made. Used in error\n/// messages.\n///\n/// Throws a `Failure` error if the condition is true. The error message includes\n/// the source location and the value that was expected to be false.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_false(false)\n///   assert_false(1 > 2)\n/// }\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_false(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not false\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a generic test failure type used primarily in test assertions and\n/// validations.\n///\n/// Since this is a type definition using `suberror` syntax, it creates an error\n/// type `Failure` that wraps a `String` value containing the failure message.\n///\n/// Parameters:\n///\n/// * `message` : A string describing the nature of the failure.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let err : Failure = Failure(\"Test assertion failed\")\n///   match err {\n///     Failure(msg) => inspect(msg, content=\"Test assertion failed\")\n///   }\n///   @json.inspect(err, content=[\"Failure\", \"Test assertion failed\"])\n/// }\n/// ```\npub(all) suberror Failure String derive(ToJson, Show)\n\n///|\n/// Raises a `Failure` error with a given message and source location.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be included in the\n/// failure.\n/// * `location` : The source code location where the failure occurred.\n/// Automatically provided by the compiler when not specified.\n///\n/// Returns a value of type `T` wrapped in a `Failure` error type.\n///\n/// Throws an error of type `Failure` with a message that includes both the\n/// source location and the provided error message.\n#callsite(autofill(loc))\npub fn[T] fail(msg : String, loc~ : SourceLoc) -> T raise Failure {\n  raise Failure(\"\\{loc} FAILED: \\{msg}\")\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#cfg(not(target=\"js\"))\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\n#cfg(not(target=\"js\"))\nfn unsafe_fixedarray_uint16_to_string(buffer : FixedArray[UInt16]) -> String = \"%string.unsafe_from_uint16_fixedarray\"\n\n//==========================================\n// Int and UInt (Non JS)\n//==========================================\n\n///|\n/// Converts an unsigned 32-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFU).reinterpret_as_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFU).reinterpret_as_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36\n#cfg(not(target=\"js\"))\nfn int_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.reinterpret_as_uint()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1U\n    while n > 0U {\n      offset = offset - 1\n      let digit = n.land(mask).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0U {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 32-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000U {\n    let t = num / 10000U\n    let r = (num % 10000U).reinterpret_as_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.reinterpret_as_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Calculates the number of decimal digits in a u32 value\n#cfg(not(target=\"js\"))\nfn dec_count32(value : UInt) -> Int {\n  // Binary search: split 1-10 digits into halves\n  if value >= 100000U { // >= 10^5 means 6+ digits\n    if value >= 10000000U { // >= 10^7 means 8+ digits\n      if value >= 1000000000U { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000U { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000U { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000U { // >= 10^3 means 4+ digits\n    if value >= 10000U { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100U { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10U { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u32 value\n#cfg(not(target=\"js\"))\nfn hex_count32(value : UInt) -> Int {\n  if value == 0U {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (31 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u32 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count32(value : UInt, radix : Int) -> Int {\n  if value == 0U {\n    return 1\n  }\n  let mut num = value\n  let base = radix.reinterpret_as_uint()\n  let mut count = 0\n  while num > 0U {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n/// Example:\n/// ```\n/// inspect((255).to_string(radix=16), content=\"ff\")\n/// inspect((-255).to_string(radix=16), content=\"-ff\")\n/// ```\n#cfg(not(target=\"js\"))\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0 {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0\n  let num : UInt = if is_negative {\n    // Negate and reinterpret as UInt\n    // Works correctly for Int::min_value due to two's complement:\n    // -Int::min_value wraps to itself, then reinterpreting gives 2147483648U\n    (-self).reinterpret_as_uint()\n  } else {\n    self.reinterpret_as_uint()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count32(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0U {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count32(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n//==========================================\n// Int and UInt (JS)\n//==========================================\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  int_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int_to_string_js(i : Int, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return x.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  uint_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint_to_string_js(i : UInt, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return (x >>> 0).toString(radix);\n  #|}\n\n//==========================================\n// Int64 and UInt64\n//==========================================\n\n///|\n/// Calculates the number of decimal digits in a u64 value\n#cfg(not(target=\"js\"))\nfn dec_count64(value : UInt64) -> Int {\n  // Binary search: split 1-20 digits into halves\n  if value >= 10000000000UL { // >= 10^10 means 11+ digits\n    if value >= 100000000000000UL { // >= 10^14 means 15+ digits\n      if value >= 10000000000000000UL { // >= 10^16 means 17+ digits\n        if value >= 1000000000000000000UL { // >= 10^18 means 19+ digits\n          if value >= 10000000000000000000UL { // >= 10^19 means 20 digits\n            20\n          } else {\n            19\n          }\n        } else if value >= 100000000000000000UL { // >= 10^17 means 18 digits\n          18\n        } else {\n          17\n        }\n      } else if value >= 1000000000000000UL { // >= 10^15 means 16 digits\n        16\n      } else {\n        15\n      }\n    } else if value >= 1000000000000UL { // >= 10^12 means 13+ digits\n      if value >= 10000000000000UL { // >= 10^13 means 14 digits\n        14\n      } else {\n        13\n      }\n    } else if value >= 100000000000UL { // >= 10^11 means 12 digits\n      12\n    } else {\n      11\n    }\n  } else if value >= 100000UL { // >= 10^5 means 6+ digits\n    if value >= 10000000UL { // >= 10^7 means 8+ digits\n      if value >= 1000000000UL { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000UL { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000UL { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000UL { // >= 10^3 means 4+ digits\n    if value >= 10000UL { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100UL { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10UL { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u64 value\n#cfg(not(target=\"js\"))\nfn hex_count64(value : UInt64) -> Int {\n  if value == 0UL {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (63 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u64 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count64(value : UInt64, radix : Int) -> Int {\n  if value == 0UL {\n    return 1\n  }\n  let mut num = value\n  let base = radix.to_uint64()\n  let mut count = 0\n  while num > 0UL {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an unsigned 64-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int64_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFUL).to_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFUL).to_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36 (64-bit)\n#cfg(not(target=\"js\"))\nfn int64_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.to_uint64()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1UL\n    while n > 0UL {\n      offset = offset - 1\n      let digit = n.land(mask).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0UL {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int64_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000UL {\n    let t = num / 10000UL\n    let r = (num % 10000UL).to_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.to_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0L {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0L\n  let num : UInt64 = if is_negative {\n    // Negate and reinterpret as UInt64\n    // Works correctly for Int64::min_value due to two's complement\n    (-self).reinterpret_as_uint64()\n  } else {\n    self.reinterpret_as_uint64()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count64(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0UL {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count64(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  int64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int64_to_string_js(num : Int64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  let val = (BigInt(num.hi >>> 0) << 32n) | BigInt(num.lo >>> 0);\n  #|  if (val & (1n << 63n)) {\n  #|    val = val - (1n << 64n);\n  #|  }\n  #|  return val.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  uint64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint64_to_string_js(num : UInt64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  return (BigInt(num.hi >>> 0) << 32n | BigInt(num.lo >>> 0)).toString(radix);\n  #|}\n\n//==========================================\n// Int16 and UInt16\n//==========================================\n\n///|\npub fn UInt16::to_string(self : UInt16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n//==========================================\n// Test cases\n//==========================================\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  equal(Self, Self) -> Bool = _\n  #deprecated(\"use `equal` instead\", skip_current_package=true)\n  op_equal(Self, Self) -> Bool = _\n  not_equal(Self, Self) -> Bool = _\n}\n\n///|\nimpl Eq with not_equal(x, y) {\n  !(x == y)\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n  op_lt(Self, Self) -> Bool = _\n  op_gt(Self, Self) -> Bool = _\n  op_le(Self, Self) -> Bool = _\n  op_ge(Self, Self) -> Bool = _\n}\n\n///|\nimpl Compare with op_lt(x, y) {\n  x.compare(y).is_neg()\n}\n\n///|\nimpl Compare with op_gt(x, y) {\n  x.compare(y).is_pos()\n}\n\n///|\nimpl Compare with op_le(x, y) {\n  x.compare(y).is_non_pos()\n}\n\n///|\nimpl Compare with op_ge(x, y) {\n  x.compare(y).is_non_neg()\n}\n\n///|\n/// Trait for types that can be hashed\n/// \n/// The `hash` method should return a hash value for the type, which is used in hash tables and other data structures.\n/// The `hash_combine` method is used to combine the hash of the current value with another hash value,\n/// typically used to hash composite types.\n/// \n/// When two values are equal according to the `Eq` trait, they should produce the same hash value.\n/// \n/// The `hash` method does not need to be implemented if `hash_combine` is implemented,\n/// When implemented separately, `hash` **does not need** to produce a hash value that is consistent with `hash_combine`.\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit = _\n  #deprecated(\"use `write_view` instead\", skip_current_package=true)\n  write_substring(Self, String, Int, Int) -> Unit = _\n  write_view(Self, StringView) -> Unit = _\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_substring(self, value, start, len) {\n  self.write_view(try! value[start:start + len])\n}\n\n///|\nimpl Logger with write_string(self, value) {\n  self.write_view(value[:])\n}\n\n///|\n#deprecated(\"replace `impl write_substring` with `impl write_view`\")\nimpl Logger with write_view(self, value) {\n  self.write_substring(value.data(), value.start_offset(), value.length())\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n///|\n/// Default implementation for `Show::to_string`, uses a `StringBuilder`\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix? : String = \"[\",\n  suffix? : String = \"]\",\n  sep? : String = \", \",\n  trailing? : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n\n///|\n#deprecated(\"replace `impl op_equal` with `impl equal`\")\nimpl Eq with equal(self, other) {\n  Eq::op_equal(self, other)\n}\n\n///|\nimpl Eq with op_equal(self, other) {\n  Eq::equal(self, other)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Reinterpret the byte sequence as Bytes.\n///\n/// Notice that this will make the `Bytes` object to be a view of the original\n/// byte sequence, so any modification to the original byte sequence will be\n/// reflected in the `Bytes` object.\n#internal(unsafe, \"Creating mutable Bytes\")\n#doc(hidden)\npub fn FixedArray::unsafe_reinterpret_as_bytes(\n  self : FixedArray[Byte],\n) -> Bytes = \"%identity\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized using a function that maps indices to bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. If `length` is less than or\n/// equal to 0, returns an empty byte sequence.\n/// * `value` : A function that takes an index (from 0 to `length - 1`) and\n/// returns a byte for that position.\n///\n/// Returns a new byte sequence containing the bytes produced by applying the\n/// value function to each index.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::makei(3, i => (i + 65).to_byte())\n///   assert_eq(bytes, b\"ABC\")\n/// }\n/// ```\npub fn Bytes::makei(length : Int, value : (Int) -> Byte raise?) -> Bytes raise? {\n  if length <= 0 {\n    return []\n  }\n  let arr = FixedArray::make(length, value(0))\n  for i in 1..<length {\n    arr[i] = value(i)\n  }\n  FixedArray::unsafe_reinterpret_as_bytes(arr)\n}\n\n///|\n/// TODO: support local primitive declaration\n#owned(bytes)\nfn unsafe_sub_string(\n  bytes : Bytes,\n  byte_offset : Int,\n  byte_length : Int,\n) -> String = \"$moonbit.unsafe_bytes_sub_string\"\n\n///|\n/// Return an unchecked string, containing the subsequence of `self` that starts at\n/// `offset` and has length `length`. Both `offset` and `length`\n/// are indexed by byte.\n///\n/// Note this function does not validate the encoding of the byte sequence,\n/// it simply copy the bytes into a new String.\npub fn Bytes::to_unchecked_string(\n  self : Bytes,\n  offset? : Int = 0,\n  length? : Int,\n) -> String {\n  let len = self.length()\n  let length = if length is Some(l) { l } else { len - offset }\n  guard offset >= 0 && length >= 0 && offset + length <= len\n  unsafe_sub_string(self, offset, length)\n}\n\n///|\n/// Copies characters from a string to a byte sequence in UTF-16LE encoding. Each\n/// character is converted into two bytes, with the lower byte stored first.\n///\n/// Parameters:\n///\n/// * `self` : The destination byte array to copy the characters into.\n/// * `bytes_offset` : The starting position in the destination array where bytes\n/// will be written.\n/// * `str` : The source string containing the characters to copy.\n/// * `str_offset` : The starting position in the source string from which\n/// characters will be read.\n/// * `length` : The number of characters to copy.\n///\n/// Throws a runtime error if:\n///\n/// * `length` is negative\n/// * `bytes_offset` is negative\n/// * `str_offset` is negative\n/// * The range `[bytes_offset, bytes_offset + length * 2)` exceeds the length of\n/// the destination array\n/// * The range `[str_offset, str_offset + length)` exceeds the length of the\n/// source string\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = FixedArray::make(6, b'\\x00')\n///   bytes.blit_from_string(0, \"ABC\", 0, 3)\n///   @json.inspect(bytes, content=[65, 0, 66, 0, 67, 0]) // 'A'\n///   bytes.blit_from_string(0, \"ä½ å¥½å•Š\", 0, 3)\n///   @json.inspect(bytes, content=[96, 79, 125, 89, 74, 85]) // 'ä½ å¥½å•Š'\n///   bytes.blit_from_string(0, \"ğŸ˜ˆ\", 0, 2)\n///   @json.inspect(bytes, content=[61, 216, 8, 222, 74, 85]) // 'ğŸ˜ˆ'\n/// }\n/// ```\npub fn FixedArray::blit_from_string(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  str : String,\n  str_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = str_offset\n  let e1 = bytes_offset + length * 2 - 1\n  let e2 = str_offset + length - 1\n  let len1 = self.length()\n  let len2 = str.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  let end_str_offset = str_offset + length\n  for i = str_offset, j = bytes_offset; i < end_str_offset; i = i + 1, j = j + 2 {\n    let c = str.unsafe_charcode_at(i).reinterpret_as_uint()\n    self[j] = (c & 0xff).to_byte()\n    self[j + 1] = (c >> 8).to_byte()\n  }\n}\n\n///|\n/// TODO: specific copy\nfn unsafe_from_bytes(bytes : Bytes) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Copy `length` chars from byte sequence `src`, starting at `src_offset`,\n/// into byte sequence `self`, starting at `bytes_offset`.\npub fn FixedArray::blit_from_bytes(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : Bytes,\n  src_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = src_offset\n  let e1 = bytes_offset + length - 1\n  let e2 = src_offset + length - 1\n  let len1 = self.length()\n  let len2 = src.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  FixedArray::unsafe_blit(\n    self,\n    bytes_offset,\n    unsafe_from_bytes(src),\n    src_offset,\n    length,\n  )\n}\n\n///|\n/// Copy bytes from a BytesView into a fixed array of bytes.\n///\n/// Parameters:\n///\n/// * `self` : The destination fixed array of bytes.\n/// * `bytes_offset` : The starting position in the destination array where bytes will be copied.\n/// * `src` : The source View to copy from.\n///\n/// Throws a panic if:\n/// * `bytes_offset` is negative\n/// * The destination array is too small to hold all bytes from the source View\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(4, b'\\x00')\n///   let view = b\"\\x01\\x02\\x03\"[1:]\n///   arr.blit_from_bytesview(1, view)\n///   inspect(arr, content=\"[b'\\\\x00', b'\\\\x02', b'\\\\x03', b'\\\\x00']\")\n/// }\n/// ```\npub fn FixedArray::blit_from_bytesview(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : BytesView,\n) -> Unit {\n  FixedArray::blit_from_bytes(\n    self,\n    bytes_offset,\n    src.bytes(),\n    src.start(),\n    src.len(),\n  )\n}\n\n///|\n/// Encodes a Unicode character into UTF-8 bytes and writes them into a fixed\n/// array of bytes at the specified offset.\n///\n/// Parameters:\n///\n/// * `array` : The fixed array of bytes to write into.\n/// * `offset` : The starting position in the array where the encoded bytes will\n/// be written.\n/// * `char` : The Unicode character to be encoded.\n///\n/// Returns the number of bytes written (1 to 4 bytes depending on the\n/// character's code point).\n///\n/// Throws a panic if:\n///\n/// * The character's code point is greater than 0x10FFFF.\n/// ```mbt check\n/// test {\n///   let buf = FixedArray::make(4, b'\\x00')\n///   let written = buf.set_utf8_char(0, 'â‚¬') // Euro symbol (U+20AC)\n///   inspect(written, content=\"3\") // UTF-8 encoding takes 3 bytes\n///   inspect(buf[0], content=\"b'\\\\xE2'\")\n///   inspect(buf[1], content=\"b'\\\\x82'\")\n///   inspect(buf[2], content=\"b'\\\\xAC'\")\n/// }\n/// ```\npub fn FixedArray::set_utf8_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  match code {\n    _..<0x80 => {\n      self[offset] = ((code & 0x7F) | 0x00).to_byte()\n      1\n    }\n    _..<0x0800 => {\n      self[offset] = (((code >> 6) & 0x1F) | 0xC0).to_byte()\n      self[offset + 1] = ((code & 0x3F) | 0x80).to_byte()\n      2\n    }\n    _..<0x010000 => {\n      self[offset] = (((code >> 12) & 0x0F) | 0xE0).to_byte()\n      self[offset + 1] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = ((code & 0x3F) | 0x80).to_byte()\n      3\n    }\n    _..<0x110000 => {\n      self[offset] = (((code >> 18) & 0x07) | 0xF0).to_byte()\n      self[offset + 1] = (((code >> 12) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 3] = ((code & 0x3F) | 0x80).to_byte()\n      4\n    }\n    _ => abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16LE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16le_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code & 0xFF).to_byte()\n    self[offset + 1] = (code >> 8).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo & 0xFF).to_byte()\n    self[offset + 1] = (lo >> 8).to_byte()\n    self[offset + 2] = (hi & 0xFF).to_byte()\n    self[offset + 3] = (hi >> 8).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16BE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16be_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code >> 8).to_byte()\n    self[offset + 1] = (code & 0xFF).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo >> 8).to_byte()\n    self[offset + 1] = (lo & 0xFF).to_byte()\n    self[offset + 2] = (hi >> 8).to_byte()\n    self[offset + 3] = (hi & 0xFF).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Compares two byte sequences for equality. Returns true only if both sequences\n/// have the same length and contain identical bytes in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns `true` if the byte sequences are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes1 = b\"\\x01\\x02\\x03\"\n///   let bytes2 = b\"\\x01\\x02\\x03\"\n///   let bytes3 = b\"\\x01\\x02\\x04\"\n///   inspect(bytes1 == bytes2, content=\"true\")\n///   inspect(bytes1 == bytes3, content=\"false\")\n/// }\n/// ```\npub impl Eq for Bytes with equal(self : Bytes, other : Bytes) -> Bool {\n  if self.length() != other.length() {\n    false\n  } else {\n    let len = self.length()\n    for i in 0..<len {\n      if self[i] != other[i] {\n        break false\n      }\n    } else {\n      true\n    }\n  }\n}\n\n///|\n/// Compares two byte sequences based on shortlex order. First compares the lengths of\n/// the sequences, then compares bytes pairwise until a difference is found or\n/// all bytes have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = b\"\\x01\\x02\\x03\"\n///   let b = b\"\\x01\\x02\\x04\"\n///   inspect(a.compare(b), content=\"-1\") // a < b\n///   inspect(b.compare(a), content=\"1\") // b > a\n///   inspect(a.compare(a), content=\"0\") // a = a\n///   let a = b\"\\x01\\x02\"\n///   let b = b\"\\x01\\x02\\x03\"\n///   inspect(a.compare(b), content=\"-1\") // shorter sequence is less\n///   inspect(b.compare(a), content=\"1\") // longer sequence is greater\n/// }\n/// ```\npub impl Compare for Bytes with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  if cmp != 0 {\n    return cmp\n  }\n  for i in 0..<self_len {\n    let b1 = self.unsafe_get(i)\n    let b2 = other.unsafe_get(i)\n    let cmp = b1.compare(b2)\n    if cmp != 0 {\n      break cmp\n    }\n  } else {\n    0\n  }\n}\n\n///|\n/// Creates a new bytes sequence from a byte array.\n///\n/// Parameters:\n///\n/// * `array` : An array of bytes to be converted.\n///\n/// Returns a new bytes sequence containing the same bytes as the input array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = [b'h', b'i']\n///   let bytes = Bytes::from_array(arr)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hi\"\n///     ),\n///   )\n/// }\n///\n/// test {\n///   let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n///   let bytes = Bytes::from_array(arr)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hello\"\n///     ),\n///   )\n/// }\n/// ```\n// TODO: marked as intrinsic, inline if it is constant\n#alias(of, deprecated)\npub fn Bytes::from_array(arr : ArrayView[Byte]) -> Bytes {\n  Bytes::makei(arr.length(), i => arr[i])\n}\n\n///|\n/// Creates a new bytes sequence from a fixed-size array of bytes with an\n/// optional length parameter.\n///\n/// Parameters:\n///\n/// * `array` : A fixed-size array of bytes to be converted into a bytes\n/// sequence.\n/// * `length` : (Optional) The length of the resulting bytes sequence. If not\n/// provided, uses the full length of the input array.\n///\n/// Returns a new bytes sequence containing the bytes from the input array. If a\n/// length is specified, only includes up to that many bytes.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n///   let bytes = Bytes::from_array(arr[0:3])\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"hel\"\n///     ),\n///   )\n/// }\n/// ```\n/// \n/// Panics if the length is invalid\n#deprecated(\"Use Bytes::from_array instead\")\npub fn Bytes::from_fixedarray(arr : FixedArray[Byte], len? : Int) -> Bytes {\n  let len = match len {\n    None => arr.length()\n    Some(x) => {\n      guard 0 <= x && x <= arr.length()\n      x\n    }\n  }\n  let result = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_to(result, len~)\n  result.unsafe_reinterpret_as_bytes()\n}\n\n///|\n/// Converts a bytes sequence into a fixed-size array of bytes. If an optional\n/// length is provided, the resulting array will have exactly that length,\n/// otherwise it will match the length of the input bytes.\n///\n/// Parameters:\n///\n/// * `self` : The bytes sequence to convert.\n/// * `len` : Optional. The desired length of the output array. If specified, the\n/// resulting array will have this length. If not specified, the length of the\n/// input bytes sequence will be used.\n///\n/// Returns a fixed-size array containing the bytes from the input sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"hello\"\n///   let arr = bytes.to_fixedarray()\n///   inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n///   let arr2 = bytes[:3].to_fixedarray()\n///   inspect(arr2, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C']\")\n/// }\n/// ```\n/// \n/// Panics if the length is invalid\n#label_migration(len, fill=false)\npub fn Bytes::to_fixedarray(self : Bytes, len? : Int) -> FixedArray[Byte] {\n  let len = match len {\n    None => self.length()\n    Some(x) => {\n      guard 0 <= x && x <= self.length()\n      x\n    }\n  }\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self, 0, len)\n  arr\n}\n\n///|\npub fn BytesView::to_fixedarray(self : BytesView) -> FixedArray[Byte] {\n  let len = self.length()\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self.data(), self.start_offset(), len)\n  arr\n}\n\n///|\n/// Creates a new bytes sequence from an iterator of bytes.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator that yields bytes.\n///\n/// Returns a new bytes sequence containing all the bytes from the iterator.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let iter = Iter::singleton(b'h')\n///   let bytes = Bytes::from_iter(iter)\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"h\"\n///     ),\n///   )\n/// }\n/// ```\n#alias(from_iterator, deprecated)\npub fn Bytes::from_iter(iter : Iter[Byte]) -> Bytes {\n  Bytes::from_array(iter.collect())\n}\n\n///|\n/// Converts a bytes sequence into an array of bytes.\n///\n/// Parameters:\n///\n/// * `bytes` : A sequence of bytes to be converted into an array.\n///\n/// Returns an array containing the same bytes as the input sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"hello\"\n///   let arr = bytes.to_array()\n///   inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n/// }\n/// ```\npub fn Bytes::to_array(self : Bytes) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\npub fn BytesView::to_array(self : BytesView) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\n/// Creates an iterator over the bytes in the sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : A byte sequence to iterate over.\n///\n/// Returns an iterator that yields each byte in the sequence in order.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::from_array([b'h', b'i'])\n///   let mut sum = 0\n///   bytes.iter().each(b => sum = sum + b.to_int())\n///   inspect(sum, content=\"209\") // ASCII values: 'h'(104) + 'i'(105) = 209\n/// }\n/// ```\n#alias(iterator, deprecated)\npub fn Bytes::iter(self : Bytes) -> Iter[Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let c = self.unsafe_get(i)\n    i += 1\n    Some(c)\n  })\n}\n\n///|\n/// Creates an iterator that yields tuples of index and byte,\n/// indices start from 0.\n/// \n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let buf = StringBuilder::new(size_hint=5)\n///   let keys = []\n///   let it = b\"abcde\".iter2()\n///   while it.next() is Some((i, x)) {\n///     buf.write_string(x.to_string())\n///     keys.push(i)\n///   }\n///   inspect(buf, content=\"b'\\\\x61'b'\\\\x62'b'\\\\x63'b'\\\\x64'b'\\\\x65'\")\n///   inspect(keys, content=\"[0, 1, 2, 3, 4]\")\n/// }\n/// ```\n#alias(iterator2, deprecated)\npub fn Bytes::iter2(self : Bytes) -> Iter2[Int, Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iter::new(fn() {\n    guard i < len else { None }\n    let result = (i, self.unsafe_get(i))\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Creates a new empty bytes sequence.\n///\n/// Returns an empty bytes sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::default()\n///   inspect(bytes, content=\"b\\\"\\\"\")\n///   inspect(bytes.length(), content=\"0\")\n/// }\n/// ```\npub impl Default for Bytes with default() {\n  b\"\"\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index, or None if the index is out of bounds.\n///\n/// Example:\n/// \n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   let byte = bytes.get(1)\n///   inspect(byte, content=\"Some(b'\\\\x02')\")\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   let byte = bytes.get(3)\n///   inspect(byte, content=\"None\")\n/// }\n/// ```\npub fn Bytes::get(self : Bytes, index : Int) -> Byte? {\n  guard index >= 0 && index < self.length() else { None }\n  Some(self[index])\n}\n\n///|\nfn unsafe_to_fixedarray(array : UninitializedArray[Byte]) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Concatenates two bytes sequences.\n///\n/// Parameters:\n///\n/// * `self` : The first bytes sequence.\n/// * `other` : The second bytes sequence.\n/// TODO: marked as intrinsic, inline if it is constant\npub impl Add for Bytes with add(self : Bytes, other : Bytes) -> Bytes {\n  let len_self = self.length()\n  let len_other = other.length()\n  let rv : FixedArray[Byte] = FixedArray::make(len_self + len_other, 0)\n  for i in 0..<len_self {\n    rv[i] = self[i]\n  }\n  for i in 0..<len_other {\n    rv[len_self + i] = other[i]\n  }\n  unsafe_to_bytes(rv)\n}\n\n///|\npub impl Hash for Bytes with hash_combine(self, hasher) {\n  hasher.combine(self[:])\n}\n\n///|\n/// Returns a new `Bytes` consisting of `self` repeated `count` times.\n///\n/// If `count <= 0` or `self` is empty, an empty `Bytes` is returned. When\n/// `count == 1`, `self` is returned directly without allocation.\n///\n/// This implementation performs a single allocation sized exactly to the\n/// result and fills it using an exponential copy (doubling) strategy so the\n/// number of blit operations is O(log count).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(\n///     b\"ab\".repeat(3),\n///     content=(\n///       #|b\"ababab\"\n///     ),\n///   )\n///   inspect(\n///     b\"xyz\".repeat(0),\n///     content=(\n///       #|b\"\"\n///     ),\n///   )\n/// }\n/// ```\npub fn Bytes::repeat(self : Self, count : Int) -> Bytes {\n  if count <= 0 || self.length() == 0 {\n    return []\n  }\n  if count == 1 {\n    return self\n  }\n  let len = self.length()\n  let total = len * count\n  // (Optional) detect overflow: if multiplication wrapped (best-effort)\n  guard total / count == len\n  let arr = FixedArray::make(total, (0 : Byte))\n  arr.blit_from_bytes(0, self, 0, len)\n  let mut filled = len\n  while filled < total {\n    let remaining = total - filled\n    let copy_len = if filled < remaining { filled } else { remaining }\n    let src = unsafe_to_bytes(arr)\n    arr.blit_from_bytes(filled, src, 0, copy_len)\n    filled = filled + copy_len\n  }\n  unsafe_to_bytes(arr)\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Evaluates an expression and discards its result. This is useful when you want\n/// to execute an expression for its side effects but don't care about its return\n/// value, or when you want to explicitly indicate that a value is intentionally\n/// unused.\n///\n/// Parameters:\n///\n/// * `value` : The value to be ignored. Can be of any type.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 42\n///   ignore(x) // Explicitly ignore the value\n///   let mut sum = 0\n///   ignore([1, 2, 3].iter().each(x => sum = sum + x)) // Ignore the Unit return value of each()\n/// }\n/// ```\npub fn[T] ignore(t : T) -> Unit = \"%ignore\"\n\n///|\n/// Tests if two values are physically equal (i.e., point to the same memory\n/// location). Unlike structural equality testing (`==`), this function checks if\n/// two references point to exactly the same object in memory.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `T` : The type parameter representing the type of values being compared.\n///\n/// Returns `true` if both values refer to the same object in memory, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr1 = [1, 2, 3]\n///   let arr2 = arr1\n///   let arr3 = [1, 2, 3]\n///   inspect(physical_equal(arr1, arr2), content=\"true\") // Same object\n///   inspect(physical_equal(arr1, arr3), content=\"false\") // Different objects with same content\n/// }\n/// ```\npub fn[T] physical_equal(a : T, b : T) -> Bool = \"%refeq\"\n\n///|\n#callsite(autofill(loc))\npub fn[T] abort(string : String, loc~ : SourceLoc) -> T {\n  @abort.abort(\n    (\n      $|\\{string}\n      $|  at \\{loc}\n      $|\n    ),\n  )\n}\n\n///|\npub fn[T] panic() -> T = \"%panic\"\n\n// Bool primitive ops\n\n///|\n/// Performs logical negation on a boolean value.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to negate.\n///\n/// Returns the logical NOT of the input value: `true` if the input is `false`,\n/// and `false` if the input is `true`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(not(true), content=\"false\")\n///   inspect(not(false), content=\"true\")\n/// }\n/// ```\npub fn not(x : Bool) -> Bool = \"%bool_not\"\n\n///|\n/// Compares two boolean values for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare.\n///\n/// Returns `true` if both boolean values are equal (either both `true` or both\n/// `false`), `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true == true, content=\"true\")\n///   inspect(false == true, content=\"false\")\n///   inspect(true == false, content=\"false\")\n///   inspect(false == false, content=\"true\")\n/// }\n/// ```\npub impl Eq for Bool with equal(self : Bool, other : Bool) -> Bool = \"%bool_eq\"\n\n///|\n/// Compares two boolean values and returns their relative order. This is a\n/// deprecated method and users should use `compare` instead.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other` (i.e., `self` is `false`\n/// and `other` is `true`)\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other` (i.e., `self` is `true`\n/// and `other` is `false`)\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let t = true\n///   let f = false\n///   // This usage is deprecated, use compare() instead\n///   inspect(t.compare(f), content=\"1\")\n///   inspect(f.compare(t), content=\"-1\")\n///   inspect(t.compare(t), content=\"0\")\n/// }\n/// ```\n///\n#deprecated(\"Use `compare` instead\")\n#coverage.skip\npub fn Bool::op_compare(self : Bool, other : Bool) -> Int = \"%bool_compare\"\n\n///|\n/// Compares two boolean values and returns their relative order. The comparison\n/// follows the rule that `false` is less than `true`.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is `false` and `other` is `true`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is `true` and `other` is `false`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(true.compare(false), content=\"1\") // true > false\n///   inspect(false.compare(true), content=\"-1\") // false < true\n///   inspect(true.compare(true), content=\"0\") // true = true\n/// }\n/// ```\npub impl Compare for Bool with compare(self, other) = \"%bool_compare\"\n\n///|\n/// Returns the default value for the `Bool` type, which is `false`.\n///\n/// Returns a `Bool` value that represents the default state of a boolean value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b : Bool = Bool::default()\n///   inspect(b, content=\"false\")\n/// }\n/// ```\npub impl Default for Bool with default() = \"%bool_default\"\n\n// int32 primitive ops\n\n///|\n/// Performs arithmetic negation on an integer value, returning its additive\n/// inverse.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to negate.\n///\n/// Returns the negation of the input value. For all inputs except\n/// `Int::min_value()`, returns the value with opposite sign. When the input is\n/// `Int::min_value()`, returns `Int::min_value()` due to two's complement\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42, content=\"-42\")\n///   inspect(42, content=\"42\")\n///   inspect(2147483647, content=\"2147483647\") // negating near min value\n/// }\n/// ```\npub impl Neg for Int with neg(self) = \"%i32_neg\"\n\n///|\n/// Adds two 32-bit signed integers. Performs two's complement arithmetic, which\n/// means the operation will wrap around if the result exceeds the range of a\n/// 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer that is the sum of the two operands. If the\n/// mathematical sum exceeds the range of a 32-bit integer (-2,147,483,648 to\n/// 2,147,483,647), the result wraps around according to two's complement rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 + 1, content=\"43\")\n///   inspect(2147483647 + 1, content=\"-2147483648\") // Overflow wraps around to minimum value\n/// }\n/// ```\npub impl Add for Int with add(self, other) = \"%i32_add\"\n\n///|\n/// Performs subtraction between two 32-bit integers, following standard two's\n/// complement arithmetic rules. When the result overflows or underflows, it\n/// wraps around within the 32-bit integer range.\n///\n/// Parameters:\n///\n/// * `self` : The minuend (the number being subtracted from).\n/// * `other` : The subtrahend (the number to subtract).\n///\n/// Returns the difference between `self` and `other`.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 10\n///   inspect(a - b, content=\"32\")\n///   let max = 2147483647 // Int maximum value\n///   inspect(max - -1, content=\"-2147483648\") // Overflow case\n/// }\n/// ```\npub impl Sub for Int with sub(self, other) = \"%i32_sub\"\n\n///|\n/// Multiplies two 32-bit integers. This is the implementation of the `*`\n/// operator for `Int`.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns the product of the two integers. If the result overflows the range of\n/// `Int`, it wraps around according to two's complement arithmetic.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 * 2, content=\"84\")\n///   inspect(-10 * 3, content=\"-30\")\n///   let max = 2147483647 // Int.max_value\n///   inspect(max * 2, content=\"-2\") // Overflow wraps around\n/// }\n/// ```\npub impl Mul for Int with mul(self, other) = \"%i32_mul\"\n\n///|\n/// Performs integer division between two 32-bit integers. The result is\n/// truncated towards zero (rounds down for positive numbers and up for negative\n/// numbers).\n///\n/// Parameters:\n///\n/// * `dividend` : The first integer operand to be divided.\n/// * `divisor` : The second integer operand that divides the dividend.\n///\n/// Returns the quotient of the division operation.\n///\n/// Throws a panic if `divisor` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(10 / 3, content=\"3\") // truncates towards zero\n///   inspect(-10 / 3, content=\"-3\")\n///   inspect(10 / -3, content=\"-3\")\n/// }\n/// ```\npub impl Div for Int with div(self, other) = \"%i32_div\"\n\n///|\n/// Calculates the remainder of dividing one integer by another. The result\n/// follows the formula `dividend - (dividend / divisor) * divisor`, maintaining\n/// the same sign as the dividend.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number being divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns the remainder of the division. If `other` is 0, the behavior is\n/// undefined.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(7 % 3, content=\"1\")\n///   inspect(-7 % 3, content=\"-1\")\n///   inspect(7 % -3, content=\"1\")\n/// }\n/// ```\npub impl Mod for Int with mod(self, other) = \"%i32_mod\"\n\n///|\n/// Performs a bitwise NOT operation on a 32-bit integer. Flips each bit in the\n/// integer's binary representation (0 becomes 1 and 1 becomes 0).\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit integer on which to perform the bitwise NOT operation.\n///\n/// Returns a new integer with all bits flipped from the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = -1 // All bits are 1\n///   let b = 0 // All bits are 0\n///   inspect(a.lnot(), content=\"0\")\n///   inspect(b.lnot(), content=\"-1\")\n/// }\n/// ```\npub fn Int::lnot(self : Int) -> Int = \"%i32_lnot\"\n\n///|\n/// Performs a bitwise AND operation between two 32-bit integers. Each bit in the\n/// result is set to 1 only if the corresponding bits in both operands are 1.\n///\n/// Parameters:\n///\n/// * `self` : The first 32-bit integer operand.\n/// * `other` : The second 32-bit integer operand.\n///\n/// Returns the result of the bitwise AND operation. The resulting value has a\n/// bit set to 1 at each position where both input integers have a bit set to 1.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0 // 11110000\n///   let y = 0xAA // 10101010\n///   inspect(x & y, content=\"160\") // 10100000 = 160\n/// }\n/// ```\npub impl BitAnd for Int with land(self : Int, other : Int) -> Int = \"%i32_land\"\n\n///|\n/// Performs a bitwise OR operation between two 32-bit integers. For each bit\n/// position, the result is 1 if at least one of the corresponding bits in either\n/// operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if at least one of the\n/// corresponding bits in either operand is 1, and 0 otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x | y, content=\"65535\") // 1111_1111_1111_1111 = 65535\n/// }\n/// ```\npub impl BitOr for Int with lor(self : Int, other : Int) -> Int = \"%i32_lor\"\n\n///|\n/// Performs a bitwise XOR operation between two integers.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if the corresponding bits in\n/// the operands are different, and 0 if they are the same.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0 // 1111_0000_1111_0000\n///   let y = 0x0F0F // 0000_1111_0000_1111\n///   inspect(x ^ y, content=\"65535\") // 1111_1111_1111_1111\n///   inspect(x ^ x, content=\"0\") // XOR with self gives 0\n/// }\n/// ```\npub impl BitXOr for Int with lxor(self : Int, other : Int) -> Int = \"%i32_lxor\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the\n/// rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift. Must be a non-negative value\n/// less than 32. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new integer with bits shifted left by the specified number of\n/// positions. For each position shifted, the rightmost bit is filled with 0, and\n/// the leftmost bit is discarded.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = -4\n///   inspect(y << 2, content=\"-16\") // Binary: 100 -> 10000\n/// }\n/// ```\npub impl Shl for Int with shl(self, other) = \"%i32_shl\"\n\n///|\n/// Performs an arithmetic right shift operation on an integer value. Shifts the\n/// bits of the first operand to the right by the number of positions specified\n/// by the second operand. The sign bit is preserved and copied to the leftmost\n/// positions.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the right. Must be\n/// non-negative.\n///\n/// Returns an integer representing the result of the arithmetic right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -16\n///   inspect(n >> 2, content=\"-4\") // Sign bit is preserved during shift\n///   let p = 16\n///   inspect(p >> 2, content=\"4\") // Regular right shift for positive numbers\n/// }\n/// ```\npub impl Shr for Int with shr(self, other) = \"%i32_shr\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the vacated\n/// bit positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the left.\n///\n/// Returns an integer containing the result of shifting `self` left by `shift`\n/// positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 42\n///   inspect(y << 2, content=\"168\") // Binary: 101010 -> 10101000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::lsl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts the bits of the\n/// first operand to the left by the specified number of positions. The rightmost\n/// positions are filled with zeros.\n///\n/// Parameters:\n///\n/// * `value` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift left. Must be non-negative and\n/// less than 32.\n///\n/// Returns a new integer value after performing the left shift operation. The\n/// value is equal to multiplying the input by 2 raised to the power of the shift\n/// count.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1\n///   inspect(x << 3, content=\"8\") // Equivalent to x << 3\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::shl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a logical right shift operation on a signed 32-bit integer. In a\n/// logical right shift, zeros are shifted in from the left, regardless of the\n/// sign bit. This function is DEPRECATED and users should use `UInt` type with\n/// the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The signed 32-bit integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a signed 32-bit integer containing the same bits as if the input were\n/// treated as an unsigned integer and shifted right logically.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -4 // Binary: 11111...11100\n///   let unsigned = x.reinterpret_as_uint() // Convert to UInt first\n///   inspect(unsigned >> 1, content=\"2147483646\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use UInt type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int::lsr(self : Int, other : Int) -> Int {\n  (self.reinterpret_as_uint() >> other).reinterpret_as_int()\n}\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer value,\n/// preserving the sign bit by replicating it into the positions vacated by the\n/// shift. This is a deprecated function; use the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new integer value that is the result of arithmetically shifting\n/// `self` right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = -16\n///   inspect(x >> 2, content=\"-4\") // Right shift preserves sign bit\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::asr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer by the\n/// specified number of positions. The operation preserves the sign bit,\n/// replicating it into the positions vacated by the shift.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right.\n///\n/// Returns a new integer representing the result of shifting `self` right by\n/// `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = -1024\n///   inspect(n >> 3, content=\"-128\") // Preserves sign bit during right shift\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::shr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Counts the number of consecutive zero bits at the least significant end of\n/// the integer's binary representation.\n///\n/// Parameters:\n///\n/// * `self` : The integer value whose trailing zeros are to be counted.\n///\n/// Returns the number of trailing zero bits (0 to 32). For example, returns 0 if\n/// the value is odd (least significant bit is 1), returns 32 if the value is 0\n/// (all bits are zeros).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0\n///   inspect(x.ctz(), content=\"32\") // All bits are zero\n///   let y = 1\n///   inspect(y.ctz(), content=\"0\") // No trailing zeros\n///   let z = 16\n///   inspect(z.ctz(), content=\"4\") // Binary: ...10000\n/// }\n/// ```\npub fn Int::ctz(self : Int) -> Int = \"%i32_ctz\"\n\n///|\npub fn Int::clz(self : Int) -> Int = \"%i32_clz\"\n\n///|\n/// Counts the number of set bits (1s) in the binary representation of a 32-bit\n/// integer.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be counted.\n///\n/// Returns the number of bits set to 1 in the binary representation of the input\n/// integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0b1011 // Binary: 1011 (3 bits set)\n///   inspect(x.popcnt(), content=\"3\")\n///   let y = -1 // All bits set in two's complement\n///   inspect(y.popcnt(), content=\"32\")\n/// }\n/// ```\npub fn Int::popcnt(self : Int) -> Int = \"%i32_popcnt\"\n\n///|\n/// Compares two integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 == 42, content=\"true\")\n///   inspect(42 == -42, content=\"false\")\n/// }\n/// ```\npub impl Eq for Int with equal(self : Int, other : Int) -> Bool = \"%i32_eq\"\n\n///|\n/// Compares two integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(42 != 42, content=\"false\")\n///   inspect(42 != -42, content=\"true\")\n/// }\n/// ```\npub impl Eq for Int with not_equal(self : Int, other : Int) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42\n///   let b = 24\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for Int with compare(self, other) = \"%i32_compare\"\n\n///|\npub impl Compare for Int with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Int with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Int with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Int with op_ge(x, y) = \"%i32.ge\"\n\n///|\npub fn Int::is_pos(self : Int) -> Bool = \"%i32_is_pos\"\n\n///|\n/// Tests whether an integer is negative.\n///\n/// Parameters:\n///\n/// * `self` : The integer to test.\n///\n/// Returns `true` if the integer is negative, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let neg = -42\n///   let zero = 0\n///   let pos = 42\n///   inspect(neg.is_neg(), content=\"true\")\n///   inspect(zero.is_neg(), content=\"false\")\n///   inspect(pos.is_neg(), content=\"false\")\n/// }\n/// ```\npub fn Int::is_neg(self : Int) -> Bool = \"%i32_is_neg\"\n\n///|\npub fn Int::is_non_pos(self : Int) -> Bool = \"%i32_is_non_pos\"\n\n///|\npub fn Int::is_non_neg(self : Int) -> Bool = \"%i32_is_non_neg\"\n\n///|\n/// Returns the default value for integers, which is 0.\n///\n/// Returns an integer value of 0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x : Int = Int::default()\n///   inspect(x, content=\"0\")\n/// }\n/// ```\npub impl Default for Int with default() = \"%i32_default\"\n\n///|\n/// Converts a 32-bit integer to a double-precision floating-point number. The\n/// conversion preserves the exact value since all integers in the range of `Int`\n/// can be represented exactly as `Double` values.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that represents the same\n/// numerical value as the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_double(), content=\"42\")\n///   let neg = -42\n///   inspect(neg.to_double(), content=\"-42\")\n/// }\n/// ```\npub fn Int::to_double(self : Int) -> Double = \"%i32_to_f64\"\n\n///|\n/// Converts a double-precision floating-point number to an unsigned 32-bit\n/// integer by truncating the decimal part. When the input is NaN or negative,\n/// returns 0. When the input exceeds the maximum value of UInt (4294967295),\n/// returns 4294967295.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the truncated value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(UInt::trunc_double(42.75), content=\"42\")\n/// }\n/// ```\npub fn UInt::trunc_double(val : Double) -> UInt = \"%f64.to_u32\"\n\n///|\n/// reinterpret the signed int as unsigned int, when the value is\n/// non-negative, i.e, 0..=2^31-1, the value is the same. When the\n/// value is negative, it turns into a large number,\n/// for example, -1 turns into 2^32-1\npub fn Int::reinterpret_as_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n\n///|\n/// Reinterprets a signed 32-bit integer as an unsigned 32-bit integer. For\n/// numbers within the range \\[0, 2^31-1], the value remains the same. For\n/// negative numbers, they are reinterpreted as large positive numbers in the\n/// range \\[2^31, 2^32-1].\n///\n/// Parameters:\n///\n/// * `value` : The signed 32-bit integer to be reinterpreted.\n///\n/// Returns an unsigned 32-bit integer that has the same bit pattern as the\n/// input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   let neg = -1\n///   inspect(pos.reinterpret_as_uint(), content=\"42\")\n///   inspect(neg.reinterpret_as_uint(), content=\"4294967295\") // 2^32 - 1\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_uint` instead\")\n#coverage.skip\npub fn Int::to_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n// Double primitive ops\n\n///|\n/// Converts a 32-bit signed integer to an unsigned 64-bit integer by first\n/// converting it to a signed 64-bit integer and then reinterpreting the bits as\n/// an unsigned value.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted.\n///\n/// Returns an unsigned 64-bit integer representing the same bit pattern as the\n/// input value when extended to 64 bits.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let pos = 42\n///   inspect(pos.to_uint64(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint64(), content=\"18446744073709551615\") // 2^64 - 1\n/// }\n/// ```\npub fn Int::to_uint64(self : Int) -> UInt64 {\n  self.to_int64().reinterpret_as_uint64()\n}\n\n///|\n/// Negates a double-precision floating-point number. For non-NaN inputs, changes\n/// the sign of the number. For NaN inputs, returns NaN.\n///\n/// Parameters:\n///\n/// * `number` : The double-precision floating-point number to negate.\n///\n/// Returns a new double-precision floating-point number that is the negation of\n/// the input number.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(-42.0, content=\"-42\")\n///   inspect(42.0, content=\"42\")\n///   inspect(-(0.0 / 0.0), content=\"NaN\") // Negating NaN returns NaN\n/// }\n/// ```\npub impl Neg for Double with neg(self) = \"%f64_neg\"\n\n///|\n/// Adds two double-precision floating-point numbers together following IEEE 754\n/// standards.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number.\n/// * `other` : The second double-precision floating-point number to add.\n///\n/// Returns the sum of the two numbers. Special cases follow IEEE 754 rules:\n///\n/// * If either operand is NaN, returns NaN\n/// * If adding +âˆ and -âˆ, returns NaN\n/// * If adding Â±âˆ with any finite number, returns Â±âˆ\n/// * If adding +0.0 and -0.0, returns +0.0\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 + 3.7, content=\"6.2\")\n///   inspect(1.0 / 0.0 + -1.0 / 0.0, content=\"NaN\") // Infinity + -Infinity = NaN\n/// }\n/// ```\npub impl Add for Double with add(self, other) = \"%f64_add\"\n\n///|\n/// Performs subtraction between two double-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first operand (minuend).\n/// * `other` : The second operand (subtrahend).\n///\n/// Returns the difference between the two numbers according to IEEE 754\n/// double-precision arithmetic rules.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5.0\n///   let b = 3.0\n///   inspect(a - b, content=\"2\")\n///   inspect(0.0 / 0.0 - 1.0, content=\"NaN\") // NaN - anything = NaN\n/// }\n/// ```\npub impl Sub for Double with sub(self, other) = \"%f64_sub\"\n\n///|\n/// Multiplies two double-precision floating-point numbers. This is the\n/// implementation of the `*` operator for `Double` type.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point operand.\n/// * `other` : The second double-precision floating-point operand.\n///\n/// Returns a new double-precision floating-point number representing the product\n/// of the two operands. Special cases follow IEEE 754 standard:\n///\n/// * If either operand is NaN, returns NaN\n/// * If one operand is infinity and the other is zero, returns NaN\n/// * If one operand is infinity and the other is a non-zero finite number,\n/// returns infinity with the appropriate sign\n/// * If both operands are infinity, returns infinity with the appropriate sign\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(2.5 * 2.0, content=\"5\")\n///   inspect(-2.0 * 3.0, content=\"-6\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan * 1.0, content=\"NaN\")\n/// }\n/// ```\npub impl Mul for Double with mul(self, other) = \"%f64_mul\"\n\n///|\n/// Performs division between two double-precision floating-point numbers.\n/// Follows IEEE 754 standard for floating-point arithmetic, including handling\n/// of special cases like division by zero (returns infinity) and operations\n/// involving NaN.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (numerator) in the division operation.\n/// * `other` : The divisor (denominator) in the division operation.\n///\n/// Returns the result of dividing `self` by `other`. Special cases follow IEEE\n/// 754:\n///\n/// * Division by zero returns positive or negative infinity based on the\n/// dividend's sign\n/// * Operations involving NaN return NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(6.0 / 2.0, content=\"3\")\n///   inspect(-6.0 / 2.0, content=\"-3\")\n///   inspect(1.0 / 0.0, content=\"Infinity\")\n/// }\n/// ```\npub impl Div for Double with div(self, other) = \"%f64_div\"\n\n///|\n/// Calculates the square root of a double-precision floating-point number. For\n/// non-negative numbers, returns the positive square root. For negative numbers\n/// or NaN, returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number whose square root is to\n/// be calculated.\n///\n/// Returns the square root of the input number, or NaN if the input is negative\n/// or NaN.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(4.0.sqrt(), content=\"2\")\n///   inspect(0.0.sqrt(), content=\"0\")\n///   inspect((-1.0).sqrt(), content=\"NaN\")\n/// }\n/// ```\npub fn Double::sqrt(self : Double) -> Double = \"%f64_sqrt\"\n\n///|\n/// Compares two double-precision floating-point numbers for equality following\n/// IEEE 754 rules. Returns `true` if both numbers are equal, including when both\n/// are `NaN`. Note that this differs from the standard IEEE 754 behavior where\n/// `NaN` is not equal to any value, including itself.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan == nan, content=\"false\") // NaN != NaN\n/// }\n/// ```\npub impl Eq for Double with equal(self : Double, other : Double) -> Bool = \"%f64_eq\"\n\n///|\n/// Compares two double-precision floating-point numbers for inequality following\n/// IEEE 754 rules. Returns `true` if the numbers are not equal.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if the numbers are not equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 3.14\n///   let c = 2.718\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n///   let nan = 0.0 / 0.0 // NaN\n///   inspect(nan != nan, content=\"true\") // NaN != NaN is true\n/// }\n/// ```\npub impl Eq for Double with not_equal(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn Double::op_neq(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n/// Compares two double-precision floating-point numbers and returns their\n/// relative order. Follows IEEE 754 rules for floating-point comparisons,\n/// including handling of special values like NaN.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare\n/// against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n/// * If either value is NaN, returns an implementation-defined value that is\n/// consistent with total ordering\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3.14\n///   let b = 2.718\n///   inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n///   inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n///   inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// }\n/// ```\npub impl Compare for Double with compare(self, other) = \"%f64_compare\"\n\n///|\npub impl Compare for Double with op_lt(x, y) = \"%f64.lt\"\n\n///|\npub impl Compare for Double with op_le(x, y) = \"%f64.le\"\n\n///|\npub impl Compare for Double with op_gt(x, y) = \"%f64.gt\"\n\n///|\npub impl Compare for Double with op_ge(x, y) = \"%f64.ge\"\n\n///|\n/// Returns the default value for double-precision floating-point numbers (0.0).\n///\n/// Returns a `Double` value initialized to 0.0.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(Double::default(), content=\"0\")\n/// }\n/// ```\npub impl Default for Double with default() = \"%f64_default\"\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(Double::convert_uint(n), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(Double::convert_uint(max), content=\"4294967295\")\n/// }\n/// ```\npub fn Double::convert_uint(val : UInt) -> Double = \"%u32.to_f64\"\n\n// Char primitive ops\n\n///|\n/// Converts a character to its Unicode code point value as an integer.\n///\n/// Parameters:\n///\n/// * `self` : The character to be converted.\n///\n/// Returns an integer representing the Unicode code point value of the\n/// character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('A'.to_int(), content=\"65\") // ASCII value of 'A'\n///   inspect('ã‚'.to_int(), content=\"12354\") // Unicode code point of 'ã‚'\n/// }\n/// ```\npub fn Char::to_int(self : Char) -> Int = \"%char_to_int\"\n\n///|\n/// Converts a Unicode character to its unsigned 32-bit integer code point\n/// representation. The character's code point value is first converted to a\n/// signed integer and then reinterpreted as an unsigned integer.\n///\n/// Parameters:\n///\n/// * `character` : The Unicode character to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the character's Unicode code\n/// point.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let c = 'A'\n///   inspect(c.to_uint(), content=\"65\") // ASCII value of 'A'\n///   let emoji = 'ğŸ¤£'\n///   inspect(emoji.to_uint(), content=\"129315\") // Unicode code point U+1F923\n/// }\n/// ```\npub fn Char::to_uint(self : Char) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n#deprecated(\"Use `Int::unsafe_to_char` instead, and use `Int::to_char` for safe conversion\")\npub fn Char::from_int(val : Int) -> Char = \"%char_from_int\"\n\n///|\n/// Compares two characters for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if both characters represent the same Unicode code point,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for Char with equal(self : Char, other : Char) -> Bool = \"%char_eq\"\n\n///|\n/// Compares two characters for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if the characters represent different Unicode code points,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 'A'\n///   let b = 'A'\n///   let c = 'B'\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for Char with not_equal(self : Char, other : Char) -> Bool = \"%i32_ne\"\n\n///|\n/// Compares two characters based on their Unicode code points. Returns a\n/// negative value if the first character comes before the second, zero if they\n/// are equal, and a positive value if the first character comes after the\n/// second.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare against.\n///\n/// Returns an integer indicating the relative ordering:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect('a'.compare('b'), content=\"-1\")\n///   inspect('b'.compare('a'), content=\"1\")\n///   inspect('a'.compare('a'), content=\"0\")\n/// }\n/// ```\npub impl Compare for Char with compare(self, other) = \"%char_compare\"\n\n///|\npub impl Compare for Char with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Char with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Char with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Char with op_ge(x, y) = \"%i32.ge\"\n\n///|\n/// Returns the default value for the `Char` type, which is the null character\n/// (`'\\x00'`).\n///\n/// Returns a `Char` value representing the null character.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   assert_true(Char::default().to_string() == \"\\u0000\")\n/// }\n/// ```\npub impl Default for Char with default() = \"%char_default\"\n\n// Bytes primitive ops\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to access.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a byte value from the specified position in the sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes[1], content=\"b'\\\\x02'\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn Bytes::at(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence without\n/// performing bounds checking. This is a low-level operation that should be used\n/// with caution.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to retrieve the byte from.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a single byte from the specified position in the byte sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.unsafe_get(1), content=\"b'\\\\x02'\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn Bytes::unsafe_get(self : Bytes, idx : Int) -> Byte = \"%bytes.unsafe_get\"\n\n///|\n/// Returns the number of bytes in a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence whose length is to be determined.\n///\n/// Returns an integer representing the length (number of bytes) of the sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = b\"\\x01\\x02\\x03\"\n///   inspect(bytes.length(), content=\"3\")\n///   let empty = b\"\"\n///   inspect(empty.length(), content=\"0\")\n/// }\n/// ```\npub fn Bytes::length(self : Bytes) -> Int = \"%bytes_length\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized to the given value. Returns an empty byte sequence if the\n/// length is negative.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be non-negative.\n/// * `initial_value` : The byte value used to initialize each position in the\n/// sequence.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::make(3, b'\\xFF')\n///   inspect(\n///     bytes,\n///     content=(\n///       #|b\"\\xff\\xff\\xff\"\n///     ),\n///   )\n///   let empty = Bytes::make(0, b'\\x00')\n///   inspect(empty, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::make(len : Int, init : Byte) -> Bytes {\n  if len < 0 {\n    return []\n  }\n  Bytes::unsafe_make(len, init)\n}\n\n///|\nfn Bytes::unsafe_make(len : Int, init : Byte) -> Bytes = \"%bytes_make\"\n\n///|\n/// Creates a new byte sequence filled with zero bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be a\n/// non-negative integer.\n///\n/// Returns a new byte sequence of the specified length, with all bytes\n/// initialized to zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let bytes = Bytes::new(3)\n///   inspect(bytes, content=\"b\\\"\\\\x00\\\\x00\\\\x00\\\"\")\n///   let bytes = Bytes::new(0)\n///   inspect(bytes, content=\"b\\\"\\\"\")\n/// }\n/// ```\npub fn Bytes::new(len : Int) -> Bytes {\n  Bytes::make(len, b'\\x00')\n}\n\n///|\n/// Converts a 32-bit signed integer to a byte by taking its least significant 8\n/// bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258 // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let neg = -1 // In binary: all 1's\n///   inspect(neg.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn Int::to_byte(self : Int) -> Byte = \"%i32_to_byte\"\n\n///|\npub fn Int::unsafe_to_char(self : Int) -> Char = \"%char_from_int\"\n\n///|\npub fn Int::to_char(self : Int) -> Char? {\n  if self is (0..=0xD7FF) || self is (0xE000..=0x10FFFF) {\n    Some(self.unsafe_to_char())\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to a byte by truncating it to fit within\n/// the byte range (0 to 255).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258UL // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// }\n/// ```\npub fn UInt64::to_byte(self : UInt64) -> Byte {\n  self.to_int().to_byte()\n}\n\n// FixedArray primitive ops\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function implements the array indexing operator `[]`.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Panics if the index is out of bounds.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]\")\npub fn[T] FixedArray::at(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Retrieves an element from a fixed-size array at the specified index without\n/// performing bounds checking. This is an unsafe operation that may cause\n/// undefined behavior if used incorrectly.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to retrieve the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index in the array.\n///\n/// Throws a panic if the index is out of bounds (negative or greater than or\n/// equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.unsafe_get(1), content=\"42\")\n/// }\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_get(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.unsafe_get\"\n\n///|\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_set(\n  self : FixedArray[T],\n  idx : Int,\n  val : T,\n) -> Unit = \"%fixedarray.unsafe_set\"\n\n///|\n/// Sets the value at the specified index in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to be modified.\n/// * `index` : The index at which to set the value. Must be non-negative and\n/// less than the array's length.\n/// * `value` : The value to be set at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 0)\n///   arr.set(1, 42)\n///   inspect(arr[1], content=\"42\")\n/// }\n/// ```\n#alias(\"_[_]=_\")\npub fn[T] FixedArray::set(self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Returns the number of elements in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\npub fn[T] FixedArray::length(self : FixedArray[T]) -> Int = \"%fixedarray.length\"\n\n///|\n/// Creates a new fixed-size array with the specified length, initializing all\n/// elements with the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be non-negative.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new fixed-size array of type `FixedArray[T]` with `length`\n/// elements, where each element is initialized to `initial_value`.\n///\n/// Throws a panic if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let arr = FixedArray::make(3, 42)\n///   inspect(arr[0], content=\"42\")\n///   inspect(arr.length(), content=\"3\")\n/// }\n/// ```\n/// \n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt check\n/// test {\n///   let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))\n///   two_dimension_array[0][5] = 10\n///   assert_eq(two_dimension_array[5][5], 10)\n/// }\n/// ```\n/// This is because all the cells reference to the same object (the FixedArray[Int] in this case). \n/// One should use makei() instead which creates an object for each index.\npub fn[T] FixedArray::make(len : Int, init : T) -> FixedArray[T] = \"%fixedarray.make\"\n\n// String primitive ops\n\n///|\n/// Returns the number of UTF-16 code units in the string. Note that this is not\n/// necessarily equal to the number of Unicode characters (code points) in the\n/// string, as some characters may be represented by multiple UTF-16 code units.\n///\n/// Parameters:\n///\n/// * `string` : The string whose length is to be determined.\n///\n/// Returns the number of UTF-16 code units in the string.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(\"hello\".length(), content=\"5\")\n///   inspect(\"ğŸ¤£\".length(), content=\"2\") // Emoji uses two UTF-16 code units\n///   inspect(\"\".length(), content=\"0\") // Empty string\n/// }\n/// ```\n#alias(charcode_length, deprecated)\npub fn String::length(self : String) -> Int = \"%string_length\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n///\n/// Parameters:\n///\n/// * `string` : The string to access.\n/// * `index` : The position in the string from which to retrieve the code unit.\n///\n/// This method has O(1) complexity.\n#deprecated(\"Use `_[_]` instead which returns UInt16\")\npub fn String::charcode_at(self : String, idx : Int) -> Int = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn String::at(self : String, idx : Int) -> UInt16 = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at a given position in the string without\n/// performing bounds checking. This is a low-level function that provides direct\n/// access to the internal representation of the string.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the code unit.\n/// * `index` : The position of the code unit to retrieve.\n///\n/// Returns the UTF-16 code unit at the specified position as an integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str = \"BğŸ¤£ğŸ¤£C\"\n///   inspect(str.unsafe_charcode_at(0), content=\"66\") // 'B'\n///   inspect(str.unsafe_charcode_at(1), content=\"55358\") // First surrogate of ğŸ¤£\n///   inspect(str.unsafe_charcode_at(2), content=\"56611\") // Second surrogate of ğŸ¤£\n///   inspect(str.unsafe_charcode_at(3), content=\"55358\") // First surrogate of ğŸ¤£\n///   inspect(str.unsafe_charcode_at(4), content=\"56611\") // Second surrogate of ğŸ¤£\n///   inspect(str.unsafe_charcode_at(5), content=\"67\") // 'C'\n/// }\n/// ```\n/// TODO: rename to `unsafe_get`\n#internal(unsafe, \"Panic if index is out of bounds.\")\n#doc(hidden)\npub fn String::unsafe_charcode_at(self : String, idx : Int) -> Int = \"%string.unsafe_get\"\n\n///|\n/// Concatenates two strings, creating a new string that contains all characters\n/// from the first string followed by all characters from the second string.\n///\n/// Parameters:\n///\n/// * `self` : The first string to concatenate.\n/// * `other` : The second string to concatenate.\n///\n/// Returns a new string containing the concatenation of both input strings.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let hello = \"Hello\"\n///   let world = \" World!\"\n///   inspect(hello + world, content=\"Hello World!\")\n///   inspect(\"\" + \"abc\", content=\"abc\") // concatenating with empty string\n/// }\n/// ```\npub impl Add for String with add(self, other) = \"%string_add\"\n\n///|\n/// Tests whether two strings are equal by comparing their characters.\n///\n/// Parameters:\n///\n/// * `self` : The first string to compare.\n/// * `other` : The second string to compare.\n///\n/// Returns `true` if both strings contain exactly the same sequence of\n/// characters, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let str1 = \"hello\"\n///   let str2 = \"hello\"\n///   let str3 = \"world\"\n///   inspect(str1 == str2, content=\"true\")\n///   inspect(str1 == str3, content=\"false\")\n/// }\n/// ```\npub impl Eq for String with equal(self : String, other : String) -> Bool = \"%string_eq\"\n\n///|\n/// Returns the string itself without any modifications. This method is primarily\n/// used to implement the `Show` trait, which requires a `to_string` function.\n///\n/// Parameters:\n///\n/// * `string` : The string value to be returned.\n///\n/// Returns the same string that was passed in.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let s = \"hello\"\n///   inspect(s.to_string(), content=\"hello\")\n/// }\n/// ```\npub fn String::to_string(self : String) -> String = \"%string_to_string\"\n\n// For internal use only\n\n///|\npriv type UnsafeMaybeUninit[_]\n\n///|\n/// Converts a byte value to a 32-bit signed integer. The resulting integer will\n/// have the same binary representation as the byte value, preserving the\n/// numerical value in the range \\[0, 255].\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an integer.\n///\n/// Returns a 32-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_int(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_int(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_int(self : Byte) -> Int = \"%byte_to_int\"\n\n///|\n/// Converts a byte value to a character.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns the character corresponding to the byte value.\npub fn Byte::to_char(self : Byte) -> Char {\n  self.to_int().unsafe_to_char()\n}\n\n///|\n/// Converts a byte value to a 64-bit signed integer by first converting it to a\n/// 32-bit integer and then extending it to a 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 64-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF'\n///   inspect(b.to_int64(), content=\"255\")\n/// }\n/// ```\npub fn Byte::to_int64(self : Byte) -> Int64 {\n  self.to_int().to_int64()\n}\n\n///|\n/// reinterpret the unsigned int as signed int\n/// For number within the range of 0..=2^31-1,\n/// the value is the same. For number within the range of 2^31..=2^32-1,\n/// the value is negative\npub fn UInt::reinterpret_as_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets an unsigned 32-bit integer as a signed 32-bit integer. For\n/// values within the range of 0 to 2^31-1, the value remains the same. For\n/// values within the range of 2^31 to 2^32-1, the value becomes negative due to\n/// two's complement representation.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be reinterpreted.\n///\n/// Returns a signed 32-bit integer that has the same bit pattern as the input\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   inspect(a.reinterpret_as_int(), content=\"42\")\n///   let b = 4294967295U // maximum value of UInt (2^32 - 1)\n///   inspect(b.reinterpret_as_int(), content=\"-1\") // becomes -1 when reinterpreted as Int\n/// }\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_int` instead\")\n#coverage.skip\npub fn UInt::to_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Performs addition between two unsigned 32-bit integers. If the result\n/// overflows, it wraps around according to the rules of modular arithmetic\n/// (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand to be added.\n///\n/// Returns the sum of the two unsigned integers, wrapped around if necessary.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 100U\n///   inspect(a + b, content=\"142\")\n///\n///   // Demonstrate overflow behavior\n///   let max = 4294967295U // UInt::max_value\n///   inspect(max + 1U, content=\"0\")\n/// }\n/// ```\npub impl Add for UInt with add(self, other) = \"%u32.add\"\n\n///|\n/// Performs subtraction between two unsigned 32-bit integers. When the result\n/// would be negative, the function wraps around using modular arithmetic (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer (minuend).\n/// * `other` : The second unsigned 32-bit integer to subtract from the first\n/// (subtrahend).\n///\n/// Returns a new unsigned 32-bit integer representing the difference between the\n/// two numbers. If the result would be negative, it wraps around to a positive\n/// number by adding 2^32 repeatedly until the result is in range.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 5U\n///   let b = 3U\n///   inspect(a - b, content=\"2\")\n///   let c = 3U\n///   let d = 5U\n///   inspect(c - d, content=\"4294967294\") // wraps around to 2^32 - 2\n/// }\n/// ```\npub impl Sub for UInt with sub(self, other) = \"%u32.sub\"\n\n///|\n/// Performs multiplication between two unsigned 32-bit integers. The result\n/// wraps around if it exceeds the maximum value of `UInt`.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand.\n///\n/// Returns the product of the two unsigned integers. If the result exceeds the\n/// maximum value of `UInt` (4294967295), it wraps around to the corresponding\n/// value modulo 2^32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 3U\n///   let b = 4U\n///   inspect(a * b, content=\"12\")\n///   let max = 4294967295U\n///   inspect(max * 2U, content=\"4294967294\") // Wraps around to max * 2 % 2^32\n/// }\n/// ```\npub impl Mul for UInt with mul(self, other) = \"%u32.mul\"\n\n///|\n/// Performs division between two unsigned 32-bit integers. The operation follows\n/// standard unsigned integer division rules, where the result is truncated\n/// towards zero.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number to be divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns an unsigned 32-bit integer representing the quotient of the division.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 5U\n///   inspect(a / b, content=\"8\") // Using infix operator\n/// }\n/// ```\npub impl Div for UInt with div(self, other) = \"%u32.div\"\n\n///|\n/// Calculates the remainder of dividing one unsigned integer by another.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned integer dividend.\n/// * `other` : The unsigned integer divisor.\n///\n/// Returns the remainder of the division operation.\n///\n/// Throws a panic if `other` is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 17U\n///   let b = 5U\n///   inspect(a % b, content=\"2\") // 17 divided by 5 gives quotient 3 and remainder 2\n///   inspect(7U % 4U, content=\"3\")\n/// }\n/// ```\npub impl Mod for UInt with mod(self, other) = \"%u32.mod\"\n\n///|\n/// Compares two unsigned 32-bit integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a == b, content=\"true\")\n///   inspect(a == c, content=\"false\")\n/// }\n/// ```\npub impl Eq for UInt with equal(self : UInt, other : UInt) -> Bool = \"%u32.eq\"\n\n///|\n/// Compares two unsigned 32-bit integers for inequality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if the integers have different values, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 42U\n///   let c = 24U\n///   inspect(a != b, content=\"false\")\n///   inspect(a != c, content=\"true\")\n/// }\n/// ```\npub impl Eq for UInt with not_equal(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn UInt::op_neq(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n/// Compares two unsigned 32-bit integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 42U\n///   let b = 24U\n///   inspect(a.compare(b), content=\"1\") // 42 > 24\n///   inspect(b.compare(a), content=\"-1\") // 24 < 42\n///   inspect(a.compare(a), content=\"0\") // 42 = 42\n/// }\n/// ```\npub impl Compare for UInt with compare(self, other) = \"%u32.compare\"\n\n///|\npub impl Compare for UInt with op_lt(x, y) = \"%u32.lt\"\n\n///|\npub impl Compare for UInt with op_le(x, y) = \"%u32.le\"\n\n///|\npub impl Compare for UInt with op_gt(x, y) = \"%u32.gt\"\n\n///|\npub impl Compare for UInt with op_ge(x, y) = \"%u32.ge\"\n\n///|\n/// Performs a bitwise AND operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if the bits at that position in both\n/// operands are 1, and 0 otherwise.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns an unsigned 32-bit integer representing the result of the bitwise AND\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // 1111_0000_1111_0000\n///   let b = 0xFF00U // 1111_1111_0000_0000\n///   inspect(a & b, content=\"61440\") // 1111_0000_0000_0000 = 61440\n/// }\n/// ```\npub impl BitAnd for UInt with land(self : UInt, other : UInt) -> UInt = \"%u32.bitand\"\n\n///|\n/// Performs a bitwise OR operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if at least one of the corresponding bits\n/// in either operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise OR operation as an unsigned 32-bit integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xF0F0U // Binary: 1111_0000_1111_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a | b, content=\"65535\") // Binary: 1111_1111_1111_1111\n/// }\n/// ```\npub impl BitOr for UInt with lor(self : UInt, other : UInt) -> UInt = \"%u32.bitor\"\n\n///|\n/// Performs a bitwise XOR (exclusive OR) operation between two unsigned 32-bit\n/// integers. Each bit in the result is set to 1 if the corresponding bits in the\n/// operands are different, and 0 if they are the same.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise XOR operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let a = 0xFF00U // Binary: 1111_1111_0000_0000\n///   let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n///   inspect(a ^ b, content=\"61455\") // Binary: 1111_0000_0000_1111\n/// }\n/// ```\npub impl BitXOr for UInt with lxor(self : UInt, other : UInt) -> UInt = \"%u32.bitxor\"\n\n///|\n/// Performs a bitwise NOT operation on an unsigned 32-bit integer. Flips all\n/// bits in the number (changes each 0 to 1 and each 1 to 0).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer value on which to perform the bitwise\n/// NOT operation.\n///\n/// Returns a new unsigned 32-bit integer where each bit is inverted from the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF00U // Binary: 1111_1111_0000_0000\n///   inspect(x.lnot(), content=\"4294902015\") // Binary: ...0000_0000_1111_1111\n/// }\n/// ```\npub fn UInt::lnot(self : UInt) -> UInt = \"%u32.bitnot\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the number to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift the bits. Must be non-negative\n/// and less than 32. Values outside this range are wrapped to fit within it\n/// (i.e., `shift & 31`).\n///\n/// Returns a new `UInt` value representing the result of shifting the bits left\n/// by the specified number of positions. Each position shifted multiplies the\n/// number by 2.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Using the recommended operator\n///   let y = 8U\n///   inspect(y << 1, content=\"16\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::lsl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the integer to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift left. Must be between 0 and 31\n/// inclusive. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new `UInt` value containing the result of the left shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::shl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift on an unsigned 32-bit integer. Each bit in the\n/// input value is shifted right by the specified number of positions, with zeros\n/// shifted in from the left. DEPRECATED: Use the `>>` operator instead.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value representing the result of the logical right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0000000U\n///   inspect(x >> 4, content=\"251658240\") // Using the recommended operator\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::lsr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer by a\n/// specified number of positions. All bits shifted in from the left are zeros.\n///\n/// Parameters:\n///\n/// * `number` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value that represents the result of shifting all bits in\n/// `number` to the right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n/// }\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::shr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Each bit in\n/// the integer is shifted left by the specified number of positions, and zeros\n/// are filled in from the right.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift. Only the least significant 5\n/// bits are used, effectively making the shift count always between 0 and 31.\n///\n/// Returns a new unsigned 32-bit integer that is the result of shifting `self`\n/// left by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 1U\n///   inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n///   let y = 0xFFFFFFFFU\n///   inspect(y << 16, content=\"4294901760\") // All bits after position 16 are discarded\n/// }\n/// ```\npub impl Shl for UInt with shl(self, shift) = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer. The\n/// operation shifts all bits to the right by a specified number of positions,\n/// filling the leftmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. If this value is\n/// negative, the behavior is undefined. Values larger than 31 are masked with `&\n/// 31`.\n///\n/// Returns a new unsigned 32-bit integer containing the result of the right\n/// shift operation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xFF000000U\n///   inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n///   inspect(x >> 24, content=\"255\") // 0x000000FF\n///   let x = 0xFF000000U\n///   inspect(x >> 32, content=\"4278190080\") // Same as x >> 0 due to masking\n/// }\n/// ```\npub impl Shr for UInt with shr(self, shift) = \"%u32.shr\"\n\n///|\n/// Counts the number of leading zero bits in an unsigned 32-bit integer,\n/// starting from the most significant bit.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer whose leading zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros starting from the most significant\n/// bit. For a zero value, returns 32.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   inspect(0U.clz(), content=\"32\")\n///   inspect(1U.clz(), content=\"31\")\n///   inspect(0x80000000U.clz(), content=\"0\")\n/// }\n/// ```\npub fn UInt::clz(self : UInt) -> Int = \"%u32.clz\"\n\n///|\n/// Counts the number of trailing zero bits in an unsigned 32-bit integer,\n/// starting from the least significant bit. For a zero input, returns 32.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose trailing zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros at the least significant end of the\n/// binary representation. Returns 32 if the input is zero.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 24U // Binary: ...011000\n///   inspect(x.ctz(), content=\"3\") // 3 trailing zeros\n///   let y = 0U\n///   inspect(y.ctz(), content=\"32\") // All bits are zero\n/// }\n/// ```\npub fn UInt::ctz(self : UInt) -> Int = \"%u32.ctz\"\n\n///|\n/// Counts the number of 1 bits (population count) in the binary representation\n/// of an unsigned 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be counted.\n///\n/// Returns an integer representing the count of set bits (1s) in the binary\n/// representation.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = 0xF0F0U // Binary: 1111 0000 1111 0000\n///   inspect(x.popcnt(), content=\"8\") // Has 8 bits set to 1\n/// }\n/// ```\npub fn UInt::popcnt(self : UInt) -> Int = \"%u32.popcnt\"\n\n///|\n/// Converts an unsigned 32-bit integer to an unsigned 64-bit integer by\n/// zero-extending it. The resulting value preserves the original number's\n/// magnitude while using 64 bits to represent it.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer (`UInt`) to be converted.\n///\n/// Returns an unsigned 64-bit integer (`UInt64`) representing the same numerical\n/// value as the input.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint64(), content=\"42\")\n///   let max = 4294967295U // Maximum value of UInt\n///   inspect(max.to_uint64(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_uint64(self : UInt) -> UInt64 {\n  UInt64::extend_uint(self)\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a byte by taking its least significant\n/// 8 bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 258U // In binary: 100000010\n///   inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n///   let big = 4294967295U // Maximum value of UInt\n///   inspect(big.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// }\n/// ```\npub fn UInt::to_byte(self : UInt) -> Byte {\n  self.reinterpret_as_int().to_byte()\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_double(), content=\"42\")\n///   let max = 4294967295U // maximum value of UInt\n///   inspect(max.to_double(), content=\"4294967295\")\n/// }\n/// ```\npub fn UInt::to_double(self : UInt) -> Double = \"%u32.to_f64\"\n\n///|\n#deprecated(\"Use `Float::from_int` instead\")\npub fn Int::to_float(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_int` instead\")\npub fn Int::reinterpret_as_float(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_uint` instead\")\npub fn UInt::reinterpret_as_float(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::from_byte` instead\")\npub fn Byte::to_float(self : Byte) -> Float = \"%byte.to_f32\"\n\n///|\n/// TODO: use intrinsics implement this\npub fn Byte::to_double(self : Byte) -> Double {\n  self.to_int().to_double()\n}\n\n///|\n/// TODO: enable skip_current_package=false\n#deprecated(\"Use `Float::from_double` instead\", skip_current_package=true)\npub fn Double::to_float(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n#deprecated(\"Use `Float::from_uint` instead\")\npub fn UInt::to_float(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n#deprecated(\"Use `Int16::from_int` instead\")\npub fn Int::to_int16(self : Int) -> Int16 = \"%i32_to_i16\"\n\n///|\n/// Converts a byte value to a 16-bit signed integer. The byte value is\n/// sign-extended to 16 bits during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an `Int16`.\n///\n/// Returns a 16-bit signed integer representing the same value as the input\n/// byte.\n#deprecated(\"Use `Int16::from_byte` instead\")\npub fn Byte::to_int16(self : Byte) -> Int16 = \"%byte_to_i16\"\n\n///|\n/// Converts an unsigned 16-bit integer to a 32-bit signed integer. The value is\n/// zero-extended to fill the higher bits.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 16-bit integer to be converted.\n///\n/// Returns a 32-bit signed integer. Since the input value is always non-negative\n/// and less than 65536, the conversion never results in overflow.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(42)\n///   inspect(x.to_int(), content=\"42\")\n///   let max = Int::to_uint16(65535) // maximum value of UInt16\n///   inspect(max.to_int(), content=\"65535\")\n/// }\n/// ```\npub fn UInt16::to_int(self : UInt16) -> Int = \"%u16_to_i32\"\n\n///|\n/// Converts a 16-bit unsigned integer to an 8-bit byte by truncating the higher\n/// bits.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit unsigned integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let x = Int::to_uint16(258) // Binary: 0000_0001_0000_0010\n///   inspect(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// }\n/// ```\npub fn UInt16::to_byte(self : UInt16) -> Byte = \"%u16_to_byte\"\n\n///|\n/// Converts a 32-bit unsigned integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit unsigned integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42U\n///   inspect(n.to_uint16(), content=\"42\")\n///   let max = 4294967295U\n///   inspect(max.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536U\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn UInt::to_uint16(self : UInt) -> UInt16 {\n  self.reinterpret_as_int().to_uint16()\n}\n\n///|\n/// Converts a 32-bit signed integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit signed integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let n = 42\n///   inspect(n.to_uint16(), content=\"42\")\n///   let neg = -1\n///   inspect(neg.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n///   let large = 65536\n///   inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// }\n/// ```\npub fn Int::to_uint16(self : Int) -> UInt16 = \"%i32_to_u16\"\n\n///|\n/// Converts a byte value to a 16-bit unsigned integer by zero-extending it.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 16-bit unsigned integer (`UInt16`) representing the same value as\n/// the input byte.\n///\n/// Example:\n///\n/// ```mbt check\n/// test {\n///   let b = b'\\xFF' // byte with value 255\n///   inspect(b.to_uint16(), content=\"255\")\n///   let zero = b'\\x00'\n///   inspect(zero.to_uint16(), content=\"0\")\n/// }\n/// ```\npub fn Byte::to_uint16(self : Byte) -> UInt16 = \"%byte_to_u16\"\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct UninitializedArray[T](FixedArray[UnsafeMaybeUninit[T]])\n\n///|\n/// Creates an uninitialized array of the specified size.\n///\n/// Parameters:\n///\n/// - `size` : The number of elements the array should hold.\n///\n/// Returns an uninitialized array of type `T` with the specified size.\npub fn[T] UninitializedArray::make(size : Int) -> UninitializedArray[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Retrieves the element at the specified index from an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array from which to retrieve the element.\n/// - `index` : The index of the element to retrieve.\n///\n/// Returns the element at the specified index.\n#alias(\"_[_]\")\npub fn[T] UninitializedArray::at(\n  self : UninitializedArray[T],\n  index : Int,\n) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets the value at the specified index in an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array where the value will be set.\n/// - `index` : The position in the array where the value will be set.\n/// - `value` : The value to be set at the specified index.\n#alias(\"_[_]=_\")\npub fn[T] UninitializedArray::set(\n  self : UninitializedArray[T],\n  index : Int,\n  value : T,\n) = \"%fixedarray.set\"\n\n///|\n/// Creates a view into a portion of the uninitialized array.\n///\n/// Parameters:\n///\n/// * `array` : The uninitialized array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws an error if the indices are out of bounds or if `start` is greater\n/// than `end`.\n#alias(\"_[_:_]\")\npub fn[T] UninitializedArray::sub(\n  self : UninitializedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => end\n  }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View start index out of bounds\")\n  }\n  ArrayView::make(self, start, end - start)\n}\n\n///|\n/// Returns the length of an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array whose length is to be determined.\n///\n/// Returns the length of the uninitialized array as an integer.\npub fn[A] UninitializedArray::length(self : UninitializedArray[A]) -> Int {\n  self.0.length()\n}\n\n///|\n#internal(unsafe, \"For internal use only.\")\n#doc(hidden)\npub fn[T] UninitializedArray::unsafe_blit(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : UninitializedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(dst.0, dst_offset, src.0, src_offset, len)\n}\n\n///|\ntest \"as_view with valid_range\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  let view = arr[1:4]\n  inspect(view.start(), content=\"1\")\n  inspect(view.len(), content=\"3\")\n}\n\n///|\ntest \"panic as_view with invalid_start\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[-1:])\n}\n\n///|\ntest \"panic as_view with invalid_end\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[2:10])\n}\n\n///|\n#coverage.skip\n#intrinsic(\"%fixedarray.fill\")\n#cfg(not(target=\"js\"))\nfn[T] UninitializedArray::unchecked_fill(\n  self : UninitializedArray[T],\n  start : Int,\n  value : T,\n  len : Int,\n) -> Unit {\n  for i in start..<(start + len) {\n    self[i] = value\n  }\n}\n","// Copyright 2026 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(not(target=\"native\"))\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\n#cfg(target=\"native\")\nfn println(s : String) -> Unit = \"%println\"\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(target=\"native\")\npub fn[T] abort(msg : String) -> T {\n  println(msg)\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n"],"mappings":"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"}