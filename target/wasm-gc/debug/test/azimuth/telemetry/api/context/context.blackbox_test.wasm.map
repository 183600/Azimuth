{"version":3,"sources":["/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/__generated_driver_for_blackbox_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/baggage_edge_cases_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/context_advanced_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/context_basic_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/context_boundary_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/context_edge_cases_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/context_key_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/context_test.mbt","/home/runner/work/Azimuth/Azimuth/src/azimuth/telemetry/api/context/context.mbt","/home/runner/.moon/lib/core/test/test.mbt","/home/runner/.moon/lib/core/builtin/array.mbt","/home/runner/.moon/lib/core/builtin/autoloc.mbt","/home/runner/.moon/lib/core/builtin/console.mbt","/home/runner/.moon/lib/core/builtin/hasher.mbt","/home/runner/.moon/lib/core/builtin/linked_hash_map.mbt","/home/runner/.moon/lib/core/builtin/int.mbt","/home/runner/.moon/lib/core/builtin/option.mbt","/home/runner/.moon/lib/core/builtin/show.mbt","/home/runner/.moon/lib/core/builtin/string_methods.mbt","/home/runner/.moon/lib/core/builtin/arraycore_nonjs.mbt","/home/runner/.moon/lib/core/builtin/stringbuilder_buffer.mbt","/home/runner/.moon/lib/core/builtin/string.mbt","/home/runner/.moon/lib/core/builtin/byte.mbt","/home/runner/.moon/lib/core/builtin/assert.mbt","/home/runner/.moon/lib/core/builtin/failure.mbt","/home/runner/.moon/lib/core/builtin/to_string.mbt","/home/runner/.moon/lib/core/builtin/traits.mbt","/home/runner/.moon/lib/core/builtin/stringview.mbt","/home/runner/.moon/lib/core/builtin/bytes.mbt","/home/runner/.moon/lib/core/builtin/op.mbt","/home/runner/.moon/lib/core/builtin/intrinsics.mbt","/home/runner/.moon/lib/core/builtin/uninitialized_array.mbt","/home/runner/.moon/lib/core/abort/abort.mbt"],"sourcesContent":[null,"test \"baggage_edge_cases\" {\n  // æµ‹è¯•Baggageçš„è¾¹ç•Œæƒ…å†µ\n  \n  let empty_baggage = Baggage::empty()\n  \n  // æµ‹è¯•ç©ºBaggageçš„æ“ä½œ\n  match empty_baggage.get(\"non.existent\") {\n    Some(_) => @test.fail(\"Expected None for empty baggage\")\n    None => assert_eq(true, true)\n  }\n  \n  // æµ‹è¯•å¤§å€¼\n  let large_value = \"è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„å€¼ï¼Œç”¨æ¥æµ‹è¯•Baggageåœ¨å¤„ç†å¤§å€¼æ—¶çš„è¡Œä¸ºã€‚\".repeat(50)\n  let baggage_with_large = empty_baggage.with_entry(\"large.key\", large_value)\n  \n  match baggage_with_large.get(\"large.key\") {\n    Some(value) => assert_eq(value.length(), large_value.length())\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼\n  let special_key = \"special.key!@#$%^&*()\"\n  let special_value = \"special_value!@#$%^&*()\"\n  let baggage_with_special = empty_baggage.with_entry(special_key, special_value)\n  \n  match baggage_with_special.get(special_key) {\n    Some(value) => assert_eq(value, special_value)\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•Unicodeé”®å’Œå€¼\n  let unicode_key = \"æµ‹è¯•é”®ğŸš€\"\n  let unicode_value = \"æµ‹è¯•å€¼ğŸ‰\"\n  let baggage_with_unicode = empty_baggage.with_entry(unicode_key, unicode_value)\n  \n  match baggage_with_unicode.get(unicode_key) {\n    Some(value) => assert_eq(value, unicode_value)\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•è¦†ç›–å€¼\n  let baggage1 = empty_baggage.with_entry(\"test.key\", \"value1\")\n  let baggage2 = baggage1.with_entry(\"test.key\", \"value2\")\n  \n  match baggage2.get(\"test.key\") {\n    Some(value) => assert_eq(value, \"value2\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼\n  let baggage_empty_key = empty_baggage.with_entry(\"\", \"empty.key.value\")\n  match baggage_empty_key.get(\"\") {\n    Some(value) => assert_eq(value, \"empty.key.value\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  let baggage_empty_value = empty_baggage.with_entry(\"empty.value.key\", \"\")\n  match baggage_empty_value.get(\"empty.value.key\") {\n    Some(value) => assert_eq(value, \"\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„é”®å’Œå€¼\n  let baggage_spaces = empty_baggage.with_entry(\"key with spaces\", \"value with spaces\")\n  match baggage_spaces.get(\"key with spaces\") {\n    Some(value) => assert_eq(value, \"value with spaces\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•æ•°å­—é”®ï¼ˆè™½ç„¶ç±»å‹æ˜¯Stringï¼Œä½†å¯ä»¥åŒ…å«æ•°å­—ï¼‰\n  let baggage_numeric_key = empty_baggage.with_entry(\"123\", \"numeric.key.value\")\n  match baggage_numeric_key.get(\"123\") {\n    Some(value) => assert_eq(value, \"numeric.key.value\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•å¤§é‡æ¡ç›®\n  let mut baggage_multi = empty_baggage\n  let mut i = 0\n  while i < 30 {\n    baggage_multi = baggage_multi.with_entry(\"key.\" + i.to_string(), \"value.\" + i.to_string())\n    i = i + 1\n  }\n  \n  // éªŒè¯ä¸€äº›æ¡ç›®\n  match baggage_multi.get(\"key.0\") {\n    Some(value) => assert_eq(value, \"value.0\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match baggage_multi.get(\"key.29\") {\n    Some(value) => assert_eq(value, \"value.29\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match baggage_multi.get(\"key.30\") {\n    Some(_) => @test.fail(\"Expected None for non-existent key\")\n    None => assert_eq(true, true)\n  }\n  \n  // æµ‹è¯•åŒ…å«ç‰¹æ®ŠHTTPå¤´çš„é”®å€¼å¯¹\n  let baggage_headers = empty_baggage\n    .with_entry(\"user-id\", \"12345\")\n    .with_entry(\"session-id\", \"abcdef123456\")\n    .with_entry(\"request-id\", \"req-789\")\n    .with_entry(\"trace-id\", \"trace-abc123\")\n    .with_entry(\"correlation-id\", \"corr-def456\")\n  \n  match baggage_headers.get(\"user-id\") {\n    Some(value) => assert_eq(value, \"12345\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match baggage_headers.get(\"correlation-id\") {\n    Some(value) => assert_eq(value, \"corr-def456\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n}","// Contextæ¨¡å—é«˜çº§æµ‹è¯•ç”¨ä¾‹\n\ntest \"context_complex_interactions\" {\n  // æµ‹è¯•Contextçš„å¤æ‚äº¤äº’\n  \n  let base_ctx = Context::empty()\n  \n  // åˆ›å»ºå¤šä¸ªkeys\n  let user_key = create_key(\"user.id\")\n  let session_key = create_key(\"session.id\")\n  let request_key = create_key(\"request.id\")\n  let trace_key = create_key(\"trace.id\")\n  let auth_key = create_key(\"auth.token\")\n  let locale_key = create_key(\"user.locale\")\n  let timezone_key = create_key(\"user.timezone\")\n  let feature_key = create_key(\"feature.flags\")\n  \n  // é€æ­¥æ·»åŠ contextå€¼\n  let ctx_with_user = base_ctx.with_value(user_key, \"user-12345\")\n  let ctx_with_session = ctx_with_user.with_value(session_key, \"session-abcdef\")\n  let ctx_with_request = ctx_with_session.with_value(request_key, \"req-789012\")\n  let ctx_with_trace = ctx_with_request.with_value(trace_key, \"trace-fedcba\")\n  let ctx_with_auth = ctx_with_trace.with_value(auth_key, \"bearer-token-xyz\")\n  let ctx_with_locale = ctx_with_auth.with_value(locale_key, \"zh-CN\")\n  let ctx_with_timezone = ctx_with_locale.with_value(timezone_key, \"Asia/Shanghai\")\n  let ctx_with_feature = ctx_with_timezone.with_value(feature_key, \"new-ui-enabled,experimental-api\")\n  \n  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨\n  match ctx_with_feature.get(user_key) {\n    Some(user_id) => assert_eq(user_id, \"user-12345\")\n    None => @test.fail(\"Expected user.id\")\n  }\n  \n  match ctx_with_feature.get(session_key) {\n    Some(session_id) => assert_eq(session_id, \"session-abcdef\")\n    None => @test.fail(\"Expected session.id\")\n  }\n  \n  match ctx_with_feature.get(request_key) {\n    Some(request_id) => assert_eq(request_id, \"req-789012\")\n    None => @test.fail(\"Expected request.id\")\n  }\n  \n  match ctx_with_feature.get(trace_key) {\n    Some(trace_id) => assert_eq(trace_id, \"trace-fedcba\")\n    None => @test.fail(\"Expected trace.id\")\n  }\n  \n  match ctx_with_feature.get(auth_key) {\n    Some(auth_token) => assert_eq(auth_token, \"bearer-token-xyz\")\n    None => @test.fail(\"Expected auth.token\")\n  }\n  \n  match ctx_with_feature.get(locale_key) {\n    Some(locale) => assert_eq(locale, \"zh-CN\")\n    None => @test.fail(\"Expected user.locale\")\n  }\n  \n  match ctx_with_feature.get(timezone_key) {\n    Some(timezone) => assert_eq(timezone, \"Asia/Shanghai\")\n    None => @test.fail(\"Expected user.timezone\")\n  }\n  \n  match ctx_with_feature.get(feature_key) {\n    Some(features) => {\n      assert_eq(features.contains(\"new-ui-enabled\"), true)\n      assert_eq(features.contains(\"experimental-api\"), true)\n    }\n    None => @test.fail(\"Expected feature.flags\")\n  }\n  \n  // éªŒè¯contextä¸­çš„valuesæ•°é‡\n  assert_eq(ctx_with_feature.values.length(), 8)\n  \n  // éªŒè¯ä¸å­˜åœ¨çš„key\n  let non_existent_key = create_key(\"non.existent.key\")\n  match ctx_with_feature.get(non_existent_key) {\n    Some(_) => @test.fail(\"Expected None for non-existent key\")\n    None => assert_eq(true, true)  // æœŸæœ›None\n  }\n}\n\ntest \"context_and_baggage_integration\" {\n  // æµ‹è¯•Contextå’ŒBaggageçš„é›†æˆ\n  \n  let base_ctx = Context::empty()\n  let base_baggage = Baggage::empty()\n  \n  // åœ¨Contextä¸­æ·»åŠ å€¼\n  let ctx_key1 = create_key(\"ctx.key1\")\n  let ctx_key2 = create_key(\"ctx.key2\")\n  let ctx_key3 = create_key(\"ctx.key3\")\n  \n  let enriched_ctx = base_ctx\n    .with_value(ctx_key1, \"context-value-1\")\n    .with_value(ctx_key2, \"context-value-2\")\n    .with_value(ctx_key3, \"context-value-3\")\n  \n  // åœ¨Baggageä¸­æ·»åŠ å€¼\n  let enriched_baggage = base_baggage\n    .with_entry(\"baggage.key1\", \"baggage-value-1\")\n    .with_entry(\"baggage.key2\", \"baggage-value-2\")\n    .with_entry(\"baggage.key3\", \"baggage-value-3\")\n    .with_entry(\"user.id\", \"user-from-baggage\")\n    .with_entry(\"session.id\", \"session-from-baggage\")\n  \n  // éªŒè¯Contextä¸­çš„å€¼\n  match enriched_ctx.get(ctx_key1) {\n    Some(value) => assert_eq(value, \"context-value-1\")\n    None => @test.fail(\"Expected ctx.key1\")\n  }\n  \n  match enriched_ctx.get(ctx_key2) {\n    Some(value) => assert_eq(value, \"context-value-2\")\n    None => @test.fail(\"Expected ctx.key2\")\n  }\n  \n  match enriched_ctx.get(ctx_key3) {\n    Some(value) => assert_eq(value, \"context-value-3\")\n    None => @test.fail(\"Expected ctx.key3\")\n  }\n  \n  // éªŒè¯Baggageä¸­çš„å€¼\n  match enriched_baggage.get(\"baggage.key1\") {\n    Some(value) => assert_eq(value, \"baggage-value-1\")\n    None => @test.fail(\"Expected baggage.key1\")\n  }\n  \n  match enriched_baggage.get(\"baggage.key2\") {\n    Some(value) => assert_eq(value, \"baggage-value-2\")\n    None => @test.fail(\"Expected baggage.key2\")\n  }\n  \n  match enriched_baggage.get(\"baggage.key3\") {\n    Some(value) => assert_eq(value, \"baggage-value-3\")\n    None => @test.fail(\"Expected baggage.key3\")\n  }\n  \n  match enriched_baggage.get(\"user.id\") {\n    Some(user_id) => assert_eq(user_id, \"user-from-baggage\")\n    None => @test.fail(\"Expected user.id from baggage\")\n  }\n  \n  match enriched_baggage.get(\"session.id\") {\n    Some(session_id) => assert_eq(session_id, \"session-from-baggage\")\n    None => @test.fail(\"Expected session.id from baggage\")\n  }\n  \n  // éªŒè¯æ•°é‡\n  assert_eq(enriched_ctx.values.length(), 3)\n  assert_eq(enriched_baggage.entries.length(), 5)\n  \n  // æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼šç©ºå€¼å’Œç‰¹æ®Šå­—ç¬¦\n  let special_ctx = base_ctx\n    .with_value(create_key(\"empty.value\"), \"\")\n    .with_value(create_key(\"special.chars\"), \"!@#$%^&*()_+-=[]{}|;':\\\",./<>?\")\n    .with_value(create_key(\"unicode.value\"), \"Unicodeæµ‹è¯•ğŸš€ğŸŒŸğŸ’«\")\n    .with_value(create_key(\"multi.line\"), \"line1\\nline2\\nline3\")\n    .with_value(create_key(\"spaces\"), \"   leading and trailing   \")\n  \n  // éªŒè¯ç‰¹æ®Šå€¼\n  match special_ctx.get(create_key(\"empty.value\")) {\n    Some(value) => assert_eq(value, \"\")\n    None => @test.fail(\"Expected empty value\")\n  }\n  \n  match special_ctx.get(create_key(\"special.chars\")) {\n    Some(value) => assert_eq(value.contains(\"!@#$%^&*()\"), true)\n    None => @test.fail(\"Expected special chars\")\n  }\n  \n  match special_ctx.get(create_key(\"unicode.value\")) {\n    Some(value) => {\n      assert_eq(value.contains(\"æµ‹è¯•\"), true)\n      assert_eq(value.contains(\"ğŸš€\"), true)\n    }\n    None => @test.fail(\"Expected unicode value\")\n  }\n  \n  match special_ctx.get(create_key(\"multi.line\")) {\n    Some(value) => {\n      assert_eq(value.contains(\"line1\"), true)\n      assert_eq(value.contains(\"line2\"), true)\n      assert_eq(value.contains(\"line3\"), true)\n      assert_eq(value.contains(\"\\n\"), true)\n    }\n    None => @test.fail(\"Expected multi-line value\")\n  }\n  \n  // æµ‹è¯•Baggageçš„ç‰¹æ®Šå€¼\n  let special_baggage = base_baggage\n    .with_entry(\"empty.baggage\", \"\")\n    .with_entry(\"special.baggage\", \"special=!@#$%^&*()\")\n    .with_entry(\"unicode.baggage\", \"æµ‹è¯•=ğŸš€ğŸŒŸ\")\n    .with_entry(\"complex.baggage\", \"key1=value1;prop1=val1,key2=value2\")\n  \n  match special_baggage.get(\"empty.baggage\") {\n    Some(value) => assert_eq(value, \"\")\n    None => @test.fail(\"Expected empty baggage\")\n  }\n  \n  match special_baggage.get(\"special.baggage\") {\n    Some(value) => assert_eq(value.contains(\"!@#$%^&*()\"), true)\n    None => @test.fail(\"Expected special baggage\")\n  }\n  \n  match special_baggage.get(\"unicode.baggage\") {\n    Some(value) => {\n      assert_eq(value.contains(\"æµ‹è¯•\"), true)\n      assert_eq(value.contains(\"ğŸš€\"), true)\n    }\n    None => @test.fail(\"Expected unicode baggage\")\n  }\n}","// Contextæ¨¡å—åŸºæœ¬æµ‹è¯•ç”¨ä¾‹\ntest \"context_basic_operations\" {\n  let ctx = Context::empty()\n  let key = create_key(\"test_key\")\n  let ctx_with_value = ctx.with_value(key, \"test_value\")\n  \n  let retrieved_value = ctx_with_value.get(key)\n  match retrieved_value {\n    Some(value) => assert_eq(value, \"test_value\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®\n  let non_existent_key = create_key(\"non_existent\")\n  let non_existent_value = ctx_with_value.get(non_existent_key)\n  match non_existent_value {\n    Some(_) => @test.fail(\"Expected None\")\n    None => assert_eq(true, true)\n  }\n}\n\ntest \"baggage_basic_operations\" {\n  let baggage = Baggage::empty()\n  let baggage_with_entry = baggage.with_entry(\"test_key\", \"test_value\")\n  \n  let retrieved_value = baggage_with_entry.get(\"test_key\")\n  match retrieved_value {\n    Some(value) => assert_eq(value, \"test_value\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®\n  let non_existent_value = baggage_with_entry.get(\"non_existent\")\n  match non_existent_value {\n    Some(_) => @test.fail(\"Expected None\")\n    None => assert_eq(true, true)\n  }\n}\n\ntest \"context_key_creation\" {\n  let key1 = create_key(\"key1\")\n  let key2 = create_key(\"key2\")\n  \n  assert_eq(key1.name, \"key1\")\n  assert_eq(key2.name, \"key2\")\n  if key1.name == key2.name {\n    @test.fail(\"Expected key1.name != key2.name\")\n  }\n}\n\ntest \"context_multiple_values_and_overwrites\" {\n  let ctx = Context::empty()\n  let key1 = create_key(\"user.id\")\n  let key2 = create_key(\"request.id\")\n  let key3 = create_key(\"session.token\")\n  \n  // æ·»åŠ å¤šä¸ªå€¼\n  let ctx1 = ctx.with_value(key1, \"user-123\")\n  let ctx2 = ctx1.with_value(key2, \"req-456\")\n  let ctx3 = ctx2.with_value(key3, \"token-abc\")\n  \n  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨\n  match ctx3.get(key1) {\n    Some(value) => assert_eq(value, \"user-123\")\n    None => @test.fail(\"Expected Some(value) for user.id\")\n  }\n  \n  match ctx3.get(key2) {\n    Some(value) => assert_eq(value, \"req-456\")\n    None => @test.fail(\"Expected Some(value) for request.id\")\n  }\n  \n  match ctx3.get(key3) {\n    Some(value) => assert_eq(value, \"token-abc\")\n    None => @test.fail(\"Expected Some(value) for session.token\")\n  }\n  \n  // æµ‹è¯•è¦†ç›–ç°æœ‰å€¼\n  let ctx4 = ctx3.with_value(key1, \"user-789\")\n  match ctx4.get(key1) {\n    Some(value) => assert_eq(value, \"user-789\")\n    None => @test.fail(\"Expected Some(value) for updated user.id\")\n  }\n  \n  // éªŒè¯å…¶ä»–å€¼ä¸å—å½±å“\n  match ctx4.get(key2) {\n    Some(value) => assert_eq(value, \"req-456\")\n    None => @test.fail(\"Expected Some(value) for request.id\")\n  }\n}\n\ntest \"context_empty_and_special_values\" {\n  let ctx = Context::empty()\n  let empty_key = create_key(\"empty.value\")\n  let special_key = create_key(\"special.value\")\n  \n  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼\n  let ctx_with_empty = ctx.with_value(empty_key, \"\")\n  match ctx_with_empty.get(empty_key) {\n    Some(value) => assert_eq(value, \"\")\n    None => @test.fail(\"Expected Some(empty string)\")\n  }\n  \n  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å€¼\n  let special_value = \"special!@#$%^&*()_+-={}[]|\\\\:;\\\"'<>?,./\"\n  let ctx_with_special = ctx_with_empty.with_value(special_key, special_value)\n  match ctx_with_special.get(special_key) {\n    Some(value) => assert_eq(value, special_value)\n    None => @test.fail(\"Expected Some(special string)\")\n  }\n  \n  // æµ‹è¯•é•¿å­—ç¬¦ä¸²å€¼\n  let long_value = \"This is a very long string that contains many words and characters to test if the context can handle long values properly without any issues or truncation or other problems that might occur with string handling in the implementation.\"\n  let long_key = create_key(\"long.value\")\n  let ctx_with_long = ctx_with_special.with_value(long_key, long_value)\n  match ctx_with_long.get(long_key) {\n    Some(value) => assert_eq(value, long_value)\n    None => @test.fail(\"Expected Some(long string)\")\n  }\n}\n\ntest \"baggage_multiple_entries_and_overwrites\" {\n  let baggage = Baggage::empty()\n  \n  // æ·»åŠ å¤šä¸ªæ¡ç›®\n  let baggage1 = baggage.with_entry(\"user.id\", \"12345\")\n  let baggage2 = baggage1.with_entry(\"request.id\", \"67890\")\n  let baggage3 = baggage2.with_entry(\"session.id\", \"abcdef\")\n  let baggage4 = baggage3.with_entry(\"trace.id\", \"1234567890\")\n  \n  // éªŒè¯æ‰€æœ‰æ¡ç›®éƒ½å­˜åœ¨\n  match baggage4.get(\"user.id\") {\n    Some(value) => assert_eq(value, \"12345\")\n    None => @test.fail(\"Expected Some(value) for user.id\")\n  }\n  \n  match baggage4.get(\"request.id\") {\n    Some(value) => assert_eq(value, \"67890\")\n    None => @test.fail(\"Expected Some(value) for request.id\")\n  }\n  \n  match baggage4.get(\"session.id\") {\n    Some(value) => assert_eq(value, \"abcdef\")\n    None => @test.fail(\"Expected Some(value) for session.id\")\n  }\n  \n  match baggage4.get(\"trace.id\") {\n    Some(value) => assert_eq(value, \"1234567890\")\n    None => @test.fail(\"Expected Some(value) for trace.id\")\n  }\n  \n  // æµ‹è¯•è¦†ç›–ç°æœ‰æ¡ç›®\n  let baggage5 = baggage4.with_entry(\"user.id\", \"54321\")\n  match baggage5.get(\"user.id\") {\n    Some(value) => assert_eq(value, \"54321\")\n    None => @test.fail(\"Expected Some(value) for updated user.id\")\n  }\n  \n  // éªŒè¯å…¶ä»–æ¡ç›®ä¸å—å½±å“\n  match baggage5.get(\"request.id\") {\n    Some(value) => assert_eq(value, \"67890\")\n    None => @test.fail(\"Expected Some(value) for request.id\")\n  }\n}\n\ntest \"context_and_baggage_integration\" {\n  let ctx = Context::empty()\n  let baggage = Baggage::empty()\n  \n  // åœ¨contextä¸­æ·»åŠ å€¼\n  let trace_key = create_key(\"trace.id\")\n  let span_key = create_key(\"span.id\")\n  let ctx_with_values = ctx\n    .with_value(trace_key, \"trace-123\")\n    .with_value(span_key, \"span-456\")\n  \n  // åœ¨baggageä¸­æ·»åŠ ç›¸å…³å€¼\n  let baggage_with_entries = baggage\n    .with_entry(\"user.id\", \"user-789\")\n    .with_entry(\"correlation.id\", \"corr-012\")\n  \n  // éªŒè¯contextå’Œbaggageä¸­çš„å€¼\n  match ctx_with_values.get(trace_key) {\n    Some(value) => assert_eq(value, \"trace-123\")\n    None => @test.fail(\"Expected Some(value) for trace.id\")\n  }\n  \n  match ctx_with_values.get(span_key) {\n    Some(value) => assert_eq(value, \"span-456\")\n    None => @test.fail(\"Expected Some(value) for span.id\")\n  }\n  \n  match baggage_with_entries.get(\"user.id\") {\n    Some(value) => assert_eq(value, \"user-789\")\n    None => @test.fail(\"Expected Some(value) for user.id\")\n  }\n  \n  match baggage_with_entries.get(\"correlation.id\") {\n    Some(value) => assert_eq(value, \"corr-012\")\n    None => @test.fail(\"Expected Some(value) for correlation.id\")\n  }\n  \n  // æµ‹è¯•ç©ºå€¼å’Œç‰¹æ®Šé”®å\n  let special_ctx = ctx_with_values\n    .with_value(create_key(\"\"), \"empty.key.value\")\n    .with_value(create_key(\"special.key.with.dots\"), \"special.value\")\n    .with_value(create_key(\"key with spaces\"), \"spaces.value\")\n  \n  match special_ctx.get(create_key(\"\")) {\n    Some(value) => assert_eq(value, \"empty.key.value\")\n    None => @test.fail(\"Expected Some(value) for empty key\")\n  }\n  \n  let special_baggage = baggage_with_entries\n    .with_entry(\"\", \"empty.entry.value\")\n    .with_entry(\"special.entry.with.dots\", \"special.entry.value\")\n    .with_entry(\"entry with spaces\", \"spaces.entry.value\")\n  \n  match special_baggage.get(\"\") {\n    Some(value) => assert_eq(value, \"empty.entry.value\")\n    None => @test.fail(\"Expected Some(value) for empty entry\")\n  }\n}","test \"context_with_nested_values\" {\n  // æµ‹è¯•åµŒå¥—Contextå€¼çš„ç®¡ç†\n  \n  let base_ctx = Context::empty()\n  let key1 = create_key(\"level1\")\n  let key2 = create_key(\"level2\")\n  let key3 = create_key(\"level3\")\n  let key4 = create_key(\"level4\")\n  \n  // åˆ›å»ºå¤šå±‚åµŒå¥—çš„context\n  let ctx1 = base_ctx.with_value(key1, \"value1\")\n  let ctx2 = ctx1.with_value(key2, \"value2\")\n  let ctx3 = ctx2.with_value(key3, \"value3\")\n  let ctx4 = ctx3.with_value(key4, \"value4\")\n  \n  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨\n  match ctx4.get(key1) {\n    Some(value) => assert_eq(value, \"value1\")\n    None => @test.fail(\"Expected Some(value1)\")\n  }\n  \n  match ctx4.get(key2) {\n    Some(value) => assert_eq(value, \"value2\")\n    None => @test.fail(\"Expected Some(value2)\")\n  }\n  \n  match ctx4.get(key3) {\n    Some(value) => assert_eq(value, \"value3\")\n    None => @test.fail(\"Expected Some(value3)\")\n  }\n  \n  match ctx4.get(key4) {\n    Some(value) => assert_eq(value, \"value4\")\n    None => @test.fail(\"Expected Some(value4)\")\n  }\n  \n  // éªŒè¯åŸå§‹contextä¸å—å½±å“\n  match base_ctx.get(key1) {\n    Some(_) => @test.fail(\"Expected None\")\n    None => assert_eq(true, true)\n  }\n}\n\ntest \"baggage_with_complex_values\" {\n  // æµ‹è¯•Baggageçš„å¤æ‚å€¼å¤„ç†\n  \n  let baggage = Baggage::empty()\n  \n  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å€¼\n  let baggage1 = baggage.with_entry(\"special.chars\", \"!@#$%^&*()\")\n  let baggage2 = baggage1.with_entry(\"unicode.value\", \"æµ‹è¯•ä¸­æ–‡ğŸš€\")\n  let baggage3 = baggage2.with_entry(\"url.encoded\", \"hello%20world\")\n  let baggage4 = baggage3.with_entry(\"empty.value\", \"\")\n  let baggage5 = baggage4.with_entry(\"spaces\", \"   leading and trailing   \")\n  \n  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å€¼\n  match baggage5.get(\"special.chars\") {\n    Some(value) => assert_eq(value, \"!@#$%^&*()\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // éªŒè¯Unicodeå€¼\n  match baggage5.get(\"unicode.value\") {\n    Some(value) => {\n      assert_eq(value.contains(\"æµ‹è¯•\"), true)\n      assert_eq(value.contains(\"ğŸš€\"), true)\n    }\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // éªŒè¯ç©ºå€¼\n  match baggage5.get(\"empty.value\") {\n    Some(value) => assert_eq(value, \"\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // éªŒè¯åŒ…å«ç©ºæ ¼çš„å€¼\n  match baggage5.get(\"spaces\") {\n    Some(value) => assert_eq(value, \"   leading and trailing   \")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n}","test \"context_edge_cases\" {\n  // æµ‹è¯•Contextçš„è¾¹ç•Œæƒ…å†µ\n  \n  // æµ‹è¯•ç©ºContext\n  let empty_ctx = Context::empty()\n  let empty_key = create_key(\"\")\n  \n  match empty_ctx.get(empty_key) {\n    Some(_) => @test.fail(\"Expected None for empty context\")\n    None => assert_eq(true, true)\n  }\n  \n  // æµ‹è¯•å¤§å€¼\n  let large_value = \"è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„å€¼ï¼Œç”¨æ¥æµ‹è¯•Contextåœ¨å¤„ç†å¤§å€¼æ—¶çš„è¡Œä¸ºã€‚\".repeat(100)\n  let ctx_with_large = empty_ctx.with_value(create_key(\"large.key\"), large_value)\n  \n  match ctx_with_large.get(create_key(\"large.key\")) {\n    Some(value) => assert_eq(value.length(), large_value.length())\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®\n  let special_key = create_key(\"special.key!@#$%^&*()\")\n  let special_value = \"special_value!@#$%^&*()\"\n  let ctx_with_special = empty_ctx.with_value(special_key, special_value)\n  \n  match ctx_with_special.get(special_key) {\n    Some(value) => assert_eq(value, special_value)\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•Unicodeé”®å’Œå€¼\n  let unicode_key = create_key(\"æµ‹è¯•é”®ğŸš€\")\n  let unicode_value = \"æµ‹è¯•å€¼ğŸ‰\"\n  let ctx_with_unicode = empty_ctx.with_value(unicode_key, unicode_value)\n  \n  match ctx_with_unicode.get(unicode_key) {\n    Some(value) => assert_eq(value, unicode_value)\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•è¦†ç›–å€¼\n  let ctx1 = empty_ctx.with_value(create_key(\"test.key\"), \"value1\")\n  let ctx2 = ctx1.with_value(create_key(\"test.key\"), \"value2\")\n  \n  match ctx2.get(create_key(\"test.key\")) {\n    Some(value) => assert_eq(value, \"value2\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•å¤§é‡é”®å€¼å¯¹\n  let mut ctx_multi = empty_ctx\n  let mut i = 0\n  while i < 50 {\n    ctx_multi = ctx_multi.with_value(create_key(\"key.\" + i.to_string()), \"value.\" + i.to_string())\n    i = i + 1\n  }\n  \n  // éªŒè¯ä¸€äº›é”®å€¼å¯¹\n  match ctx_multi.get(create_key(\"key.0\")) {\n    Some(value) => assert_eq(value, \"value.0\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match ctx_multi.get(create_key(\"key.49\")) {\n    Some(value) => assert_eq(value, \"value.49\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match ctx_multi.get(create_key(\"key.50\")) {\n    Some(_) => @test.fail(\"Expected None for non-existent key\")\n    None => assert_eq(true, true)\n  }\n}","// Contextæ¨¡å—ContextKeyè¯¦ç»†æµ‹è¯•ç”¨ä¾‹\ntest \"context_key_creation_and_properties\" {\n  // æµ‹è¯•ContextKeyçš„åŸºæœ¬åˆ›å»ºå’Œå±æ€§\n  let simple_key = create_key(\"simple.key\")\n  let numeric_key = create_key(\"key123\")\n  let symbolic_key = create_key(\"key_with_underscores_and-dashes\")\n  \n  // éªŒè¯keyåç§°\n  assert_eq(simple_key.name, \"simple.key\")\n  assert_eq(numeric_key.name, \"key123\")\n  assert_eq(symbolic_key.name, \"key_with_underscores_and-dashes\")\n  \n  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²key\n  let empty_key = create_key(\"\")\n  assert_eq(empty_key.name, \"\")\n  \n  // æµ‹è¯•å•å­—ç¬¦key\n  let single_char_key = create_key(\"x\")\n  assert_eq(single_char_key.name, \"x\")\n  \n  // æµ‹è¯•é•¿keyåç§°\n  let long_key_name = \"this.is.a.very.long.key.name.that.tests.the.handling.of.extremely.long.identifiers.in.the.context.system\"\n  let long_key = create_key(long_key_name)\n  assert_eq(long_key.name, long_key_name)\n}\n\ntest \"context_key_with_special_characters\" {\n  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„keyåç§°\n  \n  // Unicodeå­—ç¬¦\n  let unicode_key = create_key(\"Unicodeé”®æµ‹è¯•ğŸš€\")\n  assert_eq(unicode_key.name, \"Unicodeé”®æµ‹è¯•ğŸš€\")\n  \n  // ç‰¹æ®Šç¬¦å·\n  let symbols_key = create_key(\"key!@#$%^&*()_+-={}[]|\\\\:;\\\"'<>?,./\")\n  assert_eq(symbols_key.name, \"key!@#$%^&*()_+-={}[]|\\\\:;\\\"'<>?,./\")\n  \n  // ç©ºæ ¼å’Œåˆ¶è¡¨ç¬¦\n  let spaces_key = create_key(\"key with spaces\")\n  assert_eq(spaces_key.name, \"key with spaces\")\n  \n  let tab_key = create_key(\"key\\twith\\ttabs\")\n  assert_eq(tab_key.name, \"key\\twith\\ttabs\")\n  \n  // æ¢è¡Œç¬¦ï¼ˆè™½ç„¶åœ¨å®é™…ä½¿ç”¨ä¸­ä¸æ¨èï¼‰\n  let newline_key = create_key(\"key\\nwith\\nnewlines\")\n  assert_eq(newline_key.name, \"key\\nwith\\nnewlines\")\n  \n  // ç‚¹å·å¼€å¤´çš„key\n  let dot_prefix_key = create_key(\".hidden.key\")\n  assert_eq(dot_prefix_key.name, \".hidden.key\")\n  \n  // æ–œæ å’Œåæ–œæ \n  let slash_key = create_key(\"path/key/with/slashes\")\n  assert_eq(slash_key.name, \"path/key/with/slashes\")\n  \n  let backslash_key = create_key(\"path\\\\key\\\\with\\\\backslashes\")\n  assert_eq(backslash_key.name, \"path\\\\key\\\\with\\\\backslashes\")\n}\n\ntest \"context_key_in_context_operations\" {\n  // æµ‹è¯•ContextKeyåœ¨Contextæ“ä½œä¸­çš„ä½¿ç”¨\n  \n  let ctx = Context::empty()\n  \n  // åˆ›å»ºå„ç§ç±»å‹çš„key\n  let user_key = create_key(\"user.id\")\n  let session_key = create_key(\"session.token\")\n  let request_key = create_key(\"request.id\")\n  let trace_key = create_key(\"trace.id\")\n  let span_key = create_key(\"span.id\")\n  let empty_key = create_key(\"\")\n  let special_key = create_key(\"special!@#$%^&*()\")\n  \n  // ä½¿ç”¨keyå­˜å‚¨å’Œè·å–å€¼\n  let ctx1 = ctx.with_value(user_key, \"user-12345\")\n  let ctx2 = ctx1.with_value(session_key, \"session-abcdef\")\n  let ctx3 = ctx2.with_value(request_key, \"req-67890\")\n  let ctx4 = ctx3.with_value(trace_key, \"trace-111111\")\n  let ctx5 = ctx4.with_value(span_key, \"span-222222\")\n  let ctx6 = ctx5.with_value(empty_key, \"empty.key.value\")\n  let ctx7 = ctx6.with_value(special_key, \"special.value\")\n  \n  // éªŒè¯æ‰€æœ‰å€¼éƒ½èƒ½æ­£ç¡®è·å–\n  match ctx7.get(user_key) {\n    Some(value) => assert_eq(value, \"user-12345\")\n    None => @test.fail(\"Expected user.id value\")\n  }\n  \n  match ctx7.get(session_key) {\n    Some(value) => assert_eq(value, \"session-abcdef\")\n    None => @test.fail(\"Expected session.token value\")\n  }\n  \n  match ctx7.get(request_key) {\n    Some(value) => assert_eq(value, \"req-67890\")\n    None => @test.fail(\"Expected request.id value\")\n  }\n  \n  match ctx7.get(trace_key) {\n    Some(value) => assert_eq(value, \"trace-111111\")\n    None => @test.fail(\"Expected trace.id value\")\n  }\n  \n  match ctx7.get(span_key) {\n    Some(value) => assert_eq(value, \"span-222222\")\n    None => @test.fail(\"Expected span.id value\")\n  }\n  \n  match ctx7.get(empty_key) {\n    Some(value) => assert_eq(value, \"empty.key.value\")\n    None => @test.fail(\"Expected empty key value\")\n  }\n  \n  match ctx7.get(special_key) {\n    Some(value) => assert_eq(value, \"special.value\")\n    None => @test.fail(\"Expected special key value\")\n  }\n  \n  // éªŒè¯ä¸å­˜åœ¨çš„key\n  let non_existent_key = create_key(\"non.existent.key\")\n  match ctx7.get(non_existent_key) {\n    Some(_) => @test.fail(\"Expected None for non-existent key\")\n    None => assert_eq(true, true)\n  }\n}\n\ntest \"context_key_value_overwrite\" {\n  // æµ‹è¯•ä½¿ç”¨ç›¸åŒkeyè¦†ç›–å€¼\n  \n  let ctx = Context::empty()\n  let key = create_key(\"overwrite.test\")\n  \n  // åˆå§‹å€¼\n  let ctx1 = ctx.with_value(key, \"initial.value\")\n  match ctx1.get(key) {\n    Some(value) => assert_eq(value, \"initial.value\")\n    None => @test.fail(\"Expected initial value\")\n  }\n  \n  // ç¬¬ä¸€æ¬¡è¦†ç›–\n  let ctx2 = ctx1.with_value(key, \"first.overwrite\")\n  match ctx2.get(key) {\n    Some(value) => assert_eq(value, \"first.overwrite\")\n    None => @test.fail(\"Expected first overwrite value\")\n  }\n  \n  // ç¬¬äºŒæ¬¡è¦†ç›–\n  let ctx3 = ctx2.with_value(key, \"second.overwrite\")\n  match ctx3.get(key) {\n    Some(value) => assert_eq(value, \"second.overwrite\")\n    None => @test.fail(\"Expected second overwrite value\")\n  }\n  \n  // è¦†ç›–ä¸ºç©ºå­—ç¬¦ä¸²\n  let ctx4 = ctx3.with_value(key, \"\")\n  match ctx4.get(key) {\n    Some(value) => assert_eq(value, \"\")\n    None => @test.fail(\"Expected empty string value\")\n  }\n  \n  // è¦†ç›–ä¸ºç‰¹æ®Šå­—ç¬¦\n  let ctx5 = ctx4.with_value(key, \"special!@#$%^&*()\")\n  match ctx5.get(key) {\n    Some(value) => assert_eq(value, \"special!@#$%^&*()\")\n    None => @test.fail(\"Expected special characters value\")\n  }\n  \n  // è¦†ç›–ä¸ºé•¿å­—ç¬¦ä¸²\n  let long_value = \"this.is.a.very.long.value.that.tests.the.context.system's.ability.to.handle.large.strings.without.any.issues.or.performance.problems\"\n  let ctx6 = ctx5.with_value(key, long_value)\n  match ctx6.get(key) {\n    Some(value) => assert_eq(value, long_value)\n    None => @test.fail(\"Expected long string value\")\n  }\n}\n\ntest \"context_key_with_similar_names\" {\n  // æµ‹è¯•åç§°ç›¸ä¼¼ä½†ä¸åŒçš„key\n  \n  let ctx = Context::empty()\n  \n  // åˆ›å»ºåç§°ç›¸ä¼¼çš„key\n  let key1 = create_key(\"user.id\")\n  let key2 = create_key(\"user_id\")  // ä¸‹åˆ’çº¿ vs ç‚¹å·\n  let key3 = create_key(\"user.id \")  // æœ«å°¾æœ‰ç©ºæ ¼\n  let key4 = create_key(\" user.id\")  // å¼€å¤´æœ‰ç©ºæ ¼\n  let key5 = create_key(\"USER.ID\")  // å¤§å†™\n  let key6 = create_key(\"user.Id\")  // éƒ¨åˆ†å¤§å†™\n  \n  // ä¸ºæ¯ä¸ªkeyè®¾ç½®ä¸åŒçš„å€¼\n  let ctx1 = ctx.with_value(key1, \"value1\")\n  let ctx2 = ctx1.with_value(key2, \"value2\")\n  let ctx3 = ctx2.with_value(key3, \"value3\")\n  let ctx4 = ctx3.with_value(key4, \"value4\")\n  let ctx5 = ctx4.with_value(key5, \"value5\")\n  let ctx6 = ctx5.with_value(key6, \"value6\")\n  \n  // éªŒè¯æ¯ä¸ªkeyéƒ½æœ‰ç‹¬ç«‹çš„å€¼\n  match ctx6.get(key1) {\n    Some(value) => assert_eq(value, \"value1\")\n    None => @test.fail(\"Expected value1 for user.id\")\n  }\n  \n  match ctx6.get(key2) {\n    Some(value) => assert_eq(value, \"value2\")\n    None => @test.fail(\"Expected value2 for user_id\")\n  }\n  \n  match ctx6.get(key3) {\n    Some(value) => assert_eq(value, \"value3\")\n    None => @test.fail(\"Expected value3 for 'user.id '\")\n  }\n  \n  match ctx6.get(key4) {\n    Some(value) => assert_eq(value, \"value4\")\n    None => @test.fail(\"Expected value4 for ' user.id'\")\n  }\n  \n  match ctx6.get(key5) {\n    Some(value) => assert_eq(value, \"value5\")\n    None => @test.fail(\"Expected value5 for USER.ID\")\n  }\n  \n  match ctx6.get(key6) {\n    Some(value) => assert_eq(value, \"value6\")\n    None => @test.fail(\"Expected value6 for user.Id\")\n  }\n}\n\ntest \"context_key_in_complex_scenarios\" {\n  // æµ‹è¯•ContextKeyåœ¨å¤æ‚åœºæ™¯ä¸­çš„ä½¿ç”¨\n  \n  let ctx = Context::empty()\n  \n  // æ¨¡æ‹ŸHTTPè¯·æ±‚çš„context\n  let http_method_key = create_key(\"http.method\")\n  let http_url_key = create_key(\"http.url\")\n  let http_user_agent_key = create_key(\"http.user_agent\")\n  let http_headers_key = create_key(\"http.headers\")\n  \n  // æ¨¡æ‹Ÿç”¨æˆ·ä¿¡æ¯çš„context\n  let user_id_key = create_key(\"user.id\")\n  let user_name_key = create_key(\"user.name\")\n  let user_email_key = create_key(\"user.email\")\n  let user_tier_key = create_key(\"user.tier\")\n  \n  // æ¨¡æ‹Ÿè¿½è¸ªä¿¡æ¯çš„context\n  let trace_id_key = create_key(\"trace.id\")\n  let span_id_key = create_key(\"span.id\")\n  let parent_span_id_key = create_key(\"parent.span.id\")\n  let trace_flags_key = create_key(\"trace.flags\")\n  \n  // æ¨¡æ‹Ÿä¸šåŠ¡é€»è¾‘çš„context\n  let operation_key = create_key(\"operation\")\n  let service_name_key = create_key(\"service.name\")\n  let service_version_key = create_key(\"service.version\")\n  let correlation_id_key = create_key(\"correlation.id\")\n  \n  // æ„å»ºå¤æ‚çš„context\n  let complex_ctx = ctx\n    // HTTPç›¸å…³ä¿¡æ¯\n    .with_value(http_method_key, \"POST\")\n    .with_value(http_url_key, \"https://api.example.com/v1/payments\")\n    .with_value(http_user_agent_key, \"PaymentClient/3.2.1\")\n    .with_value(http_headers_key, \"Authorization: Bearer token123, Content-Type: application/json\")\n    // ç”¨æˆ·ä¿¡æ¯\n    .with_value(user_id_key, \"user-12345\")\n    .with_value(user_name_key, \"John Doe\")\n    .with_value(user_email_key, \"john.doe@example.com\")\n    .with_value(user_tier_key, \"premium\")\n    // è¿½è¸ªä¿¡æ¯\n    .with_value(trace_id_key, \"trace-abcdef-123456\")\n    .with_value(span_id_key, \"span-789012-345678\")\n    .with_value(parent_span_id_key, \"span-parent-111111\")\n    .with_value(trace_flags_key, \"01\")\n    // ä¸šåŠ¡é€»è¾‘ä¿¡æ¯\n    .with_value(operation_key, \"payment.process\")\n    .with_value(service_name_key, \"payment-service\")\n    .with_value(service_version_key, \"3.2.1\")\n    .with_value(correlation_id_key, \"corr-987654-321098\")\n  \n  // éªŒè¯æ‰€æœ‰ä¿¡æ¯éƒ½èƒ½æ­£ç¡®è·å–\n  match complex_ctx.get(http_method_key) {\n    Some(value) => assert_eq(value, \"POST\")\n    None => @test.fail(\"Expected HTTP method\")\n  }\n  \n  match complex_ctx.get(http_url_key) {\n    Some(value) => assert_eq(value, \"https://api.example.com/v1/payments\")\n    None => @test.fail(\"Expected HTTP URL\")\n  }\n  \n  match complex_ctx.get(user_id_key) {\n    Some(value) => assert_eq(value, \"user-12345\")\n    None => @test.fail(\"Expected user ID\")\n  }\n  \n  match complex_ctx.get(user_name_key) {\n    Some(value) => assert_eq(value, \"John Doe\")\n    None => @test.fail(\"Expected user name\")\n  }\n  \n  match complex_ctx.get(trace_id_key) {\n    Some(value) => assert_eq(value, \"trace-abcdef-123456\")\n    None => @test.fail(\"Expected trace ID\")\n  }\n  \n  match complex_ctx.get(operation_key) {\n    Some(value) => assert_eq(value, \"payment.process\")\n    None => @test.fail(\"Expected operation\")\n  }\n  \n  match complex_ctx.get(correlation_id_key) {\n    Some(value) => assert_eq(value, \"corr-987654-321098\")\n    None => @test.fail(\"Expected correlation ID\")\n  }\n  \n  // æµ‹è¯•åœ¨å¤æ‚contextä¸­æ·»åŠ æ–°çš„key-valueå¯¹\n  let new_key = create_key(\"new.added.key\")\n  let updated_ctx = complex_ctx.with_value(new_key, \"new.value\")\n  \n  match updated_ctx.get(new_key) {\n    Some(value) => assert_eq(value, \"new.value\")\n    None => @test.fail(\"Expected new added value\")\n  }\n  \n  // éªŒè¯åŸæœ‰å€¼ä¸å—å½±å“\n  match updated_ctx.get(user_id_key) {\n    Some(value) => assert_eq(value, \"user-12345\")\n    None => @test.fail(\"Original user ID should not be affected\")\n  }\n}\n\ntest \"context_key_edge_cases_and_boundary_conditions\" {\n  // æµ‹è¯•ContextKeyçš„è¾¹ç•Œæ¡ä»¶å’Œç‰¹æ®Šæƒ…å†µ\n  \n  let ctx = Context::empty()\n  \n  // æµ‹è¯•æé•¿çš„keyåç§°\n  let mut very_long_key_name = \"\"\n  let mut i = 0\n  while i < 1000 {\n    very_long_key_name = very_long_key_name + \"a\"\n    i = i + 1\n  }\n  let very_long_key = create_key(very_long_key_name)\n  assert_eq(very_long_key.name, very_long_key_name)\n  \n  // æµ‹è¯•åŒ…å«å„ç§æ§åˆ¶å­—ç¬¦çš„key\n  let control_chars_key = create_key(\"key\\u0000with\\u0001control\\u0002chars\")\n  assert_eq(control_chars_key.name, \"key\\u0000with\\u0001control\\u0002chars\")\n  \n  // æµ‹è¯•åªåŒ…å«æ•°å­—çš„key\n  let numbers_only_key = create_key(\"123456789\")\n  assert_eq(numbers_only_key.name, \"123456789\")\n  \n  // æµ‹è¯•åªåŒ…å«ç¬¦å·çš„key\n  let symbols_only_key = create_key(\"!@#$%^&*()\")\n  assert_eq(symbols_only_key.name, \"!@#$%^&*()\")\n  \n  // æµ‹è¯•åŒ…å«emojiçš„key\n  let emoji_key = create_key(\"key_with_emoji_ğŸš€ğŸ‰ğŸ’»\")\n  assert_eq(emoji_key.name, \"key_with_emoji_ğŸš€ğŸ‰ğŸ’»\")\n  \n  // æµ‹è¯•æ··åˆè¯­è¨€çš„key\n  let mixed_language_key = create_key(\"mixed_Englishä¸­æ–‡í•œêµ­ì–´Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\")\n  assert_eq(mixed_language_key.name, \"mixed_Englishä¸­æ–‡í•œêµ­ì–´Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\")\n  \n  // æµ‹è¯•ä½¿ç”¨è¿™äº›ç‰¹æ®Škeyåœ¨contextä¸­å­˜å‚¨å€¼\n  let ctx_with_special_keys = ctx\n    .with_value(very_long_key, \"very.long.key.value\")\n    .with_value(control_chars_key, \"control.chars.value\")\n    .with_value(numbers_only_key, \"numbers.only.value\")\n    .with_value(symbols_only_key, \"symbols.only.value\")\n    .with_value(emoji_key, \"emoji.value\")\n    .with_value(mixed_language_key, \"mixed.language.value\")\n  \n  // éªŒè¯æ‰€æœ‰ç‰¹æ®Škeyéƒ½èƒ½æ­£ç¡®å·¥ä½œ\n  match ctx_with_special_keys.get(very_long_key) {\n    Some(value) => assert_eq(value, \"very.long.key.value\")\n    None => @test.fail(\"Expected value for very long key\")\n  }\n  \n  match ctx_with_special_keys.get(control_chars_key) {\n    Some(value) => assert_eq(value, \"control.chars.value\")\n    None => @test.fail(\"Expected value for control chars key\")\n  }\n  \n  match ctx_with_special_keys.get(numbers_only_key) {\n    Some(value) => assert_eq(value, \"numbers.only.value\")\n    None => @test.fail(\"Expected value for numbers only key\")\n  }\n  \n  match ctx_with_special_keys.get(symbols_only_key) {\n    Some(value) => assert_eq(value, \"symbols.only.value\")\n    None => @test.fail(\"Expected value for symbols only key\")\n  }\n  \n  match ctx_with_special_keys.get(emoji_key) {\n    Some(value) => assert_eq(value, \"emoji.value\")\n    None => @test.fail(\"Expected value for emoji key\")\n  }\n  \n  match ctx_with_special_keys.get(mixed_language_key) {\n    Some(value) => assert_eq(value, \"mixed.language.value\")\n    None => @test.fail(\"Expected value for mixed language key\")\n  }\n}\n\ntest \"context_key_performance_and_efficiency\" {\n  // æµ‹è¯•ContextKeyçš„æ€§èƒ½å’Œæ•ˆç‡ï¼ˆå¤§é‡key-valueæ“ä½œï¼‰\n  \n  let ctx = Context::empty()\n  let mut current_ctx = ctx\n  \n  // åˆ›å»ºå°‘é‡keyå¹¶å­˜å‚¨å€¼ï¼ˆé¿å…æ•°ç»„æ“ä½œé—®é¢˜ï¼‰\n  let key1 = create_key(\"perf.test.key.1\")\n  let key2 = create_key(\"perf.test.key.2\")\n  let key3 = create_key(\"perf.test.key.3\")\n  let key4 = create_key(\"perf.test.key.4\")\n  let key5 = create_key(\"perf.test.key.5\")\n  \n  // å­˜å‚¨å€¼\n  current_ctx = current_ctx.with_value(key1, \"value.1\")\n  current_ctx = current_ctx.with_value(key2, \"value.2\")\n  current_ctx = current_ctx.with_value(key3, \"value.3\")\n  current_ctx = current_ctx.with_value(key4, \"value.4\")\n  current_ctx = current_ctx.with_value(key5, \"value.5\")\n  \n  // éªŒè¯æ‰€æœ‰å€¼éƒ½èƒ½æ­£ç¡®è·å–\n  match current_ctx.get(key1) {\n    Some(value) => assert_eq(value, \"value.1\")\n    None => @test.fail(\"Expected value for key1\")\n  }\n  \n  match current_ctx.get(key2) {\n    Some(value) => assert_eq(value, \"value.2\")\n    None => @test.fail(\"Expected value for key2\")\n  }\n  \n  match current_ctx.get(key3) {\n    Some(value) => assert_eq(value, \"value.3\")\n    None => @test.fail(\"Expected value for key3\")\n  }\n  \n  match current_ctx.get(key4) {\n    Some(value) => assert_eq(value, \"value.4\")\n    None => @test.fail(\"Expected value for key4\")\n  }\n  \n  match current_ctx.get(key5) {\n    Some(value) => assert_eq(value, \"value.5\")\n    None => @test.fail(\"Expected value for key5\")\n  }\n  \n  // æµ‹è¯•è¦†ç›–å€¼\n  current_ctx = current_ctx.with_value(key1, \"updated.value.1\")\n  current_ctx = current_ctx.with_value(key3, \"updated.value.3\")\n  current_ctx = current_ctx.with_value(key5, \"updated.value.5\")\n  \n  // éªŒè¯æ›´æ–°åçš„å€¼\n  match current_ctx.get(key1) {\n    Some(value) => assert_eq(value, \"updated.value.1\")\n    None => @test.fail(\"Expected updated value for key1\")\n  }\n  \n  match current_ctx.get(key2) {\n    Some(value) => assert_eq(value, \"value.2\")  // æœªæ›´æ–°\n    None => @test.fail(\"Expected original value for key2\")\n  }\n  \n  match current_ctx.get(key3) {\n    Some(value) => assert_eq(value, \"updated.value.3\")\n    None => @test.fail(\"Expected updated value for key3\")\n  }\n  \n  match current_ctx.get(key4) {\n    Some(value) => assert_eq(value, \"value.4\")  // æœªæ›´æ–°\n    None => @test.fail(\"Expected original value for key4\")\n  }\n  \n  match current_ctx.get(key5) {\n    Some(value) => assert_eq(value, \"updated.value.5\")\n    None => @test.fail(\"Expected updated value for key5\")\n  }\n}","test \"context_multiple_values\" {\n  let ctx = Context::empty()\n  let key1 = create_key(\"test-key-1\")\n  let key2 = create_key(\"test-key-2\")\n  \n  // æµ‹è¯•è®¾ç½®å¤šä¸ªå€¼\n  let ctx_with_value1 = ctx.with_value(key1, \"test-value-1\")\n  let ctx_with_values = ctx_with_value1.with_value(key2, \"test-value-2\")\n  \n  match ctx_with_values.get(key1) {\n    Some(value) => assert_eq(value, \"test-value-1\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match ctx_with_values.get(key2) {\n    Some(value) => assert_eq(value, \"test-value-2\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n}\n\ntest \"baggage_multiple_entries\" {\n  let baggage = Baggage::empty()\n  \n  // æµ‹è¯•æ·»åŠ å¤šä¸ªæ¡ç›®\n  let baggage1 = baggage.with_entry(\"user.id\", \"12345\")\n  let baggage2 = baggage1.with_entry(\"session.id\", \"abcdef\")\n  let baggage3 = baggage2.with_entry(\"request.id\", \"xyz789\")\n  \n  match baggage3.get(\"user.id\") {\n    Some(value) => assert_eq(value, \"12345\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match baggage3.get(\"session.id\") {\n    Some(value) => assert_eq(value, \"abcdef\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  match baggage3.get(\"request.id\") {\n    Some(value) => assert_eq(value, \"xyz789\")\n    None => @test.fail(\"Expected Some(value)\")\n  }\n  \n  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®\n  match baggage3.get(\"non.existent\") {\n    Some(_) => @test.fail(\"Expected None\")\n    None => assert_eq(true, true)\n  }\n}","// Azimuth Telemetry - Context API\n// ä¸Šä¸‹æ–‡ä¼ æ’­å’Œç®¡ç†\n\npub struct ContextKey {\n  name : String\n}\n\npub struct Context {\n  values : Array[(String, String)]  // ç®€åŒ–å®ç°ï¼Œä½¿ç”¨å­—ç¬¦ä¸²å­˜å‚¨\n}\n\npub struct Baggage {\n  entries : Array[(String, String)]\n}\n\n// Contextç›¸å…³å‡½æ•°\npub fn Context::empty() -> Context {\n  Context::{ values: [] }\n}\n\npub fn Context::with_value(self : Context, key : ContextKey, value : String) -> Context {\n  // ç®€åŒ–å®ç°ï¼Œå°†å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸²\n  let new_values = []\n  let mut i = 0\n  while i < self.values.length() {\n    new_values.push(self.values[i])\n    i = i + 1\n  }\n  new_values.push((key.name, value))\n  Context::{ values: new_values }\n}\n\npub fn Context::get(self : Context, key : ContextKey) -> String? {\n  let mut index = 0\n  while index < self.values.length() {\n    let (k, v) = self.values[index]\n    if k == key.name {\n      return Some(v)\n    }\n    index = index + 1\n  }\n  None\n}\n\n// Baggageç›¸å…³å‡½æ•°\npub fn Baggage::empty() -> Baggage {\n  Baggage::{ entries: [] }\n}\n\npub fn Baggage::with_entry(self : Baggage, key : String, value : String) -> Baggage {\n  let new_entries = []\n  let mut i = 0\n  while i < self.entries.length() {\n    new_entries.push(self.entries[i])\n    i = i + 1\n  }\n  new_entries.push((key, value))\n  Baggage::{ entries: new_entries }\n}\n\npub fn Baggage::get(self : Baggage, key : String) -> String? {\n  let mut index = 0\n  while index < self.entries.length() {\n    let (k, v) = self.entries[index]\n    if k == key {\n      return Some(v)\n    }\n    index = index + 1\n  }\n  None\n}\n\n// åˆ›å»ºContextKeyçš„ä¾¿æ·å‡½æ•°\npub fn create_key(name : String) -> ContextKey {\n  ContextKey::{ name }\n}","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T : Show] debug_string(t : T) -> String {\n  let buf = StringBuilder::new(size_hint=50)\n  t.output(buf)\n  buf.to_string()\n}\n\n///|\n/// Assert referential equality of two values.\n///\n/// Returns Ok if the two arguments are the same object by reference, using\n/// `physical_equal`; raise an Error otherwise. Certain objects may be equal by\n/// value, but they are different objects in the memory. This function checks\n/// the latter.\n///\n/// # Examples\n///\n/// ```skip\n/// let a = \"4\" + \"2\"\n/// let b = \"4\" + \"2\"\n/// @test.same_object(a, a)\n/// @test.is_not(a, b)\n/// ```\n#callsite(autofill(loc))\npub fn[T : Show] same_object(a : T, b : T, loc~ : SourceLoc) -> Unit raise {\n  if !physical_equal(a, b) {\n    let a = debug_string(a)\n    let b = debug_string(b)\n    fail(\"`\\{a} is \\{b}`\", loc~)\n  }\n}\n\n///|\n/// Assert referential inequality of two values.\n///\n/// Returns Ok if the two arguments are NOT the same object by reference, using\n/// `physical_equal`; raise an Error otherwise. Certain objects may be equal\n/// by value, but they are different objects in the memory. This function\n/// checks the latter.\n///\n/// # Examples\n///\n/// ```skip\n/// let a = \"4\" + \"2\"\n/// let b = \"4\" + \"2\"\n/// @test.is_not(a, b)\n/// @test.same_object(a, a)\n/// ```\n#callsite(autofill(loc))\n#alias(is_not, deprecated)\npub fn[T : Show] not_same_object(a : T, b : T, loc~ : SourceLoc) -> Unit raise {\n  if physical_equal(a, b) {\n    let a = debug_string(a)\n    let b = debug_string(b)\n    fail(\"`!(\\{a} is \\{b})`\", loc~)\n  }\n}\n\n///|\n/// Expected to be used in test blocks, don't catch this error.\n///  \n/// Produces an error message similar to @builtin.fail.\n#callsite(autofill(loc))\npub fn[T] fail(msg : String, loc~ : SourceLoc) -> T raise {\n  @builtin.fail(msg, loc~)\n}\n\n///|\n/// Write data to snapshot buffer, use `snapshot` to output.\n/// \n/// See also `@test.T::writeln`\npub fn Test::write(self : Test, obj : &Show) -> Unit {\n  self.buffer.write_string(obj.to_string())\n}\n\n///|\n/// Write data to snapshot buffer and newline, use `snapshot` to output.\n/// \n/// See also `@test.T::write`\npub fn Test::writeln(self : Test, obj : &Show) -> Unit {\n  self.write(obj)\n  self.buffer.write_char('\\n')\n}\n\n///|\n/// Take a snapshot of the current buffer and write to a file.\n/// \n/// ```mbt\n///   let t = @test.new(\"test.txt\")\n///   t.writeln(\"hello\")\n///   t.snapshot(filename=\"test.txt\") // actual test block end\n/// ```\n///\n/// Currently it can only be used once and should be used as the last step.\n#callsite(autofill(args_loc, loc))\npub fn Test::snapshot(\n  self : Test,\n  filename~ : String,\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise SnapshotError {\n  let loc = loc.to_json_string()\n  let args_loc = args_loc.to_json()\n  let actual = self.buffer.to_string().escape()\n  let expect = filename.escape()\n  // always raise SnapshotError, moon will handle this\n  raise SnapshotError(\n    \"@SNAPSHOT_TESTING {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect}, \\\"actual\\\": \\{actual}, \\\"snapshot\\\": true}\",\n  )\n}\n\n///|\n/// Return the name of the test.\npub fn Test::name(self : Self) -> String {\n  self.name\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Creates a new dynamic array from a fixed-size array.\n///\n/// Parameters:\n///\n/// * `arr` : The fixed-size array to convert. The elements of this array will be\n/// copied to the new array.\n///\n/// Returns a new dynamic array containing all elements from the input fixed-size\n/// array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let fixed = FixedArray::make(3, 42)\n/// let dynamic = Array::from_fixed_array(fixed)\n/// inspect(dynamic, content=\"[42, 42, 42]\")\n/// ```\npub fn[T] Array::from_fixed_array(arr : FixedArray[T]) -> Array[T] {\n  let len = arr.length()\n  let arr2 = Array::make_uninit(len)\n  UninitializedArray::unsafe_blit_fixed(arr2.buffer(), 0, arr, 0, len)\n  arr2\n}\n\n///|\n/// Creates a new array with a specified length and initializes all elements with\n/// the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be a non-negative\n/// integer.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new array of type `Array[T]` with `length` elements, where each\n/// element is initialized to `initial_value`.\n///\n/// Throws an error if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = Array::make(3, 42)\n/// inspect(arr, content=\"[42, 42, 42]\")\n/// ```\n///\n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt test\n/// let two_dimension_array = Array::make(10, Array::make(10, 0))\n/// two_dimension_array[0][5] = 10\n/// assert_eq(two_dimension_array[5][5], 10)\n/// ```\n/// This is because all the cells reference to the same object (the Array[Int] in this case).\n/// One should use makei() instead which creates an object for each index.\npub fn[T] Array::make(len : Int, elem : T) -> Array[T] {\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, elem)\n  }\n  arr\n}\n\n///|\n/// Creates a new array of the specified length, where each element is\n/// initialized using an index-based initialization function.\n///\n/// Parameters:\n///\n/// * `length` : The length of the new array. If `length` is less than or equal\n/// to 0, returns an empty array.\n/// * `initializer` : A function that takes an index (starting from 0) and\n/// returns a value of type `T`. This function is called for each index to\n/// initialize the corresponding element.\n///\n/// Returns a new array of type `Array[T]` with the specified length, where each\n/// element is initialized using the provided function.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = Array::makei(3, i => i * 2)\n/// inspect(arr, content=\"[0, 2, 4]\")\n/// ```\n#locals(f)\npub fn[T] Array::makei(length : Int, f : (Int) -> T raise?) -> Array[T] raise? {\n  if length <= 0 {\n    []\n  } else {\n    let array = Array::make_uninit(length)\n    for i in 0..<length {\n      array.unsafe_set(i, f(i))\n    }\n    array\n  }\n}\n\n///|\n/// Returns the total capacity of the array, which is the number of elements that\n/// the array can hold without requiring reallocation of its internal buffer.\n///\n/// Parameters:\n///\n/// * `array` : The array whose capacity is to be determined.\n///\n/// Returns the current capacity of the array as an integer.\n///\n/// NOTE: The capacity of an array may not be consistent across different backends\n/// and/or different versions of the MoonBit compiler/core.\npub fn[T] Array::capacity(self : Array[T]) -> Int {\n  self.buffer().0.length()\n}\n\n///|\n/// Retrieves the element at the specified index from an array without bounds\n/// checking.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to retrieve the element.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// inspect(arr.unsafe_get(1), content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.unsafe_get\")\npub fn[T] Array::unsafe_get(self : Array[T], idx : Int) -> T {\n  self.buffer()[idx]\n}\n\n///|\n/// Retrieves an element from the array at the specified index.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// inspect(arr[1], content=\"2\")\n/// ```\n///\n#intrinsic(\"%array.get\")\n#alias(\"_[_]\")\npub fn[T] Array::at(self : Array[T], index : Int) -> T {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index]\n}\n\n///|\n/// Retrieves the element at the specified index from the array.\n///\n/// Parameters:\n///\n/// * `self` : The array to get the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns `Some(element)` if the index is within bounds, or `None` if the index\n/// is out of bounds.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// inspect(arr.get(-1), content=\"None\")\n/// inspect(arr.get(0), content=\"Some(1)\")\n/// inspect(arr.get(3), content=\"None\")\n/// ```\npub fn[T] Array::get(self : Array[T], index : Int) -> T? {\n  let len = self.length()\n  guard index >= 0 && index < len else { None }\n  Some(self.unsafe_get(index))\n}\n\n///|\n#intrinsic(\"%array.unsafe_set\")\npub fn[T] Array::unsafe_set(self : Array[T], idx : Int, val : T) -> Unit {\n  self.buffer()[idx] = val\n}\n\n///|\n/// Sets the element at the specified index in the array to a new value. The\n/// original value at that index is overwritten.\n///\n/// Parameters:\n///\n/// * `array` : The array to modify.\n/// * `index` : The position in the array where the value will be set.\n/// * `value` : The new value to assign at the specified index.\n///\n/// Throws an error if `index` is negative or greater than or equal to the length\n/// of the array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// arr[1] = 42\n/// inspect(arr, content=\"[1, 42, 3]\")\n/// ```\n///\n#intrinsic(\"%array.set\")\n#alias(\"_[_]=_\")\npub fn[T] Array::set(self : Array[T], index : Int, value : T) -> Unit {\n  let len = self.length()\n  guard index >= 0 && index < len\n  self.buffer()[index] = value\n}\n\n///|\n/// Compares two arrays for equality. Returns true if both arrays have the same\n/// length and contain equal elements in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns true if the arrays are equal, false otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr1 = [1, 2, 3]\n/// let arr2 = [1, 2, 3]\n/// let arr3 = [1, 2, 4]\n/// inspect(arr1 == arr2, content=\"true\")\n/// inspect(arr1 == arr3, content=\"false\")\n/// ```\npub impl[T : Eq] Eq for Array[T] with equal(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  guard self_len == other_len else { return false }\n  for i in 0..<self_len {\n    guard self.unsafe_get(i) == other.unsafe_get(i) else { break false }\n  } else {\n    true\n  }\n}\n\n///|\npub impl[T : Hash] Hash for Array[T] with hash_combine(self, hasher) {\n  for v in self {\n    v.hash_combine(hasher)\n  }\n}\n\n///|\n/// Compares two arrays based on shortlex order.\n///\n/// First compares the lengths of the arrays. If they differ, returns -1 if the\n/// first array is shorter, 1 if it's longer. If the lengths are equal, compares\n/// elements pairwise until a difference is found or all elements have been\n/// compared.\n///\n/// Parameters:\n///\n/// * `self` : The first array to compare.\n/// * `other` : The second array to compare.\n///\n/// Returns an integer that indicates the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr1 = [1, 2, 3]\n/// let arr2 = [1, 2, 4]\n/// let arr3 = [1, 2]\n/// inspect(arr1.compare(arr2), content=\"-1\") // arr1 < arr2\n/// inspect(arr2.compare(arr1), content=\"1\") // arr2 > arr1\n/// inspect(arr1.compare(arr3), content=\"1\") // arr1 > arr3 (longer)\n/// inspect(arr1.compare(arr1), content=\"0\") // arr1 = arr1\n/// ```\npub impl[T : Compare] Compare for Array[T] with compare(self, other) {\n  let len_self = self.length()\n  let len_other = other.length()\n  let cmp = len_self.compare(len_other)\n  guard cmp is 0 else { return cmp }\n  for i in 0..<len_self {\n    let cmp = self.unsafe_get(i).compare(other.unsafe_get(i))\n    guard cmp is 0 else { break cmp }\n  } else {\n    0\n  }\n}\n\n///|\n/// Concatenates two arrays into a new array. The resulting array contains all\n/// elements from the first array followed by all elements from the second array.\n///\n/// Parameters:\n///\n/// * `self` : The first array to concatenate.\n/// * `other` : The second array to concatenate.\n///\n/// Returns a new array containing all elements from both arrays in order.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = [1, 2, 3]\n/// let b = [4, 5]\n/// inspect(a + b, content=\"[1, 2, 3, 4, 5]\")\n/// ```\npub impl[T] Add for Array[T] with add(self, other) {\n  let result = Array::make_uninit(self.length() + other.length())\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    0,\n    self.buffer(),\n    0,\n    self.length(),\n  )\n  UninitializedArray::unsafe_blit(\n    result.buffer(),\n    self.length(),\n    other.buffer(),\n    0,\n    other.length(),\n  )\n  result\n}\n\n///|\n/// Appends all elements from one array to the end of another array. The elements\n/// are added in-place, modifying the original array.\n///\n/// Parameters:\n///\n/// * `self` : The array to append to.\n/// * `other` : The array whose elements will be appended.\n///\n/// Example:\n///\n/// ```mbt test\n/// let v1 = [1, 2, 3]\n/// let v2 = [4, 5, 6]\n/// v1.append(v2)\n/// inspect(v1, content=\"[1, 2, 3, 4, 5, 6]\")\n/// let v1 = [1, 2, 3]\n/// let v2 : Array[Int] = []\n/// v1.append(v2)\n/// inspect(v1, content=\"[1, 2, 3]\")\n/// ```\npub fn[T] Array::append(self : Array[T], other : ArrayView[T]) -> Unit {\n  other.blit_to(self, dst_offset=self.length())\n}\n\n///|\n/// Iterates through each element of the array in order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `function` : A function that takes a single element of type `T` as input\n/// and returns `Unit`. This function is applied to each element of the array in\n/// order.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// let mut sum = 0\n/// arr.each(x => sum = sum + x)\n/// inspect(sum, content=\"6\")\n/// ```\n#locals(f)\npub fn[T] Array::each(self : Array[T], f : (T) -> Unit raise?) -> Unit raise? {\n  for v in self {\n    f(v)\n  }\n}\n\n///|\n/// Iterates over the elements of the array in reverse order, applying the given\n/// function to each element.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over.\n/// * `f` : A function that takes an element of type `T` and returns `Unit`. This\n/// function is applied to each element of the array in reverse order.\n///\n/// Example:\n///\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_each((x) => { sum = sum - x })\n///   @json.inspect(sum, content=-12)\n/// ```\n#locals(f)\npub fn[T] Array::rev_each(self : Array[T], f : (T) -> Unit) -> Unit {\n  let len = self.length()\n  for i in 0..<len {\n    f(self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index in reversed order.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let mut sum = 0\n///   v.rev_eachi((i, x) => { sum = sum + x + i })\n///   assert_eq(sum, 15)\n/// ```\n#locals(f)\npub fn[T] Array::rev_eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  let len = self.length()\n  for i in 0..<len {\n    f(i, self[len - i - 1])\n  }\n}\n\n///|\n/// Iterates over the elements of the array with index.\n///\n/// # Example\n/// ```mbt test\n/// let v = [3, 4, 5]\n/// let mut sum = 0\n/// v.eachi((i, x) => sum = sum + x + i)\n/// inspect(sum, content=\"15\")\n/// ```\n#locals(f)\npub fn[T] Array::eachi(\n  self : Array[T],\n  f : (Int, T) -> Unit raise?,\n) -> Unit raise? {\n  for i, v in self {\n    f(i, v)\n  }\n}\n\n///|\n/// Clears the array, removing all values.\n///\n/// This method has no effect on the allocated capacity of the array, only setting the length to 0.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.clear()\n///   assert_eq(v.length(), 0)\n/// ```\npub fn[T] Array::clear(self : Array[T]) -> Unit {\n  self.unsafe_truncate_to_length(0)\n}\n\n///|\n/// Maps a function over the elements of the array.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.map((x) => {x + 1})\n///   assert_eq(v2, [4, 5, 6])\n/// ```\n#locals(f)\npub fn[T, U] Array::map(\n  self : Array[T],\n  f : (T) -> U raise?,\n) -> Array[U] raise? {\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.map_in_place((x) => {x + 1})\n///   assert_eq(v, [4, 5, 6])\n/// ```\n#locals(f)\n#alias(map_inplace, deprecated)\npub fn[T] Array::map_in_place(\n  self : Array[T],\n  f : (T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(v)\n  }\n}\n\n///|\n/// Maps a function over the elements of the array with index.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.mapi((i, x) => {x + i})\n///   assert_eq(v2, [3, 5, 7])\n/// ```\n#locals(f)\npub fn[T, U] Array::mapi(\n  self : Array[T],\n  f : (Int, T) -> U raise?,\n) -> Array[U] raise? {\n  if self.length() == 0 {\n    return []\n  }\n  let arr = Array::make_uninit(self.length())\n  for i, v in self {\n    arr.unsafe_set(i, f(i, v))\n  }\n  arr\n}\n\n///|\n/// Maps a function over the elements of the array with index in place.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   v.mapi_in_place((i, x) => {x + i})\n///   assert_eq(v, [3, 5, 7])\n/// ```\n#locals(f)\n#alias(mapi_inplace, deprecated)\npub fn[T] Array::mapi_in_place(\n  self : Array[T],\n  f : (Int, T) -> T raise?,\n) -> Unit raise? {\n  for i, v in self {\n    self[i] = f(i, v)\n  }\n}\n\n///|\n/// Creates a new array containing all elements from the input array that satisfy\n/// the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to filter.\n/// * `predicate` : A function that takes an element and returns a boolean\n/// indicating whether the element should be included in the result.\n///\n/// Returns a new array containing only the elements for which the predicate\n/// function returns `true`. The relative order of the elements is preserved.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// let evens = arr.filter(x => x % 2 == 0)\n/// inspect(evens, content=\"[2, 4]\")\n/// ```\n#locals(f)\npub fn[T] Array::filter(\n  self : Array[T],\n  f : (T) -> Bool raise?,\n) -> Array[T] raise? {\n  let arr = []\n  for v in self {\n    if f(v) {\n      arr.push(v)\n    }\n  }\n  arr\n}\n\n///|\n/// Tests whether the array contains no elements.\n///\n/// Parameters:\n///\n/// * `array` : The array to check.\n///\n/// Returns `true` if the array has no elements, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let empty : Array[Int] = []\n/// inspect(empty.is_empty(), content=\"true\")\n/// let non_empty = [1, 2, 3]\n/// inspect(non_empty.is_empty(), content=\"false\")\n/// ```\npub fn[T] Array::is_empty(self : Array[T]) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Reverses the order of elements in an array in place, modifying the original\n/// array.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.rev_in_place()\n/// inspect(arr, content=\"[5, 4, 3, 2, 1]\")\n/// let arr : Array[Int] = []\n/// arr.rev_in_place()\n/// inspect(arr, content=\"[]\")\n/// ```\n#alias(rev_inplace, deprecated)\npub fn[T] Array::rev_in_place(self : Array[T]) -> Unit {\n  let len = self.length()\n  for i in 0..<(len / 2) {\n    let temp = self.unsafe_get(i)\n    self.unsafe_set(i, self.unsafe_get(len - i - 1))\n    self.unsafe_set(len - i - 1, temp)\n  }\n}\n\n///|\n/// Creates a new array with elements in reversed order.\n///\n/// Parameters:\n///\n/// * `self` : The array to be reversed.\n///\n/// Returns a new array containing the same elements as the input array but in\n/// reverse order. The original array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// inspect(arr.rev(), content=\"[5, 4, 3, 2, 1]\")\n/// inspect(arr, content=\"[1, 2, 3, 4, 5]\") // original array unchanged\n/// ```\npub fn[T] Array::rev(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  let arr = Array::make_uninit(len)\n  for i in 0..<len {\n    arr.unsafe_set(i, self.unsafe_get(len - i - 1))\n  }\n  arr\n}\n\n///|\n/// Split the array into two at the given index.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let (v1, v2) = (v[:1], v[1:])\n///   assert_eq(v1, [3])\n///   assert_eq(v2, [4, 5])\n/// ```\n#deprecated(\"Use ArrayView instead, e.g, (a[:index], a[index:])\")\n#doc(hidden)\npub fn[T] Array::split_at(self : Array[T], index : Int) -> (Array[T], Array[T]) {\n  if index < 0 || index > self.length() {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is \\{index}\",\n    )\n  }\n  let v1 = Array::make_uninit(index)\n  let v2 = Array::make_uninit(self.length() - index)\n  UninitializedArray::unsafe_blit(v1.buffer(), 0, self.buffer(), 0, index)\n  if index != self.length() {\n    UninitializedArray::unsafe_blit(\n      v2.buffer(),\n      0,\n      self.buffer(),\n      index,\n      self.length() - index,\n    )\n  }\n  (v1, v2)\n}\n\n///|\n/// Checks whether the array contains an element equal to the given value.\n///\n/// Parameters:\n///\n/// * `array` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns `true` if the array contains an element equal to the given value,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// inspect(arr.contains(3), content=\"true\")\n/// inspect(arr.contains(6), content=\"false\")\n/// let arr : Array[Int] = []\n/// inspect(arr.contains(1), content=\"false\")\n/// ```\npub fn[T : Eq] Array::contains(self : Array[T], value : T) -> Bool {\n  for v in self {\n    if v == value {\n      break true\n    }\n  } else {\n    false\n  }\n}\n\n///|\n/// Checks if the array begins with all elements of the provided prefix array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to check against.\n/// * `prefix` : The array containing the sequence of elements to look for at the\n/// beginning.\n///\n/// Returns `true` if the array starts with all elements in `prefix` in the same\n/// order, `false` otherwise. An empty prefix array always returns `true`, and a\n/// prefix longer than the array always returns `false`.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// inspect(arr.starts_with([1, 2]), content=\"true\")\n/// inspect(arr.starts_with([2, 3]), content=\"false\")\n/// inspect(arr.starts_with([]), content=\"true\")\n/// inspect(arr.starts_with([1, 2, 3, 4, 5, 6]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::starts_with(self : Array[T], prefix : Array[T]) -> Bool {\n  if prefix.length() > self.length() {\n    return false\n  }\n  for i in 0..<prefix.length() {\n    if self.unsafe_get(i) != prefix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Tests if an array ends with the given suffix.\n///\n/// Parameters:\n///\n/// * `self` : The array to check.\n/// * `suffix` : The array to test against.\n///\n/// Returns `true` if the array ends with the given suffix, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// inspect(arr.ends_with([4, 5]), content=\"true\")\n/// inspect(arr.ends_with([3, 4]), content=\"false\")\n/// inspect(arr.ends_with([]), content=\"true\")\n/// let arr : Array[Int] = []\n/// inspect(arr.ends_with([]), content=\"true\")\n/// inspect(arr.ends_with([1]), content=\"false\")\n/// ```\npub fn[T : Eq] Array::ends_with(self : Array[T], suffix : Array[T]) -> Bool {\n  if suffix.length() > self.length() {\n    return false\n  }\n  for i in 0..<suffix.length() {\n    if self.unsafe_get(self.length() - suffix.length() + i) !=\n      suffix.unsafe_get(i) {\n      break false\n    }\n  } else {\n    true\n  }\n}\n\n///|\n/// Removes a prefix from an array if it exists.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove the prefix from.\n/// * `prefix` : The array to be removed from the beginning of `array`.\n///\n/// Returns `Some(array)` containing the remaining elements after removing the\n/// prefix if the array starts with the prefix, or `None` if the array doesn't\n/// start with the prefix.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// inspect(arr.strip_prefix([1, 2]), content=\"Some([3, 4, 5])\")\n/// inspect(arr.strip_prefix([2, 3]), content=\"None\")\n/// ```\npub fn[T : Eq] Array::strip_prefix(\n  self : Array[T],\n  prefix : Array[T],\n) -> Array[T]? {\n  if self.starts_with(prefix) {\n    let v = Array::make_uninit(self.length() - prefix.length())\n    UninitializedArray::unsafe_blit(\n      v.buffer(),\n      0,\n      self.buffer(),\n      prefix.length(),\n      self.length() - prefix.length(),\n    )\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Strip a suffix from the array.\n///\n/// If the array ends with the suffix, return the array before the suffix, otherwise return None.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let v2 = v.strip_suffix([5])\n///   assert_eq(v2, Some([3, 4]))\n/// ```\npub fn[T : Eq] Array::strip_suffix(\n  self : Array[T],\n  suffix : Array[T],\n) -> Array[T]? {\n  if self.ends_with(suffix) {\n    let v = Array::make_uninit(self.length() - suffix.length())\n    let len = self.length() - suffix.length()\n    UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), 0, len)\n    Some(v)\n  } else {\n    None\n  }\n}\n\n///|\n/// Searches for the first occurrence of a value in the array and returns its\n/// index.\n///\n/// Parameters:\n///\n/// * `self` : The array to search in.\n/// * `value` : The value to search for.\n///\n/// Returns an `Option` containing the index of the first occurrence of `value`\n/// if found, or `None` if the value is not present in the array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 2, 4]\n/// inspect(arr.search(2), content=\"Some(1)\") // first occurrence\n/// inspect(arr.search(5), content=\"None\") // not found\n/// ```\npub fn[T : Eq] Array::search(self : Array[T], value : T) -> Int? {\n  for i, v in self {\n    if v == value {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Search the index of the first element that satisfies the predicate.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = [1, 2, 3, 4, 5]\n///   match v.search_by((x) => { x == 3 }) {\n///     Some(index) => assert_eq(index, 2) // 2\n///     None => println(\"Not found\")\n///   }\n/// ```\n#locals(f)\n#alias(find_index, deprecated)\npub fn[T] Array::search_by(self : Array[T], f : (T) -> Bool) -> Int? {\n  for i, v in self {\n    if f(v) {\n      break Some(i)\n    }\n  } else {\n    None\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array to find the index of a given element.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let result = v.binary_search(3)\n///   assert_eq(result, Ok(0)) // The element 3 is found at index 0\n/// ```\n///\n/// # Arguments\n/// - `self`: The array in which to perform the search.\n/// - `value`: The element to search for in the array.\n///\n/// # Returns\n/// - `Result[Int, Int]`:\n/// If the element is found, an `Ok` variant is returned, containing the index of the matching element in the array.\n/// If there are multiple matches, the leftmost match will be returned.\n/// If the element is not found, an `Err` variant is returned, containing the index where the element could be inserted to maintain the sorted order.\n///\n/// # Notes\n/// - Ensure that the array is sorted in increasing order before calling this function.\n/// - If the array is not sorted, the returned result is undefined and should not be relied on.\npub fn[T : Compare] Array::binary_search(\n  self : Array[T],\n  value : T,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if self.unsafe_get(h) < value {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && self.unsafe_get(i) == value {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Performs a binary search on a sorted array using a custom comparison\n/// function. Returns the position of the matching element if found, or the\n/// position where the element could be inserted while maintaining the sorted\n/// order.\n///\n/// Parameters:\n///\n/// * `array` : The sorted array to search in.\n/// * `comparator` : A function that compares each element with the target value,\n/// returning:\n///  * A negative integer if the element is less than the target\n///  * Zero if the element equals the target\n///  * A positive integer if the element is greater than the target\n///\n/// Returns a `Result` containing either:\n///\n/// * `Ok(index)` if a matching element is found at position `index`\n/// * `Err(index)` if no match is found, where `index` is the position where the\n/// element could be inserted\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 3, 5, 7, 9]\n/// let find_3 = arr.binary_search_by(x => x.compare(3))\n/// inspect(find_3, content=\"Ok(1)\")\n/// let find_4 = arr.binary_search_by(x => x.compare(4))\n/// inspect(find_4, content=\"Err(2)\")\n/// ```\n///\n/// Notes:\n///\n/// * Assumes the array is sorted according to the ordering implied by the\n/// comparison function\n/// * For multiple matches, returns the leftmost matching position\n/// * Returns an insertion point that maintains the sort order when no match is\n/// found\n#locals(cmp)\npub fn[T] Array::binary_search_by(\n  self : Array[T],\n  cmp : (T) -> Int,\n) -> Result[Int, Int] {\n  let len = self.length()\n  for i = 0, j = len; i < j; {\n    let h = i + (j - i) / 2\n    // Note even if self[h] == value, we still continue the search\n    // because we want to find the leftmost match\n    if cmp(self.unsafe_get(h)) < 0 {\n      continue h + 1, j\n    } else {\n      continue i, h\n    }\n  } else {\n    if i < len && cmp(self.unsafe_get(i)) == 0 {\n      Ok(i)\n    } else {\n      Err(i)\n    }\n  }\n}\n\n///|\n/// Swaps the values at two positions in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array in which to swap elements.\n/// * `index1` : The index of the first element to be swapped.\n/// * `index2` : The index of the second element to be swapped.\n///\n/// This function will panic if either index is negative or greater than or equal to\n/// the length of the array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// arr.swap(0, 2)\n/// inspect(arr, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::swap(self : Array[T], i : Int, j : Int) -> Unit {\n  if i >= self.length() || j >= self.length() || i < 0 || j < 0 {\n    let len = self.length()\n    abort(\n      \"index out of bounds: the len is from 0 to \\{len} but the index is (\\{i}, \\{j})\",\n    )\n  }\n  let temp = self.unsafe_get(i)\n  self.unsafe_set(i, self.unsafe_get(j))\n  self.unsafe_set(j, temp)\n}\n\n///|\n/// Removes all elements from the array that do not satisfy the predicate\n/// function, modifying the array in place. The order of remaining elements is\n/// preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to be filtered.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.retain(x => x % 2 == 0)\n/// inspect(arr, content=\"[2, 4]\")\n/// let arr = [1, 2, 3]\n/// arr.retain(x => x > 10)\n/// inspect(arr, content=\"[]\")\n/// let arr = [1, 2, 3]\n/// arr.retain(_ => true)\n/// inspect(arr, content=\"[1, 2, 3]\")\n/// ```\n/// TODO: perf could be improved\n#locals(f)\npub fn[T] Array::retain(self : Array[T], f : (T) -> Bool raise?) -> Unit raise? {\n  let len = self.length()\n  for i = 0, j = 0; i < len; {\n    let item = self.unsafe_get(i)\n    if f(item) {\n      self.unsafe_set(j, item)\n      continue i + 1, j + 1\n    }\n    continue i + 1, j\n  } else {\n    // we use `else` here to capture `j`\n    self.unsafe_truncate_to_length(j)\n  }\n}\n\n///|\n/// Resizes an array to a specified length, either by truncating if the new\n/// length is smaller, or by appending copies of a default value if the new\n/// length is larger.\n///\n/// Parameters:\n///\n/// * `array` : The array to be resized.\n/// * `new_length` : The desired length of the array after resizing.\n/// * `default_value` : The value to append when extending the array.\n///\n/// Throws a panic if `new_length` is negative.\n///\n/// Examples:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.resize(3, 0)\n/// inspect(arr, content=\"[1, 2, 3]\")\n/// let arr = [1, 2, 3]\n/// arr.resize(5, 0)\n/// inspect(arr, content=\"[1, 2, 3, 0, 0]\")\n/// ```\n///\npub fn[T] Array::resize(self : Array[T], new_len : Int, f : T) -> Unit {\n  if new_len < 0 {\n    abort(\"negative new length\")\n  }\n  if new_len < self.length() {\n    self.unsafe_truncate_to_length(new_len)\n  } else {\n    let len = self.length()\n    for _ in len..<new_len {\n      self.push(f)\n    }\n  }\n}\n\n///|\n/// Flattens an array of arrays into an array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let v = [[3, 4], [5, 6]].flatten()\n/// assert_eq(v, [3, 4, 5, 6])\n/// ```\npub fn[T] Array::flatten(self : Array[Array[T]]) -> Array[T] {\n  let mut len = 0\n  for x in self {\n    len += x.length()\n  }\n  let res = Array::make_uninit(len)\n  let mut i = 0\n  for xs in self {\n    res.unsafe_blit(i, xs, 0, xs.length())\n    i += xs.length()\n  }\n  res\n}\n\n///|\n/// Create an array by repeat a given array for a given times.\n///\n/// Example:\n///\n/// ```mbt test\n/// let v = [3, 4].repeat(2)\n/// assert_eq(v, [3, 4, 3, 4])\n/// ```\npub fn[T] Array::repeat(self : Array[T], times : Int) -> Array[T] {\n  let v = Array::new(capacity=self.length() * times)\n  for i in 0..<times {\n    v.append(self)\n  }\n  v\n}\n\n///|\n/// Fold out values from an array according to certain rules.\n///\n/// Example:\n///\n/// ```mbt test\n/// let sum = [1, 2, 3, 4, 5].fold(init=0, (sum, elem) => sum + elem)\n/// assert_eq(sum, 15)\n/// ```\n#locals(f)\n#alias(fold_left, deprecated)\npub fn[A, B] Array::fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn.\n///\n/// Example:\n///\n/// ```mbt test\n/// let sum = [1, 2, 3, 4, 5].rev_fold(init=0, (sum, elem) => sum + elem)\n/// assert_eq(sum, 15)\n/// ```\n#locals(f)\n#alias(fold_right, deprecated)\npub fn[A, B] Array::rev_fold(\n  self : Array[A],\n  init~ : B,\n  f : (B, A) -> B raise?,\n) -> B raise? {\n  for i = self.length() - 1, acc = init; i >= 0; {\n    continue i - 1, f(acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules with index.\n///\n/// Example:\n///\n/// ```mbt test\n/// let sum = [1, 2, 3, 4, 5].foldi(init=0, (index, sum, _elem) => sum + index)\n/// assert_eq(sum, 10)\n/// ```\n#locals(f)\n#alias(fold_lefti, deprecated)\npub fn[A, B] Array::foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  for i = 0, acc = init; i < self.length(); {\n    continue i + 1, f(i, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Fold out values from an array according to certain rules in reversed turn with index.\n///\n/// Example:\n///\n/// ```mbt test\n/// let sum = [1, 2, 3, 4, 5].rev_foldi(init=0, (index, sum, _elem) => sum + index)\n/// assert_eq(sum, 10)\n/// ```\n#locals(f)\n#alias(fold_righti, deprecated)\npub fn[A, B] Array::rev_foldi(\n  self : Array[A],\n  init~ : B,\n  f : (Int, B, A) -> B raise?,\n) -> B raise? {\n  let len = self.length()\n  for i = len - 1, acc = init; i >= 0; {\n    continue i - 1, f(len - i - 1, acc, self[i])\n  } else {\n    acc\n  }\n}\n\n///|\n/// Removes consecutive duplicate elements from an array in-place, using equality\n/// comparison. The first occurrence of each element is retained while subsequent\n/// equal elements are removed.\n///\n/// Parameters:\n///\n/// * `array` : The array to remove duplicates from. Must contain elements that\n/// implement the `Eq` trait for equality comparison.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 2, 3, 3, 3, 2]\n/// arr.dedup()\n/// inspect(arr, content=\"[1, 2, 3, 2]\")\n/// let arr = [1, 2, 2, 2, 3, 3]\n/// arr.dedup()\n/// inspect(arr, content=\"[1, 2, 3]\")\n/// let arr : Array[Int] = []\n/// arr.dedup()\n/// inspect(arr, content=\"[]\")\n/// ```\n///\n/// Note: For best results when removing all duplicates regardless of position,\n/// sort the array before calling this function. When used on an unsorted array,\n/// this function only removes consecutive duplicates.\npub fn[T : Eq] Array::dedup(self : Array[T]) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let mut w = 1\n  for i in 1..<self.length() {\n    if self[i] != self[w - 1] {\n      self[w] = self[i]\n      w = w + 1\n    }\n  }\n  self.unsafe_truncate_to_length(w)\n}\n\n///|\n/// Extracts elements from an array that satisfy a given predicate function. The\n/// extracted elements are removed from the original array and returned as a new\n/// array. The relative order of the extracted elements is preserved.\n///\n/// Parameters:\n///\n/// * `array` : The array to extract elements from.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be extracted, `false` otherwise.\n///\n/// Returns a new array containing all elements that satisfy the predicate\n/// function, in the order they appeared in the original array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// let extracted = arr.extract_if(x => x % 2 == 0)\n/// inspect(extracted, content=\"[2, 4]\")\n/// inspect(arr, content=\"[1, 3, 5]\")\n/// ```\n#locals(f)\npub fn[T] Array::extract_if(self : Array[T], f : (T) -> Bool) -> Array[T] {\n  let removed = []\n  let mut write = 0\n  for read in 0..<self.length() {\n    let elem = self[read]\n    if f(elem) {\n      removed.push(elem)\n    } else {\n      if read != write {\n        self[write] = elem\n      }\n      write += 1\n    }\n  }\n  self.truncate(write)\n  removed\n}\n\n///|\n/// Divides an array into smaller arrays (chunks) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be divided into chunks.\n/// * `size` : The size of each chunk. Must be a positive integer, otherwise it will panic.\n///\n///\n/// Returns an array of arrays, where each inner array is a chunk containing\n/// elements from the original array. If the length of the original array is not\n/// divisible by the chunk size, the last chunk will contain fewer elements.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// let chunks = arr.chunks(2)\n/// inspect(chunks, content=\"[[1, 2], [3, 4], [5]]\")\n/// let arr : Array[Int] = []\n/// inspect(arr.chunks(3), content=\"[]\")\n/// ```\npub fn[T] Array::chunks(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length()\n  if len == 0 {\n    return []\n  }\n  let num_chunks = (len + size - 1) / size\n  Array::makei(num_chunks, i => {\n    let start = i * size\n    let end = Int::min(start + size, len)\n    self[start:end]\n  })\n}\n\n///|\n/// Groups consecutive elements of the array into chunks where adjacent elements\n/// satisfy the given predicate function.\n///\n/// Parameters:\n///\n/// * `array` : The array to be chunked.\n/// * `predicate` : A function that takes two adjacent elements and returns\n/// `true` if they should be in the same chunk, `false` otherwise.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that satisfy the predicate with their adjacent elements.\n///\n/// Example:\n///\n/// ```mbt test\n/// let v = [1, 1, 2, 3, 2, 3, 2, 3, 4]\n/// let chunks = v.chunk_by((x, y) => x <= y)\n/// inspect(chunks, content=\"[[1, 1, 2, 3], [2, 3], [2, 3, 4]]\")\n/// let v : Array[Int] = []\n/// inspect(v.chunk_by((x, y) => x <= y), content=\"[]\")\n/// ```\n#locals(pred)\npub fn[T] Array::chunk_by(\n  self : Array[T],\n  pred : (T, T) -> Bool raise?,\n) -> Array[ArrayView[T]] raise? {\n  let chunks = []\n  if self.is_empty() {\n    return chunks\n  }\n  let mut start = 0\n  for i in 1..<self.length() {\n    if !pred(self[i - 1], self[i]) {\n      chunks.push(self[start:i])\n      start = i\n    }\n  }\n  chunks.push(self[start:self.length()])\n  chunks\n}\n\n///|\n/// Generates overlapping subslices (sliding windows) of the specified size.\n///\n/// Parameters:\n///\n/// * `array` : The array to be processed with sliding windows.\n/// * `size` : The window length. Must be a positive integer, otherwise it will panic.\n///\n/// Returns an array of slices, where each inner slice is a contiguous subslice\n/// of the original array. Windows are produced with a step size of 1. If the\n/// original array's length is less than the specified window size, the result\n/// will be an empty array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// let windows = arr.windows(2)\n/// inspect(windows, content=\"[[1, 2], [2, 3], [3, 4], [4, 5]]\")\n/// let arr = [1, 2]\n/// inspect(arr.windows(3), content=\"[]\")\n/// ```\npub fn[T] Array::windows(self : Array[T], size : Int) -> Array[ArrayView[T]] {\n  guard size > 0\n  let len = self.length() - size + 1\n  if len < 1 {\n    return []\n  }\n  Array::makei(len, i => self[i:i + size])\n}\n\n///|\npub fn[T] Array::suffixes(\n  self : Array[T],\n  include_empty? : Bool = false,\n) -> Iterator[ArrayView[T]] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\n/// Splits an array into chunks using a predicate function. Creates chunks by\n/// grouping consecutive elements that do not satisfy the predicate function.\n/// Elements that satisfy the predicate function are excluded from the resulting\n/// chunks and act as delimiters.\n///\n/// Parameters:\n///\n/// * `array` : The array to be split into chunks.\n/// * `predicate` : A function that takes an element and returns `true` if the\n/// element should be used as a delimiter.\n///\n/// Returns an array of arrays, where each inner array is a chunk of consecutive\n/// elements that do not satisfy the predicate.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 0, 2, 0, 3, 0, 4]\n/// inspect(arr.split(x => x == 0), content=\"[[1], [2], [3], [4]]\")\n/// let arr = [0, 1, 0, 0, 2, 0]\n/// inspect(arr.split(x => x == 0), content=\"[[], [1], [], [2]]\")\n/// ```\n#locals(pred)\npub fn[T] Array::split(\n  self : Array[T],\n  pred : (T) -> Bool raise?,\n) -> Array[Array[T]] raise? {\n  let chunks = []\n  let mut i = 0\n  while i < self.length() {\n    let chunk = []\n    while i < self.length() && !pred(self[i]) {\n      chunk.push(self[i])\n      i = i + 1\n    }\n    chunks.push(chunk)\n    i = i + 1\n  }\n  chunks\n}\n\n///|\n/// Creates an iterator over the elements of the array.\n///\n/// Parameters:\n///\n/// * `array` : The array to create an iterator from.\n///\n/// Returns an iterator that yields each element of the array in order.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// let mut sum = 0\n/// arr.iter().each(x => sum = sum + x)\n/// inspect(sum, content=\"6\")\n/// ```\npub fn[T] Array::iter(self : Array[T]) -> Iter[T] {\n  self.iterator().iter()\n}\n\n///|\n/// Returns an iterator that yields elements from the array in reverse order,\n/// from the last element to the first.\n///\n/// Parameters:\n///\n/// * `array` : The array to iterate over in reverse order.\n///\n/// Returns an iterator that yields each element of the array, starting from the\n/// last element and moving towards the first.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// let result = []\n/// arr.rev_iter().each(x => result.push(x))\n/// inspect(result, content=\"[3, 2, 1]\")\n/// ```\npub fn[T] Array::rev_iter(self : Array[T]) -> Iter[T] {\n  self.rev_iterator().iter()\n}\n\n///|\n/// Returns an iterator that provides both indices and values of the array in\n/// order.\n///\n/// Parameters:\n///\n/// * `self` : The array to iterate over.\n///\n/// Returns an iterator that yields tuples of index and value pairs, where\n/// indices start from 0.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [10, 20, 30]\n/// let mut sum = 0\n/// arr.iter2().each((i, x) => sum = sum + i + x)\n/// inspect(sum, content=\"63\") // (0 + 10) + (1 + 20) + (2 + 30) = 63\n/// ```\npub fn[A] Array::iter2(self : Array[A]) -> Iter2[Int, A] {\n  self.iterator2().iter2()\n}\n\n///|\n/// Creates a new empty array.\n///\n/// Returns an empty array of type `Array[T]`.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr : Array[Int] = Array::default()\n/// inspect(arr.length(), content=\"0\")\n/// inspect(arr.is_empty(), content=\"true\")\n/// ```\npub impl[T] Default for Array[T] with default() {\n  []\n}\n\n///|\n/// Removes a back element from an array.\n///\n/// # Example\n/// ```mbt\n///   let array = [1, 2, 3, 4, 5]\n///   array.unsafe_pop_back()\n///   assert_eq(array.last(), Some(4))\n/// ```\n#internal(unsafe, \"Panic if the array is empty on non-JS backend.\")\n#doc(hidden)\npub fn[A] Array::unsafe_pop_back(self : Array[A]) -> Unit {\n  self.unsafe_pop() |> ignore\n}\n\n///|\n/// Truncates the array in-place to the specified length.\n///\n/// If `len` is greater than or equal to the current array length,\n/// the function does nothing. If `len` is 0, the array is cleared.\n/// Otherwise, removes elements from the end until the array reaches the given length.\n///\n/// Parameters:\n///\n/// * `self` : The target array (modified in-place).\n/// * `len` : The new desired length (must be non-negative).\n///\n/// Important:\n///   - If `len` is negative, the function does nothing.\n///   - If `len` exceeds current length, the array remains unchanged.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.truncate(3)\n/// inspect(arr, content=\"[1, 2, 3]\")\n/// ```\npub fn[A] Array::truncate(self : Array[A], len : Int) -> Unit {\n  guard len >= 0 && len < self.length() else { return }\n  self.unsafe_truncate_to_length(len)\n}\n\n///|\n/// In-place filter and map for Array\n///\n/// # Example\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.retain_map(fn(x) { if x % 2 == 0 { Some(x * 2) } else { None } })\n/// inspect(arr, content=\"[4, 8]\")\n/// ```\npub fn[A] Array::retain_map(self : Array[A], f : (A) -> A?) -> Unit {\n  if self.is_empty() {\n    return\n  }\n  let buf = self.buffer()\n  let len = self.length()\n  let mut write_idx = 0\n  for read_idx in 0..<len {\n    let val = buf[read_idx]\n    match f(val) {\n      Some(new_val) => {\n        buf[write_idx] = new_val\n        write_idx += 1\n      }\n      None => ()\n    }\n  }\n  self.unsafe_truncate_to_length(write_idx)\n}\n\n///|\n/// Creates a new array containing all elements from an iterator.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator containing elements of type `T`.\n///\n/// Returns a new array containing all elements from the iterator in the same\n/// order.\n///\n/// Example:\n///\n/// ```mbt test\n/// let iter = Iter::singleton(42)\n/// let arr = Array::from_iter(iter)\n/// inspect(arr, content=\"[42]\")\n/// ```\npub fn[T] Array::from_iter(iter : Iter[T]) -> Array[T] {\n  iter.collect()\n}\n\n///|\n/// Creates a new array containing all elements from an iterator.\n///\n/// Parameters:\n///\n/// * `iter` : An iterator containing elements of type `T`.\n///\n/// Returns a new array containing all elements from the iterator in the same\n/// order.\n///\n/// Example:\n///\n/// ```mbt test\n/// let iter = Iterator::singleton(42)\n/// let arr = Array::from_iterator(iter)\n/// inspect(arr, content=\"[42]\")\n/// ```\npub fn[T] Array::from_iterator(iter : Iterator[T]) -> Array[T] {\n  iter.collect()\n}\n\n///|\n/// Adds all elements from an iterator to the end of the array.\n///\n/// This function iterates over each element in the provided iterator\n/// and adds them to the array using the `push` method.\n///\n/// # Example\n/// ```mbt\n///   let u = [1, 2, 3]\n///   let v = [4, 5, 6]\n///   u.push_iter(v.iter())\n///   assert_eq(u, [1, 2, 3, 4, 5, 6])\n/// ```\npub fn[T] Array::push_iter(self : Self[T], iter : Iter[T]) -> Unit {\n  // This function used by [Array spread operator](https://docs.moonbitlang.com/en/latest/language/fundamentals.html#spread-operator)\n  // it can't be removed and deprecated\n  for x in iter {\n    self.push(x)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt test\n/// let arr = [1, 2, 3, 4, 5]\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// Array::shuffle_in_place(arr, rand~)\n/// ```\npub fn[T] Array::shuffle_in_place(\n  self : Array[T],\n  rand~ : (Int) -> Int,\n) -> Unit {\n  let n = self.length()\n  for i = n - 1; i > 0; i = i - 1 {\n    let j = rand(i + 1) % (i + 1)\n    // for safety, perf is not a concern here\n    // TODO: maybe return an error later\n    self.swap(i, j)\n  }\n}\n\n///|\n/// Shuffle the array using Knuth shuffle\n///\n/// To use this function, you need to provide a rand function, which takes an integer as it upper bound\n/// and returns an integer.\n/// *rand n* is expected to returns a uniformly distribution integer between 0 and n - 1\n/// # Example\n///\n/// ```mbt\n/// let arr = [1, 2, 3, 4, 5]\n///\n/// fn rand(upper : Int) -> Int {\n///   let rng = @random.Rand::new()\n///   rng.int(limit=upper)\n/// }\n///\n/// let _shuffled = Array::shuffle(arr, rand~)\n/// ```\npub fn[T] Array::shuffle(self : Array[T], rand~ : (Int) -> Int) -> Array[T] {\n  let new_arr = self.copy()\n  Array::shuffle_in_place(new_arr, rand~)\n  new_arr\n}\n\n///|\n/// Returns a new array containing the elements of the original array that satisfy the given predicate.\n///\n/// # Arguments\n///\n/// * `self` - The array to filter.\n/// * `f` - The predicate function.\n///\n/// # Returns\n///\npub fn[A, B] Array::filter_map(\n  self : Array[A],\n  f : (A) -> B? raise?,\n) -> Array[B] raise? {\n  let result = []\n  for x in self {\n    if f(x) is Some(x) {\n      result.push(x)\n    }\n  }\n  result\n}\n\n///|\n/// Returns the last element of the array, or `None` if the array is empty.\n///\n/// Parameters:\n///\n/// * `array` : The array to get the last element from.\n///\n/// Returns an optional value containing the last element of the array. The\n/// result is `None` if the array is empty, or `Some(x)` where `x` is the last\n/// element of the array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// inspect(arr.last(), content=\"Some(3)\")\n/// let empty : Array[Int] = []\n/// inspect(empty.last(), content=\"None\")\n/// ```\npub fn[A] Array::last(self : Array[A]) -> A? {\n  match self {\n    [] => None\n    [.., last] => Some(last)\n  }\n}\n\n///|\n/// Zips two arrays into a single array of tuples.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an array of tuples, where each tuple contains corresponding elements\n/// from the two input arrays.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr1 = [1, 2, 3]\n/// let arr2 = ['a', 'b', 'c']\n/// inspect(arr1.zip(arr2), content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\")\n/// ```\npub fn[A, B] Array::zip(self : Array[A], other : Array[B]) -> Array[(A, B)] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  Array::makei(length, i => (self[i], other[i]))\n}\n\n///|\n/// Splits an array of pairs into two arrays, separating the first and second elements.\n///\n/// # Example\n/// ```mbt test\n/// let arr = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n/// let (nums, strs) = arr.unzip()\n/// inspect(nums, content=\"[1, 2, 3]\")\n/// inspect(strs, content=\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\")\n/// ```\npub fn[T1, T2] Array::unzip(self : Array[(T1, T2)]) -> (Array[T1], Array[T2]) {\n  let arr1 : Array[T1] = Array::new(capacity=self.length())\n  let arr2 : Array[T2] = Array::new(capacity=self.length())\n  for pair in self {\n    let (x, y) = pair\n    arr1.push(x)\n    arr2.push(y)\n  }\n  (arr1, arr2)\n}\n\n///|\n/// Zips two arrays into an iterator that yields corresponding elements.\n///\n/// Parameters:\n///\n/// * `self` : The first array.\n/// * `other` : The second array.\n///\n/// Returns an `Iter2` iterator that produces corresponding elements\n/// from both arrays. The iteration continues until the shorter array is exhausted.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr1 = [1, 2, 3]\n/// let arr2 = ['a', 'b', 'c']\n/// inspect(\n///   arr1.zip_to_iter2(arr2).to_array(),\n///   content=\"[(1, 'a'), (2, 'b'), (3, 'c')]\",\n/// )\n/// ```\npub fn[A, B] Array::zip_to_iter2(\n  self : Array[A],\n  other : Array[B],\n) -> Iter2[A, B] {\n  let length = if self.length() < other.length() {\n    self.length()\n  } else {\n    other.length()\n  }\n  let mut i = 0\n  Iterator2::new(() => {\n    guard i < length else { None }\n    let elem = (self[i], other[i])\n    i += 1\n    Some(elem)\n  }).iter2()\n}\n\n///|\n/// Join an array of strings using the provided `separator`.\n///\n/// Parameters:\n///   * `separator` : The string inserted between each element.\n///\n/// Returns a single concatenated `String`.\n/// # Example:\n/// ```mbt test\n/// let s = \"hello world\"\n/// inspect(s.split(\" \").to_array().join(\":\"), content=\"hello:world\")\n/// ```\npub fn[A : ToStringView] Array::join(\n  self : Array[A],\n  separator : StringView,\n) -> String {\n  self[:].join(separator)\n}\n\n///|\npub fn[X] Array::iterator(self : Array[X]) -> Iterator[X] {\n  self[:].iterator()\n}\n\n///|\npub fn[X] Array::rev_iterator(self : Array[X]) -> Iterator[X] {\n  self[:].rev_iterator()\n}\n\n///|\npub fn[X] Array::iterator2(self : Array[X]) -> Iterator2[Int, X] {\n  self[:].iterator2()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a source code location in a MoonBit program, containing\n/// information about the file path, line number, and column number. Used\n/// internally by the compiler for error reporting and debugging purposes.\n///\n/// This type is public to all packages but its internal representation is\n/// opaque. Users cannot construct values of this type directly; they are\n/// automatically created by the compiler when needed.\n/// TODO: can not make a dummy loc\npub(all) type SourceLoc\n\n///|\n/// Converts a source location to its string representation.\n///\n/// Parameters:\n///\n/// * `source_location` : A source code location containing information about the\n/// file path, line number, and column number.\n///\n/// Returns a string representation of the source location, typically in the\n/// format \"@package:file:start_line:start_column-end_line:end_column\".\n///\n/// Note: This function is primarily used internally by the compiler for error\n/// reporting and debugging purposes. Source locations are automatically created\n/// by the compiler when needed.\nfn SourceLoc::repr(self : Self) -> String = \"%loc_to_string\"\n\n///|\npub impl Show for SourceLoc with output(self, logger) {\n  SourceLocRepr::parse(self.repr()).output(logger)\n}\n\n///|\npriv struct SourceLocRepr {\n  pkg : StringView\n  filename : StringView\n  start_line : StringView\n  start_column : StringView\n  end_line : StringView\n  end_column : StringView\n}\n\n///|\nimpl Show for SourceLocRepr with output(self, logger) {\n  let pkg = self.pkg\n  let (module_name, package_name) = {\n    guard pkg.find(\"/\") is Some(first_slash) else { (pkg, None) }\n    guard pkg.view(start_offset=first_slash + 1).find(\"/\") is Some(second_slash) else {\n      (pkg, None)\n    }\n    let module_name_end = first_slash + 1 + second_slash\n    (\n      pkg.view(end_offset=module_name_end),\n      Some(pkg.view(start_offset=module_name_end + 1)),\n    )\n  }\n  if package_name is Some(pkg_name) {\n    logger..write_view(pkg_name)..write_char('/')\n  }\n  logger\n  ..write_view(self.filename)\n  ..write_char(':')\n  ..write_view(self.start_line)\n  ..write_char(':')\n  ..write_view(self.start_column)\n  ..write_char('-')\n  ..write_view(self.end_line)\n  ..write_char(':')\n  ..write_view(self.end_column)\n  ..write_char('@')\n  ..write_view(module_name)\n}\n\n///|\nfn SourceLocRepr::parse(repr : String) -> SourceLocRepr {\n  fn parse_loc(view : StringView) -> (StringView, StringView)? {\n    guard view.find(\":\") is Some(i) else { None }\n    guard i > 0 && i + 1 < view.length() else { None }\n    Some((view.view(end_offset=i), view.view(start_offset=i + 1)))\n  }\n  // extract package name\n  guard repr is ['@', .. rest]\n  guard rest.find(\":\") is Some(pkg_end)\n  let pkg = rest.view(start_offset=0, end_offset=pkg_end)\n\n  // extract end location in reverse\n  guard rest.rev_find(\"-\") is Some(start_loc_end)\n  guard start_loc_end + 1 < rest.length()\n  let end_loc = rest.view(start_offset=start_loc_end + 1)\n  guard parse_loc(end_loc) is Some((end_line, end_column))\n  let rest = rest.view(end_offset=start_loc_end)\n\n  // extract start location\n  guard rest.rev_find(\":\") is Some(start_line_end) &&\n    rest.view(end_offset=start_line_end).rev_find(\":\") is Some(filename_end)\n  guard filename_end + 1 < rest.length()\n  let start_loc = rest.view(start_offset=filename_end + 1)\n  guard parse_loc(start_loc) is Some((start_line, start_column))\n\n  // everything else remaining is treated as filename\n  guard filename_end > pkg_end + 1\n  let filename = rest.view(start_offset=pkg_end + 1, end_offset=filename_end)\n  { pkg, filename, start_line, start_column, end_line, end_column }\n}\n\n///|\nfn SourceLocRepr::to_json_string(self : SourceLocRepr) -> String {\n  StringBuilder::new()\n  ..write_string(\"{\\\"pkg\\\":\\\"\\{self.pkg}\\\"\")\n  ..write_string(\",\\\"filename\\\":\")\n  ..write_object(self.filename)\n  ..write_string(\",\\\"start_line\\\":\\{self.start_line}\")\n  ..write_string(\",\\\"start_column\\\":\\{self.start_column}\")\n  ..write_string(\",\\\"end_line\\\":\\{self.end_line}\")\n  ..write_string(\",\\\"end_column\\\":\\{self.end_column}}\")\n  .to_string()\n}\n\n///|\n/// Convert a source location to a JSON string\npub fn SourceLoc::to_json_string(self : SourceLoc) -> String {\n  SourceLocRepr::parse(self.repr()).to_json_string()\n}\n\n///|\n/// Represents a type for storing argument locations in source code. It is an\n/// array of optional source locations, where each element corresponds to an\n/// argument's location in the source code. Used internally by the compiler for\n/// error reporting and debugging purposes.\npub(all) struct ArgsLoc(Array[SourceLoc?]) derive(Show)\n\n///|\n/// Converts an array of optional source locations to its JSON string\n/// representation. Each location in the array is either represented as a string\n/// if present, or \"null\" if absent.\n///\n/// Parameters:\n///\n/// * `self` : The array of optional source locations to be converted.\n///\n/// Returns a JSON array string where each element is either a string\n/// representation of a source location or \"null\".\npub fn ArgsLoc::to_json(self : ArgsLoc) -> String {\n  let buf = StringBuilder::new(size_hint=10)\n  let ArgsLoc(self) = self\n  buf.write_char('[')\n  for i in 0..<self.length() {\n    if i != 0 {\n      buf.write_string(\", \")\n    }\n    let item = self[i]\n    match item {\n      None => buf.write_string(\"null\")\n      Some(loc) => buf.write_string(loc.to_json_string())\n    }\n  }\n  buf.write_char(']')\n  buf.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn println_mono(s : String) -> Unit = \"%println\"\n\n///|\nfn[T] any_to_string(any : T) -> String = \"%any.to_string\"\n\n///|\n/// Prints any value that implements the `Show` trait to the standard output,\n/// followed by a newline.\n///\n/// Parameters:\n///\n/// * `value` : The value to be printed. Must implement the `Show` trait.\n///\n/// Example:\n///\n/// ```mbt\n///   println(42)\n///   println(\"Hello, World!\")\n///   println([1, 2, 3])\n/// ```\npub fn[T : Show] println(input : T) -> Unit {\n  println_mono(input.to_string())\n}\n\n///|\n/// Represents an error type used by the `inspect` function to indicate failures\n/// in value inspection. Contains a string message describing the nature of the\n/// inspection failure.\n///\n/// Returns a type constructor that creates an error type from a string message.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x : Int = 42\n/// inspect(x, content=\"42\") // Raises InspectError with detailed failure message\n/// ```\npub(all) suberror InspectError String\n\n///|\nfn base64_encode(data : FixedArray[Byte]) -> String {\n  let base64 = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n  let buf = StringBuilder::new()\n  let len = data.length()\n  let rem = len % 3\n  for i = 0; i < len - rem; i = i + 3 {\n    let b0 = data[i].to_int()\n    let b1 = data[i + 1].to_int()\n    let b2 = data[i + 2].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[((b1 & 0x0F) << 2) | ((b2 & 0xC0) >> 6)]\n    let x3 = base64[b2 & 0x3F]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char(x3.to_char())\n  }\n  if rem == 1 {\n    let b0 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[(b0 & 0x03) << 4]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char('=')\n    buf.write_char('=')\n  } else if rem == 2 {\n    let b0 = data[len - 2].to_int()\n    let b1 = data[len - 1].to_int()\n    let x0 = base64[(b0 & 0xFC) >> 2]\n    let x1 = base64[((b0 & 0x03) << 4) | ((b1 & 0xF0) >> 4)]\n    let x2 = base64[(b1 & 0x0F) << 2]\n    buf.write_char(x0.to_char())\n    buf.write_char(x1.to_char())\n    buf.write_char(x2.to_char())\n    buf.write_char('=')\n  }\n  buf.to_string()\n}\n\n///|\nfn base64_encode_string_codepoint(s : String) -> String {\n  // the input string is expected to be valid utf-16 string\n  let codepoint_length = s.char_length()\n  let data : FixedArray[Byte] = FixedArray::make(codepoint_length * 4, 0)\n  for i = 0, utf16_index = 0\n      i < codepoint_length\n      i = i + 1, utf16_index = utf16_index + 1 {\n    let c = s.unsafe_char_at(utf16_index).to_int()\n    if c > 0xFFFF {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = ((c >> 16) & 0xFF).to_byte()\n      data[i * 4 + 3] = ((c >> 24) & 0xFF).to_byte()\n      continue i + 1, utf16_index + 2\n    } else {\n      data[i * 4] = (c & 0xFF).to_byte()\n      data[i * 4 + 1] = ((c >> 8) & 0xFF).to_byte()\n      data[i * 4 + 2] = 0\n      data[i * 4 + 3] = 0\n    }\n  }\n  base64_encode(data)\n}\n\n///|\ntest {\n  inspect(base64_encode_string_codepoint(\"\"))\n  inspect(base64_encode_string_codepoint(\"a\"), content=\"YQAAAA==\")\n  inspect(base64_encode_string_codepoint(\"ab\"), content=\"YQAAAGIAAAA=\")\n  inspect(base64_encode_string_codepoint(\"abc\"), content=\"YQAAAGIAAABjAAAA\")\n  inspect(\n    base64_encode_string_codepoint(\"abcd\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"abcde\"),\n    content=\"YQAAAGIAAABjAAAAZAAAAGUAAAA=\",\n  )\n  inspect(base64_encode_string_codepoint(\"aä¸­\"), content=\"YQAAAC1OAAA=\")\n  inspect(\n    base64_encode_string_codepoint(\"aä¸­ğŸ¤£\"),\n    content=\"YQAAAC1OAAAj+QEA\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"aä¸­ğŸ¤£a\"),\n    content=\"YQAAAC1OAAAj+QEAYQAAAA==\",\n  )\n  inspect(\n    base64_encode_string_codepoint(\"aä¸­ğŸ¤£ä¸­\"),\n    content=\"YQAAAC1OAAAj+QEALU4AAA==\",\n  )\n}\n\n///|\n/// Tests if the string representation of an object matches the expected content.\n/// Used primarily in test cases to verify the correctness of `Show`\n/// implementations and program outputs.\n///\n/// Parameters:\n///\n/// * `object` : The object to be inspected. Must implement the `Show` trait.\n/// * `content` : The expected string representation of the object. Defaults to\n/// an empty string.\n/// * `location` : Source code location information for error reporting.\n/// Automatically provided by the compiler.\n/// * `arguments_location` : Location information for function arguments in\n/// source code. Automatically provided by the compiler.\n///\n/// Throws an `InspectError` if the actual string representation of the object\n/// does not match the expected content. The error message includes detailed\n/// information about the mismatch, including source location and both expected\n/// and actual values.\n///\n/// Example:\n///\n/// ```mbt test skip\n/// inspect(42, content=\"42\")\n/// inspect(\"hello\", content=\"hello\")\n/// inspect([1, 2, 3], content=\"[1, 2, 3]\")\n/// ```\n#callsite(autofill(args_loc, loc))\npub fn inspect(\n  obj : &Show,\n  content? : String = \"\",\n  loc~ : SourceLoc,\n  args_loc~ : ArgsLoc,\n) -> Unit raise InspectError {\n  let actual = obj.to_string()\n  if actual != content {\n    let loc = loc.to_json_string()\n    let args_loc = args_loc.to_json()\n    let expect_escaped = content.escape()\n    let actual_escaped = actual.escape()\n    let expect_base64 = \"\\\"\\{base64_encode_string_codepoint(content)}\\\"\"\n    let actual_base64 = \"\\\"\\{base64_encode_string_codepoint(actual)}\\\"\"\n    raise InspectError(\n      \"@EXPECT_FAILED {\\\"loc\\\": \\{loc}, \\\"args_loc\\\": \\{args_loc}, \\\"expect\\\": \\{expect_escaped}, \\\"actual\\\": \\{actual_escaped}, \\\"expect_base64\\\": \\{expect_base64}, \\\"actual_base64\\\": \\{actual_base64}}\",\n    )\n  }\n}\n\n///|\n/// Represents an error that occurs during snapshot testing. Contains a string\n/// message describing the error.\n///\n/// Used internally by the test driver to handle snapshot-related errors. Not\n/// intended for direct use by end users.\n///\n/// Example:\n///\n/// ```mbt test\n/// let err : SnapshotError = SnapshotError(\"failed to load snapshot\")\n/// match err {\n///   SnapshotError(msg) => assert_eq(msg, \"failed to load snapshot\")\n/// }\n/// ```\npub(all) suberror SnapshotError String\n\n///|\npub(all) suberror BenchError String\n\n///|\ntest \"panic error case of inspect\" {\n  let x : Int = 42\n  inspect(x, content=\"100\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nconst GPRIME1 : UInt = 0x9E3779B1\n\n///|\nconst GPRIMES2 : UInt = 0x85EBCA77\n\n///|\nconst GPRIME3 : UInt = 0xC2B2AE3D\n\n///|\nconst GPRIME4 : UInt = 0x27D4EB2F\n\n///|\nconst GPRIME5 : UInt = 0x165667B1\n\n///|\n/// Represents a hasher that implements the xxHash32 algorithm. The hasher\n/// maintains a mutable accumulator that is updated with each value added to the\n/// hash computation.\n///\n/// This struct provides methods for combining different types of values into a\n/// single hash value, making it suitable for implementing hash functions for\n/// custom types.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_int(42)\n/// hasher.combine_string(\"hello\")\n/// inspect(hasher.finalize(), content=\"860601284\")\n/// ```\nstruct Hasher {\n  mut acc : UInt\n}\n\n///|\n/// Creates a new hasher with an optional seed value.\n///\n/// Parameters:\n///\n/// * `seed` : An integer value used to initialize the hasher's internal state.\n/// Defaults to 0.\n///\n/// Returns a new `Hasher` instance initialized with the given seed value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let h1 = Hasher::new(seed=0) // Create a hasher with default seed\n/// let h2 = Hasher::new(seed=42) // Create a hasher with custom seed\n/// let x = 123\n/// h1.combine(x)\n/// h2.combine(x)\n/// inspect(h1.finalize() != h2.finalize(), content=\"true\") // Different seeds produce different hashes\n/// ```\npub fn Hasher::new(seed? : Int = seed) -> Hasher {\n  { acc: seed.reinterpret_as_uint() + GPRIME5 }\n}\n\n///|\n#cfg(not(target=\"js\"))\nlet seed : Int = 0\n\n///|\n#cfg(target=\"js\")\nlet seed : Int = random_seed()\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn random_seed() -> Int =\n  #|() => {\n  #|  if (globalThis.crypto?.getRandomValues) {\n  #|    const array = new Uint32Array(1);\n  #|    globalThis.crypto.getRandomValues(array);\n  #|    return array[0] | 0; // Convert to signed 32\n  #|  } else {\n  #|    return Math.floor(Math.random() * 0x100000000) | 0; // Fallback to Math.random\n  #|  }\n  #|}\n\n///|\n/// Combines a hashable value with the current state of the hasher. This is\n/// typically used to incrementally build a hash value from multiple components.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The value to be combined with the current hash state. Must\n/// implement the `Hash` trait.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine(42)\n/// hasher.combine(\"hello\")\n/// inspect(hasher.finalize(), content=\"860601284\")\n/// ```\npub fn[T : Hash] Hasher::combine(self : Hasher, value : T) -> Unit {\n  value.hash_combine(self)\n}\n\n///|\n/// Combines the unit value (i.e., `()`) into the hasher's internal state by\n/// hashing it as an integer value of 0.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to combine the unit value into.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_unit()\n/// inspect(hasher.finalize(), content=\"148298089\")\n/// ```\npub fn Hasher::combine_unit(self : Hasher) -> Unit {\n  self.combine_uint(0)\n}\n\n///|\n/// Combines a boolean value into the current hash state. The boolean value is\n/// converted to an integer (1 for true, 0 for false) before being combined with\n/// the hash.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The boolean value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_bool(true)\n/// inspect(hasher.finalize(), content=\"-205818221\")\n/// ```\npub fn Hasher::combine_bool(self : Hasher, value : Bool) -> Unit {\n  self.combine_uint(if value { 1 } else { 0 })\n}\n\n///|\n/// Combines a 32-bit integer value into the hasher's internal state. The value\n/// is processed\n/// as a 4-byte sequence, and the internal accumulator is updated accordingly.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : A 32-bit integer value to be incorporated into the hash.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_int(42)\n/// inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_int(self : Hasher, value : Int) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\n/// Combines a 64-bit integer value into the hash state by splitting it into two\n/// 32-bit parts and processing them separately. This method is used internally\n/// by the hash implementation to incorporate 64-bit integers into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object whose internal state will be updated.\n/// * `value` : The 64-bit integer value to be incorporated into the hash state.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_int64(42L)\n/// inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_int64(self : Hasher, value : Int64) -> Unit {\n  self.acc += 8\n  self.consume4(value.reinterpret_as_uint64().to_uint())\n  self.consume4((value.reinterpret_as_uint64() >> 32).to_uint())\n}\n\n///|\n/// Combines an unsigned 32-bit integer into the hasher's internal state by\n/// reinterpreting it as a signed integer and incorporating it into the hash\n/// computation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update.\n/// * `value` : The unsigned 32-bit integer value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_uint(42U)\n/// inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub fn Hasher::combine_uint(self : Hasher, value : UInt) -> Unit {\n  self.acc += 4\n  self.consume4(value)\n}\n\n///|\n/// Combines a 64-bit unsigned integer into the hasher's internal state. Useful\n/// for hashing `UInt64` values as part of a larger composite structure.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The 64-bit unsigned integer value to be incorporated into the\n/// hash.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_uint64(42UL)\n/// inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub fn Hasher::combine_uint64(self : Hasher, value : UInt64) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a double-precision floating-point number into the hasher's internal\n/// state by reinterpreting its bits as a 64-bit integer. Maintains consistent\n/// hashing behavior regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher to combine the value into.\n/// * `value` : The double-precision floating-point number to be combined into\n/// the hash.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_double(3.14)\n/// inspect(hasher.finalize(), content=\"-428265677\")\n/// ```\npub fn Hasher::combine_double(self : Hasher, value : Double) -> Unit {\n  self.combine_int64(value.reinterpret_as_int64())\n}\n\n///|\n/// Combines a 32-bit floating-point value into the hasher by reinterpreting its\n/// bit pattern as a 32-bit integer. The operation maintains the same hash result\n/// regardless of the floating-point value's representation.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object that maintains the internal state of the\n/// hashing operation.\n/// * `value` : The 32-bit floating-point value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine(3.14F)\n/// inspect(hasher.finalize(), content=\"635116317\") // Hash of the bits of 3.14\n/// ```\n#deprecated\npub fn Hasher::combine_float(self : Hasher, value : Float) -> Unit {\n  self.combine_uint(value.reinterpret_as_uint())\n}\n\n///|\nfn Float::reinterpret_as_uint(self : Float) -> UInt = \"%f32.to_i32_reinterpret\"\n\n///|\n/// Combines a byte value into the hash state.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte value.\n/// * `byte` : The byte value to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_byte(b'\\xFF')\n/// inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::combine_byte(self : Hasher, value : Byte) -> Unit {\n  self.consume1(value)\n}\n\n///|\n/// Combines a byte sequence into the hasher's internal state using xxHash32\n/// algorithm. Processes the input bytes in chunks of 4 bytes for efficiency,\n/// with remaining bytes processed individually.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object to update with the byte sequence.\n/// * `bytes` : The byte sequence to be combined into the hash.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_bytes(b\"\\xFF\\x00\\xFF\\x00\")\n/// inspect(hasher.finalize(), content=\"-686861102\")\n/// ```\npub fn Hasher::combine_bytes(self : Hasher, value : Bytes) -> Unit {\n  let mut remain = value.length()\n  let mut cur = 0\n  while remain >= 4 {\n    self.consume4(endian32(value, cur))\n    cur += 4\n    remain -= 4\n  }\n  while remain >= 1 {\n    self.consume1(value[cur])\n    cur += 1\n    remain -= 1\n  }\n}\n\n///|\n/// Combines a string value into the current hash state by processing each\n/// character in the string sequentially.\n///\n/// Parameters:\n///\n/// * `self` : The hasher object whose state will be updated.\n/// * `value` : The string value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_string(\"hello\")\n/// inspect(hasher.finalize(), content=\"-655549713\")\n/// ```\npub fn Hasher::combine_string(self : Hasher, value : String) -> Unit {\n  for i in 0..<value.length() {\n    self.combine_uint(value.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Combines a character value into the hasher's internal state. The character is\n/// first converted to its Unicode code point (as an integer) before being\n/// combined.\n///\n/// Parameters:\n///\n/// * `self` : The hasher instance to update.\n/// * `value` : The character value to be combined into the hash state.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_char('A')\n/// inspect(hasher.finalize(), content=\"-1625495534\")\n/// ```\npub fn Hasher::combine_char(self : Hasher, value : Char) -> Unit {\n  self.combine_uint(value.to_uint())\n}\n\n///|\n/// Finalizes the hashing process and returns the computed hash value. Applies an\n/// avalanche function to improve the distribution of the hash value.\n///\n/// Parameters:\n///\n/// * `hasher` : The hasher object containing the accumulated hash state.\n///\n/// Returns a 32-bit integer representing the final hash value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_byte(b'\\xFF')\n/// inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub fn Hasher::finalize(self : Hasher) -> Int {\n  self.avalanche().reinterpret_as_int()\n}\n\n///|\nfn Hasher::avalanche(self : Hasher) -> UInt {\n  let mut acc = self.acc\n  acc = acc ^ (acc >> 15)\n  acc *= GPRIMES2\n  acc = acc ^ (acc >> 13)\n  acc *= GPRIME3\n  acc = acc ^ (acc >> 16)\n  acc\n}\n\n///|\nfn Hasher::consume4(self : Hasher, input : UInt) -> Unit {\n  self.acc = rotl(self.acc + input * GPRIME3, 17) * GPRIME4\n}\n\n///|\nfn Hasher::consume1(self : Hasher, input : Byte) -> Unit {\n  self.acc = rotl(self.acc + input.to_uint() * GPRIME5, 11) * GPRIME1\n}\n\n///|\nfn rotl(x : UInt, r : Int) -> UInt {\n  (x << r) | (x >> (32 - r))\n}\n\n///|\nfn endian32(input : Bytes, cur : Int) -> UInt {\n  input[cur + 0].to_uint() |\n  (\n    (input[cur + 1].to_uint() << 8) |\n    (input[cur + 2].to_uint() << 16) |\n    (input[cur + 3].to_uint() << 24)\n  )\n}\n\n///|\n/// Implements the `Hash` trait for `String` type, providing a method to combine\n/// a string's hash value with a hasher's state.\n///\n/// Parameters:\n///\n/// * `self` : The string value to be hashed.\n/// * `hasher` : The hasher object that will be updated with the string's hash\n/// value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let s1 = \"hello\"\n/// let s2 = \"hello\"\n/// let s3 = \"world\"\n/// inspect(Hash::hash(s1) == Hash::hash(s2), content=\"true\")\n/// inspect(Hash::hash(s1) == Hash::hash(s3), content=\"false\")\n/// ```\npub impl Hash for String with hash_combine(self, hasher) {\n  hasher.combine_string(self)\n}\n\n///|\npub impl Hash for StringView with hash_combine(\n  self : StringView,\n  hasher : Hasher,\n) -> Unit {\n  let str = self.str()\n  for i in self.start()..<self.end() {\n    hasher.combine_uint(str.unsafe_charcode_at(i).reinterpret_as_uint())\n  }\n}\n\n///|\n/// Implements hash combination for integers by combining the integer value with\n/// a hasher. This implementation ensures that integers can be used as keys in\n/// hash-based collections like hash maps and hash sets.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be hashed.\n/// * `hasher` : A `Hasher` object that accumulates the hash value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_int(42)\n/// inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for Int with hash_combine(self, hasher) {\n  hasher.combine_int(self)\n}\n\n///|\n/// Combines the hash value of an unsigned integer with a hasher object. This is\n/// useful when you need to hash a data structure that contains unsigned\n/// integers.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned integer to be combined with the hasher.\n/// * `hasher` : The hasher object that will incorporate the hash value of the\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_uint(42U)\n/// inspect(hasher.finalize(), content=\"1161967057\")\n/// ```\npub impl Hash for UInt with hash_combine(self, hasher) {\n  hasher.combine_uint(self)\n}\n\n///|\n/// Implements the `Hash` trait for `UInt64` by combining the hash value of an\n/// unsigned 64-bit integer into a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer value to be hashed.\n/// * `hasher` : The hasher object used to compute the combined hash value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_uint64(42UL)\n/// inspect(hasher.finalize(), content=\"-1962516083\")\n/// ```\npub impl Hash for UInt64 with hash_combine(self, hasher) {\n  hasher.combine_uint64(self)\n}\n\n///|\n/// Implements the `Hash` trait for `Option` types, allowing them to be used as\n/// keys in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Option` value to be hashed.\n/// * `hasher` : The hasher object that accumulates the hash state.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// let some_value : Int? = Some(42)\n/// let none_value : Int? = None\n/// hasher.combine(some_value)\n/// inspect(hasher.finalize(), content=\"2103260413\")\n/// let hasher2 = Hasher::new(seed=0)\n/// hasher2.combine(none_value)\n/// inspect(hasher2.finalize(), content=\"148298089\")\n/// ```\npub impl[X : Hash] Hash for X? with hash_combine(self, hasher) {\n  match self {\n    None => hasher.combine_int(0)\n    Some(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\n/// Implements the `Hash` trait for `Result` type, allowing `Result` values to be\n/// used in hash-based collections.\n///\n/// Parameters:\n///\n/// * `self` : The `Result` value to be hashed.\n/// * `hasher` : The hasher object to which the hash value will be combined.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// let ok_result : Result[Int, String] = Ok(42)\n/// let err_result : Result[Int, String] = Err(\"error\")\n/// hasher.combine(ok_result)\n/// inspect(hasher.finalize(), content=\"-1948635851\")\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine(err_result)\n/// inspect(hasher.finalize(), content=\"1953766574\")\n/// ```\npub impl[T : Hash, E : Hash] Hash for Result[T, E] with hash_combine(\n  self,\n  hasher,\n) {\n  match self {\n    Ok(x) => hasher..combine_int(0)..combine(x)\n    Err(x) => hasher..combine_int(1)..combine(x)\n  }\n}\n\n///|\npub impl Hash for BytesView with hash_combine(self : BytesView, hasher : Hasher) {\n  let mut start = self.start()\n  let data = self.bytes()\n  let mut rest = self.len()\n  while rest >= 4 {\n    let mut result : UInt = 0\n    for i in 0..=3 {\n      result = result | (data.unsafe_get(i + start).to_uint() << (8 * i))\n    }\n    hasher.combine_uint(result)\n    rest -= 4\n    start += 4\n  }\n  while rest >= 1 {\n    hasher.combine_byte(data.unsafe_get(start))\n    rest -= 1\n    start += 1\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Types\n\n///|\npriv struct Entry[K, V] {\n  mut prev : Int\n  mut next : Entry[K, V]?\n  mut psl : Int\n  hash : Int\n  key : K\n  mut value : V\n} derive(Show)\n\n///|\n/// Mutable linked hash map that maintains the order of insertion, not thread safe.\n///\n/// # Example\n///\n/// ```mbt\n///   let map = { 3: \"three\", 8 :  \"eight\", 1 :  \"one\"}\n///   assert_eq(map.get(2), None)\n///   assert_eq(map.get(3), Some(\"three\"))\n///   map.set(3, \"updated\")\n///   assert_eq(map.get(3), Some(\"updated\"))\n/// ```\nstruct Map[K, V] {\n  mut entries : FixedArray[Entry[K, V]?]\n  mut size : Int // active key-value pairs count\n  mut capacity : Int // current capacity\n  mut capacity_mask : Int // capacity_mask = capacity - 1, used to find idx\n  mut grow_at : Int // threshold that triggers grow\n  mut head : Entry[K, V]? // head of linked list\n  mut tail : Int // tail of linked list\n}\n\n// Implementations\n\n///|\n/// Create a hash map.\n/// The capacity of the map will be the smallest power of 2 that is\n/// greater than or equal to the provided [capacity].\npub fn[K, V] Map::new(capacity? : Int = 8) -> Map[K, V] {\n  let capacity = capacity.next_power_of_two()\n  {\n    size: 0,\n    capacity,\n    capacity_mask: capacity - 1,\n    grow_at: calc_grow_threshold(capacity),\n    entries: FixedArray::make(capacity, None),\n    head: None,\n    tail: -1,\n  }\n}\n\n///|\n/// Create a hash map from array.\npub fn[K : Hash + Eq, V] Map::from_array(arr : ArrayView[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  for e in arr {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\n/// Sets a key-value pair into the hash map. If the key already exists, updates\n/// its value. If the hash map is near full capacity, automatically\n/// grows the internal storage to accommodate more entries.\n///\n/// Parameters:\n///\n/// * `map` : The hash map to modify.\n/// * `key` : The key to insert or update. Must implement `Hash` and `Eq` traits.\n/// * `value` : The value to associate with the key.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map : Map[String, Int] = Map::new()\n/// map.set(\"key\", 42)\n/// inspect(map.get(\"key\"), content=\"Some(42)\")\n/// map.set(\"key\", 24) // update existing key\n/// inspect(map.get(\"key\"), content=\"Some(24)\")\n/// ```\n#alias(\"_[_]=_\")\npub fn[K : Hash + Eq, V] Map::set(self : Map[K, V], key : K, value : V) -> Unit {\n  self.set_with_hash(key, value, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::set_with_hash(\n  self : Map[K, V],\n  key : K,\n  value : V,\n  hash : Int,\n) -> Unit {\n  if self.size >= self.grow_at {\n    self.grow()\n  }\n  let (idx, psl) = for psl = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      None => break (idx, psl)\n      Some(curr_entry) => {\n        if curr_entry.hash == hash && curr_entry.key == key {\n          curr_entry.value = value\n          return\n        }\n        if psl > curr_entry.psl {\n          self.push_away(idx, curr_entry)\n          break (idx, psl)\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n    }\n  }\n  let entry = { prev: self.tail, next: None, psl, key, value, hash }\n  self.add_entry_to_tail(idx, entry)\n}\n\n///|\nfn[K, V] Map::push_away(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  for psl = entry.psl + 1, idx = (idx + 1) & self.capacity_mask, entry = entry {\n    match self.entries[idx] {\n      None => {\n        entry.psl = psl\n        self.set_entry(entry, idx)\n        break\n      }\n      Some(curr_entry) =>\n        if psl > curr_entry.psl {\n          entry.psl = psl\n          self.set_entry(entry, idx)\n          continue curr_entry.psl + 1,\n            (idx + 1) & self.capacity_mask,\n            curr_entry\n        } else {\n          continue psl + 1, (idx + 1) & self.capacity_mask, entry\n        }\n    }\n  }\n}\n\n///|\nfn[K, V] Map::set_entry(\n  self : Map[K, V],\n  entry : Entry[K, V],\n  new_idx : Int,\n) -> Unit {\n  self.entries[new_idx] = Some(entry)\n  match entry.next {\n    None => self.tail = new_idx\n    Some(next) => next.prev = new_idx\n  }\n}\n\n///|\n/// Retrieves the value associated with a given key in the hash map.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to search in.\n/// * `key` : The key to look up in the map.\n///\n/// Returns `Some(value)` if the key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { \"key\": 42 }\n/// inspect(map.get(\"key\"), content=\"Some(42)\")\n/// inspect(map.get(\"nonexistent\"), content=\"None\")\n/// ```\npub fn[K : Hash + Eq, V] Map::get(self : Map[K, V], key : K) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && entry.key == key {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n#alias(\"_[_]\")\npub fn[K : Hash + Eq, V] Map::at(self : Map[K, V], key : K) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry)\n    if entry.hash == hash && entry.key == key {\n      return entry.value\n    }\n    guard i <= entry.psl\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Returns the value associated with the key in the map, or computes and returns\n/// a default value if the key does not exist.\n///\n/// Parameters:\n///\n/// * `map` : The map to search in.\n/// * `key` : The key to look up in the map.\n/// * `default` : A function that returns a default value when the key is not\n/// found.\n///\n/// Returns either the value associated with the key if it exists, or the result\n/// of calling the default function.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { \"a\": 1, \"b\": 2 }\n/// inspect(map.get_or_default(\"a\", 0), content=\"1\")\n/// inspect(map.get_or_default(\"c\", 42), content=\"42\")\n/// ```\npub fn[K : Hash + Eq, V] Map::get_or_default(\n  self : Map[K, V],\n  key : K,\n  default : V,\n) -> V {\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          break entry.value\n        }\n        if i > entry.psl {\n          break default\n        }\n        continue i + 1, (idx + 1) & self.capacity_mask\n      }\n      None => break default\n    }\n  }\n}\n\n///|\n/// Returns the value for the given key, or sets and returns a default value if the key does not exist.\npub fn[K : Hash + Eq, V] Map::get_or_init(\n  self : Map[K, V],\n  key : K,\n  default : () -> V,\n) -> V {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          return entry.value\n        }\n        if psl > entry.psl {\n          let new_value = default()\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        let new_value = default()\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set_with_hash(key, new_value, hash)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n  new_value\n}\n\n///|\n/// Check if the hash map contains a key.\npub fn[K : Hash + Eq, V] Map::contains(self : Map[K, V], key : K) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Checks if a map contains a specific key-value pair.\n///\n/// Parameters:\n///\n/// * `map` : A map of type `Map[K, V]` to search in.\n/// * `key` : The key to look up in the map.\n/// * `value` : The value to be compared with the value associated with the key.\n///\n/// Returns `true` if the map contains the specified key and its associated value\n/// equals the given value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { \"a\": 1, \"b\": 2 }\n/// inspect(map.contains_kv(\"a\", 1), content=\"true\")\n/// inspect(map.contains_kv(\"a\", 2), content=\"false\")\n/// inspect(map.contains_kv(\"c\", 3), content=\"false\")\n/// ```\npub fn[K : Hash + Eq, V : Eq] Map::contains_kv(\n  self : Map[K, V],\n  key : K,\n  value : V,\n) -> Bool {\n  // inline Map::get to avoid boxing\n  let hash = key.hash()\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break false }\n    if entry.hash == hash && entry.key == key && entry.value == value {\n      break true\n    }\n    if i > entry.psl {\n      break false\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\n/// Removes the entry for the specified key from the hash map. If the key exists\n/// in the map, removes its entry and adjusts the probe sequence length (PSL) of\n/// subsequent entries to maintain the Robin Hood hashing invariant. If the key\n/// does not exist, the map remains unchanged.\n///\n/// Parameters:\n///\n/// * `self` : The hash map to remove the entry from.\n/// * `key` : The key to remove from the map.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { \"a\": 1, \"b\": 2 }\n/// map.remove(\"a\")\n/// inspect(map.get(\"a\"), content=\"None\")\n/// inspect(map.length(), content=\"1\")\n/// ```\npub fn[K : Hash + Eq, V] Map::remove(self : Map[K, V], key : K) -> Unit {\n  self.remove_with_hash(key, key.hash())\n}\n\n///|\nfn[K : Eq, V] Map::remove_with_hash(\n  self : Map[K, V],\n  key : K,\n  hash : Int,\n) -> Unit {\n  for i = 0, idx = hash & self.capacity_mask {\n    guard self.entries[idx] is Some(entry) else { break }\n    if entry.hash == hash && entry.key == key {\n      self.remove_entry(entry)\n      self.shift_back(idx)\n      self.size -= 1\n      break\n    }\n    if i > entry.psl {\n      break\n    }\n    continue i + 1, (idx + 1) & self.capacity_mask\n  }\n}\n\n///|\nfn[K, V] Map::add_entry_to_tail(\n  self : Map[K, V],\n  idx : Int,\n  entry : Entry[K, V],\n) -> Unit {\n  match self.tail {\n    -1 => self.head = Some(entry)\n    tail => self.entries[tail].unwrap().next = Some(entry)\n  }\n  self.tail = idx\n  self.entries[idx] = Some(entry)\n  self.size += 1\n}\n\n///|\nfn[K, V] Map::remove_entry(self : Map[K, V], entry : Entry[K, V]) -> Unit {\n  match entry.prev {\n    -1 => self.head = entry.next\n    idx => self.entries[idx].unwrap().next = entry.next\n  }\n  match entry.next {\n    None => self.tail = entry.prev\n    Some(next) => next.prev = entry.prev\n  }\n}\n\n///|\nfn[K, V] Map::shift_back(self : Map[K, V], idx : Int) -> Unit {\n  let next = (idx + 1) & self.capacity_mask\n  match self.entries[next] {\n    None | Some({ psl: 0, .. }) => self.entries[idx] = None\n    Some(entry) => {\n      entry.psl -= 1\n      self.set_entry(entry, idx)\n      self.shift_back(next)\n    }\n  }\n}\n\n///|\nfn[K : Eq, V] Map::grow(self : Map[K, V]) -> Unit {\n  let old_head = self.head\n  let new_capacity = self.capacity << 1\n  self.entries = FixedArray::make(new_capacity, None)\n  self.capacity = new_capacity\n  self.capacity_mask = new_capacity - 1\n  self.grow_at = calc_grow_threshold(self.capacity)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n  loop old_head {\n    Some({ next, key, value, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\nfn calc_grow_threshold(capacity : Int) -> Int {\n  capacity * 13 / 16\n}\n\n// Utils\n\n///|\npub impl[K : Show, V : Show] Show for Map[K, V] with output(self, logger) {\n  logger.write_string(\"{\")\n  loop (0, self.head) {\n    (_, None) => logger.write_string(\"}\")\n    (i, Some({ key, value, next, .. })) => {\n      if i > 0 {\n        logger.write_string(\", \")\n      }\n      logger..write_object(key)..write_string(\": \")..write_object(value)\n      continue (i + 1, next)\n    }\n  }\n}\n\n///|\n/// Get the number of key-value pairs in the map.\n#alias(size, deprecated)\npub fn[K, V] Map::length(self : Map[K, V]) -> Int {\n  self.size\n}\n\n///|\n/// Get the capacity of the map.\npub fn[K, V] Map::capacity(self : Map[K, V]) -> Int {\n  self.capacity\n}\n\n///|\n/// Check if the hash map is empty.\npub fn[K, V] Map::is_empty(self : Map[K, V]) -> Bool {\n  self.size == 0\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion.\n#locals(f)\npub fn[K, V] Map::each(\n  self : Map[K, V],\n  f : (K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      f(key, value)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Iterate over all key-value pairs of the map in the order of insertion, with index.\n#locals(f)\npub fn[K, V] Map::eachi(\n  self : Map[K, V],\n  f : (Int, K, V) -> Unit raise?,\n) -> Unit raise? {\n  loop (0, self.head) {\n    (i, Some({ key, value, next, .. })) => {\n      f(i, key, value)\n      continue (i + 1, next)\n    }\n    (_, None) => break\n  }\n}\n\n///|\n/// Clears the map, removing all key-value pairs. Keeps the allocated space.\npub fn[K, V] Map::clear(self : Map[K, V]) -> Unit {\n  self.entries.fill(None)\n  self.size = 0\n  self.head = None\n  self.tail = -1\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\npub fn[K, V] Map::iter(self : Map[K, V]) -> Iter[(K, V)] {\n  self.iterator().iter()\n}\n\n///|\n/// Returns the iterator of the hash map, provide elements in the order of insertion.\npub fn[K, V] Map::iterator(self : Map[K, V]) -> Iterator[(K, V)] {\n  let mut curr_entry = self.head\n  Iterator::new(fn() {\n    match curr_entry {\n      Some({ key, value, next, .. }) => {\n        curr_entry = next\n        Some((key, value))\n      }\n      None => None\n    }\n  })\n}\n\n///|\npub fn[K, V] Map::iterator2(self : Map[K, V]) -> Iterator2[K, V] {\n  self.iterator()\n}\n\n///|\npub fn[K, V] Map::iter2(self : Map[K, V]) -> Iter2[K, V] {\n  self.iterator2().iter2()\n}\n\n///|\npub fn[K, V] Map::keys(self : Map[K, V]) -> Iter[K] {\n  let mut curr_entry = self.head\n  Iterator::new(fn() {\n    match curr_entry {\n      Some({ key, next, .. }) => {\n        curr_entry = next\n        Some(key)\n      }\n      None => None\n    }\n  }).iter()\n}\n\n///|\npub fn[K, V] Map::values(self : Map[K, V]) -> Iter[V] {\n  let mut curr_entry = self.head\n  Iterator::new(fn() {\n    match curr_entry {\n      Some({ value, next, .. }) => {\n        curr_entry = next\n        Some(value)\n      }\n      None => None\n    }\n  }).iter()\n}\n\n///|\n/// Converts the hash map to an array.\npub fn[K, V] Map::to_array(self : Map[K, V]) -> Array[(K, V)] {\n  let arr = Array::make_uninit(self.size)\n  let mut i = 0\n  loop self.head {\n    Some({ key, value, next, .. }) => {\n      arr.unsafe_set(i, (key, value))\n      i += 1\n      continue next\n    }\n    None => break\n  }\n  arr\n}\n\n///|\npub impl[K : Hash + Eq, V : Eq] Eq for Map[K, V] with equal(\n  self : Map[K, V],\n  that : Map[K, V],\n) -> Bool {\n  guard self.size == that.size else { return false }\n  for k, v in self {\n    guard that.contains_kv(k, v) else { return false }\n  } else {\n    true\n  }\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::of(arr : FixedArray[(K, V)]) -> Map[K, V] {\n  let length = arr.length()\n  let mut capacity = length.next_power_of_two()\n  if length > calc_grow_threshold(capacity) {\n    capacity *= 2\n  }\n  let m = Map::new(capacity~)\n  // arr.iter((e) => { m.set(e.0, e.1) })\n  for i in 0..<length {\n    let e = arr[i]\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::from_iter(iter : Iter[(K, V)]) -> Map[K, V] {\n  let m = {}\n  for e in iter {\n    m.set(e.0, e.1)\n  }\n  m\n}\n\n///|\npub fn[K : Hash + Eq, V] Map::from_iterator(\n  iter : Iterator[(K, V)],\n) -> Map[K, V] {\n  let m = {}\n  while iter.next() is Some((k, v)) {\n    m.set(k, v)\n  }\n  m\n}\n\n///|\npub impl[K, V] Default for Map[K, V] with default() {\n  Map::new()\n}\n\n///|\n/// Applies a function to each key-value pair in the map and returns a new map with the results, using the original keys.\npub fn[K, V, V2] Map::map(self : Map[K, V], f : (K, V) -> V2) -> Map[K, V2] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_value = f(key, value)\n      let new_entry = { prev, next, psl, hash, key, value: new_value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Copy the map, creating a new map with the same key-value pairs and order of insertion.\npub fn[K, V] Map::copy(self : Map[K, V]) -> Map[K, V] {\n  // copy structure\n  let other = {\n    capacity: self.capacity,\n    entries: FixedArray::make(self.capacity, None),\n    size: self.size,\n    capacity_mask: self.capacity_mask,\n    grow_at: self.grow_at,\n    head: None,\n    tail: self.tail,\n  }\n  if self.size == 0 {\n    return other\n  }\n  guard self.entries[self.tail] is Some(last)\n  loop (last, self.tail, None) {\n    ({ prev, psl, hash, key, value, .. }, idx, next) => {\n      let new_entry = { prev, next, psl, hash, key, value }\n      other.entries[idx] = Some(new_entry)\n      if prev != -1 {\n        continue (self.entries[prev].unwrap(), prev, Some(new_entry))\n      } else {\n        other.head = Some(new_entry)\n      }\n    }\n  }\n  other\n}\n\n///|\n/// Merges two maps into a new map. Returns a new map containing all key-value\n/// pairs from both maps. When both maps contain the same key, the value from\n/// `other` takes precedence. The iteration order follows the order of `self`\n/// followed by new entries from `other`.\n///\n/// This is a pure operation - it does not modify either of the input maps.\n///\n/// Parameters:\n///\n/// * `self` : The first map.\n/// * `other` : The second map whose values take precedence in case of key\n/// conflicts.\n///\n/// Returns a new linked hash map containing all entries from both maps.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n/// let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n/// let merged = map1.merge(map2)\n/// @json.inspect(merged, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// ```\npub fn[K : Eq, V] Map::merge(self : Map[K, V], other : Map[K, V]) -> Map[K, V] {\n  let result = self.copy()\n  result.merge_in_place(other)\n  result\n}\n\n///|\n/// Merges another map into this map in-place. Updates the current map by adding\n/// all key-value pairs from `other`. When both maps contain the same key, the\n/// value from `other` overwrites the value in this map. New entries from `other`\n/// are added at the end, preserving the original order of `self` and appending\n/// new keys from `other`.\n///\n/// This is a mutating operation - it modifies the receiver map.\n///\n/// Parameters:\n///\n/// * `self` : The map to be modified.\n/// * `other` : The map whose entries will be added to `self`.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map1 : Map[String, Int] = { \"a\": 1, \"b\": 2 }\n/// let map2 : Map[String, Int] = { \"b\": 3, \"c\": 4 }\n/// map1.merge_in_place(map2)\n/// @json.inspect(map1, content={ \"a\": 1, \"b\": 3, \"c\": 4 })\n/// ```\npub fn[K : Eq, V] Map::merge_in_place(\n  self : Map[K, V],\n  other : Map[K, V],\n) -> Unit {\n  loop other.head {\n    Some({ key, value, next, hash, .. }) => {\n      self.set_with_hash(key, value, hash)\n      continue next\n    }\n    None => break\n  }\n}\n\n///|\n/// Retains only the key-value pairs that satisfy the given predicate function.\n/// This method modifies the map in-place, removing all entries for which\n/// the predicate returns `false`. The order of remaining elements is preserved.\n///\n/// Parameters:\n///\n/// * `self` : The map to be filtered.\n/// * `predicate` : A function that takes a key and value as arguments and returns\n/// `true` if the key-value pair should be kept, `false` if it should be removed.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { \"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4 }\n/// map.retain((_k, v) => v % 2 == 0) // Keep only even values\n/// inspect(map.length(), content=\"2\")\n/// inspect(map.get(\"a\"), content=\"None\")\n/// inspect(map.get(\"b\"), content=\"Some(2)\")\n/// inspect(map.get(\"c\"), content=\"None\")\n/// inspect(map.get(\"d\"), content=\"Some(4)\")\n/// ```\n#locals(f)\npub fn[K, V] Map::retain(self : Map[K, V], f : (K, V) -> Bool) -> Unit {\n  loop (self.head, false) {\n    (Some({ key, value, next, prev: idx, .. }), remove_prev) => {\n      if remove_prev {\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n      continue (next, !f(key, value))\n    }\n    (None, remove_prev) =>\n      if remove_prev {\n        let idx = self.tail\n        guard self.entries[idx] is Some(entry)\n        self.remove_entry(entry)\n        self.shift_back(idx)\n        self.size -= 1\n      }\n  }\n}\n\n///|\n/// Updates a value in the map based on the existing value.\n///\n/// This method allows you to conditionally update, insert, or remove a key-value pair\n/// based on whether the key already exists in the map. The provided function `f` is\n/// called with `Some(current_value)` if the key exists, or `None` if it doesn't.\n///\n/// Parameters:\n///\n/// * `self` : The map to update.\n/// * `key` : The key to update.\n/// * `f` : A function that takes the current value (wrapped in `Option`) and returns\n///   the new value (wrapped in `Option`). Returning `None` will remove the key-value\n///   pair from the map.\n///\n/// Behavior:\n///\n/// * If the key exists and `f` returns `Some(new_value)`, the value is updated.\n/// * If the key exists and `f` returns `None`, the key-value pair is removed.\n/// * If the key doesn't exist and `f` returns `Some(new_value)`, a new pair is inserted.\n/// * If the key doesn't exist and `f` returns `None`, no operation is performed.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { \"a\": 1, \"b\": 2 }\n///\n/// // Update existing value\n/// map.update(\"a\", fn(v) {\n///   match v {\n///     Some(x) => Some(x + 10)\n///     None => Some(0)\n///   }\n/// })\n/// inspect(\n///   map,\n///   content=(\n///     #|{\"a\": 11, \"b\": 2}\n///   ),\n/// )\n///\n/// // Insert new value\n/// map.update(\"c\", fn(v) {\n///   match v {\n///     Some(x) => Some(x)\n///     None => Some(3)\n///   }\n/// })\n/// inspect(\n///   map,\n///   content=(\n///     #|{\"a\": 11, \"b\": 2, \"c\": 3}\n///   ),\n/// )\n///\n/// // Remove existing value\n/// map.update(\"b\", fn(_) { None })\n/// inspect(\n///   map,\n///   content=(\n///     #|{\"a\": 11, \"c\": 3}\n///   ),\n/// )\n/// ```\npub fn[K : Hash + Eq, V] Map::update(\n  self : Map[K, V],\n  key : K,\n  f : (V?) -> V?,\n) -> Unit {\n  let hash = key.hash()\n  let (idx, psl, new_value, push_away) = for psl = 0, idx = hash &\n                                               self.capacity_mask {\n    match self.entries[idx] {\n      Some(entry) => {\n        if entry.hash == hash && entry.key == key {\n          // Found the entry, update its value\n          if f(Some(entry.value)) is Some(new_value) {\n            entry.value = new_value\n          } else {\n            // Remove the entry since the new value is None\n            self.remove_entry(entry)\n            self.shift_back(idx)\n            self.size -= 1\n          }\n          return\n        }\n        if psl > entry.psl {\n          guard f(None) is Some(new_value) else { return }\n          break (idx, psl, new_value, Some(entry))\n        }\n        continue psl + 1, (idx + 1) & self.capacity_mask\n      }\n      None => {\n        guard f(None) is Some(new_value) else { return }\n        break (idx, psl, new_value, None)\n      }\n    }\n  }\n  if self.size >= self.grow_at {\n    // Slow path, we need to resize\n    self.grow()\n    self.set(key, new_value)\n  } else {\n    if push_away is Some(entry) {\n      self.push_away(idx, entry)\n    }\n    let entry = {\n      prev: self.tail,\n      next: None,\n      psl,\n      hash,\n      key,\n      value: new_value,\n    }\n    self.add_entry_to_tail(idx, entry)\n  }\n}\n\n// Special handling for Views as accessors\n\n///|\nfn StringView::equal_to_string(self : Self, other : String) -> Bool {\n  let str = self.str()\n  let start = self.start()\n  let end = self.end()\n  let len = end - start\n  guard len == other.length() else { return false }\n  if physical_equal(str, other) && self.start() == 0 {\n    return true\n  }\n  for i in 0..<len {\n    guard str.unsafe_charcode_at(self.start() + i) ==\n      other.unsafe_charcode_at(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\nfn BytesView::equal_to_bytes(self : Self, other : Bytes) -> Bool {\n  let self_len = self.len()\n  let start = self.start()\n  guard self_len == other.length() else { return false }\n  for i in 0..<self_len {\n    guard self.bytes().unsafe_get(i + start) == other.unsafe_get(i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Retrieves the value associated with a `BytesView` key in a map with `Bytes` keys.\n///\n/// This function allows efficient lookups using `BytesView` without creating a new `Bytes` object.\n/// It's particularly useful when working with byte slices or subranges of existing byte arrays.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `Bytes` keys to search in.\n/// * `key` : A `BytesView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { b\"hello\": 1, b\"world\": 2 }\n/// let bytes = b\"prefix_hello_suffix\"\n/// let view = bytes[7:12] // view of \"hello\"\n/// inspect(map.get_from_bytes(view), content=\"Some(1)\")\n/// ```\npub fn[V] Map::get_from_bytes(map : Self[Bytes, V], key : BytesView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_bytes(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n\n///|\n/// Retrieves the value associated with a `StringView` key in a map with `String` keys.\n///\n/// This function allows efficient lookups using `StringView` without creating a new `String` object.\n/// It's particularly useful when working with substrings or string slices.\n///\n/// Parameters:\n///\n/// * `map` : The hash map with `String` keys to search in.\n/// * `key` : A `StringView` representing the key to look up.\n///\n/// Returns `Some(value)` if a matching key exists in the map, `None` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let map = { \"hello\": 1, \"world\": 2 }\n/// let str = \"say hello to everyone\"\n/// let view = str.view(start_offset=4, end_offset=9) // view of \"hello\"\n/// inspect(map.get_from_string(view), content=\"Some(1)\")\n/// ```\npub fn[V] Map::get_from_string(map : Self[String, V], key : StringView) -> V? {\n  let hash = key.hash()\n  for i = 0, idx = hash & map.capacity_mask {\n    guard map.entries[idx] is Some(entry) else { break None }\n    if entry.hash == hash && key.equal_to_string(entry.key) {\n      break Some(entry.value)\n    }\n    if i > entry.psl {\n      break None\n    }\n    continue i + 1, (idx + 1) & map.capacity_mask\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the smallest power of two greater than or equal to `self`.\n/// This function will panic if `self` is negative. For values greater than\n/// the largest representable power of two (2^30 = 1073741824), it returns\n/// the largest representable power of two.\n///\n/// Example:\n/// ```mbt test\n/// inspect((0).next_power_of_two(), content=\"1\")\n/// inspect((1).next_power_of_two(), content=\"1\")\n/// inspect((2).next_power_of_two(), content=\"2\")\n/// inspect((3).next_power_of_two(), content=\"4\")\n/// inspect((8).next_power_of_two(), content=\"8\")\n/// inspect((1073741824).next_power_of_two(), content=\"1073741824\")\n/// inspect((2000000000).next_power_of_two(), content=\"1073741824\")\n/// ```\npub fn Int::next_power_of_two(self : Int) -> Int {\n  guard self >= 0\n  if self <= 1 {\n    return 1\n  }\n  // The largest power of 2 that fits in a 32-bit signed integer is 2^30\n  let max_power_of_two = 1073741824 // 2^30\n  if self > max_power_of_two {\n    return max_power_of_two\n  }\n  // 2147483647 is the largest value of an integer\n  (2147483647 >> ((self - 1).clz() - 1)) + 1\n}\n\n///|\n/// Returns the minimum of two integers.\n///\n/// Example:\n/// ```mbt test\n/// inspect((1).min(2), content=\"1\")\n/// inspect((2).min(1), content=\"1\")\n/// ```\npub fn Int::min(self : Int, other : Int) -> Int {\n  if self < other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Returns the maximum of two integers.\n///\n/// Example:\n/// ```mbt test\n/// inspect((1).max(2), content=\"2\")\n/// inspect((2).max(1), content=\"2\")\n/// ```\npub fn Int::max(self : Int, other : Int) -> Int {\n  if self > other {\n    self\n  } else {\n    other\n  }\n}\n\n///|\n/// Clamps the value `self` between `min` and `max`.\n///\n/// Example:\n/// ```mbt test\n/// inspect((1).clamp(min=0, max=2), content=\"1\")\n/// inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// inspect((3).clamp(min=0, max=2), content=\"2\")\n/// inspect((-1).clamp(min=0, max=2), content=\"0\")\n/// ```\npub fn Int::clamp(self : Int, min~ : Int, max~ : Int) -> Int {\n  guard min <= max\n  if self < min {\n    min\n  } else if self > max {\n    max\n  } else {\n    self\n  }\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 leading surrogate.\n/// Leading surrogates are in the range 0xD800 to 0xDBFF.\n///\n/// Example:\n/// ```mbt test\n/// inspect((0xD800).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDBFF).is_leading_surrogate(), content=\"true\")\n/// inspect((0xDC00).is_leading_surrogate(), content=\"false\")\n/// inspect((0x41).is_leading_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_leading_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDBFF\n}\n\n///|\n/// Checks if the integer value represents a UTF-16 trailing surrogate.\n/// Trailing surrogates are in the range 0xDC00 to 0xDFFF.\n///\n/// Example:\n/// ```mbt test\n/// inspect((0xDC00).is_trailing_surrogate(), content=\"true\")\n/// inspect((0xDFFF).is_trailing_surrogate(), content=\"true\")\n/// inspect((0xD800).is_trailing_surrogate(), content=\"false\")\n/// inspect((0x41).is_trailing_surrogate(), content=\"false\") // 'A'\n/// ```\npub fn Int::is_trailing_surrogate(self : Int) -> Bool {\n  0xDC00 <= self && self <= 0xDFFF\n}\n\n///|\n/// Checks if the integer value represents any UTF-16 surrogate (leading or trailing).\n/// Surrogates are in the range 0xD800 to 0xDFFF.\n///\n/// Example:\n/// ```mbt test\n/// inspect((0xD800).is_surrogate(), content=\"true\") // leading surrogate\n/// inspect((0xDC00).is_surrogate(), content=\"true\") // trailing surrogate\n/// inspect((0xDFFF).is_surrogate(), content=\"true\") // trailing surrogate\n/// inspect((0x41).is_surrogate(), content=\"false\") // 'A'\n/// inspect((0x1F600).is_surrogate(), content=\"false\") // ğŸ˜€ emoji codepoint\n/// ```\npub fn Int::is_surrogate(self : Int) -> Bool {\n  0xD800 <= self && self <= 0xDFFF\n}\n\n///|\n/// Computes the absolute value of an integer.\n///\n/// Parameters:\n///\n/// * `self` : The integer whose absolute value is to be computed.\n///\n/// Returns the absolute value of the integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(Int::abs(42), content=\"42\")\n/// inspect(Int::abs(-42), content=\"42\")\n/// inspect(Int::abs(0), content=\"0\")\n/// ```\npub fn Int::abs(self : Int) -> Int {\n  if self < 0 {\n    -self\n  } else {\n    self\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl[X : Eq] Eq for X? with equal(self, other) {\n  match (self, other) {\n    (None, None) => true\n    (Some(x), Some(y)) => x == y\n    _ => false\n  }\n}\n\n///|\npub fn[X : Show] Option::to_string(self : X?) -> String {\n  match self {\n    None => \"None\"\n    Some(x) => \"Some(\" + x.to_string() + \")\"\n  }\n}\n\n///|\n/// Extract the value in `Some`.\n/// \n/// If the value is `None`, it throws a panic.\npub fn[X] Option::unwrap(self : X?) -> X {\n  match self {\n    None => panic()\n    Some(x) => x\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n#alias(or, deprecated)\npub fn[T] Option::unwrap_or(self : T?, default : T) -> T {\n  match self {\n    None => default\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the provided default.\n///\n/// Default is lazily evaluated\n#alias(or_else, deprecated)\npub fn[T] Option::unwrap_or_else(\n  self : T?,\n  default : () -> T raise?,\n) -> T raise? {\n  match self {\n    None => default()\n    Some(t) => t\n  }\n}\n\n///|\n/// Return the contained `Some` value or the result of the `T::default()`.\n#alias(or_default, deprecated)\npub fn[T : Default] Option::unwrap_or_default(self : T?) -> T {\n  match self {\n    None => T::default()\n    Some(t) => t\n  }\n}\n\n///|\npub impl[X : Compare] Compare for X? with compare(self, other) {\n  match (self, other) {\n    (Some(x), Some(y)) => x.compare(y)\n    (Some(_), None) => 1\n    (None, Some(_)) => -1\n    (None, None) => 0\n  }\n}\n\n///|\n#alias(or_error, deprecated)\npub fn[T, Err : Error] Option::unwrap_or_error(\n  self : T?,\n  err : Err,\n) -> T raise Err {\n  match self {\n    Some(v) => v\n    None => raise err\n  }\n}\n\n///|\n/// `None`\npub impl[X] Default for X? with default() {\n  None\n}\n\n///|\npub fn[T] Option::iter(self : T?) -> Iter[T] {\n  match self {\n    Some(v) => Iter::singleton(v)\n    None => Iter::empty()\n  }\n}\n\n///|\npub fn[T] Option::iterator(self : T?) -> Iterator[T] {\n  match self {\n    Some(v) => Iterator::singleton(v)\n    None => Iterator::empty()\n  }\n}\n\n///|\n/// Maps the value of an `Option` using a provided function.\n///\n/// # Example\n///\n/// ```mbt\n///   let a = Some(5)\n///   assert_eq(a.map(x => x * 2), Some(10))\n///\n///   let b = None\n///   assert_eq(b.map(x => x * 2), None)\n/// ```\npub fn[T, U] Option::map(self : T?, f : (T) -> U raise?) -> U? raise? {\n  match self {\n    Some(t) => Some(f(t))\n    None => None\n  }\n}\n\n///|\n/// Returns the provided default result (if none), or applies a function to the contained value (if any).\n/// Arguments passed to map_or are eagerly evaluated; if you are passing the result of a function call, it is recommended to use `map_or_else`, which is lazily evaluated.\n///\n/// # Example\n///\n/// ```mbt\n///   let a = Some(5)\n///   assert_eq(a.map_or(3, x => x * 2), 10)\n/// ```\npub fn[T, U] Option::map_or(\n  self : T?,\n  default : U,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Computes a default function result (if none), or applies a different function to the contained value (if any).\n///\n/// # Example\n///\n/// ```mbt\n///   let a = Some(5)\n///   assert_eq(a.map_or_else(() => 3, x => x * 2), 10)\n/// ```\npub fn[T, U] Option::map_or_else(\n  self : T?,\n  default : () -> U raise?,\n  f : (T) -> U raise?,\n) -> U raise? {\n  match self {\n    None => default()\n    Some(x) => f(x)\n  }\n}\n\n///|\n/// Binds an option to a function that returns another option.\n///\n/// # Example\n///\n/// ```mbt\n///   let a = Option::Some(5)\n///   let r1 = a.bind(x => Some(x * 2))\n///   assert_eq(r1, Some(10))\n///   let b : Option[Int] = None\n///   let r2 = b.bind(x => Some(x * 2))\n///   assert_eq(r2, None)\n/// ```\npub fn[T, U] Option::bind(self : T?, f : (T) -> U? raise?) -> U? raise? {\n  match self {\n    Some(t) => f(t)\n    None => None\n  }\n}\n\n///|\n#deprecated(\"use `option.bind(x => x)` instead\")\npub fn[T] Option::flatten(self : T??) -> T? {\n  match self {\n    Some(inner) => inner\n    None => None\n  }\n}\n\n///|\n/// Checks if the option is empty.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_empty(self : T?) -> Bool {\n  self is None\n}\n\n///|\n/// Filters the option by applying the given predicate function `f`.\n///\n/// If the predicate function `f` returns `true` for the value contained in the option,\n/// the same option is returned. Otherwise, `None` is returned.\n///\n/// # Example\n/// ```mbt\n///   let x = Some(3)\n///   assert_eq(x.filter(x => x > 5), None)\n///   assert_eq(x.filter(x => x < 5), Some(3))\n/// ```\npub fn[T] Option::filter(self : T?, f : (T) -> Bool raise?) -> T? raise? {\n  match self {\n    Some(t) => if f(t) { self } else { None }\n    None => None\n  }\n}\n\n///|\n/// Checks if the option contains a value.\n#deprecated(\"use `x is Some(_)` instead\")\npub fn[T] Option::is_some(self : T?) -> Bool {\n  self is Some(_)\n}\n\n///|\n/// Checks if the option is None.\n#deprecated(\"use `x is None` instead\")\npub fn[T] Option::is_none(self : T?) -> Bool {\n  self is None\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\npub impl Show for Unit with output(_self, logger) {\n  logger.write_string(\"()\")\n}\n\n///|\npub impl Show for Bool with output(self, logger) {\n  if self {\n    logger.write_string(\"true\")\n  } else {\n    logger.write_string(\"false\")\n  }\n}\n\n///|\npub impl Show for Int with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Int64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt64 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for Byte with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub impl Show for UInt16 with output(self, logger) {\n  logger.write_string(self.to_string())\n}\n\n///|\npub fn Byte::to_hex(b : Byte) -> String {\n  fn to_hex_digit(i : Byte) -> Char {\n    if i < 10 {\n      (i + '0').to_char()\n    } else {\n      (i + 'a' - 10).to_char()\n    }\n  }\n\n  [to_hex_digit(b / 16), to_hex_digit(b % 16)]\n}\n\n///|\ntest \"to_hex_digit\" {\n  inspect(Byte::to_hex(b'\\xee'), content=\"ee\")\n  inspect(Byte::to_hex(b'\\xf3'), content=\"f3\")\n}\n\n///|\npub impl Show for String with output(self, logger) {\n  logger.write_char('\"')\n  fn flush_segment(seg : Int, i : Int) {\n    if i > seg {\n      logger.write_substring(self, seg, i - seg)\n    }\n  }\n  // The loop keeps two pieces of state:\n  //   i   : the current scanning position\n  //   seg : the beginning index of the current \"plain\" segment that has\n  //         no escaping requirements. Whenever we meet a character that\n  //         needs escaping, we flush the segment [seg, i) and reset seg.\n  let len = self.length()\n  for i = 0, seg = 0 {\n    if i >= len {\n      // If we reached the end of the string, flush any remaining segment\n      // and break out of the loop.\n      flush_segment(seg, i)\n      break\n    }\n    let code = self.unsafe_charcode_at(i)\n    match code {\n      '\"' | '\\\\' as c => {\n        flush_segment(seg, i)\n        logger..write_char('\\\\')..write_char(c.unsafe_to_char())\n        // Advance both pointers: continue with next index, new segment starts after current char\n        continue i + 1, i + 1\n      }\n      '\\n' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\n\")\n        continue i + 1, i + 1\n      }\n      '\\r' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\r\")\n        continue i + 1, i + 1\n      }\n      '\\b' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\b\")\n        continue i + 1, i + 1\n      }\n      '\\t' => {\n        flush_segment(seg, i)\n        logger.write_string(\"\\\\t\")\n        continue i + 1, i + 1\n      }\n      code =>\n        if code < ' ' {\n          // has to be ascii  \n          flush_segment(seg, i)\n          logger\n          ..write_string(\"\\\\u{\")\n          ..write_string(code.to_byte().to_hex())\n          ..write_char('}')\n          continue i + 1, i + 1\n        } else {\n          // Normal character, keep scanning; only advance index.\n          continue i + 1, seg\n        }\n    }\n  }\n  logger.write_char('\"')\n}\n\n///|\n/// This is different from `Show::output`,\n/// here it returns the original string without escaping. \n/// The rationale is in string interpolation,\n/// we want to show the original string, not the escaped one.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub impl Show for String with to_string(self) {\n  self\n}\n\n///|\n/// Returns a valid MoonBit string literal representation of a string,\n/// add quotes and escape special characters.\n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello \\n\"\n///   inspect(str.to_string(), content=\"Hello \\n\")\n///   inspect(str.escape(), content=\"\\\"Hello \\\\n\\\"\")\n/// ```\npub fn String::escape(self : String) -> String {\n  let buf = StringBuilder::new()\n  Show::output(self, buf)\n  buf.to_string()\n}\n\n///|\npub impl[X : Show] Show for X? with output(self, logger) {\n  match self {\n    None => logger.write_string(\"None\")\n    Some(arg) =>\n      logger..write_string(\"Some(\")..write_object(arg)..write_string(\")\")\n  }\n}\n\n///|\npub impl[T : Show, E : Show] Show for Result[T, E] with output(self, logger) {\n  match self {\n    Ok(x) => logger..write_string(\"Ok(\")..write_object(x)..write_string(\")\")\n    Err(e) => logger..write_string(\"Err(\")..write_object(e)..write_string(\")\")\n  }\n}\n\n///|\npub impl[X : Show] Show for FixedArray[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n\n///|\npub impl[X : Show] Show for Array[X] with output(self, logger) {\n  logger.write_iter(self.iter())\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the offset (charcode index) of the first occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn StringView::find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_find(self, str)\n  } else {\n    boyer_moore_horspool_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack left to right, matching the needle at each position\nfn brute_force_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let forward_len = haystack_len - needle_len\n  let mut i = 0\n  while i <= forward_len {\n    // Skip positions where first charcode doesn't match\n    while i <= forward_len && haystack.unsafe_charcode_at(i) != needle_first {\n      i += 1\n    }\n    if i <= forward_len {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i += 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for string search (left to right)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(0) }\n  guard haystack_len >= needle_len else { return None }\n  // Build skip table\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i in 0..<(needle_len - 1) {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = needle_len - 1 - i\n  }\n  for i = 0\n      i <= haystack_len - needle_len\n      i = i + skip_table[haystack.unsafe_charcode_at(i + needle_len - 1) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..=(needle_len - 1) {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\ntest \"boyer_moore_horspool_find edge cases\" {\n  inspect(boyer_moore_horspool_find(\"abc\"[:], \"\"[:]), content=\"Some(0)\")\n  inspect(boyer_moore_horspool_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\ntest \"boyer_moore_horspool_rev_find edge cases\" {\n  inspect(boyer_moore_horspool_rev_find(\"abc\"[:], \"\"[:]), content=\"Some(3)\")\n  inspect(boyer_moore_horspool_rev_find(\"ab\"[:], \"abcd\"[:]), content=\"None\")\n}\n\n///|\n/// Returns the offset of the first occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn String::find(self : String, str : StringView) -> Int? {\n  self[:].find(str)\n}\n\n///|\ntest \"find\" {\n  inspect(\"hello\".find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".find(\"l\"), content=\"Some(2)\")\n  inspect(\"hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"\"), content=\"Some(0)\")\n  inspect(\"hello\".find(\"world\"), content=\"None\")\n  inspect(\"\".find(\"\"), content=\"Some(0)\")\n  inspect(\"\".find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".find(\"hello\"), content=\"Some(0)\")\n  inspect(\"aaa\".find(\"aa\"), content=\"Some(0)\")\n  inspect(\"ğŸ˜€ğŸ˜€\".find(\"ğŸ˜€\"), content=\"Some(0)\")\n  inspect(\n    (\"ğŸ˜€ğŸ˜€aa\".repeat(20) + \"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\").find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\" + \"ğŸ˜€ğŸ˜€aa\".repeat(20)).find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(0)\",\n  )\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn StringView::find_by(self : StringView, pred : (Char) -> Bool) -> Int? {\n  for i, c in self {\n    if pred(c) {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset of the first character that satisfies the given predicate.\n/// If no such character is found, it returns None.\npub fn String::find_by(self : String, pred : (Char) -> Bool) -> Int? {\n  self[:].find_by(pred)\n}\n\n///|\ntest \"find_by\" {\n  inspect(\"hello\".find_by(c => c == 'o'), content=\"Some(4)\")\n  inspect(\"hello\".find_by(c => c == 'l'), content=\"Some(2)\")\n  inspect(\"hello\".find_by(c => c == 'z'), content=\"None\")\n  inspect(\"\".find_by(c => c == 'a'), content=\"None\")\n  inspect(\"hello\".find_by(c => c is ('0'..='9')), content=\"None\")\n  inspect(\"hello123\".find_by(c => c is ('0'..='9')), content=\"Some(5)\")\n  inspect(\"hello\".find_by(c => c is ('A'..='Z')), content=\"None\")\n  inspect(\"Hello\".find_by(c => c is ('A'..='Z')), content=\"Some(0)\")\n  inspect(\"Î±Î²Î³\".find_by(c => c == 'Î²'), content=\"Some(1)\")\n  inspect(\"ğŸ˜€ğŸ˜ğŸ˜‚\".find_by(c => c == 'ğŸ˜‚'), content=\"Some(2)\")\n}\n\n///|\n/// Returns the offset of the last occurrence of the given substring. If the\n/// substring is not found, it returns None.\npub fn StringView::rev_find(self : StringView, str : StringView) -> Int? {\n  if str.length() <= 4 {\n    brute_force_rev_find(self, str)\n  } else {\n    boyer_moore_horspool_rev_find(self, str)\n  }\n  // TODO: When the pattern string is long (>= 256),\n  // consider using Two-Way algorithm to ensure linear time complexity.\n}\n\n///|\n/// Simple brute force string search algorithm\n/// Scans the haystack right to left, matching the needle at each position\nfn brute_force_rev_find(haystack : StringView, needle : StringView) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let needle_first = needle.unsafe_charcode_at(0)\n  let mut i = haystack_len - needle_len\n  while i >= 0 {\n    // Skip positions where first charcode doesn't match\n    while i >= 0 && haystack.unsafe_charcode_at(i) != needle_first {\n      i -= 1\n    }\n    if i >= 0 {\n      // Check remaining charcodes for full match\n      for j in 1..<needle_len {\n        if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n          break\n        }\n      } else {\n        return Some(i)\n      }\n      i -= 1\n    }\n  }\n  None\n}\n\n///|\n/// Boyer-Moore-Horspool algorithm for reverse string search (right to left)\n/// More efficient than brute force for longer patterns by using bad char heuristic\nfn boyer_moore_horspool_rev_find(\n  haystack : StringView,\n  needle : StringView,\n) -> Int? {\n  let haystack_len = haystack.length()\n  let needle_len = needle.length()\n  guard needle_len > 0 else { return Some(haystack_len) }\n  guard haystack_len >= needle_len else { return None }\n  let skip_table = FixedArray::make(1 << 8, needle_len)\n  for i = needle_len - 1; i > 0; i = i - 1 {\n    skip_table[needle.unsafe_charcode_at(i) & 0xFF] = i\n  }\n  for i = haystack_len - needle_len\n      i >= 0\n      i = i - skip_table[haystack.unsafe_charcode_at(i) & 0xFF] {\n    // Check all charcodes for match at current position\n    for j in 0..<needle_len {\n      if haystack.unsafe_charcode_at(i + j) != needle.unsafe_charcode_at(j) {\n        break\n      }\n    } else {\n      return Some(i)\n    }\n  }\n  None\n}\n\n///|\n/// Returns the offset (charcode index) of the last occurrence of the given\n/// substring. If the substring is not found, it returns None.\npub fn String::rev_find(self : String, str : StringView) -> Int? {\n  self[:].rev_find(str)\n}\n\n///|\ntest \"rev_find\" {\n  inspect(\"hello\".rev_find(\"o\"), content=\"Some(4)\")\n  inspect(\"hello\".rev_find(\"l\"), content=\"Some(3)\")\n  inspect(\"hello\".rev_find(\"hello\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"h\"), content=\"Some(0)\")\n  inspect(\"hello\".rev_find(\"\"), content=\"Some(5)\")\n  inspect(\"hello\".rev_find(\"world\"), content=\"None\")\n  inspect(\"\".rev_find(\"\"), content=\"Some(0)\")\n  inspect(\"\".rev_find(\"a\"), content=\"None\")\n  inspect(\"hello hello\".rev_find(\"hello\"), content=\"Some(6)\")\n  inspect(\"aaa\".rev_find(\"aa\"), content=\"Some(1)\")\n  inspect(\"ğŸ˜€ğŸ˜€\".rev_find(\"ğŸ˜€\"), content=\"Some(2)\")\n  inspect(\n    (\"ğŸ˜€ğŸ˜€aa\".repeat(20) + \"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\").rev_find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(120)\",\n  )\n  inspect(\n    (\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\" + \"ğŸ˜€ğŸ˜€aa\".repeat(20)).rev_find(\"ğŸ˜€ğŸ˜€ğŸ˜€ğŸ˜€\"),\n    content=\"Some(4)\",\n  )\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn StringView::has_suffix(self : StringView, str : StringView) -> Bool {\n  self.rev_find(str) is Some(i) && i == self.length() - str.length()\n}\n\n///|\n/// Returns true if the given substring is suffix of this string.\n#alias(ends_with, deprecated)\npub fn String::has_suffix(self : String, str : StringView) -> Bool {\n  self[:].has_suffix(str)\n}\n\n///|\ntest \"has_suffix\" {\n  inspect(\"hello\".has_suffix(\"lo\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"hello\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"\"), content=\"true\")\n  inspect(\"hello\".has_suffix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_suffix(\"hel\"), content=\"false\")\n  inspect(\"\".has_suffix(\"\"), content=\"true\")\n  inspect(\"\".has_suffix(\"a\"), content=\"false\")\n  inspect(\"hello world\".has_suffix(\"world\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".has_suffix(\"ğŸ˜€\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".has_suffix(\"ğŸ˜€ğŸ˜€\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn StringView::has_prefix(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(i) && i == 0\n}\n\n///|\n/// Returns true if this string starts with the given substring.\n#alias(starts_with, deprecated)\npub fn String::has_prefix(self : String, str : StringView) -> Bool {\n  self[:].has_prefix(str)\n}\n\n///|\ntest \"has_prefix\" {\n  inspect(\"hello\".has_prefix(\"h\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"he\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"\"), content=\"true\")\n  inspect(\"hello\".has_prefix(\"world\"), content=\"false\")\n  inspect(\"hello\".has_prefix(\"lo\"), content=\"false\")\n  inspect(\"\".has_prefix(\"\"), content=\"true\")\n  inspect(\"\".has_prefix(\"a\"), content=\"false\")\n  inspect(\"ğŸ˜€hello\".has_prefix(\"ğŸ˜€\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhello\".has_prefix(\"ğŸ˜€ğŸ˜ƒ\"), content=\"true\")\n  inspect(\"ğŸ˜€hello\".has_prefix(\"ğŸ˜ƒ\"), content=\"false\")\n  inspect(\"helloğŸ˜€\".has_prefix(\"ğŸ˜€\"), content=\"false\")\n}\n\n///|\n/// Removes the given suffix from the string if it exists.\n/// \n/// Returns `Some(prefix)` if the string ends with the given suffix,\n/// where `prefix` is the string without the suffix.\n/// Returns `None` if the string does not end with the suffix.\n/// \n/// # Example\n/// \n/// ```mbt test\n/// inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n/// inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n/// inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// ```\npub fn String::strip_suffix(self : String, suffix : StringView) -> StringView? {\n  if self.has_suffix(suffix) {\n    Some(self.view(end_offset=self.length() - suffix.length()))\n  } else {\n    None\n  }\n}\n\n///|\ntest \"strip_prefix\" {\n  inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n  inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_prefix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_prefix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"ğŸ˜€hello\".strip_prefix(\"ğŸ˜€\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhello\".strip_prefix(\"ğŸ˜€ğŸ˜ƒ\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\ntest \"strip_suffix\" {\n  inspect(\"hello world\".strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"hello world\".strip_suffix(\" moon\"), content=\"None\")\n  inspect(\"hello\".strip_suffix(\"hello\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(\"\".strip_suffix(\"a\"), content=\"None\")\n  inspect(\"abc\".strip_suffix(\"\"), content=\"Some(\\\"abc\\\")\")\n  inspect(\"helloğŸ˜€\".strip_suffix(\"ğŸ˜€\"), content=\"Some(\\\"hello\\\")\")\n  inspect(\"helloğŸ˜€ğŸ˜ƒ\".strip_suffix(\"ğŸ˜€ğŸ˜ƒ\"), content=\"Some(\\\"hello\\\")\")\n}\n\n///|\n/// Removes the given prefix from the string if it exists.\n/// \n/// Returns `Some(suffix)` if the string starts with the given prefix,\n/// where `suffix` is the string without the prefix.\n/// Returns `None` if the string does not start with the prefix.\n/// \n/// # Example\n/// \n/// ```mbt test\n/// inspect(\"hello world\".strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n/// inspect(\"hello world\".strip_prefix(\"hi \"), content=\"None\")\n/// inspect(\"hello\".strip_prefix(\"hello\"), content=\"Some(\\\"\\\")\")\n/// ```\npub fn String::strip_prefix(self : String, prefix : StringView) -> StringView? {\n  if self.has_prefix(prefix) {\n    Some(self.view(start_offset=prefix.length()))\n  } else {\n    None\n  }\n}\n\n///|\n/// Removes the given prefix from the view if it exists.\n/// \n/// Returns `Some(suffix)` if the view starts with the given prefix,\n/// where `suffix` is the view without the prefix.\n/// Returns `None` if the view does not start with the prefix.\n/// \n/// # Example\n/// \n/// ```mbt test\n/// let view = \"hello world\"[:]\n/// inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n/// inspect(view.strip_prefix(\"hi \"), content=\"None\")\n/// inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// ```\n/// \npub fn StringView::strip_prefix(\n  self : StringView,\n  prefix : StringView,\n) -> StringView? {\n  if self.has_prefix(prefix) {\n    Some(self.view(start_offset=prefix.length()))\n  } else {\n    None\n  }\n}\n\n///|\n/// Removes the given suffix from the view if it exists.\n/// \n/// Returns `Some(prefix)` if the view ends with the given suffix,\n/// where `prefix` is the view without the suffix.\n/// Returns `None` if the view does not end with the suffix.\n/// \n/// # Example\n/// \n/// ```mbt test\n/// let view = \"hello world\"[:]\n/// inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n/// inspect(view.strip_suffix(\" moon\"), content=\"None\")\n/// inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n/// ```\npub fn StringView::strip_suffix(\n  self : StringView,\n  suffix : StringView,\n) -> StringView? {\n  if self.has_suffix(suffix) {\n    Some(self.view(end_offset=self.length() - suffix.length()))\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts the View into an array of Chars.\n/// \n/// # Example\n/// \n/// ```mbt test\n/// let view = \"HelloğŸ¤£xa\"[1:-1]\n/// let chars = view.to_array()\n/// inspect(chars, content=\"['e', 'l', 'l', 'o', 'ğŸ¤£', 'x']\")\n/// ```\npub fn StringView::to_array(self : StringView) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n#deprecated(\"Check `@encoding/utf8.encode`\")\n#coverage.skip\npub fn StringView::to_bytes(self : StringView) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self.data(), self.start_offset(), self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\ntest \"View::strip_prefix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_prefix(\"hello \"), content=\"Some(\\\"world\\\")\")\n  inspect(view.strip_prefix(\"hi \"), content=\"None\")\n  inspect(view.strip_prefix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_prefix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_prefix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_prefix(\"a\"), content=\"None\")\n  let unicode_view = \"ğŸ˜€helloğŸ˜ƒ\"[:]\n  inspect(unicode_view.strip_prefix(\"ğŸ˜€\"), content=\"Some(\\\"helloğŸ˜ƒ\\\")\")\n  inspect(unicode_view.strip_prefix(\"ğŸ˜ƒ\"), content=\"None\")\n}\n\n///|\ntest \"View::strip_suffix\" {\n  let view = \"hello world\"[:]\n  inspect(view.strip_suffix(\" world\"), content=\"Some(\\\"hello\\\")\")\n  inspect(view.strip_suffix(\" moon\"), content=\"None\")\n  inspect(view.strip_suffix(\"hello world\"), content=\"Some(\\\"\\\")\")\n  inspect(view.strip_suffix(\"\"), content=\"Some(\\\"hello world\\\")\")\n  let empty_view = \"\"[:]\n  inspect(empty_view.strip_suffix(\"\"), content=\"Some(\\\"\\\")\")\n  inspect(empty_view.strip_suffix(\"a\"), content=\"None\")\n  let unicode_view = \"ğŸ˜€helloğŸ˜ƒ\"[:]\n  inspect(unicode_view.strip_suffix(\"ğŸ˜ƒ\"), content=\"Some(\\\"ğŸ˜€hello\\\")\")\n  inspect(unicode_view.strip_suffix(\"ğŸ˜€\"), content=\"None\")\n}\n\n///|\ntest \"View::to_array\" {\n  let view = \"HelloğŸ¤£\"[:]\n  let chars = view.to_array()\n  assert_eq(chars, ['H', 'e', 'l', 'l', 'o', 'ğŸ¤£'])\n  let empty_view = \"\"[:]\n  let empty_chars = empty_view.to_array()\n  assert_eq(empty_chars, [])\n  let sub_view = \"Hello World\"[6:11] // \"World\"\n  let sub_chars = sub_view.to_array()\n  assert_eq(sub_chars, ['W', 'o', 'r', 'l', 'd'])\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn StringView::contains(self : StringView, str : StringView) -> Bool {\n  self.find(str) is Some(_)\n}\n\n///|\n/// Returns true if this string contains the given substring.\npub fn String::contains(self : String, str : StringView) -> Bool {\n  self[:].contains(str)\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn StringView::contains_any(self : StringView, chars~ : StringView) -> Bool {\n  match chars {\n    [] => false\n    [c] => self.contains_char(c) // specialize for single character\n    _ =>\n      for c in self {\n        if chars.contains_char(c) {\n          break true\n        }\n      } else {\n        false\n      }\n  }\n}\n\n///|\n/// Returns true if this string contains any character from the given set.\npub fn String::contains_any(self : String, chars~ : StringView) -> Bool {\n  self[:].contains_any(chars~)\n}\n\n///|\ntest \"contains\" {\n  inspect(\"hello\".contains(\"o\"), content=\"true\")\n  inspect(\"hello\".contains(\"l\"), content=\"true\")\n  inspect(\"hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"hello\".contains(\"h\"), content=\"true\")\n  inspect(\"hello\".contains(\"\"), content=\"true\")\n  inspect(\"hello\".contains(\"world\"), content=\"false\")\n  inspect(\"\".contains(\"\"), content=\"true\")\n  inspect(\"\".contains(\"a\"), content=\"false\")\n  inspect(\"hello hello\".contains(\"hello\"), content=\"true\")\n  inspect(\"aaa\".contains(\"aa\"), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".contains(\"ğŸ˜€\"), content=\"true\")\n}\n\n///|\ntest \"contains_any\" {\n  inspect(\"hello\".contains_any(chars=\"h\"), content=\"true\")\n  inspect(\"hello\".contains_any(chars=\"xyz\"), content=\"false\")\n  inspect(\"hello\".contains_any(chars=\"\"), content=\"false\")\n  inspect(\"\".contains_any(chars=\"abc\"), content=\"false\")\n  inspect(\"ğŸ˜€ğŸ˜ƒ\".contains_any(chars=\"ğŸ˜„ğŸ˜€\"), content=\"true\")\n  inspect(\"hello\"[:].contains_any(chars=\"eo\"), content=\"true\")\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn StringView::contains_char(self : StringView, c : Char) -> Bool {\n  let len = self.length()\n  // Check empty\n  guard len > 0 else { return false }\n  let c = c.to_int()\n  if c <= 0xFFFF {\n    // Search BMP\n    for i in 0..<len {\n      if self.unsafe_charcode_at(i) == c {\n        return true\n      }\n    }\n  } else {\n    // Check insufficient\n    guard len >= 2 else { return false }\n    // Calc surrogate pair\n    let adj = c - 0x10000\n    let high = 0xD800 + (adj >> 10)\n    let low = 0xDC00 + (adj & 0x3FF)\n    // Search surrogate pair\n    let mut i = 0\n    while i < len - 1 {\n      if self.unsafe_charcode_at(i) == high {\n        i += 1\n        if self.unsafe_charcode_at(i) == low {\n          return true\n        }\n      }\n      i += 1\n    }\n  }\n  false\n}\n\n///|\n/// Returns true if this string contains the given character.\npub fn String::contains_char(self : String, c : Char) -> Bool {\n  self[:].contains_char(c)\n}\n\n///|\ntest \"contains_char\" {\n  inspect(\"hello\".contains_char('h'), content=\"true\")\n  inspect(\"hello\".contains_char('e'), content=\"true\")\n  inspect(\"hello\".contains_char('l'), content=\"true\")\n  inspect(\"hello\".contains_char('o'), content=\"true\")\n  inspect(\"hello\".contains_char('x'), content=\"false\")\n  inspect(\"\".contains_char('a'), content=\"false\")\n  inspect(\"hello world\".contains_char(' '), content=\"true\")\n  inspect(\"hello world\".contains_char('w'), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".contains_char('ğŸ˜€'), content=\"true\")\n  inspect(\"ğŸ˜€ğŸ˜€\".contains_char('ğŸ˜ƒ'), content=\"false\")\n  inspect(\"hello\".contains_char((104).unsafe_to_char()), content=\"true\") // 'h' is 104 in ASCII\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, allow_positional=true)\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_start(\n  self : StringView,\n  chars~ : StringView,\n) -> StringView {\n  loop self {\n    [] as v => v\n    [c, .. rest] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the leading characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim_start(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_start(chars~)\n}\n\n///|\ntest \"trim_start\" {\n  inspect(\"hello\".trim_start(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim_start(chars=\"he\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"eh\"), content=\"llo\")\n  inspect(\"hello\".trim_start(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_start(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_start(chars=\"a\"), content=\"\")\n  inspect(\"   hello\".trim_start(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_start(chars=\"helo\"), content=\" world\")\n  inspect(\"ğŸ˜€ğŸ˜€hello\".trim_start(chars=\"ğŸ˜€\"), content=\"hello\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhello\".trim_start(chars=\"ğŸ˜€ğŸ˜ƒ\"), content=\"hello\")\n  inspect(\"aaaabc\".trim_start(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim_start(chars=\"a\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim_end(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  loop self {\n    [] as v => v\n    [.. rest, c] as v => if chars.contains_char(c) { continue rest } else { v }\n  }\n}\n\n///|\n/// Returns the view of the string without the trailing characters that are in\n/// the given string.\n// TODO(upstream): label_migration warning does not apply to the current package\n// TODO: make chars optional with default value of whitespace characters\n#label_migration(chars, alias=char_set)\npub fn String::trim_end(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim_end(chars~)\n}\n\n///|\ntest \"trim_end\" {\n  inspect(\"hello\".trim_end(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim_end(chars=\"lo\"), content=\"he\")\n  inspect(\"hello\".trim_end(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim_end(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim_end(chars=\"a\"), content=\"\")\n  inspect(\"hello   \".trim_end(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim_end(chars=\"dlrow \"), content=\"he\")\n  inspect(\"helloğŸ˜€ğŸ˜€\".trim_end(chars=\"ğŸ˜€\"), content=\"hello\")\n  inspect(\"helloğŸ˜€ğŸ˜ƒ\".trim_end(chars=\"ğŸ˜€ğŸ˜ƒ\"), content=\"hello\")\n  inspect(\"abcccc\".trim_end(chars=\"c\"), content=\"ab\")\n  inspect(\"cccc\".trim_end(chars=\"c\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn StringView::trim(\n  self : StringView,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self.trim_start(chars~).trim_end(chars~)\n}\n\n///|\n/// Returns the view of the string without the leading and trailing characters\n/// that are in the given string.\n#label_migration(chars, alias=char_set)\npub fn String::trim(\n  self : String,\n  chars? : StringView = \"\\t\\n\\r \",\n) -> StringView {\n  self[:].trim(chars~)\n}\n\n///|\ntest \"trim\" {\n  inspect(\"hello\".trim(chars=\"h\"), content=\"ello\")\n  inspect(\"hello\".trim(chars=\"o\"), content=\"hell\")\n  inspect(\"hello\".trim(chars=\"ho\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"oh\"), content=\"ell\")\n  inspect(\"hello\".trim(chars=\"x\"), content=\"hello\")\n  inspect(\"hello\".trim(chars=\"\"), content=\"hello\")\n  inspect(\"\".trim(chars=\"a\"), content=\"\")\n  inspect(\"   hello   \".trim(chars=\" \"), content=\"hello\")\n  inspect(\"hello world\".trim(chars=\"hd\"), content=\"ello worl\")\n  inspect(\"ğŸ˜€helloğŸ˜€\".trim(chars=\"ğŸ˜€\"), content=\"hello\")\n  inspect(\"ğŸ˜€ğŸ˜ƒhelloğŸ˜€ğŸ˜ƒ\".trim(chars=\"ğŸ˜€ğŸ˜ƒ\"), content=\"hello\")\n  inspect(\"aaaabcaaa\".trim(chars=\"a\"), content=\"bc\")\n  inspect(\"aaaa\".trim(chars=\"a\"), content=\"\")\n  inspect(\"  hello world  \".trim(chars=\" \"), content=\"hello world\")\n  inspect(\"abcabc\".trim(chars=\"abc\"), content=\"\")\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn StringView::trim_space(self : StringView) -> StringView {\n  self.trim()\n}\n\n///|\n/// Returns the view of the string without the leading and trailing spaces.\n#deprecated(\"Use `trim` with default whitespace characters instead\")\npub fn String::trim_space(self : String) -> StringView {\n  self.trim()\n}\n\n///|\ntest \"trim whitespace for string\" {\n  inspect(\"hello\".trim(), content=\"hello\")\n  inspect(\"  hello  \".trim(), content=\"hello\")\n  inspect(\"hello  \".trim(), content=\"hello\")\n  inspect(\"  hello\".trim(), content=\"hello\")\n  inspect(\"\\t\\nhello\\r\\n\".trim(), content=\"hello\")\n  inspect(\"  hello world  \".trim(), content=\"hello world\")\n  inspect(\"  \".trim(), content=\"\")\n  inspect(\"\\n\\r\\t\".trim(), content=\"\")\n  inspect(\"\".trim(), content=\"\")\n  inspect(\"  hello\\nworld\\t\".trim(), content=\"hello\\nworld\")\n}\n\n///|\n/// Returns true if this string is empty.\npub fn StringView::is_empty(self : StringView) -> Bool {\n  self.length() == 0\n}\n\n///|\n/// Returns true if this string is empty.\npub fn String::is_empty(self : String) -> Bool {\n  self == \"\"\n}\n\n///|\ntest \"is_empty\" {\n  inspect(\"\".is_empty(), content=\"true\")\n  inspect(\"hello\".is_empty(), content=\"false\")\n  inspect(\" \".is_empty(), content=\"false\")\n  inspect(\"\\n\".is_empty(), content=\"false\")\n  inspect(\"\\t\".is_empty(), content=\"false\")\n  inspect(\"   \".is_empty(), content=\"false\")\n\n  // Test with string views\n  let s = \"hello\"\n  let empty_view = s[0:0]\n  let non_empty_view = s[0:3]\n  inspect(empty_view.is_empty(), content=\"true\")\n  inspect(non_empty_view.is_empty(), content=\"false\")\n}\n\n///|\n/// Returns true if this string is blank.\npub fn StringView::is_blank(self : StringView) -> Bool {\n  self.trim().is_empty()\n}\n\n///|\n/// Returns true if this string is blank.\npub fn String::is_blank(self : String) -> Bool {\n  self[:].is_blank()\n}\n\n///|\ntest \"is_blank\" {\n  inspect(\"\".is_blank(), content=\"true\")\n  inspect(\"hello\".is_blank(), content=\"false\")\n  inspect(\" \".is_blank(), content=\"true\")\n  inspect(\"\\n\".is_blank(), content=\"true\")\n  inspect(\"\\t\".is_blank(), content=\"true\")\n  inspect(\"   \".is_blank(), content=\"true\")\n  inspect(\" \\n\\t\\r \".is_blank(), content=\"true\")\n  inspect(\"hello world\".is_blank(), content=\"false\")\n  inspect(\"  hello  \".is_blank(), content=\"false\")\n\n  // Test with string views\n  let s = \"   hello  \"\n  let blank_view = s[0:3] // \"   \"\n  let non_blank_view = s[3:8] // \"hello\"\n  inspect(blank_view.is_blank(), content=\"true\")\n  inspect(non_blank_view.is_blank(), content=\"false\")\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_start(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\n/// Returns a new string with `padding_char`s prefixed to `self` if\n/// `self.char_length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_start(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..padding, ..self]\n}\n\n///|\ntest \"pad_start\" {\n  // Test with regular strings\n  inspect(\"2\".pad_start(3, '0'), content=\"002\")\n  inspect(\"abc\".pad_start(5, 'x'), content=\"xxabc\")\n  inspect(\"hello\".pad_start(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_start(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_start(8, '*'), content=\"****test\")\n  inspect(\"123\".pad_start(6, '0'), content=\"000123\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_start(5, 'x'), content=\"xxllo\")\n\n  // Test with Unicode characters\n  inspect(\"ğŸŒŸ\".pad_start(3, 'âœ¨'), content=\"âœ¨ğŸŒŸ\")\n\n  // Edge cases\n  inspect(\"abc\".pad_start(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_start(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn StringView::pad_end(\n  self : StringView,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self.to_string() }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\n/// Returns a new string with `padding_char`s appended to `self` if\n/// `self.length() < total_width`. The number of unicode characters in\n/// the returned string is `total_width` if padding is added.\npub fn String::pad_end(\n  self : String,\n  total_width : Int,\n  padding_char : Char,\n) -> String {\n  let len = self.length()\n  guard len < total_width else { return self }\n  let padding = String::make(total_width - len, padding_char)\n  [..self, ..padding]\n}\n\n///|\ntest \"pad_end\" {\n  // Test with regular strings\n  inspect(\"2\".pad_end(3, '0'), content=\"200\")\n  inspect(\"abc\".pad_end(5, 'x'), content=\"abcxx\")\n  inspect(\"hello\".pad_end(4, ' '), content=\"hello\") // No padding needed\n  inspect(\"\".pad_end(3, '-'), content=\"---\")\n\n  // Test with different padding characters\n  inspect(\"test\".pad_end(8, '*'), content=\"test****\")\n  inspect(\"123\".pad_end(6, '0'), content=\"123000\")\n\n  // Test with string views\n  let s = \"hello\"\n  let view = s[2:5] // \"llo\"\n  inspect(view.pad_end(5, 'x'), content=\"lloxx\")\n\n  // Test with Unicode characters\n  inspect(\"ğŸŒŸ\".pad_end(3, 'âœ¨'), content=\"ğŸŒŸâœ¨\")\n\n  // Edge cases\n  inspect(\"abc\".pad_end(0, 'x'), content=\"abc\") // width less than string length\n  inspect(\"abc\".pad_end(3, 'x'), content=\"abc\") // width equal to string length\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn StringView::repeat(self : StringView, n : Int) -> StringView {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\n/// Returns a new string with `self` repeated `n` times.\npub fn String::repeat(self : String, n : Int) -> String {\n  match n {\n    _..=0 => \"\"\n    1 => self\n    _ => {\n      let len = self.length()\n      let buf = StringBuilder::new(size_hint=len * n)\n      let str = self.to_string()\n      for _ in 0..<n {\n        buf.write_string(str)\n      }\n      buf.to_string()\n    }\n  }\n}\n\n///|\ntest \"repeat\" {\n  // Test with regular strings\n  inspect(\"abc\".repeat(3), content=\"abcabcabc\")\n  inspect(\"x\".repeat(5), content=\"xxxxx\")\n  inspect(\"hello \".repeat(2), content=\"hello hello \")\n\n  // Test with empty string\n  inspect(\"\".repeat(10), content=\"\")\n\n  // Test with string views\n  let s = \"hello world\"\n  let view = s[6:11] // \"world\"\n  inspect(view.repeat(2), content=\"worldworld\")\n\n  // Test with Unicode characters\n  inspect(\"ğŸŒŸ\".repeat(3), content=\"ğŸŒŸğŸŒŸğŸŒŸ\")\n  inspect(\"âœ¨ğŸŒŸ\".repeat(2), content=\"âœ¨ğŸŒŸâœ¨ğŸŒŸ\")\n\n  // Edge cases\n  inspect(\"abc\".repeat(0), content=\"\")\n  inspect(\"abc\".repeat(-5), content=\"\")\n  inspect(\"abc\".repeat(1), content=\"abc\")\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn StringView::rev(self : StringView) -> String {\n  let buf = StringBuilder::new(size_hint=self.length())\n  for c in self.rev_iter() {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Returns a new string with the characters in reverse order. It respects\n/// Unicode characters and surrogate pairs but not grapheme clusters.\npub fn String::rev(self : String) -> String {\n  self[:].rev()\n}\n\n///|\ntest \"rev\" {\n  inspect(\"hello\".rev(), content=\"olleh\")\n  inspect(\"\".rev(), content=\"\")\n  inspect(\"abc\".rev(), content=\"cba\")\n  inspect(\"ğŸ˜€ğŸ˜ƒ\".rev(), content=\"ğŸ˜ƒğŸ˜€\")\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn StringView::split(\n  self : StringView,\n  sep : StringView,\n) -> Iter[StringView] {\n  let sep_len = sep.length()\n  if sep_len == 0 {\n    return self.iter().map(c => c.to_string().view())\n  }\n  let mut remaining = Some(self)\n  Iterator::new(() => {\n    guard remaining is Some(view) else { None }\n    guard view.find(sep) is Some(end) else {\n      remaining = None\n      Some(view)\n    }\n    remaining = Some(view.view(start_offset=end + sep_len))\n    Some(view.view(end_offset=end))\n  }).iter()\n}\n\n///|\n/// Splits the string into all substrings separated by the given separator.\n/// \n/// If the string does not contain the separator and the separator is not empty,\n/// the returned iterator will contain only one element, which is the original\n/// string.\n/// \n/// If the separator is empty, the returned iterator will contain all the\n/// characters in the string as single elements.\npub fn String::split(self : String, sep : StringView) -> Iter[StringView] {\n  self[:].split(sep)\n}\n\n///|\ntest \"split\" {\n  assert_eq(\"a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\n    \"apple::orange::banana\".split(\"::\").map(StringView::to_string).collect(),\n    [\"apple\", \"orange\", \"banana\"],\n  )\n  assert_eq(\"abc\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"hello\".split(\",\").map(StringView::to_string).collect(), [\"hello\"])\n  assert_eq(\",a,b,c\".split(\",\").map(StringView::to_string).collect(), [\n    \"\", \"a\", \"b\", \"c\",\n  ])\n  assert_eq(\"a,b,c,\".split(\",\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\", \"\",\n  ])\n  assert_eq(\"a,b,c\".split(\"\").map(StringView::to_string).collect(), [\n    \"a\", \",\", \"b\", \",\", \"c\",\n  ])\n  assert_eq(\"\".split(\"\").map(StringView::to_string).collect(), [])\n  assert_eq(\"\".split(\",\").map(StringView::to_string).collect(), [\"\"])\n  assert_eq(\"ğŸ˜€,ğŸ˜ƒ,ğŸ˜„\".split(\",\").map(StringView::to_string).collect(), [\n    \"ğŸ˜€\", \"ğŸ˜ƒ\", \"ğŸ˜„\",\n  ])\n  assert_eq(\"ağŸ˜€bğŸ˜€c\".split(\"ğŸ˜€\").map(StringView::to_string).collect(), [\n    \"a\", \"b\", \"c\",\n  ])\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn StringView::replace(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\n/// Replaces the first occurrence of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches the beginning of the string, and `new` is\n/// prepended to the string.\npub fn String::replace(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  match self.find(old) {\n    Some(end) =>\n      [\n        ..self.view(end_offset=end),\n        ..new,\n        ..self.view(start_offset=end + old.length()),\n      ]\n    None => self\n  }\n}\n\n///|\ntest \"replace\" {\n  inspect(\"hello\".replace(old=\"o\", new=\"a\"), content=\"hella\")\n  inspect(\"hello\".replace(old=\"l\", new=\"a\"), content=\"healo\")\n  inspect(\"hello\".replace(old=\"hello\", new=\"a\"), content=\"a\")\n  inspect(\"hello\".replace(old=\"h\", new=\"a\"), content=\"aello\")\n  inspect(\"hello\".replace(old=\"\", new=\"a\"), content=\"ahello\")\n  inspect(\"hello\".replace(old=\"world\", new=\"a\"), content=\"hello\")\n  inspect(\"\".replace(old=\"\", new=\"a\"), content=\"a\")\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn StringView::replace_all(\n  self : StringView,\n  old~ : StringView,\n  new~ : StringView,\n) -> StringView {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self, end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\n/// Replaces all non-overlapping occurrences of `old` with `new` in `self`.\n/// \n/// If `old` is empty, it matches at the beginning of the string and after each\n/// character in the string, so `new` is inserted at the beginning of the string\n/// and after each character.\npub fn String::replace_all(\n  self : String,\n  old~ : StringView,\n  new~ : StringView,\n) -> String {\n  let len = self.length()\n  let buf = StringBuilder::new(size_hint=len)\n  let old_len = old.length()\n  let new = new.to_string()\n  // use write_substring to avoid intermediate allocations\n  if old_len == 0 {\n    buf.write_string(new)\n    for c in self {\n      buf.write_char(c)\n      buf.write_string(new)\n    }\n    buf.to_string()\n  } else {\n    let first_end = self.find(old)\n    if first_end is Some(end) {\n      for view = self[:], end = end {\n        let seg = view.view(end_offset=end)\n        buf.write_substring(seg.data(), seg.start_offset(), seg.length())\n        buf.write_string(new)\n        // check if there is no more characters after the last occurrence of `old`\n        guard end + old_len <= len else { break }\n        let next_view = view.view(start_offset=end + old_len)\n        guard next_view.find(old) is Some(next_end) else {\n          buf.write_substring(\n            next_view.data(),\n            next_view.start_offset(),\n            next_view.length(),\n          )\n          break\n        }\n        continue next_view, next_end\n      }\n      buf.to_string()\n    } else {\n      self\n    }\n  }\n}\n\n///|\ntest \"replace_all\" {\n  assert_eq(\"hello\".replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\".replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\".replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\".replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\"hello hello hello\".replace_all(old=\"hello\", new=\"hi\"), \"hi hi hi\")\n  assert_eq(\n    \"hello hello helloi\".replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\".replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\".replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\".replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\".replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\".replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\".replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\"ğŸ¤£ğŸ¤£ğŸ¤£\".replace_all(old=\"ğŸ¤£\", new=\"ğŸ˜Š\"), \"ğŸ˜ŠğŸ˜ŠğŸ˜Š\")\n  assert_eq(\"abc123abc\".replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\".replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"String::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1187: guard end + old_len <= len else { break }\n  // This happens when the pattern is found at the very end of the string\n\n  // Pattern at the end of string - should trigger the guard condition\n  assert_eq(\"helloworld\".replace_all(old=\"world\", new=\"X\"), \"helloX\")\n  assert_eq(\"abcdef\".replace_all(old=\"def\", new=\"XYZ\"), \"abcXYZ\")\n\n  // Multiple patterns where the last one is at the end\n  assert_eq(\"abcabc\".replace_all(old=\"abc\", new=\"X\"), \"XX\")\n\n  // Pattern that exactly matches the string length\n  assert_eq(\"test\".replace_all(old=\"test\", new=\"done\"), \"done\")\n\n  // Empty replacement at the end\n  assert_eq(\"remove_me\".replace_all(old=\"_me\", new=\"\"), \"remove\")\n}\n\n///|\ntest \"View::replace_all\" {\n  assert_eq(\"hello\"[:].replace_all(old=\"o\", new=\"a\"), \"hella\")\n  assert_eq(\"hello\"[:].replace_all(old=\"l\", new=\"a\"), \"heaao\")\n  assert_eq(\"hello\"[:].replace_all(old=\"ll\", new=\"rr\"), \"herro\")\n  assert_eq(\"hello\"[:].replace_all(old=\"hello\", new=\"world\"), \"world\")\n  assert_eq(\n    \"hello hello hello\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hi\",\n  )\n  assert_eq(\n    \"hello hello helloi\"[:].replace_all(old=\"hello\", new=\"hi\"),\n    \"hi hi hii\",\n  )\n  assert_eq(\n    \"hi hi hii\"[:].replace_all(old=\"hi\", new=\"hello\"),\n    \"hello hello helloi\",\n  )\n  assert_eq(\"hello\"[:].replace_all(old=\"\", new=\"a\"), \"ahaealalaoa\")\n  assert_eq(\"hello\"[:].replace_all(old=\"world\", new=\"a\"), \"hello\")\n  assert_eq(\"\"[:].replace_all(old=\"\", new=\"a\"), \"a\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"b\"), \"bbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"a\", new=\"bb\"), \"bbbbbb\")\n  assert_eq(\"aaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"ba\")\n  assert_eq(\n    \"ğŸ¤£ğŸ¤£ğŸ¤£\"[:].replace_all(old=\"ğŸ¤£\", new=\"ğŸ˜Š\"),\n    \"ğŸ˜ŠğŸ˜ŠğŸ˜Š\",\n  )\n  assert_eq(\"abc123abc\"[:].replace_all(old=\"abc\", new=\"xyz\"), \"xyz123xyz\")\n  assert_eq(\"abcabcabc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"abc\", new=\"\"), \"\")\n  assert_eq(\"abc\"[:].replace_all(old=\"\", new=\"x\"), \"xaxbxcx\")\n}\n\n///|\ntest \"View::replace_all boundary cases\" {\n  // These tests should trigger the uncovered line 1141: guard end + old_len <= len else { break }\n  // This condition triggers when end + old_len > len, meaning we're at the boundary\n\n  // Let me trace through the algorithm more carefully...\n  // Actually, let me try a different approach - create a scenario where the view length changes\n\n  // Try with overlapping patterns or edge cases\n  assert_eq(\"abcabc\"[:].replace_all(old=\"abc\", new=\"X\"), \"XX\")\n  assert_eq(\"aaaa\"[:].replace_all(old=\"aa\", new=\"b\"), \"bb\")\n\n  // Pattern at exact end\n  assert_eq(\"hello\"[:].replace_all(old=\"lo\", new=\"X\"), \"helX\")\n\n  // Test with empty string edge case\n  assert_eq(\"a\"[:].replace_all(old=\"a\", new=\"\"), \"\")\n\n  // Let me try to understand when end + old_len > len could happen...\n  // Maybe when we have a complex replacement scenario\n  inspect(\"Testing boundary condition\", content=\"Testing boundary condition\")\n}\n\n///|\n/// Converts this string to lowercase.\npub fn StringView::to_lower(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to lowercase.\npub fn String::to_lower(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(x => x.is_ascii_uppercase()) is Some(idx) else {\n    return self\n  }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_uppercase() {\n      // 'A' is 65 in ASCII, 'a' is 97, the difference is 32\n      buf.write_char((c.to_int() + 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_lower\" {\n  assert_eq(\"Hello\".to_lower(), \"hello\")\n  assert_eq(\"HELLO\".to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\".to_lower(), \"hello, world!\")\n}\n\n///|\ntest \"View::to_lower\" {\n  assert_eq(\"Hello\"[:].to_lower(), \"hello\")\n  assert_eq(\"HELLO\"[:].to_lower(), \"hello\")\n  assert_eq(\"Hello, World!\"[:].to_lower(), \"hello, world!\")\n}\n\n///|\n/// Converts this string to uppercase.\npub fn StringView::to_upper(self : StringView) -> StringView {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\n/// Converts this string to uppercase.\npub fn String::to_upper(self : String) -> String {\n  // TODO: deal with non-ascii characters\n  guard self.find_by(_.is_ascii_lowercase()) is Some(idx) else { return self }\n  let buf = StringBuilder::new(size_hint=self.length())\n  let head = self.view(end_offset=idx)\n  buf.write_substring(head.data(), head.start_offset(), head.length())\n  for c in self.view(start_offset=idx) {\n    if c.is_ascii_lowercase() {\n      buf.write_char((c.to_int() - 32).unsafe_to_char())\n    } else {\n      buf.write_char(c)\n    }\n  }\n  buf.to_string()\n}\n\n///|\ntest \"to_upper\" {\n  assert_eq(\"hello\".to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\".to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\".to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\ntest \"View::to_upper\" {\n  assert_eq(\"hello\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"HELLO\"[:].to_upper(), \"HELLO\")\n  assert_eq(\"Hello, World!\"[:].to_upper(), \"HELLO, WORLD!\")\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] StringView::fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\n/// Folds the characters of the string into a single value.\npub fn[A] String::fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].fold(init~, f)\n}\n\n///|\ntest \"fold\" {\n  assert_eq(\n    \"hello\".fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['h', 'e', 'l', 'l', 'o'],\n  )\n  assert_eq(\n    \"hello\".fold(init=0, (acc, c) => acc + c.to_int()),\n    104 + 101 + 108 + 108 + 111,\n  )\n}\n\n///|\ntest \"fold with raise\" {\n  let result = try? \"hello\".fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\npub fn[A] StringView::rev_fold(\n  self : StringView,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  let mut rv = init\n  for c in self.rev_iter() {\n    rv = f(rv, c)\n  }\n  rv\n}\n\n///|\npub fn[A] String::rev_fold(\n  self : String,\n  init~ : A,\n  f : (A, Char) -> A raise?,\n) -> A raise? {\n  self[:].rev_fold(init~, f)\n}\n\n///|\ntest \"rev_fold\" {\n  assert_eq(\n    \"hello\".rev_fold(init=[], (acc, c) => {\n      acc.push(c)\n      acc\n    }),\n    ['o', 'l', 'l', 'e', 'h'],\n  )\n  assert_eq(\n    \"hello\".rev_fold(init=0, (acc, c) => acc + c.to_int()),\n    111 + 108 + 108 + 101 + 104,\n  )\n}\n\n///|\ntest \"rev_fold with raise\" {\n  let result = try? \"hello\".rev_fold(init=0, (acc, c) => {\n    if c == 'l' {\n      raise Failure(\"found l\")\n    }\n    acc + 1\n  })\n  inspect(result, content=\"Err(Failure(\\\"found l\\\"))\")\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `String::code_unit_at` instead.\", skip_current_package=true)\npub fn String::get(self : String, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\n/// Returns the UTF-16 code unit at the given index. Returns `None` if the index\n/// is out of bounds.\n#deprecated(\"The return type is about to change to `UInt16?` in a future release. Please check boundaries manually and use `StringView::code_unit_at` instead.\", skip_current_package=true)\npub fn StringView::get(self : StringView, idx : Int) -> Int? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  Some(self.unsafe_charcode_at(idx))\n}\n\n///|\ntest \"String::get supports emoji (surrogate pair)\" {\n  let s = \"hello\"\n  inspect(s.get(0), content=\"Some(104)\")\n  inspect(s.get(4), content=\"Some(111)\")\n  inspect(s.get(5), content=\"None\")\n  inspect(s.get(-1), content=\"None\")\n  let s = \"ağŸ¤£b\"\n  inspect(s.get(0), content=\"Some(97)\")\n  inspect(s.get(1), content=\"Some(55358)\")\n  inspect(s.get(2), content=\"Some(56611)\")\n  inspect(s.get(3), content=\"Some(98)\")\n  inspect(s.get(4), content=\"None\")\n}\n\n///|\ntest \"View::get basic cases\" {\n  let v = \"hello\"[1:-1]\n  inspect(v.get(0), content=\"Some(101)\")\n  inspect(v.get(2), content=\"Some(108)\")\n  inspect(v.get(3), content=\"None\")\n  inspect(v.get(-1), content=\"None\")\n  let v = \"abğŸ¤£cd\"[1:-1]\n  inspect(v.get(0), content=\"Some(98)\")\n  inspect(v.get(1), content=\"Some(55358)\")\n  inspect(v.get(2), content=\"Some(56611)\")\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn String::get_char(self : String, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\n/// Returns the character at the given index. Returns `None` if the index is out\n/// of bounds or the index splits a surrogate pair.\npub fn StringView::get_char(self : StringView, idx : Int) -> Char? {\n  guard idx >= 0 && idx < self.length() else { return None }\n  let c = self.unsafe_charcode_at(idx)\n  if c.is_leading_surrogate() {\n    guard idx + 1 < self.length() else { return None }\n    let next = self.unsafe_charcode_at(idx + 1)\n    if next.is_trailing_surrogate() {\n      Some(code_point_of_surrogate_pair(c, next))\n    } else {\n      None\n    }\n  } else if c.is_trailing_surrogate() {\n    None\n  } else {\n    Some(c.unsafe_to_char())\n  }\n}\n\n///|\ntest \"String::get_char basic cases\" {\n  // Basic ASCII characters\n  let s = \"hello\"\n  inspect(s.get_char(0), content=\"Some('h')\")\n  inspect(s.get_char(1), content=\"Some('e')\")\n  inspect(s.get_char(4), content=\"Some('o')\")\n  inspect(s.get_char(5), content=\"None\")\n  inspect(s.get_char(-1), content=\"None\")\n\n  // Contains emoji (surrogate pair)\n  let s = \"ağŸ¤£b\"\n  inspect(s.get_char(0), content=\"Some('a')\")\n  inspect(s.get_char(1), content=\"Some('ğŸ¤£')\")\n  inspect(s.get_char(2), content=\"None\") // Second half of surrogate pair is not a valid char\n  inspect(s.get_char(3), content=\"Some('b')\")\n  inspect(s.get_char(4), content=\"None\")\n}\n\n///|\ntest \"View::get_char basic cases\" {\n  let s = \"ağŸ¤£b\"\n  let v = s[0:-1]\n  inspect(v.get_char(0), content=\"Some('a')\")\n  inspect(v.get_char(1), content=\"Some('ğŸ¤£')\")\n  inspect(v.get_char(2), content=\"None\")\n  inspect(v.get_char(3), content=\"None\")\n  inspect(v.get_char(4), content=\"None\")\n\n  // Test substring view\n  let v2 = s[1:3] // Only contains the emoji surrogate pair\n  inspect(v2.get_char(0), content=\"Some('ğŸ¤£')\")\n  inspect(v2.get_char(1), content=\"None\")\n  inspect(v2.get_char(2), content=\"None\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T] UninitializedArray::set_null(self : UninitializedArray[T], index : Int) = \"%fixedarray.set_null\"\n\n///|\n/// An `Array` is a collection of values that supports random access and can\n/// grow in size.\nstruct Array[T] {\n  mut buf : UninitializedArray[T]\n  mut len : Int\n}\n\n///|\nfn[T] Array::make_uninit(len : Int) -> Array[T] {\n  { buf: UninitializedArray::make(len), len }\n}\n\n///|\n/// Creates a new empty array with an optional initial capacity.\n///\n/// Parameters:\n///\n/// * `capacity` : The initial capacity of the array. If 0 (default), creates an\n/// array with minimum capacity. Must be non-negative.\n///\n/// Returns a new empty array of type `Array[T]` with the specified initial\n/// capacity.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr : Array[Int] = Array::new(capacity=10)\n/// inspect(arr.length(), content=\"0\")\n/// inspect(arr.capacity(), content=\"10\")\n/// let arr : Array[Int] = Array::new()\n/// inspect(arr.length(), content=\"0\")\n/// ```\npub fn[T] Array::new(capacity? : Int = 0) -> Array[T] {\n  if capacity == 0 {\n    []\n  } else {\n    { buf: UninitializedArray::make(capacity), len: 0 }\n  }\n}\n\n///|\n/// Returns the number of elements in the array.\n///\n/// Parameters:\n///\n/// * `array` : The array whose length is to be determined.\n///\n/// Returns the number of elements in the array as an integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// inspect(arr.length(), content=\"3\")\n/// let empty : Array[Int] = []\n/// inspect(empty.length(), content=\"0\")\n/// ```\n#intrinsic(\"%array.length\")\npub fn[T] Array::length(self : Array[T]) -> Int {\n  self.len\n}\n\n///|\n/// Truncates the array to the specified length. This function is marked as\n/// `unsafe` because it directly manipulates the internal buffer of the array,\n/// which can lead to undefined behavior if not used carefully.\n///\n/// # Parameters\n///\n/// - `self` : The array to be truncated.\n/// - `new_len` : The new length to which the array should be truncated. Must be\n/// less than or equal to the current length of the array.\n///\n/// # Returns\n///\n/// - `Unit` : This function does not return a value.\n///\n/// # Errors\n///\n/// - This function does not explicitly raise errors, but improper use (e.g.,\n/// setting `new_len` greater than the current length) can lead to undefined\n/// behavior.\n///\n/// TODO: this can be optimized by using the intrinsic to null out the range\nfn[T] Array::unsafe_truncate_to_length(self : Array[T], new_len : Int) -> Unit {\n  let len = self.length()\n  guard new_len <= len\n  for i in new_len..<len {\n    self.buf.set_null(i)\n  }\n  self.len = new_len\n}\n\n///|\ntest \"unsafe_truncate_to_length\" {\n  let arr = [1, 2, 3, 4, 5]\n  arr.unsafe_truncate_to_length(3)\n  inspect(arr, content=\"[1, 2, 3]\")\n}\n\n///|\nfn[T] Array::buffer(self : Array[T]) -> UninitializedArray[T] {\n  self.buf\n}\n\n///|\nfn[T] Array::resize_buffer(self : Array[T], new_capacity : Int) -> Unit {\n  let new_buf = UninitializedArray::make(new_capacity)\n  let old_buf = self.buf\n  let old_cap = old_buf.0.length()\n  let copy_len = if old_cap < new_capacity { old_cap } else { new_capacity }\n  UninitializedArray::unsafe_blit(new_buf, 0, old_buf, 0, copy_len)\n  self.buf = new_buf\n}\n\n///|\ntest \"array_unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"UninitializedArray::unsafe_blit_fixed\" {\n  let src = FixedArray::make(5, 0)\n  let dst = UninitializedArray::make(5)\n  for i in 0..<5 {\n    src[i] = i + 1\n  }\n  UninitializedArray::unsafe_blit_fixed(dst, 0, src, 0, 5)\n  for i in 0..<5 {\n    assert_eq(dst[i], src[i])\n  }\n}\n\n///|\ntest \"Array::resize_buffer\" {\n  let arr = Array::new(capacity=2)\n  arr.push(1)\n  arr.push(2)\n  arr.resize_buffer(4)\n  assert_eq(arr.buffer().0.length() >= 4, true)\n  arr.push(3)\n  arr.push(4)\n  assert_eq(arr.length(), 4)\n  assert_eq(arr[0], 1)\n  assert_eq(arr[1], 2)\n  assert_eq(arr[2], 3)\n  assert_eq(arr[3], 4)\n}\n\n///|\n/// Reallocate the array with a new capacity.\nfn[T] Array::realloc(self : Array[T]) -> Unit {\n  let old_cap = self.length()\n  let new_cap = if old_cap == 0 { 8 } else { old_cap * 2 }\n  self.resize_buffer(new_cap)\n}\n\n///|\n/// Reserves capacity to ensure that it can hold at least the number of elements\n/// specified by the `capacity` argument.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = [1]\n///   v.reserve_capacity(10)\n///   assert_eq(v.capacity(), 10)\n/// ```\npub fn[T] Array::reserve_capacity(self : Array[T], capacity : Int) -> Unit {\n  if self.capacity() >= capacity {\n    return\n  }\n  self.resize_buffer(capacity)\n}\n\n///|\n/// Shrinks the capacity of the array as much as possible.\n///\n/// # Example\n///\n/// ```mbt\n///   let v = Array::new(capacity=10)\n///   v.push(1)\n///   v.push(2)\n///   v.push(3)\n///   v.shrink_to_fit()\n///   assert_eq(v.capacity(), 3)\n/// ```\npub fn[T] Array::shrink_to_fit(self : Array[T]) -> Unit {\n  if self.capacity() <= self.length() {\n    return\n  }\n  self.resize_buffer(self.length())\n}\n\n///|\n/// Adds an element to the end of the array.\n///\n/// If the array is at capacity, it will be reallocated.\n///\n/// # Example\n/// ```mbt\n///   let v = []\n///   v.push(3)\n/// ```\npub fn[T] Array::push(self : Array[T], value : T) -> Unit {\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  let length = self.length()\n  self.unsafe_set(length, value)\n  self.len = length + 1\n}\n\n///|\n/// Removes the last element from an array and returns it, or `None` if it is empty.\n///\n/// # Example\n/// ```mbt\n///   let v = [1, 2, 3]\n///   assert_eq(v.pop(), Some(3))\n///   assert_eq(v, [1, 2])\n/// ```\npub fn[T] Array::pop(self : Array[T]) -> T? {\n  let len = self.length()\n  if len == 0 {\n    None\n  } else {\n    let index = len - 1\n    let v = self.unsafe_get(index)\n    self.buf.set_null(index)\n    self.len = index\n    Some(v)\n  }\n}\n\n///|\n/// Removes and returns the last element from the array.\n///\n/// Parameters:\n///\n/// * `array` : The array from which to remove and return the last element.\n///\n/// Returns the last element of the array before removal.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [1, 2, 3]\n/// inspect(arr.unsafe_pop(), content=\"3\")\n/// inspect(arr, content=\"[1, 2]\")\n/// ```\n///\n#internal(unsafe, \"Panic if the array is empty.\")\n#doc(hidden)\n#alias(pop_exn, deprecated)\npub fn[T] Array::unsafe_pop(self : Array[T]) -> T {\n  let len = self.length()\n  guard len != 0\n  let index = len - 1\n  let v = self.unsafe_get(index)\n  self.buf.set_null(index)\n  self.len = index\n  v\n}\n\n///|\n/// Removes and returns the element at position index within the array, \n/// shifting all elements after it to the left.\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   assert_eq(v.remove(1), 4)\n///   assert_eq(v, [3, 5])\n/// ```\npub fn[T] Array::remove(self : Array[T], index : Int) -> T {\n  guard index >= 0 && index < self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  let value = self.unsafe_get(index)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index,\n    self.buffer(),\n    index + 1,\n    self.length() - index - 1,\n  )\n  self.unsafe_truncate_to_length(self.length() - 1)\n  value\n}\n\n///|\n/// Removes the specified range from the array and returns it.\n///\n/// This functions returns an array range from `begin` to `end` `[begin, end)`\n/// \n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt\n///   let v = [3, 4, 5]\n///   let vv = v.drain(1, 2) // vv = [4], v = [3, 5]\n///   assert_eq(vv, [4])\n///   assert_eq(v, [3, 5])\n/// ```\npub fn[T] Array::drain(self : Array[T], begin : Int, end : Int) -> Array[T] {\n  guard begin >= 0 && end <= self.length() && begin <= end\n  let num = end - begin\n  let v = Array::make_uninit(num)\n  UninitializedArray::unsafe_blit(v.buffer(), 0, self.buffer(), begin, num)\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    begin,\n    self.buffer(),\n    end,\n    self.length() - end,\n  )\n  self.unsafe_truncate_to_length(self.length() - num)\n  v\n}\n\n///|\n/// Inserts an element at a given index within the array.\n/// This function will panic if the index is out of bounds.\n///\n/// # Example\n/// ```mbt test\n/// let a = [1, 2, 3]\n/// a.insert(1, 4)\n/// inspect(a, content=\"[1, 4, 2, 3]\")\n/// let b = [1, 2, 3]\n/// b.insert(0, 5)\n/// inspect(b, content=\"[5, 1, 2, 3]\")\n/// let c = [1, 2, 3]\n/// c.insert(3, 6)\n/// inspect(c, content=\"[1, 2, 3, 6]\")\n/// ```\npub fn[T] Array::insert(self : Array[T], index : Int, value : T) -> Unit {\n  guard index >= 0 && index <= self.length() else {\n    abort(\n      \"index out of bounds: the len is from 0 to \\{self.length()} but the index is \\{index}\",\n    )\n  }\n  if self.length() == self.buffer().0.length() {\n    self.realloc()\n  }\n  UninitializedArray::unsafe_blit(\n    self.buffer(),\n    index + 1,\n    self.buffer(),\n    index,\n    self.length() - index,\n  )\n  let length = self.length()\n  self.unsafe_set(index, value)\n  self.len = length + 1\n}\n\n///|\n/// Resize the array in-place so that `len` is equal to `new_len`.\n///\n/// If `new_len` is greater than `len`, the array will be extended by the\n/// difference, and the values in the new slots are left uninitialized.\n///  If `new_len` is less than `len`, it will panic\n///\nfn[T] Array::unsafe_grow_to_length(self : Array[T], new_len : Int) -> Unit {\n  guard new_len >= self.length()\n  let new_buf = UninitializedArray::make(new_len)\n  UninitializedArray::unsafe_blit(new_buf, 0, self.buf, 0, self.len)\n  self.len = new_len\n  self.buf = new_buf\n}\n\n///|\n/// Fills an Array with a specified value.\n/// \n/// This method fills all or part of an Array with the given value.\n/// \n/// # Parameters\n/// - `value`: The value to fill the array with\n/// - `start`: The starting index (inclusive, default: 0)\n/// - `end`: The ending index (exclusive, optional)\n/// \n/// If `end` is not provided, fills from `start` to the end of the array.\n/// If `start` equals `end`, no elements are modified.\n/// \n/// # Panics\n/// - Panics if `start` is negative or greater than or equal to the array length\n/// - Panics if `end` is provided and is less than `start` or greater than array length\n/// - Does nothing if the array is empty\n/// \n/// # Example\n/// ```mbt test\n/// // Fill entire array\n/// let arr = [1, 2, 3, 4, 5]\n/// arr.fill(0)\n/// inspect(arr, content=\"[0, 0, 0, 0, 0]\")\n///\n/// // Fill from index 1 to 3 (exclusive)\n/// let arr2 = [1, 2, 3, 4, 5]\n/// arr2.fill(99, start=1, end=3)\n/// inspect(arr2, content=\"[1, 99, 99, 4, 5]\")\n///\n/// // Fill from index 2 to end\n/// let arr3 = [\"a\", \"b\", \"c\", \"d\"]\n/// arr3.fill(\"x\", start=2)\n/// inspect(\n///   arr3,\n///   content=(\n///     #|[\"a\", \"b\", \"x\", \"x\"]\n///   ),\n/// )\n/// ```\npub fn[A] Array::fill(\n  self : Array[A],\n  value : A,\n  start? : Int = 0,\n  end? : Int,\n) -> Unit {\n  let array_length = self.length()\n  guard array_length > 0 else { return }\n  guard start >= 0 && start < array_length\n  let length = match end {\n    None => array_length\n    Some(e) => {\n      guard e >= start && e <= array_length\n      e\n    }\n  }\n  self.buf.unchecked_fill(start, value, length - start)\n}\n\n///|\n/// Creates and returns a new array with a copy of all elements from the input\n/// array.\n///\n/// Parameters:\n///\n/// * `array` : The array to be copied.\n///\n/// Returns a new array containing all elements from the original array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let original = [1, 2, 3]\n/// let copied = original.copy()\n/// inspect(copied, content=\"[1, 2, 3]\")\n/// inspect(physical_equal(original, copied), content=\"false\")\n/// ```\npub fn[T] Array::copy(self : Array[T]) -> Array[T] {\n  let len = self.length()\n  if len == 0 {\n    []\n  } else {\n    let arr = Array::make(len, self[0])\n    Array::unsafe_blit(arr, 0, self, 0, len)\n    arr\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct StringBuilder {\n  mut data : FixedArray[Byte]\n  mut len : Int\n}\n\n///|\n/// Creates a new string builder with an optional initial capacity hint.\n///\n/// Parameters:\n///\n/// * `size_hint` : An optional initial capacity hint for the internal buffer. If\n/// less than 1, a minimum capacity of 1 is used. Defaults to 0. It is the size of bytes, \n/// not the size of characters. `size_hint` may be ignored on some platforms, JS for example.\n///\n/// Returns a new `StringBuilder` instance with the specified initial capacity.\n///\npub fn StringBuilder::new(size_hint? : Int = 0) -> StringBuilder {\n  let initial = if size_hint < 1 { 1 } else { size_hint }\n  let data : FixedArray[Byte] = FixedArray::make(initial, 0)\n  { data, len: 0 }\n}\n\n///|\n/// Return whether the given buffer is empty.\npub fn StringBuilder::is_empty(self : StringBuilder) -> Bool {\n  self.len == 0\n}\n\n///|\nfn StringBuilder::grow_if_necessary(\n  self : StringBuilder,\n  required : Int,\n) -> Unit {\n  let current_len = self.data.length()\n  if required <= current_len {\n    return\n  }\n  // current_len is at least 1\n  let mut enough_space = current_len\n  // double the enough_space until it larger than required\n  while enough_space < required {\n    enough_space = enough_space * 2\n  }\n  let new_data = FixedArray::make(enough_space, Byte::default())\n  new_data.unsafe_blit(0, self.data, 0, self.len)\n  self.data = new_data\n}\n\n///|\n/// Writes a string to the StringBuilder.\npub impl Logger for StringBuilder with write_string(self, str) {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(self.len, str, 0, str.length())\n  self.len += str.length() * 2\n}\n\n///|\n/// Writes a character to the StringBuilder.\npub impl Logger for StringBuilder with write_char(self, ch) {\n  self.grow_if_necessary(self.len + 4)\n  let inc = self.data.set_utf16le_char(self.len, ch)\n  self.len += inc\n}\n\n///|\n/// Writes a part of the given string to the StringBuilder.\n/// \n/// Parameters:\n///\n/// * `self` : The StringBuilder to write to.\n/// * `str` : The given string.\n/// * `start` : The start index of the substring to write.\n/// * `len` : The length of the substring to write.\n///\n/// Example:\n///\n/// ```mbt test\n/// let sb = StringBuilder::new()\n/// sb.write_view(\"Hello, world!\"[:5])\n/// assert_eq(sb.to_string(), \"Hello\")\n/// ```\npub impl Logger for StringBuilder with write_view(\n  self : StringBuilder,\n  str : StringView,\n) -> Unit {\n  self.grow_if_necessary(self.len + str.length() * 2)\n  self.data.blit_from_string(\n    self.len,\n    str.data(),\n    str.start_offset(),\n    str.length(),\n  )\n  self.len += str.length() * 2\n}\n\n///|\n/// Returns the current content of the StringBuilder as a string.\npub fn StringBuilder::to_string(self : StringBuilder) -> String {\n  self.data\n  .unsafe_reinterpret_as_bytes()\n  .to_unchecked_string(offset=0, length=self.len)\n}\n\n///|\n/// TODO: improve perf\npub impl Show for StringBuilder with output(self, logger) {\n  logger.write_string(\n    self.data\n    .unsafe_reinterpret_as_bytes()\n    .to_unchecked_string(offset=0, length=self.len),\n  )\n}\n\n///|\n/// Resets the string builder to an empty state.\npub fn StringBuilder::reset(self : StringBuilder) -> Unit {\n  self.len = 0\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn unsafe_make_string(length : Int, value : Char) -> String = \"$moonbit.unsafe_make_string\"\n\n///|\n/// Create new string of `length`, where each character is `value`\n///\n/// ```mbt\n///   assert_eq(String::make(5,'S'), \"SSSSS\")\n/// ```\npub fn String::make(length : Int, value : Char) -> String {\n  guard length >= 0 else { abort(\"invalid length\") }\n  if value.to_int() <= 0xFFFF {\n    unsafe_make_string(length, value)\n  } else {\n    let buf = StringBuilder::new(size_hint=2 * length)\n    for _ in 0..<length {\n      buf.write_char(value)\n    }\n    buf.to_string()\n  }\n}\n\n///|\nfn code_point_of_surrogate_pair(leading : Int, trailing : Int) -> Char {\n  ((leading - 0xD800) * 0x400 + trailing - 0xDC00 + 0x10000).unsafe_to_char()\n}\n\n///|\n/// Returns the number of Unicode code points (characters) in the string.\n///\n/// This method counts actual Unicode characters, properly handling surrogate pairs\n/// that represent single characters like emojis. For the raw UTF-16 code unit count,\n/// use `length()` instead.\n///\n/// # Examples\n///\n/// ```mbt\n///   let s = \"HelloğŸ¤£\";\n///   inspect(s.char_length(), content = \"6\"); // 6 actual characters\n///   inspect(s.length(), content = \"7\");  // 5 ASCII chars + 2 surrogate pairs\n/// ```\n#alias(codepoint_length, deprecated)\npub fn String::char_length(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"invalid start or end index for String::codepoint_length\")\n  }\n  for utf16_index = start_offset, char_count = 0\n      utf16_index < end_offset\n      utf16_index = utf16_index + 1, char_count = char_count + 1 {\n    let c1 = self.unsafe_charcode_at(utf16_index)\n    if c1.is_leading_surrogate() && utf16_index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(utf16_index + 1)\n      if c2.is_trailing_surrogate() {\n        continue utf16_index + 2, char_count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    char_count\n  }\n}\n\n///|\n#intrinsic(\"%string.substring\")\npub fn String::unsafe_substring(\n  str : String,\n  start~ : Int,\n  end~ : Int,\n) -> String {\n  if start == 0 && end == str.length() {\n    return str\n  }\n  let len = end - start\n  let bytes = FixedArray::make(len * 2, Byte::default())\n  bytes.blit_from_string(0, str, start, len)\n  bytes.unsafe_reinterpret_as_bytes().to_unchecked_string()\n}\n\n///|\n/// Returns a new string containing characters from the original string starting\n/// at `start` index up to (but not including) `end` index.\n///\n/// Parameters:\n///\n/// * `string` : The source string from which to extract the substring.\n/// * `start` : The starting index of the substring (inclusive). Defaults to 0.\n/// * `end` : The ending index of the substring (exclusive). Defaults to the\n/// length of the string.\n///\n/// Returns a new string containing the specified substring.\n///\n#deprecated(\"Use `str[:]` or `str[:].to_string()` instead\", skip_current_package=true)\npub fn String::substring(self : String, start? : Int = 0, end? : Int) -> String {\n  let len = self.length()\n  let end = match end {\n    Some(end) => end\n    None => len\n  }\n  guard start >= 0 && start <= end && end <= len\n  self.unsafe_substring(start~, end~)\n}\n\n///|\n/// Iterates over all suffixes of the string as views that reuse the\n/// original storage. Surrogate pairs stay intact while advancing.\npub fn String::suffixes(\n  self : String,\n  include_empty? : Bool = false,\n) -> Iterator[StringView] {\n  self[:].suffixes(include_empty~)\n}\n\n///|\ntest \"substring/empty\" {\n  let s = \"test\"\n  inspect(s.substring(start=2, end=2), content=\"\")\n  inspect(s.substring(start=4, end=4), content=\"\")\n  inspect(\"\".substring(), content=\"\")\n}\n\n///|\ntest \"panic substring/invalid_range\" {\n  let s = \"test\"\n  ignore(s.substring(start=-1))\n  ignore(s.substring(end=5))\n  ignore(s.substring(start=3, end=2))\n}\n\n///|\ntest \"substring/basic\" {\n  inspect(\"Hello world\".substring(start=0, end=5), content=\"Hello\")\n  inspect(\"Hello world\".substring(start=6, end=11), content=\"world\")\n  inspect(\"Hello world\".substring(start=0), content=\"Hello world\")\n  inspect(\"Hello world\".substring(start=6), content=\"world\")\n}\n\n///|\ntest \"substring/boundary\" {\n  inspect(\"\".substring(start=0, end=0), content=\"\")\n  inspect(\"a\".substring(start=0, end=1), content=\"a\")\n  inspect(\"abc\".substring(start=0), content=\"abc\")\n  inspect(\"abc\".substring(start=1), content=\"bc\")\n  inspect(\"abc\".substring(start=0, end=3), content=\"abc\")\n}\n\n///|\ntest \"panic substring/out_of_bounds\" {\n  ignore(\"hello\".substring(start=-1, end=4))\n  ignore(\"hello\".substring(start=6, end=4))\n  ignore(\"hello\".substring(start=0, end=6))\n}\n\n///|\n/// Strings are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for String with compare(self, other) {\n  let len = self.length()\n  match len.compare(other.length()) {\n    0 => {\n      for i in 0..<len {\n        let order = self\n          .unsafe_charcode_at(i)\n          .compare(other.unsafe_charcode_at(i))\n        if order != 0 {\n          return order\n        }\n      }\n      0\n    }\n    order => order\n  }\n}\n\n///|\n/// The empty string\npub impl Default for String with default() {\n  \"\"\n}\n\n///|\n/// `String` holds a sequence of UTF-16 code units encoded in little endian format\n#deprecated(\"Check `@encoding/utf8.encode`\")\npub fn String::to_bytes(self : String) -> Bytes {\n  let array = FixedArray::make(self.length() * 2, Byte::default())\n  array.blit_from_string(0, self, 0, self.length())\n  array |> unsafe_to_bytes\n}\n\n///|\nfn unsafe_to_bytes(array : FixedArray[Byte]) -> Bytes = \"%identity\"\n\n///|\n/// Converts the String into an array of Chars.\npub fn String::to_array(self : String) -> Array[Char] {\n  self\n  .iter()\n  .fold(init=Array::new(capacity=self.length()), (rv, c) => {\n    rv.push(c)\n    rv\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string.\n///\n/// Note: This iterator yields Unicode characters, not Utf16 code units.\n/// As a result, the count of characters returned by `iter().count()` may not be equal to the length of the string returned by `length()`.\n///\n/// ```mbt\n///   let s = \"Hello, World!ğŸ¤£\";\n///   assert_eq(s.iter().count(), 14); // Unicode characters\n///   assert_eq(s.length(), 15); // Utf16 code units\n/// ```\npub fn String::iter(self : String) -> Iter[Char] {\n  self.iterator().iter()\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string.\n///\n/// Note: This iterator yields Unicode characters, not Utf16 code units.\n/// As a result, the count of characters returned by `iterator().count()` may not be equal to the length of the string returned by `length()`.\n///\n/// ```mbt\n///   let s = \"Hello, World!ğŸ¤£\";\n///   assert_eq(s.iterator().count(), 14); // Unicode characters\n///   assert_eq(s.length(), 15); // Utf16 code units\n/// ```\npub fn String::iterator(self : String) -> Iterator[Char] {\n  let len = self.length()\n  let mut index = 0\n  Iterator::new(fn() {\n    guard index < len else { None }\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < len {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        let c = code_point_of_surrogate_pair(c1, c2)\n        index += 2\n        return Some(c)\n      }\n    }\n    index += 1\n    //TODO: handle garbage input\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\npub fn String::iter2(self : String) -> Iter2[Int, Char] {\n  self.iterator2().iter2()\n}\n\n///|\npub fn String::iterator2(self : String) -> Iterator2[Int, Char] {\n  self.iterator().iterator2()\n}\n\n///|\n/// Returns an iterator that yields characters from the end to the start of the string. This function handles\n/// Unicode surrogate pairs correctly, ensuring that characters are not split across surrogate pairs.\n///\n/// # Parameters\n///\n/// - `self` : The input `String` to be iterated in reverse.\n///\n/// # Returns\n///\n/// - An `Iter[Char]` that yields characters from the end to the start of the string.\n///\n/// # Behavior\n///\n/// - The function iterates over the string in reverse order.\n/// - If a trailing surrogate is encountered, it checks for a preceding leading surrogate to form a complete Unicode code point.\n/// - Yields each character or combined code point to the iterator.\n/// - Stops iteration if the `yield_` function returns `IterEnd`.\n///\n/// # Examples\n///\n/// ```mbt\n///   let input = \"Hello, World!\"\n///   let reversed = input.rev_iter().collect()\n///   assert_eq(reversed, ['!', 'd', 'l', 'r', 'o', 'W', ' ', ',', 'o', 'l', 'l', 'e', 'H'])\n/// ```\npub fn String::rev_iter(self : String) -> Iter[Char] {\n  self.rev_iterator().iter()\n}\n\n///|\n/// Returns an iterator that yields characters from the end to the start of the string. This function handles\n/// Unicode surrogate pairs correctly, ensuring that characters are not split across surrogate pairs.\n///\n/// # Parameters\n///\n/// - `self` : The input `String` to be iterated in reverse.\n///\n/// # Returns\n///\n/// - An `Iter[Char]` that yields characters from the end to the start of the string.\n///\n/// # Behavior\n///\n/// - The function iterates over the string in reverse order.\n/// - If a trailing surrogate is encountered, it checks for a preceding leading surrogate to form a complete Unicode code point.\n/// - Yields each character or combined code point to the iterator.\n/// - Stops iteration if the `yield_` function returns `IterEnd`.\n///\n/// # Examples\n///\n/// ```mbt\n///   let input = \"Hello, World!\"\n///   let reversed = input.rev_iterator().collect()\n///   assert_eq(reversed, ['!', 'd', 'l', 'r', 'o', 'W', ' ', ',', 'o', 'l', 'l', 'e', 'H'])\n/// ```\npub fn String::rev_iterator(self : String) -> Iterator[Char] {\n  let len = self.length()\n  let mut index = len\n  Iterator::new(fn() {\n    guard index > 0 else { None }\n    index -= 1\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.unsafe_charcode_at(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2, c1))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\nfn String::offset_of_nth_char_forward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int,\n) -> Int? {\n  guard start_offset >= 0 && start_offset <= end_offset else {\n    abort(\"Invalid start index\")\n  }\n  let mut utf16_offset = start_offset\n  let mut char_count = 0\n  while utf16_offset < end_offset && char_count < n {\n    let c = self.unsafe_charcode_at(utf16_offset)\n    // check if this is a surrogate pair\n    if c.is_leading_surrogate() {\n      utf16_offset = utf16_offset + 2\n    } else {\n      utf16_offset = utf16_offset + 1\n    }\n    char_count = char_count + 1\n  }\n  // Return None if either:\n  // 1. We couldn't reach the requested character offset\n  // 2. The resulting offset is beyond the end of the string\n  // This handles the empty string case correctly.\n  if char_count < n || utf16_offset >= end_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the index of the n-th (zero-indexed) character within the range [start, end).\n/// self[end] is counted as the 0-th character (though it might not exist if end = self.length()).\nfn String::offset_of_nth_char_backward(\n  self : String,\n  n : Int,\n  start_offset~ : Int,\n  end_offset~ : Int,\n) -> Int? {\n  let mut char_count = 0\n  let mut utf16_offset = end_offset\n  // Iterating backwards from the end of the string. \n  // Invariant: utf16_offset always points to the previous character\n  while utf16_offset - 1 >= start_offset && char_count < n {\n    let c = self.unsafe_charcode_at(utf16_offset - 1)\n    if c.is_trailing_surrogate() {\n      utf16_offset = utf16_offset - 2\n    } else {\n      utf16_offset = utf16_offset - 1\n    }\n    char_count = char_count + 1\n  }\n  if char_count < n || utf16_offset < start_offset {\n    None\n  } else {\n    Some(utf16_offset)\n  }\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character \n/// within the range [start, end). If i is negative, it returns the index of \n/// the (n + i)-th character where n is the number of Unicode characters \n/// in the range [start, end).\n/// \n/// This functions assumes that the string is valid UTF-16.\npub fn String::offset_of_nth_char(\n  self : String,\n  i : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Int? {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  if i >= 0 {\n    // forward case\n    self.offset_of_nth_char_forward(i, start_offset~, end_offset~)\n  } else {\n    // backward case\n    self.offset_of_nth_char_backward(-i, start_offset~, end_offset~)\n  }\n}\n\n///|\n/// Test if the length of the string is equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_eq(\n  self : String,\n  len : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Bool {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count == len && index == end_offset\n  }\n}\n\n///|\n/// Test if the length of the string is greater than or equal to the given length.\n///\n/// This has O(n) complexity where n is the length in the parameter.\npub fn String::char_length_ge(\n  self : String,\n  len : Int,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> Bool {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  for index = start_offset, count = 0\n      index < end_offset && count < len\n      index = index + 1, count = count + 1 {\n    let c1 = self.unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < end_offset {\n      let c2 = self.unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        continue index + 2, count + 1\n      } else {\n        abort(\"invalid surrogate pair\")\n      }\n    }\n  } else {\n    count >= len\n  }\n}\n\n///|\n/// Performs a lexicographical comparison of two strings.\n///\n/// This method compares the strings character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one string is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt\n/// inspect(\"ab\".lexical_compare(\"abc\"), content=\"-1\")\n/// inspect(\"abc\".lexical_compare(\"ab\"), content=\"1\")\n/// inspect(\"abc\".lexical_compare(\"abc\"), content=\"0\")\n/// inspect(\"abc\".lexical_compare(\"abd\"), content=\"-1\")\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn String::lexical_compare(self : String, other : String) -> Int {\n  self[:].lexical_compare(other[:])\n}\n\n///|\n/// Convert char array to string.\n///\n/// ```mbt\n///   let s = String::from_array(['H', 'e', 'l', 'l', 'o'])\n///   assert_eq(s, \"Hello\")\n/// ```\n///\n/// Do not convert large data to `Array[Char]` and build a string with `String::from_array`.\n///\n/// For efficiency considerations, it's recommended to use `Buffer` instead.\npub fn String::from_array(chars : ArrayView[Char]) -> String {\n  let buf = StringBuilder::new(size_hint=chars.length() * 4)\n  for c in chars {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Convert char iterator to string,\npub fn String::from_iter(iter : Iter[Char]) -> String {\n  let buf = StringBuilder::new()\n  for c in iter {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n\n///|\n/// Convert char iterator to string,\npub fn String::from_iterator(iter : Iterator[Char]) -> String {\n  let buf = StringBuilder::new()\n  for c in iter {\n    buf.write_char(c)\n  }\n  buf.to_string()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Performs multiplication between two byte values. The result is truncated to\n/// fit within the byte range.\n///\n/// Parameters:\n///\n/// * `self` : The first byte operand in the multiplication.\n/// * `that` : The second byte operand in the multiplication.\n///\n/// Returns the product of the two bytes, truncated to fit within the byte range\n/// (0-255).\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = b'\\x02'\n/// let b = b'\\x03'\n/// inspect(a * b, content=\"b'\\\\x06'\") // 2 * 3 = 6\n/// let c = b'\\xFF'\n/// inspect(c * c, content=\"b'\\\\x01'\") // 255 * 255 = 65025, truncated to 1\n/// ```\npub impl Mul for Byte with mul(self : Byte, that : Byte) -> Byte {\n  (self.to_int() * that.to_int()).to_byte()\n}\n\n///|\n/// Performs division operation between two bytes by converting them to integers,\n/// performing the division, and converting the result back to a byte.\n///\n/// Parameters:\n///\n/// * `self` : The dividend byte value.\n/// * `that` : The divisor byte value.\n///\n/// Returns the quotient of the division as a byte.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = b'\\xFF' // 255\n/// let b = b'\\x03' // 3\n/// inspect(a / b, content=\"b'\\\\x55'\") // 255 / 3 = 85 (0x55)\n/// ```\npub impl Div for Byte with div(self : Byte, that : Byte) -> Byte {\n  (self.to_int() / that.to_int()).to_byte()\n}\n\n///|\npub impl Mod for Byte with mod(self : Byte, that : Byte) -> Byte {\n  (self.to_int() % that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values for equality.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value to compare.\n/// - `that` : The second `Byte` value to compare.\n///\n/// Returns `true` if the two `Byte` values are equal, otherwise `false`.\npub impl Eq for Byte with equal(self : Byte, that : Byte) -> Bool {\n  self.to_int() == that.to_int()\n}\n\n///|\n/// Adds two `Byte` values together and returns the result as a `Byte`.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to be added.\n/// - `byte2` : The second `Byte` value to be added.\n///\n/// Returns the sum of `byte1` and `byte2` as a `Byte`.\npub impl Add for Byte with add(self : Byte, that : Byte) -> Byte {\n  (self.to_int() + that.to_int()).to_byte()\n}\n\n///|\n/// Subtracts the second byte from the first byte and returns the result as a\n/// byte.\n///\n/// Parameters:\n///\n/// - `self` : The byte from which the second byte will be subtracted.\n/// - `that` : The byte to subtract from the first byte.\n///\n/// Returns the result of the subtraction as a byte.\npub impl Sub for Byte with sub(self : Byte, that : Byte) -> Byte {\n  (self.to_int() - that.to_int()).to_byte()\n}\n\n///|\n/// Compares two `Byte` values and returns an integer indicating their relative\n/// order.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to compare.\n/// - `byte2` : The second `Byte` value to compare.\n///\n/// Returns an integer where:\n/// - A value less than 0 indicates that `byte1` is less than `byte2`.\n/// - A value of 0 indicates that `byte1` is equal to `byte2`.\n/// - A value greater than 0 indicates that `byte1` is greater than `byte2`.\npub impl Compare for Byte with compare(self : Byte, that : Byte) -> Int {\n  self.to_int().compare(that.to_int())\n}\n\n///|\npub impl Compare for Byte with op_lt(x, y) {\n  x.to_int() < y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_le(x, y) {\n  x.to_int() <= y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_gt(x, y) {\n  x.to_int() > y.to_int()\n}\n\n///|\npub impl Compare for Byte with op_ge(x, y) {\n  x.to_int() >= y.to_int()\n}\n\n///|\nfn alphabet(x : Int) -> String {\n  match x {\n    0 => \"0\"\n    1 => \"1\"\n    2 => \"2\"\n    3 => \"3\"\n    4 => \"4\"\n    5 => \"5\"\n    6 => \"6\"\n    7 => \"7\"\n    8 => \"8\"\n    9 => \"9\"\n    10 => \"A\"\n    11 => \"B\"\n    12 => \"C\"\n    13 => \"D\"\n    14 => \"E\"\n    15 => \"F\"\n    _ => abort(\"impossible\")\n  }\n}\n\n///|\n/// Converts a `Byte` to its string representation in hexadecimal format.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns a `String` representing the `Byte` in the format `b'\\xHH'`, where\n/// `HH` is the hexadecimal representation of the byte.\npub fn Byte::to_string(self : Byte) -> String {\n  let i = self.to_int()\n  let hi = alphabet(i / 16)\n  let lo = alphabet(i % 16)\n  \"b'\\\\x\\{hi}\\{lo}'\"\n}\n\n///|\n/// Implements the `Hash` trait for `Byte` type by providing a `hash_combine`\n/// method that combines a byte value with a hasher.\n///\n/// Parameters:\n///\n/// * `self` : The byte value to be hashed.\n/// * `hasher` : The hasher object that will be used to combine the byte value\n/// into its internal state.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hasher = Hasher::new(seed=0)\n/// hasher.combine_byte(b'\\xFF')\n/// inspect(hasher.finalize(), content=\"1955036104\")\n/// ```\npub impl Hash for Byte with hash_combine(self, hasher) {\n  hasher.combine_byte(self)\n}\n\n///|\n/// Returns the default value for a `Byte`, which is `b'\\x00'`.\n///\n/// Parameters:\n///\n/// - None\n///\n/// Returns the default `Byte` value, which is `b'\\x00'`.\npub impl Default for Byte with default() {\n  b'\\x00'\n}\n\n///|\n/// Performs a bitwise NOT operation on the given `Byte` value.\n///\n/// Parameters:\n///\n/// - `value` : The `Byte` value to apply the bitwise NOT operation on.\n///\n/// Returns the result of the bitwise NOT operation as a `Byte`.\npub fn Byte::lnot(self : Byte) -> Byte {\n  self.to_int().lnot().to_byte()\n}\n\n///|\n/// Performs a bitwise AND operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `byte1` : The first `Byte` value to perform the bitwise AND operation with.\n/// - `byte2` : The second `Byte` value to perform the bitwise AND operation\n///   with.\n///\n/// Returns the result of the bitwise AND operation as a `Byte`.\npub impl BitAnd for Byte with land(self : Byte, that : Byte) -> Byte {\n  (self.to_int() & that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise OR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns a new `Byte` value resulting from the bitwise OR operation.\npub impl BitOr for Byte with lor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() | that.to_int()).to_byte()\n}\n\n///|\n/// Performs a bitwise XOR operation between two `Byte` values.\n///\n/// Parameters:\n///\n/// - `self` : The first `Byte` value.\n/// - `that` : The second `Byte` value.\n///\n/// Returns the result of the bitwise XOR operation as a `Byte`.\npub impl BitXOr for Byte with lxor(self : Byte, that : Byte) -> Byte {\n  (self.to_int() ^ that.to_int()).to_byte()\n}\n\n///|\n/// Converts a `Byte` to a `UInt`.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value to be converted.\n///\n/// Returns the `UInt` representation of the `Byte`.\npub fn Byte::to_uint(self : Byte) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n/// Converts a byte value to an unsigned 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns an unsigned 64-bit integer representation of the byte value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let b = b'\\xFF'\n/// inspect(b.to_uint64(), content=\"255\")\n/// ```\npub fn Byte::to_uint64(self : Byte) -> UInt64 {\n  self.to_uint().to_uint64()\n}\n\n///|\n/// Counts the number of 1-bits (population count) in the byte using bitwise operations.\n///\n/// Parameters:\n///\n/// * `self` : The byte value whose 1-bits are to be counted.\n///\n/// Returns the number of 1-bits in the byte.\n///\n/// Example:\n///\n/// ```mbt test\n/// let b = b'\\x0F'\n/// inspect(b.popcnt(), content=\"4\")\n/// ```\npub fn Byte::popcnt(self : Byte) -> Int {\n  let mut n = self\n  n = (n & 0x55) + ((n >> 1) & 0x55)\n  n = (n & 0x33) + ((n >> 2) & 0x33)\n  n = (n & 0x0F) + ((n >> 4) & 0x0F)\n  n.to_int()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the left by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte_value` : The `Byte` value whose bits are to be shifted.\n/// - `shift_count` : The number of bit positions to shift the `byte_value` to\n///   the left.\n///\n/// Returns the resulting `Byte` value after the shift operation.\npub impl Shl for Byte with shl(self : Byte, count : Int) -> Byte {\n  (self.to_int() << count).to_byte()\n}\n\n///|\n/// Shifts the bits of the `Byte` value to the right by the specified number of\n/// positions.\n///\n/// Parameters:\n///\n/// - `byte` : The `Byte` value whose bits are to be shifted.\n/// - `count` : The number of bit positions to shift the `byte` value to the\n///   right.\n///\n/// Returns the resulting `Byte` value after the bitwise right shift operation.\npub impl Shr for Byte with shr(self : Byte, count : Int) -> Byte {\n  (self.to_uint() >> count).reinterpret_as_int().to_byte()\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nfn[T : Show] debug_string(t : T) -> String {\n  let buf = StringBuilder::new(size_hint=50)\n  t.output(buf)\n  buf.to_string()\n}\n\n///|\n/// Asserts that two values are equal. If they are not equal, raises a failure\n/// with a message containing the source location and the values being compared.\n///\n/// Parameters:\n///\n/// * `a` : First value to compare.\n/// * `b` : Second value to compare.\n/// * `loc` : Source location information to include in failure messages. This is\n/// usually automatically provided by the compiler.\n///\n/// Throws a `Failure` error if the values are not equal, with a message showing\n/// the location of the failing assertion and the actual values that were\n/// compared.\n///\n/// Example:\n///\n/// ```mbt test\n/// assert_eq(1, 1)\n/// assert_eq(\"hello\", \"hello\")\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if a != b {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} != \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that two values of the same type are not equal. If the values are\n/// equal, raises a failure with a detailed error message including the source\n/// location and string representation of both values.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `location` : Source location information for error reporting. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error if the values are equal. The error message includes\n/// the source location and string representations of both values.\n///\n/// Example:\n///\n/// ```mbt test\n/// assert_not_eq(1, 2) // Passes\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn[T : Eq + Show] assert_not_eq(\n  a : T,\n  b : T,\n  msg? : String,\n  loc~ : SourceLoc,\n) -> Unit raise {\n  if !(a != b) {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{debug_string(a)} == \\{debug_string(b)}`\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Asserts that the given boolean value is true. Throws an error with source\n/// location information if the assertion fails.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean value to be checked.\n/// * `location` : The source location where the assertion is made. Defaults to\n/// the current location.\n///\n/// Throws a `Failure` error with a descriptive message including the source\n/// location if the condition is false.\n///\n/// Example:\n///\n/// ```mbt test\n/// assert_true(true)\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_true(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if !x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not true\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n\n///|\n/// Tests whether a boolean condition is false, throwing an error if the\n/// condition is true.\n///\n/// Parameters:\n///\n/// * `condition` : The boolean condition to test.\n/// * `location` : The source location where the assertion is made. Used in error\n/// messages.\n///\n/// Throws a `Failure` error if the condition is true. The error message includes\n/// the source location and the value that was expected to be false.\n///\n/// Example:\n///\n/// ```mbt test\n/// assert_false(false)\n/// assert_false(1 > 2)\n/// ```\n#callsite(autofill(loc))\n#coverage.skip\npub fn assert_false(x : Bool, msg? : String, loc~ : SourceLoc) -> Unit raise {\n  if x {\n    let fail_msg = match msg {\n      Some(msg) => msg\n      None => \"`\\{x}` is not false\"\n    }\n    fail(fail_msg, loc~)\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Represents a generic test failure type used primarily in test assertions and\n/// validations.\n///\n/// Since this is a type definition using `suberror` syntax, it creates an error\n/// type `Failure` that wraps a `String` value containing the failure message.\n///\n/// Parameters:\n///\n/// * `message` : A string describing the nature of the failure.\n///\n/// Example:\n///\n/// ```mbt test\n/// let err : Failure = Failure(\"Test assertion failed\")\n/// match err {\n///   Failure(msg) => inspect(msg, content=\"Test assertion failed\")\n/// }\n/// @json.inspect(err, content=[\"Failure\", \"Test assertion failed\"])\n/// ```\npub(all) suberror Failure String derive(ToJson, Show)\n\n///|\n/// Raises a `Failure` error with a given message and source location.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be included in the\n/// failure.\n/// * `location` : The source code location where the failure occurred.\n/// Automatically provided by the compiler when not specified.\n///\n/// Returns a value of type `T` wrapped in a `Failure` error type.\n///\n/// Throws an error of type `Failure` with a message that includes both the\n/// source location and the provided error message.\n#callsite(autofill(loc))\npub fn[T] fail(msg : String, loc~ : SourceLoc) -> T raise Failure {\n  raise Failure(\"\\{loc} FAILED: \\{msg}\")\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#cfg(not(target=\"js\"))\nconst ALPHABET : String = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\n///|\n#cfg(not(target=\"js\"))\nfn unsafe_fixedarray_uint16_to_string(buffer : FixedArray[UInt16]) -> String = \"%string.unsafe_from_uint16_fixedarray\"\n\n//==========================================\n// Int and UInt (Non JS)\n//==========================================\n\n///|\n/// Converts an unsigned 32-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFU).reinterpret_as_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFU).reinterpret_as_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36\n#cfg(not(target=\"js\"))\nfn int_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.reinterpret_as_uint()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1U\n    while n > 0U {\n      offset = offset - 1\n      let digit = n.land(mask).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0U {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).reinterpret_as_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 32-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000U {\n    let t = num / 10000U\n    let r = (num % 10000U).reinterpret_as_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.reinterpret_as_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Calculates the number of decimal digits in a u32 value\n#cfg(not(target=\"js\"))\nfn dec_count32(value : UInt) -> Int {\n  // Binary search: split 1-10 digits into halves\n  if value >= 100000U { // >= 10^5 means 6+ digits\n    if value >= 10000000U { // >= 10^7 means 8+ digits\n      if value >= 1000000000U { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000U { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000U { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000U { // >= 10^3 means 4+ digits\n    if value >= 10000U { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100U { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10U { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u32 value\n#cfg(not(target=\"js\"))\nfn hex_count32(value : UInt) -> Int {\n  if value == 0U {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (31 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u32 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count32(value : UInt, radix : Int) -> Int {\n  if value == 0U {\n    return 1\n  }\n  let mut num = value\n  let base = radix.reinterpret_as_uint()\n  let mut count = 0\n  while num > 0U {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n/// Example:\n/// ```\n/// inspect((255).to_string(radix=16), content=\"ff\")\n/// inspect((-255).to_string(radix=16), content=\"-ff\")\n/// ```\n#cfg(not(target=\"js\"))\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0 {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0\n  let num : UInt = if is_negative {\n    // Negate and reinterpret as UInt\n    // Works correctly for Int::min_value due to two's complement:\n    // -Int::min_value wraps to itself, then reinterpreting gives 2147483648U\n    (-self).reinterpret_as_uint()\n  } else {\n    self.reinterpret_as_uint()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count32(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count32(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0U {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count32(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count32(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n//==========================================\n// Int and UInt (JS)\n//==========================================\n\n///|\n/// Converts an integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int::to_string(self : Int, radix? : Int = 10) -> String {\n  int_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int_to_string_js(i : Int, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return x.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt::to_string(self : UInt, radix? : Int = 10) -> String {\n  uint_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint_to_string_js(i : UInt, radix : Int) -> String =\n  #|(x, radix) => {\n  #|  return (x >>> 0).toString(radix);\n  #|}\n\n//==========================================\n// Int64 and UInt64\n//==========================================\n\n///|\n/// Calculates the number of decimal digits in a u64 value\n#cfg(not(target=\"js\"))\nfn dec_count64(value : UInt64) -> Int {\n  // Binary search: split 1-20 digits into halves\n  if value >= 10000000000UL { // >= 10^10 means 11+ digits\n    if value >= 100000000000000UL { // >= 10^14 means 15+ digits\n      if value >= 10000000000000000UL { // >= 10^16 means 17+ digits\n        if value >= 1000000000000000000UL { // >= 10^18 means 19+ digits\n          if value >= 10000000000000000000UL { // >= 10^19 means 20 digits\n            20\n          } else {\n            19\n          }\n        } else if value >= 100000000000000000UL { // >= 10^17 means 18 digits\n          18\n        } else {\n          17\n        }\n      } else if value >= 1000000000000000UL { // >= 10^15 means 16 digits\n        16\n      } else {\n        15\n      }\n    } else if value >= 1000000000000UL { // >= 10^12 means 13+ digits\n      if value >= 10000000000000UL { // >= 10^13 means 14 digits\n        14\n      } else {\n        13\n      }\n    } else if value >= 100000000000UL { // >= 10^11 means 12 digits\n      12\n    } else {\n      11\n    }\n  } else if value >= 100000UL { // >= 10^5 means 6+ digits\n    if value >= 10000000UL { // >= 10^7 means 8+ digits\n      if value >= 1000000000UL { // >= 10^9 means 10 digits\n        10\n      } else if value >= 100000000UL { // >= 10^8 means 9 digits\n        9\n      } else {\n        8\n      }\n    } else if value >= 1000000UL { // >= 10^6 means 7 digits\n      7\n    } else {\n      6\n    }\n  } else if value >= 1000UL { // >= 10^3 means 4+ digits\n    if value >= 10000UL { // >= 10^4 means 5 digits\n      5\n    } else {\n      4\n    }\n  } else if value >= 100UL { // >= 10^2 means 3 digits\n    3\n  } else if value >= 10UL { // >= 10^1 means 2 digits\n    2\n  } else {\n    1\n  }\n}\n\n///|\n/// Calculates the number of hex digits needed for a u64 value\n#cfg(not(target=\"js\"))\nfn hex_count64(value : UInt64) -> Int {\n  if value == 0UL {\n    1\n  } else {\n    let leading_zeros = value.clz()\n    (63 - leading_zeros) / 4 + 1\n  }\n}\n\n///|\n/// Calculates the number of digits needed for a u64 value in any radix\n#cfg(not(target=\"js\"))\nfn radix_count64(value : UInt64, radix : Int) -> Int {\n  if value == 0UL {\n    return 1\n  }\n  let mut num = value\n  let base = radix.to_uint64()\n  let mut count = 0\n  while num > 0UL {\n    count = count + 1\n    num = num / base\n  }\n  count\n}\n\n///|\n/// Converts an unsigned 64-bit integer to hexadecimal\n#cfg(not(target=\"js\"))\nfn int64_to_string_hex(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n\n  // Process 2 hex digits (1 byte) at a time\n  while offset >= 2 {\n    offset = offset - 2\n    let byte_val = n.land(0xFFUL).to_int()\n    let hi = byte_val / 16\n    let lo = byte_val % 16\n    buffer.unsafe_set(\n      digit_start + offset,\n      ALPHABET.unsafe_charcode_at(hi).to_uint16(),\n    )\n    buffer.unsafe_set(\n      digit_start + offset + 1,\n      ALPHABET.unsafe_charcode_at(lo).to_uint16(),\n    )\n    n = n >> 8\n  }\n\n  // Handle remaining single hex digit\n  if offset == 1 {\n    let nibble = n.land(0xFUL).to_int()\n    buffer.unsafe_set(\n      digit_start,\n      ALPHABET.unsafe_charcode_at(nibble).to_uint16(),\n    )\n  }\n}\n\n///|\n/// Generic radix conversion for any base 2-36 (64-bit)\n#cfg(not(target=\"js\"))\nfn int64_to_string_generic(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n  radix : Int,\n) -> Unit {\n  let mut offset = total_len - digit_start\n  let mut n = num\n  let base = radix.to_uint64()\n  if (radix & (radix - 1)) == 0 {\n    // Power-of-two radix: use bit shifts\n    let shift = radix.ctz()\n    let mask = base - 1UL\n    while n > 0UL {\n      offset = offset - 1\n      let digit = n.land(mask).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = n >> shift\n    }\n  } else {\n    // General radix: use division\n    while n > 0UL {\n      offset = offset - 1\n      let q = n / base\n      let digit = (n - q * base).to_int()\n      buffer.unsafe_set(\n        digit_start + offset,\n        ALPHABET.unsafe_charcode_at(digit).to_uint16(),\n      )\n      n = q\n    }\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to decimal string\n#cfg(not(target=\"js\"))\nfn int64_to_string_dec(\n  buffer : FixedArray[UInt16],\n  num : UInt64,\n  digit_start : Int,\n  total_len : Int,\n) -> Unit {\n  let mut num = num\n  let mut offset = total_len - digit_start\n\n  // Process digits in groups of 4 (chunks of 10000)\n  while num >= 10000UL {\n    let t = num / 10000UL\n    let r = (num % 10000UL).to_int()\n    num = t\n    let d1 = r / 100\n    let d2 = r % 100\n    offset = offset - 4\n    let d1_hi = (0x30 + d1 / 10).to_uint16()\n    let d1_lo = (0x30 + d1 % 10).to_uint16()\n    let d2_hi = (0x30 + d2 / 10).to_uint16()\n    let d2_lo = (0x30 + d2 % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d1_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d1_lo)\n    buffer.unsafe_set(digit_start + offset + 2, d2_hi)\n    buffer.unsafe_set(digit_start + offset + 3, d2_lo)\n  }\n\n  // Handle remaining digits (< 10000)\n  let mut remaining = num.to_int()\n\n  // Process pairs of digits\n  while remaining >= 100 {\n    let t = remaining / 100\n    let d = remaining % 100\n    remaining = t\n    offset = offset - 2\n    let d_hi = (0x30 + d / 10).to_uint16()\n    let d_lo = (0x30 + d % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  }\n\n  // Handle final 1 or 2 digits\n  if remaining >= 10 {\n    offset = offset - 2\n    let d_hi = (0x30 + remaining / 10).to_uint16()\n    let d_lo = (0x30 + remaining % 10).to_uint16()\n    buffer.unsafe_set(digit_start + offset, d_hi)\n    buffer.unsafe_set(digit_start + offset + 1, d_lo)\n  } else {\n    offset = offset - 1\n    buffer.unsafe_set(digit_start + offset, (0x30 + remaining).to_uint16())\n  }\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0L {\n    return \"0\"\n  }\n\n  // Handle negative numbers\n  let is_negative = self < 0L\n  let num : UInt64 = if is_negative {\n    // Negate and reinterpret as UInt64\n    // Works correctly for Int64::min_value due to two's complement\n    (-self).reinterpret_as_uint64()\n  } else {\n    self.reinterpret_as_uint64()\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let digit_len = dec_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_dec(buffer, num, digit_start, total_len)\n      buffer\n    }\n    16 => {\n      let digit_len = hex_count64(num)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_hex(buffer, num, digit_start, total_len)\n      buffer\n    }\n    _ => {\n      let digit_len = radix_count64(num, radix)\n      let total_len = digit_len + (if is_negative { 1 } else { 0 })\n      let buffer : FixedArray[UInt16] = FixedArray::make(total_len, 0)\n      let digit_start = if is_negative { 1 } else { 0 }\n      int64_to_string_generic(buffer, num, digit_start, total_len, radix)\n      buffer\n    }\n  }\n\n  // Write minus sign if negative\n  if is_negative {\n    buffer.unsafe_set(0, 0x002D)\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(not(target=\"js\"))\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  // Validate radix\n  if radix < 2 || radix > 36 {\n    abort(\"radix must be between 2 and 36\")\n  }\n\n  // Special case for zero\n  if self == 0UL {\n    return \"0\"\n  }\n\n  // Calculate length, allocate buffer, and write digits\n  let buffer = match radix {\n    10 => {\n      let len = dec_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_dec(buffer, self, 0, len)\n      buffer\n    }\n    16 => {\n      let len = hex_count64(self)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_hex(buffer, self, 0, len)\n      buffer\n    }\n    _ => {\n      let len = radix_count64(self, radix)\n      let buffer : FixedArray[UInt16] = FixedArray::make(len, 0)\n      int64_to_string_generic(buffer, self, 0, len, radix)\n      buffer\n    }\n  }\n  unsafe_fixedarray_uint16_to_string(buffer)\n}\n\n///|\n/// Converts a 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn Int64::to_string(self : Int64, radix? : Int = 10) -> String {\n  int64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn int64_to_string_js(num : Int64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  let val = (BigInt(num.hi >>> 0) << 32n) | BigInt(num.lo >>> 0);\n  #|  if (val & (1n << 63n)) {\n  #|    val = val - (1n << 64n);\n  #|  }\n  #|  return val.toString(radix);\n  #|}\n\n///|\n/// Converts an unsigned 64-bit integer to its string representation in the specified radix (base).\n#cfg(target=\"js\")\npub fn UInt64::to_string(self : UInt64, radix? : Int = 10) -> String {\n  uint64_to_string_js(self, radix)\n}\n\n///|\n#cfg(target=\"js\")\nextern \"js\" fn uint64_to_string_js(num : UInt64, radix : Int) -> String =\n  #|(num, radix) => {\n  #|  return (BigInt(num.hi >>> 0) << 32n | BigInt(num.lo >>> 0)).toString(radix);\n  #|}\n\n//==========================================\n// Int16 and UInt16\n//==========================================\n\n///|\npub fn UInt16::to_string(self : UInt16, radix? : Int = 10) -> String {\n  self.to_int().to_string(radix~)\n}\n\n//==========================================\n// Test cases\n//==========================================\n\n///|\ntest \"UInt::to_string\" {\n  inspect(0U, content=\"0\")\n  inspect(17U, content=\"17\")\n  inspect(4294967295U, content=\"4294967295\")\n}\n\n///|\ntest \"to_string\" {\n  assert_eq((0x100).to_string(), \"256\")\n  assert_eq(\"\\{0x100}\", \"256\")\n  assert_eq(0x200U.to_string(), \"512\")\n  assert_eq(\"\\{0x200U}\", \"512\")\n  assert_eq(0x300L.to_string(), \"768\")\n  assert_eq(\"\\{0x300L}\", \"768\")\n  assert_eq(0x400UL.to_string(), \"1024\")\n  assert_eq(\"\\{0x400UL}\", \"1024\")\n}\n\n///|\ntest \"panic to_string_by_radix/illegal_radix\" {\n  ignore((1).to_string(radix=1))\n  ignore((1).to_string(radix=37))\n  ignore(1L.to_string(radix=0))\n  ignore(1L.to_string(radix=42))\n  ignore(1U.to_string(radix=-1))\n  ignore(1U.to_string(radix=73))\n  ignore(1UL.to_string(radix=-100))\n  ignore(1UL.to_string(radix=100))\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Trait for types whose elements can test for equality\npub(open) trait Eq {\n  equal(Self, Self) -> Bool = _\n  #deprecated(\"use `equal` instead\", skip_current_package=true)\n  op_equal(Self, Self) -> Bool = _\n}\n\n///|\n/// Trait for types whose elements are ordered\n///\n/// The return value of [compare] is:\n/// - zero, if the two arguments are equal\n/// - negative, if the first argument is smaller\n/// - positive, if the first argument is greater\npub(open) trait Compare: Eq {\n  compare(Self, Self) -> Int\n  op_lt(Self, Self) -> Bool = _\n  op_gt(Self, Self) -> Bool = _\n  op_le(Self, Self) -> Bool = _\n  op_ge(Self, Self) -> Bool = _\n}\n\n///|\nimpl Compare with op_lt(x, y) {\n  x.compare(y).is_neg()\n}\n\n///|\nimpl Compare with op_gt(x, y) {\n  x.compare(y).is_pos()\n}\n\n///|\nimpl Compare with op_le(x, y) {\n  x.compare(y).is_non_pos()\n}\n\n///|\nimpl Compare with op_ge(x, y) {\n  x.compare(y).is_non_neg()\n}\n\n///|\n/// Trait for types that can be hashed\n/// \n/// The `hash` method should return a hash value for the type, which is used in hash tables and other data structures.\n/// The `hash_combine` method is used to combine the hash of the current value with another hash value,\n/// typically used to hash composite types.\n/// \n/// When two values are equal according to the `Eq` trait, they should produce the same hash value.\n/// \n/// The `hash` method does not need to be implemented if `hash_combine` is implemented,\n/// When implemented separately, `hash` **does not need** to produce a hash value that is consistent with `hash_combine`.\npub(open) trait Hash {\n  hash_combine(Self, Hasher) -> Unit\n  hash(Self) -> Int = _\n}\n\n///|\nimpl Hash with hash(self) {\n  Hasher::new()..combine(self).finalize()\n}\n\n///|\n/// Trait for types with a default value\npub(open) trait Default {\n  default() -> Self\n}\n\n///|\n/// Trait for a logger, where debug logs can be written into\npub(open) trait Logger {\n  write_string(Self, String) -> Unit = _\n  #deprecated(\"use `write_view` instead\", skip_current_package=true)\n  write_substring(Self, String, Int, Int) -> Unit = _\n  write_view(Self, StringView) -> Unit = _\n  write_char(Self, Char) -> Unit = _\n}\n\n///|\nimpl Logger with write_substring(self, value, start, len) {\n  self.write_view(try! value[start:start + len])\n}\n\n///|\nimpl Logger with write_string(self, value) {\n  self.write_view(value[:])\n}\n\n///|\n#deprecated(\"replace `impl write_substring` with `impl write_view`\")\nimpl Logger with write_view(self, value) {\n  self.write_substring(value.data(), value.start_offset(), value.length())\n}\n\n///|\nimpl Logger with write_char(self, value) {\n  self.write_string([value])\n}\n\n///|\n/// Trait for types that can be converted to `String`\npub(open) trait Show {\n  // `output` is used for composition of aggregate structure.\n  // `output` writes a string representation of `self` to a logger.\n  // `output` should produce a valid MoonBit-syntax representation if possible.\n  // For example, `Show::output` for `String` should be quoted\n  output(Self, &Logger) -> Unit\n  // `to_string` should be used by end users of `Show`,\n  // for printing, interpolation, etc. only, and should not be used for composition.\n  // By default `to_string` is implemented using `output` and a buffer,\n  // but some types, such as `String`, may override `to_string`,\n  // for different (unescaped) behavior when interpolated/printed directly\n  to_string(Self) -> String = _\n}\n\n///|\n/// Default implementation for `Show::to_string`, uses a `StringBuilder`\nimpl Show with to_string(self) {\n  let logger = StringBuilder::new()\n  self.output(logger)\n  logger.to_string()\n}\n\n///|\npub fn[Obj : Show] &Logger::write_object(self : &Logger, obj : Obj) -> Unit {\n  obj.output(self)\n}\n\n///|\npub fn[T : Show] &Logger::write_iter(\n  self : &Logger,\n  iter : Iter[T],\n  prefix? : String = \"[\",\n  suffix? : String = \"]\",\n  sep? : String = \", \",\n  trailing? : Bool = false,\n) -> Unit {\n  self.write_string(prefix)\n  if trailing {\n    for x in iter {\n      self.write_object(x)\n      self.write_string(sep)\n    }\n  } else {\n    // trailing is false\n    let mut first = true\n    for x in iter {\n      if first {\n        first = false\n      } else {\n        self.write_string(sep)\n      }\n      self.write_object(x)\n    }\n  }\n  self.write_string(suffix)\n}\n// TODO: Logger::write_double(self:Logger, val:Double) -> Unit\n\n///|\npub fn[T : Show] repr(t : T) -> String {\n  let logger = StringBuilder::new()\n  t.output(logger)\n  logger.to_string()\n}\n\n///|\n#deprecated(\"replace `impl op_equal` with `impl equal`\")\nimpl Eq with equal(self, other) {\n  Eq::op_equal(self, other)\n}\n\n///|\nimpl Eq with op_equal(self, other) {\n  Eq::equal(self, other)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Returns the source string being viewed.\nfn StringView::str(self : StringView) -> String = \"%stringview.str\"\n\n///|\n/// Returns the starting UTF-16 code unit index into the string.\nfn StringView::start(self : StringView) -> Int = \"%stringview.start\"\n\n///|\n/// Returns the ending UTF-16 code unit index into the string (not included).\nfn StringView::end(self : StringView) -> Int = \"%stringview.end\"\n\n///|\nfn StringView::make_view(str : String, start : Int, end : Int) -> StringView = \"%stringview.make\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn StringView::at(self : StringView, index : Int) -> UInt16 {\n  guard index >= 0 && index < self.length() else {\n    abort(\"Index out of bounds\")\n  }\n  self.str().code_unit_at(self.start() + index)\n}\n\n///|\n/// Returns the length of the view.\n/// \n/// This method counts the charcodes(code unit) in the view and has O(1) complexity.\npub fn StringView::length(self : StringView) -> Int {\n  self.end() - self.start()\n}\n\n///|\n/// Iterates over all suffixes of the view, advancing by a Unicode character at\n/// a time. Each yielded suffix is itself a view into the original string.\npub fn StringView::suffixes(\n  self : StringView,\n  include_empty? : Bool = false,\n) -> Iterator[StringView] {\n  let str = self.str()\n  let end = self.end()\n  let mut next_start = self.start()\n  let mut finished = false\n  Iterator::new(fn() -> StringView? {\n    if finished {\n      None\n    } else if next_start == end {\n      finished = true\n      if include_empty {\n        Some(StringView::make_view(str, next_start, end))\n      } else {\n        None\n      }\n    } else {\n      let suffix = StringView::make_view(str, next_start, end)\n      let code = str.unsafe_charcode_at(next_start)\n      if code.is_leading_surrogate() &&\n        next_start + 1 < end &&\n        str.unsafe_charcode_at(next_start + 1).is_trailing_surrogate() {\n        next_start += 2\n      } else {\n        next_start += 1\n      }\n      Some(suffix)\n    }\n  })\n}\n\n///|\n/// Returns the original string that is being viewed.\npub fn StringView::data(self : StringView) -> String {\n  self.str()\n}\n\n///|\n/// Returns the starting offset (in UTF-16 code units) of this view into its\n/// underlying string.\npub fn StringView::start_offset(self : StringView) -> Int {\n  self.start()\n}\n\n///|\n/// Returns a new view of the view with the given start and end offsets.\npub fn StringView::view(\n  self : StringView,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(\n    self.str(),\n    self.start() + start_offset,\n    self.start() + end_offset,\n  )\n}\n\n///|\n/// Returns the charcode(code unit) at the given index without checking if the\n/// index is within bounds.\n/// \n/// This method has O(1) complexity.\n/// #Example\n/// \n/// ```mbt\n///   let str = \"BğŸ¤£ğŸ¤£C\"\n///   let view = str[:]\n///   inspect(view.unsafe_charcode_at(0), content=\"66\")\n///   inspect(view.unsafe_charcode_at(1), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(2), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(3), content=\"55358\")\n///   inspect(view.unsafe_charcode_at(4), content=\"56611\")\n///   inspect(view.unsafe_charcode_at(5), content=\"67\")\n/// ```\n/// TODO: rename to `unsafe_get`\npub fn StringView::unsafe_charcode_at(self : StringView, index : Int) -> Int {\n  self.str().unsafe_charcode_at(self.start() + index)\n}\n\n///|\n/// Returns the number of Unicode characters in this view.\n/// \n/// Note this has O(n) complexity where n is the length of the code points in \n/// the view.\npub fn StringView::char_length(self : StringView) -> Int {\n  self.str().char_length(start_offset=self.start(), end_offset=self.end())\n}\n\n///|\npub impl Show for StringView with output(self, logger) {\n  let substr = self.str().unsafe_substring(start=self.start(), end=self.end())\n  String::output(substr, logger)\n}\n\n///|\n/// Returns a new String containing a copy of the characters in this view.\n/// \n/// # Examples\n/// \n/// ```mbt\n///   let str = \"Hello World\"\n///   let view = str.view(start_offset = str.offset_of_nth_char(0).unwrap(),end_offset = str.offset_of_nth_char(5).unwrap()) // \"Hello\"\n///   inspect(view.to_string(), content=\"Hello\")\n/// ```\npub impl Show for StringView with to_string(self) {\n  // when `self == self.str()`, `String::unsafe_substring` would return original string, which doesn't create a new copy.\n  self.str().unsafe_substring(start=self.start(), end=self.end())\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\npub fn StringView::iter(self : StringView) -> Iter[Char] {\n  self.iterator().iter()\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view.\npub fn StringView::iterator(self : StringView) -> Iterator[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  Iterator::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        index += 2\n        return Some(code_point_of_surrogate_pair(c1, c2))\n      }\n    }\n    index += 1\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\npub fn StringView::iter2(self : StringView) -> Iter2[Int, Char] {\n  self.iterator2().iter2()\n}\n\n///|\npub fn StringView::iterator2(self : StringView) -> Iterator2[Int, Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = start\n  let mut char_index = 0\n  Iterator2::new(fn() {\n    guard index < end else { None }\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_leading_surrogate() && index + 1 < self.end() {\n      let c2 = self.str().unsafe_charcode_at(index + 1)\n      if c2.is_trailing_surrogate() {\n        let result = (char_index, code_point_of_surrogate_pair(c1, c2))\n        index += 2\n        char_index += 1\n        return Some(result)\n      }\n    }\n    let result = (char_index, c1.unsafe_to_char())\n    index += 1\n    char_index += 1\n    Some(result)\n  })\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\npub fn StringView::rev_iter(self : StringView) -> Iter[Char] {\n  self.rev_iterator().iter()\n}\n\n///|\n/// Returns an iterator over the Unicode characters in the string view in reverse order.\npub fn StringView::rev_iterator(self : StringView) -> Iterator[Char] {\n  let start = self.start()\n  let end = self.end()\n  let mut index = end\n  Iterator::new(fn() {\n    guard index > start else { None }\n    index -= 1\n    let c1 = self.str().unsafe_charcode_at(index)\n    if c1.is_trailing_surrogate() && index - 1 >= 0 {\n      let c2 = self.str().unsafe_charcode_at(index - 1)\n      if c2.is_leading_surrogate() {\n        index -= 1\n        return Some(code_point_of_surrogate_pair(c2, c1))\n      }\n    }\n    Some(c1.unsafe_to_char())\n  })\n}\n\n///|\n/// Compares two views for equality. Returns true only if both views\n/// have the same length and contain identical characters in the same order.\npub impl Eq for StringView with equal(self, other) {\n  let len = self.length()\n  guard len == other.length() else { return false }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return true\n  }\n  for i in 0..<len {\n    guard self.str().unsafe_charcode_at(self.start() + i) ==\n      other.str().unsafe_charcode_at(other.start() + i) else {\n      return false\n    }\n  }\n  true\n}\n\n///|\n/// Views are ordered based on shortlex order by their charcodes (code units). This \n/// orders Unicode characters based on their positions in the code charts. This is\n/// not necessarily the same as \"alphabetical\" order, which varies by language\n/// and locale.\npub impl Compare for StringView with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  guard cmp == 0 else { return cmp }\n  if physical_equal(self.str(), other.str()) && self.start() == other.start() {\n    return 0\n  }\n  for i in 0..<self_len {\n    let cmp = self\n      .str()\n      .unsafe_charcode_at(self.start() + i)\n      .compare(other.str().unsafe_charcode_at(other.start() + i))\n    guard cmp == 0 else { return cmp }\n  }\n  0\n}\n\n///|\n/// Performs a lexicographical comparison of two string views.\n///\n/// This method compares the views character by character (UTF-16 code unit by code unit),\n/// similar to Java's `String.compareTo()`. Unlike the `Compare` trait implementation which\n/// uses shortlex order (shorter strings come first), this method compares based purely on\n/// character values until a difference is found or one view is exhausted.\n///\n/// # Returns\n///\n/// - A negative integer if `self` is lexicographically less than `other`\n/// - Zero if `self` is lexicographically equal to `other`\n/// - A positive integer if `self` is lexicographically greater than `other`\n///\n/// # Example\n///\n/// ```mbt\n/// let str = \"abc\"\n/// inspect(str.view(start_offset=0, end_offset=2).lexical_compare(str.view(start_offset=0, end_offset=3)), content=\"-1\")\n/// inspect(str.view(start_offset=0, end_offset=3).lexical_compare(str.view(start_offset=0, end_offset=2)), content=\"1\")\n/// inspect(str.view(start_offset=0, end_offset=2).lexical_compare(str.view(start_offset=1, end_offset=3)), content=\"-1\")\n/// ```\n///\n/// # Note\n///\n/// Since MoonBit strings are UTF-16 encoded (like Java), this comparison operates on\n/// UTF-16 code units, not Unicode code points. Surrogate pairs (used for characters\n/// outside the Basic Multilingual Plane) are compared as individual code units.\npub fn StringView::lexical_compare(\n  self : StringView,\n  other : StringView,\n) -> Int {\n  let self_len = self.length()\n  let other_len = other.length()\n  let min_len = if self_len < other_len { self_len } else { other_len }\n\n  // Compare character by character up to the minimum length\n  for i in 0..<min_len {\n    let self_char = self.str().unsafe_charcode_at(self.start() + i)\n    let other_char = other.str().unsafe_charcode_at(other.start() + i)\n    let cmp = self_char.compare(other_char)\n    if cmp != 0 {\n      return cmp\n    }\n  }\n\n  // If all characters match up to min_len, the shorter one is lexicographically smaller\n  self_len.compare(other_len)\n}\n\n///|\n/// Creates a `View` into a `String`.\n/// \n/// # Example\n/// \n/// ```mbt\n///   let str = \"HelloğŸ¤£ğŸ¤£ğŸ¤£\"\n///   let view1 = str.view()\n///   inspect(view1, content=\n///    \"HelloğŸ¤£ğŸ¤£ğŸ¤£\"\n///   )\n///   let start_offset = str.offset_of_nth_char(1).unwrap()\n///   let end_offset = str.offset_of_nth_char(6).unwrap() // the second emoji\n///   let view2 = str.view(start_offset~, end_offset~)\n///   inspect(view2, content=\n///    \"elloğŸ¤£\"\n///   )\n/// ```\npub fn String::view(\n  self : String,\n  start_offset? : Int = 0,\n  end_offset? : Int,\n) -> StringView {\n  let end_offset = if end_offset is Some(o) { o } else { self.length() }\n  guard start_offset >= 0 &&\n    start_offset <= end_offset &&\n    end_offset <= self.length() else {\n    abort(\"Invalid index for View\")\n  }\n  StringView::make_view(self, start_offset, end_offset)\n}\n\n///|\n/// Convert char array to string view.\npub fn StringView::from_array(chars : ArrayView[Char]) -> StringView {\n  String::from_array(chars)\n}\n\n///|\n/// Convert char iterator to string view.\npub fn StringView::from_iter(iter : Iter[Char]) -> StringView {\n  String::from_iter(iter)\n}\n\n///|\n/// Convert char iterator to string view.\npub fn StringView::from_iterator(iter : Iterator[Char]) -> StringView {\n  String::from_iterator(iter)\n}\n\n///|\npub suberror CreatingViewError {\n  IndexOutOfBounds\n  InvalidIndex\n} derive(Show)\n\n///|\n/// Creates a view of a string with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index (default: 0)\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string (e.g., -1 means last position)\n/// - `end` : Ending UTF-16 code unit index (optional)\n///   - If `None`: extends to the end of the string\n///   - If positive: counts from the beginning of the string\n///   - If negative: counts from the end of the string\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified substring range\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of valid range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt\n/// let str = \"HelloğŸ¤£World\"\n/// let view1 =  str[0:5]\n/// inspect(\n///   view1,\n///   content=(\n///     \"Hello\"\n///   ),\n/// )\n/// let view2 = try? str[-5:]\n/// inspect(\n///   view2,\n///   content=(\n///     #|Ok(\"World\")\n///   ),\n/// )\n/// let view3 = try? str[:6]\n/// inspect(view3, content=\"Err(InvalidIndex)\")\n/// ```\n#alias(\"_[_:_]\")\npub fn String::sub(\n  self : String,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => if end < 0 { len + end } else { end }\n  }\n  let start = if start < 0 { len + start } else { start }\n  guard start >= 0 && start <= end && end <= len else { raise IndexOutOfBounds }\n  if start < len && self.unsafe_charcode_at(start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if end < len && self.unsafe_charcode_at(end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self, start, end)\n}\n\n///|\n/// Creates a subview of an existing view with proper UTF-16 boundary validation.\n/// \n/// # Parameters\n/// \n/// - `start` : Starting UTF-16 code unit index relative to this view (default: 0)\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// - `end` : Ending UTF-16 code unit index relative to this view (optional)\n///   - If `None`: extends to the end of this view\n///   - If positive: counts from the beginning of this view\n///   - If negative: counts from the end of this view\n/// \n/// # Returns\n/// \n/// - A `View` representing the specified subrange of this view\n/// \n/// # Errors\n/// \n/// - `IndexOutOfBounds` : If start or end indices are out of this view's range\n/// - `InvalidIndex` : If start or end position would split a UTF-16 surrogate pair\n/// \n/// This prevents creating views that would split surrogate pairs, which would\n/// result in invalid Unicode characters.\n/// \n/// # Performance\n/// \n/// This function has O(1) complexity as it only performs boundary checks\n/// without scanning the string content.\n/// \n/// # Examples\n/// \n/// ```mbt\n/// let str = \"HelloğŸ¤£World\"[1:-1] // \"elloğŸ¤£Worl\"\n/// let view1 = str[0:6]\n/// inspect(view1, content=\"elloğŸ¤£\")\n/// let view2 = str[-2:]\n/// inspect(view2, content=\"rl\")\n/// let view3 = try? str[:5]\n/// inspect(view3, content=\"Err(InvalidIndex)\")\n/// ```\n#alias(\"_[_:_]\")\npub fn StringView::sub(\n  self : StringView,\n  start? : Int = 0,\n  end? : Int,\n) -> StringView raise CreatingViewError {\n  let str_len = self.str().length()\n\n  // Calculate absolute positions in the original string\n  let abs_end = match end {\n    None => self.end()\n    Some(end) => if end < 0 { self.end() + end } else { self.start() + end }\n  }\n  let abs_start = if start < 0 {\n    self.end() + start\n  } else {\n    self.start() + start\n  }\n\n  // Validate bounds against the original string\n  guard abs_start >= self.start() &&\n    abs_start <= abs_end &&\n    abs_end <= self.end() else {\n    raise IndexOutOfBounds\n  }\n\n  // Check for surrogate pair boundaries\n  if abs_start < str_len &&\n    self.str().unsafe_charcode_at(abs_start).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  if abs_end < str_len &&\n    self.str().unsafe_charcode_at(abs_end).is_trailing_surrogate() {\n    raise InvalidIndex\n  }\n  StringView::make_view(self.str(), abs_start, abs_end)\n}\n\n///|\n/// Test if the length of the view is equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_eq(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_eq(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Test if the length of the view is greater than or equal to the given length.\n/// \n/// This has O(n) complexity where n is the length in the parameter.\npub fn StringView::char_length_ge(self : StringView, len : Int) -> Bool {\n  self\n  .str()\n  .char_length_ge(len, start_offset=self.start(), end_offset=self.end())\n}\n\n///|\n/// Returns the UTF-16 index of the i-th (zero-indexed) Unicode character of\n/// the view. If i is negative, it returns the index of the (n + i)-th character\n/// where n is the total number of Unicode characters in the view.\npub fn StringView::offset_of_nth_char(self : StringView, i : Int) -> Int? {\n  if self\n    .str()\n    .offset_of_nth_char(i, start_offset=self.start(), end_offset=self.end())\n    is Some(index) {\n    Some(index - self.start())\n  } else {\n    None\n  }\n}\n\n///|\n/// The empty view of a string\npub impl Default for StringView with default() {\n  \"\"\n}\n\n///|\n/// Create a new string by repeating the given character `value` `length` times.\npub fn StringView::make(length : Int, value : Char) -> StringView {\n  String::make(length, value)\n}\n\n///|\npub impl ToJson for StringView with to_json(self) {\n  String::to_json(self.to_string())\n}\n\n///|\npub impl Add for StringView with add(self, other) {\n  [..self, ..other]\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Reinterpret the byte sequence as Bytes.\n///\n/// Notice that this will make the `Bytes` object to be a view of the original\n/// byte sequence, so any modification to the original byte sequence will be\n/// reflected in the `Bytes` object.\n#internal(unsafe, \"Creating mutable Bytes\")\n#doc(hidden)\npub fn FixedArray::unsafe_reinterpret_as_bytes(\n  self : FixedArray[Byte],\n) -> Bytes = \"%identity\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized using a function that maps indices to bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. If `length` is less than or\n/// equal to 0, returns an empty byte sequence.\n/// * `value` : A function that takes an index (from 0 to `length - 1`) and\n/// returns a byte for that position.\n///\n/// Returns a new byte sequence containing the bytes produced by applying the\n/// value function to each index.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = Bytes::makei(3, i => (i + 65).to_byte())\n/// assert_eq(bytes, b\"ABC\")\n/// ```\npub fn Bytes::makei(length : Int, value : (Int) -> Byte raise?) -> Bytes raise? {\n  if length <= 0 {\n    return []\n  }\n  let arr = FixedArray::make(length, value(0))\n  for i in 1..<length {\n    arr[i] = value(i)\n  }\n  FixedArray::unsafe_reinterpret_as_bytes(arr)\n}\n\n///|\n/// TODO: support local primitive declaration\n#owned(bytes)\nfn unsafe_sub_string(\n  bytes : Bytes,\n  byte_offset : Int,\n  byte_length : Int,\n) -> String = \"$moonbit.unsafe_bytes_sub_string\"\n\n///|\n/// Return an unchecked string, containing the subsequence of `self` that starts at\n/// `offset` and has length `length`. Both `offset` and `length`\n/// are indexed by byte.\n///\n/// Note this function does not validate the encoding of the byte sequence,\n/// it simply copy the bytes into a new String.\npub fn Bytes::to_unchecked_string(\n  self : Bytes,\n  offset? : Int = 0,\n  length? : Int,\n) -> String {\n  let len = self.length()\n  let length = if length is Some(l) { l } else { len - offset }\n  guard offset >= 0 && length >= 0 && offset + length <= len\n  unsafe_sub_string(self, offset, length)\n}\n\n///|\n/// Copies characters from a string to a byte sequence in UTF-16LE encoding. Each\n/// character is converted into two bytes, with the lower byte stored first.\n///\n/// Parameters:\n///\n/// * `self` : The destination byte array to copy the characters into.\n/// * `bytes_offset` : The starting position in the destination array where bytes\n/// will be written.\n/// * `str` : The source string containing the characters to copy.\n/// * `str_offset` : The starting position in the source string from which\n/// characters will be read.\n/// * `length` : The number of characters to copy.\n///\n/// Throws a runtime error if:\n///\n/// * `length` is negative\n/// * `bytes_offset` is negative\n/// * `str_offset` is negative\n/// * The range `[bytes_offset, bytes_offset + length * 2)` exceeds the length of\n/// the destination array\n/// * The range `[str_offset, str_offset + length)` exceeds the length of the\n/// source string\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = FixedArray::make(6, b'\\x00')\n/// bytes.blit_from_string(0, \"ABC\", 0, 3)\n/// @json.inspect(bytes, content=[65, 0, 66, 0, 67, 0]) // 'A'\n/// bytes.blit_from_string(0, \"ä½ å¥½å•Š\", 0, 3)\n/// @json.inspect(bytes, content=[96, 79, 125, 89, 74, 85]) // 'ä½ å¥½å•Š'\n/// bytes.blit_from_string(0, \"ğŸ˜ˆ\", 0, 2)\n/// @json.inspect(bytes, content=[61, 216, 8, 222, 74, 85]) // 'ğŸ˜ˆ'\n/// ```\npub fn FixedArray::blit_from_string(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  str : String,\n  str_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = str_offset\n  let e1 = bytes_offset + length * 2 - 1\n  let e2 = str_offset + length - 1\n  let len1 = self.length()\n  let len2 = str.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  let end_str_offset = str_offset + length\n  for i = str_offset, j = bytes_offset; i < end_str_offset; i = i + 1, j = j + 2 {\n    let c = str.unsafe_charcode_at(i).reinterpret_as_uint()\n    self[j] = (c & 0xff).to_byte()\n    self[j + 1] = (c >> 8).to_byte()\n  }\n}\n\n///|\n/// TODO: specific copy\nfn unsafe_from_bytes(bytes : Bytes) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Copy `length` chars from byte sequence `src`, starting at `src_offset`,\n/// into byte sequence `self`, starting at `bytes_offset`.\npub fn FixedArray::blit_from_bytes(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : Bytes,\n  src_offset : Int,\n  length : Int,\n) -> Unit {\n  let s1 = bytes_offset\n  let s2 = src_offset\n  let e1 = bytes_offset + length - 1\n  let e2 = src_offset + length - 1\n  let len1 = self.length()\n  let len2 = src.length()\n  guard length >= 0 && s1 >= 0 && e1 < len1 && s2 >= 0 && e2 < len2\n  FixedArray::unsafe_blit(\n    self,\n    bytes_offset,\n    unsafe_from_bytes(src),\n    src_offset,\n    length,\n  )\n}\n\n///|\n/// Copy bytes from a BytesView into a fixed array of bytes.\n///\n/// Parameters:\n///\n/// * `self` : The destination fixed array of bytes.\n/// * `bytes_offset` : The starting position in the destination array where bytes will be copied.\n/// * `src` : The source View to copy from.\n///\n/// Throws a panic if:\n/// * `bytes_offset` is negative\n/// * The destination array is too small to hold all bytes from the source View\n///\n/// Example:\n///\n/// ```mbt\n///  let arr = FixedArray::make(4, b'\\x00')\n///  let view = b\"\\x01\\x02\\x03\"[1:]\n///  arr.blit_from_bytesview(1, view)\n///  inspect(arr, content=\"[b'\\\\x00', b'\\\\x02', b'\\\\x03', b'\\\\x00']\")\n/// ```\npub fn FixedArray::blit_from_bytesview(\n  self : FixedArray[Byte],\n  bytes_offset : Int,\n  src : BytesView,\n) -> Unit {\n  FixedArray::blit_from_bytes(\n    self,\n    bytes_offset,\n    src.bytes(),\n    src.start(),\n    src.len(),\n  )\n}\n\n///|\n/// Encodes a Unicode character into UTF-8 bytes and writes them into a fixed\n/// array of bytes at the specified offset.\n///\n/// Parameters:\n///\n/// * `array` : The fixed array of bytes to write into.\n/// * `offset` : The starting position in the array where the encoded bytes will\n/// be written.\n/// * `char` : The Unicode character to be encoded.\n///\n/// Returns the number of bytes written (1 to 4 bytes depending on the\n/// character's code point).\n///\n/// Throws a panic if:\n///\n/// * The character's code point is greater than 0x10FFFF.\n/// ```mbt test\n/// let buf = FixedArray::make(4, b'\\x00')\n/// let written = buf.set_utf8_char(0, 'â‚¬') // Euro symbol (U+20AC)\n/// inspect(written, content=\"3\") // UTF-8 encoding takes 3 bytes\n/// inspect(buf[0], content=\"b'\\\\xE2'\")\n/// inspect(buf[1], content=\"b'\\\\x82'\")\n/// inspect(buf[2], content=\"b'\\\\xAC'\")\n/// ```\npub fn FixedArray::set_utf8_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  match code {\n    _..<0x80 => {\n      self[offset] = ((code & 0x7F) | 0x00).to_byte()\n      1\n    }\n    _..<0x0800 => {\n      self[offset] = (((code >> 6) & 0x1F) | 0xC0).to_byte()\n      self[offset + 1] = ((code & 0x3F) | 0x80).to_byte()\n      2\n    }\n    _..<0x010000 => {\n      self[offset] = (((code >> 12) & 0x0F) | 0xE0).to_byte()\n      self[offset + 1] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = ((code & 0x3F) | 0x80).to_byte()\n      3\n    }\n    _..<0x110000 => {\n      self[offset] = (((code >> 18) & 0x07) | 0xF0).to_byte()\n      self[offset + 1] = (((code >> 12) & 0x3F) | 0x80).to_byte()\n      self[offset + 2] = (((code >> 6) & 0x3F) | 0x80).to_byte()\n      self[offset + 3] = ((code & 0x3F) | 0x80).to_byte()\n      4\n    }\n    _ => abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16LE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16le_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code & 0xFF).to_byte()\n    self[offset + 1] = (code >> 8).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo & 0xFF).to_byte()\n    self[offset + 1] = (lo >> 8).to_byte()\n    self[offset + 2] = (hi & 0xFF).to_byte()\n    self[offset + 3] = (hi >> 8).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Fill UTF16BE encoded char `value` into byte sequence `self`, starting at `offset`.\n/// It return the length of bytes has been written.\n///\n/// This function will panic if the `value` is out of range.\npub fn FixedArray::set_utf16be_char(\n  self : FixedArray[Byte],\n  offset : Int,\n  value : Char,\n) -> Int {\n  let code = value.to_uint()\n  if code < 0x10000 {\n    self[offset] = (code >> 8).to_byte()\n    self[offset + 1] = (code & 0xFF).to_byte()\n    2\n  } else if code < 0x110000 {\n    let hi = code - 0x10000\n    let lo = (hi >> 10) | 0xD800\n    let hi = (hi & 0x3FF) | 0xDC00\n    self[offset] = (lo >> 8).to_byte()\n    self[offset + 1] = (lo & 0xFF).to_byte()\n    self[offset + 2] = (hi >> 8).to_byte()\n    self[offset + 3] = (hi & 0xFF).to_byte()\n    4\n  } else {\n    abort(\"Char out of range\")\n  }\n}\n\n///|\n/// Compares two byte sequences for equality. Returns true only if both sequences\n/// have the same length and contain identical bytes in the same order.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns `true` if the byte sequences are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes1 = b\"\\x01\\x02\\x03\"\n/// let bytes2 = b\"\\x01\\x02\\x03\"\n/// let bytes3 = b\"\\x01\\x02\\x04\"\n/// inspect(bytes1 == bytes2, content=\"true\")\n/// inspect(bytes1 == bytes3, content=\"false\")\n/// ```\npub impl Eq for Bytes with equal(self : Bytes, other : Bytes) -> Bool {\n  if self.length() != other.length() {\n    false\n  } else {\n    let len = self.length()\n    for i in 0..<len {\n      if self[i] != other[i] {\n        break false\n      }\n    } else {\n      true\n    }\n  }\n}\n\n///|\n/// Compares two byte sequences based on shortlex order. First compares the lengths of\n/// the sequences, then compares bytes pairwise until a difference is found or\n/// all bytes have been compared.\n///\n/// Parameters:\n///\n/// * `self` : The first byte sequence to compare.\n/// * `other` : The second byte sequence to compare.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = b\"\\x01\\x02\\x03\"\n/// let b = b\"\\x01\\x02\\x04\"\n/// inspect(a.compare(b), content=\"-1\") // a < b\n/// inspect(b.compare(a), content=\"1\") // b > a\n/// inspect(a.compare(a), content=\"0\") // a = a\n/// let a = b\"\\x01\\x02\"\n/// let b = b\"\\x01\\x02\\x03\"\n/// inspect(a.compare(b), content=\"-1\") // shorter sequence is less\n/// inspect(b.compare(a), content=\"1\") // longer sequence is greater\n/// ```\npub impl Compare for Bytes with compare(self, other) {\n  let self_len = self.length()\n  let other_len = other.length()\n  let cmp = self_len.compare(other_len)\n  if cmp != 0 {\n    return cmp\n  }\n  for i in 0..<self_len {\n    let b1 = self.unsafe_get(i)\n    let b2 = other.unsafe_get(i)\n    let cmp = b1.compare(b2)\n    if cmp != 0 {\n      break cmp\n    }\n  } else {\n    0\n  }\n}\n\n///|\n/// Creates a new bytes sequence from a byte array.\n///\n/// Parameters:\n///\n/// * `array` : An array of bytes to be converted.\n///\n/// Returns a new bytes sequence containing the same bytes as the input array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = [b'h', b'i']\n/// let bytes = Bytes::from_array(arr)\n/// inspect(\n///   bytes,\n///   content=(\n///     #|b\"hi\"\n///   ),\n/// )\n/// ```\n#alias(of, deprecated=\"Use Bytes::from_array instead\")\npub fn Bytes::from_array(arr : ArrayView[Byte]) -> Bytes {\n  Bytes::makei(arr.length(), i => arr[i])\n}\n\n///|\n/// Creates a new bytes sequence from a fixed-size array of bytes with an\n/// optional length parameter.\n///\n/// Parameters:\n///\n/// * `array` : A fixed-size array of bytes to be converted into a bytes\n/// sequence.\n/// * `length` : (Optional) The length of the resulting bytes sequence. If not\n/// provided, uses the full length of the input array.\n///\n/// Returns a new bytes sequence containing the bytes from the input array. If a\n/// length is specified, only includes up to that many bytes.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n/// let bytes = Bytes::from_array(arr[0:3])\n/// inspect(\n///   bytes,\n///   content=(\n///     #|b\"hel\"\n///   ),\n/// )\n/// ```\n/// \n/// Panics if the length is invalid\n#deprecated(\"Use Bytes::from_array instead\")\npub fn Bytes::from_fixedarray(arr : FixedArray[Byte], len? : Int) -> Bytes {\n  let len = match len {\n    None => arr.length()\n    Some(x) => {\n      guard 0 <= x && x <= arr.length()\n      x\n    }\n  }\n  let result = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_to(result, len~)\n  result.unsafe_reinterpret_as_bytes()\n}\n\n///|\n/// Converts a bytes sequence into a fixed-size array of bytes. If an optional\n/// length is provided, the resulting array will have exactly that length,\n/// otherwise it will match the length of the input bytes.\n///\n/// Parameters:\n///\n/// * `self` : The bytes sequence to convert.\n/// * `len` : Optional. The desired length of the output array. If specified, the\n/// resulting array will have this length. If not specified, the length of the\n/// input bytes sequence will be used.\n///\n/// Returns a fixed-size array containing the bytes from the input sequence.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = b\"hello\"\n/// let arr = bytes.to_fixedarray()\n/// inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n/// let arr2 = bytes[:3].to_fixedarray()\n/// inspect(arr2, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C']\")\n/// ```\n/// \n/// Panics if the length is invalid\n#label_migration(len, fill=false)\npub fn Bytes::to_fixedarray(self : Bytes, len? : Int) -> FixedArray[Byte] {\n  let len = match len {\n    None => self.length()\n    Some(x) => {\n      guard 0 <= x && x <= self.length()\n      x\n    }\n  }\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self, 0, len)\n  arr\n}\n\n///|\npub fn BytesView::to_fixedarray(self : BytesView) -> FixedArray[Byte] {\n  let len = self.length()\n  let arr = unsafe_to_fixedarray(UninitializedArray::make(len))\n  arr.blit_from_bytes(0, self.data(), self.start_offset(), len)\n  arr\n}\n\n///|\n/// Creates a new bytes sequence from an iterator of bytes.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator that yields bytes.\n///\n/// Returns a new bytes sequence containing all the bytes from the iterator.\n///\n/// Example:\n///\n/// ```mbt test\n/// let iter = Iter::singleton(b'h')\n/// let bytes = Bytes::from_iter(iter)\n/// inspect(\n///   bytes,\n///   content=(\n///     #|b\"h\"\n///   ),\n/// )\n/// ```\npub fn Bytes::from_iter(iter : Iter[Byte]) -> Bytes {\n  Bytes::from_array(iter.collect())\n}\n\n///|\n/// Creates a new bytes sequence from an iterator of bytes.\n///\n/// Parameters:\n///\n/// * `iterator` : An iterator that yields bytes.\n///\n/// Returns a new bytes sequence containing all the bytes from the iterator.\n///\n/// Example:\n///\n/// ```mbt test\n/// let iter = Iterator::singleton(b'h')\n/// let bytes = Bytes::from_iterator(iter)\n/// inspect(\n///   bytes,\n///   content=(\n///     #|b\"h\"\n///   ),\n/// )\n/// ```\npub fn Bytes::from_iterator(iter : Iterator[Byte]) -> Bytes {\n  Bytes::from_array(iter.collect())\n}\n\n///|\n/// Creates a new bytes sequence from a fixed-size byte array.\n///\n/// Parameters:\n///\n/// * `array` : A fixed-size array of bytes to be converted into a bytes\n/// sequence. Elements in the array should be of type `Byte`.\n///\n/// Returns a new bytes sequence containing the same bytes as the input array.\n///\n/// Example:\n///\n/// ```mbt test\n///   let arr : FixedArray[Byte] = [b'h', b'e', b'l', b'l', b'o']\n///   let bytes = Bytes::of(arr)\n///   inspect(\n///     bytes, \n///     content=(\n///       \n///   #|b\"hello\"\n/// \n///     ),\n///   )\n/// ```\n/// TODO: marked as intrinsic, inline if it is constant\n\n///|\n/// Converts a bytes sequence into an array of bytes.\n///\n/// Parameters:\n///\n/// * `bytes` : A sequence of bytes to be converted into an array.\n///\n/// Returns an array containing the same bytes as the input sequence.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = b\"hello\"\n/// let arr = bytes.to_array()\n/// inspect(arr, content=\"[b'\\\\x68', b'\\\\x65', b'\\\\x6C', b'\\\\x6C', b'\\\\x6F']\")\n/// ```\npub fn Bytes::to_array(self : Bytes) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\npub fn BytesView::to_array(self : BytesView) -> Array[Byte] {\n  let len = self.length()\n  let rv = Array::make(len, b'0')\n  for i in 0..<len {\n    rv[i] = self[i]\n  }\n  rv\n}\n\n///|\n/// Creates an iterator over the bytes in the sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : A byte sequence to iterate over.\n///\n/// Returns an iterator that yields each byte in the sequence in order.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = Bytes::from_array([b'h', b'i'])\n/// let mut sum = 0\n/// bytes.iter().each(b => sum = sum + b.to_int())\n/// inspect(sum, content=\"209\") // ASCII values: 'h'(104) + 'i'(105) = 209\n/// ```\npub fn Bytes::iter(self : Bytes) -> Iter[Byte] {\n  self.iterator().iter()\n}\n\n///|\n/// Creates an iterator over the bytes in the sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : A byte sequence to iterate over.\n///\n/// Returns an iterator that yields each byte in the sequence in order.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = Bytes::from_array([b'h', b'i'])\n/// let mut sum = 0\n/// bytes.iterator().each(b => sum = sum + b.to_int())\n/// inspect(sum, content=\"209\") // ASCII values: 'h'(104) + 'i'(105) = 209\n/// ```\npub fn Bytes::iterator(self : Bytes) -> Iterator[Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iterator::new(fn() {\n    guard i < len else { None }\n    let c = self.unsafe_get(i)\n    i += 1\n    Some(c)\n  })\n}\n\n///|\n/// Creates an iterator that yields tuples of index and byte,\n/// indices start from 0.\n/// \n/// Example:\n///   let buf = StringBuilder::new(size_hint=5)\n///   let keys = []\n///   b\"abcde\".iter2().each((i, x) => {\n///     buf.write_string(x.to_string())\n///     keys.push( i )\n///   })\n///   inspect(buf, content=\"b'\\\\x61'b'\\\\x62'b'\\\\x63'b'\\\\x64'b'\\\\x65'\")\n///   inspect(keys, content=\"[0, 1, 2, 3, 4]\")\npub fn Bytes::iter2(self : Bytes) -> Iter2[Int, Byte] {\n  self.iterator2().iter2()\n}\n\n///|\n/// Creates an iterator that yields tuples of index and byte,\n/// indices start from 0.\n/// \n/// Example:\n///\n/// ```mbt test\n/// let buf = StringBuilder::new(size_hint=5)\n/// let keys = []\n/// let it = b\"abcde\".iterator2()\n/// while it.next() is Some((i, x)) {\n///   buf.write_string(x.to_string())\n///   keys.push(i)\n/// }\n/// inspect(buf, content=\"b'\\\\x61'b'\\\\x62'b'\\\\x63'b'\\\\x64'b'\\\\x65'\")\n/// inspect(keys, content=\"[0, 1, 2, 3, 4]\")\n/// ```\npub fn Bytes::iterator2(self : Bytes) -> Iterator2[Int, Byte] {\n  let mut i = 0\n  let len = self.length()\n  Iterator::new(fn() {\n    guard i < len else { None }\n    let result = (i, self.unsafe_get(i))\n    i += 1\n    Some(result)\n  })\n}\n\n///|\n/// Creates a new empty bytes sequence.\n///\n/// Returns an empty bytes sequence.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = Bytes::default()\n/// inspect(bytes, content=\"b\\\"\\\"\")\n/// inspect(bytes.length(), content=\"0\")\n/// ```\npub impl Default for Bytes with default() {\n  b\"\"\n}\n\n///|\n/// Retrieves a byte from the view at the specified index.\n///\n/// Parameters:\n///\n/// * `self` : The bytes view to retrieve the byte from.\n/// * `index` : The position in the view from which to retrieve the byte.\n///\n/// Returns the byte at the specified index, or None if the index is out of bounds.\n///\n/// Example:\n/// \n/// ```mbt test\n/// let bytes = b\"\\x01\\x02\\x03\"\n/// let byte = bytes.get(1)\n/// inspect(byte, content=\"Some(b'\\\\x02')\")\n/// let bytes = b\"\\x01\\x02\\x03\"\n/// let byte = bytes.get(3)\n/// inspect(byte, content=\"None\")\n/// ```\npub fn Bytes::get(self : Bytes, index : Int) -> Byte? {\n  guard index >= 0 && index < self.length() else { None }\n  Some(self[index])\n}\n\n///|\nfn unsafe_to_fixedarray(array : UninitializedArray[Byte]) -> FixedArray[Byte] = \"%identity\"\n\n///|\n/// Concatenates two bytes sequences.\n///\n/// Parameters:\n///\n/// * `self` : The first bytes sequence.\n/// * `other` : The second bytes sequence.\n/// TODO: marked as intrinsic, inline if it is constant\npub impl Add for Bytes with add(self : Bytes, other : Bytes) -> Bytes {\n  let len_self = self.length()\n  let len_other = other.length()\n  let rv : FixedArray[Byte] = FixedArray::make(len_self + len_other, 0)\n  for i in 0..<len_self {\n    rv[i] = self[i]\n  }\n  for i in 0..<len_other {\n    rv[len_self + i] = other[i]\n  }\n  unsafe_to_bytes(rv)\n}\n\n///|\npub impl Hash for Bytes with hash_combine(self, hasher) {\n  hasher.combine(self[:])\n}\n\n///|\n/// Returns a new `Bytes` consisting of `self` repeated `count` times.\n///\n/// If `count <= 0` or `self` is empty, an empty `Bytes` is returned. When\n/// `count == 1`, `self` is returned directly without allocation.\n///\n/// This implementation performs a single allocation sized exactly to the\n/// result and fills it using an exponential copy (doubling) strategy so the\n/// number of blit operations is O(log count).\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(\n///   b\"ab\".repeat(3),\n///   content=(\n///     #|b\"ababab\"\n///   ),\n/// )\n/// inspect(\n///   b\"xyz\".repeat(0),\n///   content=(\n///     #|b\"\"\n///   ),\n/// )\n/// ```\npub fn Bytes::repeat(self : Self, count : Int) -> Bytes {\n  if count <= 0 || self.length() == 0 {\n    return []\n  }\n  if count == 1 {\n    return self\n  }\n  let len = self.length()\n  let total = len * count\n  // (Optional) detect overflow: if multiplication wrapped (best-effort)\n  guard total / count == len\n  let arr = FixedArray::make(total, (0 : Byte))\n  arr.blit_from_bytes(0, self, 0, len)\n  let mut filled = len\n  while filled < total {\n    let remaining = total - filled\n    let copy_len = if filled < remaining { filled } else { remaining }\n    let src = unsafe_to_bytes(arr)\n    arr.blit_from_bytes(filled, src, 0, copy_len)\n    filled = filled + copy_len\n  }\n  unsafe_to_bytes(arr)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n#coverage.skip\n#deprecated\n#doc(hidden)\npub fn[T : Compare] op_lt(self_ : T, other : T) -> Bool {\n  Compare::op_lt(self_, other)\n}\n\n///|\n#coverage.skip\n#deprecated\n#doc(hidden)\npub fn[T : Compare] op_gt(self_ : T, other : T) -> Bool {\n  Compare::op_gt(self_, other)\n}\n\n///|\n#coverage.skip\n#deprecated\n#doc(hidden)\npub fn[T : Compare] op_le(self_ : T, other : T) -> Bool {\n  Compare::op_le(self_, other)\n}\n\n///|\n#coverage.skip\n#deprecated\n#doc(hidden)\npub fn[T : Compare] op_ge(self_ : T, other : T) -> Bool {\n  Compare::op_ge(self_, other)\n}\n\n///|\n#coverage.skip\npub fn[T : Eq] op_notequal(x : T, y : T) -> Bool {\n  !(x == y)\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Evaluates an expression and discards its result. This is useful when you want\n/// to execute an expression for its side effects but don't care about its return\n/// value, or when you want to explicitly indicate that a value is intentionally\n/// unused.\n///\n/// Parameters:\n///\n/// * `value` : The value to be ignored. Can be of any type.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 42\n/// ignore(x) // Explicitly ignore the value\n/// let mut sum = 0\n/// ignore([1, 2, 3].iter().each(x => sum = sum + x)) // Ignore the Unit return value of each()\n/// ```\npub fn[T] ignore(t : T) -> Unit = \"%ignore\"\n\n///|\n/// Tests if two values are physically equal (i.e., point to the same memory\n/// location). Unlike structural equality testing (`==`), this function checks if\n/// two references point to exactly the same object in memory.\n///\n/// Parameters:\n///\n/// * `first` : The first value to compare.\n/// * `second` : The second value to compare.\n/// * `T` : The type parameter representing the type of values being compared.\n///\n/// Returns `true` if both values refer to the same object in memory, `false`\n/// otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr1 = [1, 2, 3]\n/// let arr2 = arr1\n/// let arr3 = [1, 2, 3]\n/// inspect(physical_equal(arr1, arr2), content=\"true\") // Same object\n/// inspect(physical_equal(arr1, arr3), content=\"false\") // Different objects with same content\n/// ```\npub fn[T] physical_equal(a : T, b : T) -> Bool = \"%refeq\"\n\n///|\n#callsite(autofill(loc))\npub fn[T] abort(string : String, loc~ : SourceLoc) -> T {\n  @abort.abort(\n    (\n      $|\\{string}\n      $|  at \\{loc}\n      $|\n    ),\n  )\n}\n\n///|\npub fn[T] panic() -> T = \"%panic\"\n\n// Bool primitive ops\n\n///|\n/// Performs logical negation on a boolean value.\n///\n/// Parameters:\n///\n/// * `value` : The boolean value to negate.\n///\n/// Returns the logical NOT of the input value: `true` if the input is `false`,\n/// and `false` if the input is `true`.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(not(true), content=\"false\")\n/// inspect(not(false), content=\"true\")\n/// ```\npub fn not(x : Bool) -> Bool = \"%bool_not\"\n\n///|\n/// Compares two boolean values for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare.\n///\n/// Returns `true` if both boolean values are equal (either both `true` or both\n/// `false`), `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(true == true, content=\"true\")\n/// inspect(false == true, content=\"false\")\n/// inspect(true == false, content=\"false\")\n/// inspect(false == false, content=\"true\")\n/// ```\npub impl Eq for Bool with equal(self : Bool, other : Bool) -> Bool = \"%bool_eq\"\n\n///|\n/// Compares two boolean values and returns their relative order. This is a\n/// deprecated method and users should use `compare` instead.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other` (i.e., `self` is `false`\n/// and `other` is `true`)\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other` (i.e., `self` is `true`\n/// and `other` is `false`)\n///\n/// Example:\n///\n/// ```mbt test\n/// let t = true\n/// let f = false\n/// // This usage is deprecated, use compare() instead\n/// inspect(t.compare(f), content=\"1\")\n/// inspect(f.compare(t), content=\"-1\")\n/// inspect(t.compare(t), content=\"0\")\n/// ```\n///\n#deprecated(\"Use `compare` instead\")\n#coverage.skip\npub fn Bool::op_compare(self : Bool, other : Bool) -> Int = \"%bool_compare\"\n\n///|\n/// Compares two boolean values and returns their relative order. The comparison\n/// follows the rule that `false` is less than `true`.\n///\n/// Parameters:\n///\n/// * `self` : The first boolean value to compare.\n/// * `other` : The second boolean value to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is `false` and `other` is `true`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is `true` and `other` is `false`\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(true.compare(false), content=\"1\") // true > false\n/// inspect(false.compare(true), content=\"-1\") // false < true\n/// inspect(true.compare(true), content=\"0\") // true = true\n/// ```\npub impl Compare for Bool with compare(self, other) = \"%bool_compare\"\n\n///|\n/// Returns the default value for the `Bool` type, which is `false`.\n///\n/// Returns a `Bool` value that represents the default state of a boolean value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let b : Bool = Bool::default()\n/// inspect(b, content=\"false\")\n/// ```\npub impl Default for Bool with default() = \"%bool_default\"\n\n// int32 primitive ops\n\n///|\n/// Performs arithmetic negation on an integer value, returning its additive\n/// inverse.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to negate.\n///\n/// Returns the negation of the input value. For all inputs except\n/// `Int::min_value()`, returns the value with opposite sign. When the input is\n/// `Int::min_value()`, returns `Int::min_value()` due to two's complement\n/// representation.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(-42, content=\"-42\")\n/// inspect(42, content=\"42\")\n/// inspect(2147483647, content=\"2147483647\") // negating near min value\n/// ```\npub impl Neg for Int with neg(self) = \"%i32_neg\"\n\n///|\n/// Adds two 32-bit signed integers. Performs two's complement arithmetic, which\n/// means the operation will wrap around if the result exceeds the range of a\n/// 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer that is the sum of the two operands. If the\n/// mathematical sum exceeds the range of a 32-bit integer (-2,147,483,648 to\n/// 2,147,483,647), the result wraps around according to two's complement rules.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(42 + 1, content=\"43\")\n/// inspect(2147483647 + 1, content=\"-2147483648\") // Overflow wraps around to minimum value\n/// ```\npub impl Add for Int with add(self, other) = \"%i32_add\"\n\n///|\n/// Performs subtraction between two 32-bit integers, following standard two's\n/// complement arithmetic rules. When the result overflows or underflows, it\n/// wraps around within the 32-bit integer range.\n///\n/// Parameters:\n///\n/// * `self` : The minuend (the number being subtracted from).\n/// * `other` : The subtrahend (the number to subtract).\n///\n/// Returns the difference between `self` and `other`.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 42\n/// let b = 10\n/// inspect(a - b, content=\"32\")\n/// let max = 2147483647 // Int maximum value\n/// inspect(max - -1, content=\"-2147483648\") // Overflow case\n/// ```\npub impl Sub for Int with sub(self, other) = \"%i32_sub\"\n\n///|\n/// Multiplies two 32-bit integers. This is the implementation of the `*`\n/// operator for `Int`.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns the product of the two integers. If the result overflows the range of\n/// `Int`, it wraps around according to two's complement arithmetic.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(42 * 2, content=\"84\")\n/// inspect(-10 * 3, content=\"-30\")\n/// let max = 2147483647 // Int.max_value\n/// inspect(max * 2, content=\"-2\") // Overflow wraps around\n/// ```\npub impl Mul for Int with mul(self, other) = \"%i32_mul\"\n\n///|\n/// Performs integer division between two 32-bit integers. The result is\n/// truncated towards zero (rounds down for positive numbers and up for negative\n/// numbers).\n///\n/// Parameters:\n///\n/// * `dividend` : The first integer operand to be divided.\n/// * `divisor` : The second integer operand that divides the dividend.\n///\n/// Returns the quotient of the division operation.\n///\n/// Throws a panic if `divisor` is zero.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(10 / 3, content=\"3\") // truncates towards zero\n/// inspect(-10 / 3, content=\"-3\")\n/// inspect(10 / -3, content=\"-3\")\n/// ```\npub impl Div for Int with div(self, other) = \"%i32_div\"\n\n///|\n/// Calculates the remainder of dividing one integer by another. The result\n/// follows the formula `dividend - (dividend / divisor) * divisor`, maintaining\n/// the same sign as the dividend.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number being divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns the remainder of the division. If `other` is 0, the behavior is\n/// undefined.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(7 % 3, content=\"1\")\n/// inspect(-7 % 3, content=\"-1\")\n/// inspect(7 % -3, content=\"1\")\n/// ```\npub impl Mod for Int with mod(self, other) = \"%i32_mod\"\n\n///|\n/// Performs a bitwise NOT operation on a 32-bit integer. Flips each bit in the\n/// integer's binary representation (0 becomes 1 and 1 becomes 0).\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit integer on which to perform the bitwise NOT operation.\n///\n/// Returns a new integer with all bits flipped from the input value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = -1 // All bits are 1\n/// let b = 0 // All bits are 0\n/// inspect(a.lnot(), content=\"0\")\n/// inspect(b.lnot(), content=\"-1\")\n/// ```\npub fn Int::lnot(self : Int) -> Int = \"%i32_lnot\"\n\n///|\n/// Performs a bitwise AND operation between two 32-bit integers. Each bit in the\n/// result is set to 1 only if the corresponding bits in both operands are 1.\n///\n/// Parameters:\n///\n/// * `self` : The first 32-bit integer operand.\n/// * `other` : The second 32-bit integer operand.\n///\n/// Returns the result of the bitwise AND operation. The resulting value has a\n/// bit set to 1 at each position where both input integers have a bit set to 1.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xF0 // 11110000\n/// let y = 0xAA // 10101010\n/// inspect(x & y, content=\"160\") // 10100000 = 160\n/// ```\npub impl BitAnd for Int with land(self : Int, other : Int) -> Int = \"%i32_land\"\n\n///|\n/// Performs a bitwise OR operation between two 32-bit integers. For each bit\n/// position, the result is 1 if at least one of the corresponding bits in either\n/// operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if at least one of the\n/// corresponding bits in either operand is 1, and 0 otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xF0F0 // 1111_0000_1111_0000\n/// let y = 0x0F0F // 0000_1111_0000_1111\n/// inspect(x | y, content=\"65535\") // 1111_1111_1111_1111 = 65535\n/// ```\npub impl BitOr for Int with lor(self : Int, other : Int) -> Int = \"%i32_lor\"\n\n///|\n/// Performs a bitwise XOR operation between two integers.\n///\n/// Parameters:\n///\n/// * `self` : The first integer operand.\n/// * `other` : The second integer operand.\n///\n/// Returns a new integer where each bit is set to 1 if the corresponding bits in\n/// the operands are different, and 0 if they are the same.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xF0F0 // 1111_0000_1111_0000\n/// let y = 0x0F0F // 0000_1111_0000_1111\n/// inspect(x ^ y, content=\"65535\") // 1111_1111_1111_1111\n/// inspect(x ^ x, content=\"0\") // XOR with self gives 0\n/// ```\npub impl BitXOr for Int with lxor(self : Int, other : Int) -> Int = \"%i32_lxor\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the\n/// rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift. Must be a non-negative value\n/// less than 32. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new integer with bits shifted left by the specified number of\n/// positions. For each position shifted, the rightmost bit is filled with 0, and\n/// the leftmost bit is discarded.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 1\n/// inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// let y = -4\n/// inspect(y << 2, content=\"-16\") // Binary: 100 -> 10000\n/// ```\npub impl Shl for Int with shl(self, other) = \"%i32_shl\"\n\n///|\n/// Performs an arithmetic right shift operation on an integer value. Shifts the\n/// bits of the first operand to the right by the number of positions specified\n/// by the second operand. The sign bit is preserved and copied to the leftmost\n/// positions.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the right. Must be\n/// non-negative.\n///\n/// Returns an integer representing the result of the arithmetic right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = -16\n/// inspect(n >> 2, content=\"-4\") // Sign bit is preserved during shift\n/// let p = 16\n/// inspect(p >> 2, content=\"4\") // Regular right shift for positive numbers\n/// ```\npub impl Shr for Int with shr(self, other) = \"%i32_shr\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts each bit in the\n/// integer to the left by the specified number of positions, filling the vacated\n/// bit positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift the bits to the left.\n///\n/// Returns an integer containing the result of shifting `self` left by `shift`\n/// positions.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 1\n/// inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// let y = 42\n/// inspect(y << 2, content=\"168\") // Binary: 101010 -> 10101000\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::lsl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a left shift operation on a 32-bit integer. Shifts the bits of the\n/// first operand to the left by the specified number of positions. The rightmost\n/// positions are filled with zeros.\n///\n/// Parameters:\n///\n/// * `value` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift left. Must be non-negative and\n/// less than 32.\n///\n/// Returns a new integer value after performing the left shift operation. The\n/// value is equal to multiplying the input by 2 raised to the power of the shift\n/// count.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 1\n/// inspect(x << 3, content=\"8\") // Equivalent to x << 3\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn Int::shl(self : Int, other : Int) -> Int = \"%i32_shl\"\n\n///|\n/// Performs a logical right shift operation on a signed 32-bit integer. In a\n/// logical right shift, zeros are shifted in from the left, regardless of the\n/// sign bit. This function is DEPRECATED and users should use `UInt` type with\n/// the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The signed 32-bit integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a signed 32-bit integer containing the same bits as if the input were\n/// treated as an unsigned integer and shifted right logically.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = -4 // Binary: 11111...11100\n/// let unsigned = x.reinterpret_as_uint() // Convert to UInt first\n/// inspect(unsigned >> 1, content=\"2147483646\") // Using the recommended operator\n/// ```\n///\n#deprecated(\"Use UInt type and infix operator `>>` instead\")\n#coverage.skip\npub fn Int::lsr(self : Int, other : Int) -> Int {\n  (self.reinterpret_as_uint() >> other).reinterpret_as_int()\n}\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer value,\n/// preserving the sign bit by replicating it into the positions vacated by the\n/// shift. This is a deprecated function; use the infix operator `>>` instead.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new integer value that is the result of arithmetically shifting\n/// `self` right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = -16\n/// inspect(x >> 2, content=\"-4\") // Right shift preserves sign bit\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::asr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Performs an arithmetic right shift operation on a 32-bit integer by the\n/// specified number of positions. The operation preserves the sign bit,\n/// replicating it into the positions vacated by the shift.\n///\n/// Parameters:\n///\n/// * `self` : The integer value to be shifted.\n/// * `shift` : The number of positions to shift right.\n///\n/// Returns a new integer representing the result of shifting `self` right by\n/// `shift` positions.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = -1024\n/// inspect(n >> 3, content=\"-128\") // Preserves sign bit during right shift\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn Int::shr(self : Int, other : Int) -> Int = \"%i32_shr\"\n\n///|\n/// Counts the number of consecutive zero bits at the least significant end of\n/// the integer's binary representation.\n///\n/// Parameters:\n///\n/// * `self` : The integer value whose trailing zeros are to be counted.\n///\n/// Returns the number of trailing zero bits (0 to 32). For example, returns 0 if\n/// the value is odd (least significant bit is 1), returns 32 if the value is 0\n/// (all bits are zeros).\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0\n/// inspect(x.ctz(), content=\"32\") // All bits are zero\n/// let y = 1\n/// inspect(y.ctz(), content=\"0\") // No trailing zeros\n/// let z = 16\n/// inspect(z.ctz(), content=\"4\") // Binary: ...10000\n/// ```\npub fn Int::ctz(self : Int) -> Int = \"%i32_ctz\"\n\n///|\npub fn Int::clz(self : Int) -> Int = \"%i32_clz\"\n\n///|\n/// Counts the number of set bits (1s) in the binary representation of a 32-bit\n/// integer.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer whose bits are to be counted.\n///\n/// Returns the number of bits set to 1 in the binary representation of the input\n/// integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0b1011 // Binary: 1011 (3 bits set)\n/// inspect(x.popcnt(), content=\"3\")\n/// let y = -1 // All bits set in two's complement\n/// inspect(y.popcnt(), content=\"32\")\n/// ```\npub fn Int::popcnt(self : Int) -> Int = \"%i32_popcnt\"\n\n///|\n/// Compares two integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(42 == 42, content=\"true\")\n/// inspect(42 == -42, content=\"false\")\n/// ```\npub impl Eq for Int with equal(self : Int, other : Int) -> Bool = \"%i32_eq\"\n\n///|\n/// Compares two integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first integer to compare.\n/// * `other` : The second integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 42\n/// let b = 24\n/// inspect(a.compare(b), content=\"1\") // 42 > 24\n/// inspect(b.compare(a), content=\"-1\") // 24 < 42\n/// inspect(a.compare(a), content=\"0\") // 42 = 42\n/// ```\npub impl Compare for Int with compare(self, other) = \"%i32_compare\"\n\n///|\npub impl Compare for Int with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Int with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Int with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Int with op_ge(x, y) = \"%i32.ge\"\n\n///|\npub fn Int::is_pos(self : Int) -> Bool = \"%i32_is_pos\"\n\n///|\n/// Tests whether an integer is negative.\n///\n/// Parameters:\n///\n/// * `self` : The integer to test.\n///\n/// Returns `true` if the integer is negative, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let neg = -42\n/// let zero = 0\n/// let pos = 42\n/// inspect(neg.is_neg(), content=\"true\")\n/// inspect(zero.is_neg(), content=\"false\")\n/// inspect(pos.is_neg(), content=\"false\")\n/// ```\npub fn Int::is_neg(self : Int) -> Bool = \"%i32_is_neg\"\n\n///|\npub fn Int::is_non_pos(self : Int) -> Bool = \"%i32_is_non_pos\"\n\n///|\npub fn Int::is_non_neg(self : Int) -> Bool = \"%i32_is_non_neg\"\n\n///|\n/// Returns the default value for integers, which is 0.\n///\n/// Returns an integer value of 0.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x : Int = Int::default()\n/// inspect(x, content=\"0\")\n/// ```\npub impl Default for Int with default() = \"%i32_default\"\n\n///|\n/// Converts a 32-bit integer to a double-precision floating-point number. The\n/// conversion preserves the exact value since all integers in the range of `Int`\n/// can be represented exactly as `Double` values.\n///\n/// Parameters:\n///\n/// * `self` : The 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that represents the same\n/// numerical value as the input integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 42\n/// inspect(n.to_double(), content=\"42\")\n/// let neg = -42\n/// inspect(neg.to_double(), content=\"-42\")\n/// ```\npub fn Int::to_double(self : Int) -> Double = \"%i32_to_f64\"\n\n///|\n/// Converts a double-precision floating-point number to an unsigned 32-bit\n/// integer by truncating the decimal part. When the input is NaN or negative,\n/// returns 0. When the input exceeds the maximum value of UInt (4294967295),\n/// returns 4294967295.\n///\n/// Parameters:\n///\n/// * `value` : The double-precision floating-point number to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the truncated value.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(UInt::trunc_double(42.75), content=\"42\")\n/// ```\npub fn UInt::trunc_double(val : Double) -> UInt = \"%f64.to_u32\"\n\n///|\n/// reinterpret the signed int as unsigned int, when the value is\n/// non-negative, i.e, 0..=2^31-1, the value is the same. When the\n/// value is negative, it turns into a large number,\n/// for example, -1 turns into 2^32-1\npub fn Int::reinterpret_as_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n\n///|\n/// Reinterprets a signed 32-bit integer as an unsigned 32-bit integer. For\n/// numbers within the range \\[0, 2^31-1], the value remains the same. For\n/// negative numbers, they are reinterpreted as large positive numbers in the\n/// range \\[2^31, 2^32-1].\n///\n/// Parameters:\n///\n/// * `value` : The signed 32-bit integer to be reinterpreted.\n///\n/// Returns an unsigned 32-bit integer that has the same bit pattern as the\n/// input.\n///\n/// Example:\n///\n/// ```mbt test\n/// let pos = 42\n/// let neg = -1\n/// inspect(pos.reinterpret_as_uint(), content=\"42\")\n/// inspect(neg.reinterpret_as_uint(), content=\"4294967295\") // 2^32 - 1\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_uint` instead\")\n#coverage.skip\npub fn Int::to_uint(self : Int) -> UInt = \"%i32.to_u32_reinterpret\"\n// Double primitive ops\n\n///|\n/// Converts a 32-bit signed integer to an unsigned 64-bit integer by first\n/// converting it to a signed 64-bit integer and then reinterpreting the bits as\n/// an unsigned value.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted.\n///\n/// Returns an unsigned 64-bit integer representing the same bit pattern as the\n/// input value when extended to 64 bits.\n///\n/// Example:\n///\n/// ```mbt test\n/// let pos = 42\n/// inspect(pos.to_uint64(), content=\"42\")\n/// let neg = -1\n/// inspect(neg.to_uint64(), content=\"18446744073709551615\") // 2^64 - 1\n/// ```\npub fn Int::to_uint64(self : Int) -> UInt64 {\n  self.to_int64().reinterpret_as_uint64()\n}\n\n///|\n/// Negates a double-precision floating-point number. For non-NaN inputs, changes\n/// the sign of the number. For NaN inputs, returns NaN.\n///\n/// Parameters:\n///\n/// * `number` : The double-precision floating-point number to negate.\n///\n/// Returns a new double-precision floating-point number that is the negation of\n/// the input number.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(-42.0, content=\"-42\")\n/// inspect(42.0, content=\"42\")\n/// inspect(-(0.0 / 0.0), content=\"NaN\") // Negating NaN returns NaN\n/// ```\npub impl Neg for Double with neg(self) = \"%f64_neg\"\n\n///|\n/// Adds two double-precision floating-point numbers together following IEEE 754\n/// standards.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number.\n/// * `other` : The second double-precision floating-point number to add.\n///\n/// Returns the sum of the two numbers. Special cases follow IEEE 754 rules:\n///\n/// * If either operand is NaN, returns NaN\n/// * If adding +âˆ and -âˆ, returns NaN\n/// * If adding Â±âˆ with any finite number, returns Â±âˆ\n/// * If adding +0.0 and -0.0, returns +0.0\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(2.5 + 3.7, content=\"6.2\")\n/// inspect(1.0 / 0.0 + -1.0 / 0.0, content=\"NaN\") // Infinity + -Infinity = NaN\n/// ```\npub impl Add for Double with add(self, other) = \"%f64_add\"\n\n///|\n/// Performs subtraction between two double-precision floating-point numbers.\n///\n/// Parameters:\n///\n/// * `self` : The first operand (minuend).\n/// * `other` : The second operand (subtrahend).\n///\n/// Returns the difference between the two numbers according to IEEE 754\n/// double-precision arithmetic rules.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 5.0\n/// let b = 3.0\n/// inspect(a - b, content=\"2\")\n/// inspect(0.0 / 0.0 - 1.0, content=\"NaN\") // NaN - anything = NaN\n/// ```\npub impl Sub for Double with sub(self, other) = \"%f64_sub\"\n\n///|\n/// Multiplies two double-precision floating-point numbers. This is the\n/// implementation of the `*` operator for `Double` type.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point operand.\n/// * `other` : The second double-precision floating-point operand.\n///\n/// Returns a new double-precision floating-point number representing the product\n/// of the two operands. Special cases follow IEEE 754 standard:\n///\n/// * If either operand is NaN, returns NaN\n/// * If one operand is infinity and the other is zero, returns NaN\n/// * If one operand is infinity and the other is a non-zero finite number,\n/// returns infinity with the appropriate sign\n/// * If both operands are infinity, returns infinity with the appropriate sign\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(2.5 * 2.0, content=\"5\")\n/// inspect(-2.0 * 3.0, content=\"-6\")\n/// let nan = 0.0 / 0.0 // NaN\n/// inspect(nan * 1.0, content=\"NaN\")\n/// ```\npub impl Mul for Double with mul(self, other) = \"%f64_mul\"\n\n///|\n/// Performs division between two double-precision floating-point numbers.\n/// Follows IEEE 754 standard for floating-point arithmetic, including handling\n/// of special cases like division by zero (returns infinity) and operations\n/// involving NaN.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (numerator) in the division operation.\n/// * `other` : The divisor (denominator) in the division operation.\n///\n/// Returns the result of dividing `self` by `other`. Special cases follow IEEE\n/// 754:\n///\n/// * Division by zero returns positive or negative infinity based on the\n/// dividend's sign\n/// * Operations involving NaN return NaN\n/// * Division of infinity by infinity returns NaN\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(6.0 / 2.0, content=\"3\")\n/// inspect(-6.0 / 2.0, content=\"-3\")\n/// inspect(1.0 / 0.0, content=\"Infinity\")\n/// ```\npub impl Div for Double with div(self, other) = \"%f64_div\"\n\n///|\n/// Calculates the square root of a double-precision floating-point number. For\n/// non-negative numbers, returns the positive square root. For negative numbers\n/// or NaN, returns NaN.\n///\n/// Parameters:\n///\n/// * `self` : The double-precision floating-point number whose square root is to\n/// be calculated.\n///\n/// Returns the square root of the input number, or NaN if the input is negative\n/// or NaN.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(4.0.sqrt(), content=\"2\")\n/// inspect(0.0.sqrt(), content=\"0\")\n/// inspect((-1.0).sqrt(), content=\"NaN\")\n/// ```\npub fn Double::sqrt(self : Double) -> Double = \"%f64_sqrt\"\n\n///|\n/// Compares two double-precision floating-point numbers for equality following\n/// IEEE 754 rules. Returns `true` if both numbers are equal, including when both\n/// are `NaN`. Note that this differs from the standard IEEE 754 behavior where\n/// `NaN` is not equal to any value, including itself.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare.\n///\n/// Returns `true` if both numbers are equal, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 3.14\n/// let b = 3.14\n/// let c = 2.718\n/// inspect(a == b, content=\"true\")\n/// inspect(a == c, content=\"false\")\n/// let nan = 0.0 / 0.0 // NaN\n/// inspect(nan == nan, content=\"false\") // NaN != NaN\n/// ```\npub impl Eq for Double with equal(self : Double, other : Double) -> Bool = \"%f64_eq\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn Double::op_neq(self : Double, other : Double) -> Bool = \"%f64_ne\"\n\n///|\n/// Compares two double-precision floating-point numbers and returns their\n/// relative order. Follows IEEE 754 rules for floating-point comparisons,\n/// including handling of special values like NaN.\n///\n/// Parameters:\n///\n/// * `self` : The first double-precision floating-point number to compare.\n/// * `other` : The second double-precision floating-point number to compare\n/// against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n/// * If either value is NaN, returns an implementation-defined value that is\n/// consistent with total ordering\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 3.14\n/// let b = 2.718\n/// inspect(a.compare(b), content=\"1\") // 3.14 > 2.718\n/// inspect(b.compare(a), content=\"-1\") // 2.718 < 3.14\n/// inspect(a.compare(a), content=\"0\") // 3.14 = 3.14\n/// ```\npub impl Compare for Double with compare(self, other) = \"%f64_compare\"\n\n///|\npub impl Compare for Double with op_lt(x, y) = \"%f64.lt\"\n\n///|\npub impl Compare for Double with op_le(x, y) = \"%f64.le\"\n\n///|\npub impl Compare for Double with op_gt(x, y) = \"%f64.gt\"\n\n///|\npub impl Compare for Double with op_ge(x, y) = \"%f64.ge\"\n\n///|\n/// Returns the default value for double-precision floating-point numbers (0.0).\n///\n/// Returns a `Double` value initialized to 0.0.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(Double::default(), content=\"0\")\n/// ```\npub impl Default for Double with default() = \"%f64_default\"\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 42U\n/// inspect(Double::convert_uint(n), content=\"42\")\n/// let max = 4294967295U // maximum value of UInt\n/// inspect(Double::convert_uint(max), content=\"4294967295\")\n/// ```\npub fn Double::convert_uint(val : UInt) -> Double = \"%u32.to_f64\"\n\n// Char primitive ops\n\n///|\n/// Converts a character to its Unicode code point value as an integer.\n///\n/// Parameters:\n///\n/// * `self` : The character to be converted.\n///\n/// Returns an integer representing the Unicode code point value of the\n/// character.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect('A'.to_int(), content=\"65\") // ASCII value of 'A'\n/// inspect('ã‚'.to_int(), content=\"12354\") // Unicode code point of 'ã‚'\n/// ```\npub fn Char::to_int(self : Char) -> Int = \"%char_to_int\"\n\n///|\n/// Converts a Unicode character to its unsigned 32-bit integer code point\n/// representation. The character's code point value is first converted to a\n/// signed integer and then reinterpreted as an unsigned integer.\n///\n/// Parameters:\n///\n/// * `character` : The Unicode character to be converted.\n///\n/// Returns an unsigned 32-bit integer representing the character's Unicode code\n/// point.\n///\n/// Example:\n///\n/// ```mbt test\n/// let c = 'A'\n/// inspect(c.to_uint(), content=\"65\") // ASCII value of 'A'\n/// let emoji = 'ğŸ¤£'\n/// inspect(emoji.to_uint(), content=\"129315\") // Unicode code point U+1F923\n/// ```\npub fn Char::to_uint(self : Char) -> UInt {\n  self.to_int().reinterpret_as_uint()\n}\n\n///|\n#deprecated(\"Use `Int::unsafe_to_char` instead, and use `Int::to_char` for safe conversion\")\npub fn Char::from_int(val : Int) -> Char = \"%char_from_int\"\n\n///|\n/// Compares two characters for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare.\n///\n/// Returns `true` if both characters represent the same Unicode code point,\n/// `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 'A'\n/// let b = 'A'\n/// let c = 'B'\n/// inspect(a == b, content=\"true\")\n/// inspect(a == c, content=\"false\")\n/// ```\npub impl Eq for Char with equal(self : Char, other : Char) -> Bool = \"%char_eq\"\n\n///|\n/// Compares two characters based on their Unicode code points. Returns a\n/// negative value if the first character comes before the second, zero if they\n/// are equal, and a positive value if the first character comes after the\n/// second.\n///\n/// Parameters:\n///\n/// * `self` : The first character to compare.\n/// * `other` : The second character to compare against.\n///\n/// Returns an integer indicating the relative ordering:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect('a'.compare('b'), content=\"-1\")\n/// inspect('b'.compare('a'), content=\"1\")\n/// inspect('a'.compare('a'), content=\"0\")\n/// ```\npub impl Compare for Char with compare(self, other) = \"%char_compare\"\n\n///|\npub impl Compare for Char with op_lt(x, y) = \"%i32.lt\"\n\n///|\npub impl Compare for Char with op_le(x, y) = \"%i32.le\"\n\n///|\npub impl Compare for Char with op_gt(x, y) = \"%i32.gt\"\n\n///|\npub impl Compare for Char with op_ge(x, y) = \"%i32.ge\"\n\n///|\n/// Returns the default value for the `Char` type, which is the null character\n/// (`'\\x00'`).\n///\n/// Returns a `Char` value representing the null character.\n///\n/// Example:\n///\n/// ```mbt test\n/// assert_true(Char::default().to_string() == \"\\u0000\")\n/// ```\npub impl Default for Char with default() = \"%char_default\"\n\n// Bytes primitive ops\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to access.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a byte value from the specified position in the sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = b\"\\x01\\x02\\x03\"\n/// inspect(bytes[1], content=\"b'\\\\x02'\")\n/// ```\n#alias(\"_[_]\")\npub fn Bytes::at(self : Bytes, idx : Int) -> Byte = \"%bytes_get\"\n\n///|\n/// Retrieves a byte at the specified index from a byte sequence without\n/// performing bounds checking. This is a low-level operation that should be used\n/// with caution.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence to retrieve the byte from.\n/// * `index` : The position in the byte sequence from which to retrieve the\n/// byte.\n///\n/// Returns a single byte from the specified position in the byte sequence.\n///\n/// Throws a panic if the index is negative or greater than or equal to the\n/// length of the byte sequence.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = b\"\\x01\\x02\\x03\"\n/// inspect(bytes.unsafe_get(1), content=\"b'\\\\x02'\")\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn Bytes::unsafe_get(self : Bytes, idx : Int) -> Byte = \"%bytes.unsafe_get\"\n\n///|\n/// Returns the number of bytes in a byte sequence.\n///\n/// Parameters:\n///\n/// * `bytes` : The byte sequence whose length is to be determined.\n///\n/// Returns an integer representing the length (number of bytes) of the sequence.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = b\"\\x01\\x02\\x03\"\n/// inspect(bytes.length(), content=\"3\")\n/// let empty = b\"\"\n/// inspect(empty.length(), content=\"0\")\n/// ```\npub fn Bytes::length(self : Bytes) -> Int = \"%bytes_length\"\n\n///|\n/// Creates a new byte sequence of the specified length, where each byte is\n/// initialized to the given value. Returns an empty byte sequence if the\n/// length is negative.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be non-negative.\n/// * `initial_value` : The byte value used to initialize each position in the\n/// sequence.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = Bytes::make(3, b'\\xFF')\n/// inspect(\n///   bytes,\n///   content=(\n///     #|b\"\\xff\\xff\\xff\"\n///   ),\n/// )\n/// let empty = Bytes::make(0, b'\\x00')\n/// inspect(empty, content=\"b\\\"\\\"\")\n/// ```\npub fn Bytes::make(len : Int, init : Byte) -> Bytes {\n  if len < 0 {\n    return []\n  }\n  Bytes::unsafe_make(len, init)\n}\n\n///|\nfn Bytes::unsafe_make(len : Int, init : Byte) -> Bytes = \"%bytes_make\"\n\n///|\n/// Creates a new byte sequence filled with zero bytes.\n///\n/// Parameters:\n///\n/// * `length` : The length of the byte sequence to create. Must be a\n/// non-negative integer.\n///\n/// Returns a new byte sequence of the specified length, with all bytes\n/// initialized to zero.\n///\n/// Example:\n///\n/// ```mbt test\n/// let bytes = Bytes::new(3)\n/// inspect(bytes, content=\"b\\\"\\\\x00\\\\x00\\\\x00\\\"\")\n/// let bytes = Bytes::new(0)\n/// inspect(bytes, content=\"b\\\"\\\"\")\n/// ```\npub fn Bytes::new(len : Int) -> Bytes {\n  Bytes::make(len, b'\\x00')\n}\n\n///|\n/// Converts a 32-bit signed integer to a byte by taking its least significant 8\n/// bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `value` : The 32-bit signed integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 258 // In binary: 100000010\n/// inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// let neg = -1 // In binary: all 1's\n/// inspect(neg.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// ```\npub fn Int::to_byte(self : Int) -> Byte = \"%i32_to_byte\"\n\n///|\npub fn Int::unsafe_to_char(self : Int) -> Char = \"%char_from_int\"\n\n///|\npub fn Int::to_char(self : Int) -> Char? {\n  if self is (0..=0xD7FF) || self is (0xE000..=0x10FFFF) {\n    Some(self.unsafe_to_char())\n  } else {\n    None\n  }\n}\n\n///|\n/// Converts an unsigned 64-bit integer to a byte by truncating it to fit within\n/// the byte range (0 to 255).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 64-bit integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 258UL // In binary: 100000010\n/// inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// ```\npub fn UInt64::to_byte(self : UInt64) -> Byte {\n  self.to_int().to_byte()\n}\n\n// FixedArray primitive ops\n\n///|\n/// Retrieves an element at the specified index from a fixed-size array. This\n/// function implements the array indexing operator `[]`.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to access.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index.\n///\n/// Panics if the index is out of bounds.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = FixedArray::make(3, 42)\n/// inspect(arr[1], content=\"42\")\n/// ```\n#alias(\"_[_]\")\npub fn[T] FixedArray::at(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.get\"\n\n///|\n/// Retrieves an element from a fixed-size array at the specified index without\n/// performing bounds checking. This is an unsafe operation that may cause\n/// undefined behavior if used incorrectly.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to retrieve the element from.\n/// * `index` : The position in the array from which to retrieve the element.\n///\n/// Returns the element at the specified index in the array.\n///\n/// Throws a panic if the index is out of bounds (negative or greater than or\n/// equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = FixedArray::make(3, 42)\n/// inspect(arr.unsafe_get(1), content=\"42\")\n/// ```\n///\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_get(self : FixedArray[T], idx : Int) -> T = \"%fixedarray.unsafe_get\"\n\n///|\n#internal(unsafe, \"Panic if index is out of bounds\")\n#doc(hidden)\npub fn[T] FixedArray::unsafe_set(\n  self : FixedArray[T],\n  idx : Int,\n  val : T,\n) -> Unit = \"%fixedarray.unsafe_set\"\n\n///|\n/// Sets the value at the specified index in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array to be modified.\n/// * `index` : The index at which to set the value. Must be non-negative and\n/// less than the array's length.\n/// * `value` : The value to be set at the specified index.\n///\n/// Throws a runtime error if the index is out of bounds (less than 0 or greater\n/// than or equal to the array's length).\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = FixedArray::make(3, 0)\n/// arr.set(1, 42)\n/// inspect(arr[1], content=\"42\")\n/// ```\n#alias(\"_[_]=_\")\npub fn[T] FixedArray::set(self : FixedArray[T], idx : Int, val : T) -> Unit = \"%fixedarray.set\"\n\n///|\n/// Returns the number of elements in a fixed-size array.\n///\n/// Parameters:\n///\n/// * `array` : The fixed-size array whose length is to be determined.\n///\n/// Returns an integer representing the number of elements in the array.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = FixedArray::make(3, 42)\n/// inspect(arr.length(), content=\"3\")\n/// ```\npub fn[T] FixedArray::length(self : FixedArray[T]) -> Int = \"%fixedarray.length\"\n\n///|\n/// Creates a new fixed-size array with the specified length, initializing all\n/// elements with the given value.\n///\n/// Parameters:\n///\n/// * `length` : The length of the array to create. Must be non-negative.\n/// * `initial_value` : The value used to initialize all elements in the array.\n///\n/// Returns a new fixed-size array of type `FixedArray[T]` with `length`\n/// elements, where each element is initialized to `initial_value`.\n///\n/// Throws a panic if `length` is negative.\n///\n/// Example:\n///\n/// ```mbt test\n/// let arr = FixedArray::make(3, 42)\n/// inspect(arr[0], content=\"42\")\n/// inspect(arr.length(), content=\"3\")\n/// ```\n/// \n/// WARNING: A common pitfall is creating with the same initial value, for example:\n/// ```mbt test\n/// let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))\n/// two_dimension_array[0][5] = 10\n/// assert_eq(two_dimension_array[5][5], 10)\n/// ```\n/// This is because all the cells reference to the same object (the FixedArray[Int] in this case). \n/// One should use makei() instead which creates an object for each index.\npub fn[T] FixedArray::make(len : Int, init : T) -> FixedArray[T] = \"%fixedarray.make\"\n\n// String primitive ops\n\n///|\n/// Returns the number of UTF-16 code units in the string. Note that this is not\n/// necessarily equal to the number of Unicode characters (code points) in the\n/// string, as some characters may be represented by multiple UTF-16 code units.\n///\n/// Parameters:\n///\n/// * `string` : The string whose length is to be determined.\n///\n/// Returns the number of UTF-16 code units in the string.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(\"hello\".length(), content=\"5\")\n/// inspect(\"ğŸ¤£\".length(), content=\"2\") // Emoji uses two UTF-16 code units\n/// inspect(\"\".length(), content=\"0\") // Empty string\n/// ```\n#alias(charcode_length, deprecated)\npub fn String::length(self : String) -> Int = \"%string_length\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n///\n/// Parameters:\n///\n/// * `string` : The string to access.\n/// * `index` : The position in the string from which to retrieve the code unit.\n///\n/// This method has O(1) complexity.\n#deprecated(\"Use `_[_]` instead which returns UInt16\")\npub fn String::charcode_at(self : String, idx : Int) -> Int = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at the given index.\n/// \n/// This method has O(1) complexity.\n#alias(\"_[_]\")\n#alias(code_unit_at)\npub fn String::at(self : String, idx : Int) -> UInt16 = \"%string_get\"\n\n///|\n/// Returns the UTF-16 code unit at a given position in the string without\n/// performing bounds checking. This is a low-level function that provides direct\n/// access to the internal representation of the string.\n///\n/// Parameters:\n///\n/// * `string` : The string from which to retrieve the code unit.\n/// * `index` : The position of the code unit to retrieve.\n///\n/// Returns the UTF-16 code unit at the specified position as an integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let str = \"BğŸ¤£ğŸ¤£C\"\n/// inspect(str.unsafe_charcode_at(0), content=\"66\") // 'B'\n/// inspect(str.unsafe_charcode_at(1), content=\"55358\") // First surrogate of ğŸ¤£\n/// inspect(str.unsafe_charcode_at(2), content=\"56611\") // Second surrogate of ğŸ¤£\n/// inspect(str.unsafe_charcode_at(3), content=\"55358\") // First surrogate of ğŸ¤£\n/// inspect(str.unsafe_charcode_at(4), content=\"56611\") // Second surrogate of ğŸ¤£\n/// inspect(str.unsafe_charcode_at(5), content=\"67\") // 'C'\n/// ```\n/// TODO: rename to `unsafe_get`\n#internal(unsafe, \"Panic if index is out of bounds.\")\n#doc(hidden)\npub fn String::unsafe_charcode_at(self : String, idx : Int) -> Int = \"%string.unsafe_get\"\n\n///|\n/// Concatenates two strings, creating a new string that contains all characters\n/// from the first string followed by all characters from the second string.\n///\n/// Parameters:\n///\n/// * `self` : The first string to concatenate.\n/// * `other` : The second string to concatenate.\n///\n/// Returns a new string containing the concatenation of both input strings.\n///\n/// Example:\n///\n/// ```mbt test\n/// let hello = \"Hello\"\n/// let world = \" World!\"\n/// inspect(hello + world, content=\"Hello World!\")\n/// inspect(\"\" + \"abc\", content=\"abc\") // concatenating with empty string\n/// ```\npub impl Add for String with add(self, other) = \"%string_add\"\n\n///|\n/// Tests whether two strings are equal by comparing their characters.\n///\n/// Parameters:\n///\n/// * `self` : The first string to compare.\n/// * `other` : The second string to compare.\n///\n/// Returns `true` if both strings contain exactly the same sequence of\n/// characters, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let str1 = \"hello\"\n/// let str2 = \"hello\"\n/// let str3 = \"world\"\n/// inspect(str1 == str2, content=\"true\")\n/// inspect(str1 == str3, content=\"false\")\n/// ```\npub impl Eq for String with equal(self : String, other : String) -> Bool = \"%string_eq\"\n\n///|\n/// Returns the string itself without any modifications. This method is primarily\n/// used to implement the `Show` trait, which requires a `to_string` function.\n///\n/// Parameters:\n///\n/// * `string` : The string value to be returned.\n///\n/// Returns the same string that was passed in.\n///\n/// Example:\n///\n/// ```mbt test\n/// let s = \"hello\"\n/// inspect(s.to_string(), content=\"hello\")\n/// ```\npub fn String::to_string(self : String) -> String = \"%string_to_string\"\n\n// For internal use only\n\n///|\npriv type UnsafeMaybeUninit[_]\n\n///|\n/// Converts a byte value to a 32-bit signed integer. The resulting integer will\n/// have the same binary representation as the byte value, preserving the\n/// numerical value in the range \\[0, 255].\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an integer.\n///\n/// Returns a 32-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt test\n/// let b = b'\\xFF' // byte with value 255\n/// inspect(b.to_int(), content=\"255\")\n/// let zero = b'\\x00'\n/// inspect(zero.to_int(), content=\"0\")\n/// ```\npub fn Byte::to_int(self : Byte) -> Int = \"%byte_to_int\"\n\n///|\n/// Converts a byte value to a character.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns the character corresponding to the byte value.\npub fn Byte::to_char(self : Byte) -> Char {\n  self.to_int().unsafe_to_char()\n}\n\n///|\n/// Converts a byte value to a 64-bit signed integer by first converting it to a\n/// 32-bit integer and then extending it to a 64-bit integer.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 64-bit signed integer representing the same numerical value as the\n/// input byte.\n///\n/// Example:\n///\n/// ```mbt test\n/// let b = b'\\xFF'\n/// inspect(b.to_int64(), content=\"255\")\n/// ```\npub fn Byte::to_int64(self : Byte) -> Int64 {\n  self.to_int().to_int64()\n}\n\n///|\n/// reinterpret the unsigned int as signed int\n/// For number within the range of 0..=2^31-1,\n/// the value is the same. For number within the range of 2^31..=2^32-1,\n/// the value is negative\npub fn UInt::reinterpret_as_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Reinterprets an unsigned 32-bit integer as a signed 32-bit integer. For\n/// values within the range of 0 to 2^31-1, the value remains the same. For\n/// values within the range of 2^31 to 2^32-1, the value becomes negative due to\n/// two's complement representation.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be reinterpreted.\n///\n/// Returns a signed 32-bit integer that has the same bit pattern as the input\n/// unsigned integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 42U\n/// inspect(a.reinterpret_as_int(), content=\"42\")\n/// let b = 4294967295U // maximum value of UInt (2^32 - 1)\n/// inspect(b.reinterpret_as_int(), content=\"-1\") // becomes -1 when reinterpreted as Int\n/// ```\n///\n#deprecated(\"Use `reinterpret_as_int` instead\")\n#coverage.skip\npub fn UInt::to_int(self : UInt) -> Int = \"%u32.to_i32_reinterpret\"\n\n///|\n/// Performs addition between two unsigned 32-bit integers. If the result\n/// overflows, it wraps around according to the rules of modular arithmetic\n/// (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand to be added.\n///\n/// Returns the sum of the two unsigned integers, wrapped around if necessary.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 42U\n/// let b = 100U\n/// inspect(a + b, content=\"142\")\n///\n/// // Demonstrate overflow behavior\n/// let max = 4294967295U // UInt::max_value\n/// inspect(max + 1U, content=\"0\")\n/// ```\npub impl Add for UInt with add(self, other) = \"%u32.add\"\n\n///|\n/// Performs subtraction between two unsigned 32-bit integers. When the result\n/// would be negative, the function wraps around using modular arithmetic (2^32).\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer (minuend).\n/// * `other` : The second unsigned 32-bit integer to subtract from the first\n/// (subtrahend).\n///\n/// Returns a new unsigned 32-bit integer representing the difference between the\n/// two numbers. If the result would be negative, it wraps around to a positive\n/// number by adding 2^32 repeatedly until the result is in range.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 5U\n/// let b = 3U\n/// inspect(a - b, content=\"2\")\n/// let c = 3U\n/// let d = 5U\n/// inspect(c - d, content=\"4294967294\") // wraps around to 2^32 - 2\n/// ```\npub impl Sub for UInt with sub(self, other) = \"%u32.sub\"\n\n///|\n/// Performs multiplication between two unsigned 32-bit integers. The result\n/// wraps around if it exceeds the maximum value of `UInt`.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand.\n///\n/// Returns the product of the two unsigned integers. If the result exceeds the\n/// maximum value of `UInt` (4294967295), it wraps around to the corresponding\n/// value modulo 2^32.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 3U\n/// let b = 4U\n/// inspect(a * b, content=\"12\")\n/// let max = 4294967295U\n/// inspect(max * 2U, content=\"4294967294\") // Wraps around to max * 2 % 2^32\n/// ```\npub impl Mul for UInt with mul(self, other) = \"%u32.mul\"\n\n///|\n/// Performs division between two unsigned 32-bit integers. The operation follows\n/// standard unsigned integer division rules, where the result is truncated\n/// towards zero.\n///\n/// Parameters:\n///\n/// * `self` : The dividend (the number to be divided).\n/// * `other` : The divisor (the number to divide by).\n///\n/// Returns an unsigned 32-bit integer representing the quotient of the division.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 42U\n/// let b = 5U\n/// inspect(a / b, content=\"8\") // Using infix operator\n/// ```\npub impl Div for UInt with div(self, other) = \"%u32.div\"\n\n///|\n/// Calculates the remainder of dividing one unsigned integer by another.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned integer dividend.\n/// * `other` : The unsigned integer divisor.\n///\n/// Returns the remainder of the division operation.\n///\n/// Throws a panic if `other` is zero.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 17U\n/// let b = 5U\n/// inspect(a % b, content=\"2\") // 17 divided by 5 gives quotient 3 and remainder 2\n/// inspect(7U % 4U, content=\"3\")\n/// ```\npub impl Mod for UInt with mod(self, other) = \"%u32.mod\"\n\n///|\n/// Compares two unsigned 32-bit integers for equality.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer operand.\n/// * `other` : The second unsigned integer operand to compare with.\n///\n/// Returns `true` if both integers have the same value, `false` otherwise.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 42U\n/// let b = 42U\n/// let c = 24U\n/// inspect(a == b, content=\"true\")\n/// inspect(a == c, content=\"false\")\n/// ```\npub impl Eq for UInt with equal(self : UInt, other : UInt) -> Bool = \"%u32.eq\"\n\n///|\n#deprecated(\"Use `a != b` instead\")\n#doc(hidden)\npub fn UInt::op_neq(self : UInt, other : UInt) -> Bool = \"%u32.ne\"\n\n///|\n/// Compares two unsigned 32-bit integers and returns their relative order.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned integer to compare.\n/// * `other` : The second unsigned integer to compare against.\n///\n/// Returns an integer indicating the relative order:\n///\n/// * A negative value if `self` is less than `other`\n/// * Zero if `self` equals `other`\n/// * A positive value if `self` is greater than `other`\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 42U\n/// let b = 24U\n/// inspect(a.compare(b), content=\"1\") // 42 > 24\n/// inspect(b.compare(a), content=\"-1\") // 24 < 42\n/// inspect(a.compare(a), content=\"0\") // 42 = 42\n/// ```\npub impl Compare for UInt with compare(self, other) = \"%u32.compare\"\n\n///|\npub impl Compare for UInt with op_lt(x, y) = \"%u32.lt\"\n\n///|\npub impl Compare for UInt with op_le(x, y) = \"%u32.le\"\n\n///|\npub impl Compare for UInt with op_gt(x, y) = \"%u32.gt\"\n\n///|\npub impl Compare for UInt with op_ge(x, y) = \"%u32.ge\"\n\n///|\n/// Performs a bitwise AND operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if the bits at that position in both\n/// operands are 1, and 0 otherwise.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns an unsigned 32-bit integer representing the result of the bitwise AND\n/// operation.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 0xF0F0U // 1111_0000_1111_0000\n/// let b = 0xFF00U // 1111_1111_0000_0000\n/// inspect(a & b, content=\"61440\") // 1111_0000_0000_0000 = 61440\n/// ```\npub impl BitAnd for UInt with land(self : UInt, other : UInt) -> UInt = \"%u32.bitand\"\n\n///|\n/// Performs a bitwise OR operation between two unsigned 32-bit integers. For\n/// each bit position, the result is 1 if at least one of the corresponding bits\n/// in either operand is 1.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise OR operation as an unsigned 32-bit integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 0xF0F0U // Binary: 1111_0000_1111_0000\n/// let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n/// inspect(a | b, content=\"65535\") // Binary: 1111_1111_1111_1111\n/// ```\npub impl BitOr for UInt with lor(self : UInt, other : UInt) -> UInt = \"%u32.bitor\"\n\n///|\n/// Performs a bitwise XOR (exclusive OR) operation between two unsigned 32-bit\n/// integers. Each bit in the result is set to 1 if the corresponding bits in the\n/// operands are different, and 0 if they are the same.\n///\n/// Parameters:\n///\n/// * `self` : The first unsigned 32-bit integer operand.\n/// * `other` : The second unsigned 32-bit integer operand.\n///\n/// Returns the result of the bitwise XOR operation.\n///\n/// Example:\n///\n/// ```mbt test\n/// let a = 0xFF00U // Binary: 1111_1111_0000_0000\n/// let b = 0x0F0FU // Binary: 0000_1111_0000_1111\n/// inspect(a ^ b, content=\"61455\") // Binary: 1111_0000_0000_1111\n/// ```\npub impl BitXOr for UInt with lxor(self : UInt, other : UInt) -> UInt = \"%u32.bitxor\"\n\n///|\n/// Performs a bitwise NOT operation on an unsigned 32-bit integer. Flips all\n/// bits in the number (changes each 0 to 1 and each 1 to 0).\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer value on which to perform the bitwise\n/// NOT operation.\n///\n/// Returns a new unsigned 32-bit integer where each bit is inverted from the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xFF00U // Binary: 1111_1111_0000_0000\n/// inspect(x.lnot(), content=\"4294902015\") // Binary: ...0000_0000_1111_1111\n/// ```\npub fn UInt::lnot(self : UInt) -> UInt = \"%u32.bitnot\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the number to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift the bits. Must be non-negative\n/// and less than 32. Values outside this range are wrapped to fit within it\n/// (i.e., `shift & 31`).\n///\n/// Returns a new `UInt` value representing the result of shifting the bits left\n/// by the specified number of positions. Each position shifted multiplies the\n/// number by 2.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 1U\n/// inspect(x << 3, content=\"8\") // Using the recommended operator\n/// let y = 8U\n/// inspect(y << 1, content=\"16\") // Using the recommended operator\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::lsl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Shifts each\n/// bit in the integer to the left by the specified number of positions, filling\n/// the rightmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift left. Must be between 0 and 31\n/// inclusive. Values outside this range will be masked with `& 31`.\n///\n/// Returns a new `UInt` value containing the result of the left shift operation.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 1U\n/// inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// ```\n///\n#deprecated(\"Use infix operator `<<` instead\")\n#coverage.skip\npub fn UInt::shl(self : UInt, shift : Int) -> UInt = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift on an unsigned 32-bit integer. Each bit in the\n/// input value is shifted right by the specified number of positions, with zeros\n/// shifted in from the left. DEPRECATED: Use the `>>` operator instead.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value representing the result of the logical right shift\n/// operation.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xF0000000U\n/// inspect(x >> 4, content=\"251658240\") // Using the recommended operator\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::lsr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer by a\n/// specified number of positions. All bits shifted in from the left are zeros.\n///\n/// Parameters:\n///\n/// * `number` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. Must be non-negative.\n///\n/// Returns a new `UInt` value that represents the result of shifting all bits in\n/// `number` to the right by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xFF000000U\n/// inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n/// ```\n///\n#deprecated(\"Use infix operator `>>` instead\")\n#coverage.skip\npub fn UInt::shr(self : UInt, shift : Int) -> UInt = \"%u32.shr\"\n\n///|\n/// Performs a left shift operation on an unsigned 32-bit integer. Each bit in\n/// the integer is shifted left by the specified number of positions, and zeros\n/// are filled in from the right.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift. Only the least significant 5\n/// bits are used, effectively making the shift count always between 0 and 31.\n///\n/// Returns a new unsigned 32-bit integer that is the result of shifting `self`\n/// left by `shift` positions.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 1U\n/// inspect(x << 3, content=\"8\") // Binary: 1 -> 1000\n/// let y = 0xFFFFFFFFU\n/// inspect(y << 16, content=\"4294901760\") // All bits after position 16 are discarded\n/// ```\npub impl Shl for UInt with shl(self, shift) = \"%u32.shl\"\n\n///|\n/// Performs a logical right shift operation on an unsigned 32-bit integer. The\n/// operation shifts all bits to the right by a specified number of positions,\n/// filling the leftmost positions with zeros.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be shifted.\n/// * `shift` : The number of positions to shift right. If this value is\n/// negative, the behavior is undefined. Values larger than 31 are masked with `&\n/// 31`.\n///\n/// Returns a new unsigned 32-bit integer containing the result of the right\n/// shift operation.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xFF000000U\n/// inspect(x >> 8, content=\"16711680\") // 0x00FF0000\n/// inspect(x >> 24, content=\"255\") // 0x000000FF\n/// let x = 0xFF000000U\n/// inspect(x >> 32, content=\"4278190080\") // Same as x >> 0 due to masking\n/// ```\npub impl Shr for UInt with shr(self, shift) = \"%u32.shr\"\n\n///|\n/// Counts the number of leading zero bits in an unsigned 32-bit integer,\n/// starting from the most significant bit.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer whose leading zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros starting from the most significant\n/// bit. For a zero value, returns 32.\n///\n/// Example:\n///\n/// ```mbt test\n/// inspect(0U.clz(), content=\"32\")\n/// inspect(1U.clz(), content=\"31\")\n/// inspect(0x80000000U.clz(), content=\"0\")\n/// ```\npub fn UInt::clz(self : UInt) -> Int = \"%u32.clz\"\n\n///|\n/// Counts the number of trailing zero bits in an unsigned 32-bit integer,\n/// starting from the least significant bit. For a zero input, returns 32.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose trailing zeros are to be\n/// counted.\n///\n/// Returns the number of consecutive zeros at the least significant end of the\n/// binary representation. Returns 32 if the input is zero.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 24U // Binary: ...011000\n/// inspect(x.ctz(), content=\"3\") // 3 trailing zeros\n/// let y = 0U\n/// inspect(y.ctz(), content=\"32\") // All bits are zero\n/// ```\npub fn UInt::ctz(self : UInt) -> Int = \"%u32.ctz\"\n\n///|\n/// Counts the number of 1 bits (population count) in the binary representation\n/// of an unsigned 32-bit integer.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer whose bits are to be counted.\n///\n/// Returns an integer representing the count of set bits (1s) in the binary\n/// representation.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = 0xF0F0U // Binary: 1111 0000 1111 0000\n/// inspect(x.popcnt(), content=\"8\") // Has 8 bits set to 1\n/// ```\npub fn UInt::popcnt(self : UInt) -> Int = \"%u32.popcnt\"\n\n///|\n/// Converts an unsigned 32-bit integer to an unsigned 64-bit integer by\n/// zero-extending it. The resulting value preserves the original number's\n/// magnitude while using 64 bits to represent it.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer (`UInt`) to be converted.\n///\n/// Returns an unsigned 64-bit integer (`UInt64`) representing the same numerical\n/// value as the input.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 42U\n/// inspect(n.to_uint64(), content=\"42\")\n/// let max = 4294967295U // Maximum value of UInt\n/// inspect(max.to_uint64(), content=\"4294967295\")\n/// ```\npub fn UInt::to_uint64(self : UInt) -> UInt64 {\n  UInt64::extend_uint(self)\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a byte by taking its least significant\n/// 8 bits. Any bits beyond the first 8 bits are truncated.\n///\n/// Parameters:\n///\n/// * `self` : The unsigned 32-bit integer to be converted. Only the least\n/// significant 8 bits will be used.\n///\n/// Returns a byte containing the least significant 8 bits of the input integer.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 258U // In binary: 100000010\n/// inspect(n.to_byte(), content=\"b'\\\\x02'\") // Only keeps 00000010\n/// let big = 4294967295U // Maximum value of UInt\n/// inspect(big.to_byte(), content=\"b'\\\\xFF'\") // Only keeps 11111111\n/// ```\npub fn UInt::to_byte(self : UInt) -> Byte {\n  self.reinterpret_as_int().to_byte()\n}\n\n///|\n/// Converts an unsigned 32-bit integer to a double-precision floating-point\n/// number. Since the range of unsigned 32-bit integers is smaller than what can\n/// be precisely represented by a double-precision floating-point number, this\n/// conversion is guaranteed to be exact.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 32-bit integer to be converted.\n///\n/// Returns a double-precision floating-point number that exactly represents the\n/// input value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 42U\n/// inspect(n.to_double(), content=\"42\")\n/// let max = 4294967295U // maximum value of UInt\n/// inspect(max.to_double(), content=\"4294967295\")\n/// ```\npub fn UInt::to_double(self : UInt) -> Double = \"%u32.to_f64\"\n\n///|\n#deprecated(\"Use `Float::from_int` instead\")\npub fn Int::to_float(self : Int) -> Float = \"%i32.to_f32\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_int` instead\")\npub fn Int::reinterpret_as_float(self : Int) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::reinterpret_from_uint` instead\")\npub fn UInt::reinterpret_as_float(self : UInt) -> Float = \"%i32.to_f32_reinterpret\"\n\n///|\n#deprecated(\"Use `Float::from_byte` instead\")\npub fn Byte::to_float(self : Byte) -> Float = \"%byte.to_f32\"\n\n///|\n/// TODO: use intrinsics implement this\npub fn Byte::to_double(self : Byte) -> Double {\n  self.to_int().to_double()\n}\n\n///|\n/// TODO: enable skip_current_package=false\n#deprecated(\"Use `Float::from_double` instead\", skip_current_package=true)\npub fn Double::to_float(self : Double) -> Float = \"%f64.to_f32\"\n\n///|\n#deprecated(\"Use `Float::from_uint` instead\")\npub fn UInt::to_float(self : UInt) -> Float = \"%u32.to_f32\"\n\n///|\n#deprecated(\"Use `Int16::from_int` instead\")\npub fn Int::to_int16(self : Int) -> Int16 = \"%i32_to_i16\"\n\n///|\n/// Converts a byte value to a 16-bit signed integer. The byte value is\n/// sign-extended to 16 bits during the conversion.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted to an `Int16`.\n///\n/// Returns a 16-bit signed integer representing the same value as the input\n/// byte.\n#deprecated(\"Use `Int16::from_byte` instead\")\npub fn Byte::to_int16(self : Byte) -> Int16 = \"%byte_to_i16\"\n\n///|\n/// Converts an unsigned 16-bit integer to a 32-bit signed integer. The value is\n/// zero-extended to fill the higher bits.\n///\n/// Parameters:\n///\n/// * `value` : The unsigned 16-bit integer to be converted.\n///\n/// Returns a 32-bit signed integer. Since the input value is always non-negative\n/// and less than 65536, the conversion never results in overflow.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = Int::to_uint16(42)\n/// inspect(x.to_int(), content=\"42\")\n/// let max = Int::to_uint16(65535) // maximum value of UInt16\n/// inspect(max.to_int(), content=\"65535\")\n/// ```\npub fn UInt16::to_int(self : UInt16) -> Int = \"%u16_to_i32\"\n\n///|\n/// Converts a 16-bit unsigned integer to an 8-bit byte by truncating the higher\n/// bits.\n///\n/// Parameters:\n///\n/// * `value` : The 16-bit unsigned integer to be converted.\n///\n/// Returns a byte containing the least significant 8 bits of the input value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let x = Int::to_uint16(258) // Binary: 0000_0001_0000_0010\n/// inspect(x.to_byte(), content=\"b'\\\\x02'\") // Only keeps 0000_0010\n/// ```\npub fn UInt16::to_byte(self : UInt16) -> Byte = \"%u16_to_byte\"\n\n///|\n/// Converts a 32-bit unsigned integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit unsigned integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 42U\n/// inspect(n.to_uint16(), content=\"42\")\n/// let max = 4294967295U\n/// inspect(max.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n/// let large = 65536U\n/// inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// ```\npub fn UInt::to_uint16(self : UInt) -> UInt16 {\n  self.reinterpret_as_int().to_uint16()\n}\n\n///|\n/// Converts a 32-bit signed integer to a 16-bit unsigned integer by truncating\n/// its value to fit within the range of 0 to 65535.\n///\n/// Parameters:\n///\n/// * `integer` : The 32-bit signed integer to be converted. Values outside the\n/// range of UInt16 will be truncated to fit.\n///\n/// Returns a 16-bit unsigned integer containing the lower 16 bits of the input\n/// value.\n///\n/// Example:\n///\n/// ```mbt test\n/// let n = 42\n/// inspect(n.to_uint16(), content=\"42\")\n/// let neg = -1\n/// inspect(neg.to_uint16(), content=\"65535\") // -1 becomes max value of UInt16\n/// let large = 65536\n/// inspect(large.to_uint16(), content=\"0\") // Values wrap around\n/// ```\npub fn Int::to_uint16(self : Int) -> UInt16 = \"%i32_to_u16\"\n\n///|\n/// Converts a byte value to a 16-bit unsigned integer by zero-extending it.\n///\n/// Parameters:\n///\n/// * `byte` : The byte value to be converted.\n///\n/// Returns a 16-bit unsigned integer (`UInt16`) representing the same value as\n/// the input byte.\n///\n/// Example:\n///\n/// ```mbt test\n/// let b = b'\\xFF' // byte with value 255\n/// inspect(b.to_uint16(), content=\"255\")\n/// let zero = b'\\x00'\n/// inspect(zero.to_uint16(), content=\"0\")\n/// ```\npub fn Byte::to_uint16(self : Byte) -> UInt16 = \"%byte_to_u16\"\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\nstruct UninitializedArray[T](FixedArray[UnsafeMaybeUninit[T]])\n\n///|\n/// Creates an uninitialized array of the specified size.\n///\n/// Parameters:\n///\n/// - `size` : The number of elements the array should hold.\n///\n/// Returns an uninitialized array of type `T` with the specified size.\npub fn[T] UninitializedArray::make(size : Int) -> UninitializedArray[T] = \"%fixedarray.make_uninit\"\n\n///|\n/// Retrieves the element at the specified index from an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array from which to retrieve the element.\n/// - `index` : The index of the element to retrieve.\n///\n/// Returns the element at the specified index.\n#alias(\"_[_]\")\npub fn[T] UninitializedArray::at(\n  self : UninitializedArray[T],\n  index : Int,\n) -> T = \"%fixedarray.get\"\n\n///|\n/// Sets the value at the specified index in an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array where the value will be set.\n/// - `index` : The position in the array where the value will be set.\n/// - `value` : The value to be set at the specified index.\n#alias(\"_[_]=_\")\npub fn[T] UninitializedArray::set(\n  self : UninitializedArray[T],\n  index : Int,\n  value : T,\n) = \"%fixedarray.set\"\n\n///|\n/// Creates a view into a portion of the uninitialized array.\n///\n/// Parameters:\n///\n/// * `array` : The uninitialized array to create a view from.\n/// * `start` : The starting index of the view (inclusive). Defaults to 0.\n/// * `end` : The ending index of the view (exclusive). If not provided, defaults\n/// to the length of the array.\n///\n/// Returns an `ArrayView` that provides a window into the specified portion of\n/// the array.\n///\n/// Throws an error if the indices are out of bounds or if `start` is greater\n/// than `end`.\n#alias(\"_[_:_]\")\npub fn[T] UninitializedArray::sub(\n  self : UninitializedArray[T],\n  start? : Int = 0,\n  end? : Int,\n) -> ArrayView[T] {\n  let len = self.length()\n  let end = match end {\n    None => len\n    Some(end) => end\n  }\n  guard start >= 0 && start <= end && end <= len else {\n    abort(\"View start index out of bounds\")\n  }\n  ArrayView::make(self, start, end - start)\n}\n\n///|\n/// Returns the length of an uninitialized array.\n///\n/// Parameters:\n///\n/// - `array` : The uninitialized array whose length is to be determined.\n///\n/// Returns the length of the uninitialized array as an integer.\npub fn[A] UninitializedArray::length(self : UninitializedArray[A]) -> Int {\n  self.0.length()\n}\n\n///|\n#internal(unsafe, \"For internal use only.\")\n#doc(hidden)\npub fn[T] UninitializedArray::unsafe_blit(\n  dst : UninitializedArray[T],\n  dst_offset : Int,\n  src : UninitializedArray[T],\n  src_offset : Int,\n  len : Int,\n) -> Unit {\n  FixedArray::unsafe_blit(dst.0, dst_offset, src.0, src_offset, len)\n}\n\n///|\ntest \"as_view with valid_range\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  let view = arr[1:4]\n  inspect(view.start(), content=\"1\")\n  inspect(view.len(), content=\"3\")\n}\n\n///|\ntest \"panic as_view with invalid_start\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[-1:])\n}\n\n///|\ntest \"panic as_view with invalid_end\" {\n  let arr : UninitializedArray[Int] = UninitializedArray::make(5)\n  ignore(arr[2:10])\n}\n\n///|\n#intrinsic(\"%fixedarray.fill\")\n#cfg(not(target=\"js\"))\nfn[T] UninitializedArray::unchecked_fill(\n  self : UninitializedArray[T],\n  start : Int,\n  value : T,\n  len : Int,\n) -> Unit {\n  for i in start..<(start + len) {\n    self[i] = value\n  }\n}\n","// Copyright 2025 International Digital Economy Academy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(not(target=\"native\"))\npub fn[T] abort(msg : String) -> T {\n  let _ = msg\n  panic_impl()\n}\n\n///|\n#cfg(target=\"native\")\nfn println(s : String) -> Unit = \"%println\"\n\n///|\n/// Aborts the program with an error message. Always causes a panic, regardless\n/// of the message provided.\n///\n/// Parameters:\n///\n/// * `message` : A string containing the error message to be displayed when\n/// aborting.\n///\n/// Returns a value of type `T`. However, this function never actually returns a\n/// value as it always causes a panic.\n#cfg(target=\"native\")\npub fn[T] abort(msg : String) -> T {\n  println(msg)\n  panic_impl()\n}\n\n///|\nfn[T] panic_impl() -> T = \"%panic\"\n"],"mappings":"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"}