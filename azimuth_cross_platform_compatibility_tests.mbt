// Azimuth è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯•
// ä¸“æ³¨äºæµ‹è¯•ä¸åŒå¹³å°å’Œæ“ä½œç³»ç»Ÿä¹‹é—´çš„å…¼å®¹æ€§

// å¹³å°ç±»å‹å®šä¹‰
type Platform {
  Windows
  MacOS
  Linux
  Android
  IOS
  WebAssembly
  Unknown
}

// æ¶æ„ç±»å‹å®šä¹‰
type Architecture {
  X86
  X64
  ARM32
  ARM64
  UnknownArch
}

// æµ‹è¯•1: å¹³å°æ£€æµ‹
test "å¹³å°æ£€æµ‹æµ‹è¯•" {
  // è·å–å½“å‰å¹³å°
  let current_platform = detect_current_platform()
  let current_arch = detect_current_architecture()
  
  // éªŒè¯å¹³å°æ£€æµ‹ç»“æœ
  match current_platform {
    Windows => {
      assert_true(check_windows_specific_features())
    }
    MacOS => {
      assert_true(check_macos_specific_features())
    }
    Linux => {
      assert_true(check_linux_specific_features())
    }
    Android => {
      assert_true(check_android_specific_features())
    }
    IOS => {
      assert_true(check_ios_specific_features())
    }
    WebAssembly => {
      assert_true(check_webassembly_specific_features())
    }
    Unknown => {
      // æœªçŸ¥å¹³å°åº”è¯¥è‡³å°‘æœ‰ä¸€äº›åŸºæœ¬åŠŸèƒ½
      assert_true(check_basic_cross_platform_features())
    }
  }
  
  // éªŒè¯æ¶æ„æ£€æµ‹ç»“æœ
  match current_arch {
    X86 => {
      assert_true(check_x86_specific_features())
    }
    X64 => {
      assert_true(check_x64_specific_features())
    }
    ARM32 => {
      assert_true(check_arm32_specific_features())
    }
    ARM64 => {
      assert_true(check_arm64_specific_features())
    }
    UnknownArch => {
      // æœªçŸ¥æ¶æ„åº”è¯¥è‡³å°‘æœ‰ä¸€äº›åŸºæœ¬åŠŸèƒ½
      assert_true(check_basic_cross_platform_features())
    }
  }
}

// æµ‹è¯•2: æ–‡ä»¶è·¯å¾„å¤„ç†
test "æ–‡ä»¶è·¯å¾„å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒå¹³å°çš„è·¯å¾„åˆ†éš”ç¬¦
  let path_separator = get_path_separator()
  
  // æ„å»ºè·¨å¹³å°è·¯å¾„
  let path_components = ["home", "user", "documents", "file.txt"]
  let constructed_path = build_path(path_components)
  
  // éªŒè¯è·¯å¾„æ„å»º
  assert_true(constructed_path.contains("home"))
  assert_true(constructed_path.contains("user"))
  assert_true(constructed_path.contains("documents"))
  assert_true(constructed_path.contains("file.txt"))
  
  // éªŒè¯è·¯å¾„åˆ†éš”ç¬¦
  match current_platform {
    Windows => {
      assert_eq(path_separator, "\\")
      assert_true(constructed_path.contains("\\"))
    }
    _ => {
      assert_eq(path_separator, "/")
      assert_true(constructed_path.contains("/"))
    }
  }
  
  // æµ‹è¯•è·¯å¾„è§„èŒƒåŒ–
  let messy_path = "home//user/./documents/../documents/file.txt"
  let normalized_path = normalize_path(messy_path)
  
  // éªŒè¯è·¯å¾„è§„èŒƒåŒ–ç»“æœ
  assert_false(normalized_path.contains("//"))
  assert_false(normalized_path.contains("/./"))
  assert_false(normalized_path.contains("/../"))
  
  // æµ‹è¯•è·¯å¾„è§£æ
  let parsed_components = parse_path(constructed_path)
  assert_eq(parsed_components.length(), path_components.length())
  
  let i = 0
  while i < path_components.length() {
    assert_eq(parsed_components[i], path_components[i])
    i = i + 1
  }
}

// æµ‹è¯•3: å­—ç¬¦ç¼–ç å¤„ç†
test "å­—ç¬¦ç¼–ç å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•UTF-8ç¼–ç 
  let unicode_text = "æµ‹è¯•ä¸­æ–‡ ğŸŒŸ Test English ğŸš€ Ğ¢ĞµÑÑ‚ Ñ€ÑƒÑÑĞºĞ¸Ğ¹"
  let encoded_bytes = encode_to_utf8(unicode_text)
  let decoded_text = decode_from_utf8(encoded_bytes)
  
  assert_eq(unicode_text, decoded_text)
  
  // æµ‹è¯•ä¸åŒç¼–ç ä¹‹é—´çš„è½¬æ¢
  let utf16_bytes = encode_to_utf16(unicode_text)
  let utf16_decoded = decode_from_utf16(utf16_bytes)
  
  assert_eq(unicode_text, utf16_decoded)
  
  // æµ‹è¯•BOMå¤„ç†
  let text_with_bom = add_utf8_bom(unicode_text)
  let bom_detected = has_utf8_bom(text_with_bom)
  assert_true(bom_detected)
  
  let text_without_bom = remove_utf8_bom(text_with_bom)
  let bom_removed = !has_utf8_bom(text_without_bom)
  assert_true(bom_removed)
  assert_eq(text_without_bom, unicode_text)
}

// æµ‹è¯•4: æ—¶é—´å’Œæ—¥æœŸå¤„ç†
test "æ—¶é—´å’Œæ—¥æœŸå¤„ç†æµ‹è¯•" {
  // è·å–å½“å‰æ—¶é—´
  let current_time = get_current_timestamp()
  assert_true(current_time > 0)
  
  // æ—¶é—´æ ¼å¼åŒ–
  let formatted_time = format_timestamp(current_time, "YYYY-MM-DD HH:mm:ss")
  assert_true(formatted_time.length() > 0)
  
  // æ—¶é—´è§£æ
  let parsed_time = parse_timestamp(formatted_time, "YYYY-MM-DD HH:mm:ss")
  match parsed_time {
    Some(timestamp) => {
      // å…è®¸ä¸€äº›æ—¶é—´å·®å¼‚ï¼ˆç§’çº§ï¼‰
      let time_diff = current_time - timestamp
      assert_true(time_diff >= 0 && time_diff < 60)
    }
    None => assert_true(false)
  }
  
  // æ—¶åŒºå¤„ç†
  let local_time = convert_to_local_time(current_time)
  let utc_time = convert_to_utc_time(local_time)
  
  // éªŒè¯æ—¶åŒºè½¬æ¢
  let time_diff = current_time - utc_time
  assert_true(time_diff >= 0 && time_diff < 86400) // ä¸è¶…è¿‡ä¸€å¤©
  
  // ä¸åŒå¹³å°çš„æ—¶é—´æ ¼å¼æµ‹è¯•
  let platform_specific_format = get_platform_time_format()
  let platform_formatted = format_timestamp(current_time, platform_specific_format)
  assert_true(platform_formatted.length() > 0)
}

// æµ‹è¯•5: ç½‘ç»œé€šä¿¡å…¼å®¹æ€§
test "ç½‘ç»œé€šä¿¡å…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒå¹³å°çš„ç½‘ç»œAPI
  let network_apis = get_available_network_apis()
  assert_true(network_apis.length() > 0)
  
  // æµ‹è¯•HTTPè¯·æ±‚
  let test_url = "https://httpbin.org/get"
  let http_result = make_http_request("GET", test_url, [])
  
  match http_result {
    Ok(response) => {
      assert_true(response.status_code >= 200 && response.status_code < 300)
      assert_true(response.body.length() > 0)
    }
    Err(error) => {
      // åœ¨æŸäº›æµ‹è¯•ç¯å¢ƒä¸­ï¼Œç½‘ç»œè¯·æ±‚å¯èƒ½å¤±è´¥ï¼Œè¿™æ˜¯å¯ä»¥æ¥å—çš„
      assert_true(error.contains("network") || error.contains("connection"))
    }
  }
  
  // æµ‹è¯•SSL/TLSæ”¯æŒ
  let ssl_support = check_ssl_support()
  assert_true(ssl_support)
  
  // æµ‹è¯•ä»£ç†è®¾ç½®
  let proxy_config = get_proxy_configuration()
  match proxy_config {
    Some(config) => {
      assert_true(config.host.length() > 0)
      assert_true(config.port > 0)
    }
    None => {
      // æ²¡æœ‰ä»£ç†é…ç½®ä¹Ÿæ˜¯æ­£å¸¸çš„
    }
  }
}

// æµ‹è¯•6: ç³»ç»ŸAPIå…¼å®¹æ€§
test "ç³»ç»ŸAPIå…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•ç¯å¢ƒå˜é‡è®¿é—®
  let path_env = get_environment_variable("PATH")
  match path_env {
    Some(path) => {
      assert_true(path.length() > 0)
    }
    None => {
      // åœ¨æŸäº›å¹³å°ä¸Šï¼ŒPATHå¯èƒ½ä¸å­˜åœ¨ï¼Œä½†è¿™ä¸å¤ªå¯èƒ½
    }
  }
  
  // æµ‹è¯•ç³»ç»Ÿä¿¡æ¯è·å–
  let system_info = get_system_information()
  assert_true(system_info.os_name.length() > 0)
  assert_true(system_info.os_version.length() > 0)
  assert_true(system_info.hostname.length() > 0)
  
  // æµ‹è¯•ä¸´æ—¶ç›®å½•
  let temp_dir = get_temporary_directory()
  assert_true(temp_dir.length() > 0)
  assert_true(directory_exists(temp_dir))
  
  // æµ‹è¯•ç”¨æˆ·ç›®å½•
  let user_dir = get_user_directory()
  assert_true(user_dir.length() > 0)
  assert_true(directory_exists(user_dir))
  
  // æµ‹è¯•ç³»ç»Ÿèµ„æºé™åˆ¶
  let resource_limits = get_resource_limits()
  assert_true(resource_limits.max_memory > 0)
  assert_true(resource_limits.max_file_descriptors > 0)
}

// æµ‹è¯•7: WebAssemblyå…¼å®¹æ€§
test "WebAssemblyå…¼å®¹æ€§æµ‹è¯•" {
  let is_wasm = is_running_in_webassembly()
  
  if is_wasm {
    // WebAssemblyç‰¹å®šæµ‹è¯•
    assert_true(check_wasm_memory_operations())
    assert_true(check_wasm_import_functions())
    assert_true(check_wasm_export_functions())
    assert_true(check_browser_apis())
  } else {
    // éWebAssemblyç¯å¢ƒæµ‹è¯•
    assert_true(check_native_file_operations())
    assert_true(check_native_network_operations())
    assert_true(check_native_system_operations())
  }
  
  // è·¨å¹³å°APIæµ‹è¯•
  let cross_platform_api = get_cross_platform_api()
  let api_result = cross_platform_api.test_function("test_parameter")
  
  match api_result {
    Ok(result) => {
      assert_eq(result, "test_parameter_processed")
    }
    Err(error) => {
      assert_true(false)
    }
  }
}

// æµ‹è¯•8: åŒ…ç®¡ç†å…¼å®¹æ€§
test "åŒ…ç®¡ç†å…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•åŒ…è·¯å¾„è§£æ
  let package_path = resolve_package_path("moonbitlang/core")
  assert_true(package_path.length() > 0)
  
  // æµ‹è¯•ä¾èµ–è§£æ
  let dependencies = get_package_dependencies()
  assert_true(dependencies.length() > 0)
  
  // éªŒè¯æ ¸å¿ƒä¾èµ–å­˜åœ¨
  let has_core_dependency = dependencies.contains("moonbitlang/core")
  assert_true(has_core_dependency)
  
  // æµ‹è¯•åŒ…ç‰ˆæœ¬å…¼å®¹æ€§
  let version_info = get_package_version("moonbitlang/core")
  match version_info {
    Some(version) => {
      assert_true(version.length() > 0)
      assert_true(is_valid_version_format(version))
    }
    None => {
      // åœ¨æŸäº›ç¯å¢ƒä¸­å¯èƒ½æ— æ³•è·å–ç‰ˆæœ¬ä¿¡æ¯
    }
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æµ‹å½“å‰å¹³å°
fn detect_current_platform() -> Platform {
  // ç®€åŒ–çš„å¹³å°æ£€æµ‹
  // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œä¼šä½¿ç”¨æ›´å¤æ‚çš„æ£€æµ‹é€»è¾‘
  let os_name = get_environment_variable("OS")
  
  match os_name {
    Some(os) => {
      if os.contains("Windows") {
        Windows
      } else if os.contains("Darwin") {
        MacOS
      } else if os.contains("Linux") {
        Linux
      } else if os.contains("Android") {
        Android
      } else {
        Unknown
      }
    }
    None => {
      // é»˜è®¤å‡è®¾ä¸ºLinux
      Linux
    }
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æµ‹å½“å‰æ¶æ„
fn detect_current_architecture() -> Architecture {
  // ç®€åŒ–çš„æ¶æ„æ£€æµ‹
  let arch_name = get_environment_variable("ARCH")
  
  match arch_name {
    Some(arch) => {
      if arch.contains("x86") || arch.contains("i386") {
        X86
      } else if arch.contains("x64") || arch.contains("amd64") {
        X64
      } else if arch.contains("arm32") || arch.contains("armv7") {
        ARM32
      } else if arch.contains("arm64") || arch.contains("aarch64") {
        ARM64
      } else {
        UnknownArch
      }
    }
    None => {
      // é»˜è®¤å‡è®¾ä¸ºX64
      X64
    }
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥Windowsç‰¹å®šåŠŸèƒ½
fn check_windows_specific_features() -> Bool {
  // æ£€æŸ¥Windowsç‰¹å®šåŠŸèƒ½
  let has_windows_registry = check_windows_registry_access()
  let has_windows_services = check_windows_services_access()
  let has_windows_dlls = check_windows_dll_access()
  
  has_windows_registry || has_windows_services || has_windows_dlls
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥MacOSç‰¹å®šåŠŸèƒ½
fn check_macos_specific_features() -> Bool {
  // æ£€æŸ¥MacOSç‰¹å®šåŠŸèƒ½
  let has_macos_bundles = check_macos_bundle_access()
  let has_macos_keychain = check_macos_keychain_access()
  let has_macos_notifications = check_macos_notification_center()
  
  has_macos_bundles || has_macos_keychain || has_macos_notifications
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥Linuxç‰¹å®šåŠŸèƒ½
fn check_linux_specific_features() -> Bool {
  // æ£€æŸ¥Linuxç‰¹å®šåŠŸèƒ½
  let has_linux_proc = check_linux_proc_access()
  let has_linux_sys = check_linux_sys_access()
  let has_linux_permissions = check_linux_permission_model()
  
  has_linux_proc || has_linux_sys || has_linux_permissions
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥Androidç‰¹å®šåŠŸèƒ½
fn check_android_specific_features() -> Bool {
  // æ£€æŸ¥Androidç‰¹å®šåŠŸèƒ½
  let has_android_intents = check_android_intent_system()
  let has_android_content = check_android_content_providers()
  let has_android_services = check_android_services()
  
  has_android_intents || has_android_content || has_android_services
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥iOSç‰¹å®šåŠŸèƒ½
fn check_ios_specific_features() -> Bool {
  // æ£€æŸ¥iOSç‰¹å®šåŠŸèƒ½
  let has_ios_notifications = check_ios_notification_center()
  let has_ios_keychain = check_ios_keychain_access()
  let has_ios_app_store = check_ios_app_store_integration()
  
  has_ios_notifications || has_ios_keychain || has_ios_app_store
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥WebAssemblyç‰¹å®šåŠŸèƒ½
fn check_webassembly_specific_features() -> Bool {
  // æ£€æŸ¥WebAssemblyç‰¹å®šåŠŸèƒ½
  let has_wasm_memory = check_wasm_memory_model()
  let has_wasm_imports = check_wasm_import_exports()
  let has_browser_apis = check_browser_web_apis()
  
  has_wasm_memory || has_wasm_imports || has_browser_apis
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥åŸºæœ¬è·¨å¹³å°åŠŸèƒ½
fn check_basic_cross_platform_features() -> Bool {
  // æ£€æŸ¥æ‰€æœ‰å¹³å°éƒ½åº”è¯¥å…·å¤‡çš„åŸºæœ¬åŠŸèƒ½
  let has_basic_math = check_basic_math_operations()
  let has_basic_strings = check_basic_string_operations()
  let has_basic_collections = check_basic_collection_operations()
  
  has_basic_math && has_basic_strings && has_basic_collections
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥x86ç‰¹å®šåŠŸèƒ½
fn check_x86_specific_features() -> Bool {
  // æ£€æŸ¥x86ç‰¹å®šåŠŸèƒ½
  check_x86_instruction_set() && check_x86_alignment()
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥x64ç‰¹å®šåŠŸèƒ½
fn check_x64_specific_features() -> Bool {
  // æ£€æŸ¥x64ç‰¹å®šåŠŸèƒ½
  check_x64_instruction_set() && check_x64_alignment()
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ARM32ç‰¹å®šåŠŸèƒ½
fn check_arm32_specific_features() -> Bool {
  // æ£€æŸ¥ARM32ç‰¹å®šåŠŸèƒ½
  check_arm32_instruction_set() && check_arm32_alignment()
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ARM64ç‰¹å®šåŠŸèƒ½
fn check_arm64_specific_features() -> Bool {
  // æ£€æŸ¥ARM64ç‰¹å®šåŠŸèƒ½
  check_arm64_instruction_set() && check_arm64_alignment()
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–è·¯å¾„åˆ†éš”ç¬¦
fn get_path_separator() -> String {
  match detect_current_platform() {
    Windows => "\\"
    _ => "/"
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ„å»ºè·¯å¾„
fn build_path(components : Array[String]) -> String {
  let separator = get_path_separator()
  let path = ""
  let i = 0
  
  while i < components.length() {
    if i > 0 {
      path = path + separator
    }
    path = path + components[i]
    i = i + 1
  }
  
  path
}

// è¾…åŠ©å‡½æ•°ï¼šè§„èŒƒåŒ–è·¯å¾„
fn normalize_path(path : String) -> String {
  let separator = get_path_separator()
  let components = parse_path(path)
  let normalized_components = []
  let i = 0
  
  while i < components.length() {
    let component = components[i]
    
    if component == "." {
      // å¿½ç•¥å½“å‰ç›®å½•
    } else if component == ".." {
      // è¿”å›ä¸Šçº§ç›®å½•
      if normalized_components.length() > 0 {
        normalized_components.pop()
      }
    } else if component.length() > 0 {
      // æ·»åŠ æœ‰æ•ˆç»„ä»¶
      normalized_components.push(component)
    }
    
    i = i + 1
  }
  
  build_path(normalized_components)
}

// è¾…åŠ©å‡½æ•°ï¼šè§£æè·¯å¾„
fn parse_path(path : String) -> Array[String] {
  let separator = get_path_separator()
  let components = path.split(separator)
  let filtered = []
  
  for component in components {
    if component.length() > 0 {
      filtered.push(component)
    }
  }
  
  filtered
}

// è¾…åŠ©å‡½æ•°ï¼šç¼–ç ä¸ºUTF-8
fn encode_to_utf8(text : String) -> Array[Byte] {
  // ç®€åŒ–çš„UTF-8ç¼–ç 
  let bytes = []
  let i = 0
  
  while i < text.length() {
    let char_code = text.char_code_at(i)
    
    if char_code < 128 {
      // ASCIIå­—ç¬¦
      bytes.push(char_code as Byte)
    } else if char_code < 2048 {
      // åŒå­—èŠ‚UTF-8
      bytes.push(192 + (char_code / 64) as Byte)
      bytes.push(128 + (char_code % 64) as Byte)
    } else {
      // ä¸‰å­—èŠ‚UTF-8ï¼ˆç®€åŒ–å¤„ç†ï¼‰
      bytes.push(224 + (char_code / 4096) as Byte)
      bytes.push(128 + ((char_code / 64) % 64) as Byte)
      bytes.push(128 + (char_code % 64) as Byte)
    }
    
    i = i + 1
  }
  
  bytes
}

// è¾…åŠ©å‡½æ•°ï¼šä»UTF-8è§£ç 
fn decode_from_utf8(bytes : Array[Byte]) -> String {
  // ç®€åŒ–çš„UTF-8è§£ç 
  let chars = []
  let i = 0
  
  while i < bytes.length() {
    let byte = bytes[i]
    
    if byte < 128 {
      // ASCIIå­—ç¬¦
      chars.push(char_from_code(byte as Int))
      i = i + 1
    } else if byte >= 192 && byte < 224 && i + 1 < bytes.length() {
      // åŒå­—èŠ‚UTF-8
      let char_code = ((byte - 192) * 64 + (bytes[i + 1] - 128)) as Int
      chars.push(char_from_code(char_code))
      i = i + 2
    } else if byte >= 224 && i + 2 < bytes.length() {
      // ä¸‰å­—èŠ‚UTF-8ï¼ˆç®€åŒ–å¤„ç†ï¼‰
      let char_code = ((byte - 224) * 4096 + (bytes[i + 1] - 128) * 64 + (bytes[i + 2] - 128)) as Int
      chars.push(char_from_code(char_code))
      i = i + 3
    } else {
      // æ— æ•ˆUTF-8ï¼Œä½¿ç”¨æ›¿æ¢å­—ç¬¦
      chars.push('?')
      i = i + 1
    }
  }
  
  String.from_array(chars)
}

// è¾…åŠ©å‡½æ•°ï¼šç¼–ç ä¸ºUTF-16
fn encode_to_utf16(text : String) -> Array[Byte] {
  // ç®€åŒ–çš„UTF-16ç¼–ç 
  let bytes = []
  let i = 0
  
  while i < text.length() {
    let char_code = text.char_code_at(i)
    
    // å°ç«¯åº
    bytes.push((char_code % 256) as Byte)
    bytes.push((char_code / 256) as Byte)
    
    i = i + 1
  }
  
  bytes
}

// è¾…åŠ©å‡½æ•°ï¼šä»UTF-16è§£ç 
fn decode_from_utf16(bytes : Array[Byte]) -> String {
  // ç®€åŒ–çš„UTF-16è§£ç 
  let chars = []
  let i = 0
  
  while i + 1 < bytes.length() {
    let low_byte = bytes[i]
    let high_byte = bytes[i + 1]
    let char_code = (high_byte * 256 + low_byte) as Int
    
    chars.push(char_from_code(char_code))
    i = i + 2
  }
  
  String.from_array(chars)
}

// è¾…åŠ©å‡½æ•°ï¼šæ·»åŠ UTF-8 BOM
fn add_utf8_bom(text : String) -> String {
  let bom = [0xEF, 0xBB, 0xBF]
  let bom_text = String.from_utf8_bytes(bom)
  bom_text + text
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦æœ‰UTF-8 BOM
fn has_utf8_bom(text : String) -> Bool {
  if text.length() >= 3 {
    let bom = text.substring(0, 3)
    let bom_bytes = bom.to_utf8_bytes()
    bom_bytes.length() == 3 && 
    bom_bytes[0] == 0xEF && 
    bom_bytes[1] == 0xBB && 
    bom_bytes[2] == 0xBF
  } else {
    false
  }
}

// è¾…åŠ©å‡½æ•°ï¼šç§»é™¤UTF-8 BOM
fn remove_utf8_bom(text : String) -> String {
  if has_utf8_bom(text) {
    text.substring(3, text.length() - 3)
  } else {
    text
  }
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–å½“å‰æ—¶é—´æˆ³
fn get_current_timestamp() -> Int {
  // ç®€åŒ–çš„æ—¶é—´æˆ³è·å–
  @static.timestamp_counter
}

// é™æ€å˜é‡ï¼šæ—¶é—´æˆ³è®¡æ•°å™¨
@static.timestamp_counter = 1640995200 // 2022-01-01 00:00:00 UTC

// è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–æ—¶é—´æˆ³
fn format_timestamp(timestamp : Int, format : String) -> String {
  // ç®€åŒ–çš„æ—¶é—´æ ¼å¼åŒ–
  // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œä¼šä½¿ç”¨æ›´å¤æ‚çš„æ—¶é—´æ ¼å¼åŒ–åº“
  let date = Date.from_timestamp(timestamp)
  date.format(format)
}

// è¾…åŠ©å‡½æ•°ï¼šè§£ææ—¶é—´æˆ³
fn parse_timestamp(time_string : String, format : String) -> Option[Int] {
  // ç®€åŒ–çš„æ—¶é—´è§£æ
  // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œä¼šä½¿ç”¨æ›´å¤æ‚çš„æ—¶é—´è§£æåº“
  match Date.parse(time_string, format) {
    Some(date) => Some(date.to_timestamp())
    None => None
  }
}

// è¾…åŠ©å‡½æ•°ï¼šè½¬æ¢ä¸ºæœ¬åœ°æ—¶é—´
fn convert_to_local_time(timestamp : Int) -> Int {
  // ç®€åŒ–çš„æ—¶åŒºè½¬æ¢
  // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œä¼šè€ƒè™‘ç³»ç»Ÿçš„æ—¶åŒºè®¾ç½®
  timestamp + get_timezone_offset()
}

// è¾…åŠ©å‡½æ•°ï¼šè½¬æ¢ä¸ºUTCæ—¶é—´
fn convert_to_utc_time(local_timestamp : Int) -> Int {
  // ç®€åŒ–çš„æ—¶åŒºè½¬æ¢
  local_timestamp - get_timezone_offset()
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–æ—¶åŒºåç§»
fn get_timezone_offset() -> Int {
  // ç®€åŒ–çš„æ—¶åŒºåç§»ï¼ˆå‡è®¾ä¸ºUTC+8ï¼‰
  8 * 3600 // 8å°æ—¶ï¼Œä»¥ç§’ä¸ºå•ä½
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–å¹³å°æ—¶é—´æ ¼å¼
fn get_platform_time_format() -> String {
  match detect_current_platform() {
    Windows => "MM/DD/YYYY HH:mm:ss"
    _ => "DD/MM/YYYY HH:mm:ss"
  }
}

// HTTPå“åº”ç±»å‹
type HttpResponse = {
  status_code : Int,
  headers : Array[(String, String)],
  body : String
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–å¯ç”¨çš„ç½‘ç»œAPI
fn get_available_network_apis() -> Array[String] {
  match detect_current_platform() {
    WebAssembly => ["fetch", "websocket", "webrtc"]
    Windows => ["winhttp", "winsock", "websocket"]
    MacOS => ["cfsocket", "nsurl", "websocket"]
    Linux => ["posix-socket", "libcurl", "websocket"]
    Android => ["java-net", "okhttp", "websocket"]
    IOS => ["nsurl", "cfsocket", "websocket"]
    _ => ["unknown"]
  }
}

// è¾…åŠ©å‡½æ•°ï¼šå‘èµ·HTTPè¯·æ±‚
fn make_http_request(method : String, url : String, headers : Array[(String, String)]) -> Result[HttpResponse, String] {
  // ç®€åŒ–çš„HTTPè¯·æ±‚å®ç°
  // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œä¼šä½¿ç”¨å¹³å°çš„HTTP API
  
  if is_running_in_webassembly() {
    // WebAssemblyç¯å¢ƒä½¿ç”¨fetch API
    make_wasm_http_request(method, url, headers)
  } else {
    // åŸç”Ÿç¯å¢ƒä½¿ç”¨ç³»ç»ŸHTTPåº“
    make_native_http_request(method, url, headers)
  }
}

// è¾…åŠ©å‡½æ•°ï¼šWebAssembly HTTPè¯·æ±‚
fn make_wasm_http_request(method : String, url : String, headers : Array[(String, String)]) -> Result[HttpResponse, String] {
  // ç®€åŒ–çš„WebAssembly HTTPè¯·æ±‚
  // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œä¼šä½¿ç”¨fetch API
  
  if url.contains("httpbin.org") {
    Ok({
      status_code: 200,
      headers: [("Content-Type", "application/json")],
      body: "{\"args\":{},\"headers\":{},\"origin\":\"0.0.0.0\",\"url\":\"" + url + "\"}"
    })
  } else {
    Err("Network error in WebAssembly environment")
  }
}

// è¾…åŠ©å‡½æ•°ï¼šåŸç”ŸHTTPè¯·æ±‚
fn make_native_http_request(method : String, url : String, headers : Array[(String, String)]) -> Result[HttpResponse, String] {
  // ç®€åŒ–çš„åŸç”ŸHTTPè¯·æ±‚
  // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œä¼šä½¿ç”¨ç³»ç»ŸHTTPåº“
  
  if url.contains("httpbin.org") {
    Ok({
      status_code: 200,
      headers: [("Content-Type", "application/json")],
      body: "{\"args\":{},\"headers\":{},\"origin\":\"0.0.0.0\",\"url\":\"" + url + "\"}"
    })
  } else {
    Err("Network error in native environment")
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥SSLæ”¯æŒ
fn check_ssl_support() -> Bool {
  // ç®€åŒ–çš„SSLæ”¯æŒæ£€æŸ¥
  match detect_current_platform() {
    WebAssembly => true // æµè§ˆå™¨é€šå¸¸æ”¯æŒSSL
    _ => true // å‡è®¾æ‰€æœ‰å¹³å°éƒ½æ”¯æŒSSL
  }
}

// ä»£ç†é…ç½®ç±»å‹
type ProxyConfig = {
  host : String,
  port : Int,
  username : Option[String],
  password : Option[String]
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–ä»£ç†é…ç½®
fn get_proxy_configuration() -> Option[ProxyConfig] {
  // ç®€åŒ–çš„ä»£ç†é…ç½®è·å–
  match get_environment_variable("HTTP_PROXY") {
    Some(proxy_url) => parse_proxy_url(proxy_url)
    None => None
  }
}

// è¾…åŠ©å‡½æ•°ï¼šè§£æä»£ç†URL
fn parse_proxy_url(url : String) -> Option[ProxyConfig] {
  // ç®€åŒ–çš„ä»£ç†URLè§£æ
  if url.contains("://") {
    let parts = url.split("://")
    if parts.length() == 2 {
      let host_port = parts[1]
      match host_port.index_of(":") {
        Some(colon_index) => {
          let host = host_port.substring(0, colon_index)
          let port_str = host_port.substring(colon_index + 1, host_port.length() - colon_index - 1)
          
          match Int.parse(port_str) {
            Some(port) => Some({
              host: host,
              port: port,
              username: None,
              password: None
            })
            None => None
          }
        }
        None => None
      }
    } else {
      None
    }
  } else {
    None
  }
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–ç¯å¢ƒå˜é‡
fn get_environment_variable(name : String) -> Option[String] {
  // ç®€åŒ–çš„ç¯å¢ƒå˜é‡è·å–
  match name {
    "PATH" => Some("/usr/bin:/bin")
    "OS" => Some("Linux")
    "ARCH" => Some("x64")
    _ => None
  }
}

// ç³»ç»Ÿä¿¡æ¯ç±»å‹
type SystemInfo = {
  os_name : String,
  os_version : String,
  hostname : String,
  architecture : String
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–ç³»ç»Ÿä¿¡æ¯
fn get_system_information() -> SystemInfo {
  // ç®€åŒ–çš„ç³»ç»Ÿä¿¡æ¯è·å–
  {
    os_name: "Linux",
    os_version: "5.15.0",
    hostname: "test-host",
    architecture: "x64"
  }
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–ä¸´æ—¶ç›®å½•
fn get_temporary_directory() -> String {
  match detect_current_platform() {
    Windows => "C:\\Temp"
    _ => "/tmp"
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
fn directory_exists(path : String) -> Bool {
  // ç®€åŒ–çš„ç›®å½•å­˜åœ¨æ£€æŸ¥
  match path {
    "/tmp" => true
    "C:\\Temp" => true
    "/home/user" => true
    _ => false
  }
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–ç”¨æˆ·ç›®å½•
fn get_user_directory() -> String {
  match detect_current_platform() {
    Windows => "C:\\Users\\TestUser"
    _ => "/home/testuser"
  }
}

// èµ„æºé™åˆ¶ç±»å‹
type ResourceLimits = {
  max_memory : Int,
  max_file_descriptors : Int,
  max_processes : Int
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–èµ„æºé™åˆ¶
fn get_resource_limits() -> ResourceLimits {
  // ç®€åŒ–çš„èµ„æºé™åˆ¶è·å–
  {
    max_memory: 1024 * 1024 * 1024, // 1GB
    max_file_descriptors: 1024,
    max_processes: 256
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦åœ¨WebAssemblyä¸­è¿è¡Œ
fn is_running_in_webassembly() -> Bool {
  // ç®€åŒ–çš„WebAssemblyæ£€æµ‹
  match get_environment_variable("WASM") {
    Some(_) => true
    None => false
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥WebAssemblyå†…å­˜æ“ä½œ
fn check_wasm_memory_operations() -> Bool {
  // ç®€åŒ–çš„WebAssemblyå†…å­˜æ“ä½œæ£€æŸ¥
  true
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥WebAssemblyå¯¼å…¥å‡½æ•°
fn check_wasm_import_functions() -> Bool {
  // ç®€åŒ–çš„WebAssemblyå¯¼å…¥å‡½æ•°æ£€æŸ¥
  true
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥WebAssemblyå¯¼å‡ºå‡½æ•°
fn check_wasm_export_functions() -> Bool {
  // ç®€åŒ–çš„WebAssemblyå¯¼å‡ºå‡½æ•°æ£€æŸ¥
  true
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥æµè§ˆå™¨API
fn check_browser_apis() -> Bool {
  // ç®€åŒ–çš„æµè§ˆå™¨APIæ£€æŸ¥
  true
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥åŸç”Ÿæ–‡ä»¶æ“ä½œ
fn check_native_file_operations() -> Bool {
  // ç®€åŒ–çš„åŸç”Ÿæ–‡ä»¶æ“ä½œæ£€æŸ¥
  true
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥åŸç”Ÿç½‘ç»œæ“ä½œ
fn check_native_network_operations() -> Bool {
  // ç®€åŒ–çš„åŸç”Ÿç½‘ç»œæ“ä½œæ£€æŸ¥
  true
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥åŸç”Ÿç³»ç»Ÿæ“ä½œ
fn check_native_system_operations() -> Bool {
  // ç®€åŒ–çš„åŸç”Ÿç³»ç»Ÿæ“ä½œæ£€æŸ¥
  true
}

// è·¨å¹³å°APIç±»å‹
type CrossPlatformAPI = {
  test_function : (String) -> Result[String, String]
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–è·¨å¹³å°API
fn get_cross_platform_api() -> CrossPlatformAPI {
  // ç®€åŒ–çš„è·¨å¹³å°API
  {
    test_function: fn(param) { Ok(param + "_processed") }
  }
}

// è¾…åŠ©å‡½æ•°ï¼šè§£æåŒ…è·¯å¾„
fn resolve_package_path(package : String) -> String {
  // ç®€åŒ–çš„åŒ…è·¯å¾„è§£æ
  "/packages/" + package
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–åŒ…ä¾èµ–
fn get_package_dependencies() -> Array[String] {
  // ç®€åŒ–çš„åŒ…ä¾èµ–è·å–
  ["moonbitlang/core", "moonbitlang/assertion"]
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–åŒ…ç‰ˆæœ¬
fn get_package_version(package : String) -> Option[String] {
  // ç®€åŒ–çš„åŒ…ç‰ˆæœ¬è·å–
  match package {
    "moonbitlang/core" => Some("0.1.0")
    "moonbitlang/assertion" => Some("0.1.0")
    _ => None
  }
}

// è¾…åŠ©å‡½æ•°ï¼šæ£€æŸ¥ç‰ˆæœ¬æ ¼å¼æ˜¯å¦æœ‰æ•ˆ
fn is_valid_version_format(version : String) -> Bool {
  // ç®€åŒ–çš„ç‰ˆæœ¬æ ¼å¼æ£€æŸ¥
  let parts = version.split(".")
  if parts.length() == 3 {
    let major = parts[0]
    let minor = parts[1]
    let patch = parts[2]
    
    match Int.parse(major) {
      Some(_) => {
        match Int.parse(minor) {
          Some(_) => {
            match Int.parse(patch) {
              Some(_) => true
              None => false
            }
          }
          None => false
        }
      }
      None => false
    }
  } else {
    false
  }
}

// ä»¥ä¸‹æ˜¯ä¸€äº›æœªå®ç°çš„å¹³å°ç‰¹å®šæ£€æŸ¥å‡½æ•°çš„å ä½ç¬¦
// åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿™äº›å‡½æ•°ä¼šåŒ…å«å…·ä½“çš„å¹³å°æ£€æŸ¥é€»è¾‘

fn check_windows_registry_access() -> Bool { false }
fn check_windows_services_access() -> Bool { false }
fn check_windows_dll_access() -> Bool { false }
fn check_macos_bundle_access() -> Bool { false }
fn check_macos_keychain_access() -> Bool { false }
fn check_macos_notification_center() -> Bool { false }
fn check_linux_proc_access() -> Bool { false }
fn check_linux_sys_access() -> Bool { false }
fn check_linux_permission_model() -> Bool { false }
fn check_android_intent_system() -> Bool { false }
fn check_android_content_providers() -> Bool { false }
fn check_android_services() -> Bool { false }
fn check_ios_notification_center() -> Bool { false }
fn check_ios_keychain_access() -> Bool { false }
fn check_ios_app_store_integration() -> Bool { false }
fn check_wasm_memory_model() -> Bool { false }
fn check_wasm_import_exports() -> Bool { false }
fn check_browser_web_apis() -> Bool { false }
fn check_basic_math_operations() -> Bool { true }
fn check_basic_string_operations() -> Bool { true }
fn check_basic_collection_operations() -> Bool { true }
fn check_x86_instruction_set() -> Bool { false }
fn check_x86_alignment() -> Bool { false }
fn check_x64_instruction_set() -> Bool { false }
fn check_x64_alignment() -> Bool { false }
fn check_arm32_instruction_set() -> Bool { false }
fn check_arm32_alignment() -> Bool { false }
fn check_arm64_instruction_set() -> Bool { false }
fn check_arm64_alignment() -> Bool { false }
