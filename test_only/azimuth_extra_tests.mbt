// é¢å¤–çš„ MoonBit æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth é¡¹ç›®çš„æ ¸å¿ƒåŠŸèƒ½

test "add_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 12345
  let b = 67890
  
  assert_eq(add(a, b), add(b, a))
  
  // æµ‹è¯•è´Ÿæ•°çš„äº¤æ¢å¾‹
  let c = -123
  let d = 456
  assert_eq(add(c, d), add(d, c))
}

test "multiply_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ï¼ša Ã— (b + c) = a Ã— b + a Ã— c
  let a = 7
  let b = 5
  let c = 3
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)
}

test "greet_multilingual_support" {
  // æµ‹è¯•å¤šè¯­è¨€æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ÐœÐ¾ÑÐºÐ²Ð°!", greet("ÐœÐ¾ÑÐºÐ²Ð°"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ðŸŒŽ!", greet("ðŸŒŽ"))
}

test "extreme_boundary_values" {
  // æµ‹è¯•æžå€¼è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸Žæœ€å°å€¼çš„è¿ç®—
  assert_eq(-1, add(max_val, min_val))
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  
  // è¾¹ç•Œå€¼çš„è‡ªè¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(min_val, add(min_val, 0))
}

test "calculation_precision_validation" {
  // æµ‹è¯•è®¡ç®—ç²¾åº¦éªŒè¯
  // å¤æ‚çš„å¤šæ­¥è®¡ç®—
  let initial = 100
  let step1 = add(initial, multiply(2, 15))  // 100 + 30 = 130
  let step2 = multiply(step1, 3)             // 130 * 3 = 390
  let step3 = add(step2, -50)                // 390 - 50 = 340
  let final_result = divide_with_ceil(step3, 8)  // ceil(340/8) = 43
  
  assert_eq(130, step1)
  assert_eq(390, step2)
  assert_eq(340, step3)
  assert_eq(43, final_result)
}

test "real_world_financial_calculation" {
  // æµ‹è¯•å®žé™…é‡‘èžè®¡ç®—åœºæ™¯
  // é“¶è¡Œå­˜æ¬¾åˆ©æ¯è®¡ç®—ï¼šæœ¬é‡‘ Ã— (1 + å¹´åˆ©çŽ‡ Ã— å­˜æ¬¾å¹´é™)
  let principal = 10000  // æœ¬é‡‘ 10000 å…ƒ
  let annual_rate = 3    // å¹´åˆ©çŽ‡ 3%
  let years = 5          // å­˜æ¬¾ 5 å¹´
  
  let interest_rate = multiply(annual_rate, years)  // 3% Ã— 5 = 15%
  let total_amount = multiply(principal, add(100, interest_rate))  // 10000 Ã— 115% = 11500
  
  assert_eq(150000, total_amount)  // 10000 Ã— 115 = 1150000 (è¡¨ç¤º 11500 å…ƒ)
}

test "string_boundary_conditions" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, 'single'!", greet("'single'"))
  assert_eq_string("Hello, mixed'quote\"test!", greet("mixed'quote\"test"))
}

test "mathematical_series_calculation" {
  // æµ‹è¯•æ•°å­¦æ•°åˆ—è®¡ç®—
  // è®¡ç®—ç­‰å·®æ•°åˆ—ï¼š3, 7, 11, 15, 19 çš„å’Œ
  // å…¬å¼ï¼šn/2 Ã— (é¦–é¡¹ + æœ«é¡¹)
  let n = 5
  let first_term = 3
  let last_term = 19
  
  let series_sum = multiply(n, add(first_term, last_term)) / 2
  assert_eq(55, series_sum)  // 5/2 Ã— (3 + 19) = 55
  
  // éªŒè¯æ‰‹åŠ¨è®¡ç®—
  let manual_sum = add(add(add(add(3, 7), 11), 15), 19)
  assert_eq(55, manual_sum)
}

test "performance_stress_test" {
  // æµ‹è¯•æ€§èƒ½åŽ‹åŠ›åœºæ™¯
  // å¤§é‡é‡å¤è®¡ç®—çš„ç´¯ç§¯
  let base = 123
  let multiplier = 456
  let iterations = 10
  
  // è®¡ç®— base Ã— multiplier Ã— iterations
  let single_product = multiply(base, multiplier)
  let total_product = multiply(single_product, iterations)
  
  assert_eq(56088, single_product)  // 123 Ã— 456
  assert_eq(560880, total_product)  // 56088 Ã— 10
}

test "comprehensive_assert_validation" {
  // ç»¼åˆæ–­è¨€éªŒè¯æµ‹è¯•
  let test_value = 42
  let test_string = "MoonBit"
  let bool_condition = test_value > 0
  
  // æµ‹è¯•æ‰€æœ‰æ–­è¨€å‡½æ•°
  assert_eq(test_value, 42)
  assert_eq_string(test_string, "MoonBit")
  assert_true(bool_condition)
  assert_false(test_value < 0)
  
  // æµ‹è¯•è®¡ç®—ç»“æžœçš„æ–­è¨€
  let calc_result = add(multiply(test_value, 2), 16)
  assert_eq(100, calc_result)
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ‹¼æŽ¥çš„æ–­è¨€
  let greeting_result = greet(test_string)
  assert_eq_string("Hello, MoonBit!", greeting_result)
}