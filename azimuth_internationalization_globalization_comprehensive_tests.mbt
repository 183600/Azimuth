// Azimuth Comprehensive Internationalization and Globalization Test Suite
// ç»¼åˆå›½é™…åŒ–å’Œå…¨çƒåŒ–æµ‹è¯•å¥—ä»¶

// Test 1: å¤šè¯­è¨€å­—ç¬¦é›†æ”¯æŒæµ‹è¯•
test "multilingual character set support" {
  let i18n_processor = @azimuth.I18nTelemetryProcessor::new()
  
  // é…ç½®å›½é™…åŒ–å¤„ç†å™¨
  let i18n_config = @azimuth.I18nConfig::new()
  @azimuth.I18nConfig::set_default_encoding(i18n_config, @azimuth.Encoding::UTF8)
  @azimuth.I18nConfig::enable_auto_encoding_detection(i18n_config, true)
  @azimuth.I18nConfig::enable_unicode_normalization(i18n_config, true)
  @azimuth.I18nConfig::set_normalization_form(i18n_config, @azimuth.UnicodeNormalizationForm::NFC)
  
  @azimuth.I18nTelemetryProcessor::configure(i18n_processor, i18n_config)
  
  // æµ‹è¯•å¤šç§è¯­è¨€çš„é¥æµ‹æ•°æ®
  let multilingual_data = [
    // è‹±æ–‡
    ("en", "User login successful", "Authentication service processed user login", "User authentication completed"),
    // ä¸­æ–‡
    ("zh", "ç”¨æˆ·ç™»å½•æˆåŠŸ", "è®¤è¯æœåŠ¡å¤„ç†ç”¨æˆ·ç™»å½•", "ç”¨æˆ·èº«ä»½éªŒè¯å®Œæˆ"),
    // æ—¥æ–‡
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ", "èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³ã‚’å‡¦ç†ã—ã¾ã—ãŸ", "ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ"),
    // éŸ©æ–‡
    ("ko", "ì‚¬ìš©ì ë¡œê·¸ì¸ ì„±ê³µ", "ì¸ì¦ ì„œë¹„ìŠ¤ê°€ ì‚¬ìš©ì ë¡œê·¸ì¸ì„ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤", "ì‚¬ìš©ì ì¸ì¦ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"),
    // é˜¿æ‹‰ä¼¯æ–‡
    ("ar", "ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­", "Ù‚Ø§Ù…Øª Ø®Ø¯Ù…Ø© Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø© Ø¨Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", "Ø§ÙƒØªÙ…Ù„Øª Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"),
    // ä¿„æ–‡
    ("ru", "Ğ’Ñ…Ğ¾Ğ´ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾", "Ğ¡Ğ»ÑƒĞ¶Ğ±Ğ° Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»Ğ° Ğ²Ñ…Ğ¾Ğ´ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", "ĞÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°"),
    // å¾·æ–‡
    ("de", "Benutzeranmeldung erfolgreich", "Authentifizierungsdienst hat Benutzeranmeldung verarbeitet", "Benutzerauthentifizierung abgeschlossen"),
    // æ³•æ–‡
    ("fr", "Connexion utilisateur rÃ©ussie", "Le service d'authentification a traitÃ© la connexion utilisateur", "Authentification utilisateur terminÃ©e"),
    // è¥¿ç­ç‰™æ–‡
    ("es", "Inicio de sesiÃ³n de usuario exitoso", "El servicio de autenticaciÃ³n procesÃ³ el inicio de sesiÃ³n del usuario", "AutenticaciÃ³n de usuario completada"),
    // å°åœ°æ–‡
    ("hi", "à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤²à¥‰à¤—à¤¿à¤¨ à¤¸à¤«à¤²", "à¤ªà¥à¤°à¤®à¤¾à¤£à¥€à¤•à¤°à¤£ à¤¸à¥‡à¤µà¤¾ à¤¨à¥‡ à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤²à¥‰à¤—à¤¿à¤¨ à¤•à¥‹ à¤¸à¤‚à¤¸à¤¾à¤§à¤¿à¤¤ à¤•à¤¿à¤¯à¤¾", "à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤ªà¥à¤°à¤®à¤¾à¤£à¥€à¤•à¤°à¤£ à¤ªà¥‚à¤°à¥à¤£ à¤¹à¥à¤†")
  ]
  
  let base_timestamp = @azimuth.Time::now_unix_nanos()
  
  // å¤„ç†å¤šè¯­è¨€æ•°æ®
  for i in 0..multilingual_data.length() - 1 {
    let (locale, short_message, long_message, status_message) = multilingual_data[i]
    let timestamp = base_timestamp + i * 1000000000 // 1ç§’é—´éš”
    
    // åˆ›å»ºå¤šè¯­è¨€å±æ€§
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("user.message.short", @azimuth.StringValue(short_message)),
      ("user.message.long", @azimuth.StringValue(long_message)),
      ("status.message", @azimuth.StringValue(status_message)),
      ("encoding", @azimuth.StringValue("UTF-8"))
    ]
    
    // åˆ›å»ºå¤šè¯­è¨€æ—¥å¿—è®°å½•
    let log_record = @azimuth.LogRecord::new(
      timestamp, 
      @azimuth.Severity::Info, 
      short_message, 
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Log(log_record)
    
    // å¤„ç†å¤šè¯­è¨€é¥æµ‹æ•°æ®
    let processed_data = @azimuth.I18nTelemetryProcessor::process(i18n_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Log(processed_log) => {
        let processed_attributes = @azimuth.LogRecord::attributes(processed_log)
        
        // éªŒè¯è¯­è¨€æ ‡è®°
        let locale_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "locale" })
        match locale_attr {
          Some(attr) => assert_eq(@azimuth.Attribute::value(attr), @azimuth.StringValue(locale))
          None => assert_true(false)
        }
        
        // éªŒè¯æ¶ˆæ¯å†…å®¹å®Œæ•´æ€§
        let short_msg_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "user.message.short" })
        let long_msg_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "user.message.long" })
        let status_msg_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "status.message" })
        
        match (short_msg_attr, long_msg_attr, status_msg_attr) {
          (Some(short), Some(long), Some(status)) => {
            assert_eq(@azimuth.Attribute::value(short), @azimuth.StringValue(short_message))
            assert_eq(@azimuth.Attribute::value(long), @azimuth.StringValue(long_message))
            assert_eq(@azimuth.Attribute::value(status), @azimuth.StringValue(status_message))
          }
          _ => assert_true(false)
        }
        
        // éªŒè¯ç¼–ç å¤„ç†
        let encoding_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "encoding" })
        match encoding_attr {
          Some(attr) => assert_eq(@azimuth.Attribute::value(attr), @azimuth.StringValue("UTF-8"))
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•Unicodeè§„èŒƒåŒ–
  let unicode_test_strings = [
    ("cafÃ©", "cafÃ©"), // å·²è§„èŒƒåŒ–
    ("cafe\u0301", "cafÃ©"), // ç»„åˆå­—ç¬¦è§„èŒƒåŒ–
    ("ä½ å¥½", "ä½ å¥½"), // ä¸­æ–‡å­—ç¬¦
    ("ğŸ‘ğŸ½", "ğŸ‘ğŸ½"), // è¡¨æƒ…ç¬¦å·
    ("ğ”˜ğ”«ğ”¦ğ” ğ”¬ğ”¡ğ”¢", "ğ”˜ğ”«ğ”¦ğ” ğ”¬ğ”¡ğ”¢") // æ•°å­¦ç¬¦å·
  ]
  
  for i in 0..unicode_test_strings.length() - 1 {
    let (input, expected) = unicode_test_strings[i]
    let timestamp = base_timestamp + (i + 100) * 1000000000
    
    let attributes = [
      ("unicode.input", @azimuth.StringValue(input)),
      ("unicode.expected", @azimuth.StringValue(expected))
    ]
    
    let metric_point = @azimuth.MetricPoint::new(timestamp, "unicode.test", 1.0, attributes)
    let telemetry_data = @azimuth.TelemetryData::Metric(metric_point)
    
    let processed_data = @azimuth.I18nTelemetryProcessor::process(i18n_processor, telemetry_data)
    
    match processed_data {
      @azimuth.TelemetryData::Metric(processed_metric) => {
        let processed_attributes = @azimuth.MetricPoint::attributes(processed_metric)
        let normalized_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "unicode.normalized" })
        
        match normalized_attr {
          Some(attr) => {
            let normalized_value = match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(value) => value
              _ => ""
            }
            assert_eq(normalized_value, expected)
          }
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  assert_true(true)
}

// Test 2: æœ¬åœ°åŒ–æ ¼å¼å’Œæ—¶åŒºå¤„ç†æµ‹è¯•
test "localized formatting and timezone handling" {
  let localization_processor = @azimuth.LocalizationProcessor::new()
  
  // é…ç½®æœ¬åœ°åŒ–å¤„ç†å™¨
  let localization_config = @azimuth.LocalizationConfig::new()
  @azimuth.LocalizationConfig::set_default_locale(localization_config, "en-US")
  @azimuth.LocalizationConfig::set_default_timezone(localization_config, "UTC")
  @azimuth.LocalizationConfig::enable_date_localization(localization_config, true)
  @azimuth.LocalizationConfig::enable_number_localization(localization_config, true)
  @azimuth.LocalizationConfig::enable_currency_localization(localization_config, true)
  
  @azimuth.LocalizationProcessor::configure(localization_processor, localization_config)
  
  // æµ‹è¯•ä¸åŒåœ°åŒºçš„æ—¥æœŸæ—¶é—´æ ¼å¼
  let datetime_locales = [
    ("en-US", "MM/DD/YYYY, hh:mm:ss A"),
    ("en-GB", "DD/MM/YYYY, HH:mm:ss"),
    ("de-DE", "DD.MM.YYYY, HH:mm:ss"),
    ("fr-FR", "DD/MM/YYYY, HH:mm:ss"),
    ("ja-JP", "YYYY/MM/DD, HH:mm:ss"),
    ("zh-CN", "YYYYå¹´MMæœˆDDæ—¥, HH:mm:ss"),
    ("ar-SA", "DD/MM/YYYY, HH:mm:ss"),
    ("ru-RU", "DD.MM.YYYY, HH:mm:ss")
  ]
  
  let test_timestamp = 1672531200000000000 // 2023-01-01 00:00:00 UTC
  
  for i in 0..datetime_locales.length() - 1 {
    let (locale, expected_pattern) = datetime_locales[i]
    
    // åˆ›å»ºæœ¬åœ°åŒ–æ—¥æœŸæ—¶é—´
    let localized_datetime = @azimuth.LocalizationProcessor::format_datetime(
      localization_processor, 
      test_timestamp, 
      locale
    )
    
    // éªŒè¯æœ¬åœ°åŒ–æ ¼å¼
    assert_true(@azimuth.String::length(localized_datetime) > 0)
    
    // åˆ›å»ºåŒ…å«æœ¬åœ°åŒ–æ—¥æœŸæ—¶é—´çš„é¥æµ‹æ•°æ®
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("timestamp.utc", @azimuth.IntValue(test_timestamp)),
      ("timestamp.localized", @azimuth.StringValue(localized_datetime)),
      ("timezone", @azimuth.StringValue("UTC"))
    ]
    
    let log_record = @azimuth.LogRecord::new(
      test_timestamp + i * 1000000000,
      @azimuth.Severity::Info,
      "Localized datetime test",
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Log(log_record)
    let processed_data = @azimuth.LocalizationProcessor::process(localization_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Log(processed_log) => {
        let processed_attributes = @azimuth.LogRecord::attributes(processed_log)
        let localized_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "timestamp.localized" })
        
        match localized_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(value) => assert_eq(value, localized_datetime)
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•æ•°å­—æœ¬åœ°åŒ–
  let number_locales = [
    ("en-US", "1,234,567.89"),
    ("de-DE", "1.234.567,89"),
    ("fr-FR", "1 234 567,89"),
    ("ja-JP", "1,234,567.89"),
    ("zh-CN", "1,234,567.89"),
    ("ar-SA", "1,234,567.89")
  ]
  
  let test_number = 1234567.89
  
  for i in 0..number_locales.length() - 1 {
    let (locale, expected_format) = number_locales[i]
    
    // åˆ›å»ºæœ¬åœ°åŒ–æ•°å­—
    let localized_number = @azimuth.LocalizationProcessor::format_number(
      localization_processor, 
      test_number, 
      locale
    )
    
    // éªŒè¯æœ¬åœ°åŒ–æ•°å­—æ ¼å¼
    assert_true(@azimuth.String::length(localized_number) > 0)
    
    // åˆ›å»ºåŒ…å«æœ¬åœ°åŒ–æ•°å­—çš„é¥æµ‹æ•°æ®
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("number.raw", @azimuth.FloatValue(test_number)),
      ("number.localized", @azimuth.StringValue(localized_number))
    ]
    
    let metric_point = @azimuth.MetricPoint::new(
      test_timestamp + (i + 100) * 1000000000,
      "localized.number.test",
      test_number,
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Metric(metric_point)
    let processed_data = @azimuth.LocalizationProcessor::process(localization_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Metric(processed_metric) => {
        let processed_attributes = @azimuth.MetricPoint::attributes(processed_metric)
        let localized_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "number.localized" })
        
        match localized_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(value) => assert_eq(value, localized_number)
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•æ—¶åŒºè½¬æ¢
  let timezones = [
    ("UTC", 0),
    ("America/New_York", -5),
    ("Europe/London", 0),
    ("Europe/Paris", 1),
    ("Asia/Tokyo", 9),
    ("Asia/Shanghai", 8),
    ("Australia/Sydney", 11)
  ]
  
  for i in 0..timezones.length() - 1 {
    let (timezone, offset_hours) = timezones[i]
    
    // è½¬æ¢æ—¶åŒº
    let converted_timestamp = @azimuth.LocalizationProcessor::convert_timezone(
      localization_processor,
      test_timestamp,
      "UTC",
      timezone
    )
    
    // éªŒè¯æ—¶åŒºè½¬æ¢
    let expected_offset = offset_hours * 3600000000000 // çº³ç§’
    assert_eq(converted_timestamp, test_timestamp + expected_offset)
    
    // åˆ›å»ºåŒ…å«æ—¶åŒºè½¬æ¢çš„é¥æµ‹æ•°æ®
    let attributes = [
      ("timezone.source", @azimuth.StringValue("UTC")),
      ("timezone.target", @azimuth.StringValue(timezone)),
      ("timestamp.source", @azimuth.IntValue(test_timestamp)),
      ("timestamp.converted", @azimuth.IntValue(converted_timestamp)),
      ("timezone.offset", @azimuth.IntValue(expected_offset))
    ]
    
    let span_data = @azimuth.SpanData::new(
      @azimuth.SpanContext::new(@azimuth.TraceId::new(), @azimuth.SpanId::new(), []),
      "timezone.conversion.test",
      test_timestamp,
      converted_timestamp,
      @azimuth.SpanKind::Internal,
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Span(span_data)
    let processed_data = @azimuth.LocalizationProcessor::process(localization_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Span(processed_span) => {
        let processed_attributes = @azimuth.SpanData::attributes(processed_span)
        let converted_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "timestamp.converted" })
        
        match converted_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.IntValue(value) => assert_eq(value, converted_timestamp)
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  assert_true(true)
}

// Test 3: å³åˆ°å·¦(RTL)è¯­è¨€æ”¯æŒæµ‹è¯•
test "right-to-left (RTL) language support" {
  let rtl_processor = @azimuth.RTLTelemetryProcessor::new()
  
  // é…ç½®RTLå¤„ç†å™¨
  let rtl_config = @azimuth.RTLConfig::new()
  @azimuth.RTLConfig::enable_bidirectional_text(rtl_config, true)
  @azimuth.RTLConfig::enable_auto_direction_detection(rtl_config, true)
  @azimuth.RTLConfig::enable_text_mirroring(rtl_config, true)
  
  @azimuth.RTLTelemetryProcessor::configure(rtl_processor, rtl_config)
  
  // æµ‹è¯•RTLè¯­è¨€æ•°æ®
  let rtl_languages = [
    ("ar", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", "Ø®Ø¯Ù…Ø© Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©", "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­"),
    ("he", "×©×œ×•× ×¢×•×œ×", "×©×™×¨×•×ª ××™××•×ª", "×”×›× ×™×¡×” ×”×¦×œ×™×—×”"),
    ("fa", "Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§", "Ø³Ø±ÙˆÛŒØ³ Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª", "ÙˆØ±ÙˆØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯"),
    ("ur", "ÛÛŒÙ„Ùˆ ÙˆØ±Ù„Úˆ", "ØªØµØ¯ÛŒÙ‚ Ø³Ø±ÙˆØ³", "Ù„Ø§Ú¯ Ø§Ù† Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ ÛÙˆØ§")
  ]
  
  let base_timestamp = @azimuth.Time::now_unix_nanos()
  
  for i in 0..rtl_languages.length() - 1 {
    let (locale, greeting, service, message) = rtl_languages[i]
    let timestamp = base_timestamp + i * 1000000000
    
    // åˆ›å»ºRTLæ–‡æœ¬å±æ€§
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("text.direction", @azimuth.StringValue("RTL")),
      ("greeting.message", @azimuth.StringValue(greeting)),
      ("service.name", @azimuth.StringValue(service)),
      ("status.message", @azimuth.StringValue(message))
    ]
    
    // åˆ›å»ºRTLæ—¥å¿—è®°å½•
    let log_record = @azimuth.LogRecord::new(
      timestamp,
      @azimuth.Severity::Info,
      greeting,
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Log(log_record)
    let processed_data = @azimuth.RTLTelemetryProcessor::process(rtl_processor, telemetry_data)
    
    // éªŒè¯RTLå¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Log(processed_log) => {
        let processed_attributes = @azimuth.LogRecord::attributes(processed_log)
        
        // éªŒè¯æ–‡æœ¬æ–¹å‘æ ‡è®°
        let direction_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "text.direction" })
        match direction_attr {
          Some(attr) => assert_eq(@azimuth.Attribute::value(attr), @azimuth.StringValue("RTL"))
          None => assert_true(false)
        }
        
        // éªŒè¯RTLæ–‡æœ¬å†…å®¹å®Œæ•´æ€§
        let greeting_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "greeting.message" })
        let service_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "service.name" })
        let status_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "status.message" })
        
        match (greeting_attr, service_attr, status_attr) {
          (Some(greeting), Some(service), Some(status)) => {
            assert_eq(@azimuth.Attribute::value(greeting), @azimuth.StringValue(greeting))
            assert_eq(@azimuth.Attribute::value(service), @azimuth.StringValue(service))
            assert_eq(@azimuth.Attribute::value(status), @azimuth.StringValue(message))
          }
          _ => assert_true(false)
        }
        
        // éªŒè¯åŒå‘æ–‡æœ¬å¤„ç†
        let bidi_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "text.bidi.processed" })
        match bidi_attr {
          Some(attr) => assert_eq(@azimuth.Attribute::value(attr), @azimuth.BoolValue(true))
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•æ··åˆLTR/RTLæ–‡æœ¬
  let mixed_direction_texts = [
    ("Hello Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", "en-ar", "Mixed greeting"),
    ("API ×©×™×¨×•×ª API", "en-he", "API service name"),
    ("User Ú©Ø§Ø±Ø¨Ø± User", "en-fa", "User label"),
    ("Data ÚˆÛŒÙ¹Ø§ Data", "en-ur", "Data label")
  ]
  
  for i in 0..mixed_direction_texts.length() - 1 {
    let (text, locale, description) = mixed_direction_texts[i]
    let timestamp = base_timestamp + (i + 100) * 1000000000
    
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("text.mixed", @azimuth.StringValue(text)),
      ("text.description", @azimuth.StringValue(description)),
      ("text.direction", @azimuth.StringValue("mixed"))
    ]
    
    let metric_point = @azimuth.MetricPoint::new(
      timestamp,
      "mixed.direction.test",
      1.0,
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Metric(metric_point)
    let processed_data = @azimuth.RTLTelemetryProcessor::process(rtl_processor, telemetry_data)
    
    match processed_data {
      @azimuth.TelemetryData::Metric(processed_metric) => {
        let processed_attributes = @azimuth.MetricPoint::attributes(processed_metric)
        
        // éªŒè¯æ··åˆæ–¹å‘æ–‡æœ¬å¤„ç†
        let mixed_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "text.mixed.processed" })
        match mixed_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(processed_text) => {
                // éªŒè¯æ–‡æœ¬å†…å®¹ä¿æŒä¸å˜ï¼Œä½†æ–¹å‘æ ‡è®°å·²æ·»åŠ 
                assert_true(@azimuth.String::length(processed_text) > 0)
              }
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
        
        // éªŒè¯åŒå‘æ–‡æœ¬åˆ†æ
        let analysis_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "text.direction.analysis" })
        match analysis_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(analysis) => assert_eq(analysis, "mixed")
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  assert_true(true)
}

// Test 4: åŒºåŸŸç‰¹å®šåº¦é‡å•ä½å’Œæ ¼å¼æµ‹è¯•
test "locale-specific units and formatting" {
  let unit_processor = @azimuth.LocaleUnitProcessor::new()
  
  // é…ç½®å•ä½å¤„ç†å™¨
  let unit_config = @azimuth.LocaleUnitConfig::new()
  @azimuth.LocaleUnitConfig::enable_automatic_conversion(unit_config, true)
  @azimuth.LocaleUnitConfig::enable_localized_display(unit_config, true)
  @azimuth.LocaleUnitConfig::set_preferred_units(unit_config, "en-US", @azimuth.UnitSystem::Imperial)
  @azimuth.LocaleUnitConfig::set_preferred_units(unit_config, "de-DE", @azimuth.UnitSystem::Metric)
  
  @azimuth.LocaleUnitProcessor::configure(unit_processor, unit_config)
  
  // æµ‹è¯•ä¸åŒåœ°åŒºçš„å•ä½è½¬æ¢
  let unit_conversions = [
    ("en-US", "imperial", "length", "1000", "meters", "3280.84", "feet"),
    ("en-US", "imperial", "weight", "70", "kg", "154.32", "lbs"),
    ("en-US", "imperial", "temperature", "20", "celsius", "68", "fahrenheit"),
    ("de-DE", "metric", "length", "3280.84", "feet", "1000", "meters"),
    ("de-DE", "metric", "weight", "154.32", "lbs", "70", "kg"),
    ("de-DE", "metric", "temperature", "68", "fahrenheit", "20", "celsius"),
    ("ja-JP", "metric", "length", "1000", "meters", "1000", "meters"),
    ("ja-JP", "metric", "weight", "70", "kg", "70", "kg"),
    ("ja-JP", "metric", "temperature", "20", "celsius", "20", "celsius")
  ]
  
  let base_timestamp = @azimuth.Time::now_unix_nanos()
  
  for i in 0..unit_conversions.length() - 1 {
    let (locale, system, unit_type, value, from_unit, expected_value, to_unit) = unit_conversions[i]
    let timestamp = base_timestamp + i * 1000000000
    
    // æ‰§è¡Œå•ä½è½¬æ¢
    let conversion_result = @azimuth.LocaleUnitProcessor::convert_unit(
      unit_processor,
      value.to_float(),
      from_unit,
      to_unit,
      locale
    )
    
    // éªŒè¯è½¬æ¢ç»“æœ
    assert_true(@azimuth.Math::abs(conversion_result - expected_value.to_float()) < 0.01)
    
    // åˆ›å»ºåŒ…å«å•ä½è½¬æ¢çš„é¥æµ‹æ•°æ®
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("unit.system", @azimuth.StringValue(system)),
      ("unit.type", @azimuth.StringValue(unit_type)),
      ("value.original", @azimuth.FloatValue(value.to_float())),
      ("unit.original", @azimuth.StringValue(from_unit)),
      ("value.converted", @azimuth.FloatValue(conversion_result)),
      ("unit.converted", @azimuth.StringValue(to_unit))
    ]
    
    let metric_point = @azimuth.MetricPoint::new(
      timestamp,
      "unit.conversion.test",
      conversion_result,
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Metric(metric_point)
    let processed_data = @azimuth.LocaleUnitProcessor::process(unit_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Metric(processed_metric) => {
        let processed_attributes = @azimuth.MetricPoint::attributes(processed_metric)
        
        // éªŒè¯è½¬æ¢å€¼
        let converted_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "value.converted" })
        match converted_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.FloatValue(value) => assert_true(@azimuth.Math::abs(value - conversion_result) < 0.01)
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
        
        // éªŒè¯æœ¬åœ°åŒ–æ˜¾ç¤ºæ ¼å¼
        let display_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "value.display" })
        match display_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(display_value) => assert_true(@azimuth.String::length(display_value) > 0)
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•è´§å¸æ ¼å¼åŒ–
  let currency_formats = [
    ("en-US", "USD", "$1,234.56"),
    ("de-DE", "EUR", "1.234,56 â‚¬"),
    ("fr-FR", "EUR", "1 234,56 â‚¬"),
    ("ja-JP", "JPY", "Â¥1,235"),
    ("zh-CN", "CNY", "Â¥1,234.56"),
    ("en-GB", "GBP", "Â£1,234.56")
  ]
  
  let test_amount = 1234.56
  
  for i in 0..currency_formats.length() - 1 {
    let (locale, currency, expected_format) = currency_formats[i]
    let timestamp = base_timestamp + (i + 100) * 1000000000
    
    // æ ¼å¼åŒ–è´§å¸
    let formatted_currency = @azimuth.LocaleUnitProcessor::format_currency(
      unit_processor,
      test_amount,
      currency,
      locale
    )
    
    // åˆ›å»ºåŒ…å«è´§å¸æ ¼å¼çš„é¥æµ‹æ•°æ®
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("currency", @azimuth.StringValue(currency)),
      ("amount.raw", @azimuth.FloatValue(test_amount)),
      ("amount.formatted", @azimuth.StringValue(formatted_currency))
    ]
    
    let span_data = @azimuth.SpanData::new(
      @azimuth.SpanContext::new(@azimuth.TraceId::new(), @azimuth.SpanId::new(), []),
      "currency.format.test",
      timestamp,
      timestamp + 1000000000,
      @azimuth.SpanKind::Internal,
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Span(span_data)
    let processed_data = @azimuth.LocaleUnitProcessor::process(unit_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Span(processed_span) => {
        let processed_attributes = @azimuth.SpanData::attributes(processed_span)
        
        // éªŒè¯æ ¼å¼åŒ–è´§å¸
        let formatted_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "amount.formatted" })
        match formatted_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(formatted) => assert_eq(formatted, formatted_currency)
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  assert_true(true)
}

// Test 5: æ–‡åŒ–ç‰¹å®šçº¦å®šå’Œåˆè§„æ€§æµ‹è¯•
test "cultural conventions and compliance" {
  let cultural_processor = @azimuth.CulturalComplianceProcessor::new()
  
  // é…ç½®æ–‡åŒ–å¤„ç†å™¨
  let cultural_config = @azimuth.CulturalConfig::new()
  @azimuth.CulturalConfig::enable_name_formatting(cultural_config, true)
  @azimuth.CulturalConfig::enable_address_formatting(cultural_config, true)
  @azimuth.CulturalConfig::enable_phone_formatting(cultural_config, true)
  @azimuth.CulturalConfig::enable_data_privacy_compliance(cultural_config, true)
  @azimuth.CulturalConfig::set_gdpr_compliance(cultural_config, true)
  
  @azimuth.CulturalComplianceProcessor::configure(cultural_processor, cultural_config)
  
  // æµ‹è¯•å§“åæ ¼å¼åŒ–
  let name_formats = [
    ("en-US", "John", "Doe", "John Doe", "Mr. John Doe"),
    ("ja-JP", "ç”°ä¸­", "å¤ªéƒ", "ç”°ä¸­ å¤ªéƒ", "ç”°ä¸­ å¤ªéƒæ§˜"),
    ("ko-KR", "ê¹€", "ì² ìˆ˜", "ê¹€ì² ìˆ˜", "ê¹€ì² ìˆ˜ ë‹˜"),
    ("zh-CN", "å¼ ", "ä¸‰", "å¼ ä¸‰", "å¼ ä¸‰å…ˆç”Ÿ"),
    ("ar-SA", "Ù…Ø­Ù…Ø¯", "Ø£Ø­Ù…Ø¯", "Ù…Ø­Ù…Ø¯ Ø£Ø­Ù…Ø¯", "Ø§Ù„Ø³ÙŠØ¯ Ù…Ø­Ù…Ø¯ Ø£Ø­Ù…Ø¯"),
    ("hu-HU", "Nagy", "JÃ¡nos", "Nagy JÃ¡nos", "Nagy JÃ¡nos Ãºr")
  ]
  
  let base_timestamp = @azimuth.Time::now_unix_nanos()
  
  for i in 0..name_formats.length() - 1 {
    let (locale, first_name, last_name, full_name, formal_name) = name_formats[i]
    let timestamp = base_timestamp + i * 1000000000
    
    // æ ¼å¼åŒ–å§“å
    let formatted_full_name = @azimuth.CulturalComplianceProcessor::format_name(
      cultural_processor,
      first_name,
      last_name,
      "full",
      locale
    )
    
    let formatted_formal_name = @azimuth.CulturalComplianceProcessor::format_name(
      cultural_processor,
      first_name,
      last_name,
      "formal",
      locale
    )
    
    // éªŒè¯å§“åæ ¼å¼
    assert_eq(formatted_full_name, full_name)
    assert_eq(formatted_formal_name, formal_name)
    
    // åˆ›å»ºåŒ…å«å§“åæ ¼å¼çš„é¥æµ‹æ•°æ®
    let attributes = [
      ("locale", @azimuth.StringValue(locale)),
      ("name.first", @azimuth.StringValue(first_name)),
      ("name.last", @azimuth.StringValue(last_name)),
      ("name.full", @azimuth.StringValue(formatted_full_name)),
      ("name.formal", @azimuth.StringValue(formatted_formal_name))
    ]
    
    let log_record = @azimuth.LogRecord::new(
      timestamp,
      @azimuth.Severity::Info,
      "User profile created",
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Log(log_record)
    let processed_data = @azimuth.CulturalComplianceProcessor::process(cultural_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Log(processed_log) => {
        let processed_attributes = @azimuth.LogRecord::attributes(processed_log)
        
        // éªŒè¯å§“åæ ¼å¼åŒ–
        let full_name_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "name.full" })
        let formal_name_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "name.formal" })
        
        match (full_name_attr, formal_name_attr) {
          (Some(full), Some(formal)) => {
            assert_eq(@azimuth.Attribute::value(full), @azimuth.StringValue(formatted_full_name))
            assert_eq(@azimuth.Attribute::value(formal), @azimuth.StringValue(formatted_formal_name))
          }
          _ => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•æ•°æ®éšç§åˆè§„æ€§
  let pii_data = [
    ("email", "user@example.com"),
    ("phone", "+1-555-123-4567"),
    ("ssn", "123-45-6789"),
    ("credit_card", "4532-1234-5678-9012")
  ]
  
  for i in 0..pii_data.length() - 1 {
    let (data_type, original_value) = pii_data[i]
    let timestamp = base_timestamp + (i + 100) * 1000000000
    
    // åº”ç”¨æ•°æ®éšç§ä¿æŠ¤
    let masked_value = @azimuth.CulturalComplianceProcessor::mask_pii(
      cultural_processor,
      original_value,
      data_type,
      "GDPR"
    )
    
    // éªŒè¯PIIæ©ç 
    assert_true(masked_value != original_value)
    assert_true(@azimuth.String::length(masked_value) > 0)
    
    // åˆ›å»ºåŒ…å«PIIä¿æŠ¤çš„é¥æµ‹æ•°æ®
    let attributes = [
      ("data.type", @azimuth.StringValue(data_type)),
      ("data.original", @azimuth.StringValue(original_value)),
      ("data.masked", @azimuth.StringValue(masked_value)),
      ("privacy.regulation", @azimuth.StringValue("GDPR")),
      ("data.pii", @azimuth.BoolValue(true))
    ]
    
    let span_data = @azimuth.SpanData::new(
      @azimuth.SpanContext::new(@azimuth.TraceId::new(), @azimuth.SpanId::new(), []),
      "pii.protection.test",
      timestamp,
      timestamp + 1000000000,
      @azimuth.SpanKind::Internal,
      attributes
    )
    
    let telemetry_data = @azimuth.TelemetryData::Span(span_data)
    let processed_data = @azimuth.CulturalComplianceProcessor::process(cultural_processor, telemetry_data)
    
    // éªŒè¯å¤„ç†ç»“æœ
    match processed_data {
      @azimuth.TelemetryData::Span(processed_span) => {
        let processed_attributes = @azimuth.SpanData::attributes(processed_span)
        
        // éªŒè¯åŸå§‹æ•°æ®å·²è¢«ç§»é™¤
        let original_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "data.original" })
        assert_eq(original_attr, None) // åŸå§‹æ•°æ®åº”è¯¥è¢«ç§»é™¤
        
        // éªŒè¯æ©ç æ•°æ®å­˜åœ¨
        let masked_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "data.masked" })
        match masked_attr {
          Some(attr) => {
            match @azimuth.Attribute::value(attr) {
              @azimuth.StringValue(value) => assert_eq(value, masked_value)
              _ => assert_true(false)
            }
          }
          None => assert_true(false)
        }
        
        // éªŒè¯åˆè§„æ€§æ ‡è®°
        let compliance_attr = processed_attributes.find(fn(attr) { @azimuth.Attribute::key(attr) == "privacy.compliance" })
        match compliance_attr {
          Some(attr) => assert_eq(@azimuth.Attribute::value(attr), @azimuth.BoolValue(true))
          None => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  assert_true(true)
}