{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

module AdditionalQuickCheckTestSpec (spec) where

import Test.Hspec
import Test.QuickCheck
import Control.Exception (try, SomeException)
import Control.Monad (replicateM_)
import qualified Data.Text as Text
import Data.Text (pack, unpack)
import System.IO.Unsafe (unsafePerformIO)
import Data.Char (isAscii, isLetter, isDigit)
import Data.List (isInfixOf)

import Azimuth.Telemetry (productionConfig)

-- | Arbitrary instance for LogLevel
instance Arbitrary LogLevel where
  arbitrary = elements [Debug, Info, Warn, Error]

-- | ç”Ÿæˆéžç©ºå­—ç¬¦ä¸²çš„ç”Ÿæˆå™¨
nonEmptyString :: Gen String
nonEmptyString = listOf1 $ elements $ ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9'] ++ "_."

-- | ç”ŸæˆASCIIå­—ç¬¦ä¸²çš„ç”Ÿæˆå™¨
asciiString :: Gen String
asciiString = listOf $ elements $ filter isAscii $ ['\0'..'~']

-- | ç”Ÿæˆå­—æ¯æ•°å­—å­—ç¬¦ä¸²çš„ç”Ÿæˆå™¨
alphanumericString :: Gen String
alphanumericString = listOf $ elements $ ['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9']

-- | ç”Ÿæˆæœ‰é™èŒƒå›´å†…çš„Doubleå€¼
reasonableDouble :: Gen Double
reasonableDouble = choose (-1000000.0, 1000000.0)

-- | ç”ŸæˆéžNaNçš„Doubleå€¼
nonNaNDouble :: Gen Double
nonNaNDouble = suchThat reasonableDouble (not . isNaN)

spec :: Spec
spec = describe "Additional QuickCheck Test Suite" $ do
  
  -- æµ‹è¯•1: Metricåˆ›å»ºå’Œè®°å½•çš„å±žæ€§
  describe "Metric Creation and Recording Properties" $ do
    it "should preserve metric identity after recording values" $ property $
      \name unit value1 value2 ->
        let metric = unsafePerformIO $ createMetricWithInitialValue (pack name) (pack unit) 0.0
            _ = unsafePerformIO $ recordMetric metric value1
            _ = unsafePerformIO $ recordMetric metric value2
            actualValue = unsafePerformIO $ metricValue metric
        in not (isNaN actualValue) && actualValue == value1 + value2
    
    it "should handle metric recording with any reasonable double" $ property $
      \name unit value ->
        let metric = unsafePerformIO $ createMetricWithInitialValue (pack name) (pack unit) 0.0
            _ = unsafePerformIO $ recordMetric metric value
            actualValue = unsafePerformIO $ metricValue metric
        in not (isNaN actualValue) && actualValue == value

  -- æµ‹è¯•2: SimpleMetricçš„å±žæ€§
  describe "SimpleMetric Properties" $ do
    it "should maintain commutative property for value recording" $ property $
      \name unit value1 value2 ->
        let metric1 = createSimpleMetric (pack name) (pack unit) 0.0
            metric2 = createSimpleMetric (pack name) (pack unit) 0.0
            -- Record in different order
            result1 = simpleMetricValue $ recordSimpleMetric (recordSimpleMetric metric1 value1) value2
            result2 = simpleMetricValue $ recordSimpleMetric (recordSimpleMetric metric2 value2) value1
        in result1 == result2 && result1 == value1 + value2
    
    it "should maintain associative property for value recording" $ property $
      \name unit value1 value2 value3 ->
        let metric1 = createSimpleMetric (pack name) (pack unit) 0.0
            -- Different grouping
            result1 = simpleMetricValue $ recordSimpleMetric (recordSimpleMetric (recordSimpleMetric metric1 value1) value2) value3
            result2 = value1 + (value2 + value3)
        in result1 == result2 && result1 == value1 + value2 + value3

  -- æµ‹è¯•3: TelemetryConfigçš„å±žæ€§
  describe "TelemetryConfig Properties" $ do
    it "should handle any string values in config fields" $ property $
      \svcName svcVersion ->
        let config = TelemetryConfig (pack svcName) (pack svcVersion) True True True False
        in unpack (serviceName config) == svcName && unpack (serviceVersion config) == svcVersion
    
    it "should maintain boolean field independence" $ property $
      \svcName svcVersion metrics tracing logging debug ->
        let config = TelemetryConfig (pack svcName) (pack svcVersion) metrics tracing logging debug
        in unpack (serviceName config) == svcName &&
           unpack (serviceVersion config) == svcVersion &&
           enableMetrics config == metrics &&
           enableTracing config == tracing &&
           enableLogging config == logging &&
           enableDebugOutput config == debug

  -- æµ‹è¯•4: Spançš„å±žæ€§
  describe "Span Properties" $ do
    it "should preserve span identity with different trace and span IDs" $ property $
      \name traceId spanId ->
        let span = Span (pack name) (pack traceId) (pack spanId)
        in unpack (spanName span) == name &&
           spanTraceId span == pack traceId &&
           spanSpanId span == pack spanId
    
    it "should handle span creation with any name" $ property $
      \name ->
        let span = unsafePerformIO $ createSpan (pack name)
            hasValidTraceId = not $ Text.null $ spanTraceId span
            hasValidSpanId = not $ Text.null $ spanSpanId span
        in unpack (spanName span) == name && hasValidTraceId && hasValidSpanId

  -- æµ‹è¯•5: Loggerçš„å±žæ€§
  describe "Logger Properties" $ do
    it "should handle all log levels consistently" $ property $
      \name ->
        let levels = [Debug, Info, Warn, Error]
            testLevel = levels !! (abs (length name) `mod` length levels)
            logger = Logger (pack name) testLevel
        in unpack (loggerName logger) == name && loggerLevel logger == testLevel
    
    it "should maintain logger properties across creation" $ property $
      \name level ->
        let logger = unsafePerformIO $ createLogger (pack name) level
        in unpack (loggerName logger) == name && loggerLevel logger == level

  -- æµ‹è¯•6: è¾¹ç•Œæ¡ä»¶å’Œç‰¹æ®Šå€¼çš„å±žæ€§
  describe "Boundary Conditions and Special Values" $ do
    it "should handle zero and identity values in metrics" $ property $
      \name unit ->
        let metric = unsafePerformIO $ createMetricWithInitialValue (pack name) (pack unit) 0.0
            _ = unsafePerformIO $ recordMetric metric 0.0
            actualValue = unsafePerformIO $ metricValue metric
        in actualValue == 0.0
    
    it "should handle negative values in metrics" $ property $
      \name unit value ->
        let metric = unsafePerformIO $ createMetricWithInitialValue (pack name) (pack unit) 0.0
            negativeValue = abs value * (-1)
            _ = unsafePerformIO $ recordMetric metric negativeValue
            actualValue = unsafePerformIO $ metricValue metric
        in actualValue == negativeValue

  -- æµ‹è¯•7: å­—ç¬¦ä¸²å¤„ç†çš„å±žæ€§
  describe "String Handling Properties" $ do
    it "should handle empty strings in metric names and units" $ property $
      \value ->
        let metric = unsafePerformIO $ createMetricWithInitialValue "" "" 0.0
            _ = unsafePerformIO $ recordMetric metric value
            actualValue = unsafePerformIO $ metricValue metric
        in metricName metric == "" && metricUnit metric == "" && actualValue == value
    
    it "should handle unicode strings in all text fields" $ property $
      \asciiValue ->
        let unicodeText = pack $ "æµ‹è¯•ðŸš€" ++ asciiValue
            metric = unsafePerformIO $ createMetricWithInitialValue unicodeText unicodeText 0.0
            logger = unsafePerformIO $ createLogger unicodeText Info
            span = unsafePerformIO $ createSpan unicodeText
        in metricName metric == unicodeText &&
           metricUnit metric == unicodeText &&
           loggerName logger == unicodeText &&
           spanName span == unicodeText

  -- æµ‹è¯•8: æ•°å€¼è¿ç®—çš„å±žæ€§
  describe "Numeric Operation Properties" $ do
    it "should maintain additive identity in metric recording" $ property $
      \name unit value ->
        let nonEmptyName = if null name then "default" else name
            nonEmptyUnit = if null unit then "default" else unit
            metric = unsafePerformIO $ createMetricWithInitialValue (pack nonEmptyName) (pack nonEmptyUnit) value
            _ = unsafePerformIO $ recordMetric metric 0.0
            actualValue = unsafePerformIO $ metricValue metric
        in not (isNaN actualValue) && actualValue == value
    
    it "should maintain additive inverse in metric recording" $ property $
      \name unit value ->
        let nonEmptyName = if null name then "default" else name
            nonEmptyUnit = if null unit then "default" else unit
            metric = unsafePerformIO $ createMetricWithInitialValue (pack nonEmptyName) (pack nonEmptyUnit) value
            _ = unsafePerformIO $ recordMetric metric (-value)
            actualValue = unsafePerformIO $ metricValue metric
        in not (isNaN actualValue) && 
           (if isInfinite value 
            then isInfinite actualValue 
            else abs actualValue < 1.0e-10)

  -- æµ‹è¯•9: å¤åˆæ“ä½œçš„å±žæ€§
  describe "Composite Operation Properties" $ do
    it "should handle multiple metric operations consistently" $ property $
      \name unit value1 value2 value3 ->
        let nonEmptyName = if null name then "default" else name
            nonEmptyUnit = if null unit then "default" else unit
            metric = unsafePerformIO $ createMetricWithInitialValue (pack nonEmptyName) (pack nonEmptyUnit) 0.0
            _ = unsafePerformIO $ do
              recordMetric metric value1
              recordMetric metric value2
              recordMetric metric value3
            actualValue = unsafePerformIO $ metricValue metric
        in not (isNaN actualValue) && 
           (if any isInfinite [value1, value2, value3] 
            then isInfinite actualValue 
            else abs (actualValue - (value1 + value2 + value3)) < 1.0e-10)
    
    it "should handle metric recreation with same name and unit" $ property $
      \name unit value1 value2 ->
        let nonEmptyName = if null name then "default" else name
            nonEmptyUnit = if null unit then "default" else unit
            metric1 = unsafePerformIO $ createMetricWithInitialValue (pack nonEmptyName) (pack nonEmptyUnit) value1
            metric2 = unsafePerformIO $ createMetricWithInitialValue (pack nonEmptyName) (pack nonEmptyUnit) value2
            value1After = unsafePerformIO $ metricValue metric1
            value2After = unsafePerformIO $ metricValue metric2
        in not (isNaN value1After) && not (isNaN value2After) &&
           (if isInfinite value1 || isInfinite value2 
            then isInfinite value1After && isInfinite value2After
            else abs (value1After - value2) < 1.0e-10 && abs (value2After - value2) < 1.0e-10)

  -- æµ‹è¯•10: é”™è¯¯å¤„ç†çš„å±žæ€§
  describe "Error Handling Properties" $ do
    it "should handle extreme values in metrics" $ property $
      \name unit ->
        let nonEmptyName = if null name then "extreme-test" else name
            nonEmptyUnit = if null unit then "count" else unit
            extremeValues = [1.0e100, -1.0e100, 1.0e-100, -1.0e-100]
            testValue value = 
              let metric = unsafePerformIO $ createMetricWithInitialValue (pack nonEmptyName) (pack nonEmptyUnit) 0.0
                  _ = unsafePerformIO $ recordMetric metric value
                  actualValue = unsafePerformIO $ metricValue metric
              in not (isNaN actualValue) && 
                 (if isInfinite value 
                  then isInfinite actualValue && signum actualValue == signum value
                  else abs (actualValue - value) < 1.0e-15)
        in all testValue extremeValues
    
    it "should handle special double values" $ do
      let positiveInfinity = 1/0 :: Double
          negativeInfinity = -1/0 :: Double
      -- Test that infinity values are handled
      let infMetric = unsafePerformIO $ createMetricWithInitialValue "infinity-test" "count" 0.0
          _ = unsafePerformIO $ recordMetric infMetric positiveInfinity
          infValue = unsafePerformIO $ metricValue infMetric
      
      let negInfMetric = unsafePerformIO $ createMetricWithInitialValue "neg-infinity-test" "count" 0.0
          _ = unsafePerformIO $ recordMetric negInfMetric negativeInfinity
          negInfValue = unsafePerformIO $ metricValue negInfMetric
      
      -- Infinity should be preserved
      not (isNaN infValue) && not (isNaN negInfValue) &&
      isInfinite infValue && isInfinite negInfValue &&
      signum infValue == signum positiveInfinity &&
      signum negInfValue == signum negativeInfinity