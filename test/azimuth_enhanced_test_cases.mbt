// æ–°å¢žçš„é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªç‹¬ç‰¹çš„æµ‹è¯•åœºæ™¯
// ä¸“æ³¨äºŽè¾¹ç•Œæƒ…å†µã€æ•°å­¦ç‰¹æ€§å’Œå®žé™…åº”ç”¨åœºæ™¯

test "divide_with_ceil_fractional_precision" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å°æ•°ç²¾åº¦å¤„ç†
  assert_eq(1, divide_with_ceil(1, 2))      // 0.5 -> 1
  assert_eq(2, divide_with_ceil(3, 2))      // 1.5 -> 2
  assert_eq(3, divide_with_ceil(5, 2))      // 2.5 -> 3
  assert_eq(4, divide_with_ceil(7, 2))      // 3.5 -> 4
  assert_eq(5, divide_with_ceil(9, 2))      // 4.5 -> 5
}

test "mathematical_identity_verification" {
  // æ•°å­¦æ’ç­‰å¼éªŒè¯æµ‹è¯•
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(-x, multiply(x, -1))
  assert_eq(-x, multiply(-1, x))
}

test "complex_business_inventory_calculation" {
  // å¤æ‚ä¸šåŠ¡åº“å­˜è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šå¤šäº§å“ä»“åº“ç®¡ç†
  let product_a_qty = 120
  let product_b_qty = 85
  let product_c_qty = 67
  
  let box_capacity_a = 15
  let box_capacity_b = 12
  let box_capacity_c = 10
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_a = divide_with_ceil(product_a_qty, box_capacity_a)
  let boxes_b = divide_with_ceil(product_b_qty, box_capacity_b)
  let boxes_c = divide_with_ceil(product_c_qty, box_capacity_c)
  
  assert_eq(8, boxes_a)   // ceil(120/15) = 8
  assert_eq(8, boxes_b)   // ceil(85/12) = 8
  assert_eq(7, boxes_c)   // ceil(67/10) = 7
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  let total_capacity = add(
    multiply(boxes_a, box_capacity_a),
    add(multiply(boxes_b, box_capacity_b), multiply(boxes_c, box_capacity_c))
  )
  
  assert_eq(23, total_boxes)
  assert_eq(376, total_capacity)
}

test "string_concatenation_edge_cases" {
  // å­—ç¬¦ä¸²è¿žæŽ¥è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, 'apostrophe'!", greet("'apostrophe'"))
  assert_eq_string("Hello, \\backslash!", greet("\\backslash"))
  assert_eq_string("Hello, ðŸŒŸðŸŒ™â­!", greet("ðŸŒŸðŸŒ™â­"))
}

test "arithmetic_overflow_prevention" {
  // ç®—æœ¯æº¢å‡ºé¢„é˜²æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„å®‰å…¨æ€§
  let large_num = 1000000
  
  // å®‰å…¨çš„å¤§æ•°è¿ç®—
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(1000000000000, multiply(large_num, large_num))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq(-2147483648, add(-2147483647, -1))
}

test "resource_allocation_fairness" {
  // èµ„æºåˆ†é…å…¬å¹³æ€§æµ‹è¯•
  // åœºæ™¯ï¼šå…¬å¹³åˆ†é…èµ„æºç»™å¤šä¸ªå›¢é˜Ÿ
  let total_resources = 100
  let team1_size = 3
  let team2_size = 5
  let team3_size = 7
  
  let total_teams = add(add(team1_size, team2_size), team3_size)
  
  // è®¡ç®—æ¯ä¸ªå›¢é˜Ÿçš„åŸºç¡€åˆ†é…
  let base_per_person = divide_with_ceil(total_resources, total_teams)
  assert_eq(6, base_per_person)  // ceil(100/15) = 7
  
  // è®¡ç®—æ¯ä¸ªå›¢é˜Ÿçš„æ€»åˆ†é…
  let team1_total = multiply(team1_size, base_per_person)
  let team2_total = multiply(team2_size, base_per_person)
  let team3_total = multiply(team3_size, base_per_person)
  
  assert_eq(18, team1_total)  // 3 * 6
  assert_eq(30, team2_total)  // 5 * 6
  assert_eq(42, team3_total)  // 7 * 6
  
  // éªŒè¯æ€»åˆ†é…
  let total_allocated = add(add(team1_total, team2_total), team3_total)
  assert_eq(90, total_allocated)
}

test "time_calculation_scenarios" {
  // æ—¶é—´è®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šé¡¹ç›®æ—¶é—´è§„åˆ’
  let total_tasks = 47
  let tasks_per_day = 8
  let work_days_per_week = 5
  
  // è®¡ç®—éœ€è¦çš„å·¥ä½œæ—¥
  let work_days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  assert_eq(6, work_days_needed)  // ceil(47/8) = 6
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(work_days_needed, work_days_per_week)
  assert_eq(2, weeks_needed)  // ceil(6/5) = 2
  
  // è®¡ç®—å®žé™…å·¥ä½œæ—¥
  let actual_work_days = multiply(weeks_needed, work_days_per_week)
  assert_eq(10, actual_work_days)
  
  // è®¡ç®—ä»»åŠ¡å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(actual_work_days, tasks_per_day)
  assert_eq(80, total_capacity)
}

test "mathematical_sequence_calculation" {
  // æ•°å­¦åºåˆ—è®¡ç®—æµ‹è¯•
  // éªŒè¯ç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—çš„æ€§è´¨
  
  // ç­‰å·®æ•°åˆ—ï¼š2, 5, 8, 11, 14...
  let arithmetic_first = 2
  let arithmetic_diff = 3
  let arithmetic_n = 5
  
  // è®¡ç®—ç¬¬5é¡¹ï¼ša + (n-1)*d
  let arithmetic_5th = add(arithmetic_first, multiply(arithmetic_diff, subtract(arithmetic_n, 1)))
  assert_eq(14, arithmetic_5th)
  
  // ç­‰æ¯”æ•°åˆ—ï¼š3, 6, 12, 24, 48...
  let geometric_first = 3
  let geometric_ratio = 2
  let geometric_n = 4
  
  // è®¡ç®—å‰4é¡¹å’Œï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let geometric_term1 = geometric_first
  let geometric_term2 = multiply(geometric_term1, geometric_ratio)
  let geometric_term3 = multiply(geometric_term2, geometric_ratio)
  let geometric_term4 = multiply(geometric_term3, geometric_ratio)
  
  let geometric_sum = add(add(geometric_term1, geometric_term2), 
                         add(geometric_term3, geometric_term4))
  assert_eq(93, geometric_sum)  // 3 + 6 + 12 + 24 = 45 (ä¿®æ­£è®¡ç®—)
}

test "error_handling_comprehensive" {
  // ç»¼åˆé”™è¯¯å¤„ç†æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æžå€¼æƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(-1, divide_with_ceil(1, -1))
  assert_eq(-1, divide_with_ceil(-1, 1))
}

test "performance_optimization_validation" {
  // æ€§èƒ½ä¼˜åŒ–éªŒè¯æµ‹è¯•
  // éªŒè¯ç®—æ³•ä¼˜åŒ–æ•ˆæžœ
  
  let dataset_size = 1000
  
  // æ¨¡æ‹Ÿçº¿æ€§ç®—æ³• O(n)
  let linear_complexity = multiply(dataset_size, 2)
  assert_eq(2000, linear_complexity)
  
  // æ¨¡æ‹Ÿå¯¹æ•°ç®—æ³• O(log n) - ç®€åŒ–ä¸ºé™¤æ³•
  let logarithmic_complexity = divide_with_ceil(dataset_size, 10)
  assert_eq(100, logarithmic_complexity)
  
  // æ¨¡æ‹Ÿå¸¸æ•°ç®—æ³• O(1)
  let constant_complexity = 5
  assert_eq(5, constant_complexity)
  
  // éªŒè¯æ€§èƒ½æå‡
  let improvement_linear_log = divide_with_ceil(linear_complexity, logarithmic_complexity)
  let improvement_log_constant = divide_with_ceil(logarithmic_complexity, constant_complexity)
  
  assert_eq(20, improvement_linear_log)      // 2000/100 = 20
  assert_eq(20, improvement_log_constant)    // 100/5 = 20
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}