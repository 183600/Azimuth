// Azimuth é¡¹ç›®ç»¼åˆå•å…ƒæµ‹è¯•
// åŒ…å« 10 ä¸ªé«˜è´¨é‡çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "mathematical_commutativity_laws" {
  // æµ‹è¯•æ•°å­¦äº¤æ¢å¾‹
  let a = 15
  let b = 27
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
  
  // éªŒè¯å…·ä½“æ•°å€¼
  assert_eq(42, add(15, 27))
  assert_eq(405, multiply(15, 27))
}

test "boundary_value_analysis" {
  // è¾¹ç•Œå€¼åˆ†ææµ‹è¯•
  // æµ‹è¯•é›¶å€¼è¾¹ç•Œ
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, add(0, 12345))
  assert_eq(0, divide_with_ceil(0, 100))
  
  // æµ‹è¯•å•ä½å€¼è¾¹ç•Œ
  assert_eq(1, multiply(1, 1))
  assert_eq(100, multiply(1, 100))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(99, 100))
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè´·æ¬¾è®¡ç®—
  let principal = 10000
  let annual_rate = 5
  let years = 3
  
  // ç®€åŒ–çš„å•åˆ©è®¡ç®—
  let yearly_interest = divide_with_ceil(multiply(principal, annual_rate), 100)
  let total_interest = multiply(yearly_interest, years)
  let total_repayment = add(principal, total_interest)
  
  assert_eq(500, yearly_interest)
  assert_eq(1500, total_interest)
  assert_eq(11500, total_repayment)
}

test "inventory_optimization" {
  // åº“å­˜ä¼˜åŒ–é—®é¢˜
  let demand_forecast = 157
  let package_size = 24
  let safety_stock = 20
  
  // è®¡ç®—éœ€è¦è®¢è´­çš„åŒ…è£¹æ•°é‡
  let base_packages = divide_with_ceil(demand_forecast, package_size)
  let safety_packages = divide_with_ceil(safety_stock, package_size)
  let total_packages = add(base_packages, safety_packages)
  
  assert_eq(7, base_packages)  // ceil(157/24) = 7
  assert_eq(1, safety_packages)  // ceil(20/24) = 1
  assert_eq(8, total_packages)
}

test "string_processing_internationalization" {
  // å­—ç¬¦ä¸²å¤„ç†å›½é™…åŒ–æµ‹è¯•
  let english_name = "Alice"
  let chinese_name = "å¼ ä¸‰"
  let spanish_name = "MarÃ­a"
  let emoji_name = "ğŸš€ğŸŒŸ"
  
  // æµ‹è¯•ä¸åŒè¯­è¨€çš„é—®å€™
  assert_eq_string("Hello, Alice!", greet(english_name))
  assert_eq_string("Hello, å¼ ä¸‰!", greet(chinese_name))
  assert_eq_string("Hello, MarÃ­a!", greet(spanish_name))
  assert_eq_string("Hello, ğŸš€ğŸŒŸ!", greet(emoji_name))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
}

test "complex_algorithm_simulation" {
  // å¤æ‚ç®—æ³•æ¨¡æ‹Ÿï¼šäºŒåˆ†æœç´¢ä¸­çš„è®¡ç®—
  let array_size = 1000
  let target_value = 743
  
  // æ¨¡æ‹ŸäºŒåˆ†æœç´¢çš„ä¸­é—´å€¼è®¡ç®—
  let low = 0
  let high = array_size - 1
  let mid = divide_with_ceil(add(low, high), 2)
  
  // æ¨¡æ‹Ÿæœç´¢æ­¥éª¤
  let steps_needed = divide_with_ceil(array_size, 2)
  let comparisons = multiply(steps_needed, 2)
  
  assert_eq(500, mid)  // ceil((0 + 999)/2) = 500
  assert_eq(500, steps_needed)
  assert_eq(1000, comparisons)
}

test "engineering_tolerance_calculation" {
  // å·¥ç¨‹å…¬å·®è®¡ç®—
  let nominal_dimension = 100
  let positive_tolerance = 2
  let negative_tolerance = 1
  
  // è®¡ç®—æœ€å¤§å’Œæœ€å°å°ºå¯¸
  let max_dimension = add(nominal_dimension, positive_tolerance)
  let min_dimension = add(nominal_dimension, -negative_tolerance)
  
  // è®¡ç®—å…¬å·®å¸¦
  let tolerance_band = add(max_dimension, -min_dimension)
  
  // è®¡ç®—å¯ä»¥å®¹çº³çš„é›¶ä»¶æ•°é‡ï¼ˆå‡è®¾æ¯ä¸ªé›¶ä»¶éœ€è¦æœ€å¤§å°ºå¯¸ç©ºé—´ï¼‰
  let available_space = 1000
  let parts_count = divide_with_ceil(available_space, max_dimension)
  
  assert_eq(102, max_dimension)
  assert_eq(99, min_dimension)
  assert_eq(3, tolerance_band)
  assert_eq(10, parts_count)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿ
  let initial_capacity = 8
  let growth_factor = 2
  let load_factor = 75  // ç™¾åˆ†æ¯”
  
  // æ¨¡æ‹ŸåŠ¨æ€æ•°ç»„æ‰©å®¹
  let current_size = 6
  let threshold = divide_with_ceil(multiply(initial_capacity, load_factor), 100)
  let needs_expansion = current_size > threshold
  
  let new_capacity = if needs_expansion {
    multiply(initial_capacity, growth_factor)
  } else {
    initial_capacity
  }
  
  assert_eq(6, threshold)  // ceil(8 * 75 / 100) = 6
  assert_eq(true, needs_expansion)
  assert_eq(16, new_capacity)
}

test "performance_benchmark_calculation" {
  // æ€§èƒ½åŸºå‡†è®¡ç®—
  let baseline_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 10
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ€§èƒ½
  let optimized_operations = multiply(baseline_operations, optimization_factor)
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  let actual_performance = add(optimized_operations, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡ç™¾åˆ†æ¯”
  let improvement = add(actual_performance, -baseline_operations)
  let improvement_percentage = divide_with_ceil(multiply(improvement, 100), baseline_operations)
  
  assert_eq(3000, optimized_operations)
  assert_eq(300, overhead)
  assert_eq(2700, actual_performance)
  assert_eq(170, improvement_percentage)
}

test "resource_allocation_problem" {
  // èµ„æºåˆ†é…é—®é¢˜
  let total_budget = 5000
  let project_costs = [1200, 800, 1500, 900]
  
  // è®¡ç®—é¡¹ç›®æ€»æˆæœ¬
  let total_cost = add(add(add(project_costs[0], project_costs[1]), project_costs[2]), project_costs[3])
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let remaining_budget = add(total_budget, -total_cost)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°å‹é¡¹ç›®æ•°é‡
  let small_project_cost = 300
  let additional_projects = divide_with_ceil(remaining_budget, small_project_cost)
  
  assert_eq(4400, total_cost)
  assert_eq(600, remaining_budget)
  assert_eq(2, additional_projects)
}