// Azimuth é¡¹ç›®çš„é«˜çº§æµ‹è¯•ç”¨ä¾‹
// è¦†ç›–è¾¹ç•Œå€¼ã€å®é™…åº”ç”¨åœºæ™¯å’Œå¤æ‚æ•°å­¦è¿ç®—

test "advanced_arithmetic_sequences" {
  // æµ‹è¯•ç­‰å·®æ•°åˆ—æ±‚å’Œï¼š1 + 4 + 7 + 10 + 13
  let first_term = 1
  let common_diff = 3
  let num_terms = 5
  
  // æ‰‹åŠ¨è®¡ç®—
  let term1 = first_term
  let term2 = add(term1, common_diff)
  let term3 = add(term2, common_diff)
  let term4 = add(term3, common_diff)
  let term5 = add(term4, common_diff)
  
  let sum = add(add(add(add(term1, term2), term3), term4), term5)
  assert_eq(35, sum)
}

test "financial_compound_interest" {
  // æµ‹è¯•å¤åˆ©è®¡ç®—ï¼šæœ¬é‡‘ Ã— (1 + åˆ©ç‡)^å¹´æ•°
  let principal = 10000
  let rate_percent = 8
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆé¿å…æµ®ç‚¹æ•°ï¼‰
  let growth_factor = add(100, multiply(rate_percent, years))
  let total = multiply(principal, growth_factor)
  assert_eq(124000, total)  // 10000 Ã— (100 + 8Ã—3) = 10000 Ã— 124 = 124000
}

test "physics_kinematics" {
  // æµ‹è¯•ç‰©ç†è¿åŠ¨å­¦å…¬å¼ï¼šs = ut + (1/2)atÂ²
  let initial_velocity = 10  // åˆå§‹é€Ÿåº¦
  let acceleration = 2       // åŠ é€Ÿåº¦
  let time = 5               // æ—¶é—´
  
  // ä½ç§» = åˆé€Ÿåº¦ Ã— æ—¶é—´ + 0.5 Ã— åŠ é€Ÿåº¦ Ã— æ—¶é—´Â²
  let distance1 = multiply(initial_velocity, time)
  let distance2 = multiply(acceleration, multiply(time, time)) / 2
  let total_distance = add(distance1, distance2)
  
  assert_eq(75, total_distance)  // 10Ã—5 + 0.5Ã—2Ã—25 = 50 + 25 = 75
}

test "data_structure_indexing" {
  // æµ‹è¯•æ•°æ®ç»“æ„ç´¢å¼•è®¡ç®—ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„
  let rows = 4
  let cols = 5
  let row_index = 2
  let col_index = 3
  
  // ä¸€ç»´ç´¢å¼• = è¡Œç´¢å¼• Ã— åˆ—æ•° + åˆ—ç´¢å¼•
  let linear_index = add(multiply(row_index, cols), col_index)
  assert_eq(13, linear_index)
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let first_index = add(multiply(0, cols), 0)
  let last_index = add(multiply(subtract(rows, 1), subtract(cols, 1)), 0)
  assert_eq(0, first_index)
}

test "string_encoding_scenarios" {
  // æµ‹è¯•å­—ç¬¦ä¸²ç¼–ç åœºæ™¯
  let ascii_text = "Hello"
  let unicode_text = "ä½ å¥½"
  let mixed_text = "Helloä½ å¥½123"
  let emoji_text = "ğŸŒğŸ‰"
  
  assert_eq_string("Hello, Hello!", greet(ascii_text))
  assert_eq_string("Hello, ä½ å¥½!", greet(unicode_text))
  assert_eq_string("Hello, Helloä½ å¥½123!", greet(mixed_text))
  assert_eq_string("Hello, ğŸŒğŸ‰!", greet(emoji_text))
}

test "extreme_boundary_combinations" {
  // æµ‹è¯•æå€¼è¾¹ç•Œç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•é“¾å¼è¿ç®—çš„è¾¹ç•Œå¤„ç†
  let chain1 = add(add(max_val, min_val), max_val)
  assert_eq(max_val, chain1)
  
  let chain2 = multiply(multiply(min_val, 1), -1)
  assert_eq(min_val, chain2)
  
  // æµ‹è¯•æ··åˆè¿ç®—
  let mixed1 = add(multiply(max_val, 0), 1)
  assert_eq(1, mixed1)
  
  let mixed2 = multiply(add(min_val, 1), 0)
  assert_eq(0, mixed2)
}

test "algorithm_complexity_simulation" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿ
  let n = 100
  
  // O(n) çº¿æ€§å¤æ‚åº¦ï¼šç®€å•çš„ç´¯åŠ 
  let linear_sum = multiply(n, add(n, 1)) / 2
  assert_eq(5050, linear_sum)
  
  // O(nÂ²) å¹³æ–¹å¤æ‚åº¦ï¼šåµŒå¥—å¾ªç¯çš„æ€»å’Œ
  let quadratic_sum = multiply(n, multiply(n, add(n, 1))) / 6
  assert_eq(171700, quadratic_sum)
  
  // O(log n) å¯¹æ•°å¤æ‚åº¦ï¼šäºŒåˆ†æŸ¥æ‰¾çš„æ­¥éª¤æ•°ï¼ˆç®€åŒ–ï¼‰
  let log_steps = 0
  let temp_n = n
  // ç®€åŒ–çš„å¯¹æ•°è®¡ç®—ï¼šlogâ‚‚(100) â‰ˆ 7
  assert_true(7 >= log_steps)
}

test "real_world_inventory_management" {
  // æµ‹è¯•å®é™…åº“å­˜ç®¡ç†åœºæ™¯
  let initial_stock = 1000
  let sales_per_day = 25
  let days = 5
  let restock_amount = 200
  
  // è®¡ç®—é”€å”®é‡
  let total_sales = multiply(sales_per_day, days)
  
  // è®¡ç®—å‰©ä½™åº“å­˜
  let remaining_stock = add(initial_stock, -total_sales)
  
  // è®¡ç®—è¡¥è´§åçš„åº“å­˜
  let final_stock = add(remaining_stock, restock_amount)
  
  assert_eq(1125, final_stock)  // 1000 - 25Ã—5 + 200 = 1000 - 125 + 200 = 1075
}

test "statistical_variance_calculation" {
  // æµ‹è¯•ç»Ÿè®¡æ–¹å·®è®¡ç®—
  // æ•°æ®é›†ï¼š[10, 20, 30, 40, 50]
  let sum = add(add(add(add(10, 20), 30), 40), 50)
  let mean = sum / 5  // å¹³å‡å€¼ = 30
  
  // è®¡ç®—æ–¹å·®ï¼šÎ£(x - mean)Â² / n
  let diff1 = subtract(10, mean)
  let diff2 = subtract(20, mean)
  let diff3 = subtract(30, mean)
  let diff4 = subtract(40, mean)
  let diff5 = subtract(50, mean)
  
  let sq1 = multiply(diff1, diff1)
  let sq2 = multiply(diff2, diff2)
  let sq3 = multiply(diff3, diff3)
  let sq4 = multiply(diff4, diff4)
  let sq5 = multiply(diff5, diff5)
  
  let variance = add(add(add(add(sq1, sq2), sq3), sq4), sq5) / 5
  assert_eq(200, variance)  // ((400+100+0+100+400)/5) = 200
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•ï¼ˆé€šè¿‡åŠ è´Ÿæ•°å®ç°ï¼‰
fn subtract(a : Int, b : Int) -> Int {
  add(a, -b)
}