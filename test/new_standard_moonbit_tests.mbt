// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½ï¼ŒåŒ…æ‹¬åŸºæœ¬è¿ç®—ã€è¾¹ç•Œæ¡ä»¶å’Œå®é™…åº”ç”¨åœºæ™¯

test "subtract_function_comprehensive" {
  // å…¨é¢æµ‹è¯•å‡æ³•å‡½æ•°
  assert_eq(2, subtract(5, 3))
  assert_eq(-2, subtract(3, 5))
  assert_eq(0, subtract(5, 5))
  assert_eq(10, subtract(5, -5))
  assert_eq(-10, subtract(-5, 5))
}

test "complex_arithmetic_sequence" {
  // æµ‹è¯•å¤æ‚çš„ç®—æœ¯åºåˆ—
  let a = add(10, 5)        // 15
  let b = multiply(a, 2)    // 30
  let c = subtract(b, 8)    // 22
  let d = divide_with_ceil(c, 5)  // 5
  assert_eq(5, d)
}

test "resource_planning_scenario" {
  // èµ„æºè§„åˆ’åœºæ™¯æµ‹è¯•
  let project_days = 15
  let team_members = 6
  let tasks_per_member = 4
  let total_tasks = multiply(team_members, tasks_per_member)  // 24
  let tasks_per_day = divide_with_ceil(total_tasks, project_days)  // 2
  assert_eq(2, tasks_per_day)
}

test "mathematical_properties_extended" {
  // æ‰©å±•çš„æ•°å­¦æ€§è´¨æµ‹è¯•
  let x = 12
  let y = 8
  
  // åŠ æ³•ç»“åˆå¾‹
  assert_eq(add(add(x, y), 3), add(x, add(y, 3)))
  
  // ä¹˜æ³•ç»“åˆå¾‹
  assert_eq(multiply(multiply(x, y), 2), multiply(x, multiply(y, 2)))
  
  // å‡æ³•æ€§è´¨
  assert_eq(subtract(x, y), add(x, multiply(y, -1)))
}

test "error_handling_comprehensive" {
  // ç»¼åˆé”™è¯¯å¤„ç†æµ‹è¯•
  // é™¤é›¶çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(-1, divide_with_ceil(-1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µ
  assert_eq_string("Hello, space!", greet("space"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
  assert_eq_string("Hello, special@#$!", greet("special@#$"))
  assert_eq_string("Hello, emojiğŸ‰!", greet("emojiğŸ‰"))
}

test "business_calculation_complex" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®æˆæœ¬å’Œèµ„æºåˆ†é…
  let base_cost = 5000
  let team_size = 8
  let project_duration = 12
  let daily_cost = divide_with_ceil(base_cost, project_duration)  // 417
  let total_cost = multiply(daily_cost, project_duration)  // 5004
  let cost_per_member = divide_with_ceil(total_cost, team_size)  // 626
  assert_eq(626, cost_per_member)
}

test "performance_optimization_test" {
  // æ€§èƒ½ä¼˜åŒ–æµ‹è¯•
  // æ¨¡æ‹Ÿç®—æ³•ä¼˜åŒ–åœºæ™¯
  let data_size = 1000
  let old_algorithm_steps = multiply(data_size, 10)  // O(n) ç®—æ³•
  let new_algorithm_steps = divide_with_ceil(data_size, 10)  // O(log n) ç®—æ³•
  let improvement_ratio = divide_with_ceil(old_algorithm_steps, new_algorithm_steps)
  assert_eq(100, improvement_ratio)  // 100å€æ”¹è¿›
}

test "boundary_conditions_extensive" {
  // å¹¿æ³›çš„è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•æå€¼æƒ…å†µ
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
  assert_eq(1000000, divide_with_ceil(1000000, 1))
}

test "real_world_application_comprehensive" {
  // çœŸå®ä¸–ç•Œåº”ç”¨ç»¼åˆæµ‹è¯•
  // åœºæ™¯ï¼šæ´»åŠ¨ç»„ç»‡å’Œèµ„æºåˆ†é…
  let participants = 156
  let tables = 12
  let chairs_per_table = 15
  let tables_needed = divide_with_ceil(participants, chairs_per_table)  // 11
  let total_chairs = multiply(tables_needed, chairs_per_table)  // 165
  let empty_chairs = subtract(total_chairs, participants)  // 9
  let cost_per_chair = 25
  let total_cost = multiply(total_chairs, cost_per_chair)  // 4125
  assert_eq(11, tables_needed)
  assert_eq(165, total_chairs)
  assert_eq(9, empty_chairs)
  assert_eq(4125, total_cost)
}