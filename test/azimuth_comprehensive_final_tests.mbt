// Azimuth ç»¼åˆæœ€ç»ˆæµ‹è¯•ç”¨ä¾‹
// é«˜è´¨é‡ MoonBit æµ‹è¯•è¯­æ³•ï¼Œè¦†ç›–æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "comprehensive_arithmetic_operations" {
  // ç»¼åˆç®—æœ¯è¿ç®—æµ‹è¯•
  let a = 15
  let b = 4
  let c = 7
  
  // æµ‹è¯•å¤åˆè¿ç®—ï¼š(a + b) * c - a / b
  let result1 = add(multiply(add(a, b), c), -divide_with_ceil(a, b))
  assert_eq(129, result1)  // (15 + 4) * 7 - ceil(15/4) = 19 * 7 - 4 = 133 - 4 = 129
  
  // æµ‹è¯•åµŒå¥—è¿ç®—ï¼ša * (b + c) + b * c
  let result2 = add(multiply(a, add(b, c)), multiply(b, c))
  assert_eq(193, result2)  // 15 * (4 + 7) + 4 * 7 = 15 * 11 + 28 = 165 + 28 = 193
}

test "mathematical_series_summation" {
  // æ•°å­¦çº§æ•°æ±‚å’Œæµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—ï¼š3, 7, 11, 15, 19 çš„å’Œ
  let first_term = 3
  let common_diff = 4
  let num_terms = 5
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šS = n/2 * (2a + (n-1)d)
  let series_sum = divide_with_ceil(
    multiply(num_terms, add(multiply(2, first_term), multiply(num_terms - 1, common_diff))),
    2
  )
  
  assert_eq(55, series_sum)  // 5/2 * (6 + 16) = 5/2 * 22 = 55
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let rate_percent = 8
  
  // ç¬¬ä¸€å¹´
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  // ç¬¬äºŒå¹´
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  // ç¬¬ä¸‰å¹´
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(10800, year1)  // 10000 + 800
  assert_eq(11664, year2)  // 10800 + 864
  assert_eq(12597, year3)  // 11664 + 933
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 5000
  let project_a_cost = 1200
  let project_b_cost = 800
  let project_c_cost = 1500
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let allocated = add(add(project_a_cost, project_b_cost), project_c_cost)
  let remaining = add(total_budget, -allocated)
  
  // è®¡ç®—å¯ä»¥å¯åŠ¨çš„å°é¡¹ç›®æ•°é‡
  let small_project_cost = 300
  let additional_projects = divide_with_ceil(remaining, small_project_cost)
  
  assert_eq(3500, allocated)
  assert_eq(1500, remaining)
  assert_eq(5, additional_projects)
}

test "logistics_packaging_efficiency" {
  // ç‰©æµåŒ…è£…æ•ˆç‡æµ‹è¯•
  
  // è®¡ç®—æ¯ç±»ç‰©å“éœ€è¦çš„ç®±å­æ•°
  let boxes1 = divide_with_ceil(25, 6)  // 25ä¸ªç‰©å“ï¼Œæ¯ç®±è£…6ä¸ª
  let boxes2 = divide_with_ceil(47, 8)  // 47ä¸ªç‰©å“ï¼Œæ¯ç®±è£…8ä¸ª
  let boxes3 = divide_with_ceil(13, 3)  // 13ä¸ªç‰©å“ï¼Œæ¯ç®±è£…3ä¸ª
  let boxes4 = divide_with_ceil(31, 7)  // 31ä¸ªç‰©å“ï¼Œæ¯ç®±è£…7ä¸ª
  
  let total_boxes = add(add(add(boxes1, boxes2), boxes3), boxes4)
  
  assert_eq(5, boxes1)   // ceil(25/6) = 5
  assert_eq(6, boxes2)   // ceil(47/8) = 6
  assert_eq(5, boxes3)   // ceil(13/3) = 5
  assert_eq(5, boxes4)   // ceil(31/7) = 5
  assert_eq(21, total_boxes)
}

test "string_processing_multilingual" {
  // å¤šè¯­è¨€å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  
  // æµ‹è¯•æ¯ç§è¯­è¨€çš„é—®å€™
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¸Ñ€!", greet("ĞœĞ¸Ñ€"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø§Ù„Ù…!", greet("Ø§Ù„Ø¹Ø§Ù„Ù…"))
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  let base_operations = 100
  let data_size = 50
  let algorithm_factor = 3
  
  // æ¨¡æ‹Ÿ O(n) ç®—æ³•
  let linear_ops = multiply(base_operations, data_size)
  
  // æ¨¡æ‹Ÿ O(nÂ²) ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let quadratic_ops = multiply(base_operations, multiply(data_size, divide_with_ceil(data_size, 10)))
  
  // æ¨¡æ‹Ÿ O(log n) ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let logarithmic_ops = multiply(base_operations, divide_with_ceil(data_size, algorithm_factor))
  
  assert_eq(5000, linear_ops)      // 100 * 50
  assert_eq(25000, quadratic_ops)  // 100 * 50 * 5
  assert_eq(1700, logarithmic_ops) // 100 * ceil(50/3) = 100 * 17
}

test "engineering_structural_calculation" {
  // å·¥ç¨‹ç»“æ„è®¡ç®—æµ‹è¯•
  let beam_length = 12
  let material_density = 2400
  let safety_factor = 2
  
  // è®¡ç®—æ¢çš„ä½“ç§¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let volume = multiply(multiply(beam_length, 5), 8)  // 0.5->5, 0.8->8
  let volume_scaled = divide_with_ceil(volume, 100)
  
  // è®¡ç®—é‡é‡
  let weight = multiply(volume_scaled, material_density)
  let weight_scaled = divide_with_ceil(weight, 1000)
  
  // åº”ç”¨å®‰å…¨ç³»æ•°
  let safe_load = multiply(weight_scaled, safety_factor)
  
  assert_eq(48, volume_scaled)   // 12 * 5 * 8 / 100
  assert_eq(115, weight_scaled)  // ceil(48 * 2400 / 1000)
  assert_eq(230, safe_load)      // 115 * 2
}

test "data_analysis_statistics_comprehensive" {
  // æ•°æ®åˆ†æç»Ÿè®¡ç»¼åˆæµ‹è¯•
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(add(add(add(add(add(45, 67), 23), 89), 12), 56), 78), 34), 90), 41)
  
  // è®¡ç®—å¹³å‡å€¼ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let average = divide_with_ceil(sum, 10)
  
  // è®¡ç®—æœ€å¤§å€¼å’Œæœ€å°å€¼çš„å·®
  let max_val = 90
  let min_val = 12
  let range = add(max_val, -min_val)
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let variance = divide_with_ceil(multiply(range, range), 10)
  
  assert_eq(535, sum)
  assert_eq(54, average)
  assert_eq(78, range)
  assert_eq(609, variance)
}

test "extreme_boundary_conditions" {
  // æç«¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  let max_positive = 2147483647
  let min_negative = -2147483648
  
  // æµ‹è¯•æ¥è¿‘è¾¹ç•Œçš„åŠ æ³•
  let near_max_sum = add(max_positive - 1000, 500)
  let near_min_sum = add(min_negative + 1000, -500)
  
  // æµ‹è¯•å¤§æ•°é™¤æ³•
  let large_division = divide_with_ceil(1000000, 3)
  let negative_large_division = divide_with_ceil(-1000000, 3)
  
  // æµ‹è¯•é›¶å€¼é™„è¿‘
  let zero_plus_small = add(0, 1)
  let zero_minus_small = add(0, -1)
  let zero_times_any = multiply(0, 12345)
  let zero_division = divide_with_ceil(0, 100)
  
  assert_eq(2147482647, near_max_sum)
  assert_eq(-2147482648, near_min_sum)
  assert_eq(333334, large_division)
  assert_eq(-333333, negative_large_division)
  assert_eq(1, zero_plus_small)
  assert_eq(-1, zero_minus_small)
  assert_eq(0, zero_times_any)
  assert_eq(0, zero_division)
}