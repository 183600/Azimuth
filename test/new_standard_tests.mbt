// æ–°å¢çš„ MoonBit æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth æ ¸å¿ƒåŠŸèƒ½çš„å„ç§åœºæ™¯

test "add_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹ï¼ša + b = b + a
  let a = 12345
  let b = 67890
  assert_eq(add(a, b), add(b, a))
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  let c = -123
  let d = 456
  assert_eq(add(c, d), add(d, c))
  
  // æµ‹è¯•æ··åˆç¬¦å·
  let e = 100
  let f = -50
  assert_eq(add(e, f), add(f, e))
}

test "add_associative_property" {
  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹ï¼š(a + b) + c = a + (b + c)
  let a = 100
  let b = 200
  let c = 300
  
  let result1 = add(add(a, b), c)
  let result2 = add(a, add(b, c))
  assert_eq(result1, result2)
  
  // æµ‹è¯•åŒ…å«è´Ÿæ•°çš„æƒ…å†µ
  let x = -100
  let y = 250
  let z = -150
  
  let result3 = add(add(x, y), z)
  let result4 = add(x, add(y, z))
  assert_eq(result3, result4)
}

test "multiply_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ï¼ša Ã— (b + c) = a Ã— b + a Ã— c
  let a = 5
  let b = 10
  let c = 15
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  let x = -3
  let y = 8
  let z = -2
  
  let left_side2 = multiply(x, add(y, z))
  let right_side2 = add(multiply(x, y), multiply(x, z))
  assert_eq(left_side2, right_side2)
}

test "multiply_identity_property" {
  // æµ‹è¯•ä¹˜æ³•å•ä½å…ƒï¼ša Ã— 1 = aï¼Œa Ã— 0 = 0
  let test_values = [0, 1, -1, 100, -100, 2147483647, -2147483648]
  
  // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨å¾ªç¯çš„ç®€åŒ–ç‰ˆæœ¬ï¼Œå› ä¸º MoonBit å¯èƒ½ä¸æ”¯æŒæ•°ç»„éå†
  assert_eq(0, multiply(0, 0))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(-1, 1))
  assert_eq(100, multiply(100, 1))
  assert_eq(-100, multiply(-100, 1))
  assert_eq(2147483647, multiply(2147483647, 1))
  assert_eq(-2147483648, multiply(-2147483648, 1))
  
  // æµ‹è¯•ä¹˜ä»¥é›¶
  assert_eq(0, multiply(0, 1))
  assert_eq(0, multiply(1, 0))
  assert_eq(0, multiply(-1, 0))
  assert_eq(0, multiply(100, 0))
  assert_eq(0, multiply(-100, 0))
  assert_eq(0, multiply(2147483647, 0))
  assert_eq(0, multiply(-2147483648, 0))
}

test "greet_function_internationalization" {
  // æµ‹è¯• greet å‡½æ•°çš„å›½é™…åŒ–æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒ!", greet("ğŸŒ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, naÃ¯ve!", greet("naÃ¯ve"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ğŸ‰!", greet("ğŸ‰"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
}

test "complex_financial_calculations" {
  // æµ‹è¯•å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  // å¤åˆåˆ©ç‡è®¡ç®—ï¼šæœ€ç»ˆé‡‘é¢ = æœ¬é‡‘ Ã— (1 + åˆ©ç‡)^æœŸæ•°
  let principal = 10000
  let rate_percent = 5
  let periods = 3
  
  // ç®€åŒ–è®¡ç®—ï¼š10000 Ã— (1 + 0.05 Ã— 3) = 10000 Ã— 1.15 â‰ˆ 11500
  let growth_factor = add(100, multiply(rate_percent, periods))
  let final_amount = multiply(principal, growth_factor) / 100
  assert_eq(115000, final_amount)  // 115000 è¡¨ç¤º 11500.00
  
  // è´·æ¬¾è®¡ç®—ï¼šæœˆä¾› = [æœ¬é‡‘ Ã— æœˆåˆ©ç‡ Ã— (1 + æœˆåˆ©ç‡)^è¿˜æ¬¾æœˆæ•°] / [(1 + æœˆåˆ©ç‡)^è¿˜æ¬¾æœˆæ•° - 1]
  // ç®€åŒ–ç‰ˆæœ¬
  let loan_principal = 200000
  let monthly_rate = 6  // 0.6%
  let months = 12
  
  let monthly_interest = multiply(loan_principal, monthly_rate) / 1000
  let monthly_payment = monthly_interest + multiply(loan_principal, 1) / months
  assert_eq(18333, monthly_payment)  // ç®€åŒ–è®¡ç®—çš„æœˆä¾›
}

test "physics_simulation_calculations" {
  // æµ‹è¯•ç‰©ç†æ¨¡æ‹Ÿè®¡ç®—
  // è‡ªç”±è½ä½“è·ç¦»ï¼šs = 0.5 Ã— g Ã— tÂ²
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼šs = 5 Ã— tÂ² (g â‰ˆ 10 m/sÂ²)
  let time = 5
  let distance = multiply(5, multiply(time, time))
  assert_eq(125, distance)  // 5 Ã— 25 = 125 ç±³
  
  // åŠ¨èƒ½è®¡ç®—ï¼šKE = 0.5 Ã— m Ã— vÂ²
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼šKE = m Ã— vÂ² / 2
  let mass = 1000
  let velocity = 20
  let kinetic_energy = multiply(mass, multiply(velocity, velocity)) / 2
  assert_eq(200000, kinetic_energy)  // 1000 Ã— 400 / 2 = 200000 ç„¦è€³
  
  // åŠ¿èƒ½è®¡ç®—ï¼šPE = m Ã— g Ã— h
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼šPE = m Ã— 10 Ã— h
  let height = 50
  let potential_energy = multiply(multiply(mass, 10), height)
  assert_eq(500000, potential_energy)  // 1000 Ã— 10 Ã— 50 = 500000 ç„¦è€³
}

test "statistical_analysis_functions" {
  // æµ‹è¯•ç»Ÿè®¡åˆ†æå‡½æ•°
  // è®¡ç®—æ–¹å·®ï¼šÏƒÂ² = Î£(xi - Î¼)Â² / n
  // æ•°æ®é›†ï¼š[10, 20, 30, 40, 50]
  let data1 = 10
  let data2 = 20
  let data3 = 30
  let data4 = 40
  let data5 = 50
  
  // è®¡ç®—å¹³å‡å€¼
  let sum = add(add(add(add(data1, data2), data3), data4), data5)
  let mean = sum / 5
  assert_eq(30, mean)
  
  // è®¡ç®—åå·®å¹³æ–¹å’Œ
  let diff1 = add(data1, -mean)
  let diff2 = add(data2, -mean)
  let diff3 = add(data3, -mean)
  let diff4 = add(data4, -mean)
  let diff5 = add(data5, -mean)
  
  let variance_sum = add(add(add(add(multiply(diff1, diff1), multiply(diff2, diff2)), multiply(diff3, diff3)), multiply(diff4, diff4)), multiply(diff5, diff5))
  let variance = variance_sum / 5
  assert_eq(200, variance)  // æ–¹å·®ä¸º 200
  
  // æ ‡å‡†å·®ï¼ˆæ•´æ•°è¿‘ä¼¼ï¼‰
  let std_dev = 14  // âˆš200 â‰ˆ 14.14ï¼Œå–æ•´æ•°éƒ¨åˆ†
  assert_eq(14, std_dev)
}

test "geometry_calculations_extended" {
  // æµ‹è¯•æ‰©å±•å‡ ä½•è®¡ç®—
  // ç«‹æ–¹ä½“è¡¨é¢ç§¯ï¼š6 Ã— aÂ²
  let cube_side = 5
  let cube_surface_area = multiply(6, multiply(cube_side, cube_side))
  assert_eq(150, cube_surface_area)
  
  // ç«‹æ–¹ä½“ä½“ç§¯ï¼šaÂ³
  let cube_volume = multiply(multiply(cube_side, cube_side), cube_side)
  assert_eq(125, cube_volume)
  
  // çƒä½“è¡¨é¢ç§¯ï¼ˆç®€åŒ–ï¼‰ï¼š4 Ã— Ï€ Ã— rÂ² â‰ˆ 12 Ã— rÂ²
  let sphere_radius = 4
  let sphere_surface_area = multiply(12, multiply(sphere_radius, sphere_radius))
  assert_eq(192, sphere_surface_area)
  
  // çƒä½“ä½“ç§¯ï¼ˆç®€åŒ–ï¼‰ï¼š4/3 Ã— Ï€ Ã— rÂ³ â‰ˆ 4 Ã— rÂ³
  let sphere_volume = multiply(4, multiply(multiply(sphere_radius, sphere_radius), sphere_radius))
  assert_eq(256, sphere_volume)
  
  // åœ†æŸ±ä½“è¡¨é¢ç§¯ï¼ˆç®€åŒ–ï¼‰ï¼š2 Ã— Ï€ Ã— r Ã— h + 2 Ã— Ï€ Ã— rÂ² â‰ˆ 6 Ã— r Ã— h + 6 Ã— rÂ²
  let cylinder_radius = 3
  let cylinder_height = 8
  let cylinder_surface_area = add(multiply(6, multiply(cylinder_radius, cylinder_height)), multiply(6, multiply(cylinder_radius, cylinder_radius)))
  assert_eq(162, cylinder_surface_area)
  
  // åœ†æŸ±ä½“ä½“ç§¯ï¼ˆç®€åŒ–ï¼‰ï¼šÏ€ Ã— rÂ² Ã— h â‰ˆ 3 Ã— rÂ² Ã— h
  let cylinder_volume = multiply(3, multiply(multiply(cylinder_radius, cylinder_radius), cylinder_height))
  assert_eq(216, cylinder_volume)
}

test "algorithm_complexity_simulation" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿ
  // O(n) çº¿æ€§å¤æ‚åº¦ï¼šç®€å•æ±‚å’Œ
  let n = 100
  let linear_sum = multiply(n, add(n, 1)) / 2  // 1 + 2 + ... + n = n(n+1)/2
  assert_eq(5050, linear_sum)
  
  // O(nÂ²) å¹³æ–¹å¤æ‚åº¦ï¼šåµŒå¥—å¾ªç¯æ±‚å’Œ
  // Î£(i=1 to n) Î£(j=1 to n) (i + j) = n Ã— Î£(i=1 to n) i + n Ã— Î£(j=1 to n) j = 2n Ã— n(n+1)/2 = nÂ²(n+1)
  let quadratic_sum = multiply(multiply(n, n), add(n, 1))
  assert_eq(1010000, quadratic_sum)  // 100Â² Ã— 101 = 1010000
  
  // O(log n) å¯¹æ•°å¤æ‚åº¦ï¼šäºŒåˆ†æŸ¥æ‰¾æ­¥æ•°ï¼ˆç®€åŒ–ï¼‰
  let log_steps = 7  // logâ‚‚(100) â‰ˆ 6.64ï¼Œå‘ä¸Šå–æ•´ä¸º 7
  assert_eq(7, log_steps)
  
  // O(n log n) çº¿æ€§å¯¹æ•°å¤æ‚åº¦ï¼šé«˜æ•ˆæ’åºç®—æ³•æ¯”è¾ƒæ¬¡æ•°ï¼ˆç®€åŒ–ï¼‰
  let n_log_n_ops = multiply(n, 7)  // 100 Ã— logâ‚‚(100) â‰ˆ 100 Ã— 7
  assert_eq(700, n_log_n_ops)
}

// æ–°å¢çš„æµ‹è¯•ç”¨ä¾‹
test "new_negative_addition" {
  // æµ‹è¯•è´Ÿæ•°åŠ æ³•
  assert_eq(-5, add(-2, -3))
  assert_eq(-10, add(-7, -3))
  assert_eq(0, add(-5, 5))
  assert_eq(-100, add(-150, 50))
}

test "new_large_multiplication" {
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(86400000, multiply(86400, 1000))
  assert_eq(-1000000, multiply(-1000, 1000))
  assert_eq(1000000, multiply(-1000, -1000))
}

test "new_unicode_greeting" {
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, âœ“âœ—!", greet("âœ“âœ—"))
}

test "new_mathematical_series" {
  // æµ‹è¯•æ•°å­¦çº§æ•°è®¡ç®—
  // ç­‰å·®æ•°åˆ—æ±‚å’Œï¼š1 + 2 + 3 + 4 + 5 = 15
  let sum_1_to_5 = add(add(add(add(1, 2), 3), 4), 5)
  assert_eq(15, sum_1_to_5)
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼š2 + 4 + 8 + 16 = 30
  let sum_powers = add(add(add(2, 4), 8), 16)
  assert_eq(30, sum_powers)
}

test "new_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼è¿ç®—
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸1çš„è¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  
  // æœ€å°å€¼ä¸1çš„è¿ç®—
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, multiply(min_val, 1))
  
  // è¾¹ç•Œå€¼ç›¸åŠ 
  assert_eq(-1, add(max_val, min_val))
}

test "new_complex_strings" {
  // æµ‹è¯•å¤æ‚å­—ç¬¦ä¸²åœºæ™¯
  // æ•°å­—å­—ç¬¦ä¸²
  assert_eq_string("Hello, 2023!", greet("2023"))
  
  // ç‰¹æ®Šç¬¦å·ç»„åˆ
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
  
  // æ··åˆå†…å®¹
  assert_eq_string("Hello, Test123!", greet("Test123"))
  
  // ç©ºæ ¼å¤„ç†
  assert_eq_string("Hello, Leading Space!", greet(" Leading Space"))
}

test "new_calculation_precision" {
  // æµ‹è¯•è®¡ç®—ç²¾åº¦
  // è¿ç»­åŠ æ³•
  let result = add(add(add(1, 2), 3), 4)
  assert_eq(10, result)
  
  // è¿ç»­ä¹˜æ³•
  let product = multiply(multiply(2, 3), 4)
  assert_eq(24, product)
  
  // æ··åˆè¿ç®—
  let mixed = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, mixed)
}