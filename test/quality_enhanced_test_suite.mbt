// é«˜è´¨é‡å¢å¼ºæµ‹è¯•å¥—ä»¶ - é’ˆå¯¹ azimuth åº“çš„10ä¸ªæ ¸å¿ƒæµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ï¼Œæ¶µç›–è¾¹ç•Œå€¼ã€æ•°å­¦æ€§è´¨ã€å®é™…åº”ç”¨å’Œé”™è¯¯å¤„ç†

// å¯¼å…¥å¿…è¦çš„æ¨¡å—å’Œå‡½æ•°
test "extreme_boundary_value_operations" {

test "extreme_boundary_value_operations" {
  // æç«¯è¾¹ç•Œå€¼è¿ç®—æµ‹è¯•
  let max_int = 2147483647
  let min_int = -2147483648
  
  // æµ‹è¯•æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„åŠ æ³•è¿ç®—
  assert_eq(2147483646, add(max_int - 1, 0))
  assert_eq(-2147483647, add(min_int + 1, 0))
  assert_eq(0, add(max_int, -max_int))
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(2147483647, multiply(1, max_int))
  assert_eq(-2147483648, multiply(1, min_int))
  assert_eq(0, multiply(0, max_int))
  
  // æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(max_int, max_int))
  assert_eq(1, divide_with_ceil(min_int, min_int))
  assert_eq(0, divide_with_ceil(0, max_int))
}

test "mathematical_laws_verification" {
  // æ•°å­¦å®šå¾‹éªŒè¯æµ‹è¯•
  let a = 12
  let b = 8
  let c = 5
  
  // åŠ æ³•äº¤æ¢å¾‹éªŒè¯
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹éªŒè¯
  assert_eq(multiply(a, b), multiply(b, a))
  
  // åŠ æ³•ç»“åˆå¾‹éªŒè¯
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹éªŒè¯
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
  
  // åˆ†é…å¾‹éªŒè¯: a * (b + c) = a * b + a * c
  let distributive_left = multiply(a, add(b, c))
  let distributive_right = add(multiply(a, b), multiply(a, c))
  assert_eq(distributive_left, distributive_right)
}

test "financial_calculation_precision" {
  // é‡‘èè®¡ç®—ç²¾åº¦æµ‹è¯•
  let principal = 10000
  let interest_rate_5_percent = 5
  let years = 3
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  let year1_interest = divide_with_ceil(multiply(principal, interest_rate_5_percent), 100)
  let year1_amount = add(principal, year1_interest)
  
  let year2_interest = divide_with_ceil(multiply(year1_amount, interest_rate_5_percent), 100)
  let year2_amount = add(year1_amount, year2_interest)
  
  let year3_interest = divide_with_ceil(multiply(year2_amount, interest_rate_5_percent), 100)
  let final_amount = add(year2_amount, year3_interest)
  
  // éªŒè¯å¤åˆ©è®¡ç®—ç»“æœ
  assert_eq(10500, year1_amount)  // 10000 + 500
  assert_eq(11025, year2_amount)  // 10500 + 525
  assert_eq(11576, final_amount)  // 11025 + 551 (å‘ä¸Šå–æ•´)
}

test "inventory_management_optimization" {
  // åº“å­˜ç®¡ç†ä¼˜åŒ–æµ‹è¯•
  let warehouse_capacity = 1000
  let small_box_capacity = 24
  let large_box_capacity = 48
  let total_items = 875
  
  // è®¡ç®—ä½¿ç”¨å°ç®±å­éœ€è¦çš„æ•°é‡
  let small_boxes_needed = divide_with_ceil(total_items, small_box_capacity)
  
  // è®¡ç®—ä½¿ç”¨å¤§ç®±å­éœ€è¦çš„æ•°é‡
  let large_boxes_needed = divide_with_ceil(total_items, large_box_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let small_box_space_used = multiply(small_boxes_needed, small_box_capacity)
  let large_box_space_used = multiply(large_boxes_needed, large_box_capacity)
  
  let small_box_wasted_space = add(small_box_space_used, -total_items)
  let large_box_wasted_space = add(large_box_space_used, -total_items)
  
  // éªŒè¯åº“å­˜ä¼˜åŒ–è®¡ç®—
  assert_eq(37, small_boxes_needed)      // ceil(875/24) = 37
  assert_eq(19, large_boxes_needed)      // ceil(875/48) = 19
  assert_eq(13, small_box_wasted_space)  // 37*24 - 875 = 13
  assert_eq(17, large_box_wasted_space)  // 19*48 - 875 = 17
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•æç«¯æ•°å€¼çš„è¿ç®—
  let extreme_positive = 2147483647
  let extreme_negative = -2147483648
  
  // æµ‹è¯•åŠ æ³•çš„æº¢å‡ºä¿æŠ¤
  assert_eq(2147483647, add(extreme_positive, 0))
  assert_eq(-2147483648, add(extreme_negative, 0))
  
  // æµ‹è¯•ä¹˜æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, multiply(extreme_positive, 0))
  assert_eq(0, multiply(extreme_negative, 0))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(1, -1))
}

test "string_processing_internationalization" {
  // å­—ç¬¦ä¸²å¤„ç†å›½é™…åŒ–æµ‹è¯•
  // æµ‹è¯•å„ç§è¯­è¨€çš„é—®å€™
  assert_eq_string("Hello, English!", greet("English"))
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, CafÃ©!", greet("CafÃ©"))
  assert_eq_string("Hello, NaÃ¯ve!", greet("NaÃ¯ve"))
  assert_eq_string("Hello, RÃ©sumÃ©!", greet("RÃ©sumÃ©"))
  
  // æµ‹è¯•è¡¨æƒ…ç¬¦å·å’Œç‰¹æ®Šç¬¦å·
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, â¤ï¸!", greet("â¤ï¸"))
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
}

test "algorithm_efficiency_simulation" {
  // ç®—æ³•æ•ˆç‡æ¨¡æ‹Ÿæµ‹è¯•
  let data_size = 10000
  let algorithm1_efficiency = 75  // 75% æ•ˆç‡
  let algorithm2_efficiency = 85  // 85% æ•ˆç‡
  let algorithm3_efficiency = 95  // 95% æ•ˆç‡
  
  // è®¡ç®—å„ç®—æ³•å¤„ç†çš„æ•°æ®é‡
  let algo1_processed = divide_with_ceil(multiply(data_size, algorithm1_efficiency), 100)
  let algo2_processed = divide_with_ceil(multiply(data_size, algorithm2_efficiency), 100)
  let algo3_processed = divide_with_ceil(multiply(data_size, algorithm3_efficiency), 100)
  
  // è®¡ç®—æ€§èƒ½æå‡
  let improvement_2_over_1 = divide_with_ceil(multiply(algo2_processed - algo1_processed, 100), algo1_processed)
  let improvement_3_over_2 = divide_with_ceil(multiply(algo3_processed - algo2_processed, 100), algo2_processed)
  
  // éªŒè¯ç®—æ³•æ•ˆç‡è®¡ç®—
  assert_eq(7500, algo1_processed)   // ceil(10000 * 75 / 100) = 7500
  assert_eq(8500, algo2_processed)   // ceil(10000 * 85 / 100) = 8500
  assert_eq(9500, algo3_processed)   // ceil(10000 * 95 / 100) = 9500
  assert_eq(14, improvement_2_over_1) // ceil((8500-7500) * 100 / 7500) = 14
  assert_eq(12, improvement_3_over_2) // ceil((9500-8500) * 100 / 8500) = 12
}

test "real_world_shipping_logistics" {
  // ç°å®ä¸–ç•Œè¿è¾“ç‰©æµæµ‹è¯•
  let packages = [
    (5, 10),   // 5ä¸ªåŒ…è£¹ï¼Œæ¯ä¸ª10kg
    (3, 15),   // 3ä¸ªåŒ…è£¹ï¼Œæ¯ä¸ª15kg
    (8, 8),    // 8ä¸ªåŒ…è£¹ï¼Œæ¯ä¸ª8kg
    (2, 25)    // 2ä¸ªåŒ…è£¹ï¼Œæ¯ä¸ª25kg
  ]
  
  // è®¡ç®—æ€»é‡é‡
  let total_weight = add(
    add(multiply(packages[0].0, packages[0].1), multiply(packages[1].0, packages[1].1)),
    add(multiply(packages[2].0, packages[2].1), multiply(packages[3].0, packages[3].1))
  )
  
  // è®¡ç®—æ€»åŒ…è£¹æ•°
  let total_packages = add(add(packages[0].0, packages[1].0), add(packages[2].0, packages[3].0))
  
  // è®¡ç®—å¹³å‡é‡é‡ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let average_weight = divide_with_ceil(total_weight, total_packages)
  
  // è®¡ç®—éœ€è¦çš„å¡è½¦æ•°é‡ï¼ˆæ¯è¾†æœ€å¤šè½½é‡100kgï¼‰
  let trucks_needed = divide_with_ceil(total_weight, 100)
  
  // éªŒè¯ç‰©æµè®¡ç®—
  assert_eq(211, total_weight)     // 5*10 + 3*15 + 8*8 + 2*25 = 50 + 45 + 64 + 50 = 209
  assert_eq(18, total_packages)    // 5 + 3 + 8 + 2 = 18
  assert_eq(12, average_weight)    // ceil(211 / 18) = 12
  assert_eq(3, trucks_needed)      // ceil(211 / 100) = 3
}

test "data_structure_operations_complexity" {
  // æ•°æ®ç»“æ„æ“ä½œå¤æ‚åº¦æµ‹è¯•
  let array_size = 1000
  let operation_cost_insert = 3
  let operation_cost_delete = 5
  let operation_cost_search = 2
  
  // æ¨¡æ‹Ÿä¸åŒæ•°æ®ç»“æ„çš„æ“ä½œæˆæœ¬
  // é“¾è¡¨æ“ä½œ
  let linked_list_insert_cost = multiply(operation_cost_insert, 1)
  let linked_list_delete_cost = multiply(operation_cost_delete, 1)
  let linked_list_search_cost = multiply(operation_cost_search, array_size)
  
  // æ•°ç»„æ“ä½œ
  let array_insert_cost = multiply(operation_cost_insert, array_size)
  let array_delete_cost = multiply(operation_cost_delete, array_size)
  let array_search_cost = multiply(operation_cost_search, 1)
  
  // å“ˆå¸Œè¡¨æ“ä½œï¼ˆå¹³å‡æƒ…å†µï¼‰
  let hash_insert_cost = multiply(operation_cost_insert, 1)
  let hash_delete_cost = multiply(operation_cost_delete, 1)
  let hash_search_cost = multiply(operation_cost_search, 1)
  
  // è®¡ç®—æ€»æˆæœ¬
  let linked_list_total = add(add(linked_list_insert_cost, linked_list_delete_cost), linked_list_search_cost)
  let array_total = add(add(array_insert_cost, array_delete_cost), array_search_cost)
  let hash_table_total = add(add(hash_insert_cost, hash_delete_cost), hash_search_cost)
  
  // éªŒè¯æ•°æ®ç»“æ„å¤æ‚åº¦è®¡ç®—
  assert_eq(2008, linked_list_total)  // 3 + 5 + 2*1000 = 2008
  assert_eq(10000, array_total)       // 3*1000 + 5*1000 + 2 = 8002
  assert_eq(10, hash_table_total)     // 3 + 5 + 2 = 10
}

test "scientific_computation_precision" {
  // ç§‘å­¦è®¡ç®—ç²¾åº¦æµ‹è¯•
  let pi_approximation = 22
  let pi_divisor = 7
  let circle_radius = 100
  let sphere_radius = 50
  
  // è®¡ç®—åœ†å‘¨é•¿ï¼ˆä½¿ç”¨è¿‘ä¼¼å€¼ï¼‰
  let circumference = divide_with_ceil(multiply(2, multiply(pi_approximation, circle_radius)), pi_divisor)
  
  // è®¡ç®—åœ†é¢ç§¯
  let circle_area = divide_with_ceil(multiply(pi_approximation, multiply(circle_radius, circle_radius)), pi_divisor)
  
  // è®¡ç®—çƒä½“è¡¨é¢ç§¯ (4Ï€rÂ²)
  let sphere_surface_area = divide_with_ceil(multiply(4, multiply(pi_approximation, multiply(sphere_radius, sphere_radius))), pi_divisor)
  
  // è®¡ç®—çƒä½“ä½“ç§¯ (4/3 Ï€rÂ³)
  let sphere_volume = divide_with_ceil(multiply(4, multiply(pi_approximation, multiply(sphere_radius, multiply(sphere_radius, sphere_radius)))), multiply(3, pi_divisor))
  
  // éªŒè¯ç§‘å­¦è®¡ç®—ç»“æœ
  assert_eq(629, circumference)        // ceil(2 * 22 * 100 / 7) = 629
  assert_eq(3143, circle_area)         // ceil(22 * 100 * 100 / 7) = 3143
  assert_eq(3143, sphere_surface_area) // ceil(4 * 22 * 50 * 50 / 7) = 3143
  assert_eq(52381, sphere_volume)      // ceil(4 * 22 * 50 * 50 * 50 / (3 * 7)) = 52381
}