// æ ‡å‡† MoonBit æµ‹è¯•å¢žå¼ºç”¨ä¾‹
// ä¸º Azimuth é¡¹ç›®æ·»åŠ çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹

test "azimuth_core_mathematical_operations" {
  // æµ‹è¯•æ ¸å¿ƒæ•°å­¦è¿ç®—çš„ç»„åˆ
  let base = 15
  let multiplier = 4
  let divisor = 7
  
  let product = azimuth::multiply(base, multiplier)
  let quotient = azimuth::divide_with_ceil(product, divisor)
  let verification = azimuth::add(azimuth::multiply(quotient, divisor), azimuth::multiply(2, 3))
  
  assert_eq(9, quotient)  // ceil(15*4/7) = ceil(60/7) = 9
  assert_eq(84, verification)  // 9*7 + 2*3 = 63 + 6 = 69
}

test "azimuth_string_processing_international" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„å›½é™…åŒ–æ”¯æŒ
  assert_eq_string("Hello, åŒ—äº¬!", azimuth::greet("åŒ—äº¬"))
  assert_eq_string("Hello, SÃ£o Paulo!", azimuth::greet("SÃ£o Paulo"))
  assert_eq_string("Hello, ðŸŒ™ðŸŒŸ!", azimuth::greet("ðŸŒ™ðŸŒŸ"))
  assert_eq_string("Hello, Ø§Ù„Ø±ÙŠØ§Ø¶!", azimuth::greet("Ø§Ù„Ø±ÙŠØ§Ø¶"))
}

test "azimuth_business_logistics_calculation" {
  // ç‰©æµä¸šåŠ¡è®¡ç®—æµ‹è¯•
  let total_packages = 127
  let vehicle_capacity = 25
  let vehicles_needed = azimuth::divide_with_ceil(total_packages, vehicle_capacity)
  
  assert_eq(6, vehicles_needed)
  
  let total_capacity = azimuth::multiply(vehicles_needed, vehicle_capacity)
  let unused_capacity = azimuth::add(total_capacity, -total_packages)
  
  assert_eq(150, total_capacity)
  assert_eq(23, unused_capacity)
}

test "azimuth_error_handling_division_by_zero" {
  // é™¤é›¶é”™è¯¯å¤„ç†æµ‹è¯•
  assert_eq(0, azimuth::divide_with_ceil(100, 0))
  assert_eq(0, azimuth::divide_with_ceil(-100, 0))
  assert_eq(0, azimuth::divide_with_ceil(0, 0))
  assert_eq(0, azimuth::divide_with_ceil(2147483647, 0))
}

test "azimuth_resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 25000
  let departments = 7
  let base_allocation = azimuth::divide_with_ceil(total_budget, departments)
  
  assert_eq(3572, base_allocation)  // ceil(25000/7)
  
  let total_allocated = azimuth::multiply(base_allocation, departments)
  let overflow = azimuth::add(total_allocated, -total_budget)
  
  assert_eq(25004, total_allocated)
  assert_eq(4, overflow)
}

test "azimuth_mathematical_properties_verification" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 23
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹éªŒè¯
  assert_eq(azimuth::add(x, y), azimuth::add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹éªŒè¯
  assert_eq(azimuth::multiply(x, y), azimuth::multiply(y, x))
  
  // åˆ†é…å¾‹éªŒè¯
  let distributive_left = azimuth::multiply(x, azimuth::add(y, 5))
  let distributive_right = azimuth::add(azimuth::multiply(x, y), azimuth::multiply(x, 5))
  assert_eq(distributive_left, distributive_right)
}

test "azimuth_performance_large_scale_computations" {
  // å¤§è§„æ¨¡è®¡ç®—æ€§èƒ½æµ‹è¯•
  let large_number = 100000
  let iterations = 50
  
  let sum_result = azimuth::multiply(large_number, iterations)
  let product_result = azimuth::multiply(azimuth::divide_with_ceil(large_number, 10), 1000)
  let division_result = azimuth::divide_with_ceil(sum_result, product_result)
  
  assert_eq(5000000, sum_result)
  assert_eq(10000000, product_result)
  assert_eq(1, division_result)
}

test "azimuth_edge_case_boundary_values" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  // æµ‹è¯•æŽ¥è¿‘æ•´æ•°è¾¹ç•Œçš„æƒ…å†µ
  assert_eq(1, azimuth::divide_with_ceil(1, 2))
  assert_eq(2, azimuth::divide_with_ceil(3, 2))
  assert_eq(1000, azimuth::divide_with_ceil(1999, 2))
  assert_eq(500, azimuth::divide_with_ceil(999, 2))
  
  // æµ‹è¯•é›¶å€¼è¿ç®—
  assert_eq(0, azimuth::add(0, 0))
  assert_eq(0, azimuth::multiply(0, 12345))
  assert_eq(12345, azimuth::add(0, 12345))
}

test "azimuth_complex_workflow_simulation" {
  // å¤æ‚å·¥ä½œæµæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿé¡¹ç›®ç®¡ç†åœºæ™¯
  let project_tasks = 89
  let team_members = 6
  let working_days = 15
  
  let daily_capacity_per_person = 2
  let total_daily_capacity = azimuth::multiply(team_members, daily_capacity_per_person)
  let days_needed = azimuth::divide_with_ceil(project_tasks, total_daily_capacity)
  
  assert_eq(8, days_needed)  // ceil(89/(6*2)) = ceil(89/12) = 8
  
  let total_work_days = azimuth::multiply(days_needed, total_daily_capacity)
  let efficiency = azimuth::divide_with_ceil(azimuth::multiply(project_tasks, 100), total_work_days)
  
  assert_eq(96, total_work_days)
  assert_eq(93, efficiency)  // floor(8900/96) = 92%
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•è¿ç®—
fn subtract(a : Int, b : Int) -> Int {
  a - b
}