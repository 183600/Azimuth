// Azimuth é¡¹ç›®æ–°å¢æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ç¼–å†™
// è¦†ç›–è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œå®é™…åº”ç”¨åœºæ™¯

test "extreme_boundary_values" {
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼
  assert_eq(2147483647, add(2147483646, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483648, add(-2147483647, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(0, add(2147483647, -2147483647))  // æœ€å¤§å€¼ä¸ç›¸åæ•°ç›¸åŠ 
}

test "divide_with_ceil_precision_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦æƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))  // å®Œå…¨ç›¸ç­‰
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(100, divide_with_ceil(9999, 100))  // 99.99 -> 100
  assert_eq(-3, divide_with_ceil(-10, 3))  // -10/3 = -3.333... -> -3
}

test "complex_business_calculation" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—ï¼šè®¢å•æ€»ä»·è®¡ç®—
  let product_price = 89
  let quantity = 4
  let tax_rate = 8
  let shipping = 12
  let discount = 20
  
  let subtotal = multiply(product_price, quantity)
  let tax = divide_with_ceil(multiply(subtotal, tax_rate), 100)
  let total_before_discount = add(add(subtotal, tax), shipping)
  let final_total = add(total_before_discount, -discount)
  
  assert_eq(356, subtotal)
  assert_eq(29, tax)
  assert_eq(397, total_before_discount)
  assert_eq(377, final_total)
}

test "string_greeting_unicode_extended" {
  // æ‰©å±•Unicodeå­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, ğŸš€ğŸŒŸ!", greet("ğŸš€ğŸŒŸ"))
  assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", greet("Î±Î²Î³Î´Îµ"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³ÃºÃ¼!", greet("Ã±Ã¡Ã©Ã­Ã³ÃºÃ¼"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—ï¼šç­‰å·®æ•°åˆ—æ±‚å’Œ
  let first_term = 3
  let common_difference = 2
  let number_of_terms = 10
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šS = n/2 * (2a + (n-1)d)
  let sum_formula = divide_with_ceil(
    multiply(number_of_terms, add(multiply(2, first_term), multiply(number_of_terms - 1, common_difference))),
    2
  )
  
  assert_eq(120, sum_formula)  // 10/2 * (6 + 18) = 5 * 24 = 120
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  assert_eq(0, divide_with_ceil(100, 0))  // é™¤æ•°ä¸ºé›¶
  assert_eq(0, divide_with_ceil(-100, 0))  // è´Ÿæ•°é™¤ä»¥é›¶
  assert_eq(0, divide_with_ceil(0, 0))  // é›¶é™¤ä»¥é›¶
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯ï¼šé¡¹ç›®å®Œæˆæ—¶é—´
  let tasks_per_day = 8
  let total_tasks = 45
  let days_needed = divide_with_ceil(total_tasks, tasks_per_day)
  let total_hours = multiply(days_needed, 8)
  
  assert_eq(6, days_needed)  // ceil(45/8) = 6
  assert_eq(48, total_hours)  // 6 * 8 = 48
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let project_cost = multiply(150, 4)  // 4ä¸ªé¡¹ç›®ï¼Œæ¯ä¸ª150
  let remaining = add(total_budget, -project_cost)
  let small_projects = divide_with_ceil(remaining, 80)  // æ¯ä¸ªå°é¡¹ç›®80
  
  assert_eq(600, project_cost)
  assert_eq(9400, remaining)
  assert_eq(118, small_projects)
}

test "nested_function_composition" {
  // åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 10
  let multiplier = 3
  let divisor = 4
  
  // å¤æ‚åµŒå¥—ï¼š((base * multiplier) + (base * 2)) / divisor
  let complex_result = divide_with_ceil(
    add(multiply(base_value, multiplier), multiply(base_value, 2)),
    divisor
  )
  
  assert_eq(12, complex_result)  // ceil((10*3 + 10*2) / 4) = ceil(50/4) = 13
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—
  let principal = 1000
  let rate_percent = 5
  
  // ç®€åŒ–çš„3å¹´å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´å‘ä¸Šå–æ•´ï¼‰
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  
  assert_eq(1050, year1)  // 1000 + ceil(1000*5/100) = 1000 + 50 = 1050
  assert_eq(1103, year2)  // 1050 + ceil(1050*5/100) = 1050 + 53 = 1103
  assert_eq(1158, year3)  // 1103 + ceil(1103*5/100) = 1103 + 55 = 1158
}