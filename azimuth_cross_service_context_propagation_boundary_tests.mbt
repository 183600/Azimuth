// è·¨æœåŠ¡ä¸Šä¸‹æ–‡ä¼ æ’­çš„è¾¹ç•Œæƒ…å†µæµ‹è¯•
// æµ‹è¯•è·¨æœåŠ¡ä¼ æ’­ä¸­çš„å„ç§è¾¹ç•Œæƒ…å†µå’Œå¼‚å¸¸åœºæ™¯

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„è¶…é•¿ä¸Šä¸‹æ–‡å¤„ç†" {
  // æµ‹è¯•è¶…é•¿ä¸Šä¸‹æ–‡çš„ä¼ æ’­å¤„ç†
  let trace_id = "trace-" + "a" * 100  // åˆ›å»ºè¶…é•¿trace ID
  let span_id = "span-" + "b" * 50     // åˆ›å»ºè¶…é•¿span ID
  let span_ctx = SpanContext::new(trace_id, span_id, true, "key=" + "c" * 1000)
  
  let carrier = TextMapCarrier::new()
  let propagator = W3CTraceContextPropagator::new()
  
  // æ³¨å…¥è¶…é•¿ä¸Šä¸‹æ–‡
  W3CTraceContextPropagator::inject(propagator, span_ctx, carrier)
  
  // éªŒè¯è¶…é•¿ä¸Šä¸‹æ–‡è¢«æ­£ç¡®å¤„ç†ï¼ˆæˆªæ–­æˆ–åˆ†æ®µï¼‰
  let traceparent_header = TextMapCarrier::get(carrier, "traceparent")
  assert_true(traceparent_header.length > 0, "Should have traceparent header even with long context")
  
  // æå–å¹¶éªŒè¯
  let extracted_ctx = W3CTraceContextPropagator::extract(propagator, carrier)
  assert_true(SpanContext::is_valid(extracted_ctx), "Extracted context should be valid")
  
  // éªŒè¯æˆªæ–­å¤„ç†
  let extracted_trace_id = SpanContext::trace_id(extracted_ctx)
  let extracted_span_id = SpanContext::span_id(extracted_ctx)
  assert_true(extracted_trace_id.length <= 128, "Trace ID should be truncated to reasonable length")
  assert_true(extracted_span_id.length <= 64, "Span ID should be truncated to reasonable length")
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„ç‰¹æ®Šå­—ç¬¦å’Œç¼–ç å¤„ç†" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„ä¸Šä¸‹æ–‡ä¼ æ’­
  let trace_id = "trace-special-!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let span_id = "span-unicode-æµ‹è¯•-ğŸš€-ğŸ“Š-ğŸ“ˆ"
  let trace_state = "key1=value1 with spaces;key2=value2@#$%;key3=æµ‹è¯•å€¼"
  
  let span_ctx = SpanContext::new(trace_id, span_id, true, trace_state)
  let carrier = TextMapCarrier::new()
  let propagator = W3CTraceContextPropagator::new()
  
  // æ³¨å…¥åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„ä¸Šä¸‹æ–‡
  W3CTraceContextPropagator::inject(propagator, span_ctx, carrier)
  
  // æå–å¹¶éªŒè¯
  let extracted_ctx = W3CTraceContextPropagator::extract(propagator, carrier)
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_true(SpanContext::is_valid(extracted_ctx), "Context with special characters should be valid")
  assert_true(SpanContext::trace_id(extracted_ctx).contains("trace-special"), "Should preserve readable part")
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„å¾ªç¯ä¾èµ–æ£€æµ‹" {
  // æµ‹è¯•æœåŠ¡è°ƒç”¨é“¾ä¸­çš„å¾ªç¯ä¾èµ–æ£€æµ‹
  let service_a_ctx = SpanContext::new("trace-cycle", "span-a", true, "")
  let carrier = TextMapCarrier::new()
  let propagator = W3CTraceContextPropagator::new()
  
  // æœåŠ¡Aæ³¨å…¥ä¸Šä¸‹æ–‡
  W3CTraceContextPropagator::inject(propagator, service_a_ctx, carrier)
  
  // æœåŠ¡Bæå–å¹¶åˆ›å»ºå­span
  let service_b_ctx = W3CTraceContextPropagator::extract(propagator, carrier)
  let service_b_span = Span::new("service-b-operation", Server, service_b_ctx)
  
  // æ¨¡æ‹ŸæœåŠ¡Bè°ƒç”¨å›æœåŠ¡A
  let return_carrier = TextMapCarrier::new()
  W3CTraceContextPropagator::inject(propagator, Span::span_context(service_b_span), return_carrier)
  
  // æœåŠ¡Aæ£€æµ‹å¾ªç¯ä¾èµ–
  let return_ctx = W3CTraceContextPropagator::extract(propagator, return_carrier)
  let cycle_detector = Context::CycleDetector::new()
  let is_circular = Context::CycleDetector::detect(cycle_detector, service_a_ctx, return_ctx)
  
  assert_true(is_circular, "Should detect circular dependency in service calls")
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„ä¸Šä¸‹æ–‡æŸåæ¢å¤" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡æŸåæ—¶çš„æ¢å¤æœºåˆ¶
  let original_ctx = SpanContext::new("trace-corruption", "span-original", true, "key=value")
  let carrier = TextMapCarrier::new()
  let propagator = W3CTraceContextPropagator::new()
  
  // æ­£å¸¸æ³¨å…¥
  W3CTraceContextPropagator::inject(propagator, original_ctx, carrier)
  
  // æ¨¡æ‹Ÿä¸Šä¸‹æ–‡æŸå
  TextMapCarrier::set(carrier, "traceparent", "corrupted-header-value")
  TextMapCarrier::set(carrier, "extra-header", "malicious-content")
  
  // å°è¯•æå–å¹¶æ¢å¤
  let recovery_propagator = W3CTraceContextPropagator::with_recovery()
  let recovered_ctx = W3CTraceContextPropagator::extract(recovery_propagator, carrier)
  
  // éªŒè¯æ¢å¤æœºåˆ¶
  assert_true(SpanContext::is_valid(recovered_ctx), "Should recover from corrupted context")
  assert_not_eq(SpanContext::trace_id(recovered_ctx), "", "Should have valid trace ID after recovery")
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„å¹¶å‘ä¸Šä¸‹æ–‡ç®¡ç†" {
  // æµ‹è¯•å¹¶å‘åœºæ™¯ä¸‹çš„ä¸Šä¸‹æ–‡ä¼ æ’­
  let base_ctx = SpanContext::new("trace-concurrent", "span-base", true, "")
  let propagator = W3CTraceContextPropagator::new()
  
  // åˆ›å»ºå¤šä¸ªå¹¶å‘ä¼ æ’­ä»»åŠ¡
  let concurrent_tasks = []
  for i in 0..10 {
    let task = fn() {
      let carrier = TextMapCarrier::new()
      W3CTraceContextPropagator::inject(propagator, base_ctx, carrier)
      
      // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
      // Thread::sleep(10)
      
      let extracted_ctx = W3CTraceContextPropagator::extract(propagator, carrier)
      return extracted_ctx
    }
    concurrent_tasks.push(task)
  }
  
  // æ‰§è¡Œå¹¶å‘ä»»åŠ¡
  let results = []
  for task in concurrent_tasks {
    let result = task()
    results.push(result)
  }
  
  // éªŒè¯æ‰€æœ‰ç»“æœä¸€è‡´
  for i in 1..results.length {
    assert_eq(SpanContext::trace_id(results[0]), SpanContext::trace_id(results[i]), "All contexts should have same trace ID")
    assert_true(SpanContext::is_valid(results[i]), "All extracted contexts should be valid")
  }
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„baggageå¤§å°é™åˆ¶" {
  // æµ‹è¯•baggageå¤§å°é™åˆ¶å¤„ç†
  let baggage = Baggage::new()
  let large_value = "x" * 10000  // åˆ›å»ºè¶…å¤§å€¼
  
  // æ·»åŠ å¤§é‡baggageæ¡ç›®
  for i in 0..100 {
    let key = "baggage.key." + i.to_string()
    let value = if i == 50 { large_value } else { "value-" + i.to_string() }
    Baggage::set_entry(baggage, key, value)
  }
  
  let carrier = TextMapCarrier::new()
  let baggage_propagator = W3CBaggagePropagator::with_limits(8192) // 8KBé™åˆ¶
  
  // æ³¨å…¥baggage
  W3CBaggagePropagator::inject(baggage_propagator, baggage, carrier)
  
  // éªŒè¯å¤§å°é™åˆ¶å¤„ç†
  let baggage_header = TextMapCarrier::get(carrier, "baggage")
  assert_true(baggage_header.length > 0, "Should have baggage header")
  assert_true(baggage_header.length <= 8192, "Baggage header should respect size limit")
  
  // æå–å¹¶éªŒè¯
  let extracted_baggage = W3CBaggagePropagator::extract(baggage_propagator, carrier)
  
  // éªŒè¯é‡è¦æ¡ç›®ä¿ç•™
  let important_entry = Baggage::get_entry(extracted_baggage, "baggage.key.0")
  assert_eq(important_entry, Some("value-0"), "Important entries should be preserved")
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„ä¸Šä¸‹æ–‡ç‰ˆæœ¬å…¼å®¹æ€§" {
  // æµ‹è¯•ä¸åŒç‰ˆæœ¬é—´çš„ä¸Šä¸‹æ–‡å…¼å®¹æ€§
  let v1_ctx = SpanContext::new("trace-version", "span-v1", true, "")
  let carrier = TextMapCarrier::new()
  let v1_propagator = W3CTraceContextPropagator::with_version("v1")
  
  // ä½¿ç”¨v1æ ¼å¼æ³¨å…¥
  W3CTraceContextPropagator::inject(v1_propagator, v1_ctx, carrier)
  
  // ä½¿ç”¨v2æ ¼å¼æå–
  let v2_propagator = W3CTraceContextPropagator::with_version("v2")
  let extracted_ctx = W3CTraceContextPropagator::extract(v2_propagator, carrier)
  
  // éªŒè¯å‘åå…¼å®¹æ€§
  assert_true(SpanContext::is_valid(extracted_ctx), "v2 should be able to extract v1 context")
  assert_eq(SpanContext::trace_id(extracted_ctx), "trace-version", "Trace ID should be preserved across versions")
  
  // æµ‹è¯•å‘å‰å…¼å®¹æ€§
  let v2_ctx = SpanContext::new("trace-version-v2", "span-v2", true, "")
  let v2_carrier = TextMapCarrier::new()
  W3CTraceContextPropagator::inject(v2_propagator, v2_ctx, v2_carrier)
  
  let v1_extracted_ctx = W3CTraceContextPropagator::extract(v1_propagator, v2_carrier)
  assert_true(SpanContext::is_valid(v1_extracted_ctx), "v1 should handle v2 context gracefully")
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„ç½‘ç»œåˆ†åŒºæ¢å¤" {
  // æµ‹è¯•ç½‘ç»œåˆ†åŒºæƒ…å†µä¸‹çš„ä¸Šä¸‹æ–‡æ¢å¤
  let primary_ctx = SpanContext::new("trace-partition", "span-primary", true, "primary=true")
  let backup_ctx = SpanContext::new("trace-partition-backup", "span-backup", true, "backup=true")
  
  let carrier = TextMapCarrier::new()
  let propagator = W3CTraceContextPropagator::with_fallback()
  
  // æ­£å¸¸æƒ…å†µæ³¨å…¥ä¸»è¦ä¸Šä¸‹æ–‡
  W3CTraceContextPropagator::inject(propagator, primary_ctx, carrier)
  
  // æ¨¡æ‹Ÿç½‘ç»œåˆ†åŒºï¼Œä¸»è¦ä¸Šä¸‹æ–‡ä¸¢å¤±
  TextMapCarrier::remove(carrier, "traceparent")
  
  // ä½¿ç”¨å¤‡ç”¨ä¸Šä¸‹æ–‡
  W3CTraceContextPropagator::inject_fallback(propagator, backup_ctx, carrier)
  
  // æå–å¹¶éªŒè¯æ¢å¤
  let recovered_ctx = W3CTraceContextPropagator::extract_with_fallback(propagator, carrier)
  
  assert_true(SpanContext::is_valid(recovered_ctx), "Should recover from network partition")
  assert_eq(SpanContext::trace_id(recovered_ctx), "trace-partition-backup", "Should use fallback context")
}

test "è·¨æœåŠ¡ä¼ æ’­ä¸­çš„ä¸Šä¸‹æ–‡å®‰å…¨è¿‡æ»¤" {
  // æµ‹è¯•æ•æ„Ÿä¿¡æ¯çš„å®‰å…¨è¿‡æ»¤
  let sensitive_ctx = SpanContext::new("trace-secure", "span-secure", true, 
    "user.id=12345;session.token=secret123;public.info=safe")
  
  let carrier = TextMapCarrier::new()
  let secure_propagator = W3CTraceContextPropagator::with_security_filter()
  
  // æ·»åŠ å®‰å…¨è¿‡æ»¤è§„åˆ™
  W3CTraceContextPropagator::add_filter_rule(secure_propagator, "session.token", "redact")
  W3CTraceContextPropagator::add_filter_rule(secure_propagator, "user.id", "hash")
  
  // æ³¨å…¥å¸¦å®‰å…¨è¿‡æ»¤çš„ä¸Šä¸‹æ–‡
  W3CTraceContextPropagator::inject(secure_propagator, sensitive_ctx, carrier)
  
  // æå–å¹¶éªŒè¯è¿‡æ»¤ç»“æœ
  let filtered_ctx = W3CTraceContextPropagator::extract(secure_propagator, carrier)
  let filtered_state = SpanContext::trace_state(filtered_ctx)
  
  // éªŒè¯æ•æ„Ÿä¿¡æ¯è¢«è¿‡æ»¤
  assert_true(filtered_state.contains("public.info=safe"), "Public info should be preserved")
  assert_true(filtered_state.contains("session.token=[REDACTED]"), "Sensitive token should be redacted")
  assert_true(filtered_state.contains("user.id=[HASHED]"), "User ID should be hashed")
  assert_false(filtered_state.contains("secret123"), "Original secret should not be present")
}