// Azimuth Comprehensive Quality Tests
// ç»¼åˆè´¨é‡æµ‹è¯•ç”¨ä¾‹ - è¦†ç›–é¥æµ‹ç³»ç»Ÿçš„å…³é”®åŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

// æµ‹è¯•1: é¥æµ‹æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
test "é¥æµ‹æ•°æ®åºåˆ—åŒ–ååºåˆ—åŒ–æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "serialization-test")
  
  // åˆ›å»ºåŒ…å«å¤šç§æ•°æ®ç±»å‹çš„Span
  let span = Tracer::start_span(tracer, "serialization-span")
  
  // æ·»åŠ äº‹ä»¶
  Span::add_event(span, "test-event", Some([("event.data", StringValue("event-data"))]))
  
  // éªŒè¯Spanåç§°
  assert_eq(Span::name(span), "serialization-span")
  match Span::get_attribute(deserialized_span, "string.value") {
    Some(StringValue(value)) => assert_eq(value, "test-string")
    _ => assert_true(false)
  }
  match Span::get_attribute(deserialized_span, "int.value") {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  match Span::get_attribute(deserialized_span, "float.value") {
    Some(FloatValue(value)) => assert_eq(value, 3.14)
    _ => assert_true(false)
  }
  match Span::get_attribute(deserialized_span, "bool.value") {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  Span::end(span)
  Span::end(deserialized_span)
}

// æµ‹è¯•2: è·¨æœåŠ¡ä¼ æ’­ä¸Šä¸‹æ–‡æµ‹è¯•
test "è·¨æœåŠ¡ä¼ æ’­ä¸Šä¸‹æ–‡æµ‹è¯•" {
  let tracer_provider1 = TracerProvider::new()
  let tracer1 = TracerProvider::get_tracer(tracer_provider1, "service-a")
  
  // åœ¨æœåŠ¡Aä¸­åˆ›å»ºSpan
  let parent_span = Tracer::start_span(tracer1, "service-a-operation")
  Span::set_attribute(parent_span, "service.name", StringValue("service-a"))
  
  // æå–ä¼ æ’­ä¸Šä¸‹æ–‡
  let context = Span::get_context(parent_span)
  let propagation_headers = W3CTraceContextPropagator::inject(context)
  
  // éªŒè¯ä¼ æ’­å¤´éƒ¨åŒ…å«å¿…è¦ä¿¡æ¯
  assert_true(propagation_headers.contains("traceparent"))
  assert_true(propagation_headers.contains("tracestate"))
  
  // æ¨¡æ‹ŸæœåŠ¡Bæ¥æ”¶ä¸Šä¸‹æ–‡
  let tracer_provider2 = TracerProvider::new()
  let tracer2 = TracerProvider::get_tracer(tracer_provider2, "service-b")
  
  let extracted_context = W3CTraceContextPropagator::extract(propagation_headers)
  let child_span = Tracer::start_span_with_context(tracer2, "service-b-operation", extracted_context)
  
  // éªŒè¯çˆ¶å­å…³ç³»
  assert_eq(Span::get_trace_id(child_span), Span::get_trace_id(parent_span))
  assert_eq(Span::get_parent_span_id(child_span), Span::get_span_id(parent_span))
  
  Span::set_attribute(child_span, "service.name", StringValue("service-b"))
  
  Span::end(parent_span)
  Span::end(child_span)
}

// æµ‹è¯•3: æ€§èƒ½æŒ‡æ ‡æ”¶é›†å’Œèšåˆæµ‹è¯•
test "æ€§èƒ½æŒ‡æ ‡æ”¶é›†å’Œèšåˆæµ‹è¯•" {
  let meter_provider = MeterProvider::new()
  let meter = MeterProvider::get_meter(meter_provider, "performance-test")
  
  // åˆ›å»ºä¸åŒç±»å‹çš„æŒ‡æ ‡
  let counter = Meter::create_counter(meter, "request.count", Some("requests"), Some("Total number of requests"))
  let histogram = Meter::create_histogram(meter, "request.duration", Some("ms"), Some("Request duration distribution"))
  let gauge = Meter::create_gauge(meter, "memory.usage", Some("MB"), Some("Current memory usage"))
  
  // æ¨¡æ‹Ÿè®°å½•æŒ‡æ ‡æ•°æ®
  for i = 0; i < 100; i++ {
    Counter::add(counter, 1.0, Some(Attributes::with_attributes([("endpoint", StringValue("/api/data")), ("method", StringValue("GET"))])))
    
    let duration = 50.0 + (Random::next_float() * 200.0)  // 50-250mséšæœºå»¶è¿Ÿ
    Histogram::record(histogram, duration, Some(Attributes::with_attributes([("endpoint", StringValue("/api/data"))])))
  }
  
  // è®°å½•å½“å‰å†…å­˜ä½¿ç”¨æƒ…å†µ
  Gauge::set(gauge, 128.5, Some(Attributes::with_attributes([("instance", StringValue("server-01"))])))
  
  // è·å–èšåˆæ•°æ®
  let counter_data = Counter::get_aggregated_data(counter)
  let histogram_data = Histogram::get_aggregated_data(histogram)
  let gauge_data = Gauge::get_current_value(gauge)
  
  // éªŒè¯èšåˆæ•°æ®
  assert_eq(counter_data.value, 100.0)
  assert_eq(histogram_data.count, 100)
  assert_true(histogram_data.sum > 5000.0)  // è‡³å°‘5000msæ€»æ—¶é—´
  assert_true(histogram_data.min >= 50.0)
  assert_true(histogram_data.max <= 250.0)
  assert_eq(gauge_data.value, 128.5)
}

// æµ‹è¯•4: é”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•
test "é”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•" {
  let tracer_provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error-handling-test")
  
  // åˆ›å»ºä¸€ä¸ªä¼šç»å†é”™è¯¯çš„Span
  let span = Tracer::start_span(tracer, "error-prone-operation")
  
  // æ¨¡æ‹Ÿæ“ä½œä¸­çš„é”™è¯¯
  Span::add_event(span, "operation.started", Some([("input.data", StringValue("test-input"))]))
  
  // è®¾ç½®é”™è¯¯çŠ¶æ€
  Span::set_status(span, Error)
  Span::set_attribute(span, "error.type", StringValue("ValidationError"))
  Span::set_attribute(span, "error.message", StringValue("Invalid input parameter"))
  
  // è®°å½•é”™è¯¯äº‹ä»¶
  Span::add_event(span, "error.occurred", Some([
    ("error.code", StringValue("ERR_001")),
    ("error.stack", StringValue("at processInput (line 42)"))
  ]))
  
  // æ¨¡æ‹Ÿæ¢å¤æ“ä½œ
  Span::add_event(span, "recovery.attempted", Some([("retry.count", IntValue(3))]))
  
  // æˆåŠŸæ¢å¤
  Span::set_status(span, Ok)
  Span::add_event(span, "recovery.successful", Some([("final.state", StringValue("success"))]))
  
  // éªŒè¯é”™è¯¯å¤„ç†æµç¨‹
  let events = Span::get_events(span)
  assert_eq(events.length(), 4)
  assert_eq(events[0].name, "operation.started")
  assert_eq(events[1].name, "error.occurred")
  assert_eq(events[2].name, "recovery.attempted")
  assert_eq(events[3].name, "recovery.successful")
  
  // éªŒè¯æœ€ç»ˆçŠ¶æ€
  assert_eq(Span::get_status(span), Ok)
  
  Span::end(span)
}

// æµ‹è¯•5: åŠ¨æ€é…ç½®æ›´æ–°æµ‹è¯•
test "åŠ¨æ€é…ç½®æ›´æ–°æµ‹è¯•" {
  let tracer_provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(tracer_provider, "config-test")
  
  // åˆ›å»ºé…ç½®ç®¡ç†å™¨
  let config_manager = ConfigManager::new()
  
  // è®¾ç½®åˆå§‹é…ç½®
  ConfigManager::set_sampling_rate(config_manager, 0.1)  // 10%é‡‡æ ·ç‡
  ConfigManager::set_max_spans(config_manager, 100)
  ConfigManager::set_batch_size(config_manager, 50)
  
  // éªŒè¯åˆå§‹é…ç½®
  assert_eq(ConfigManager::get_sampling_rate(config_manager), 0.1)
  assert_eq(ConfigManager::get_max_spans(config_manager), 100)
  assert_eq(ConfigManager::get_batch_size(config_manager), 50)
  
  // åˆ›å»ºSpanå¹¶åº”ç”¨é…ç½®
  let span1 = Tracer::start_span_with_config(tracer, "config-test-span-1", config_manager)
  Span::end(span1)
  
  // åŠ¨æ€æ›´æ–°é…ç½®
  ConfigManager::set_sampling_rate(config_manager, 0.5)  // æé«˜åˆ°50%é‡‡æ ·ç‡
  ConfigManager::set_max_spans(config_manager, 200)
  ConfigManager::set_batch_size(config_manager, 100)
  
  // éªŒè¯é…ç½®æ›´æ–°
  assert_eq(ConfigManager::get_sampling_rate(config_manager), 0.5)
  assert_eq(ConfigManager::get_max_spans(config_manager), 200)
  assert_eq(ConfigManager::get_batch_size(config_manager), 100)
  
  // åˆ›å»ºæ–°Spanå¹¶éªŒè¯æ–°é…ç½®ç”Ÿæ•ˆ
  let span2 = Tracer::start_span_with_config(tracer, "config-test-span-2", config_manager)
  Span::end(span2)
  
  // éªŒè¯é…ç½®å†å²è®°å½•
  let config_history = ConfigManager::get_history(config_manager)
  assert_true(config_history.length() >= 2)
}

// æµ‹è¯•6: æ—¶é—´åºåˆ—æ•°æ®å¤„ç†æµ‹è¯•
test "æ—¶é—´åºåˆ—æ•°æ®å¤„ç†æµ‹è¯•" {
  let meter_provider = MeterProvider::new()
  let meter = MeterProvider::get_meter(meter_provider, "timeseries-test")
  
  // åˆ›å»ºæ—¶é—´åºåˆ—æŒ‡æ ‡
  let timeseries_counter = Meter::create_timeseries_counter(meter, "cpu.usage", Some("percent"), Some("CPU usage over time"))
  
  // æ¨¡æ‹Ÿæ—¶é—´ç‚¹æ•°æ®è®°å½•
  let base_time = Clock::now_unix_nanos(Clock::new())
  for i = 0; i < 60; i++ {
    let timestamp = base_time + (i * 1000)  // æ¯ç§’ä¸€ä¸ªæ•°æ®ç‚¹
    let value = 20.0 + (Random::next_float() * 60.0)  // 20-80%éšæœºCPUä½¿ç”¨ç‡
    
    TimeSeriesCounter::record_at_time(timeseries_counter, value, timestamp, 
      Some(Attributes::with_attributes([("core", StringValue("core-" + i.to_string()))])))
  }
  
  // è·å–æ—¶é—´åºåˆ—æ•°æ®
  let timeseries_data = TimeSeriesCounter::get_timeseries_data(timeseries_counter)
  
  // éªŒè¯æ—¶é—´åºåˆ—æ•°æ®
  assert_eq(timeseries_data.points.length(), 60)
  assert_eq(timeseries_data.points[0].timestamp, base_time)
  assert_eq(timeseries_data.points[59].timestamp, base_time + 59000)
  
  // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
  let stats = TimeSeriesCounter::calculate_statistics(timeseries_data)
  assert_eq(stats.count, 60)
  assert_true(stats.min >= 20.0)
  assert_true(stats.max <= 80.0)
  assert_true(stats.average > 20.0 && stats.average < 80.0)
  
  // æµ‹è¯•æ—¶é—´èŒƒå›´æŸ¥è¯¢
  let start_time = base_time + 10000  // 10ç§’å
  let end_time = base_time + 30000    // 30ç§’å
  let filtered_data = TimeSeriesCounter::query_by_time_range(timeseries_data, start_time, end_time)
  
  assert_eq(filtered_data.points.length(), 20)  // 10-30ç§’ä¹‹é—´çš„æ•°æ®ç‚¹
}

// æµ‹è¯•7: é‡‡æ ·ç­–ç•¥æµ‹è¯•
test "é‡‡æ ·ç­–ç•¥æµ‹è¯•" {
  let tracer_provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(tracer_provider, "sampling-test")
  
  // åˆ›å»ºä¸åŒé‡‡æ ·ç­–ç•¥
  let always_on_sampler = Sampler::always_on()
  let always_off_sampler = Sampler::always_off()
  let probability_sampler = Sampler::probability(0.5)  // 50%æ¦‚ç‡é‡‡æ ·
  
  // æµ‹è¯•AlwaysOné‡‡æ ·å™¨
  let sampled_count = 0
  for i = 0; i < 100; i++ {
    let sampling_decision = Sampler::should_sample(always_on_sampler, "trace-" + i.to_string(), "test-span")
    if sampling_decision.decision == RecordAndSample {
      sampled_count += 1
    }
  }
  assert_eq(sampled_count, 100)  // æ‰€æœ‰Spanéƒ½åº”è¯¥è¢«é‡‡æ ·
  
  // æµ‹è¯•AlwaysOffé‡‡æ ·å™¨
  sampled_count = 0
  for i = 0; i < 100; i++ {
    let sampling_decision = Sampler::should_sample(always_off_sampler, "trace-" + i.to_string(), "test-span")
    if sampling_decision.decision == RecordAndSample {
      sampled_count += 1
    }
  }
  assert_eq(sampled_count, 0)  // æ²¡æœ‰Spanåº”è¯¥è¢«é‡‡æ ·
  
  // æµ‹è¯•æ¦‚ç‡é‡‡æ ·å™¨
  sampled_count = 0
  for i = 0; i < 1000; i++ {
    let sampling_decision = Sampler::should_sample(probability_sampler, "trace-" + i.to_string(), "test-span")
    if sampling_decision.decision == RecordAndSample {
      sampled_count += 1
    }
  }
  // åº”è¯¥å¤§çº¦50%è¢«é‡‡æ ·ï¼Œå…è®¸ä¸€å®šè¯¯å·®
  assert_true(sampled_count > 400 && sampled_count < 600)
  
  // æµ‹è¯•åŸºäºå±æ€§çš„é‡‡æ ·
  let attribute_based_sampler = Sampler::attribute_based([
    ("service.name", StringValue("critical-service")),
    ("sample.flag", BoolValue(true))
  ])
  
  let critical_sampling_decision = Sampler::should_sample_with_attributes(
    attribute_based_sampler, "trace-001", "critical-span",
    [("service.name", StringValue("critical-service"))]
  )
  assert_eq(critical_sampling_decision.decision, RecordAndSample)
  
  let normal_sampling_decision = Sampler::should_sample_with_attributes(
    attribute_based_sampler, "trace-002", "normal-span",
    [("service.name", StringValue("normal-service"))]
  )
  assert_eq(normal_sampling_decision.decision, Drop)
}

// æµ‹è¯•8: æ‰¹é‡æ“ä½œæ€§èƒ½æµ‹è¯•
test "æ‰¹é‡æ“ä½œæ€§èƒ½æµ‹è¯•" {
  let tracer_provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(tracer_provider, "batch-test")
  
  // åˆ›å»ºæ‰¹é‡å¤„ç†å™¨
  let batch_processor = BatchSpanProcessor::new(100, 5000)  // 100ä¸ªSpanæˆ–5ç§’è¶…æ—¶
  
  // æµ‹è¯•æ‰¹é‡åˆ›å»ºSpan
  let start_time = Clock::now_unix_nanos(Clock::new())
  let spans = []
  
  for i = 0; i < 500; i++ {
    let span = Tracer::start_span(tracer, "batch-span-" + i.to_string())
    Span::set_attribute(span, "batch.id", IntValue(i / 50))  // 50ä¸ªSpanä¸€æ‰¹
    Span::set_attribute(span, "index", IntValue(i))
    spans.push(span)
  }
  
  // æ‰¹é‡ç»“æŸSpan
  for batch_start = 0; batch_start < spans.length(); batch_start += 50 {
    let batch_end = @min(batch_start + 50, spans.length())
    let batch = spans.slice(batch_start, batch_end)
    
    for span in batch {
      Span::end_with_processor(span, batch_processor)
    }
  }
  
  let end_time = Clock::now_unix_nanos(Clock::new())
  let total_time = (end_time - start_time) / 1000000  // è½¬æ¢ä¸ºæ¯«ç§’
  
  // éªŒè¯æ‰¹é‡å¤„ç†æ€§èƒ½
  assert_true(total_time < 5000)  // åº”è¯¥åœ¨5ç§’å†…å®Œæˆ
  assert_eq(spans.length(), 500)
  
  // éªŒè¯æ‰¹æ¬¡å¤„ç†
  let processed_batches = BatchSpanProcessor::get_processed_batches(batch_processor)
  assert_eq(processed_batches.length(), 10)  // 500ä¸ªSpanï¼Œæ¯æ‰¹50ä¸ªï¼Œåº”è¯¥æœ‰10æ‰¹
  
  // éªŒè¯æ¯æ‰¹çš„å®Œæ•´æ€§
  for batch in processed_batches {
    assert_eq(batch.spans.length(), 50)
    assert_true(batch.processing_time > 0)
  }
}

// æµ‹è¯•9: èµ„æºé™åˆ¶å’Œæ¸…ç†æµ‹è¯•
test "èµ„æºé™åˆ¶å’Œæ¸…ç†æµ‹è¯•" {
  let tracer_provider = TracerProvider::with_limits(100, 1000)  // æœ€å¤š100ä¸ªæ´»è·ƒSpanï¼Œ1000ä¸ªæ€»Span
  let tracer = TracerProvider::get_tracer(tracer_provider, "resource-limit-test")
  
  // åˆ›å»ºèµ„æºç®¡ç†å™¨
  let resource_manager = ResourceManager::new()
  ResourceManager::set_memory_limit(resource_manager, 10 * 1024 * 1024)  // 10MBé™åˆ¶
  ResourceManager::set_span_limit(resource_manager, 100)
  
  // æµ‹è¯•Spanæ•°é‡é™åˆ¶
  let active_spans = []
  for i = 0; i < 150; i++ {
    let span = Tracer::start_span(tracer, "limit-test-span-" + i.to_string())
    
    // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°é™åˆ¶
    if ResourceManager::is_span_limit_reached(resource_manager) {
      break
    }
    
    active_spans.push(span)
  }
  
  // åº”è¯¥åªåˆ›å»º100ä¸ªSpanï¼ˆé™åˆ¶å€¼ï¼‰
  assert_eq(active_spans.length(), 100)
  
  // æµ‹è¯•å†…å­˜é™åˆ¶
  let large_attribute_value = "x".repeat(1024 * 1024)  // 1MBå­—ç¬¦ä¸²
  for i = 0; i < active_spans.length(); i++ {
    let span = active_spans[i]
    
    // å°è¯•æ·»åŠ å¤§å±æ€§ï¼Œç›´åˆ°è¾¾åˆ°å†…å­˜é™åˆ¶
    if ResourceManager::is_memory_limit_reached(resource_manager) {
      break
    }
    
    Span::set_attribute(span, "large.data." + i.to_string(), StringValue(large_attribute_value))
  }
  
  // éªŒè¯å†…å­˜é™åˆ¶è¢«è§¦å‘
  assert_true(ResourceManager::is_memory_limit_reached(resource_manager))
  
  // æµ‹è¯•èµ„æºæ¸…ç†
  let cleanup_count = ResourceManager::cleanup_old_spans(resource_manager, 1000)  // æ¸…ç†1ç§’å‰çš„Span
  assert_true(cleanup_count > 0)
  
  // éªŒè¯æ¸…ç†åçš„èµ„æºçŠ¶æ€
  assert_true(ResourceManager::get_active_span_count(resource_manager) < 100)
  assert_true(ResourceManager::get_memory_usage(resource_manager) < 10 * 1024 * 1024)
  
  // ç»“æŸå‰©ä½™çš„Span
  for span in active_spans {
    Span::end(span)
  }
}

// æµ‹è¯•10: æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•
test "æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  let tracer_provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(tracer_provider, "integrity-test")
  
  // åˆ›å»ºéªŒè¯å™¨
  let integrity_validator = IntegrityValidator::new()
  
  // åˆ›å»ºåŒ…å«å¤æ‚æ•°æ®çš„Span
  let span = Tracer::start_span(tracer, "integrity-test-span")
  
  // è®¾ç½®å„ç§ç±»å‹çš„å±æ€§
  Span::set_attribute(span, "string.value", StringValue("test-string-with-special-characters-ä¸­æ–‡-ğŸš€"))
  Span::set_attribute(span, "int.value", IntValue(42))
  Span::set_attribute(span, "float.value", FloatValue(3.14159265359))
  Span::set_attribute(span, "bool.value", BoolValue(true))
  Span::set_attribute(span, "null.value", NullValue())
  
  // æ·»åŠ åµŒå¥—å±æ€§
  let nested_attributes = [
    ("nested.string", StringValue("nested-value")),
    ("nested.int", IntValue(100)),
    ("nested.array", ArrayStringValue([
      StringValue("item1"),
      IntValue(2),
      BoolValue(false)
    ]))
  ]
  
  for (key, value) in nested_attributes {
    Span::set_attribute(span, key, value)
  }
  
  // æ·»åŠ äº‹ä»¶
  Span::add_event(span, "test-event-1", Some([("event.data", StringValue("event-data-1"))]))
  Span::add_event(span, "test-event-2", Some([("event.data", StringValue("event-data-2"))]))
  
  // è®¾ç½®é“¾æ¥
  let linked_context = Context::with_trace_id("linked-trace-id")
  Span::add_link(span, linked_context, Some([("link.type", StringValue("follows-from"))]))
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  let validation_result = IntegrityValidator::validate_span(integrity_validator, span)
  
  assert_true(validation_result.is_valid)
  assert_eq(validation_result.errors.length(), 0)
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½è¢«æ­£ç¡®ä¿å­˜
  match Span::get_attribute(span, "string.value") {
    Some(StringValue(value)) => assert_eq(value, "test-string-with-special-characters-ä¸­æ–‡-ğŸš€")
    _ => assert_true(false)
  }
  match Span::get_attribute(span, "int.value") {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  match Span::get_attribute(span, "float.value") {
    Some(FloatValue(value)) => assert_eq(value, 3.14159265359)
    _ => assert_true(false)
  }
  match Span::get_attribute(span, "bool.value") {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  match Span::get_attribute(span, "null.value") {
    Some(NullValue()) => assert_true(true)
    _ => assert_true(false)
  }
  
  // éªŒè¯åµŒå¥—å±æ€§
  match Span::get_attribute(span, "nested.string") {
    Some(StringValue(value)) => assert_eq(value, "nested-value")
    _ => assert_true(false)
  }
  match Span::get_attribute(span, "nested.int") {
    Some(IntValue(value)) => assert_eq(value, 100)
    _ => assert_true(false)
  }
  
  match Span::get_attribute(span, "nested.array") {
    Some(ArrayStringValue(arr)) => {
      assert_eq(arr.length(), 3)
      match arr[0] {
        StringValue(s) => assert_eq(s, "item1")
        _ => assert_true(false)
      }
      match arr[1] {
        IntValue(i) => assert_eq(i, 2)
        _ => assert_true(false)
      }
      match arr[2] {
        BoolValue(b) => assert_eq(b, false)
        _ => assert_true(false)
      }
    }
    _ => assert_true(false)
  }
  
  // éªŒè¯äº‹ä»¶
  let events = Span::get_events(span)
  assert_eq(events.length(), 2)
  assert_eq(events[0].name, "test-event-1")
  assert_eq(events[1].name, "test-event-2")
  
  // éªŒè¯é“¾æ¥
  let links = Span::get_links(span)
  assert_eq(links.length(), 1)
  assert_eq(links[0].trace_id, "linked-trace-id")
  
  // åºåˆ—åŒ–å’Œååºåˆ—åŒ–éªŒè¯
  let serialized = Span::serialize(span)
  let deserialized = Span::deserialize(serialized)
  
  let deserialized_validation = IntegrityValidator::validate_span(integrity_validator, deserialized)
  assert_true(deserialized_validation.is_valid)
  
  // æ¯”è¾ƒåŸå§‹å’Œååºåˆ—åŒ–çš„æ•°æ®
  match (Span::get_attribute(span, "string.value"), Span::get_attribute(deserialized, "string.value")) {
    (Some(StringValue(original)), Some(StringValue(deser))) => assert_eq(original, deser)
    _ => assert_true(false)
  }
  assert_eq(Span::get_events(span).length(), Span::get_events(deserialized).length())
  assert_eq(Span::get_links(span).length(), Span::get_links(deserialized).length())
  
  Span::end(span)
  Span::end(deserialized)
}