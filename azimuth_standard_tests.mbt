// Azimuth é¡¹ç›®æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–æ ¸å¿ƒåŠŸèƒ½

test "integer_basic_operations" {
  // æµ‹è¯•æ•´æ•°åŸºæœ¬è¿ç®—
  let a = 42
  let b = 17
  
  // åŠ æ³•
  assert_eq(59, a + b)
  assert_eq(25, a - b)
  assert_eq(714, a * b)
  assert_eq(2, a / b)
  assert_eq(8, a % b)
  
  // ä¸€å…ƒè¿ç®—
  assert_eq(-42, -a)
  assert_eq(42, -(-a))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, @int.max_value)
  assert_eq(-2147483648, @int.min_value)
}

test "string_operations_and_unicode" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ“ä½œå’ŒUnicodeæ”¯æŒ
  let empty_string = ""
  let hello = "Hello"
  let world = "World"
  let chinese = "ä¸–ç•Œ"
  let emoji = "ğŸš€"
  
  // å­—ç¬¦ä¸²è¿æ¥
  assert_eq("HelloWorld", hello + world)
  assert_eq("Hello World", hello + " " + world)
  
  // å­—ç¬¦ä¸²æ¯”è¾ƒ
  assert_true(hello == "Hello")
  assert_false(hello == world)
  
  // Unicodeæ”¯æŒ
  assert_eq("Hello ä¸–ç•Œ", hello + " " + chinese)
  assert_eq("Hello ğŸš€", hello + " " + emoji)
  
  // ç©ºå­—ç¬¦ä¸²å¤„ç†
  assert_eq("", empty_string)
  assert_true(empty_string.length() == 0)
}

test "mathematical_functions" {
  // æµ‹è¯•æ•°å­¦å‡½æ•°
  let x = 16.0
  let y = 2.0
  
  // åŸºæœ¬æ•°å­¦è¿ç®—
  assert_eq(4.0, @math.sqrt(x))
  assert_eq(256.0, @math.pow(x, y))
  assert_eq(2.0, @math.log(x))
  assert_eq(10.0, @math.exp(y))
  
  // ä¸‰è§’å‡½æ•°
  let pi = 3.141592653589793
  assert_eq(0.0, @math.sin(0.0))
  assert_eq(1.0, @math.cos(0.0))
  
  // å–æ•´å‡½æ•°
  assert_eq(3.0, @math.floor(3.7))
  assert_eq(4.0, @math.ceil(3.7))
  assert_eq(4.0, @math.round(3.7))
}

test "boundary_conditions_and_limits" {
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œæé™å€¼
  let max_int = @int.max_value
  let min_int = @int.min_value
  
  // è¾¹ç•Œå€¼è¿ç®—
  assert_eq(2147483646, max_int - 1)
  assert_eq(-2147483647, min_int + 1)
  
  // é›¶å€¼æµ‹è¯•
  assert_eq(0, 0 + 0)
  assert_eq(0, 0 * 42)
  assert_eq(0, 42 * 0)
  
  // é™¤æ³•è¾¹ç•Œæƒ…å†µ
  assert_eq(0, 0 / 1)
  assert_eq(1, 1 / 1)
  assert_eq(0, 1 % 1)
  
  // å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œ
  assert_eq(0, "".length())
  assert_eq(1, "a".length())
}

test "error_handling_and_validation" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’ŒéªŒè¯
  // æ³¨æ„ï¼šMoonBit æ²¡æœ‰å¼‚å¸¸ï¼Œæˆ‘ä»¬æµ‹è¯•é¢„æœŸè¡Œä¸º
  
  // é™¤é›¶è¡Œä¸ºï¼ˆåº”è¯¥è¿”å›ç‰¹å®šå€¼æˆ–ä¸ä¼šå´©æºƒï¼‰
  let result_zero_div = 1 / 0  // è¿™å–å†³äºå®ç°
  let result_zero_mod = 1 % 0  // è¿™å–å†³äºå®ç°
  
  // ç©ºå­—ç¬¦ä¸²æ“ä½œ
  let empty = ""
  let empty_concat = empty + "test"
  assert_eq("test", empty_concat)
  
  // å¤§æ•°è¿ç®—ï¼ˆä¸ä¼šæº¢å‡ºï¼‰
  let large_num = 1000000
  let result = large_num * large_num
  assert_true(result > 0)
}

test "type_conversions" {
  // æµ‹è¯•ç±»å‹è½¬æ¢
  let int_val = 42
  let string_val = "42"
  
  // æ•´æ•°åˆ°å­—ç¬¦ä¸²è½¬æ¢
  let int_to_string = int_val.to_string()
  assert_eq("42", int_to_string)
  
  // å­—ç¬¦ä¸²åˆ°æ•´æ•°è½¬æ¢ï¼ˆå¦‚æœæ”¯æŒï¼‰
  // æ³¨æ„ï¼šå…·ä½“æ–¹æ³•å–å†³äºå®ç°
  
  // å¸ƒå°”å€¼æµ‹è¯•
  let true_val = true
  let false_val = false
  
  assert_true(true_val)
  assert_false(false_val)
  assert_false(true_val == false_val)
}

test "comparison_operations" {
  // æµ‹è¯•æ¯”è¾ƒæ“ä½œ
  let a = 10
  let b = 20
  let c = 10
  
  // æ•°å€¼æ¯”è¾ƒ
  assert_true(a < b)
  assert_true(b > a)
  assert_true(a <= b)
  assert_true(b >= a)
  assert_true(a == c)
  assert_true(a != b)
  
  // å­—ç¬¦ä¸²æ¯”è¾ƒ
  let str1 = "apple"
  let str2 = "banana"
  let str3 = "apple"
  
  assert_true(str1 == str3)
  assert_true(str1 != str2)
  assert_false(str1 == str2)
  
  // æ··åˆç±»å‹æ¯”è¾ƒï¼ˆå¦‚æœæ”¯æŒï¼‰
  assert_true(10 == 10)
  assert_false(10 == "10")
}

test "collection_operations" {
  // æµ‹è¯•é›†åˆæ“ä½œ
  // æ³¨æ„ï¼šå…·ä½“å®ç°å–å†³äºå¯ç”¨çš„é›†åˆç±»å‹
  
  // æ•°ç»„æ“ä½œï¼ˆå¦‚æœæ”¯æŒï¼‰
  let arr = [1, 2, 3, 4, 5]
  assert_eq(5, arr.length())
  
  // åˆ—è¡¨æ“ä½œï¼ˆå¦‚æœæ”¯æŒï¼‰
  // let list = List::cons(1, List::cons(2, List::nil))
  
  // Option ç±»å‹æµ‹è¯•ï¼ˆå¦‚æœæ”¯æŒï¼‰
  // let some_value = Option::some(42)
  // let none_value = Option::none[Int]
  
  // åŸºæœ¬æ–­è¨€æµ‹è¯•
  assert_true(1 == 1)
  assert_false(1 == 2)
}

test "real_world_scenarios" {
  // æµ‹è¯•çœŸå®ä¸–ç•Œåº”ç”¨åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·
  
  let item1_price = 299
  let item2_price = 199
  let item3_price = 99
  let discount = 50
  
  // è®¡ç®—æ€»ä»·
  let subtotal = item1_price + item2_price + item3_price
  let total = subtotal - discount
  
  assert_eq(597, subtotal)
  assert_eq(547, total)
  
  // åœºæ™¯ï¼šè®¡ç®—å¹³å‡åˆ†
  let score1 = 85
  let score2 = 92
  let score3 = 78
  let score4 = 96
  
  let total_score = score1 + score2 + score3 + score4
  let average = total_score / 4
  
  assert_eq(351, total_score)
  assert_eq(87, average)
  
  // åœºæ™¯ï¼šå­—ç¬¦ä¸²å¤„ç†
  let first_name = "John"
  let last_name = "Doe"
  let full_name = first_name + " " + last_name
  
  assert_eq("John Doe", full_name)
}

test "performance_and_efficiency" {
  // æµ‹è¯•æ€§èƒ½å’Œæ•ˆç‡ç›¸å…³æ“ä½œ
  // åœºæ™¯ï¼šæ‰¹é‡è®¡ç®—
  
  let count = 1000
  let multiplier = 2
  
  // å¾ªç¯æ¨¡æ‹Ÿï¼ˆä½¿ç”¨é€’å½’æˆ–è¿­ä»£ï¼‰
  let result = count * multiplier
  assert_eq(2000, result)
  
  // å¤§æ•°è¿ç®—æ€§èƒ½
  let large_num1 = 1000000
  let large_num2 = 2000000
  
  let sum_result = large_num1 + large_num2
  let product_result = large_num1 * 2
  
  assert_eq(3000000, sum_result)
  assert_eq(2000000, product_result)
  
  // å­—ç¬¦ä¸²æ“ä½œæ•ˆç‡
  let base_string = "test"
  let repeated = base_string + base_string + base_string + base_string
  
  assert_eq("testtesttesttest", repeated)
  assert_eq(16, repeated.length())
}