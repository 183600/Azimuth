// Azimuth Telemetry - Internationalization Support Test
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿå›½é™…åŒ–æ”¯æŒåŠŸèƒ½

// æ¨¡æ‹Ÿè¯­è¨€åŒºåŸŸè®¾ç½®
pub struct Locale {
  language : String
  region : String
  timezone : String
  number_format : String
  date_format : String
}

pub fn Locale::default() -> Locale {
  Locale::{
    language: "en",
    region: "US",
    timezone: "UTC",
    number_format: "en-US",
    date_format: "YYYY-MM-DD"
  }
}

test "multilingual_attribute_support" {
  // æµ‹è¯•å¤šè¯­è¨€å±æ€§æ”¯æŒ
  let locales = [
    Locale::{ language: "en", region: "US", timezone: "UTC", number_format: "en-US", date_format: "YYYY-MM-DD" },
    Locale::{ language: "zh", region: "CN", timezone: "Asia/Shanghai", number_format: "zh-CN", date_format: "YYYYå¹´MMæœˆDDæ—¥" },
    Locale::{ language: "ja", region: "JP", timezone: "Asia/Tokyo", number_format: "ja-JP", date_format: "YYYYå¹´MMæœˆDDæ—¥" },
    Locale::{ language: "fr", region: "FR", timezone: "Europe/Paris", number_format: "fr-FR", date_format: "DD/MM/YYYY" },
    Locale::{ language: "de", region: "DE", timezone: "Europe/Berlin", number_format: "de-DE", date_format: "DD.MM.YYYY" }
  ]
  
  // æ¨¡æ‹Ÿå¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  let error_messages = [
    ("en", "Operation failed due to network timeout"),
    ("zh", "ç½‘ç»œè¶…æ—¶å¯¼è‡´æ“ä½œå¤±è´¥"),
    ("ja", "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã«ã‚ˆã‚Šæ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ"),
    ("fr", "L'opÃ©ration a Ã©chouÃ© en raison d'un dÃ©lai d'attente rÃ©seau"),
    ("de", "Operation aufgrund eines Netzwerk-Timeouts fehlgeschlagen")
  ]
  
  // éªŒè¯å¤šè¯­è¨€æ”¯æŒ
  for locale in locales {
    let message = error_messages.find(fn((lang, _)) { lang == locale.language })
    assert_some(message)
    
    match message.unwrap() {
      (lang, msg) => {
        assert_eq(lang, locale.language)
        assert_true(msg.length() > 0)
      }
    }
  }
  
  // æµ‹è¯•å¤šè¯­è¨€å±æ€§å€¼
  let multilingual_attributes = [
    ("error.message.en", "Operation failed"),
    ("error.message.zh", "æ“ä½œå¤±è´¥"),
    ("error.message.ja", "æ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ"),
    ("error.message.fr", "L'opÃ©ration a Ã©chouÃ©"),
    ("error.message.de", "Operation fehlgeschlagen")
  ]
  
  // éªŒè¯å¤šè¯­è¨€å±æ€§
  assert_eq(multilingual_attributes.length(), 5)
  
  for (key, value) in multilingual_attributes {
    assert_true(key.starts_with("error.message."))
    assert_true(value.length() > 0)
  }
}

test "timezone_handling" {
  // æµ‹è¯•æ—¶åŒºå¤„ç†
  let timezones = [
    ("UTC", 0L),
    ("Asia/Shanghai", 8L * 3600L * 1000L * 1000L),  // +8å°æ—¶
    ("America/New_York", -5L * 3600L * 1000L * 1000L), // -5å°æ—¶
    ("Europe/London", 0L),  // UTCï¼ˆä¸è€ƒè™‘å¤ä»¤æ—¶ï¼‰
    ("Asia/Tokyo", 9L * 3600L * 1000L * 1000L),  // +9å°æ—¶
    ("Australia/Sydney", 10L * 3600L * 1000L * 1000L) // +10å°æ—¶
  ]
  
  // åŸºç¡€æ—¶é—´æˆ³ï¼ˆUTCæ—¶é—´2022-01-01 12:00:00ï¼‰
  let base_timestamp = 1641033600000000000L
  
  // éªŒè¯æ—¶åŒºè½¬æ¢
  for (timezone, offset) in timezones {
    let local_timestamp = base_timestamp + offset
    let adjusted_timestamp = local_timestamp - offset // è½¬å›UTC
    
    assert_eq(adjusted_timestamp, base_timestamp)
  }
  
  // æµ‹è¯•æ—¶åŒºæ„ŸçŸ¥çš„Span
  let timezone_aware_spans = [
    {
      "name": "operation_utc",
      "timezone": "UTC",
      "local.time": "2022-01-01T12:00:00Z"
    },
    {
      "name": "operation_shanghai",
      "timezone": "Asia/Shanghai",
      "local.time": "2022-01-01T20:00:00+08:00"
    }
  ]
  
  // éªŒè¯æ—¶åŒºæ„ŸçŸ¥çš„Span
  assert_eq(timezone_aware_spans.length(), 2)
  
  let utc_span = timezone_aware_spans[0]
  let shanghai_span = timezone_aware_spans[1]
  
  assert_eq(utc_span["timezone"], "UTC")
  assert_eq(shanghai_span["timezone"], "Asia/Shanghai")
}

test "number_format_localization" {
  // æµ‹è¯•æ•°å­—æ ¼å¼æœ¬åœ°åŒ–
  let number_formats = [
    ("en-US", "1,234.56", "1234.56"),
    ("zh-CN", "1,234.56", "1234.56"),
    ("ja-JP", "1,234.56", "1234.56"),
    ("fr-FR", "1 234,56", "1234.56"),
    ("de-DE", "1.234,56", "1234.56"),
    ("ru-RU", "1 234,56", "1234.56")
  ]
  
  // éªŒè¯æ•°å­—æ ¼å¼
  for (locale, formatted, raw) in number_formats {
    let parsed_value = raw.to_double()
    assert_eq(parsed_value, 1234.56)
    
    // æ¨¡æ‹Ÿæ ¼å¼åŒ–éªŒè¯
    let format_valid = formatted.contains("1") && formatted.contains("2") && formatted.contains("3") && 
                       formatted.contains("4") && (formatted.contains(".") || formatted.contains(","))
    assert_true(format_valid)
  }
  
  // æµ‹è¯•æœ¬åœ°åŒ–çš„åº¦é‡å€¼
  let localized_metrics = [
    ("en-US", 1234.56),
    ("zh-CN", 1234.56),
    ("ja-JP", 1234.56),
    ("fr-FR", 1234.56),
    ("de-DE", 1234.56)
  ]
  
  // éªŒè¯æœ¬åœ°åŒ–åº¦é‡å€¼
  for (locale, value) in localized_metrics {
    assert_eq(value, 1234.56)
  }
  
  // æµ‹è¯•ä¸åŒæ•°å­—ç±»å‹çš„æœ¬åœ°åŒ–
  let integer_formats = [
    ("en-US", "1,234", "1234"),
    ("zh-CN", "1,234", "1234"),
    ("ja-JP", "1,234", "1234"),
    ("fr-FR", "1 234", "1234"),
    ("de-DE", "1.234", "1234")
  ]
  
  for (locale, formatted, raw) in integer_formats {
    let parsed_value = raw.to_int()
    assert_eq(parsed_value, 1234)
    assert_true(formatted.contains("1") && formatted.contains("2") && formatted.contains("3") && formatted.contains("4"))
  }
}

test "character_encoding_support" {
  // æµ‹è¯•å­—ç¬¦ç¼–ç æ”¯æŒ
  let multilingual_texts = [
    ("en", "Hello World"),
    ("zh", "ä½ å¥½ä¸–ç•Œ"),
    ("ja", "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ"),
    ("ko", "ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„"),
    ("ar", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"),
    ("ru", "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€"),
    ("hi", "à¤¨à¤®à¤¸à¥à¤¤à¥‡ à¤¦à¥à¤¨à¤¿à¤¯à¤¾"),
    ("th", "à¸ªà¸§à¸±à¸ªà¸”à¸µà¸Šà¸²à¸§à¹‚à¸¥à¸"),
    ("he", "×©×œ×•× ×¢×•×œ×"),
    ("es", "Hola Mundo")
  ]
  
  // éªŒè¯å¤šè¯­è¨€æ–‡æœ¬å±æ€§
  let multilingual_attributes = multilingual_texts.map(fn((language, text)) {
    ("greeting." + language, text)
  })
  
  assert_eq(multilingual_attributes.length(), 10)
  
  for (key, value) in multilingual_attributes {
    assert_true(key.starts_with("greeting."))
    assert_true(value.length() > 0)
    
    // éªŒè¯è¯­è¨€æ ‡è¯†ç¬¦
    let language_code = key.split(".")[1]
    let original_text = multilingual_texts.find(fn((lang, _) ) { lang == language_code })
    assert_some(original_text)
    
    match original_text.unwrap() {
      (_, original) => assert_eq(value, original)
    }
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’Œè¡¨æƒ…ç¬¦å·
  let special_characters = [
    ("emoji", "ğŸš€ Telemetry System ğŸ“Š"),
    ("math", "E=mcÂ² and âˆ‘(i=1â†’n)"),
    ("currency", "$100.50, â‚¬75.25, Â¥1,000.00"),
    ("symbols", "Â©2022 Azimuthâ„¢ â€¢ âˆ âˆ† âˆ‡"),
    ("mixed", "Hello ğŸŒ ä½ å¥½ ã“ã‚“ã«ã¡ã¯ Bonjour")
  ]
  
  let special_char_attributes = special_characters.map(fn((type, text)) {
    ("special." + type, text)
  })
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å±æ€§
  for (key, value) in special_char_attributes {
    assert_true(key.starts_with("special."))
    assert_true(value.length() > 0)
  }
}

test "comprehensive_internationalization" {
  // æµ‹è¯•ç»¼åˆå›½é™…åŒ–åŠŸèƒ½
  let global_locales = [
    Locale::{ language: "en", region: "US", timezone: "UTC", number_format: "en-US", date_format: "YYYY-MM-DD" },
    Locale::{ language: "zh", region: "CN", timezone: "Asia/Shanghai", number_format: "zh-CN", date_format: "YYYYå¹´MMæœˆDDæ—¥" },
    Locale::{ language: "ja", region: "JP", timezone: "Asia/Tokyo", number_format: "ja-JP", date_format: "YYYYå¹´MMæœˆDDæ—¥" },
    Locale::{ language: "ar", region: "SA", timezone: "Asia/Riyadh", number_format: "ar-SA", date_format: "DD/MM/YYYY" }
  ]
  
  // åˆ›å»ºå›½é™…åŒ–é¥æµ‹æ•°æ®
  let internationalized_spans = global_locales.map(fn(locale) {
    {
      "name": "international_operation_" + locale.language,
      "locale.language": locale.language,
      "locale.region": locale.region,
      "locale.timezone": locale.timezone,
      "locale.number_format": locale.number_format,
      "locale.date_format": locale.date_format,
      "message.localized": (
        match locale.language {
          "en" => "Operation completed successfully"
          "zh" => "æ“ä½œæˆåŠŸå®Œæˆ"
          "ja" => "æ“ä½œãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ"
          "ar" => "Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­"
          _ => "Operation completed"
        }
      ),
      "metric.value": "1234.56",
      "text.direction": (
        if locale.language == "ar" { "rtl" } else { "ltr" }
      )
    }
  })
  
  // éªŒè¯å›½é™…åŒ–Span
  assert_eq(internationalized_spans.length(), 4)
  
  for span in internationalized_spans {
    // éªŒè¯æ¯ä¸ªSpanéƒ½æœ‰å®Œæ•´çš„æœ¬åœ°åŒ–å±æ€§
    assert_eq(span["locale.language"].length(), 2) // è¯­è¨€ä»£ç é€šå¸¸æ˜¯2ä¸ªå­—ç¬¦
    assert_true(span["message.localized"].length() > 0)
    assert_true(span["metric.value"] == "1234.56")
    assert_true(span["text.direction"] == "ltr" || span["text.direction"] == "rtl")
  }
  
  // éªŒè¯å›½é™…åŒ–è¦†ç›–ç‡
  let supported_languages = internationalized_spans.map(fn(span) { span["locale.language"] })
  let expected_languages = ["en", "zh", "ja", "ar"]
  for expected_lang in expected_languages {
    let lang_supported = supported_languages.any(fn(lang) { lang == expected_lang })
    assert_true(lang_supported)
  }
  
  // éªŒè¯æ–‡æœ¬æ–¹å‘æ­£ç¡®æ€§
  let rtl_spans = internationalized_spans.filter(fn(span) { span["text.direction"] == "rtl" })
  let ltr_spans = internationalized_spans.filter(fn(span) { span["text.direction"] == "ltr" })
  
  assert_eq(rtl_spans.length(), 1) // åªæœ‰é˜¿æ‹‰ä¼¯è¯­æ˜¯RTL
  assert_eq(ltr_spans.length(), 3) // è‹±æ–‡ã€ä¸­æ–‡ã€æ—¥æ–‡æ˜¯LTR
}