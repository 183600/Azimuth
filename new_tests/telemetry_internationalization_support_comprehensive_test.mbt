// é¥æµ‹å›½é™…åŒ–æ”¯æŒç»¼åˆæµ‹è¯•ç”¨ä¾‹

test "telemetry_unicode_character_support" {
  // æµ‹è¯•é¥æµ‹Unicodeå­—ç¬¦æ”¯æŒ
  
  // Unicodeå­—ç¬¦æµ‹è¯•æ•°æ®
  type UnicodeTestData = {
    language: String,
    locale: String,
    text_content: String,
    character_set: String,
    expected_encoding: String
  }
  
  // Unicodeå¤„ç†ç»“æœ
  type UnicodeProcessingResult = {
    language: String,
    encoding_successful: Bool,
    character_loss: Bool,
    display_correct: Bool,
    byte_length: Int,
    processing_time_ms: Int
  }
  
  // Unicodeæµ‹è¯•æ•°æ®é›†
  let unicode_test_data = [
    UnicodeTestData {
      language: "English",
      locale: "en-US",
      text_content: "Telemetry monitoring system active",
      character_set: "ASCII",
      expected_encoding: "UTF-8"
    },
    UnicodeTestData {
      language: "Chinese",
      locale: "zh-CN",
      text_content: "é¥æµ‹ç›‘æ§ç³»ç»Ÿè¿è¡Œæ­£å¸¸",
      character_set: "CJK",
      expected_encoding: "UTF-8"
    },
    UnicodeTestData {
      language: "Japanese",
      locale: "ja-JP",
      text_content: "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªç›£è¦–ã‚·ã‚¹ãƒ†ãƒ ãŒç¨¼åƒä¸­",
      character_set: "CJK",
      expected_encoding: "UTF-8"
    },
    UnicodeTestData {
      language: "Arabic",
      locale: "ar-SA",
      text_content: "Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯ Ù†Ø´Ø·",
      character_set: "Arabic",
      expected_encoding: "UTF-8"
    },
    UnicodeTestData {
      language: "Russian",
      locale: "ru-RU",
      text_content: "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°",
      character_set: "Cyrillic",
      expected_encoding: "UTF-8"
    },
    UnicodeTestData {
      language: "Emoji",
      locale: "en-US",
      text_content: "ğŸš€ Telemetry System ğŸŒ Monitoring ğŸ“Š Active âœ…",
      character_set: "Emoji",
      expected_encoding: "UTF-8"
    },
    UnicodeTestData {
      language: "Mixed",
      locale: "en-US",
      text_content: "System ç³»ç»Ÿ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ù†Ø¸Ø§Ù… ğŸŒ Monitoring ç›£è¦– ç›£è§†",
      character_set: "Mixed",
      expected_encoding: "UTF-8"
    }
  ]
  
  // éªŒè¯Unicodeæµ‹è¯•æ•°æ®
  assert_eq(unicode_test_data.length(), 7)
  assert_eq(unicode_test_data[0].language, "English")
  assert_eq(unicode_test_data[1].text_content.contains("é¥æµ‹"), true)
  assert_eq(unicode_test_data[5].text_content.contains("ğŸš€"), true)
  
  // Unicodeå¤„ç†å‡½æ•°
  let process_unicode_text = fn(test_data: UnicodeTestData) -> UnicodeProcessingResult {
    let processing_start = 1000  // æ¨¡æ‹Ÿå¤„ç†å¼€å§‹æ—¶é—´
    
    // æ¨¡æ‹Ÿç¼–ç å¤„ç†
    let encoding_successful = test_data.expected_encoding == "UTF-8"
    
    // æ¨¡æ‹Ÿå­—ç¬¦æŸå¤±æ£€æµ‹
    let character_loss = false  // UTF-8åº”è¯¥æ”¯æŒæ‰€æœ‰Unicodeå­—ç¬¦
    
    // æ¨¡æ‹Ÿæ˜¾ç¤ºæ­£ç¡®æ€§
    let display_correct = encoding_successful and not character_loss
    
    // è®¡ç®—å­—èŠ‚é•¿åº¦ï¼ˆUTF-8ä¸­ä¸åŒå­—ç¬¦çš„å­—èŠ‚é•¿åº¦ä¸åŒï¼‰
    let mut byte_length = 0
    let mut i = 0
    while i < test_data.text_content.length() {
      let char = test_data.text_content[i]
      
      // ç®€åŒ–çš„å­—èŠ‚é•¿åº¦è®¡ç®—
      if test_data.character_set == "ASCII" {
        byte_length = byte_length + 1
      } else if test_data.character_set == "CJK" {
        byte_length = byte_length + 3
      } else if test_data.character_set == "Arabic" or test_data.character_set == "Cyrillic" {
        byte_length = byte_length + 2
      } else if test_data.character_set == "Emoji" {
        byte_length = byte_length + 4
      } else {  // Mixed
        if char.to_int() < 128 {
          byte_length = byte_length + 1
        } else if char.to_int() < 2048 {
          byte_length = byte_length + 2
        } else if char.to_int() < 65536 {
          byte_length = byte_length + 3
        } else {
          byte_length = byte_length + 4
        }
      }
      
      i = i + 1
    }
    
    // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    let processing_time = if test_data.character_set == "ASCII" { 5 }
                         else if test_data.character_set == "Mixed" { 15 }
                         else { 10 }
    
    UnicodeProcessingResult {
      language: test_data.language,
      encoding_successful: encoding_successful,
      character_loss: character_loss,
      display_correct: display_correct,
      byte_length: byte_length,
      processing_time_ms: processing_time
    }
  }
  
  // æ‰§è¡ŒUnicodeå­—ç¬¦æ”¯æŒæµ‹è¯•
  let mut unicode_results = []
  let mut i = 0
  
  while i < unicode_test_data.length() {
    let result = process_unicode_text(unicode_test_data[i])
    unicode_results.push(result)
    i = i + 1
  }
  
  // éªŒè¯Unicodeå¤„ç†ç»“æœ
  assert_eq(unicode_results.length(), 7)
  
  i = 0
  while i < unicode_results.length() {
    let result = unicode_results[i]
    let test_data = unicode_test_data[i]
    
    assert_eq(result.language, test_data.language)
    assert_eq(result.encoding_successful, true)
    assert_eq(result.character_loss, false)
    assert_eq(result.display_correct, true)
    assert_eq(result.byte_length > 0, true)
    assert_eq(result.processing_time_ms > 0, true)
    
    // éªŒè¯å­—èŠ‚é•¿åº¦åˆç†æ€§
    if test_data.character_set == "ASCII" {
      assert_eq(result.byte_length, test_data.text_content.length())
    } else if test_data.character_set == "CJK" {
      assert_eq(result.byte_length > test_data.text_content.length(), true)
    }
    
    i = i + 1
  }
  
  // éªŒè¯ç‰¹å®šè¯­è¨€çš„å­—ç¬¦å¤„ç†
  let chinese_result = unicode_results[1]  // Chinese
  let emoji_result = unicode_results[5]   // Emoji
  let mixed_result = unicode_results[6]   // Mixed
  
  assert_eq(chinese_result.byte_length > chinese_result.language.length() * 3, true)
  assert_eq(emoji_result.display_correct, true)
  assert_eq(mixed_result.processing_time_ms > chinese_result.processing_time_ms, true)
}

test "telemetry_timezone_handling" {
  // æµ‹è¯•é¥æµ‹æ—¶åŒºå¤„ç†
  
  // æ—¶åŒºä¿¡æ¯
  type TimezoneInfo = {
    timezone_name: String,
    utc_offset_hours: Int,
    dst_observed: Bool,
    locale: String,
    date_format: String
  }
  
  // æ—¶é—´æˆ³æ•°æ®
  type TimestampData = {
    timestamp_utc: Int,
    local_time: String,
    timezone: String,
    formatted_date: String,
    is_dst: Bool
  }
  
  // æ—¶åŒºå¤„ç†ç»“æœ
  type TimezoneHandlingResult = {
    timezone: String,
    conversion_successful: Bool,
    dst_handled_correctly: Bool,
    format_correct: Bool,
    offset_applied: Bool,
    processing_time_ms: Int
  }
  
  // æ—¶åŒºå®šä¹‰
  let timezones = [
    TimezoneInfo {
      timezone_name: "UTC",
      utc_offset_hours: 0,
      dst_observed: false,
      locale: "en-US",
      date_format: "YYYY-MM-DD HH:mm:ss"
    },
    TimezoneInfo {
      timezone_name: "America/New_York",
      utc_offset_hours: -5,
      dst_observed: true,
      locale: "en-US",
      date_format: "MM/DD/YYYY HH:mm:ss"
    },
    TimezoneInfo {
      timezone_name: "Europe/London",
      utc_offset_hours: 0,
      dst_observed: true,
      locale: "en-GB",
      date_format: "DD/MM/YYYY HH:mm:ss"
    },
    TimezoneInfo {
      timezone_name: "Asia/Tokyo",
      utc_offset_hours: 9,
      dst_observed: false,
      locale: "ja-JP",
      date_format: "YYYY/MM/DD HH:mm:ss"
    },
    TimezoneInfo {
      timezone_name: "Asia/Shanghai",
      utc_offset_hours: 8,
      dst_observed: false,
      locale: "zh-CN",
      date_format: "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss"
    },
    TimezoneInfo {
      timezone_name: "Australia/Sydney",
      utc_offset_hours: 10,
      dst_observed: true,
      locale: "en-AU",
      date_format: "DD/MM/YYYY HH:mm:ss"
    }
  ]
  
  // éªŒè¯æ—¶åŒºå®šä¹‰
  assert_eq(timezones.length(), 6)
  assert_eq(timezones[0].timezone_name, "UTC")
  assert_eq(timezones[1].dst_observed, true)
  assert_eq(timezones[4].locale, "zh-CN")
  
  // åŸºå‡†UTCæ—¶é—´æˆ³
  let base_timestamp_utc = 1640995200  // 2022-01-01 00:00:00 UTC
  
  // æ—¶åŒºå¤„ç†å‡½æ•°
  let handle_timezone_conversion = fn(timestamp_utc: Int, timezone: TimezoneInfo) -> TimezoneHandlingResult {
    // è®¡ç®—æ—¶åŒºåç§»
    let offset_hours = timezone.utc_offset_hours
    let offset_seconds = offset_hours * 3600
    let local_timestamp = timestamp_utc + offset_seconds
    
    // æ¨¡æ‹ŸDSTå¤„ç†
    let mut dst_offset = 0
    let mut dst_active = false
    
    if timezone.dst_observed {
      // ç®€åŒ–çš„DSTåˆ¤æ–­ï¼ˆå‡è®¾6æœˆåˆ°8æœˆæ˜¯DSTæ—¶é—´ï¼‰
      let month = 6  // å‡è®¾æ˜¯6æœˆ
      if month >= 6 and month <= 8 {
        dst_offset = 3600  // DSTå¢åŠ 1å°æ—¶
        dst_active = true
      }
    }
    
    let final_local_timestamp = local_timestamp + dst_offset
    
    // æ¨¡æ‹Ÿæ—¥æœŸæ ¼å¼åŒ–
    let formatted_date = if timezone.date_format == "YYYY-MM-DD HH:mm:ss" {
      "2022-01-01 00:00:00"
    } else if timezone.date_format == "MM/DD/YYYY HH:mm:ss" {
      "01/01/2022 00:00:00"
    } else if timezone.date_format == "DD/MM/YYYY HH:mm:ss" {
      "01/01/2022 00:00:00"
    } else if timezone.date_format == "YYYY/MM/DD HH:mm:ss" {
      "2022/01/01 00:00:00"
    } else if timezone.date_format == "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss" {
      "2022å¹´01æœˆ01æ—¥ 00:00:00"
    } else {
      "2022-01-01 00:00:00"
    }
    
    // éªŒè¯å¤„ç†ç»“æœ
    let conversion_successful = true
    let dst_handled_correctly = not timezone.dst_observed or (timezone.dst_observed and dst_active == (timezone.date_format != "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss"))
    let format_correct = formatted_date != ""
    let offset_applied = offset_hours != 0 or dst_offset != 0
    let processing_time = if timezone.dst_observed { 15 } else { 10 }
    
    TimezoneHandlingResult {
      timezone: timezone.timezone_name,
      conversion_successful: conversion_successful,
      dst_handled_correctly: dst_handled_correctly,
      format_correct: format_correct,
      offset_applied: offset_applied,
      processing_time_ms: processing_time
    }
  }
  
  // æ‰§è¡Œæ—¶åŒºå¤„ç†æµ‹è¯•
  let mut timezone_results = []
  let mut i = 0
  
  while i < timezones.length() {
    let result = handle_timezone_conversion(base_timestamp_utc, timezones[i])
    timezone_results.push(result)
    i = i + 1
  }
  
  // éªŒè¯æ—¶åŒºå¤„ç†ç»“æœ
  assert_eq(timezone_results.length(), 6)
  
  i = 0
  while i < timezone_results.length() {
    let result = timezone_results[i]
    let timezone = timezones[i]
    
    assert_eq(result.timezone, timezone.timezone_name)
    assert_eq(result.conversion_successful, true)
    assert_eq(result.format_correct, true)
    assert_eq(result.processing_time_ms > 0, true)
    
    // éªŒè¯åç§»åº”ç”¨
    if timezone.utc_offset_hours != 0 {
      assert_eq(result.offset_applied, true)
    }
    
    // éªŒè¯DSTå¤„ç†
    if timezone.dst_observed {
      assert_eq(result.dst_handled_correctly, true)
    }
    
    i = i + 1
  }
  
  // éªŒè¯ç‰¹å®šæ—¶åŒºçš„å¤„ç†
  let utc_result = timezone_results[0]      // UTC
  let new_york_result = timezone_results[1] // America/New_York
  let tokyo_result = timezone_results[3]    // Asia/Tokyo
  let shanghai_result = timezone_results[4] // Asia/Shanghai
  
  assert_eq(utc_result.offset_applied, false)  // UTCæ²¡æœ‰åç§»
  assert_eq(new_york_result.dst_handled_correctly, true)  // çº½çº¦æœ‰DST
  assert_eq(tokyo_result.offset_applied, true)  // ä¸œäº¬æœ‰åç§»
  assert_eq(shanghai_result.processing_time_ms, 10)  // ä¸Šæµ·æ²¡æœ‰DST
}

test "telemetry_locale_specific_formatting" {
  // æµ‹è¯•é¥æµ‹åœ°åŒºç‰¹å®šæ ¼å¼åŒ–
  
  // åœ°åŒºæ ¼å¼é…ç½®
  type LocaleFormat = {
    locale: String,
    number_format: String,
    date_format: String,
    time_format: String,
    currency_format: String,
    text_direction: String
  }
  
  // æ ¼å¼åŒ–æ•°æ®
  type FormatData = {
    number_value: Double,
    date_value: Int,
    time_value: Int,
    currency_value: Double,
    text_content: String
  }
  
  // æ ¼å¼åŒ–ç»“æœ
  type FormattingResult = {
    locale: String,
    number_formatted: String,
    date_formatted: String,
    time_formatted: String,
    currency_formatted: String,
    text_direction_applied: Bool,
    formatting_successful: Bool
  }
  
  // åœ°åŒºæ ¼å¼å®šä¹‰
  let locale_formats = [
    LocaleFormat {
      locale: "en-US",
      number_format: "#,##0.###",
      date_format: "MM/DD/YYYY",
      time_format: "HH:mm:ss",
      currency_format: "$#,##0.00",
      text_direction: "LTR"
    },
    LocaleFormat {
      locale: "zh-CN",
      number_format: "#,##0.###",
      date_format: "YYYYå¹´MMæœˆDDæ—¥",
      time_format: "HH:mm:ss",
      currency_format: "Â¥#,##0.00",
      text_direction: "LTR"
    },
    LocaleFormat {
      locale: "ja-JP",
      number_format: "#,##0.###",
      date_format: "YYYY/MM/DD",
      time_format: "HH:mm:ss",
      currency_format: "Â¥#,##0",
      text_direction: "LTR"
    },
    LocaleFormat {
      locale: "ar-SA",
      number_format: "#,##0.###",
      date_format: "DD/MM/YYYY",
      time_format: "HH:mm:ss",
      currency_format: "Ø±.Ø³ #,##0.00",
      text_direction: "RTL"
    },
    LocaleFormat {
      locale: "de-DE",
      number_format: "#.##0,###",
      date_format: "DD.MM.YYYY",
      time_format: "HH:mm:ss",
      currency_format: "#.##0,00 â‚¬",
      text_direction: "LTR"
    },
    LocaleFormat {
      locale: "fr-FR",
      number_format: "# ##0,###",
      date_format: "DD/MM/YYYY",
      time_format: "HH:mm:ss",
      currency_format: "# ##0,00 â‚¬",
      text_direction: "LTR"
    }
  ]
  
  // éªŒè¯åœ°åŒºæ ¼å¼
  assert_eq(locale_formats.length(), 6)
  assert_eq(locale_formats[0].locale, "en-US")
  assert_eq(locale_formats[3].text_direction, "RTL")
  assert_eq(locale_formats[4].number_format, "#.##0,###")
  
  // æµ‹è¯•æ•°æ®
  let test_format_data = FormatData {
    number_value: 1234567.89,
    date_value: 1640995200,  // 2022-01-01
    time_value: 43200,       // 12:00:00
    currency_value: 1234.56,
    text_content: "Telemetry monitoring system"
  }
  
  // éªŒè¯æµ‹è¯•æ•°æ®
  assert_eq(test_format_data.number_value, 1234567.89)
  assert_eq(test_format_data.currency_value, 1234.56)
  
  // åœ°åŒºæ ¼å¼åŒ–å‡½æ•°
  let format_for_locale = fn(data: FormatData, locale: LocaleFormat) -> FormattingResult {
    // æ•°å­—æ ¼å¼åŒ–
    let number_formatted = if locale.locale == "en-US" {
      "1,234,567.89"
    } else if locale.locale == "zh-CN" {
      "1,234,567.89"
    } else if locale.locale == "ja-JP" {
      "1,234,567.89"
    } else if locale.locale == "ar-SA" {
      "1,234,567.89"
    } else if locale.locale == "de-DE" {
      "1.234.567,89"
    } else if locale.locale == "fr-FR" {
      "1 234 567,89"
    } else {
      "1234567.89"
    }
    
    // æ—¥æœŸæ ¼å¼åŒ–
    let date_formatted = if locale.locale == "en-US" {
      "01/01/2022"
    } else if locale.locale == "zh-CN" {
      "2022å¹´01æœˆ01æ—¥"
    } else if locale.locale == "ja-JP" {
      "2022/01/01"
    } else if locale.locale == "ar-SA" {
      "01/01/2022"
    } else if locale.locale == "de-DE" {
      "01.01.2022"
    } else if locale.locale == "fr-FR" {
      "01/01/2022"
    } else {
      "2022-01-01"
    }
    
    // æ—¶é—´æ ¼å¼åŒ–
    let time_formatted = "12:00:00"  // ç®€åŒ–ï¼Œæ‰€æœ‰åœ°åŒºä½¿ç”¨ç›¸åŒæ ¼å¼
    
    // è´§å¸æ ¼å¼åŒ–
    let currency_formatted = if locale.locale == "en-US" {
      "$1,234.56"
    } else if locale.locale == "zh-CN" {
      "Â¥1,234.56"
    } else if locale.locale == "ja-JP" {
      "Â¥1,235"
    } else if locale.locale == "ar-SA" {
      "Ø±.Ø³ 1,234.56"
    } else if locale.locale == "de-DE" {
      "1.234,56 â‚¬"
    } else if locale.locale == "fr-FR" {
      "1 234,56 â‚¬"
    } else {
      "1234.56"
    }
    
    let text_direction_applied = locale.text_direction != ""
    let formatting_successful = number_formatted != "" and date_formatted != "" and 
                               time_formatted != "" and currency_formatted != ""
    
    FormattingResult {
      locale: locale.locale,
      number_formatted: number_formatted,
      date_formatted: date_formatted,
      time_formatted: time_formatted,
      currency_formatted: currency_formatted,
      text_direction_applied: text_direction_applied,
      formatting_successful: formatting_successful
    }
  }
  
  // æ‰§è¡Œåœ°åŒºæ ¼å¼åŒ–æµ‹è¯•
  let mut formatting_results = []
  let mut i = 0
  
  while i < locale_formats.length() {
    let result = format_for_locale(test_format_data, locale_formats[i])
    formatting_results.push(result)
    i = i + 1
  }
  
  // éªŒè¯æ ¼å¼åŒ–ç»“æœ
  assert_eq(formatting_results.length(), 6)
  
  i = 0
  while i < formatting_results.length() {
    let result = formatting_results[i]
    let locale = locale_formats[i]
    
    assert_eq(result.locale, locale.locale)
    assert_eq(result.formatting_successful, true)
    assert_eq(result.text_direction_applied, true)
    assert_eq(result.number_formatted != "", true)
    assert_eq(result.date_formatted != "", true)
    assert_eq(result.time_formatted != "", true)
    assert_eq(result.currency_formatted != "", true)
    
    i = i + 1
  }
  
  // éªŒè¯ç‰¹å®šåœ°åŒºçš„æ ¼å¼åŒ–
  let us_result = formatting_results[0]    // en-US
  let china_result = formatting_results[1] // zh-CN
  let arabic_result = formatting_results[3] // ar-SA
  let german_result = formatting_results[4] // de-DE
  
  assert_eq(us_result.number_formatted, "1,234,567.89")
  assert_eq(us_result.currency_formatted, "$1,234.56")
  assert_eq(china_result.date_formatted, "2022å¹´01æœˆ01æ—¥")
  assert_eq(arabic_result.currency_formatted.contains("Ø±.Ø³"), true)
  assert_eq(german_result.number_formatted, "1.234.567,89")
  assert_eq(german_result.currency_formatted.contains("â‚¬"), true)
}

test "telemetry_multilingual_error_messages" {
  // æµ‹è¯•é¥æµ‹å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  
  // é”™è¯¯æ¶ˆæ¯å®šä¹‰
  type ErrorMessage = {
    error_code: String,
    message_en: String,
    message_zh: String,
    message_ja: String,
    message_ar: String,
    message_de: String,
    message_fr: String
  }
  
  // æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯
  type LocalizedError = {
    error_code: String,
    language: String,
    localized_message: String,
    parameters: Array[String],
    formatting_successful: Bool
  }
  
  // é”™è¯¯æ¶ˆæ¯å®šä¹‰
  let error_messages = [
    ErrorMessage {
      error_code: "TELEMETRY_001",
      message_en: "Telemetry service connection failed: {0}",
      message_zh: "é¥æµ‹æœåŠ¡è¿æ¥å¤±è´¥: {0}",
      message_ja: "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚µãƒ¼ãƒ“ã‚¹æ¥ç¶šå¤±æ•—: {0}",
      message_ar: "ÙØ´Ù„ Ø§ØªØµØ§Ù„ Ø®Ø¯Ù…Ø© Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯: {0}",
      message_de: "Telemetrie-Dienstverbindung fehlgeschlagen: {0}",
      message_fr: "Ã‰chec de la connexion au service de tÃ©lÃ©mÃ©trie: {0}"
    },
    ErrorMessage {
      error_code: "TELEMETRY_002",
      message_en: "Data serialization error: {0}",
      message_zh: "æ•°æ®åºåˆ—åŒ–é”™è¯¯: {0}",
      message_ja: "ãƒ‡ãƒ¼ã‚¿ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã‚¨ãƒ©ãƒ¼: {0}",
      message_ar: "Ø®Ø·Ø£ ÙÙŠ ØªØ³Ù„Ø³Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {0}",
      message_de: "Datenserialisierungsfehler: {0}",
      message_fr: "Erreur de sÃ©rialisation des donnÃ©es: {0}"
    },
    ErrorMessage {
      error_code: "TELEMETRY_003",
      message_en: "Configuration validation failed: {0}",
      message_zh: "é…ç½®éªŒè¯å¤±è´¥: {0}",
      message_ja: "è¨­å®šæ¤œè¨¼å¤±æ•—: {0}",
      message_ar: "ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„ØªÙƒÙˆÙŠÙ†: {0}",
      message_de: "KonfigurationsÃ¼berprÃ¼fung fehlgeschlagen: {0}",
      message_fr: "Ã‰chec de la validation de la configuration: {0}"
    },
    ErrorMessage {
      error_code: "TELEMETRY_004",
      message_en: "Rate limit exceeded: {0} requests per second",
      message_zh: "è¶…è¿‡é€Ÿç‡é™åˆ¶: æ¯ç§’{0}ä¸ªè¯·æ±‚",
      message_ja: "ãƒ¬ãƒ¼ãƒˆåˆ¶é™è¶…é: æ¯ç§’{0}ãƒªã‚¯ã‚¨ã‚¹ãƒˆ",
      message_ar: "ØªØ¬Ø§ÙˆØ² Ø­Ø¯ Ø§Ù„Ù…Ø¹Ø¯Ù„: {0} Ø·Ù„Ø¨ ÙÙŠ Ø§Ù„Ø«Ø§Ù†ÙŠØ©",
      message_de: "Rate-Limit Ã¼berschritten: {0} Anfragen pro Sekunde",
      message_fr: "Limite de dÃ©bit dÃ©passÃ©e: {0} requÃªtes par seconde"
    }
  ]
  
  // éªŒè¯é”™è¯¯æ¶ˆæ¯å®šä¹‰
  assert_eq(error_messages.length(), 4)
  assert_eq(error_messages[0].error_code, "TELEMETRY_001")
  assert_eq(error_messages[1].message_zh.contains("æ•°æ®"), true)
  assert_eq(error_messages[3].message_ar.contains("Ù…Ø¹Ø¯Ù„"), true)
  
  // æ”¯æŒçš„è¯­è¨€
  let supported_languages = ["en", "zh", "ja", "ar", "de", "fr"]
  
  // éªŒè¯æ”¯æŒçš„è¯­è¨€
  assert_eq(supported_languages.length(), 6)
  
  // å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯æ ¼å¼åŒ–å‡½æ•°
  let format_error_message = fn(error_code: String, language: String, parameters: Array[String]) -> LocalizedError {
    let mut localized_message = ""
    let mut formatting_successful = false
    
    // æŸ¥æ‰¾é”™è¯¯æ¶ˆæ¯
    let mut i = 0
    while i < error_messages.length() {
      let error_msg = error_messages[i]
      
      if error_msg.error_code == error_code {
        // æ ¹æ®è¯­è¨€é€‰æ‹©æ¶ˆæ¯
        localized_message = if language == "en" {
          error_msg.message_en
        } else if language == "zh" {
          error_msg.message_zh
        } else if language == "ja" {
          error_msg.message_ja
        } else if language == "ar" {
          error_msg.message_ar
        } else if language == "de" {
          error_msg.message_de
        } else if language == "fr" {
          error_msg.message_fr
        } else {
          error_msg.message_en  // é»˜è®¤ä½¿ç”¨è‹±è¯­
        }
        
        // å‚æ•°æ›¿æ¢
        let mut j = 0
        while j < parameters.length() {
          let placeholder = "{" + j.to_string() + "}"
          if localized_message.contains(placeholder) {
            localized_message = localized_message.replace(placeholder, parameters[j])
          }
          j = j + 1
        }
        
        formatting_successful = true
        break
      }
      
      i = i + 1
    }
    
    LocalizedError {
      error_code: error_code,
      language: language,
      localized_message: localized_message,
      parameters: parameters,
      formatting_successful: formatting_successful
    }
  }
  
  // æ‰§è¡Œå¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯æµ‹è¯•
  let test_scenarios = [
    { error_code: "TELEMETRY_001", language: "en", params: ["Connection timeout"] },
    { error_code: "TELEMETRY_001", language: "zh", params: ["è¿æ¥è¶…æ—¶"] },
    { error_code: "TELEMETRY_002", language: "ja", params: ["JSON parse error"] },
    { error_code: "TELEMETRY_002", language: "ar", params: ["Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ JSON"] },
    { error_code: "TELEMETRY_003", language: "de", params: ["Invalid port number"] },
    { error_code: "TELEMETRY_004", language: "fr", params: ["1000"] }
  ]
  
  let mut localized_errors = []
  let mut i = 0
  
  while i < test_scenarios.length() {
    let scenario = test_scenarios[i]
    let error = format_error_message(scenario.error_code, scenario.language, scenario.params)
    localized_errors.push(error)
    i = i + 1
  }
  
  // éªŒè¯å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  assert_eq(localized_errors.length(), 6)
  
  i = 0
  while i < localized_errors.length() {
    let error = localized_errors[i]
    let scenario = test_scenarios[i]
    
    assert_eq(error.error_code, scenario.error_code)
    assert_eq(error.language, scenario.language)
    assert_eq(error.formatting_successful, true)
    assert_eq(error.localized_message != "", true)
    assert_eq(error.parameters.length(), scenario.params.length())
    
    i = i + 1
  }
  
  // éªŒè¯ç‰¹å®šè¯­è¨€çš„é”™è¯¯æ¶ˆæ¯
  let english_error = localized_errors[0]  // en
  let chinese_error = localized_errors[1]  // zh
  let arabic_error = localized_errors[3]   // ar
  let french_error = localized_errors[5]   // fr
  
  assert_eq(english_error.localized_message.contains("Connection timeout"), true)
  assert_eq(chinese_error.localized_message.contains("è¿æ¥è¶…æ—¶"), true)
  assert_eq(arabic_error.localized_message.contains("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ JSON"), true)
  assert_eq(french_error.localized_message.contains("1000"), true)
}