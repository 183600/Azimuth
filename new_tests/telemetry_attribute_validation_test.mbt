// å±æ€§éªŒè¯æµ‹è¯•
// æµ‹è¯•å„ç§å±æ€§ç±»å‹çš„éªŒè¯è§„åˆ™å’Œè¾¹ç•Œæ¡ä»¶

test "attribute_value_string_validation" {
  // æµ‹è¯•å­—ç¬¦ä¸²å±æ€§å€¼çš„éªŒè¯
  let valid_strings = [
    "simple_string",
    "string-with-dashes",
    "string_with_underscores",
    "string.with.dots",
    "string/with/slashes",
    "string\\with\\backslashes",
    "string with spaces",
    "string@with#special$characters%",
    "ä¸­æ–‡æµ‹è¯•å­—ç¬¦ä¸²",
    "Test with emoji ğŸš€",
    "",
    " ",  // ç©ºæ ¼
    "a",  // å•å­—ç¬¦
    "very_long_string_that_tests_length_validation_and_contains_many_characters_to_exceed_normal_limits"
  ]
  
  let mut i = 0
  while i < valid_strings.length() {
    let attr_value = common::AttributeValue::string(valid_strings[i])
    
    // éªŒè¯å­—ç¬¦ä¸²å±æ€§åˆ›å»ºæˆåŠŸ
    match attr_value {
      common::StringValue(s) => assert_eq(s, valid_strings[i])
      _ => @test.fail("String attribute creation failed")
    }
    
    i = i + 1
  }
  
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œ
  let max_length_string = "a".repeat(1000)  // å‡è®¾æœ€å¤§é•¿åº¦ä¸º1000
  let max_attr = common::AttributeValue::string(max_length_string)
  match max_attr {
    common::StringValue(s) => assert_eq(s.length(), 1000)
    _ => @test.fail("Max length string creation failed")
  }
}

test "attribute_value_numeric_validation" {
  // æµ‹è¯•æ•°å€¼å±æ€§å€¼çš„éªŒè¯
  let valid_ints = [
    0L,
    1L,
    -1L,
    9223372036854775807L,  // Max Int64
    -9223372036854775808L,  // Min Int64
    1234567890L,
    -1234567890L
  ]
  
  let valid_floats = [
    0.0,
    1.0,
    -1.0,
    3.14159265359,
    1.7976931348623157e308,  // Max Double
    -1.7976931348623157e308,  // Min Double
    1.0/0.0,  // Infinity
    -1.0/0.0,  // -Infinity
    0.0/0.0   // NaN
  ]
  
  // éªŒè¯æ•´æ•°å±æ€§
  let mut i = 0
  while i < valid_ints.length() {
    let attr_value = common::AttributeValue::int(valid_ints[i])
    match attr_value {
      common::IntValue(v) => assert_eq(v, valid_ints[i])
      _ => @test.fail("Int attribute creation failed")
    }
    i = i + 1
  }
  
  // éªŒè¯æµ®ç‚¹æ•°å±æ€§
  i = 0
  while i < valid_floats.length() {
    let attr_value = common::AttributeValue::float(valid_floats[i])
    match attr_value {
      common::FloatValue(v) => {
        if valid_floats[i].is_nan() {
          assert(v.is_nan())
        } else {
          assert_eq(v, valid_floats[i])
        }
      }
      _ => @test.fail("Float attribute creation failed")
    }
    i = i + 1
  }
}

test "attribute_value_boolean_validation" {
  // æµ‹è¯•å¸ƒå°”å±æ€§å€¼çš„éªŒè¯
  let true_attr = common::AttributeValue::bool(true)
  let false_attr = common::AttributeValue::bool(false)
  
  match true_attr {
    common::BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("True boolean attribute creation failed")
  }
  
  match false_attr {
    common::BoolValue(b) => assert_eq(b, false)
    _ => @test.fail("False boolean attribute creation failed")
  }
}

test "attribute_value_array_validation" {
  // æµ‹è¯•æ•°ç»„å±æ€§å€¼çš„éªŒè¯
  
  // å­—ç¬¦ä¸²æ•°ç»„
  let string_arrays = [
    [],  // ç©ºæ•°ç»„
    ["single_item"],
    ["item1", "item2", "item3"],
    ["ä¸­æ–‡", "æµ‹è¯•", "æ•°ç»„"],
    ["emoji", "ğŸš€", "test"],
    ["", " ", "   "],  // åŒ…å«ç©ºå­—ç¬¦ä¸²
    ["very_long_item_that_tests_array_item_length_validation"]
  ]
  
  let mut i = 0
  while i < string_arrays.length() {
    let attr_value = common::AttributeValue::array_string(string_arrays[i])
    match attr_value {
      common::ArrayStringValue(arr) => {
        assert_eq(arr.length(), string_arrays[i].length())
        let mut j = 0
        while j < arr.length() {
          assert_eq(arr[j], string_arrays[i][j])
          j = j + 1
        }
      }
      _ => @test.fail("String array attribute creation failed")
    }
    i = i + 1
  }
  
  // æ•´æ•°æ•°ç»„
  let int_arrays = [
    [],
    [1L],
    [1L, 2L, 3L, 4L, 5L],
    [0L, -1L, 9223372036854775807L, -9223372036854775808L]
  ]
  
  i = 0
  while i < int_arrays.length() {
    let attr_value = common::AttributeValue::array_int(int_arrays[i])
    match attr_value {
      common::ArrayIntValue(arr) => {
        assert_eq(arr.length(), int_arrays[i].length())
        let mut j = 0
        while j < arr.length() {
          assert_eq(arr[j], int_arrays[i][j])
          j = j + 1
        }
      }
      _ => @test.fail("Int array attribute creation failed")
    }
    i = i + 1
  }
  
  // æµ®ç‚¹æ•°æ•°ç»„
  let float_arrays = [
    [],
    [3.14],
    [0.0, 1.0, -1.0, 1.7976931348623157e308, -1.7976931348623157e308],
    [1.0/0.0, -1.0/0.0, 0.0/0.0]  // Infinity, -Infinity, NaN
  ]
  
  i = 0
  while i < float_arrays.length() {
    let attr_value = common::AttributeValue::array_float(float_arrays[i])
    match attr_value {
      common::ArrayFloatValue(arr) => {
        assert_eq(arr.length(), float_arrays[i].length())
        let mut j = 0
        while j < arr.length() {
          if float_arrays[i][j].is_nan() {
            assert(arr[j].is_nan())
          } else {
            assert_eq(arr[j], float_arrays[i][j])
          }
          j = j + 1
        }
      }
      _ => @test.fail("Float array attribute creation failed")
    }
    i = i + 1
  }
  
  // å¸ƒå°”æ•°ç»„
  let bool_arrays = [
    [],
    [true],
    [false],
    [true, false, true, false],
    [true, true, true],
    [false, false, false]
  ]
  
  i = 0
  while i < bool_arrays.length() {
    let attr_value = common::AttributeValue::array_bool(bool_arrays[i])
    match attr_value {
      common::ArrayBoolValue(arr) => {
        assert_eq(arr.length(), bool_arrays[i].length())
        let mut j = 0
        while j < arr.length() {
          assert_eq(arr[j], bool_arrays[i][j])
          j = j + 1
        }
      }
      _ => @test.fail("Bool array attribute creation failed")
    }
    i = i + 1
  }
}

test "attribute_key_validation" {
  // æµ‹è¯•å±æ€§é”®çš„éªŒè¯
  let valid_keys = [
    "simple_key",
    "key.with.dots",
    "key-with-dashes",
    "key_with_underscores",
    "key/with/slashes",
    "key123",
    "key_123",
    "a",  // å•å­—ç¬¦é”®
    "very.very.very.very.very.very.very.very.very.very.very.very.long.key.name.that.tests.validation.rules",
    "key.with.numbers.123",
    "key.with.special.chars!@#$%^&*()",
    "ä¸­æ–‡é”®å",
    "key.ğŸš€.emoji"
  ]
  
  // æµ‹è¯•æ— æ•ˆé”®ï¼ˆåœ¨å®é™…å®ç°ä¸­å¯èƒ½ä¼šè¢«æ‹’ç»ï¼‰
  let potentially_invalid_keys = [
    "",  // ç©ºé”®
    " ",  // ç©ºæ ¼é”®
    ".starts.with.dot",
    "ends.with.dot.",
    "has..double.dots",
    "has/invalid/special\\chars",
    "has\nnewline",
    "has\ttab",
    "has\rcarriage_return"
  ]
  
  // åˆ›å»ºå±æ€§å¯¹æ¥éªŒè¯é”®
  let mut i = 0
  while i < valid_keys.length() {
    let attributes : common::Attributes = [
      (valid_keys[i], common::AttributeValue::string("test_value"))
    ]
    
    // éªŒè¯å±æ€§åˆ›å»ºæˆåŠŸ
    assert_eq(attributes.length(), 1)
    assert_eq(attributes[0].0, valid_keys[i])
    
    i = i + 1
  }
  
  // æµ‹è¯•å¯èƒ½æ— æ•ˆçš„é”®ï¼ˆåœ¨å½“å‰å®ç°ä¸­å¯èƒ½ä»ç„¶è¢«æ¥å—ï¼‰
  i = 0
  while i < potentially_invalid_keys.length() {
    let attributes : common::Attributes = [
      (potentially_invalid_keys[i], common::AttributeValue::string("test_value"))
    ]
    
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™äº›é”®å¯èƒ½ä¼šè¢«éªŒè¯å’Œæ‹’ç»
    // ä½†åœ¨å½“å‰ç®€åŒ–å®ç°ä¸­ï¼Œæˆ‘ä»¬åªéªŒè¯å®ƒä»¬å¯ä»¥è¢«å­˜å‚¨
    assert_eq(attributes.length(), 1)
    assert_eq(attributes[0].0, potentially_invalid_keys[i])
    
    i = i + 1
  }
}

test "attribute_set_validation" {
  // æµ‹è¯•å±æ€§é›†çš„éªŒè¯
  let small_attribute_set = [
    ("key1", common::AttributeValue::string("value1")),
    ("key2", common::AttributeValue::int(123L)),
    ("key3", common::AttributeValue::float(3.14)),
    ("key4", common::AttributeValue::bool(true))
  ]
  
  let medium_attribute_set = [
    ("service.name", common::AttributeValue::string("payment-service")),
    ("service.version", common::AttributeValue::string("2.1.0")),
    ("service.namespace", common::AttributeValue::string("ecommerce")),
    ("deployment.environment", common::AttributeValue::string("production")),
    ("host.name", common::AttributeValue::string("payment-server-01")),
    ("host.ip", common::AttributeValue::string("10.0.1.100")),
    ("process.pid", common::AttributeValue::int(12345L)),
    ("process.executable.name", common::AttributeValue::string("payment-service")),
    ("process.cpu.percent", common::AttributeValue::float(75.5)),
    ("process.memory.rss", common::AttributeValue::float(512.0))
  ]
  
  // éªŒè¯å°å±æ€§é›†
  assert_eq(small_attribute_set.length(), 4)
  let mut i = 0
  while i < small_attribute_set.length() {
    let (key, value) = small_attribute_set[i]
    assert(key.has_prefix("key"))
    match value {
      common::StringValue(_) => assert(key == "key1")
      common::IntValue(_) => assert(key == "key2")
      common::FloatValue(_) => assert(key == "key3")
      common::BoolValue(_) => assert(key == "key4")
      _ => @test.fail("Unexpected attribute value type")
    }
    i = i + 1
  }
  
  // éªŒè¯ä¸­ç­‰å±æ€§é›†
  assert_eq(medium_attribute_set.length(), 10)
  i = 0
  while i < medium_attribute_set.length() {
    let (key, value) = medium_attribute_set[i]
    assert(key.contains("."))
    
    // éªŒè¯ç‰¹å®šé”®å€¼å¯¹
    match key {
      "service.name" => {
        match value {
          common::StringValue(name) => assert_eq(name, "payment-service")
          _ => @test.fail("service.name should be string")
        }
      }
      "process.pid" => {
        match value {
          common::IntValue(pid) => assert_eq(pid, 12345L)
          _ => @test.fail("process.pid should be int")
        }
      }
      "process.cpu.percent" => {
        match value {
          common::FloatValue(cpu) => assert_eq(cpu, 75.5)
          _ => @test.fail("process.cpu.percent should be float")
        }
      }
      _ => ()  // å…¶ä»–é”®ä¸éœ€è¦ç‰¹æ®ŠéªŒè¯
    }
    
    i = i + 1
  }
}

test "attribute_edge_cases_and_boundaries" {
  // æµ‹è¯•å±æ€§çš„è¾¹ç•Œæƒ…å†µå’Œè¾¹ç¼˜æ¡ä»¶
  
  // ç©ºå±æ€§é›†
  let empty_attributes : common::Attributes = []
  assert_eq(empty_attributes.length(), 0)
  
  // å•ä¸ªå±æ€§
  let single_attribute = [
    ("single.key", common::AttributeValue::string("single_value"))
  ]
  assert_eq(single_attribute.length(), 1)
  
  // é‡å¤é”®ï¼ˆåœ¨å®é™…å®ç°ä¸­å¯èƒ½ä¼šè¢«è¦†ç›–æˆ–æ‹’ç»ï¼‰
  let duplicate_keys = [
    ("duplicate.key", common::AttributeValue::string("value1")),
    ("duplicate.key", common::AttributeValue::string("value2")),
    ("duplicate.key", common::AttributeValue::string("value3"))
  ]
  assert_eq(duplicate_keys.length(), 3)
  
  // éªŒè¯é‡å¤é”®çš„å€¼
  assert_eq(duplicate_keys[0].1, common::StringValue("value1"))
  assert_eq(duplicate_keys[1].1, common::StringValue("value2"))
  assert_eq(duplicate_keys[2].1, common::StringValue("value3"))
  
  // æå¤§çš„å±æ€§é›†
  let mut large_attributes = []
  let mut i = 0
  while i < 1000 {
    large_attributes.push(("key." + i.to_string(), common::AttributeValue::string("value." + i.to_string())))
    i = i + 1
  }
  assert_eq(large_attributes.length(), 1000)
  
  // éªŒè¯å¤§å±æ€§é›†ä¸­çš„ç‰¹å®šå…ƒç´ 
  assert_eq(large_attributes[0].0, "key.0")
  assert_eq(large_attributes[999].0, "key.999")
  assert_eq(large_attributes[500].0, "key.500")
  
  match large_attributes[0].1 {
    common::StringValue(value) => assert_eq(value, "value.0")
    _ => @test.fail("Test failed")
  }
  
  match large_attributes[999].1 {
    common::StringValue(value) => assert_eq(value, "value.999")
    _ => @test.fail("Test failed")
  }
}

test "attribute_type_conversion_validation" {
  // æµ‹è¯•å±æ€§ç±»å‹è½¬æ¢çš„éªŒè¯
  
  // å­—ç¬¦ä¸²åˆ°å…¶ä»–ç±»å‹çš„è½¬æ¢éªŒè¯
  let string_value = common::AttributeValue::string("123")
  let int_value = common::AttributeValue::int(123L)
  let float_value = common::AttributeValue::float(123.0)
  let bool_value = common::AttributeValue::bool(true)
  
  // éªŒè¯ç±»å‹ä¸åŒ¹é…
  match string_value {
    common::StringValue(s) => assert_eq(s, "123")
    _ => @test.fail("Type mismatch for string value")
  }
  
  match int_value {
    common::IntValue(i) => assert_eq(i, 123L)
    _ => @test.fail("Type mismatch for int value")
  }
  
  match float_value {
    common::FloatValue(f) => assert_eq(f, 123.0)
    _ => @test.fail("Type mismatch for float value")
  }
  
  match bool_value {
    common::BoolValue(b) => assert_eq(b, true)
    _ => @test.fail("Type mismatch for bool value")
  }
  
  // æ•°ç»„ç±»å‹éªŒè¯
  let string_array = common::AttributeValue::array_string(["1", "2", "3"])
  let int_array = common::AttributeValue::array_int([1L, 2L, 3L])
  let float_array = common::AttributeValue::array_float([1.0, 2.0, 3.0])
  let bool_array = common::AttributeValue::array_bool([true, false, true])
  
  match string_array {
    common::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], "1")
      assert_eq(arr[1], "2")
      assert_eq(arr[2], "3")
    }
    _ => @test.fail("Type mismatch for string array")
  }
  
  match int_array {
    common::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], 1L)
      assert_eq(arr[1], 2L)
      assert_eq(arr[2], 3L)
    }
    _ => @test.fail("Type mismatch for int array")
  }
  
  match float_array {
    common::ArrayFloatValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], 1.0)
      assert_eq(arr[1], 2.0)
      assert_eq(arr[2], 3.0)
    }
    _ => @test.fail("Type mismatch for float array")
  }
  
  match bool_array {
    common::ArrayBoolValue(arr) => {
      assert_eq(arr.length(), 3)
      assert_eq(arr[0], true)
      assert_eq(arr[1], false)
      assert_eq(arr[2], true)
    }
    _ => @test.fail("Type mismatch for bool array")
  }
}