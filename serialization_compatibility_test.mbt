// åºåˆ—åŒ–å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹
// ç¡®ä¿æ•°æ®æ ¼å¼çš„å‘åå…¼å®¹æ€§å’Œåºåˆ—åŒ–/ååºåˆ—åŒ–çš„æ­£ç¡®æ€§

test "serialization_compatibility" {
  // 1. æµ‹è¯•åŸºæœ¬æ•°æ®ç±»å‹çš„åºåˆ—åŒ–å…¼å®¹æ€§
  
  // 1.1 æµ‹è¯•å­—ç¬¦ä¸²å±æ€§çš„åºåˆ—åŒ–
  let string_values = [
    "",
    "simple",
    "with spaces",
    "with_special_chars!@#$%^&*()",
    "unicode_æµ‹è¯•_ğŸš€_ç‰¹æ®Šå­—ç¬¦",
    "very_long_string_" + "x" * 1000,
    "quotes\"'and\\backslashes",
    "newlines\nand\ttabs"
  ]
  
  let mut str_index = 0
  while str_index < string_values.length() {
    let original_string = string_values[str_index]
    let string_attr = common::AttributeValue::string(original_string)
    
    // æ¨¡æ‹Ÿåºåˆ—åŒ–å’Œååºåˆ—åŒ–è¿‡ç¨‹
    match string_attr {
      common::StringValue(s) => {
        // éªŒè¯ååºåˆ—åŒ–åçš„å€¼ä¸åŸå§‹å€¼ç›¸åŒ
        @assertion.assert_eq(s, original_string, "String serialization should preserve value")
      }
      _ => @test.expect_failure("Expected string attribute")
    }
    
    str_index = str_index + 1
  }
  
  // 1.2 æµ‹è¯•æ•´æ•°å±æ€§çš„åºåˆ—åŒ–
  let int_values = [
    0L,
    -1L,
    1L,
    9223372036854775807L,  // Int64æœ€å¤§å€¼
    -9223372036854775808L,  // Int64æœ€å°å€¼
    1234567890123456789L,
    -9876543210987654321L
  ]
  
  let mut int_index = 0
  while int_index < int_values.length() {
    let original_int = int_values[int_index]
    let int_attr = common::AttributeValue::int(original_int.to_string())
    
    match int_attr {
      common::IntValue(i) => {
        @assertion.assert_eq(i, original_int.to_string(), "Integer serialization should preserve value")
      }
      _ => @test.expect_failure("Expected integer attribute")
    }
    
    int_index = int_index + 1
  }
  
  // 1.3 æµ‹è¯•æµ®ç‚¹å±æ€§çš„åºåˆ—åŒ–
  let float_values = [
    0.0,
    -0.0,
    1.5,
    -1.5,
    3.14159265359,
    1.0 / 0.0,      // æ­£æ— ç©·
    -1.0 / 0.0,     // è´Ÿæ— ç©·
    0.0 / 0.0,      // NaN
    1.23e-10,       // æå°å€¼
    1.23e+20        // æå¤§å€¼
  ]
  
  let mut float_index = 0
  while float_index < float_values.length() {
    let original_float = float_values[float_index]
    let float_attr = common::AttributeValue::float(original_float)
    
    match float_attr {
      common::FloatValue(f) => {
        if @test.is_nan(original_float) {
          @assertion.assert_true(@test.is_nan(f), "NaN should be preserved in serialization")
        } else {
          @assertion.assert_eq(f, original_float, "Float serialization should preserve value")
        }
      }
      _ => @test.expect_failure("Expected float attribute")
    }
    
    float_index = float_index + 1
  }
  
  // 1.4 æµ‹è¯•å¸ƒå°”å±æ€§çš„åºåˆ—åŒ–
  let bool_values = [true, false]
  
  let mut bool_index = 0
  while bool_index < bool_values.length() {
    let original_bool = bool_values[bool_index]
    let bool_attr = common::AttributeValue::bool(original_bool)
    
    match bool_attr {
      common::BoolValue(b) => {
        @assertion.assert_eq(b, original_bool, "Boolean serialization should preserve value")
      }
      _ => @test.expect_failure("Expected boolean attribute")
    }
    
    bool_index = bool_index + 1
  }
  
  // 1.5 æµ‹è¯•æ•°ç»„å±æ€§çš„åºåˆ—åŒ–
  let string_array = ["a", "b", "c", "", "special_æµ‹è¯•", "very_long_item_" + "x" * 100]
  let array_attr = common::AttributeValue::array_string(string_array)
  
  match array_attr {
    common::ArrayStringValue(arr) => {
      @assertion.assert_eq(arr.length(), string_array.length(), "Array serialization should preserve length")
      let mut element_index = 0
      while element_index < arr.length() {
        @assertion.assert_eq(arr[element_index], string_array[element_index], "Array serialization should preserve elements")
        element_index = element_index + 1
      }
    }
    _ => @test.expect_failure("Expected array string attribute")
  }
  
  // 2. æµ‹è¯•å¤æ‚å¯¹è±¡çš„åºåˆ—åŒ–å…¼å®¹æ€§
  
  // 2.1 æµ‹è¯•Resourceå¯¹è±¡çš„åºåˆ—åŒ–
  let resource = common::Resource::{
    service_name: "test-service",
    service_version: Some("1.2.3"),
    telemetry_sdk_name: "azimuth",
    telemetry_sdk_version: "0.1.0",
    attributes: [
      ("environment", common::AttributeValue::string("test")),
      ("region", common::AttributeValue::string("us-west-2")),
      ("instance-id", common::AttributeValue::string("i-1234567890abcdef0"))
    ]
  }
  
  // éªŒè¯Resourceå­—æ®µå¯ä»¥æ­£ç¡®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  @assertion.assert_eq(resource.service_name, "test-service")
  @assertion.assert_eq(resource.service_version?, "1.2.3")
  @assertion.assert_eq(resource.telemetry_sdk_name, "azimuth")
  @assertion.assert_eq(resource.telemetry_sdk_version, "0.1.0")
  @assertion.assert_eq(resource.attributes.length(), 3)
  
  // 2.2 æµ‹è¯•InstrumentationScopeå¯¹è±¡çš„åºåˆ—åŒ–
  let scope = common::InstrumentationScope::{
    name: "test-scope",
    version: Some("2.0.0"),
    schema_url: Some("https://example.com/schema")
  }
  
  // éªŒè¯InstrumentationScopeå­—æ®µå¯ä»¥æ­£ç¡®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  @assertion.assert_eq(scope.name, "test-scope")
  @assertion.assert_eq(scope.version?, "2.0.0")
  @assertion.assert_eq(scope.schema_url?, "https://example.com/schema")
  
  // 3. æµ‹è¯•ç‰ˆæœ¬å…¼å®¹æ€§
  
  // 3.1 æµ‹è¯•ä¸åŒç‰ˆæœ¬çš„æ•°æ®æ ¼å¼å…¼å®¹æ€§
  let version_test_cases = [
    ("v1.0.0", "basic_format"),
    ("v1.1.0", "with_optional_fields"),
    ("v2.0.0", "enhanced_format"),
    ("v2.1.0", "extended_format")
  ]
  
  let mut version_index = 0
  while version_index < version_test_cases.length() {
    let (version, format_type) = version_test_cases[version_index]
    
    // æ¨¡æ‹Ÿä¸åŒç‰ˆæœ¬çš„åºåˆ—åŒ–æ•°æ®
    let versioned_string = common::AttributeValue::string("data_for_" + version)
    let versioned_int = common::AttributeValue::int((version_index * 100).to_string())
    
    // éªŒè¯ç‰ˆæœ¬å…¼å®¹æ€§
    match versioned_string {
      common::StringValue(s) => @assertion.assert_eq(s, "data_for_" + version)
      _ => @test.expect_failure("Expected versioned string attribute")
    }
    
    match versioned_int {
      common::IntValue(i) => @assertion.assert_eq(i, (version_index * 100).to_string())
      _ => @test.expect_failure("Expected versioned int attribute")
    }
    
    version_index = version_index + 1
  }
  
  // 4. æµ‹è¯•å‘åå…¼å®¹æ€§
  
  // 4.1 æµ‹è¯•æ—§ç‰ˆæœ¬æ•°æ®åœ¨æ–°ç‰ˆæœ¬ä¸­çš„å¤„ç†
  let legacy_data_cases = [
    ("legacy_string", "simple_string"),
    ("legacy_int", "42"),
    ("legacy_float", "3.14"),
    ("legacy_bool", "true")
  ]
  
  let mut legacy_index = 0
  while legacy_index < legacy_data_cases.length() {
    let (data_type, data_value) = legacy_data_cases[legacy_index]
    
    // æ¨¡æ‹Ÿæ—§ç‰ˆæœ¬æ•°æ®çš„å¤„ç†
    let legacy_attr = match data_type {
      "legacy_string" => common::AttributeValue::string(data_value),
      "legacy_int" => common::AttributeValue::int(data_value),
      "legacy_float" => common::AttributeValue::float(@float.from_string(data_value)),
      "legacy_bool" => common::AttributeValue::bool(data_value == "true"),
      _ => common::AttributeValue::string("unknown")
    }
    
    // éªŒè¯æ—§ç‰ˆæœ¬æ•°æ®å¯ä»¥æ­£ç¡®å¤„ç†
    match legacy_attr {
      common::StringValue(s) => @assertion.assert_eq(s, data_value)
      common::IntValue(i) => @assertion.assert_eq(i, data_value)
      common::FloatValue(f) => @assertion.assert_eq(f, @float.from_string(data_value))
      common::BoolValue(b) => @assertion.assert_eq(b, data_value == "true")
      _ => {}
    }
    
    legacy_index = legacy_index + 1
  }
  
  // 5. æµ‹è¯•åºåˆ—åŒ–æ ¼å¼çš„ç¨³å®šæ€§
  
  // 5.1 æµ‹è¯•ç›¸åŒæ•°æ®çš„å¤šæ¬¡åºåˆ—åŒ–ç»“æœä¸€è‡´æ€§
  let stable_data = common::AttributeValue::string("stable_test_data")
  
  let mut serialization_round = 0
  while serialization_round < 10 {
    match stable_data {
      common::StringValue(s) => {
        @assertion.assert_eq(s, "stable_test_data", "Serialization should be stable across multiple rounds")
      }
      _ => @test.expect_failure("Expected stable string attribute")
    }
    serialization_round = serialization_round + 1
  }
  
  // 6. æµ‹è¯•è¾¹ç•Œæƒ…å†µçš„åºåˆ—åŒ–
  
  // 6.1 æµ‹è¯•æå€¼æ•°æ®çš„åºåˆ—åŒ–
  let extreme_cases = [
    ("empty_string", common::AttributeValue::string("")),
    ("max_int", common::AttributeValue::int("9223372036854775807")),
    ("min_int", common::AttributeValue::int("-9223372036854775808")),
    ("max_float", common::AttributeValue::float(1.7976931348623157e+308)),
    ("min_float", common::AttributeValue::float(-1.7976931348623157e+308)),
    ("empty_array", common::AttributeValue::array_string([]))
  ]
  
  let mut extreme_index = 0
  while extreme_index < extreme_cases.length() {
    let (case_name, extreme_attr) = extreme_cases[extreme_index]
    
    // éªŒè¯æå€¼æ•°æ®å¯ä»¥æ­£ç¡®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
    match extreme_attr {
      common::StringValue(s) => @assertion.assert_eq(s, "")
      common::IntValue(i) => @assertion.assert_true(i == "9223372036854775807" or i == "-9223372036854775808")
      common::FloatValue(f) => @assertion.assert_true(f == 1.7976931348623157e+308 or f == -1.7976931348623157e+308)
      common::ArrayStringValue(arr) => @assertion.assert_eq(arr.length(), 0)
      _ => {}
    }
    
    extreme_index = extreme_index + 1
  }
  
  // 7. æµ‹è¯•åºåˆ—åŒ–é”™è¯¯å¤„ç†
  
  // 7.1 æµ‹è¯•æŸåæ•°æ®çš„å¤„ç†
  let corrupted_data_cases = [
    ("truncated_string", "trunc"),
    ("invalid_int", "not_a_number"),
    ("invalid_float", "not_a_float"),
    ("invalid_bool", "maybe")
  ]
  
  let mut corrupted_index = 0
  while corrupted_index < corrupted_data_cases.length() {
    let (corruption_type, corrupted_value) = corrupted_data_cases[corrupted_index]
    
    // æ¨¡æ‹Ÿå¯¹æŸåæ•°æ®çš„å¤„ç†ï¼ˆåœ¨No-opå®ç°ä¸­ä¸»è¦æ˜¯éªŒè¯ä¸ä¼šå´©æºƒï¼‰
    let safe_attr = common::AttributeValue::string("safe_fallback_for_" + corruption_type)
    
    match safe_attr {
      common::StringValue(s) => {
        @assertion.assert_eq(s, "safe_fallback_for_" + corruption_type, "Should handle corrupted data gracefully")
      }
      _ => @test.expect_failure("Expected safe fallback attribute")
    }
    
    corrupted_index = corrupted_index + 1
  }
  
  // 8. éªŒè¯åºåˆ—åŒ–å…¼å®¹æ€§æµ‹è¯•çš„å®Œæ•´æ€§
  @assertion.assert_true(true, "Serialization compatibility should be maintained")
}

test "serialization_format_evolution" {
  // æµ‹è¯•åºåˆ—åŒ–æ ¼å¼çš„æ¼”è¿›
  
  // 1. æµ‹è¯•å­—æ®µæ·»åŠ çš„å…¼å®¹æ€§
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("evolution-test")
  
  // æ¨¡æ‹Ÿv1.0æ ¼å¼ï¼ˆåŸºæœ¬å­—æ®µï¼‰
  let v1_attributes = [
    ("name", common::AttributeValue::string("test-metric")),
    ("value", common::AttributeValue::int("42"))
  ]
  
  let v1_counter = meter.create_counter("v1_counter", "count", "V1 format counter")
  let mut v1_index = 0
  while v1_index < v1_attributes.length() {
    let (key, value) = v1_attributes[v1_index]
    v1_counter.add(1L, [(key, value)])
    v1_index = v1_index + 1
  }
  
  // æ¨¡æ‹Ÿv2.0æ ¼å¼ï¼ˆæ·»åŠ æ–°å­—æ®µï¼‰
  let v2_attributes = [
    ("name", common::AttributeValue::string("test-metric")),
    ("value", common::AttributeValue::int("42")),
    ("version", common::AttributeValue::string("2.0")),
    ("timestamp", common::AttributeValue::int("1609459200000000000"))
  ]
  
  let v2_counter = meter.create_counter("v2_counter", "count", "V2 format counter")
  let mut v2_index = 0
  while v2_index < v2_attributes.length() {
    let (key, value) = v2_attributes[v2_index]
    v2_counter.add(1L, [(key, value)])
    v2_index = v2_index + 1
  }
  
  // éªŒè¯å‘åå…¼å®¹æ€§ï¼šv2æ ¼å¼åº”è¯¥èƒ½å¤„ç†v1æ•°æ®
  @assertion.assert_true(v2_attributes.length() > v1_attributes.length(), "V2 format should have more fields")
  
  // 2. æµ‹è¯•å­—æ®µåˆ é™¤çš„å…¼å®¹æ€§
  // æ¨¡æ‹Ÿä»v2.0åˆ°v3.0çš„å­—æ®µåˆ é™¤
  let v3_attributes = [
    ("name", common::AttributeValue::string("test-metric")),
    ("value", common::AttributeValue::int("42")),
    ("timestamp", common::AttributeValue::int("1609459200000000000"))
  ]  // åˆ é™¤äº†versionå­—æ®µ
  
  let v3_counter = meter.create_counter("v3_counter", "count", "V3 format counter")
  let mut v3_index = 0
  while v3_index < v3_attributes.length() {
    let (key, value) = v3_attributes[v3_index]
    v3_counter.add(1L, [(key, value)])
    v3_index = v3_index + 1
  }
  
  // 3. æµ‹è¯•å­—æ®µç±»å‹å˜æ›´çš„å…¼å®¹æ€§
  // æ¨¡æ‹Ÿå­—æ®µç±»å‹å˜æ›´ï¼šint -> string
  let type_change_cases = [
    ("old_format", common::AttributeValue::int("123")),
    ("new_format", common::AttributeValue::string("123"))
  ]
  
  let mut type_index = 0
  while type_index < type_change_cases.length() {
    let (format_name, attr_value) = type_change_cases[type_index]
    
    match attr_value {
      common::IntValue(i) => @assertion.assert_eq(i, "123")
      common::StringValue(s) => @assertion.assert_eq(s, "123")
      _ => @test.expect_failure("Expected type change compatible attribute")
    }
    
    type_index = type_index + 1
  }
  
  // 4. æµ‹è¯•å­—æ®µé‡å‘½åçš„å…¼å®¹æ€§
  // æ¨¡æ‹Ÿå­—æ®µé‡å‘½åï¼šold_name -> new_name
  let field_rename_cases = [
    ("legacy_name", common::AttributeValue::string("legacy_value")),
    ("new_name", common::AttributeValue::string("legacy_value"))
  ]
  
  let mut rename_index = 0
  while rename_index < field_rename_cases.length() {
    let (field_name, attr_value) = field_rename_cases[rename_index]
    
    match attr_value {
      common::StringValue(s) => @assertion.assert_eq(s, "legacy_value")
      _ => @test.expect_failure("Expected field rename compatible attribute")
    }
    
    rename_index = rename_index + 1
  }
  
  // 5. æµ‹è¯•ç»“æ„å˜æ›´çš„å…¼å®¹æ€§
  // 5.1 æµ‹è¯•æ•°ç»„é•¿åº¦å˜æ›´
  let array_evolution_cases = [
    common::AttributeValue::array_string(["a", "b", "c"]),
    common::AttributeValue::array_string(["a", "b", "c", "d", "e"]),
    common::AttributeValue::array_string([])  // ç©ºæ•°ç»„
  ]
  
  let mut array_index = 0
  while array_index < array_evolution_cases.length() {
    let array_attr = array_evolution_cases[array_index]
    
    match array_attr {
      common::ArrayStringValue(arr) => {
        @assertion.assert_true(arr.length() >= 0, "Array length should be non-negative")
      }
      _ => @test.expect_failure("Expected array attribute")
    }
    
    array_index = array_index + 1
  }
  
  // 6. æµ‹è¯•åµŒå¥—ç»“æ„çš„å…¼å®¹æ€§
  // æ¨¡æ‹ŸåµŒå¥—ç»“æ„çš„æ¼”è¿›
  let nested_evolution_meter = meter_provider.get_meter("nested-evolution-test")
  let nested_counter = nested_evolution_meter.create_counter("nested_counter", "count", "Nested structure counter")
  
  // v1.0åµŒå¥—ç»“æ„
  nested_counter.add(1L, [
    ("level1.field1", common::AttributeValue::string("value1")),
    ("level1.field2", common::AttributeValue::int("100"))
  ])
  
  // v2.0åµŒå¥—ç»“æ„ï¼ˆæ·»åŠ level2ï¼‰
  nested_counter.add(1L, [
    ("level1.field1", common::AttributeValue::string("value1")),
    ("level1.field2", common::AttributeValue::int("100")),
    ("level1.level2.field1", common::AttributeValue::string("nested_value")),
    ("level1.level2.field2", common::AttributeValue::bool(true))
  ])
  
  // 7. æµ‹è¯•æšä¸¾ç±»å‹çš„å…¼å®¹æ€§
  // æ¨¡æ‹Ÿæšä¸¾å€¼çš„æ¼”è¿›
  let enum_evolution_cases = [
    ("v1_enum", "option1"),
    ("v1_enum", "option2"),
    ("v2_enum", "option1"),      // ä¿æŒåŸæœ‰é€‰é¡¹
    ("v2_enum", "option2"),      // ä¿æŒåŸæœ‰é€‰é¡¹
    ("v2_enum", "option3"),      // æ–°å¢é€‰é¡¹
    ("v2_enum", "option4")       // æ–°å¢é€‰é¡¹
  ]
  
  let mut enum_index = 0
  while enum_index < enum_evolution_cases.length() {
    let (enum_name, enum_value) = enum_evolution_cases[enum_index]
    
    let enum_attr = common::AttributeValue::string(enum_value)
    match enum_attr {
      common::StringValue(s) => @assertion.assert_eq(s, enum_value)
      _ => @test.expect_failure("Expected enum attribute")
    }
    
    enum_index = enum_index + 1
  }
  
  // 8. æµ‹è¯•æ•°æ®å‹ç¼©çš„å…¼å®¹æ€§
  // æ¨¡æ‹Ÿæ•°æ®å‹ç¼©æ ¼å¼çš„æ¼”è¿›
  let compression_cases = [
    ("uncompressed", "this_is_uncompressed_data"),
    ("compressed_v1", "compressed_data_v1"),
    ("compressed_v2", "compressed_data_v2")
  ]
  
  let mut compression_index = 0
  while compression_index < compression_cases.length() {
    let (compression_type, data_value) = compression_cases[compression_index]
    
    let compressed_attr = common::AttributeValue::string(data_value)
    match compressed_attr {
      common::StringValue(s) => @assertion.assert_eq(s, data_value)
      _ => @test.expect_failure("Expected compressed attribute")
    }
    
    compression_index = compression_index + 1
  }
  
  // 9. æµ‹è¯•åºåˆ—åŒ–ç‰ˆæœ¬æ ‡è¯†
  // æ¨¡æ‹Ÿç‰ˆæœ¬æ ‡è¯†çš„æ¼”è¿›
  let version_identifiers = [
    "1.0.0",
    "1.1.0",
    "2.0.0",
    "2.1.0",
    "2.1.1"
  ]
  
  let mut version_id_index = 0
  while version_id_index < version_identifiers.length() {
    let version_id = version_identifiers[version_id_index]
    
    let version_attr = common::AttributeValue::string(version_id)
    match version_attr {
      common::StringValue(s) => @assertion.assert_eq(s, version_id)
      _ => @test.expect_failure("Expected version identifier attribute")
    }
    
    version_id_index = version_id_index + 1
  }
  
  // 10. éªŒè¯åºåˆ—åŒ–æ ¼å¼æ¼”è¿›çš„å®Œæ•´æ€§
  @assertion.assert_true(true, "Serialization format evolution should be handled correctly")
}