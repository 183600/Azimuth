// Azimuth Boundary Condition and Exception Handling Tests
// æµ‹è¯•è¾¹ç•Œæ¡ä»¶ã€å¼‚å¸¸å¤„ç†å’Œé”™è¯¯æ¢å¤åŠŸèƒ½

test "æ•°å€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œæ¡ä»¶
  let max_int32 = 2147483647
  let min_int32 = -2147483648
  let max_int64 = 9223372036854775807L
  let min_int64 = -9223372036854775808L
  
  // æµ‹è¯•æ•´æ•°æº¢å‡º
  let overflow_result = add_with_overflow_check(max_int32, 1)
  assert_true(overflow_result.is_error)
  assert_true(overflow_result.error.contains("overflow"))
  
  let safe_add = add_with_overflow_check(max_int32, 0)
  assert_true(safe_add.is_ok)
  assert_eq(safe_add.value, max_int32)
  
  // æµ‹è¯•æ•´æ•°ä¸‹æº¢
  let underflow_result = subtract_with_overflow_check(min_int32, 1)
  assert_true(underflow_result.is_error)
  assert_true(underflow_result.error.contains("underflow"))
  
  let safe_subtract = subtract_with_overflow_check(min_int32, 0)
  assert_true(safe_subtract.is_ok)
  assert_eq(safe_subtract.value, min_int32)
  
  // æµ‹è¯•64ä½æ•´æ•°è¾¹ç•Œ
  let int64_overflow = multiply_with_overflow_check(max_int64, 2)
  assert_true(int64_overflow.is_error)
  
  let int64_safe = multiply_with_overflow_check(max_int64, 1)
  assert_true(int64_safe.is_ok)
  assert_eq(int64_safe.value, max_int64)
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œ
  let max_float = 3.4028235e38
  let min_float = -3.4028235e38
  let inf_float = 1.0 / 0.0
  let neg_inf_float = -1.0 / 0.0
  let nan_float = 0.0 / 0.0
  
  assert_true(is_infinite(inf_float))
  assert_true(is_infinite(neg_inf_float))
  assert_true(is_nan(nan_float))
  assert_false(is_nan(max_float))
  assert_false(is_infinite(max_float))
  
  // æµ‹è¯•æµ®ç‚¹æ•°ç²¾åº¦è¾¹ç•Œ
  let very_small = 1e-10
  let very_large = 1e10
  let precision_test = very_large + very_small
  assert_true(precision_test == very_large)  // å°æ•°è¢«ç²¾åº¦ä¸¢å¤±
  
  // æµ‹è¯•é™¤é›¶è¾¹ç•Œ
  let div_by_zero_result = safe_divide(10.0, 0.0)
  assert_true(div_by_zero_result.is_error)
  assert_true(div_by_zero_result.error.contains("division by zero"))
  
  let zero_div_zero_result = safe_divide(0.0, 0.0)
  assert_true(zero_div_zero_result.is_error)
  
  let safe_division = safe_divide(10.0, 2.0)
  assert_true(safe_division.is_ok)
  assert_eq(safe_division.value, 5.0)
}

test "å­—ç¬¦ä¸²å’Œé›†åˆè¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶
  let empty_string = ""
  let very_long_string = "a" * 1000000  // 1MBå­—ç¬¦ä¸²
  let unicode_string = "æµ‹è¯•ğŸš€UnicodeğŸŒŸå­—ç¬¦ä¸²"
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²æ“ä½œ
  assert_eq(empty_string.length(), 0)
  assert_true(empty_string.is_empty())
  assert_eq(empty_string.to_uppercase(), "")
  assert_eq(empty_string.to_lowercase(), "")
  assert_false(empty_string.contains("a"))
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²æ“ä½œ
  assert_eq(very_long_string.length(), 1000000)
  assert_true(very_long_string.contains("a"))
  assert_eq(very_long_string.substring(0, 10), "aaaaaaaaaa")
  
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œç´¢å¼•
  let empty_substring = empty_string.substring(0, 0)
  assert_eq(empty_substring, "")
  
  let out_of_bounds_substring = very_long_string.safe_substring(999999, 5)
  assert_eq(out_of_bounds_substring, "a")
  
  let invalid_substring = very_long_string.safe_substring(1000001, 10)
  assert_eq(invalid_substring, "")
  
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²
  assert_eq(unicode_string.length(), 11)  // Unicodeå­—ç¬¦è®¡æ•°
  assert_true(unicode_string.contains("æµ‹è¯•"))
  assert_true(unicode_string.contains("ğŸš€"))
  
  // æµ‹è¯•é›†åˆè¾¹ç•Œæ¡ä»¶
  let empty_array = []
  let large_array = [0] * 100000  // 10ä¸‡å…ƒç´ æ•°ç»„
  
  // æµ‹è¯•ç©ºæ•°ç»„æ“ä½œ
  assert_eq(empty_array.length(), 0)
  assert_true(empty_array.is_empty())
  assert_eq(empty_array.first(), None)
  assert_eq(empty_array.last(), None)
  
  // æµ‹è¯•å¤§æ•°ç»„æ“ä½œ
  assert_eq(large_array.length(), 100000)
  assert_eq(large_array.first(), Some(0))
  assert_eq(large_array.last(), Some(0))
  
  // æµ‹è¯•æ•°ç»„è¾¹ç•Œç´¢å¼•
  let empty_first = empty_array.get_safe(0)
  assert_eq(empty_first, None)
  
  let large_first = large_array.get_safe(0)
  assert_eq(large_first, Some(0))
  
  let large_last = large_array.get_safe(99999)
  assert_eq(large_last, Some(0))
  
  let out_of_bounds = large_array.get_safe(100000)
  assert_eq(out_of_bounds, None)
  
  // æµ‹è¯•é›†åˆæ“ä½œè¾¹ç•Œ
  let empty_result = empty_array.filter(fn(x) { x > 0 })
  assert_eq(empty_result.length(), 0)
  
  let large_filtered = large_array.filter(fn(x) { x > 0 })
  assert_eq(large_filtered.length(), 0)
  
  let large_mapped = large_array.map(fn(x) { x + 1 })
  assert_eq(large_mapped.length(), 100000)
  assert_eq(large_mapped[0], 1)
  assert_eq(large_mapped[99999], 1)
}

test "å†…å­˜å’Œèµ„æºè¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•å†…å­˜è¾¹ç•Œæ¡ä»¶
  let memory_limiter = MemoryLimiter::new(50 * 1024 * 1024)  // 50MBé™åˆ¶
  
  // æµ‹è¯•å†…å­˜åˆ†é…è¾¹ç•Œ
  let small_allocation = MemoryLimiter::allocate(memory_limiter, 1024)  // 1KB
  assert_true(small_allocation.is_ok)
  
  let large_allocation = MemoryLimiter::allocate(memory_limiter, 100 * 1024 * 1024)  // 100MB
  assert_true(large_allocation.is_error)
  assert_true(large_allocation.error.contains("memory limit exceeded"))
  
  // æµ‹è¯•å†…å­˜é‡Šæ”¾
  MemoryLimiter::deallocate(memory_limiter, small_allocation.value)
  
  let after_release_allocation = MemoryLimiter::allocate(memory_limiter, 1024)
  assert_true(after_release_allocation.is_ok)
  
  // æµ‹è¯•æ–‡ä»¶å¥æŸ„è¾¹ç•Œ
  let file_handle_limiter = FileHandleLimiter::new(10)
  
  let file_handles = []
  for i in 0..=9 {
    let handle = FileHandleLimiter::acquire(file_handle_limiter)
    file_handles = file_handles.push(handle)
  }
  
  assert_eq(file_handles.length(), 10)
  
  // æµ‹è¯•å¥æŸ„è€—å°½
  let exhausted_handle = FileHandleLimiter::acquire(file_handle_limiter)
  assert_true(exhausted_handle.is_error)
  assert_true(exhausted_handle.error.contains("no available file handles"))
  
  // é‡Šæ”¾ä¸€ä¸ªå¥æŸ„
  FileHandleLimiter::release(file_handle_limiter, file_handles[0])
  
  let available_handle = FileHandleLimiter::acquire(file_handle_limiter)
  assert_true(available_handle.is_ok)
  
  // æµ‹è¯•ç½‘ç»œè¿æ¥è¾¹ç•Œ
  let connection_limiter = ConnectionLimiter::new(5)
  
  let connections = []
  for i in 0..=4 {
    let conn = ConnectionLimiter::establish(connection_limiter, "endpoint-" + i.to_string())
    connections = connections.push(conn)
  }
  
  assert_eq(connections.length(), 5)
  
  // æµ‹è¯•è¿æ¥è€—å°½
  let exhausted_connection = ConnectionLimiter::establish(connection_limiter, "extra-endpoint")
  assert_true(exhausted_connection.is_error)
  assert_true(exhausted_connection.error.contains("connection limit exceeded"))
  
  // æ¸…ç†è¿æ¥
  for conn in connections {
    ConnectionLimiter::close(connection_limiter, conn)
  }
}

test "å¹¶å‘å’Œç«äº‰æ¡ä»¶è¾¹ç•Œ" {
  // æµ‹è¯•å¹¶å‘è¾¹ç•Œæ¡ä»¶
  let concurrent_counter = ConcurrentCounter::new()
  let concurrent_map = ConcurrentHashMap::new()
  let concurrent_queue = ConcurrentQueue::new(100)
  
  // å¯åŠ¨å¤šä¸ªå¹¶å‘ä»»åŠ¡
  let concurrent_tasks = []
  for i in 0..=9 {
    let task = spawn(fn() {
      // å¹¶å‘é€’å¢è®¡æ•°å™¨
      for j in 0..=99 {
        ConcurrentCounter::increment(concurrent_counter)
      }
      
      // å¹¶å‘å†™å…¥æ˜ å°„
      for k in 0..=9 {
        let key = "key-" + i.to_string() + "-" + k.to_string()
        let value = "value-" + i.to_string() + "-" + k.to_string()
        ConcurrentHashMap::put(concurrent_map, key, value)
      }
      
      // å¹¶å‘å…¥é˜Ÿ
      for m in 0..=9 {
        ConcurrentQueue::enqueue(concurrent_queue, "item-" + i.to_string() + "-" + m.to_string())
      }
    })
    concurrent_tasks = concurrent_tasks.push(task)
  }
  
  // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
  for task in concurrent_tasks {
    join(task)
  }
  
  // éªŒè¯å¹¶å‘ç»“æœ
  assert_eq(ConcurrentCounter::value(concurrent_counter), 1000)  // 10ä¸ªçº¿ç¨‹ Ã— 100æ¬¡é€’å¢
  assert_eq(ConcurrentHashMap::size(concurrent_map), 100)      // 10ä¸ªçº¿ç¨‹ Ã— 10ä¸ªé”®å€¼å¯¹
  assert_eq(ConcurrentQueue::size(concurrent_queue), 100)      // 10ä¸ªçº¿ç¨‹ Ã— 10ä¸ªé¡¹ç›®
  
  // æµ‹è¯•å¹¶å‘è¾¹ç•Œæ¡ä»¶
  let bounded_queue = BoundedConcurrentQueue::new(5)
  
  // å¡«æ»¡é˜Ÿåˆ—
  for i in 0..=4 {
    let enqueue_result = BoundedConcurrentQueue::try_enqueue(bounded_queue, "item-" + i.to_string())
    assert_true(enqueue_result.is_ok)
  }
  
  // æµ‹è¯•é˜Ÿåˆ—æ»¡æ—¶çš„è¾¹ç•Œæ¡ä»¶
  let full_queue_result = BoundedConcurrentQueue::try_enqueue(bounded_queue, "extra-item")
  assert_true(full_queue_result.is_error)
  assert_true(full_queue_result.error.contains("queue is full"))
  
  // æµ‹è¯•ç©ºé˜Ÿåˆ—çš„è¾¹ç•Œæ¡ä»¶
  let empty_queue = BoundedConcurrentQueue::new(5)
  let empty_dequeue_result = BoundedConcurrentQueue::try_dequeue(empty_queue)
  assert_true(empty_dequeue_result.is_error)
  assert_true(empty_dequeue_result.error.contains("queue is empty"))
  
  // æµ‹è¯•æ­»é”æ£€æµ‹
  let deadlock_detector = DeadlockDetector::new()
  
  // æ¨¡æ‹Ÿæ½œåœ¨æ­»é”åœºæ™¯
  let resource_a = DeadlockDetector::create_resource(deadlock_detector, "resource-a")
  let resource_b = DeadlockDetector::create_resource(deadlock_detector, "resource-b")
  
  let deadlock_task1 = spawn(fn() {
    DeadlockDetector::acquire(deadlock_detector, resource_a)
    sleep(100)  // å¢åŠ æ­»é”æ¦‚ç‡
    DeadlockDetector::acquire(deadlock_detector, resource_b)
    DeadlockDetector::release(deadlock_detector, resource_b)
    DeadlockDetector::release(deadlock_detector, resource_a)
  })
  
  let deadlock_task2 = spawn(fn() {
    DeadlockDetector::acquire(deadlock_detector, resource_b)
    sleep(100)  // å¢åŠ æ­»é”æ¦‚ç‡
    DeadlockDetector::acquire(deadlock_detector, resource_a)
    DeadlockDetector::release(deadlock_detector, resource_a)
    DeadlockDetector::release(deadlock_detector, resource_b)
  })
  
  // ç­‰å¾…å¹¶æ£€æµ‹æ­»é”
  sleep(1000)
  let deadlock_detected = DeadlockDetector::detect_deadlock(deadlock_detector)
  
  if deadlock_detected {
    DeadlockDetector::resolve_deadlock(deadlock_detector)
  }
  
  join(deadlock_task1)
  join(deadlock_task2)
}

test "å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶" {
  // æµ‹è¯•å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶
  let exception_handler = ExceptionHandler::new({
    "max_retries": 3,
    "backoff_strategy": "exponential",
    "recovery_strategies": {
      "timeout": "retry_with_backoff",
      "connection_error": "circuit_breaker",
      "data_corruption": "fallback_to_cache"
    }
  })
  
  // æµ‹è¯•å¯æ¢å¤å¼‚å¸¸
  let recoverable_attempts = ref 0
  let recoverable_result = ExceptionHandler::execute_with_recovery(
    exception_handler,
    fn() {
      recoverable_attempts := !recoverable_attempts + 1
      if !recoverable_attempts < 3 {
        raise Exception("timeout", "Operation timed out")
      } else {
        "success"
      }
    },
    "timeout"
  )
  
  assert_true(recoverable_result.is_ok)
  assert_eq(recoverable_result.value, "success")
  assert_eq(!recoverable_attempts, 3)
  
  // æµ‹è¯•ä¸å¯æ¢å¤å¼‚å¸¸
  let unrecoverable_attempts = ref 0
  let unrecoverable_result = ExceptionHandler::execute_with_recovery(
    exception_handler,
    fn() {
      unrecoverable_attempts := !unrecoverable_attempts + 1
      raise Exception("data_corruption", "Critical data corruption detected")
    },
    "data_corruption"
  )
  
  assert_true(unrecoverable_result.is_error)
  assert_eq(!unrecoverable_attempts, 1)  // ä¸åº”é‡è¯•æ•°æ®æŸåé”™è¯¯
  
  // æµ‹è¯•ç†”æ–­å™¨æœºåˆ¶
  let circuit_breaker = CircuitBreaker::new({
    "failure_threshold": 3,
    "recovery_timeout": 5000,  // 5ç§’
    "monitoring_period": 10000  // 10ç§’
  })
  
  // è§¦å‘ç†”æ–­å™¨
  for i in 0..=2 {
    let result = CircuitBreaker::execute(circuit_breaker, fn() {
      raise Exception("connection_error", "Connection failed")
    })
    assert_true(result.is_error)
  }
  
  // éªŒè¯ç†”æ–­å™¨çŠ¶æ€
  assert_true(CircuitBreaker::is_open(circuit_breaker))
  
  // æµ‹è¯•ç†”æ–­å™¨å¼€å¯æ—¶çš„è¡Œä¸º
  let open_circuit_result = CircuitBreaker::execute(circuit_breaker, fn() {
    "this should not execute"
  })
  assert_true(open_circuit_result.is_error)
  assert_true(open_circuit_result.error.contains("circuit breaker is open"))
  
  // æµ‹è¯•é™çº§ç­–ç•¥
  let fallback_handler = FallbackHandler::new({
    "strategies": {
      "cache": "return_cached_value",
      "default": "return_default_value",
      "alternative": "execute_alternative_service"
    }
  })
  
  FallbackHandler::set_cache_value(fallback_handler, "test_key", "cached_value")
  FallbackHandler::set_default_value(fallback_handler, "test_key", "default_value")
  
  // æµ‹è¯•ç¼“å­˜é™çº§
  let cache_fallback_result = FallbackHandler::execute_with_fallback(
    fallback_handler,
    fn() { raise Exception("service_unavailable", "Service is down") },
    "test_key",
    "cache"
  )
  assert_true(cache_fallback_result.is_ok)
  assert_eq(cache_fallback_result.value, "cached_value")
  
  // æµ‹è¯•é»˜è®¤å€¼é™çº§
  let default_fallback_result = FallbackHandler::execute_with_fallback(
    fallback_handler,
    fn() { raise Exception("service_unavailable", "Service is down") },
    "unknown_key",
    "default"
  )
  assert_true(default_fallback_result.is_ok)
  assert_eq(default_fallback_result.value, "default_value")
  
  // æµ‹è¯•å¼‚å¸¸é“¾å’Œä¸Šä¸‹æ–‡
  let context_builder = ExceptionContext::builder()
  ExceptionContext::add_context(context_builder, "user_id", "user-123")
  ExceptionContext::add_context(context_builder, "operation", "data_processing")
  ExceptionContext::add_context(context_builder, "timestamp", get_current_timestamp())
  
  let context = ExceptionContext::build(context_builder)
  
  let contextual_result = ExceptionHandler::execute_with_context(
    exception_handler,
    context,
    fn() {
      raise Exception("validation_error", "Invalid input data")
    }
  )
  
  assert_true(contextual_result.is_error)
  assert_true(contextual_result.error.contains("user_id"))
  assert_true(contextual_result.error.contains("operation"))
  assert_true(contextual_result.error.contains("validation_error"))
}

test "ç³»ç»Ÿèµ„æºè€—å°½åœºæ™¯" {
  // æµ‹è¯•ç³»ç»Ÿèµ„æºè€—å°½åœºæ™¯
  let resource_monitor = ResourceMonitor::new()
  
  // æµ‹è¯•å†…å­˜è€—å°½åœºæ™¯
  let memory_consumer = MemoryConsumer::new()
  let memory_consumption = ref 0
  
  let memory_exhaustion_result = ExceptionHandler::execute_with_recovery(
    exception_handler,
    fn() {
      memory_consumption := !memory_consumption + (10 * 1024 * 1024)  // æ¯æ¬¡å¢åŠ 10MB
      let allocation_attempt = MemoryConsumer::allocate(memory_consumer, 10 * 1024 * 1024)
      
      match allocation_attempt {
        Ok(_) => "allocated",
        Err(error) => {
          if error.contains("out of memory") {
            raise Exception("out_of_memory", "System memory exhausted")
          } else {
            raise Exception("allocation_error", error)
          }
        }
      }
    },
    "out_of_memory"
  )
  
  // éªŒè¯å†…å­˜è€—å°½å¤„ç†
  assert_true(memory_consumption > 0)
  assert_true(memory_exhaustion_result.is_ok || memory_exhaustion_result.is_error)
  
  // æµ‹è¯•æ–‡ä»¶æè¿°ç¬¦è€—å°½åœºæ™¯
  let fd_consumer = FileDescriptorConsumer::new()
  let fd_count = ref 0
  
  let fd_exhaustion_result = ExceptionHandler::execute_with_recovery(
    exception_handler,
    fn() {
      fd_count := !fd_count + 1
      let fd_attempt = FileDescriptorConsumer::open_file(fd_consumer, "temp_file_" + !fd_count.to_string())
      
      match fd_attempt {
        Ok(_) => "file_opened",
        Err(error) => {
          if error.contains("too many open files") {
            raise Exception("fd_exhaustion", "File descriptor limit reached")
          } else {
            raise Exception("file_error", error)
          }
        }
      }
    },
    "fd_exhaustion"
  )
  
  // éªŒè¯æ–‡ä»¶æè¿°ç¬¦è€—å°½å¤„ç†
  assert_true(fd_count > 0)
  
  // æµ‹è¯•ç£ç›˜ç©ºé—´è€—å°½åœºæ™¯
  let disk_consumer = DiskConsumer::new("/tmp")
  let disk_usage = ref 0
  
  let disk_exhaustion_result = ExceptionHandler::execute_with_recovery(
    exception_handler,
    fn() {
      disk_usage := !disk_usage + (1024 * 1024)  // æ¯æ¬¡å¢åŠ 1MB
      let write_attempt = DiskConsumer::write_file(
        disk_consumer, 
        "large_file_" + !disk_usage.to_string(), 
        "x" * (1024 * 1024)
      )
      
      match write_attempt {
        Ok(_) => "data_written",
        Err(error) => {
          if error.contains("no space left") {
            raise Exception("disk_full", "Disk space exhausted")
          } else {
            raise Exception("disk_error", error)
          }
        }
      }
    },
    "disk_full"
  )
  
  // éªŒè¯ç£ç›˜ç©ºé—´è€—å°½å¤„ç†
  assert_true(disk_usage > 0)
  
  // æµ‹è¯•ç½‘ç»œç«¯å£è€—å°½åœºæ™¯
  let port_consumer = PortConsumer::new()
  let port_count = ref 0
  
  let port_exhaustion_result = ExceptionHandler::execute_with_recovery(
    exception_handler,
    fn() {
      port_count := !port_count + 1
      let port_attempt = PortConsumer::bind_port(port_consumer, 8000 + !port_count)
      
      match port_attempt {
        Ok(_) => "port_bound",
        Err(error) => {
          if error.contains("address already in use") || error.contains("no available ports") {
            raise Exception("port_exhaustion", "Network ports exhausted")
          } else {
            raise Exception("network_error", error)
          }
        }
      }
    },
    "port_exhaustion"
  )
  
  // éªŒè¯ç½‘ç»œç«¯å£è€—å°½å¤„ç†
  assert_true(port_count > 0)
  
  // æ¸…ç†èµ„æº
  MemoryConsumer::cleanup(memory_consumer)
  FileDescriptorConsumer::cleanup(fd_consumer)
  DiskConsumer::cleanup(disk_consumer)
  PortConsumer::cleanup(port_consumer)
}