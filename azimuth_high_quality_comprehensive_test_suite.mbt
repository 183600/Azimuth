// Azimuth é«˜è´¨é‡ç»¼åˆæµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºæ ¸å¿ƒåŠŸèƒ½çš„é«˜çº§æµ‹è¯•åœºæ™¯ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§å’Œå¯é æ€§

// æµ‹è¯•1: æ•°æ®è´¨é‡éªŒè¯
test "æ•°æ®è´¨é‡éªŒè¯æµ‹è¯•" {
  // åˆ›å»ºæ•°æ®è´¨é‡éªŒè¯å™¨
  let quality_validator = DataQualityValidator::new()
  
  // é…ç½®éªŒè¯è§„åˆ™
  QualityValidator::add_rule(quality_validator, "trace_id", {
    type: "format",
    pattern: "^[a-f0-9]{32}$",
    required: true
  })
  
  QualityValidator::add_rule(quality_validator, "span_name", {
    type: "length",
    min: 1,
    max: 255,
    required: true
  })
  
  QualityValidator::add_rule(quality_validator, "duration", {
    type: "range",
    min: 0,
    max: 3600000,  // 1å°æ—¶æœ€å¤§è·¨åº¦
    required: true
  })
  
  // åˆ›å»ºæœ‰æ•ˆæµ‹è¯•æ•°æ®
  let valid_telemetry_data = {
    trace_id: "a1b2c3d4e5f6789012345678901234ab",
    span_name: "api.request.process",
    duration: 150,
    status: "ok",
    attributes: [
      ("service.name", "user.service"),
      ("http.method", "GET"),
      ("http.status_code", "200")
    ]
  }
  
  // éªŒè¯æœ‰æ•ˆæ•°æ®
  let valid_result = QualityValidator::validate(quality_validator, valid_telemetry_data)
  assert_true(valid_result.is_valid)
  assert_eq(valid_result.errors.length(), 0)
  
  // åˆ›å»ºæ— æ•ˆæµ‹è¯•æ•°æ®
  let invalid_telemetry_data = {
    trace_id: "invalid-trace-id",
    span_name: "",  // ç©ºå­—ç¬¦ä¸²
    duration: -50,  // è´Ÿæ•°
    status: "ok",
    attributes: [
      ("service.name", "user.service")
    ]
  }
  
  // éªŒè¯æ— æ•ˆæ•°æ®
  let invalid_result = QualityValidator::validate(quality_validator, invalid_telemetry_data)
  assert_false(invalid_result.is_valid)
  assert_true(invalid_result.errors.length() >= 3)
  
  // æ£€æŸ¥å…·ä½“é”™è¯¯
  let trace_id_error = invalid_result.errors.find(fn(e) { e.field == "trace_id" })
  assert_true(trace_id_error != None)
  
  let span_name_error = invalid_result.errors.find(fn(e) { e.field == "span_name" })
  assert_true(span_name_error != None)
  
  let duration_error = invalid_result.errors.find(fn(e) { e.field == "duration" })
  assert_true(duration_error != None)
  
  // æµ‹è¯•æ‰¹é‡æ•°æ®éªŒè¯
  let batch_data = [valid_telemetry_data, invalid_telemetry_data]
  let batch_results = QualityValidator::validate_batch(quality_validator, batch_data)
  
  assert_eq(batch_results.length(), 2)
  assert_true(batch_results[0].is_valid)
  assert_false(batch_results[1].is_valid)
  
  // è®¡ç®—æ•°æ®è´¨é‡åˆ†æ•°
  let quality_score = QualityValidator::calculate_quality_score(quality_validator, batch_data)
  assert_true(quality_score >= 0.0 and quality_score <= 1.0)
  assert_eq(quality_score, 0.5)  // 50%çš„æ•°æ®æœ‰æ•ˆ
}

// æµ‹è¯•2: æ€§èƒ½åŸºå‡†æµ‹è¯•
test "æ€§èƒ½åŸºå‡†æµ‹è¯•" {
  // åˆ›å»ºæ€§èƒ½åŸºå‡†æµ‹è¯•å™¨
  let benchmark = PerformanceBenchmark::new()
  
  // é…ç½®åŸºå‡†æµ‹è¯•å‚æ•°
  Benchmark::configure(benchmark, {
    warmup_iterations: 100,
    benchmark_iterations: 1000,
    memory_profiling: true,
    cpu_profiling: true
  })
  
  // æµ‹è¯•æ•°æ®åºåˆ—åŒ–æ€§èƒ½
  let test_data = []
  for i in 0..=1000 {
    test_data = test_data.push({
      trace_id: "trace-" + i.to_string(),
      span_id: "span-" + i.to_string(),
      service_name: "service-" + (i % 10).to_string(),
      operation_name: "operation-" + (i % 20).to_string(),
      duration: 50 + (i % 200),
      timestamp: 1640995200 + i,
      attributes: [
        ("http.method", "GET"),
        ("http.status_code", "200"),
        ("user.id", "user-" + (i % 100).to_string())
      ]
    })
  }
  
  // åŸºå‡†æµ‹è¯•ï¼šåºåˆ—åŒ–
  let serialization_result = Benchmark::measure(benchmark, "serialization", fn() {
    TelemetrySerializer::serialize(test_data)
  })
  
  // éªŒè¯åºåˆ—åŒ–æ€§èƒ½
  assert_true(serialization_result.avg_time_ms < 100.0)  // å¹³å‡æ—¶é—´å°äº100ms
  assert_true(serialization_result.max_time_ms < 500.0)  // æœ€å¤§æ—¶é—´å°äº500ms
  assert_true(serialization_result.memory_usage_mb < 50.0)  // å†…å­˜ä½¿ç”¨å°äº50MB
  
  // åŸºå‡†æµ‹è¯•ï¼šååºåˆ—åŒ–
  let serialized_data = TelemetrySerializer::serialize(test_data)
  let deserialization_result = Benchmark::measure(benchmark, "deserialization", fn() {
    TelemetrySerializer::deserialize(serialized_data)
  })
  
  // éªŒè¯ååºåˆ—åŒ–æ€§èƒ½
  assert_true(deserialization_result.avg_time_ms < 150.0)  // å¹³å‡æ—¶é—´å°äº150ms
  assert_true(deserialization_result.max_time_ms < 750.0)  // æœ€å¤§æ—¶é—´å°äº750ms
  assert_true(deserialization_result.memory_usage_mb < 100.0)  // å†…å­˜ä½¿ç”¨å°äº100MB
  
  // åŸºå‡†æµ‹è¯•ï¼šæ•°æ®å‹ç¼©
  let compression_result = Benchmark::measure(benchmark, "compression", fn() {
    CompressionManager::compress(serialized_data, "gzip")
  })
  
  // éªŒè¯å‹ç¼©æ€§èƒ½
  assert_true(compression_result.avg_time_ms < 200.0)  // å¹³å‡æ—¶é—´å°äº200ms
  assert_true(compression_result.compression_ratio > 0.5)  // å‹ç¼©ç‡å¤§äº50%
  
  // åŸºå‡†æµ‹è¯•ï¼šæ•°æ®èšåˆ
  let aggregator = DataAggregator::new()
  DataAggregator::add_aggregation_rule(aggregator, {
    name: "request_rate",
    source_metric: "http.requests.total",
    group_by: ["service.name"],
    aggregation: "sum",
    interval: 60
  })
  
  let aggregation_result = Benchmark::measure(benchmark, "aggregation", fn() {
    DataAggregator::aggregate(aggregator, test_data)
  })
  
  // éªŒè¯èšåˆæ€§èƒ½
  assert_true(aggregation_result.avg_time_ms < 50.0)  // å¹³å‡æ—¶é—´å°äº50ms
  assert_true(aggregation_result.memory_usage_mb < 20.0)  // å†…å­˜ä½¿ç”¨å°äº20MB
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  let performance_report = Benchmark::generate_report(benchmark)
  
  // éªŒè¯æ€§èƒ½æŠ¥å‘Š
  assert_true(performance_report.benchmarks.length() >= 4)
  assert_true(performance_report.summary.avg_time_ms > 0.0)
  assert_true(performance_report.summary.max_memory_usage_mb > 0.0)
}

// æµ‹è¯•3: å¹¶å‘å®‰å…¨æµ‹è¯•
test "å¹¶å‘å®‰å…¨æµ‹è¯•" {
  // åˆ›å»ºå¹¶å‘æµ‹è¯•ç®¡ç†å™¨
  let concurrent_tester = ConcurrentTester::new()
  
  // é…ç½®å¹¶å‘å‚æ•°
  ConcurrentTester::configure(concurrent_tester, {
    thread_count: 10,
    operations_per_thread: 100,
    timeout_seconds: 30
  })
  
  // åˆ›å»ºå…±äº«èµ„æº
  let shared_counter = AtomicCounter::new(0)
  let shared_data_store = ConcurrentDataStore::new()
  
  // å¹¶å‘æµ‹è¯•ï¼šåŸå­è®¡æ•°å™¨
  let counter_tasks = []
  for i in 0..=10 {
    counter_tasks = counter_tasks.push(fn() {
      for j in 0..=100 {
        AtomicCounter::increment(shared_counter)
        if j % 10 == 0 {
          AtomicCounter::decrement(shared_counter)
        }
      }
    })
  }
  
  // æ‰§è¡Œå¹¶å‘è®¡æ•°å™¨æµ‹è¯•
  let counter_result = ConcurrentTester::execute(concurrent_tester, counter_tasks)
  
  // éªŒè¯å¹¶å‘è®¡æ•°å™¨ç»“æœ
  assert_true(counter_result.success)
  assert_eq(counter_result.completed_tasks, 11)
  
  // éªŒè¯è®¡æ•°å™¨æœ€ç»ˆå€¼
  let expected_value = 11 * 100 - 11 * 10  // 1100 - 110 = 990
  let actual_value = AtomicCounter::get_value(shared_counter)
  assert_eq(actual_value, expected_value)
  
  // å¹¶å‘æµ‹è¯•ï¼šæ•°æ®å­˜å‚¨
  let data_store_tasks = []
  for i in 0..=10 {
    let thread_id = i
    data_store_tasks = data_store_tasks.push(fn() {
      for j in 0..=100 {
        let key = "key-" + thread_id.to_string() + "-" + j.to_string()
        let value = "value-" + thread_id.to_string() + "-" + j.to_string()
        ConcurrentDataStore::set(shared_data_store, key, value)
        
        // éšæœºè¯»å–
        if j % 5 == 0 {
          let read_key = "key-" + ((thread_id + 5) % 11).to_string() + "-" + (j / 5).to_string()
          ConcurrentDataStore::get(shared_data_store, read_key)
        }
      }
    })
  }
  
  // æ‰§è¡Œå¹¶å‘æ•°æ®å­˜å‚¨æµ‹è¯•
  let data_store_result = ConcurrentTester::execute(concurrent_tester, data_store_tasks)
  
  // éªŒè¯å¹¶å‘æ•°æ®å­˜å‚¨ç»“æœ
  assert_true(data_store_result.success)
  assert_eq(data_store_result.completed_tasks, 11)
  
  // éªŒè¯æ•°æ®å­˜å‚¨ä¸€è‡´æ€§
  let all_keys = ConcurrentDataStore::get_all_keys(shared_data_store)
  assert_eq(all_keys.length(), 11 * 101)  // æ¯ä¸ªçº¿ç¨‹101ä¸ªé”®
  
  // å¹¶å‘æµ‹è¯•ï¼šé¥æµ‹æ•°æ®å¤„ç†
  let telemetry_processor = ConcurrentTelemetryProcessor::new()
  let processor_tasks = []
  
  for i in 0..=10 {
    let thread_id = i
    processor_tasks = processor_tasks.push(fn() {
      for j in 0..=100 {
        let telemetry_data = {
          trace_id: "trace-" + thread_id.to_string() + "-" + j.to_string(),
          span_id: "span-" + thread_id.to_string() + "-" + j.to_string(),
          service_name: "service-" + thread_id.to_string(),
          operation_name: "operation-" + j.to_string(),
          duration: 50 + j,
          timestamp: 1640995200 + thread_id * 1000 + j
        }
        
        ConcurrentTelemetryProcessor::process(telemetry_processor, telemetry_data)
      }
    })
  }
  
  // æ‰§è¡Œå¹¶å‘é¥æµ‹å¤„ç†æµ‹è¯•
  let processor_result = ConcurrentTester::execute(concurrent_tester, processor_tasks)
  
  // éªŒè¯å¹¶å‘é¥æµ‹å¤„ç†ç»“æœ
  assert_true(processor_result.success)
  assert_eq(processor_result.completed_tasks, 11)
  
  // éªŒè¯å¤„ç†ç»“æœ
  let processed_data = ConcurrentTelemetryProcessor::get_processed_data(telemetry_processor)
  assert_eq(processed_data.length(), 11 * 101)
  
  // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
  let trace_ids = processed_data.map(fn(d) { d.trace_id })
  assert_eq(trace_ids.length(), Set::from_array(trace_ids).size())  // æ‰€æœ‰trace_idå”¯ä¸€
  
  // å¹¶å‘å‹åŠ›æµ‹è¯•
  let stress_test_result = ConcurrentTester::stress_test(concurrent_tester, {
    duration_seconds: 10,
    max_concurrent_operations: 100,
    operation: fn() {
      let key = "stress-" + Random::next().to_string()
      let value = "value-" + Random::next().to_string()
      ConcurrentDataStore::set(shared_data_store, key, value)
      ConcurrentDataStore::get(shared_data_store, key)
    }
  })
  
  // éªŒè¯å‹åŠ›æµ‹è¯•ç»“æœ
  assert_true(stress_test_result.success)
  assert_true(stress_test_result.operations_completed > 0)
  assert_true(stress_test_result.avg_response_time_ms < 100.0)
}

// æµ‹è¯•4: é”™è¯¯æ¢å¤æœºåˆ¶æµ‹è¯•
test "é”™è¯¯æ¢å¤æœºåˆ¶æµ‹è¯•" {
  // åˆ›å»ºé”™è¯¯æ¢å¤ç®¡ç†å™¨
  let recovery_manager = ErrorRecoveryManager::new()
  
  // é…ç½®æ¢å¤ç­–ç•¥
  RecoveryManager::add_strategy(recovery_manager, "network_timeout", {
    name: "exponential_backoff",
    parameters: {
      initial_delay: 1000,      // 1ç§’
      max_delay: 30000,         // 30ç§’
      backoff_factor: 2.0,      // æŒ‡æ•°é€€é¿å› å­
      max_attempts: 5           // æœ€å¤§é‡è¯•æ¬¡æ•°
    }
  })
  
  RecoveryManager::add_strategy(recovery_manager, "database_connection", {
    name: "circuit_breaker",
    parameters: {
      failure_threshold: 5,      // å¤±è´¥é˜ˆå€¼
      recovery_timeout: 60000,   // æ¢å¤è¶…æ—¶
      half_open_max_calls: 3     // åŠå¼€çŠ¶æ€æœ€å¤§è°ƒç”¨æ•°
    }
  })
  
  RecoveryManager::add_strategy(recovery_manager, "memory_pressure", {
    name: "resource_cleanup",
    parameters: {
      cleanup_threshold: 0.8,    // 80%å†…å­˜ä½¿ç”¨ç‡
      cleanup_ratio: 0.3,        // æ¸…ç†30%ç¼“å­˜
      force_gc: true             // å¼ºåˆ¶åƒåœ¾å›æ”¶
    }
  })
  
  // æ¨¡æ‹Ÿç½‘ç»œè¶…æ—¶é”™è¯¯
  let network_error = Error::new("network_timeout", "Connection timeout after 30 seconds")
  
  // åº”ç”¨ç½‘ç»œè¶…æ—¶æ¢å¤ç­–ç•¥
  let network_recovery = RecoveryManager::apply_recovery(recovery_manager, network_error)
  
  // éªŒè¯ç½‘ç»œæ¢å¤ç­–ç•¥
  assert_eq(network_recovery.strategy, "exponential_backoff")
  assert_true(network_recovery.should_retry)
  assert_eq(network_recovery.next_retry_delay_ms, 1000)
  
  // æ¨¡æ‹Ÿå¤šæ¬¡ç½‘ç»œå¤±è´¥
  let mut retry_count = 0
  let mut current_delay = 1000
  let mut should_retry = true
  
  while should_retry and retry_count < 5 {
    retry_count = retry_count + 1
    
    // åº”ç”¨æ¢å¤ç­–ç•¥
    let recovery = RecoveryManager::apply_recovery(recovery_manager, network_error)
    should_retry = recovery.should_retry
    current_delay = recovery.next_retry_delay_ms
    
    // éªŒè¯é€€é¿å»¶è¿Ÿå¢é•¿
    if retry_count > 1 {
      let expected_delay = 1000 * (2.0 ^ (retry_count - 1).to_float())
      assert_true(current_delay >= expected_delay)
    }
  }
  
  // éªŒè¯æœ€å¤§é‡è¯•æ¬¡æ•°
  assert_eq(retry_count, 5)
  assert_false(should_retry)
  
  // æ¨¡æ‹Ÿæ•°æ®åº“è¿æ¥é”™è¯¯
  let db_error = Error::new("database_connection", "Connection pool exhausted")
  
  // åº”ç”¨æ•°æ®åº“è¿æ¥æ¢å¤ç­–ç•¥
  let db_recovery = RecoveryManager::apply_recovery(recovery_manager, db_error)
  
  // éªŒè¯æ•°æ®åº“æ¢å¤ç­–ç•¥
  assert_eq(db_recovery.strategy, "circuit_breaker")
  
  // æ¨¡æ‹Ÿè¿ç»­æ•°æ®åº“è¿æ¥å¤±è´¥
  for i in 0..=6 {
    let circuit_state = RecoveryManager::get_circuit_state(recovery_manager, "database_connection")
    
    if i < 5 {
      assert_eq(circuit_state, "closed")  // å‰5æ¬¡å¤±è´¥ï¼Œç”µè·¯ä»å…³é—­
    } else {
      assert_eq(circuit_state, "open")    // ç¬¬6æ¬¡å¤±è´¥ï¼Œç”µè·¯æ‰“å¼€
    }
    
    RecoveryManager::record_failure(recovery_manager, "database_connection")
  }
  
  // éªŒè¯ç”µè·¯æ‰“å¼€çŠ¶æ€
  let open_circuit_state = RecoveryManager::get_circuit_state(recovery_manager, "database_connection")
  assert_eq(open_circuit_state, "open")
  
  // å°è¯•åœ¨ç”µè·¯æ‰“å¼€çŠ¶æ€ä¸‹æ“ä½œ
  let open_circuit_recovery = RecoveryManager::apply_recovery(recovery_manager, db_error)
  assert_false(open_circuit_recovery.should_retry)
  
  // æ¨¡æ‹Ÿç”µè·¯æ¢å¤
  RecoveryManager::simulate_recovery_timeout(recovery_manager, "database_connection")
  let half_open_state = RecoveryManager::get_circuit_state(recovery_manager, "database_connection")
  assert_eq(half_open_state, "half_open")
  
  // æ¨¡æ‹Ÿå†…å­˜å‹åŠ›é”™è¯¯
  let memory_error = Error::new("memory_pressure", "Memory usage at 85%")
  
  // åº”ç”¨å†…å­˜å‹åŠ›æ¢å¤ç­–ç•¥
  let memory_recovery = RecoveryManager::apply_recovery(recovery_manager, memory_error)
  
  // éªŒè¯å†…å­˜æ¢å¤ç­–ç•¥
  assert_eq(memory_recovery.strategy, "resource_cleanup")
  assert_true(memory_recovery.actions.contains("cache_cleanup"))
  assert_true(memory_recovery.actions.contains("force_gc"))
  
  // éªŒè¯æ¢å¤æ•ˆæœ
  let memory_usage_before = 85.0
  let memory_usage_after = RecoveryManager::simulate_memory_cleanup(recovery_manager, memory_usage_before)
  assert_true(memory_usage_after < memory_usage_before)
  
  // æµ‹è¯•å¤åˆé”™è¯¯æ¢å¤
  let composite_errors = [
    Error::new("network_timeout", "Connection timeout"),
    Error::new("database_connection", "Connection pool exhausted"),
    Error::new("memory_pressure", "Memory usage at 85%")
  ]
  
  let composite_recovery = RecoveryManager::apply_composite_recovery(recovery_manager, composite_errors)
  
  // éªŒè¯å¤åˆæ¢å¤ç­–ç•¥
  assert_eq(composite_recovery.strategies.length(), 3)
  assert_true(composite_recovery.strategies.contains("exponential_backoff"))
  assert_true(composite_recovery.strategies.contains("circuit_breaker"))
  assert_true(composite_recovery.strategies.contains("resource_cleanup"))
  
  // éªŒè¯æ¢å¤ä¼˜å…ˆçº§
  assert_eq(composite_recovery.priority_actions[0], "resource_cleanup")  // å†…å­˜æ¸…ç†ä¼˜å…ˆçº§æœ€é«˜
}

// æµ‹è¯•5: æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–æµ‹è¯•
test "æ•°æ®åºåˆ—åŒ–/ååºåˆ—åŒ–æµ‹è¯•" {
  // åˆ›å»ºåºåˆ—åŒ–ç®¡ç†å™¨
  let serialization_manager = SerializationManager::new()
  
  // æ³¨å†Œåºåˆ—åŒ–æ ¼å¼
  SerializationManager::register_format(serialization_manager, "json", JsonSerializer::new())
  SerializationManager::register_format(serialization_manager, "protobuf", ProtobufSerializer::new())
  SerializationManager::register_format(serialization_manager, "avro", AvroSerializer::new())
  
  // åˆ›å»ºå¤æ‚æµ‹è¯•æ•°æ®
  let complex_telemetry_data = {
    trace_context: {
      trace_id: "a1b2c3d4e5f6789012345678901234ab",
      span_id: "c1d2e3f4g5h67890",
      trace_flags: 1,
      trace_state: "key1=value1,key2=value2"
    },
    spans: [
      {
        span_id: "c1d2e3f4g5h67890",
        parent_span_id: "a1b2c3d4e5f67890",
        name: "http.request",
        kind: "server",
        start_time: 1640995200000000000,  // çº³ç§’æ—¶é—´æˆ³
        end_time: 1640995200100000000,
        status: {
          code: "ok",
          message: "Success"
        },
        attributes: [
          ("service.name", "api.gateway"),
          ("http.method", "POST"),
          ("http.url", "/api/v1/process"),
          ("http.status_code", "200"),
          ("user.id", "12345"),
          ("request.id", "req-67890")
        ],
        events: [
          {
            name: "database.query",
            timestamp: 1640995200050000000,
            attributes: [
              ("db.statement", "SELECT * FROM users WHERE id = ?"),
              ("db.type", "postgresql"),
              ("db.duration_ms", "25")
            ]
          }
        ],
        links: [
          {
            trace_id: "b2c3d4e5f6g789012345678901234abcd",
            span_id: "d2e3f4g5h6i78901",
            attributes: [
              ("link.type", "follows_from")
            ]
          }
        ]
      }
    ],
    resource: {
      attributes: [
        ("service.name", "api.gateway"),
        ("service.version", "1.2.3"),
        ("host.name", "api-server-01"),
        ("host.ip", "192.168.1.100"),
        ("process.id", "12345"),
        ("process.executable.name", "api-server"),
        ("process.executable.path", "/usr/local/bin/api-server"),
        ("process.command_args", ["--config", "/etc/api-server/config.yaml"]),
        ("process.runtime.name", "nodejs"),
        ("process.runtime.version", "18.17.0"),
        ("process.runtime.description", "Node.js JavaScript Runtime"),
        ("telemetry.sdk.name", "opentelemetry"),
        ("telemetry.sdk.language", "javascript"),
        ("telemetry.sdk.version", "1.21.0")
      ]
    }
  }
  
  // æµ‹è¯•JSONåºåˆ—åŒ–
  let json_serialized = SerializationManager::serialize(serialization_manager, complex_telemetry_data, "json")
  
  // éªŒè¯JSONåºåˆ—åŒ–ç»“æœ
  assert_true(json_serialized.length() > 0)
  assert_true(json_serialized.contains("\"trace_id\":\"a1b2c3d4e5f6789012345678901234ab\""))
  assert_true(json_serialized.contains("\"service.name\":\"api.gateway\""))
  
  // æµ‹è¯•JSONååºåˆ—åŒ–
  let json_deserialized = SerializationManager::deserialize(serialization_manager, json_serialized, "json")
  
  // éªŒè¯JSONååºåˆ—åŒ–ç»“æœ
  assert_eq(json_deserialized.trace_context.trace_id, complex_telemetry_data.trace_context.trace_id)
  assert_eq(json_deserialized.spans.length(), complex_telemetry_data.spans.length())
  assert_eq(json_deserialized.spans[0].name, "http.request")
  assert_eq(json_deserialized.resource.attributes.get("service.name"), Some(StringValue("api.gateway")))
  
  // æµ‹è¯•Protobufåºåˆ—åŒ–
  let protobuf_serialized = SerializationManager::serialize(serialization_manager, complex_telemetry_data, "protobuf")
  
  // éªŒè¯Protobufåºåˆ—åŒ–ç»“æœ
  assert_true(protobuf_serialized.length() > 0)
  
  // æµ‹è¯•Protobufååºåˆ—åŒ–
  let protobuf_deserialized = SerializationManager::deserialize(serialization_manager, protobuf_serialized, "protobuf")
  
  // éªŒè¯Protobufååºåˆ—åŒ–ç»“æœ
  assert_eq(protobuf_deserialized.trace_context.trace_id, complex_telemetry_data.trace_context.trace_id)
  assert_eq(protobuf_deserialized.spans.length(), complex_telemetry_data.spans.length())
  
  // æµ‹è¯•Avroåºåˆ—åŒ–
  let avro_serialized = SerializationManager::serialize(serialization_manager, complex_telemetry_data, "avro")
  
  // éªŒè¯Avroåºåˆ—åŒ–ç»“æœ
  assert_true(avro_serialized.length() > 0)
  
  // æµ‹è¯•Avroååºåˆ—åŒ–
  let avro_deserialized = SerializationManager::deserialize(serialization_manager, avro_serialized, "avro")
  
  // éªŒè¯Avroååºåˆ—åŒ–ç»“æœ
  assert_eq(avro_deserialized.trace_context.trace_id, complex_telemetry_data.trace_context.trace_id)
  assert_eq(avro_deserialized.spans.length(), complex_telemetry_data.spans.length())
  
  // æ¯”è¾ƒåºåˆ—åŒ–æ ¼å¼æ€§èƒ½
  let formats = ["json", "protobuf", "avro"]
  let format_performance = []
  
  for format in formats {
    let start_time = Time::now()
    
    // åºåˆ—åŒ–æ€§èƒ½æµ‹è¯•
    for i in 0..=100 {
      SerializationManager::serialize(serialization_manager, complex_telemetry_data, format)
    }
    
    let serialize_time = Time::now() - start_time
    
    // ååºåˆ—åŒ–æ€§èƒ½æµ‹è¯•
    let serialized_data = SerializationManager::serialize(serialization_manager, complex_telemetry_data, format)
    let deserialize_start = Time::now()
    
    for i in 0..=100 {
      SerializationManager::deserialize(serialization_manager, serialized_data, format)
    }
    
    let deserialize_time = Time::now() - deserialize_start
    
    format_performance = format_performance.push({
      format: format,
      serialize_time_ms: serialize_time,
      deserialize_time_ms: deserialize_time,
      serialized_size: serialized_data.length()
    })
  }
  
  // éªŒè¯æ€§èƒ½æ¯”è¾ƒ
  let json_perf = format_performance.find(fn(p) { p.format == "json" })
  let protobuf_perf = format_performance.find(fn(p) { p.format == "protobuf" })
  let avro_perf = format_performance.find(fn(p) { p.format == "avro" })
  
  // Protobufåº”è¯¥æ¯”JSONæ›´ç´§å‡‘
  match (json_perf, protobuf_perf) {
    (Some(json), Some(protobuf)) => {
      assert_true(protobuf.serialized_size < json.serialized_size)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åºåˆ—åŒ–é”™è¯¯å¤„ç†
  let invalid_data = {
    trace_context: {
      trace_id: "",  // æ— æ•ˆçš„ç©ºtrace_id
      span_id: "valid-span-id",
      trace_flags: 1,
      trace_state: ""
    },
    spans: [],
    resource: {
      attributes: []
    }
  }
  
  // éªŒè¯åºåˆ—åŒ–é”™è¯¯å¤„ç†
  let error_result = SerializationManager::serialize_with_validation(serialization_manager, invalid_data, "json")
  assert_false(error_result.success)
  assert_true(error_result.error_message.contains("trace_id"))
  
  // æµ‹è¯•ç‰ˆæœ¬å…¼å®¹æ€§
  let versioned_serializer = VersionedSerializer::new()
  VersionedSerializer::register_schema(versioned_serializer, "1.0", legacy_schema)
  VersionedSerializer::register_schema(versioned_serializer, "2.0", current_schema)
  
  // ä½¿ç”¨å½“å‰ç‰ˆæœ¬åºåˆ—åŒ–
  let current_serialized = VersionedSerializer::serialize(versioned_serializer, complex_telemetry_data, "2.0")
  
  // ä½¿ç”¨æ—§ç‰ˆæœ¬ååºåˆ—åŒ–ï¼ˆå…¼å®¹æ€§æµ‹è¯•ï¼‰
  let compat_result = VersionedSerializer::deserialize_with_compatibility(versioned_serializer, current_serialized, "1.0")
  assert_true(compat_result.success)
  assert_true(compat_result.warnings.length() > 0)  // åº”è¯¥æœ‰å…¼å®¹æ€§è­¦å‘Š
}

// æµ‹è¯•6: èµ„æºç®¡ç†æµ‹è¯•
test "èµ„æºç®¡ç†æµ‹è¯•" {
  // åˆ›å»ºèµ„æºç®¡ç†å™¨
  let resource_manager = ResourceManager::new()
  
  // é…ç½®èµ„æºé™åˆ¶
  ResourceManager::set_limits(resource_manager, {
    max_memory_mb: 512,
    max_cpu_percent: 80.0,
    max_file_descriptors: 1000,
    max_network_connections: 100,
    max_disk_usage_mb: 1024
  })
  
  // åˆ›å»ºèµ„æºç›‘æ§å™¨
  let monitor = ResourceMonitor::new()
  ResourceMonitor::start_monitoring(monitor, {
    sampling_interval_ms: 100,
    alert_threshold: 0.8
  })
  
  // æ¨¡æ‹Ÿèµ„æºä½¿ç”¨
  let initial_resources = ResourceMonitor::get_current_usage(monitor)
  
  // æµ‹è¯•å†…å­˜ç®¡ç†
  let memory_allocator = MemoryAllocator::new()
  MemoryAllocator::set_limit(memory_allocator, 100 * 1024 * 1024)  // 100MBé™åˆ¶
  
  // åˆ†é…å†…å­˜å—
  let memory_blocks = []
  let mut total_allocated = 0
  
  for i in 0..=10 {
    let block_size = 10 * 1024 * 1024  // 10MBå—
    let block = MemoryAllocator::allocate(memory_allocator, block_size)
    
    if block != None {
      memory_blocks = memory_blocks.push(block)
      total_allocated = total_allocated + block_size
    }
  }
  
  // éªŒè¯å†…å­˜åˆ†é…
  assert_true(total_allocated <= 100 * 1024 * 1024)  // ä¸è¶…è¿‡é™åˆ¶
  assert_true(memory_blocks.length() <= 10)
  
  // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
  let memory_usage = ResourceMonitor::get_memory_usage(monitor)
  assert_true(memory_usage.used_mb > initial_resources.memory_mb)
  assert_true(memory_usage.used_mb <= initial_resources.memory_mb + 100)
  
  // é‡Šæ”¾éƒ¨åˆ†å†…å­˜
  for i in 0..=5 {
    if i < memory_blocks.length() {
      MemoryAllocator::deallocate(memory_allocator, memory_blocks[i])
    }
  }
  
  // æ£€æŸ¥å†…å­˜é‡Šæ”¾åçš„çŠ¶æ€
  let memory_after_release = ResourceMonitor::get_memory_usage(monitor)
  assert_true(memory_after_release.used_mb < memory_usage.used_mb)
  
  // æµ‹è¯•CPUç®¡ç†
  let cpu_intensive_task = CPUTask::new()
  CPUTask::configure(cpu_intensive_task, {
    duration_ms: 1000,
    intensity: 0.7,  // 70% CPUä½¿ç”¨ç‡
    cores: 2
  })
  
  // æ‰§è¡ŒCPUå¯†é›†å‹ä»»åŠ¡
  let cpu_start_time = Time::now()
  CPUTask::execute(cpu_intensive_task)
  let cpu_duration = Time::now() - cpu_start_time
  
  // éªŒè¯CPUä»»åŠ¡æ‰§è¡Œ
  assert_true(cpu_duration >= 1000)
  
  // æ£€æŸ¥CPUä½¿ç”¨æƒ…å†µ
  let cpu_usage = ResourceMonitor::get_cpu_usage(monitor)
  assert_true(cpu_usage.average_percent > initial_resources.cpu_percent)
  
  // æµ‹è¯•æ–‡ä»¶æè¿°ç¬¦ç®¡ç†
  let file_manager = FileManager::new()
  FileManager::set_limit(file_manager, 100)
  
  // æ‰“å¼€å¤šä¸ªæ–‡ä»¶
  let open_files = []
  for i in 0..=50 {
    let file = FileManager::open(file_manager, "test-file-" + i.to_string() + ".tmp")
    if file != None {
      open_files = open_files.push(file)
    }
  }
  
  // éªŒè¯æ–‡ä»¶æè¿°ç¬¦ç®¡ç†
  assert_true(open_files.length() <= 100)
  
  // æ£€æŸ¥æ–‡ä»¶æè¿°ç¬¦ä½¿ç”¨æƒ…å†µ
  let fd_usage = ResourceMonitor::get_file_descriptor_usage(monitor)
  assert_true(fd_usage.used_count > initial_resources.file_descriptors)
  assert_true(fd_usage.used_count <= initial_resources.file_descriptors + 50)
  
  // å…³é—­æ‰€æœ‰æ–‡ä»¶
  for file in open_files {
    FileManager::close(file_manager, file)
  }
  
  // æ£€æŸ¥æ–‡ä»¶æè¿°ç¬¦é‡Šæ”¾åçš„çŠ¶æ€
  let fd_after_close = ResourceMonitor::get_file_descriptor_usage(monitor)
  assert_true(fd_after_close.used_count < fd_usage.used_count)
  
  // æµ‹è¯•ç½‘ç»œè¿æ¥ç®¡ç†
  let connection_pool = ConnectionPool::new()
  ConnectionPool::configure(connection_pool, {
    max_connections: 50,
    connection_timeout_ms: 5000,
    idle_timeout_ms: 30000
  })
  
  // åˆ›å»ºå¤šä¸ªè¿æ¥
  let connections = []
  for i in 0..=25 {
    let connection = ConnectionPool::create_connection(connection_pool, "endpoint-" + i.to_string())
    if connection != None {
      connections = connections.push(connection)
    }
  }
  
  // éªŒè¯è¿æ¥æ± ç®¡ç†
  assert_true(connections.length() <= 50)
  
  // æ£€æŸ¥ç½‘ç»œè¿æ¥ä½¿ç”¨æƒ…å†µ
  let network_usage = ResourceMonitor::get_network_usage(monitor)
  assert_true(network_usage.active_connections > 0)
  assert_true(network_usage.active_connections <= 50)
  
  // é‡Šæ”¾éƒ¨åˆ†è¿æ¥
  for i in 0..=12 {
    if i < connections.length() {
      ConnectionPool::release_connection(connection_pool, connections[i])
    }
  }
  
  // æ£€æŸ¥è¿æ¥é‡Šæ”¾åçš„çŠ¶æ€
  let network_after_release = ResourceMonitor::get_network_usage(monitor)
  assert_true(network_after_release.active_connections < network_usage.active_connections)
  
  // æµ‹è¯•ç£ç›˜ä½¿ç”¨ç®¡ç†
  let disk_manager = DiskManager::new()
  DiskManager::set_quota(disk_manager, 500 * 1024 * 1024)  // 500MBé…é¢
  
  // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
  let temp_files = []
  let mut total_disk_usage = 0
  
  for i in 0..=5 {
    let file_size = 50 * 1024 * 1024  // 50MBæ–‡ä»¶
    let file = DiskManager::create_file(disk_manager, "temp-" + i.to_string() + ".dat", file_size)
    
    if file != None {
      temp_files = temp_files.push(file)
      total_disk_usage = total_disk_usage + file_size
    }
  }
  
  // éªŒè¯ç£ç›˜ä½¿ç”¨ç®¡ç†
  assert_true(total_disk_usage <= 500 * 1024 * 1024)
  assert_true(temp_files.length() <= 10)
  
  // æ£€æŸ¥ç£ç›˜ä½¿ç”¨æƒ…å†µ
  let disk_usage = ResourceMonitor::get_disk_usage(monitor)
  assert_true(disk_usage.used_mb > initial_resources.disk_mb)
  assert_true(disk_usage.used_mb <= initial_resources.disk_mb + 300)
  
  // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
  for file in temp_files {
    DiskManager::delete_file(disk_manager, file)
  }
  
  // æ£€æŸ¥ç£ç›˜æ¸…ç†åçš„çŠ¶æ€
  let disk_after_cleanup = ResourceMonitor::get_disk_usage(monitor)
  assert_true(disk_after_cleanup.used_mb < disk_usage.used_mb)
  
  // æµ‹è¯•èµ„æºæ³„æ¼æ£€æµ‹
  let leak_detector = ResourceLeakDetector::new()
  LeakDetector::start_tracking(leak_detector)
  
  // æ¨¡æ‹Ÿèµ„æºæ³„æ¼
  let leaked_memory = MemoryAllocator::allocate(memory_allocator, 5 * 1024 * 1024)
  let leaked_file = FileManager::open(file_manager, "leaked-file.tmp")
  
  // ä¸é‡Šæ”¾èµ„æºï¼Œæ•…æ„æ³„æ¼
  // MemoryAllocator::deallocate(memory_allocator, leaked_memory)  // æ³¨é‡Šæ‰
  // FileManager::close(file_manager, leaked_file)  // æ³¨é‡Šæ‰
  
  // æ£€æµ‹èµ„æºæ³„æ¼
  let leak_report = LeakDetector::detect_leaks(leak_detector)
  
  // éªŒè¯æ³„æ¼æ£€æµ‹
  assert_true(leak_report.memory_leaks > 0)
  assert_true(leak_report.file_descriptor_leaks > 0)
  
  // ç”Ÿæˆèµ„æºä½¿ç”¨æŠ¥å‘Š
  let resource_report = ResourceManager::generate_report(resource_manager)
  
  // éªŒè¯èµ„æºæŠ¥å‘Š
  assert_true(resource_report.memory_usage.used_mb > 0)
  assert_true(resource_report.cpu_usage.average_percent > 0)
  assert_true(resource_report.file_descriptors.used_count > 0)
  assert_true(resource_report.network_connections.active_connections > 0)
  assert_true(resource_report.disk_usage.used_mb > 0)
  assert_true(resource_report.leaks_detected > 0)
}

// æµ‹è¯•7: è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯•
test "è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯•" {
  // åˆ›å»ºå¹³å°å…¼å®¹æ€§æµ‹è¯•å™¨
  let compatibility_tester = PlatformCompatibilityTester::new()
  
  // è·å–å½“å‰å¹³å°ä¿¡æ¯
  let current_platform = PlatformCompatibilityTester::get_current_platform(compatibility_tester)
  
  // éªŒè¯å¹³å°ä¿¡æ¯
  assert_true(current_platform.os_name.length() > 0)
  assert_true(current_platform.architecture.length() > 0)
  assert_true(current_platform.version.length() > 0)
  
  // æµ‹è¯•æ–‡ä»¶è·¯å¾„å…¼å®¹æ€§
  let path_tester = PathCompatibilityTester::new()
  
  // æµ‹è¯•ä¸åŒå¹³å°çš„è·¯å¾„æ ¼å¼
  let unix_path = "/var/log/telemetry/app.log"
  let windows_path = "C:\\ProgramData\\Telemetry\\app.log"
  let macos_path = "/Users/Shared/Telemetry/app.log"
  
  // æ ‡å‡†åŒ–è·¯å¾„
  let normalized_unix = PathCompatibilityTester::normalize(path_tester, unix_path)
  let normalized_windows = PathCompatibilityTester::normalize(path_tester, windows_path)
  let normalized_macos = PathCompatibilityTester::normalize(path_tester, macos_path)
  
  // éªŒè¯è·¯å¾„æ ‡å‡†åŒ–
  assert_true(normalized_unix.length() > 0)
  assert_true(normalized_windows.length() > 0)
  assert_true(normalized_macos.length() > 0)
  
  // æµ‹è¯•è·¯å¾„åˆ†éš”ç¬¦å…¼å®¹æ€§
  let separator = PathCompatibilityTester::get_separator(path_tester)
  let expected_separator = if current_platform.os_name == "windows" { "\\" } else { "/" }
  assert_eq(separator, expected_separator)
  
  // æµ‹è¯•è·¯å¾„æ‹¼æ¥
  let base_path = "/var/log"
  let relative_path = "telemetry/app.log"
  let joined_path = PathCompatibilityTester::join(path_tester, base_path, relative_path)
  
  // éªŒè¯è·¯å¾„æ‹¼æ¥
  assert_true(joined_path.contains(base_path))
  assert_true(joined_path.contains(relative_path))
  
  // æµ‹è¯•æ—¶åŒºå…¼å®¹æ€§
  let timezone_tester = TimezoneCompatibilityTester::new()
  
  // è·å–å½“å‰æ—¶åŒº
  let current_timezone = TimezoneCompatibilityTester::get_current_timezone(timezone_tester)
  assert_true(current_timezone.length() > 0)
  
  // æµ‹è¯•æ—¶åŒºè½¬æ¢
  let utc_time = 1640995200  // UTCæ—¶é—´æˆ³
  let local_time = TimezoneCompatibilityTester::utc_to_local(timezone_tester, utc_time)
  let back_to_utc = TimezoneCompatibilityTester::local_to_utc(timezone_tester, local_time)
  
  // éªŒè¯æ—¶åŒºè½¬æ¢
  assert_eq(back_to_utc, utc_time)
  
  // æµ‹è¯•ä¸åŒæ—¶åŒºçš„æ—¶é—´è½¬æ¢
  let timezones = ["UTC", "America/New_York", "Europe/London", "Asia/Tokyo"]
  let converted_times = []
  
  for tz in timezones {
    let converted_time = TimezoneCompatibilityTester::convert_timezone(timezone_tester, utc_time, "UTC", tz)
    converted_times = converted_times.push((tz, converted_time))
  }
  
  // éªŒè¯æ—¶åŒºè½¬æ¢ç»“æœ
  assert_eq(converted_times.length(), 4)
  
  // æµ‹è¯•å­—ç¬¦ç¼–ç å…¼å®¹æ€§
  let encoding_tester = EncodingCompatibilityTester::new()
  
  // æµ‹è¯•ä¸åŒç¼–ç çš„å­—ç¬¦ä¸²
  let test_strings = [
    "Hello World",           // ASCII
    "ä½ å¥½ä¸–ç•Œ",               // UTF-8ä¸­æ–‡
    "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€",            // UTF-8ä¿„æ–‡
    "ğŸš€ğŸŒğŸ“Š",                // Emoji
    "CafÃ© rÃ©sumÃ© naÃ¯ve"      // å¸¦é‡éŸ³ç¬¦å·
  ]
  
  for str in test_strings {
    // æµ‹è¯•UTF-8ç¼–ç 
    let utf8_encoded = EncodingCompatibilityTester::encode(encoding_tester, str, "UTF-8")
    let utf8_decoded = EncodingCompatibilityTester::decode(encoding_tester, utf8_encoded, "UTF-8")
    assert_eq(utf8_decoded, str)
    
    // æµ‹è¯•Latin-1ç¼–ç ï¼ˆå¯èƒ½ä¸æ”¯æŒæ‰€æœ‰å­—ç¬¦ï¼‰
    let latin1_encoded = EncodingCompatibilityTester::encode(encoding_tester, str, "Latin-1")
    if latin1_encoded != None {
      let latin1_decoded = EncodingCompatibilityTester::decode(encoding_tester, latin1_encoded, "Latin-1")
      // Latin-1å¯èƒ½ä¸æ”¯æŒæ‰€æœ‰å­—ç¬¦ï¼Œæ‰€ä»¥åªéªŒè¯è§£ç ä¸å‡ºé”™
      assert_true(latin1_decoded.length() > 0)
    }
  }
  
  // æµ‹è¯•ç½‘ç»œå…¼å®¹æ€§
  let network_tester = NetworkCompatibilityTester::new()
  
  // æµ‹è¯•IPv4å’ŒIPv6å…¼å®¹æ€§
  let ipv4_address = "192.168.1.100"
  let ipv6_address = "2001:db8::1"
  let hostname = "telemetry.example.com"
  
  // è§£æåœ°å€
  let ipv4_resolved = NetworkCompatibilityTester::resolve(network_tester, ipv4_address)
  let ipv6_resolved = NetworkCompatibilityTester::resolve(network_tester, ipv6_address)
  let hostname_resolved = NetworkCompatibilityTester::resolve(network_tester, hostname)
  
  // éªŒè¯åœ°å€è§£æ
  assert_true(ipv4_resolved.length() > 0)
  assert_true(ipv6_resolved.length() > 0)
  assert_true(hostname_resolved.length() > 0)
  
  // æµ‹è¯•ç«¯å£å·å…¼å®¹æ€§
  let common_ports = [80, 443, 8080, 8443, 9090]
  for port in common_ports {
    let is_available = NetworkCompatibilityTester::is_port_available(network_tester, port)
    // ç«¯å£å¯èƒ½è¢«å ç”¨ï¼Œæ‰€ä»¥åªéªŒè¯å‡½æ•°ä¸æŠ›å‡ºå¼‚å¸¸
    assert_true(is_available == true or is_available == false)
  }
  
  // æµ‹è¯•ç³»ç»Ÿè°ƒç”¨å…¼å®¹æ€§
  let syscall_tester = SyscallCompatibilityTester::new()
  
  // æµ‹è¯•æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
  let temp_dir = SyscallCompatibilityTester::get_temp_dir(syscall_tester)
  assert_true(temp_dir.length() > 0)
  
  // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
  let temp_file = temp_dir + "/compatibility-test.tmp"
  let file_created = SyscallCompatibilityTester::create_file(syscall_tester, temp_file)
  assert_true(file_created)
  
  // å†™å…¥æ–‡ä»¶
  let content = "Compatibility test content"
  let write_success = SyscallCompatibilityTester::write_file(syscall_tester, temp_file, content)
  assert_true(write_success)
  
  // è¯»å–æ–‡ä»¶
  let read_content = SyscallCompatibilityTester::read_file(syscall_tester, temp_file)
  assert_eq(read_content, content)
  
  // åˆ é™¤æ–‡ä»¶
  let file_deleted = SyscallCompatibilityTester::delete_file(syscall_tester, temp_file)
  assert_true(file_deleted)
  
  // æµ‹è¯•ç¯å¢ƒå˜é‡å…¼å®¹æ€§
  let env_tester = EnvironmentCompatibilityTester::new()
  
  // è®¾ç½®ç¯å¢ƒå˜é‡
  EnvironmentCompatibilityTester::set_env(env_tester, "AZIMUTH_TEST", "compatibility")
  
  // è·å–ç¯å¢ƒå˜é‡
  let env_value = EnvironmentCompatibilityTester::get_env(env_tester, "AZIMUTH_TEST")
  assert_eq(env_value, Some("compatibility"))
  
  // åˆ é™¤ç¯å¢ƒå˜é‡
  EnvironmentCompatibilityTester::unset_env(env_tester, "AZIMUTH_TEST")
  let env_value_after = EnvironmentCompatibilityTester::get_env(env_tester, "AZIMUTH_TEST")
  assert_eq(env_value_after, None)
  
  // ç”Ÿæˆå…¼å®¹æ€§æŠ¥å‘Š
  let compatibility_report = PlatformCompatibilityTester::generate_report(compatibility_tester)
  
  // éªŒè¯å…¼å®¹æ€§æŠ¥å‘Š
  assert_true(compatibility_report.platform_info.os_name.length() > 0)
  assert_true(compatibility_report.path_compatibility.is_supported)
  assert_true(compatibility_report.timezone_compatibility.is_supported)
  assert_true(compatibility_report.encoding_compatibility.utf8_supported)
  assert_true(compatibility_report.network_compatibility.ipv4_supported or compatibility_report.network_compatibility.ipv6_supported)
  assert_true(compatibility_report.system_compatibility.file_operations_supported)
  assert_true(compatibility_report.environment_compatibility.variables_supported)
}

// æµ‹è¯•8: å®‰å…¨æ€§æµ‹è¯•
test "å®‰å…¨æ€§æµ‹è¯•" {
  // åˆ›å»ºå®‰å…¨æµ‹è¯•å™¨
  let security_tester = SecurityTester::new()
  
  // é…ç½®å®‰å…¨ç­–ç•¥
  SecurityTester::configure_policy(security_tester, {
    max_trace_id_length: 64,
    max_attribute_key_length: 255,
    max_attribute_value_length: 4096,
    allowed_attribute_keys: ["service.name", "http.method", "http.status_code", "user.id"],
    blocked_patterns: ["password", "secret", "token", "key"]
  })
  
  // æµ‹è¯•è¾“å…¥éªŒè¯
  let valid_trace_id = "a1b2c3d4e5f6789012345678901234ab"
  let invalid_trace_id_too_long = "a" * 65  // è¶…è¿‡æœ€å¤§é•¿åº¦
  let invalid_trace_id_injection = "trace-123'; DROP TABLE traces; --"
  
  // éªŒè¯æœ‰æ•ˆtrace_id
  let valid_result = SecurityTester::validate_trace_id(security_tester, valid_trace_id)
  assert_true(valid_result.is_valid)
  
  // éªŒè¯æ— æ•ˆtrace_idï¼ˆè¿‡é•¿ï¼‰
  let invalid_length_result = SecurityTester::validate_trace_id(security_tester, invalid_trace_id_too_long)
  assert_false(invalid_length_result.is_valid)
  assert_true(invalid_length_result.error_message.contains("length"))
  
  // éªŒè¯æ— æ•ˆtrace_idï¼ˆSQLæ³¨å…¥ï¼‰
  let injection_result = SecurityTester::validate_trace_id(security_tester, invalid_trace_id_injection)
  assert_false(injection_result.is_valid)
  assert_true(injection_result.error_message.contains("invalid characters"))
  
  // æµ‹è¯•å±æ€§å®‰å…¨éªŒè¯
  let safe_attributes = [
    ("service.name", "user.service"),
    ("http.method", "GET"),
    ("http.status_code", "200"),
    ("user.id", "12345")
  ]
  
  let unsafe_attributes = [
    ("service.name", "user.service"),
    ("password", "secret123"),  // æ•æ„Ÿä¿¡æ¯
    ("http.method", "GET"),
    ("api.token", "abc123xyz")  // æ•æ„Ÿä¿¡æ¯
  ]
  
  // éªŒè¯å®‰å…¨å±æ€§
  let safe_result = SecurityTester::validate_attributes(security_tester, safe_attributes)
  assert_true(safe_result.is_valid)
  
  // éªŒè¯ä¸å®‰å…¨å±æ€§
  let unsafe_result = SecurityTester::validate_attributes(security_tester, unsafe_attributes)
  assert_false(unsafe_result.is_valid)
  assert_true(unsafe_result.blocked_attributes.length() >= 2)
  assert_true(unsafe_result.blocked_attributes.contains("password"))
  assert_true(unsafe_result.blocked_attributes.contains("api.token"))
  
  // æµ‹è¯•æ•°æ®è„±æ•
  let data_sanitizer = DataSanitizer::new()
  DataSanitizer::add_sensitive_pattern(data_sanitizer, "password")
  DataSanitizer::add_sensitive_pattern(data_sanitizer, "token")
  DataSanitizer::add_sensitive_pattern(data_sanitizer, "secret")
  
  let sensitive_data = {
    service_name: "auth.service",
    user_id: "12345",
    password: "user123password",
    api_token: "sk-1234567890abcdef",
    session_id: "sess_abc123"
  }
  
  // è„±æ•å¤„ç†
  let sanitized_data = DataSanitizer::sanitize(data_sanitizer, sensitive_data)
  
  // éªŒè¯è„±æ•ç»“æœ
  assert_eq(sanitized_data.service_name, "auth.service")  // éæ•æ„Ÿæ•°æ®ä¸å˜
  assert_eq(sanitized_data.user_id, "12345")              // éæ•æ„Ÿæ•°æ®ä¸å˜
  assert_eq(sanitized_data.password, "***")               // æ•æ„Ÿæ•°æ®è¢«è„±æ•
  assert_eq(sanitized_data.api_token, "***")              // æ•æ„Ÿæ•°æ®è¢«è„±æ•
  assert_eq(sanitized_data.session_id, "sess_abc123")     // éæ•æ„Ÿæ•°æ®ä¸å˜
  
  // æµ‹è¯•åŠ å¯†/è§£å¯†
  let encryption_manager = EncryptionManager::new()
  EncryptionManager::configure(encryption_manager, {
    algorithm: "AES-256-GCM",
    key_derivation: "PBKDF2",
    iterations: 100000
  })
  
  // ç”ŸæˆåŠ å¯†å¯†é’¥
  let encryption_key = EncryptionManager::generate_key(encryption_manager, "test-password")
  assert_true(encryption_key.length() > 0)
  
  // åŠ å¯†æ•°æ®
  let plaintext = "Sensitive telemetry data"
  let encrypted_data = EncryptionManager::encrypt(encryption_manager, plaintext, encryption_key)
  
  // éªŒè¯åŠ å¯†ç»“æœ
  assert_true(encrypted_data.length() > 0)
  assert_false(encrypted_data.contains(plaintext))  // ç¡®ä¿æ•°æ®å·²åŠ å¯†
  
  // è§£å¯†æ•°æ®
  let decrypted_data = EncryptionManager::decrypt(encryption_manager, encrypted_data, encryption_key)
  assert_eq(decrypted_data, plaintext)
  
  // æµ‹è¯•é”™è¯¯å¯†é’¥è§£å¯†
  let wrong_key = EncryptionManager::generate_key(encryption_manager, "wrong-password")
  let failed_decrypt = EncryptionManager::decrypt(encryption_manager, encrypted_data, wrong_key)
  assert_eq(failed_decrypt, None)
  
  // æµ‹è¯•è®¿é—®æ§åˆ¶
  let access_controller = AccessController::new()
  
  // å®šä¹‰è§’è‰²å’Œæƒé™
  AccessController::define_role(access_controller, "admin", [
    "telemetry.read",
    "telemetry.write",
    "telemetry.delete",
    "system.config"
  ])
  
  AccessController::define_role(access_controller, "analyst", [
    "telemetry.read",
    "telemetry.export"
  ])
  
  AccessController::define_role(access_controller, "viewer", [
    "telemetry.read"
  ])
  
  // åˆ›å»ºç”¨æˆ·
  AccessController::create_user(access_controller, "alice", ["admin"])
  AccessController::create_user(access_controller, "bob", ["analyst"])
  AccessController::create_user(access_controller, "charlie", ["viewer"])
  
  // æµ‹è¯•æƒé™æ£€æŸ¥
  let alice_can_delete = AccessController::check_permission(access_controller, "alice", "telemetry.delete")
  assert_true(alice_can_delete)
  
  let bob_can_delete = AccessController::check_permission(access_controller, "bob", "telemetry.delete")
  assert_false(bob_can_delete)
  
  let charlie_can_read = AccessController::check_permission(access_controller, "charlie", "telemetry.read")
  assert_true(charlie_can_read)
  
  // æµ‹è¯•èµ„æºè®¿é—®æ§åˆ¶
  let protected_resource = "trace-data-12345"
  
  // æµ‹è¯•ç®¡ç†å‘˜è®¿é—®
  let admin_access = AccessController::check_resource_access(access_controller, "alice", protected_resource, "read")
  assert_true(admin_access)
  
  // æµ‹è¯•åˆ†æå¸ˆè®¿é—®
  let analyst_access = AccessController::check_resource_access(access_controller, "bob", protected_resource, "read")
  assert_true(analyst_access)
  
  // æµ‹è¯•è®¿å®¢è®¿é—®
  let viewer_access = AccessController::check_resource_access(access_controller, "charlie", protected_resource, "read")
  assert_true(viewer_access)
  
  // æµ‹è¯•è®¿å®¢å†™å…¥æƒé™
  let viewer_write = AccessController::check_resource_access(access_controller, "charlie", protected_resource, "write")
  assert_false(viewer_write)
  
  // æµ‹è¯•å®¡è®¡æ—¥å¿—
  let audit_logger = AuditLogger::new()
  AuditLogger::configure(audit_logger, {
    log_file: "/var/log/azimuth/audit.log",
    rotation_policy: "daily",
    retention_days: 30
  })
  
  // è®°å½•å®¡è®¡äº‹ä»¶
  AuditLogger::log_access(audit_logger, {
    user: "alice",
    action: "read",
    resource: protected_resource,
    result: "success",
    timestamp: Time::now(),
    ip_address: "192.168.1.100"
  })
  
  AuditLogger::log_access(audit_logger, {
    user: "charlie",
    action: "write",
    resource: protected_resource,
    result: "denied",
    timestamp: Time::now(),
    ip_address: "192.168.1.101"
  })
  
  // æŸ¥è¯¢å®¡è®¡æ—¥å¿—
  let audit_logs = AuditLogger::query_logs(audit_logger, {
    start_time: Time::now() - 3600,  // æœ€è¿‘1å°æ—¶
    end_time: Time::now(),
    user: Some("alice")
  })
  
  // éªŒè¯å®¡è®¡æ—¥å¿—
  assert_true(audit_logs.length() >= 1)
  
  let alice_log = audit_logs.find(fn(log) { log.user == "alice" })
  assert_true(alice_log != None)
  
  match alice_log {
    Some(log) => {
      assert_eq(log.action, "read")
      assert_eq(log.resource, protected_resource)
      assert_eq(log.result, "success")
    }
    None => assert_true(false)
  }
  
  // æµ‹è¯•å®‰å…¨æ‰«æ
  let security_scanner = SecurityScanner::new()
  SecurityScanner::add_vulnerability_check(security_scanner, "weak_encryption", {
    description: "æ£€æµ‹å¼±åŠ å¯†ç®—æ³•",
    check_function: fn(data) { data.contains("DES") or data.contains("RC4") }
  })
  
  SecurityScanner::add_vulnerability_check(security_scanner, "exposed_credentials", {
    description: "æ£€æµ‹æš´éœ²çš„å‡­æ®",
    check_function: fn(data) { 
      data.contains("password=") or data.contains("secret=") or data.contains("token=")
    }
  })
  
  // æ‰«æå®‰å…¨æ¼æ´
  let scan_data = "Using DES encryption for password=secret123"
  let vulnerabilities = SecurityScanner::scan(security_scanner, scan_data)
  
  // éªŒè¯æ¼æ´æ‰«æç»“æœ
  assert_true(vulnerabilities.length() >= 2)
  
  let weak_encryption_found = vulnerabilities.any(fn(v) { v.type == "weak_encryption" })
  assert_true(weak_encryption_found)
  
  let exposed_credentials_found = vulnerabilities.any(fn(v) { v.type == "exposed_credentials" })
  assert_true(exposed_credentials_found)
  
  // ç”Ÿæˆå®‰å…¨æŠ¥å‘Š
  let security_report = SecurityTester::generate_report(security_tester)
  
  // éªŒè¯å®‰å…¨æŠ¥å‘Š
  assert_true(security_report.input_validation.enabled)
  assert_true(security_report.data_sanitization.enabled)
  assert_true(security_report.encryption.enabled)
  assert_true(security_report.access_control.enabled)
  assert_true(security_report.audit_logging.enabled)
  assert_true(security_report.vulnerability_scanning.enabled)
  assert_true(security_report.vulnerabilities_found > 0)
}