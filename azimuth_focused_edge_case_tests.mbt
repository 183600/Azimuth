// Azimuth Focused Edge Case Tests
// ä¸“æ³¨äºè¾¹ç•Œæƒ…å†µå’Œç‰¹æ®Šåœºæ™¯çš„æµ‹è¯•ç”¨ä¾‹

// æµ‹è¯•1: ç©ºå±æ€§å’Œç©ºå€¼çš„å¤„ç†
pub test "ç©ºå±æ€§å’Œç©ºå€¼å¤„ç†æµ‹è¯•" {
  let empty_attrs : Array[(String, azimuth::AttributeValue)] = []
  let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), empty_attrs)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å±æ€§
  let empty_string_attrs = [
    ("empty.string", azimuth::StringValue("")),
    ("normal.string", azimuth::StringValue("normal"))
  ]
  let resource_with_empty = azimuth::Resource::with_attributes(resource, empty_string_attrs)
  
  let empty_value = azimuth::Resource::get_attribute(resource_with_empty, "empty.string")
  match empty_value {
    None => assert_true(false)
    Some(azimuth::StringValue(value)) => assert_true(value.length() == 0)
    _ => assert_true(false)
  }
}

// æµ‹è¯•2: æé•¿å­—ç¬¦ä¸²å±æ€§çš„å¤„ç†
pub test "æé•¿å­—ç¬¦ä¸²å±æ€§å¤„ç†æµ‹è¯•" {
  let long_string = "a" * 10000
  let long_attrs = [
    ("long.attribute", azimuth::StringValue(long_string))
  ]
  let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), long_attrs)
  
  let retrieved = azimuth::Resource::get_attribute(resource, "long.attribute")
  match retrieved {
    None => assert_true(false)
    Some(azimuth::StringValue(value)) => assert_true(value.length() == 10000)
    _ => assert_true(false)
  }
}

// æµ‹è¯•3: ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeå±æ€§å¤„ç†
pub test "ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeå±æ€§å¤„ç†æµ‹è¯•" {
  let special_attrs = [
    ("unicode.æµ‹è¯•", azimuth::StringValue("æµ‹è¯•å†…å®¹")),
    ("special.chars", azimuth::StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?")),
    ("newline.test", azimuth::StringValue("line1\nline2\rline3")),
    ("emoji.test", azimuth::StringValue("ğŸš€ğŸ“ŠğŸ“ˆğŸ“‰"))
  ]
  let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), special_attrs)
  
  let unicode_value = azimuth::Resource::get_attribute(resource, "unicode.æµ‹è¯•")
  match unicode_value {
    None => assert_true(false)
    Some(azimuth::StringValue(value)) => assert_true(value == "æµ‹è¯•å†…å®¹")
    _ => assert_true(false)
  }
}

// æµ‹è¯•4: æ•°å€¼è¾¹ç•Œæƒ…å†µå¤„ç†
pub test "æ•°å€¼è¾¹ç•Œæƒ…å†µå¤„ç†æµ‹è¯•" {
  let boundary_attrs = [
    ("max.int", azimuth::IntValue(2147483647)),
    ("min.int", azimuth::IntValue(-2147483648)),
    ("zero.int", azimuth::IntValue(0)),
    ("max.float", azimuth::FloatValue(1.7976931348623157e+308)),
    ("min.float", azimuth::FloatValue(2.2250738585072014e-308)),
    ("zero.float", azimuth::FloatValue(0.0)),
    ("negative.float", azimuth::FloatValue(-1.23456789))
  ]
  let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), boundary_attrs)
  
  let max_int = azimuth::Resource::get_attribute(resource, "max.int")
  match max_int {
    None => assert_true(false)
    Some(azimuth::IntValue(value)) => assert_true(value == 2147483647)
    _ => assert_true(false)
  }
}

// æµ‹è¯•5: å¤§é‡å±æ€§çš„æ€§èƒ½æµ‹è¯•
pub test "å¤§é‡å±æ€§æ€§èƒ½æµ‹è¯•" {
  let many_attrs = []
  for i in 0..1000 {
    many_attrs.push(("attr." + i.to_string(), azimuth::StringValue("value." + i.to_string())))
  }
  
  let start_time = azimuth::current_timestamp()
  let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), many_attrs)
  let end_time = azimuth::current_timestamp()
  
  // éªŒè¯å¤„ç†æ—¶é—´åœ¨åˆç†èŒƒå›´å†…ï¼ˆè¿™é‡Œç®€å•éªŒè¯ä¸ä¸ºç©ºï¼‰
  assert_true(end_time > start_time)
  
  // éªŒè¯å±æ€§æ•°é‡
  let first_attr = azimuth::Resource::get_attribute(resource, "attr.0")
  let last_attr = azimuth::Resource::get_attribute(resource, "attr.999")
  
  match (first_attr, last_attr) {
    (Some(azimuth::StringValue(first)), Some(azimuth::StringValue(last))) => {
      assert_true(first == "value.0")
      assert_true(last == "value.999")
    }
    _ => assert_true(false)
  }
}

// æµ‹è¯•6: ä¸Šä¸‹æ–‡ä¼ æ’­çš„è¾¹ç•Œæƒ…å†µ
pub test "ä¸Šä¸‹æ–‡ä¼ æ’­è¾¹ç•Œæƒ…å†µæµ‹è¯•" {
  let empty_context = azimuth::Context::new()
  let propagator = azimuth::W3CTraceContextPropagator::new()
  let carrier = azimuth::TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡çš„æ³¨å…¥
  azimuth::W3CTraceContextPropagator::inject(propagator, empty_context, carrier)
  
  // æµ‹è¯•ä»ç©ºè½½ä½“æå–
  let extracted_context = azimuth::W3CTraceContextPropagator::extract(propagator, carrier)
  
  // éªŒè¯ç©ºä¸Šä¸‹æ–‡å¤„ç†
  assert_true(true)  // ç®€åŒ–å®ç°ï¼Œå®é™…åº”éªŒè¯å…·ä½“è¡Œä¸º
}

// æµ‹è¯•7: SpanåµŒå¥—å±‚çº§æ·±åº¦æµ‹è¯•
pub test "SpanåµŒå¥—å±‚çº§æ·±åº¦æµ‹è¯•" {
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "nested-test")
  let spans = []
  
  // åˆ›å»ºæ·±å±‚åµŒå¥—çš„Span
  let root_span = azimuth::Tracer::start_span(tracer, "root")
  spans.push(root_span)
  
  for level in 0..50 {
    let parent_span = spans[level]
    let child_span = azimuth::Tracer::start_span(tracer, "level-" + level.to_string())
    spans.push(child_span)
    
    // è®¾ç½®çˆ¶å­å…³ç³»
    azimuth::Span::set_parent(child_span, parent_span)
  }
  
  // éªŒè¯æ‰€æœ‰Spanéƒ½è¢«åˆ›å»º
  assert_true(spans.length() == 51)
  
  // ç»“æŸæ‰€æœ‰Span
  for span in spans {
    azimuth::Span::end(span)
  }
}

// æµ‹è¯•8: æ•°ç»„å±æ€§çš„ç‰¹æ®Šæƒ…å†µ
pub test "æ•°ç»„å±æ€§ç‰¹æ®Šæƒ…å†µæµ‹è¯•" {
  let array_attrs = [
    ("empty.string.array", azimuth::ArrayStringValue([])),
    ("single.string.array", azimuth::ArrayStringValue(["single"])),
    ("large.string.array", azimuth::ArrayStringValue(["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"])),
    ("empty.int.array", azimuth::ArrayIntValue([])),
    ("single.int.array", azimuth::ArrayIntValue([42])),
    ("large.int.array", azimuth::ArrayIntValue([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
  ]
  let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), array_attrs)
  
  let empty_array = azimuth::Resource::get_attribute(resource, "empty.string.array")
  match empty_array {
    None => assert_true(false)
    Some(azimuth::ArrayStringValue(values)) => assert_true(values.length() == 0)
    _ => assert_true(false)
  }
  
  let single_array = azimuth::Resource::get_attribute(resource, "single.string.array")
  match single_array {
    None => assert_true(false)
    Some(azimuth::ArrayStringValue(values)) => {
      assert_true(values.length() == 1)
      assert_true(values[0] == "single")
    }
    _ => assert_true(false)
  }
}

// æµ‹è¯•9: å¹¶å‘èµ„æºåˆå¹¶æµ‹è¯•
pub test "å¹¶å‘èµ„æºåˆå¹¶æµ‹è¯•" {
  let base_resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("base.attr", azimuth::StringValue("base.value"))
  ])
  
  let resources = []
  for i in 0..20 {
    let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
      ("attr." + i.to_string(), azimuth::StringValue("value." + i.to_string()))
    ])
    resources.push(resource)
  }
  
  // å¹¶å‘åˆå¹¶èµ„æº
  let merged_resource = base_resource
  for resource in resources {
    merged_resource = azimuth::Resource::merge(merged_resource, resource)
  }
  
  // éªŒè¯åˆå¹¶ç»“æœ
  let base_attr = azimuth::Resource::get_attribute(merged_resource, "base.attr")
  match base_attr {
    None => assert_true(false)
    Some(azimuth::StringValue(value)) => assert_true(value == "base.value")
    _ => assert_true(false)
  }
}

// æµ‹è¯•10: é”™è¯¯æ¢å¤å’Œå¼‚å¸¸å¤„ç†
pub test "é”™è¯¯æ¢å¤å’Œå¼‚å¸¸å¤„ç†æµ‹è¯•" {
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "error-test")
  
  // æµ‹è¯•åœ¨Spanæ“ä½œä¸­çš„é”™è¯¯å¤„ç†
  let span = azimuth::Tracer::start_span(tracer, "error-test-span")
  
  // å°è¯•è®¾ç½®æ— æ•ˆå±æ€§ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
  azimuth::Span::set_attribute(span, "invalid.key", azimuth::StringValue("invalid.value"))
  
  // éªŒè¯Spanä»ç„¶å¯ç”¨
  azimuth::Span::add_event(span, "recovery-event", None)
  azimuth::Span::set_status(span, azimuth::Ok)
  azimuth::Span::end(span)
  
  // ç®€åŒ–éªŒè¯ï¼Œå®é™…åº”æ£€æŸ¥é”™è¯¯å¤„ç†æœºåˆ¶
  assert_true(true)
}