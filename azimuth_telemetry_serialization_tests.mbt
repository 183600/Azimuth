// é¥æµ‹æ•°æ®åºåˆ—åŒ–æµ‹è¯•
// æµ‹è¯•Azimuthé¥æµ‹æ•°æ®çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–åŠŸèƒ½

test "spanåºåˆ—åŒ–åˆ°JSONæ ¼å¼" {
  // åˆ›å»ºæµ‹è¯•span
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "serialization.test")
  
  let span = Tracer::start_span(tracer, "serialization.test.operation")
  
  // è®¾ç½®spanå±æ€§
  Span::set_attribute(span, "http.method", "GET")
  Span::set_attribute(span, "http.url", "https://api.example.com/users")
  Span::set_attribute(span, "http.status_code", 200)
  Span::set_attribute(span, "user.id", "user-12345")
  
  // æ·»åŠ äº‹ä»¶
  Span::add_event(span, "http.request.started", [
    ("timestamp", "2025-01-02T10:00:00Z"),
    ("request.size", "1024")
  ])
  
  Span::add_event(span, "http.response.completed", [
    ("timestamp", "2025-01-02T10:00:05Z"),
    ("response.size", "2048"),
    ("duration", "5000")
  ])
  
  // åºåˆ—åŒ–spanåˆ°JSON
  let serialized = SpanSerializer::to_json(span)
  
  // éªŒè¯JSONåŒ…å«å¿…è¦å­—æ®µ
  assert_true(serialized.contains("\"name\":\"serialization.test.operation\""))
  assert_true(serialized.contains("\"http.method\":\"GET\""))
  assert_true(serialized.contains("\"http.url\":\"https://api.example.com/users\""))
  assert_true(serialized.contains("\"http.status_code\":200"))
  assert_true(serialized.contains("\"user.id\":\"user-12345\""))
  assert_true(serialized.contains("\"http.request.started\""))
  assert_true(serialized.contains("\"http.response.completed\""))
  
  Span::end(span)
}

test "åº¦é‡æ•°æ®åºåˆ—åŒ–åˆ°äºŒè¿›åˆ¶æ ¼å¼" {
  // åˆ›å»ºæµ‹è¯•åº¦é‡
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "metrics.serialization.test")
  
  // åˆ›å»ºè®¡æ•°å™¨
  let counter = Meter::create_counter(meter, "requests.total", Some("Total requests"), Some("count"))
  
  // æ·»åŠ åº¦é‡æ•°æ®
  Counter::add_with_attributes(counter, 1.0, [
    ("method", "GET"),
    ("endpoint", "/api/users"),
    ("status", "200")
  ])
  
  Counter::add_with_attributes(counter, 1.0, [
    ("method", "POST"),
    ("endpoint", "/api/orders"),
    ("status", "201")
  ])
  
  // åˆ›å»ºç›´æ–¹å›¾
  let histogram = Meter::create_histogram(meter, "response.time", Some("Response time"), Some("ms"))
  
  Histogram::record_with_attributes(histogram, 123.5, [
    ("endpoint", "/api/users"),
    ("method", "GET")
  ])
  
  Histogram::record_with_attributes(histogram, 456.7, [
    ("endpoint", "/api/orders"),
    ("method", "POST")
  ])
  
  // åºåˆ—åŒ–åˆ°äºŒè¿›åˆ¶æ ¼å¼
  let binary_data = MetricsSerializer::to_binary(counter, histogram)
  
  // éªŒè¯äºŒè¿›åˆ¶æ•°æ®ä¸ä¸ºç©º
  assert_true(binary_data.length() > 0)
  
  // ååºåˆ—åŒ–å¹¶éªŒè¯
  let deserialized_metrics = MetricsSerializer::from_binary(binary_data)
  assert_true(deserialized_metrics.is_valid())
  
  // éªŒè¯ååºåˆ—åŒ–çš„æ•°æ®
  let counter_data = deserialized_metrics.get_counter("requests.total")
  assert_true(counter_data.is_some())
  
  let histogram_data = deserialized_metrics.get_histogram("response.time")
  assert_true(histogram_data.is_some())
}

test "æ—¥å¿—è®°å½•åºåˆ—åŒ–åˆ°ç»“æ„åŒ–æ ¼å¼" {
  // åˆ›å»ºæµ‹è¯•æ—¥å¿—
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "log.serialization.test")
  
  // åˆ›å»ºä¸åŒçº§åˆ«çš„æ—¥å¿—è®°å½•
  let info_log = LogRecord::new(Info, "User login successful")
  LogRecord::add_attribute(info_log, "user.id", "user-12345")
  LogRecord::add_attribute(info_log, "ip.address", "192.168.1.100")
  LogRecord::add_attribute(info_log, "user.agent", "Mozilla/5.0")
  LogRecord::add_attribute(info_log, "session.id", "sess-abcdef")
  
  let warn_log = LogRecord::new(Warn, "Rate limit approaching")
  LogRecord::add_attribute(warn_log, "current.rate", "95")
  LogRecord::add_attribute(warn_log, "limit", "100")
  LogRecord::add_attribute(warn_log, "window", "1m")
  LogRecord::add_attribute(warn_log, "client.id", "client-67890")
  
  let error_log = LogRecord::new(Error, "Database connection failed")
  LogRecord::add_attribute(error_log, "error.code", "DB_CONN_ERROR")
  LogRecord::add_attribute(error_log, "retry.attempt", "3")
  LogRecord::add_attribute(error_log, "max.retries", "5")
  LogRecord::add_attribute(error_log, "connection.pool", "primary")
  
  // åºåˆ—åŒ–æ—¥å¿—åˆ°ç»“æ„åŒ–æ ¼å¼
  let structured_logs = LogSerializer::to_structured([info_log, warn_log, error_log])
  
  // éªŒè¯ç»“æ„åŒ–æ—¥å¿—
  assert_eq(structured_logs.length(), 3)
  
  let info_serialized = structured_logs.get(0)
  assert_true(info_serialized.contains("\"severity\":\"INFO\""))
  assert_true(info_serialized.contains("\"message\":\"User login successful\""))
  assert_true(info_serialized.contains("\"user.id\":\"user-12345\""))
  
  let warn_serialized = structured_logs.get(1)
  assert_true(warn_serialized.contains("\"severity\":\"WARN\""))
  assert_true(warn_serialized.contains("\"message\":\"Rate limit approaching\""))
  assert_true(warn_serialized.contains("\"current.rate\":\"95\""))
  
  let error_serialized = structured_logs.get(2)
  assert_true(error_serialized.contains("\"severity\":\"ERROR\""))
  assert_true(error_serialized.contains("\"message\":\"Database connection failed\""))
  assert_true(error_serialized.contains("\"error.code\":\"DB_CONN_ERROR\""))
}

test "æ‰¹é‡é¥æµ‹æ•°æ®åºåˆ—åŒ–" {
  // åˆ›å»ºå¤šä¸ªspanç”¨äºæ‰¹é‡æµ‹è¯•
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "batch.serialization.test")
  
  let spans = []
  for i in 1..=5 {
    let span = Tracer::start_span(tracer, "batch.operation." + i.to_string())
    Span::set_attribute(span, "batch.id", "batch-123")
    Span::set_attribute(span, "operation.index", i)
    Span::set_attribute(span, "operation.type", "batch.process")
    
    spans = spans.push(span)
  }
  
  // åˆ›å»ºå¤šä¸ªåº¦é‡
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "batch.metrics.test")
  
  let batch_counter = Meter::create_counter(meter, "batch.operations", Some("Batch operations"), Some("count"))
  for i in 1..=5 {
    Counter::add_with_attributes(batch_counter, 1.0, [
      ("batch.id", "batch-123"),
      "operation.index", i,
      ("operation.status", "completed")
    ])
  }
  
  // æ‰¹é‡åºåˆ—åŒ–
  let batch_serializer = BatchSerializer::new()
  let serialized_data = batch_serializer.serialize_spans(spans)
  let serialized_metrics = batch_serializer.serialize_metrics(batch_counter)
  
  // éªŒè¯æ‰¹é‡åºåˆ—åŒ–ç»“æœ
  assert_true(serialized_data.contains("\"batch.id\":\"batch-123\""))
  assert_true(serialized_data.contains("\"operation.type\":\"batch.process\""))
  
  // éªŒè¯å‹ç¼©åŠŸèƒ½
  let compressed_data = batch_serializer.compress(serialized_data)
  assert_true(compressed_data.length() < serialized_data.length())
  
  // éªŒè¯è§£å‹ç¼©åŠŸèƒ½
  let decompressed_data = batch_serializer.decompress(compressed_data)
  assert_eq(decompressed_data, serialized_data)
  
  // ç»“æŸæ‰€æœ‰spans
  for span in spans {
    Span::end(span)
  }
}

test "åºåˆ—åŒ–é”™è¯¯å¤„ç†å’Œæ¢å¤" {
  // æµ‹è¯•åºåˆ—åŒ–è¿‡ç¨‹ä¸­çš„é”™è¯¯å¤„ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.serialization.test")
  
  let span = Tracer::start_span(tracer, "error.test.operation")
  
  // æ·»åŠ å¯èƒ½å¯¼è‡´åºåˆ—åŒ–é—®é¢˜çš„ç‰¹æ®Šå­—ç¬¦
  Span::set_attribute(span, "special.chars", "ç‰¹æ®Šå­—ç¬¦: \"quotes\", 'apostrophes', \n\t\r")
  Span::set_attribute(span, "unicode.chars", "ğŸš€ emoji and Ã¼Ã±Ã­Ã§Ã¸dÃ©")
  Span::set_attribute(span, "null.value", "")
  Span::set_attribute(span, "large.data", "x" * 10000)  // å¤§æ•°æ®
  
  // æµ‹è¯•åºåˆ—åŒ–é”™è¯¯å¤„ç†
  match SpanSerializer::to_json_safe(span) {
    Ok(serialized) => {
      // éªŒè¯ç‰¹æ®Šå­—ç¬¦è¢«æ­£ç¡®å¤„ç†
      assert_true(serialized.contains("ç‰¹æ®Šå­—ç¬¦"))
      assert_true(serialized.contains("ğŸš€"))
      assert_true(serialized.contains("Ã¼Ã±Ã­Ã§Ã¸dÃ©"))
    }
    Err(error) => {
      // å¦‚æœåºåˆ—åŒ–å¤±è´¥ï¼ŒéªŒè¯é”™è¯¯ä¿¡æ¯
      assert_true(error.contains("serialization") || error.contains("encoding"))
    }
  }
  
  // æµ‹è¯•æŸåæ•°æ®çš„ååºåˆ—åŒ–
  let corrupted_data = "{\"invalid\": json data"
  match SpanSerializer::from_json(corrupted_data) {
    Ok(_) => assert_true(false)  // ä¸åº”è¯¥æˆåŠŸ
    Err(error) => assert_true(error.contains("parse") || error.contains("invalid"))
  }
  
  // æµ‹è¯•ç©ºæ•°æ®å¤„ç†
  let empty_data = ""
  match SpanSerializer::from_json(empty_data) {
    Ok(_) => assert_true(false)  // ä¸åº”è¯¥æˆåŠŸ
    Err(error) => assert_true(error.contains("empty") || error.contains("parse"))
  }
  
  Span::end(span)
}

test "è·¨æ ¼å¼åºåˆ—åŒ–å…¼å®¹æ€§" {
  // æµ‹è¯•ä¸åŒåºåˆ—åŒ–æ ¼å¼ä¹‹é—´çš„å…¼å®¹æ€§
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "compatibility.test")
  
  let span = Tracer::start_span(tracer, "compatibility.test.operation")
  
  // è®¾ç½®æµ‹è¯•å±æ€§
  Span::set_attribute(span, "service.name", "test-service")
  Span::set_attribute(span, "service.version", "1.0.0")
  Span::set_attribute(span, "environment", "test")
  Span::set_attribute(span, "trace.id", "trace-123456")
  Span::set_attribute(span, "span.id", "span-789012")
  
  // åºåˆ—åŒ–åˆ°JSON
  let json_data = SpanSerializer::to_json(span)
  
  // ä»JSONè½¬æ¢ä¸ºå…¶ä»–æ ¼å¼
  let xml_data = FormatConverter::json_to_xml(json_data)
  let yaml_data = FormatConverter::json_to_yaml(json_data)
  let protobuf_data = FormatConverter::json_to_protobuf(json_data)
  
  // éªŒè¯æ ¼å¼è½¬æ¢
  assert_true(xml_data.contains("<service.name>test-service</service.name>"))
  assert_true(yaml_data.contains("service.name: test-service"))
  assert_true(protobuf_data.length() > 0)
  
  // éªŒè¯å¾€è¿”è½¬æ¢çš„ä¸€è‡´æ€§
  let json_from_xml = FormatConverter::xml_to_json(xml_data)
  let json_from_yaml = FormatConverter::yaml_to_json(yaml_data)
  let json_from_protobuf = FormatConverter::protobuf_to_json(protobuf_data)
  
  // éªŒè¯å…³é”®æ•°æ®åœ¨æ‰€æœ‰æ ¼å¼ä¸­éƒ½ä¿æŒä¸€è‡´
  assert_true(json_from_xml.contains("test-service"))
  assert_true(json_from_yaml.contains("test-service"))
  assert_true(json_from_protobuf.contains("test-service"))
  
  Span::end(span)
}