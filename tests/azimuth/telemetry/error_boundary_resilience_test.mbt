// é”™è¯¯è¾¹ç•Œå’Œå¼‚å¸¸å¤„ç†æµ‹è¯•
// Error boundary and exception handling tests

test "Spanæ“ä½œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•Spanæ“ä½œä¸­çš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•æ— æ•ˆSpanContextçš„å¤„ç†
  let invalid_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(invalid_ctx))
  
  // ä½¿ç”¨æ— æ•ˆä¸Šä¸‹æ–‡åˆ›å»ºSpan
  let invalid_span = Span::new("invalid-span", Server, invalid_ctx)
  assert_eq(Span::name(invalid_span), "invalid-span")
  assert_eq(Span::kind(invalid_span), Server)
  
  // æµ‹è¯•å¯¹æ— æ•ˆSpançš„æ“ä½œ
  Span::set_status(invalid_span, Error, Some("æ— æ•ˆä¸Šä¸‹æ–‡çš„Span"))
  Span::add_event(invalid_span, "é”™è¯¯äº‹ä»¶", Some([
    ("error.type", StringValue("invalid_context")),
    ("error.severity", StringValue("warning"))
  ]))
  Span::end(invalid_span)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²Spançš„å¤„ç†
  let empty_name_span = Span::new("", Internal, invalid_ctx)
  assert_eq(Span::name(empty_name_span), "")
  
  // æµ‹è¯•è¶…é•¿Spanåç§°çš„å¤„ç†
  let long_name = "a".repeat(1000)
  let long_name_span = Span::new(long_name, Client, invalid_ctx)
  assert_eq(Span::name(long_name_span), long_name)
}

test "å±æ€§æ“ä½œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•å±æ€§æ“ä½œä¸­çš„é”™è¯¯å¤„ç†
  
  let attrs = Attributes::new()
  
  // æµ‹è¯•è®¾ç½®ç©ºé”®å±æ€§
  Attributes::set(attrs, "", StringValue("empty key value"))
  let empty_key_result = Attributes::get(attrs, "")
  // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒç©ºé”®
  
  // æµ‹è¯•è®¾ç½®nullå€¼å±æ€§ï¼ˆè¿™é‡Œç”¨Noneè¡¨ç¤ºï¼‰
  // Attributes::set(attrs, "null.key", null) // MoonBitä¸­æ²¡æœ‰nullï¼Œä½¿ç”¨Option
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å±æ€§
  let nonexistent_result = Attributes::get(attrs, "definitely.nonexistent.key.12345")
  assert_eq(nonexistent_result, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®çš„å¤„ç†
  let special_keys = [
    "key.with.dots",
    "key-with-dashes",
    "key_with_underscores",
    "key/with/slashes",
    "key\\with\\backslashes",
    "key with spaces",
    "key@with@symbols",
    "é”®å€¼å¯¹ä¸­æ–‡",
    "ĞºĞ»ÑÑ‡.Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ",
    "clÃ©.valeur"
  ]
  
  for i = 0; i < special_keys.length(); i = i + 1 {
    let key = special_keys[i]
    let value = StringValue("value for " + key)
    Attributes::set(attrs, key, value)
    
    let retrieved = Attributes::get(attrs, key)
    // ç®€åŒ–å®ç°å¯èƒ½åªæ”¯æŒç‰¹å®šé”®
  }
  
  // æµ‹è¯•æå€¼å±æ€§
  Attributes::set(attrs, "max.int", IntValue(2147483647))
  Attributes::set(attrs, "min.int", IntValue(-2147483648))
  Attributes::set(attrs, "max.float", FloatValue(1.7976931348623157e+308))
  Attributes::set(attrs, "min.float", FloatValue(-1.7976931348623157e+308))
  Attributes::set(attrs, "infinity", FloatValue(1.0/0.0))
  Attributes::set(attrs, "neg.infinity", FloatValue(-1.0/0.0))
  Attributes::set(attrs, "nan", FloatValue(0.0/0.0))
}

test "Contextæ“ä½œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•Contextæ“ä½œä¸­çš„é”™è¯¯å¤„ç†
  
  let root_ctx = Context::root()
  
  // æµ‹è¯•ç©ºé”®ContextKey
  let empty_key = ContextKey::new("")
  let ctx_with_empty = Context::with_value(root_ctx, empty_key, "empty key value")
  let empty_result = Context::get(ctx_with_empty, empty_key)
  
  // æµ‹è¯•ç©ºå€¼Context
  let ctx_with_empty_value = Context::with_value(root_ctx, ContextKey::new("test"), "")
  let empty_value_result = Context::get(ctx_with_empty_value, ContextKey::new("test"))
  assert_eq(empty_value_result, Some(""))
  
  // æµ‹è¯•è¶…é•¿Contextå€¼
  let long_value = "x".repeat(10000)
  let ctx_with_long = Context::with_value(root_ctx, ContextKey::new("long"), long_value)
  let long_result = Context::get(ctx_with_long, ContextKey::new("long"))
  assert_eq(long_result, Some(long_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Contextå€¼
  let special_values = [
    "value\nwith\nnewlines",
    "value\twith\ttabs",
    "value\rwith\rcarriage",
    "value\"with\"quotes",
    "value'with'apostrophes",
    "value\\with\\backslashes",
    "å€¼åŒ…å«ä¸­æ–‡",
    "Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼",
    "valeur en franÃ§ais",
    "ğŸš€ emoji value ğŸŒŸ"
  ]
  
  for i = 0; i < special_values.length(); i = i + 1 {
    let value = special_values[i]
    let key = ContextKey::new("special." + i.to_string())
    let ctx = Context::with_value(root_ctx, key, value)
    let result = Context::get(ctx, key)
    assert_eq(result, Some(value))
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„Contextå€¼
  let nonexistent_ctx = Context::get(root_ctx, ContextKey::new("nonexistent.key"))
  assert_eq(nonexistent_ctx, None)
}

test "æ—¥å¿—è®°å½•é”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•æ—¥å¿—è®°å½•ä¸­çš„é”™è¯¯å¤„ç†
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "error-test-logger")
  
  // æµ‹è¯•ç©ºæ¶ˆæ¯æ—¥å¿—
  let empty_log = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_log), Some(""))
  Logger::emit(logger, empty_log)
  
  // æµ‹è¯•è¶…é•¿æ—¥å¿—æ¶ˆæ¯
  let long_message = "x".repeat(100000)
  let long_log = LogRecord::new(Error, long_message)
  assert_eq(LogRecord::body(long_log), Some(long_message))
  Logger::emit(logger, long_log)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ—¥å¿—æ¶ˆæ¯
  let special_messages = [
    "Message with\nnewlines\nand\ttabs",
    "Message with \"quotes\" and 'apostrophes'",
    "Message with \\backslashes\\",
    "ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯",
    "Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼",
    "Message en franÃ§ais",
    "ğŸš¨ Alert emoji ğŸš¨",
    "Message with null\0character"
  ]
  
  for i = 0; i < special_messages.length(); i = i + 1 {
    let message = special_messages[i]
    let log = LogRecord::new(Warn, message)
    assert_eq(LogRecord::body(log), Some(message))
    Logger::emit(logger, log)
  }
  
  // æµ‹è¯•æç«¯æ—¶é—´æˆ³
  let min_timestamp = -9223372036854775808L
  let max_timestamp = 9223372036854775807L
  let zero_timestamp = 0L
  
  let min_log = LogRecord::new_with_context(
    Debug,
    Some("Min timestamp"),
    None,
    Some(min_timestamp),
    None,
    None,
    None,
    None
  )
  
  let max_log = LogRecord::new_with_context(
    Debug,
    Some("Max timestamp"),
    None,
    Some(max_timestamp),
    None,
    None,
    None,
    None
  )
  
  let zero_log = LogRecord::new_with_context(
    Debug,
    Some("Zero timestamp"),
    None,
    Some(zero_timestamp),
    None,
    None,
    None,
    None
  )
  
  Logger::emit(logger, min_log)
  Logger::emit(logger, max_log)
  Logger::emit(logger, zero_log)
  
  // æµ‹è¯•æ— æ•ˆtrace_idå’Œspan_id
  let invalid_trace_log = LogRecord::new_with_context(
    Error,
    Some("Invalid trace"),
    None,
    None,
    None,
    Some(""),
    Some(""),
    None
  )
  
  Logger::emit(logger, invalid_trace_log)
}

test "æŒ‡æ ‡æ“ä½œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•æŒ‡æ ‡æ“ä½œä¸­çš„é”™è¯¯å¤„ç†
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "error-test-meter")
  
  // æµ‹è¯•ç©ºåç§°æŒ‡æ ‡
  let empty_counter = Meter::create_counter(meter, "")
  let empty_histogram = Meter::create_histogram(meter, "")
  
  assert_eq(empty_counter.name, "")
  assert_eq(empty_histogram.name, "")
  
  // æµ‹è¯•è¶…é•¿åç§°æŒ‡æ ‡
  let long_name = "metric".repeat(100)
  let long_counter = Meter::create_counter(meter, long_name)
  let long_histogram = Meter::create_histogram(meter, long_name)
  
  assert_eq(long_counter.name, long_name)
  assert_eq(long_histogram.name, long_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æŒ‡æ ‡åç§°
  let special_names = [
    "metric.with.dots",
    "metric-with-dashes",
    "metric_with_underscores",
    "metric/with/slashes",
    "æŒ‡æ ‡ä¸­æ–‡",
    "Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ°.Ñ€Ñƒ",
    "mÃ©trique.fr",
    "metric@with@symbols",
    "metric with spaces"
  ]
  
  for i = 0; i < special_names.length(); i = i + 1 {
    let name = special_names[i]
    let counter = Meter::create_counter(meter, name)
    let histogram = Meter::create_histogram(meter, name)
    
    assert_eq(counter.name, name)
    assert_eq(histogram.name, name)
    
    // æµ‹è¯•è®°å½•å€¼
    Counter::add(counter, 1.0)
    Histogram::record(histogram, 100.0)
  }
  
  // æµ‹è¯•æå€¼æŒ‡æ ‡è®°å½•
  let test_counter = Meter::create_counter(meter, "extreme.counter")
  let test_histogram = Meter::create_histogram(meter, "extreme.histogram")
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(test_counter, 1.7976931348623157e+308)
  Histogram::record(test_histogram, 1.7976931348623157e+308)
  
  // æµ‹è¯•æå°å€¼
  Counter::add(test_counter, -1.7976931348623157e+308)
  Histogram::record(test_histogram, -1.7976931348623157e+308)
  
  // æµ‹è¯•æ— ç©·å€¼
  Counter::add(test_counter, 1.0/0.0)
  Histogram::record(test_histogram, 1.0/0.0)
  
  Counter::add(test_counter, -1.0/0.0)
  Histogram::record(test_histogram, -1.0/0.0)
  
  // æµ‹è¯•NaN
  Counter::add(test_counter, 0.0/0.0)
  Histogram::record(test_histogram, 0.0/0.0)
}

test "HTTPæ“ä½œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•HTTPæ“ä½œä¸­çš„é”™è¯¯å¤„ç†
  
  // æµ‹è¯•æ— æ•ˆHTTPæ–¹æ³•
  let invalid_methods = [
    "",
    "INVALID",
    "invalid",
    "POSTGET",
    " GET ",
    "GET\n",
    "GET\t",
    "ä¸­æ–‡æ–¹æ³•"
  ]
  
  for i = 0; i < invalid_methods.length(); i = i + 1 {
    let method = invalid_methods[i]
    let request = HttpRequest::new(method, "https://example.com", [], None)
    assert_eq(HttpRequest::http_method(request), method)
  }
  
  // æµ‹è¯•æ— æ•ˆURL
  let invalid_urls = [
    "",
    "not-a-url",
    "ftp://invalid.protocol",
    "http://",
    "https://",
    "://missing.protocol",
    "http://[invalid-ipv6",
    "http://256.256.256.256",
    "http://user:pass@host:99999"
  ]
  
  for i = 0; i < invalid_urls.length(); i = i + 1 {
    let url = invalid_urls[i]
    let request = HttpRequest::new("GET", url, [], None)
    assert_eq(HttpRequest::url(request), url)
  }
  
  // æµ‹è¯•æç«¯çŠ¶æ€ç 
  let extreme_status_codes = [
    -1, 0, 99, 100, 999, 1000, 2147483647, -2147483648
  ]
  
  for i = 0; i < extreme_status_codes.length(); i = i + 1 {
    let code = extreme_status_codes[i]
    let response = HttpResponse::new(code, [], None)
    assert_eq(HttpResponse::status_code(response), code)
  }
  
  // æµ‹è¯•è¶…é•¿å¤´éƒ¨
  let long_header_name = "x".repeat(1000)
  let long_header_value = "y".repeat(10000)
  let long_headers = [(long_header_name, long_header_value)]
  
  let request_with_long_headers = HttpRequest::new("GET", "https://example.com", long_headers, None)
  assert_eq(HttpRequest::http_method(request_with_long_headers), "GET")
  
  let response_with_long_headers = HttpResponse::new(200, long_headers, None)
  assert_eq(HttpResponse::status_code(response_with_long_headers), 200)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤´éƒ¨
  let special_headers = [
    ("X-Unicode-æµ‹è¯•", "å€¼ä¸­æ–‡"),
    ("X-Cyrillic-Ğ˜Ğ¼Ñ", "Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"),
    ("X-French-Nom", "valeur"),
    ("X-Emoji-ğŸš€", "ğŸŒŸvalueğŸŒŸ"),
    ("X-Newline\nName", "Value\nWith\nNewlines"),
    ("X-Null\0Name", "Value\0With\0Nulls")
  ]
  
  let request_with_special = HttpRequest::new("GET", "https://example.com", special_headers, None)
  assert_eq(HttpRequest::http_method(request_with_special), "GET")
  
  let response_with_special = HttpResponse::new(200, special_headers, None)
  assert_eq(HttpResponse::status_code(response_with_special), 200)
}

test "ä¼ æ’­å™¨é”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ä¼ æ’­å™¨æ“ä½œä¸­çš„é”™è¯¯å¤„ç†
  
  let trace_propagator = W3CTraceContextPropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  
  // æµ‹è¯•ç©ºCarrier
  let empty_carrier = TextMapCarrier::new()
  let ctx_from_empty = CompositePropagator::extract(composite, empty_carrier)
  
  // æµ‹è¯•å‘ç©ºCarrieræ³¨å…¥
  CompositePropagator::inject(composite, Context::root(), empty_carrier)
  
  // æµ‹è¯•æ— æ•ˆtraceparentæ ¼å¼
  let invalid_traceparents = [
    "",
    "invalid-format",
    "00-invalid-trace",
    "01-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331",
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-",
    "00--b7ad6b7169203331-01",
    "00-0af7651916cd43dd8448eb211c80319c--01",
    "01-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01",
    "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-99"
  ]
  
  for i = 0; i < invalid_traceparents.length(); i = i + 1 {
    let traceparent = invalid_traceparents[i]
    let carrier = TextMapCarrier::new()
    TextMapCarrier::set(carrier, "traceparent", traceparent)
    
    let extracted_ctx = CompositePropagator::extract(composite, carrier)
    // ç®€åŒ–å®ç°å¯èƒ½ä¸éªŒè¯æ ¼å¼
  }
  
  // æµ‹è¯•ç©ºä¼ æ’­å™¨åˆ—è¡¨
  let empty_composite = CompositePropagator::new([])
  let carrier = TextMapCarrier::new()
  
  CompositePropagator::inject(empty_composite, Context::root(), carrier)
  let ctx_from_empty_composite = CompositePropagator::extract(empty_composite, carrier)
  
  // æµ‹è¯•å¤šæ¬¡æ³¨å…¥å’Œæå–
  let carrier_multi = TextMapCarrier::new()
  let ctx = Context::root()
  
  for i = 0; i < 10; i = i + 1 {
    CompositePropagator::inject(composite, ctx, carrier_multi)
    let extracted = CompositePropagator::extract(composite, carrier_multi)
  }
}