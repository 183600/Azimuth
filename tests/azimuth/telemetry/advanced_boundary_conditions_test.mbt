// Azimuth Telemetry System - Advanced Boundary Conditions Test
// é«˜çº§è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼Œè¦†ç›–æç«¯æƒ…å†µå’Œè¾¹ç•Œå€¼

test "æå€¼æ•°æ®å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•å„ç§æå€¼æ•°æ®çš„å¤„ç†
  let attrs = Attributes::new()
  
  // æµ‹è¯•æœ€å¤§æ•´æ•°å€¼
  let max_int = IntValue(2147483647)
  Attributes::set(attrs, "max.int.value", max_int)
  
  // æµ‹è¯•æœ€å°æ•´æ•°å€¼
  let min_int = IntValue(-2147483648)
  Attributes::set(attrs, "min.int.value", min_int)
  
  // æµ‹è¯•é›¶å€¼
  let zero_int = IntValue(0)
  Attributes::set(attrs, "zero.int.value", zero_int)
  
  // æµ‹è¯•æå¤§æµ®ç‚¹æ•°
  let max_float = FloatValue(1.7976931348623157e+308) // æ¥è¿‘Doubleæœ€å¤§å€¼
  Attributes::set(attrs, "max.float.value", max_float)
  
  // æµ‹è¯•æå°æµ®ç‚¹æ•°
  let min_float = FloatValue(2.2250738585072014e-308) // æ¥è¿‘Doubleæœ€å°æ­£å€¼
  Attributes::set(attrs, "min.float.value", min_float)
  
  // æµ‹è¯•è´Ÿæ— ç©·å¤§
  let neg_infinity = FloatValue(-1.0/0.0)
  Attributes::set(attrs, "negative.infinity", neg_infinity)
  
  // æµ‹è¯•æ­£æ— ç©·å¤§
  let pos_infinity = FloatValue(1.0/0.0)
  Attributes::set(attrs, "positive.infinity", pos_infinity)
  
  // æµ‹è¯•NaN
  let nan_value = FloatValue(0.0/0.0)
  Attributes::set(attrs, "nan.value", nan_value)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_string = StringValue("")
  Attributes::set(attrs, "empty.string", empty_string)
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²
  let long_string = "a" * 10000 // 10000ä¸ªå­—ç¬¦
  Attributes::set(attrs, "long.string", StringValue(long_string))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = StringValue("\x00\x01\x02\x03\x04\x05\n\t\r\u0000")
  Attributes::set(attrs, "special.chars", special_chars)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = StringValue("ğŸš€æµ‹è¯•ä¸­æ–‡ğŸŒŸEmojiæ··åˆ")
  Attributes::set(attrs, "unicode.string", unicode_string)
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_array = ArrayStringValue([])
  Attributes::set(attrs, "empty.array", empty_array)
  
  // æµ‹è¯•å¤§æ•°ç»„
  let large_array = ArrayStringValue(["item" + i.to_string() for i in range(0, 1000)])
  Attributes::set(attrs, "large.array", large_array)
  
  // æµ‹è¯•åŒ…å«nullå­—ç¬¦çš„æ•°ç»„
  let null_array = ArrayStringValue(["", "\x00", "normal"])
  Attributes::set(attrs, "null.chars.array", null_array)
  
  // éªŒè¯æ‰€æœ‰è®¾ç½®æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}

test "SpanContextè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•SpanContextçš„å„ç§è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•ç©ºtrace_idå’Œspan_id
  let empty_trace_ctx = SpanContext::new("", "span123", true, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  
  let empty_span_ctx = SpanContext::new("trace123", "", true, "")
  assert_false(SpanContext::is_valid(empty_span_ctx))
  
  let both_empty_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(both_empty_ctx))
  assert_false(SpanContext::is_sampled(both_empty_ctx))
  
  // æµ‹è¯•æé•¿çš„trace_idå’Œspan_id
  let long_trace_id = "a" * 100 // è¶…è¿‡æ ‡å‡†é•¿åº¦
  let long_span_id = "b" * 50   // è¶…è¿‡æ ‡å‡†é•¿åº¦
  let long_ctx = SpanContext::new(long_trace_id, long_span_id, true, "")
  
  // å³ä½¿é•¿åº¦å¼‚å¸¸ï¼ŒåŸºæœ¬æ“ä½œåº”è¯¥æ­£å¸¸å·¥ä½œ
  assert_eq(SpanContext::trace_id(long_ctx), long_trace_id)
  assert_eq(SpanContext::span_id(long_ctx), long_span_id)
  assert_true(SpanContext::is_sampled(long_ctx))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„trace_idå’Œspan_id
  let special_trace_id = "trace-123!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_span_id = "span-456!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_ctx = SpanContext::new(special_trace_id, special_span_id, true, "special=chars")
  
  assert_eq(SpanContext::trace_id(special_ctx), special_trace_id)
  assert_eq(SpanContext::span_id(special_ctx), special_span_id)
  assert_eq(SpanContext::is_sampled(special_ctx), true)
  
  // æµ‹è¯•Unicodeå­—ç¬¦çš„trace_idå’Œspan_id
  let unicode_trace_id = "è¿½è¸ªID-123-ğŸš€"
  let unicode_span_id = "è·¨åº¦ID-456-ğŸŒŸ"
  let unicode_ctx = SpanContext::new(unicode_trace_id, unicode_span_id, true, "unicode=æµ‹è¯•")
  
  assert_eq(SpanContext::trace_id(unicode_ctx), unicode_trace_id)
  assert_eq(SpanContext::span_id(unicode_ctx), unicode_span_id)
  
  // æµ‹è¯•æé•¿çš„trace_state
  let long_trace_state = "key1=value1" + ("&key" + i.to_string() + "=value" + i.to_string() for i in range(2, 100))
  let long_state_ctx = SpanContext::new("trace123", "span456", true, long_trace_state)
  
  assert_eq(SpanContext::trace_id(long_state_ctx), "trace123")
  assert_eq(SpanContext::span_id(long_state_ctx), "span456")
  assert_true(SpanContext::is_sampled(long_state_ctx))
}

test "Attributeæ“ä½œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•å±æ€§æ“ä½œçš„è¾¹ç•Œæ¡ä»¶
  let attrs = Attributes::new()
  
  // æµ‹è¯•æé•¿çš„é”®å
  let long_key = "very.long.key.name." + "segment." * 100
  Attributes::set(attrs, long_key, StringValue("test value"))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®å
  let special_key = "key.with.special.chars!@#$%^&*()_+-=[]{}|;':\",./<>?"
  Attributes::set(attrs, special_key, StringValue("special value"))
  
  // æµ‹è¯•Unicodeé”®å
  let unicode_key = "é”®å.åŒ…å«.ä¸­æ–‡.å’Œ.emojiğŸš€"
  Attributes::set(attrs, unicode_key, StringValue("unicodeå€¼"))
  
  // æµ‹è¯•ç©ºé”®å
  Attributes::set(attrs, "", StringValue("empty key value"))
  
  // æµ‹è¯•å¤§é‡å±æ€§è®¾ç½®
  for i in range(0, 10000) {
    let key = "bulk.key." + i.to_string()
    let value = StringValue("bulk.value." + i.to_string())
    Attributes::set(attrs, key, value)
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„é”®
  let non_existent = Attributes::get(attrs, "non.existent.key")
  assert_true(non_existent is None)
  
  // æµ‹è¯•è¦†ç›–å·²å­˜åœ¨çš„é”®
  Attributes::set(attrs, "duplicate.key", StringValue("first value"))
  Attributes::set(attrs, "duplicate.key", StringValue("second value"))
  Attributes::set(attrs, "duplicate.key", StringValue("third value"))
  
  // æµ‹è¯•è®¾ç½®ä¸åŒç±»å‹çš„å€¼åˆ°åŒä¸€ä¸ªé”®
  Attributes::set(attrs, "type.changing.key", StringValue("string value"))
  Attributes::set(attrs, "type.changing.key", IntValue(42))
  Attributes::set(attrs, "type.changing.key", FloatValue(3.14))
  Attributes::set(attrs, "type.changing.key", BoolValue(true))
  
  // æµ‹è¯•æå€¼æ•°ç»„å±æ€§
  let huge_string_array = ArrayStringValue(["item" + i.to_string() for i in range(0, 10000)])
  Attributes::set(attrs, "huge.string.array", huge_string_array)
  
  let huge_int_array = ArrayIntValue([i for i in range(0, 10000)])
  Attributes::set(attrs, "huge.int.array", huge_int_array)
  
  // æµ‹è¯•åŒ…å«æå€¼å…ƒç´ çš„æ•°ç»„
  let extreme_value_array = ArrayStringValue([
    "", "a" * 1000, "ğŸš€", "\x00", "normal", "very long string with special chars !@#$%^&*()"
  ])
  Attributes::set(attrs, "extreme.values.array", extreme_value_array)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}

test "Contextä¼ æ’­è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•Contextä¼ æ’­çš„è¾¹ç•Œæ¡ä»¶
  let root_ctx = Context::root()
  
  // æµ‹è¯•æé•¿çš„é”®åå’Œå€¼
  let long_key = ContextKey::new("very.long.context.key." + "segment." * 50)
  let long_value = "very.long.context.value." + "segment." * 50
  let ctx_with_long = Context::with_value(root_ctx, long_key, long_value)
  
  let retrieved_long = Context::get(ctx_with_long, long_key)
  match retrieved_long {
    Some(value) => assert_eq(value, long_value)
    None => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®åå’Œå€¼
  let special_key = ContextKey::new("special.key!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let special_value = "special.value!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let ctx_with_special = Context::with_value(root_ctx, special_key, special_value)
  
  let retrieved_special = Context::get(ctx_with_special, special_key)
  match retrieved_special {
    Some(value) => assert_eq(value, special_value)
    None => assert_true(false)
  }
  
  // æµ‹è¯•Unicodeé”®åå’Œå€¼
  let unicode_key = ContextKey::new("unicode.é”®å.ğŸš€")
  let unicode_value = "unicode.å€¼.ğŸŒŸ"
  let ctx_with_unicode = Context::with_value(root_ctx, unicode_key, unicode_value)
  
  let retrieved_unicode = Context::get(ctx_with_unicode, unicode_key)
  match retrieved_unicode {
    Some(value) => assert_eq(value, unicode_value)
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºå€¼
  let empty_key = ContextKey::new("empty.key")
  let ctx_with_empty = Context::with_value(root_ctx, empty_key, "")
  
  let retrieved_empty = Context::get(ctx_with_empty, empty_key)
  match retrieved_empty {
    Some(value) => assert_eq(value, "")
    None => assert_true(false)
  }
  
  // æµ‹è¯•æ·±å±‚åµŒå¥—çš„Context
  let nested_ctx = Context::root()
  for i in range(0, 1000) {
    let key = ContextKey::new("nested.key." + i.to_string())
    let value = "nested.value." + i.to_string()
    nested_ctx = Context::with_value(nested_ctx, key, value)
  }
  
  // éªŒè¯æ·±å±‚åµŒå¥—ä¸ä¼šå¯¼è‡´é—®é¢˜
  let deep_key = ContextKey::new("nested.key.999")
  let deep_value = Context::get(nested_ctx, deep_key)
  match deep_value {
    Some(value) => assert_eq(value, "nested.value.999")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒæ·±å±‚åµŒå¥—
  }
  
  // æµ‹è¯•TextMapCarrierçš„è¾¹ç•Œæ¡ä»¶
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•æé•¿çš„å¤´éƒ¨åç§°å’Œå€¼
  let long_header_name = "very.long.header.name." + "segment." * 50
  let long_header_value = "very.long.header.value." + "segment." * 50
  TextMapCarrier::set(carrier, long_header_name, long_header_value)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å¤´éƒ¨
  let special_header_name = "special-header!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_header_value = "special-value!@#$%^&*()_+-=[]{}|;':\",./<>?"
  TextMapCarrier::set(carrier, special_header_name, special_header_value)
  
  // æµ‹è¯•Unicodeå¤´éƒ¨
  let unicode_header_name = "unicode-å¤´éƒ¨-ğŸš€"
  let unicode_header_value = "unicode-å€¼-ğŸŒŸ"
  TextMapCarrier::set(carrier, unicode_header_name, unicode_header_value)
  
  // æµ‹è¯•å¤§é‡å¤´éƒ¨
  for i in range(0, 1000) {
    let header_name = "bulk.header." + i.to_string()
    let header_value = "bulk.value." + i.to_string()
    TextMapCarrier::set(carrier, header_name, header_value)
  }
  
  // éªŒè¯æ‰€æœ‰æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}

test "LogRecordè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•LogRecordçš„è¾¹ç•Œæ¡ä»¶
  
  // æµ‹è¯•æé•¿çš„æ—¥å¿—æ¶ˆæ¯
  let very_long_message = "This is a very long log message " + "that goes on and on. " * 200
  let long_log = LogRecord::new(Info, very_long_message)
  assert_eq(LogRecord::severity_number(long_log), Info)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—æ¶ˆæ¯
  let special_message = "Log message with special chars: \x00\x01\x02\n\t\r!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_log = LogRecord::new(Error, special_message)
  assert_eq(LogRecord::severity_number(special_log), Error)
  
  // æµ‹è¯•Unicodeæ—¥å¿—æ¶ˆæ¯
  let unicode_message = "æ—¥å¿—æ¶ˆæ¯åŒ…å«ä¸­æ–‡å’ŒemojiğŸš€ğŸŒŸ"
  let unicode_log = LogRecord::new(Warn, unicode_message)
  assert_eq(LogRecord::severity_number(unicode_log), Warn)
  
  // æµ‹è¯•ç©ºæ—¥å¿—æ¶ˆæ¯
  let empty_log = LogRecord::new(Debug, "")
  assert_eq(LogRecord::severity_number(empty_log), Debug)
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let max_timestamp = 9223372036854775807L // Int64æœ€å¤§å€¼
  let min_timestamp = -9223372036854775808L // Int64æœ€å°å€¼
  let zero_timestamp = 0L
  
  let max_time_log = LogRecord::new_with_context(
    Info, Some("Max timestamp"), None, Some(max_timestamp), None, None, None, None
  )
  
  let min_time_log = LogRecord::new_with_context(
    Info, Some("Min timestamp"), None, Some(min_timestamp), None, None, None, None
  )
  
  let zero_time_log = LogRecord::new_with_context(
    Info, Some("Zero timestamp"), None, Some(zero_timestamp), None, None, None, None
  )
  
  // æµ‹è¯•æé•¿çš„trace_idå’Œspan_id
  let long_trace_id = "a" * 100
  let long_span_id = "b" * 100
  
  let long_ids_log = LogRecord::new_with_context(
    Error, Some("Long IDs"), None, None, None, Some(long_trace_id), Some(long_span_id), None
  )
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„trace_idå’Œspan_id
  let special_trace_id = "trace-123!@#$%^&*()"
  let special_span_id = "span-456!@#$%^&*()"
  
  let special_ids_log = LogRecord::new_with_context(
    Warn, Some("Special IDs"), None, None, None, Some(special_trace_id), Some(special_span_id), None
  )
  
  // æµ‹è¯•Unicode trace_idå’Œspan_id
  let unicode_trace_id = "è¿½è¸ªID-123-ğŸš€"
  let unicode_span_id = "è·¨åº¦ID-456-ğŸŒŸ"
  
  let unicode_ids_log = LogRecord::new_with_context(
    Info, Some("Unicode IDs"), None, None, None, Some(unicode_trace_id), Some(unicode_span_id), None
  )
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡æ€§çº§åˆ«
  let trace_log = LogRecord::new(Trace, "Trace message")
  let debug_log = LogRecord::new(Debug, "Debug message")
  let info_log = LogRecord::new(Info, "Info message")
  let warn_log = LogRecord::new(Warn, "Warning message")
  let error_log = LogRecord::new(Error, "Error message")
  let fatal_log = LogRecord::new(Fatal, "Fatal message")
  
  assert_eq(LogRecord::severity_number(trace_log), Trace)
  assert_eq(LogRecord::severity_number(debug_log), Debug)
  assert_eq(LogRecord::severity_number(info_log), Info)
  assert_eq(LogRecord::severity_number(warn_log), Warn)
  assert_eq(LogRecord::severity_number(error_log), Error)
  assert_eq(LogRecord::severity_number(fatal_log), Fatal)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}

test "Instrumentè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•Instrumentçš„è¾¹ç•Œæ¡ä»¶
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary-test")
  
  // æµ‹è¯•æé•¿çš„instrumentåç§°
  let long_name = "very.long.instrument.name." + "segment." * 50
  let long_counter = Meter::create_counter(meter, long_name)
  assert_eq(long_counter.name, long_name)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„instrumentåç§°
  let special_name = "special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_counter = Meter::create_counter(meter, special_name)
  assert_eq(special_counter.name, special_name)
  
  // æµ‹è¯•Unicode instrumentåç§°
  let unicode_name = "unicode.ä»ªå™¨.åç§°.ğŸš€"
  let unicode_counter = Meter::create_counter(meter, unicode_name)
  assert_eq(unicode_counter.name, unicode_name)
  
  // æµ‹è¯•ç©ºçš„instrumentåç§°
  let empty_counter = Meter::create_counter(meter, "")
  assert_eq(empty_counter.name, "")
  
  // æµ‹è¯•æé•¿çš„æè¿°
  let long_description = "This is a very long description " + "that goes on and on. " * 100
  let long_desc_counter = Meter::create_counter(meter, "long.desc", Some(long_description))
  assert_eq(long_desc_counter.description, Some(long_description))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æè¿°
  let special_description = "Special description with chars: \x00\x01\n\t!@#$%^&*()"
  let special_desc_counter = Meter::create_counter(meter, "special.desc", Some(special_description))
  assert_eq(special_desc_counter.description, Some(special_description))
  
  // æµ‹è¯•Unicodeæè¿°
  let unicode_description = "æè¿°åŒ…å«ä¸­æ–‡å’ŒemojiğŸš€ğŸŒŸ"
  let unicode_desc_counter = Meter::create_counter(meter, "unicode.desc", Some(unicode_description))
  assert_eq(unicode_desc_counter.description, Some(unicode_description))
  
  // æµ‹è¯•æé•¿çš„å•ä½
  let long_unit = "very.long.unit." + "segment." * 20
  let long_unit_counter = Meter::create_counter(meter, "long.unit", None, Some(long_unit))
  assert_eq(long_unit_counter.unit, Some(long_unit))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å•ä½
  let special_unit = "special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_unit_counter = Meter::create_counter(meter, "special.unit", None, Some(special_unit))
  assert_eq(special_unit_counter.unit, Some(special_unit))
  
  // æµ‹è¯•Unicodeå•ä½
  let unicode_unit = "å•ä½.åŒ…å«.ä¸­æ–‡.ğŸš€"
  let unicode_unit_counter = Meter::create_counter(meter, "unicode.unit", None, Some(unicode_unit))
  assert_eq(unicode_unit_counter.unit, Some(unicode_unit))
  
  // æµ‹è¯•æå€¼æŒ‡æ ‡è®°å½•
  let extreme_counter = Meter::create_counter(meter, "extreme.values")
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(extreme_counter, 1.7976931348623157e+308) // æ¥è¿‘Doubleæœ€å¤§å€¼
  
  // æµ‹è¯•æå°å€¼
  Counter::add(extreme_counter, 2.2250738585072014e-308) // æ¥è¿‘Doubleæœ€å°æ­£å€¼
  
  // æµ‹è¯•è´Ÿå€¼
  Counter::add(extreme_counter, -1.7976931348623157e+308) // è´Ÿæå¤§å€¼
  
  // æµ‹è¯•é›¶å€¼
  Counter::add(extreme_counter, 0.0)
  
  // æµ‹è¯•æ— ç©·å¤§
  Counter::add(extreme_counter, 1.0/0.0) // æ­£æ— ç©·å¤§
  Counter::add(extreme_counter, -1.0/0.0) // è´Ÿæ— ç©·å¤§
  
  // æµ‹è¯•NaN
  Counter::add(extreme_counter, 0.0/0.0) // NaN
  
  // æµ‹è¯•Histogramçš„æå€¼è®°å½•
  let extreme_histogram = Meter::create_histogram(meter, "extreme.histogram")
  
  Histogram::record(extreme_histogram, 1.7976931348623157e+308)
  Histogram::record(extreme_histogram, -1.7976931348623157e+308)
  Histogram::record(extreme_histogram, 1.0/0.0)
  Histogram::record(extreme_histogram, 0.0/0.0)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}

test "Resourceè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•Resourceçš„è¾¹ç•Œæ¡ä»¶
  let resource = Resource::new()
  
  // æµ‹è¯•æé•¿å±æ€§åå’Œå€¼
  let long_attrs = [
    ("very.long.attribute.name." + "segment." * 50, StringValue("very long value " + "segment." * 50)),
    ("special.chars!@#$%^&*()", StringValue("special values!@#$%^&*()")),
    ("unicode.å±æ€§.ğŸš€", StringValue("unicode.å€¼.ğŸŒŸ")),
    ("empty.attribute", StringValue("")),
    ("number.attr", IntValue(2147483647)),
    ("float.attr", FloatValue(1.7976931348623157e+308)),
    ("bool.attr", BoolValue(true))
  ]
  
  let resource_with_long_attrs = Resource::with_attributes(resource, long_attrs)
  
  // æµ‹è¯•æå¤šçš„å±æ€§
  let many_attrs = [("attr." + i.to_string(), StringValue("value." + i.to_string())) for i in range(0, 10000)]
  let resource_with_many_attrs = Resource::with_attributes(resource, many_attrs)
  
  // æµ‹è¯•åŒ…å«æå€¼çš„å±æ€§
  let extreme_attrs = [
    ("max.int", IntValue(2147483647)),
    ("min.int", IntValue(-2147483648)),
    ("max.float", FloatValue(1.7976931348623157e+308)),
    ("min.float", FloatValue(2.2250738585072014e-308)),
    ("infinity", FloatValue(1.0/0.0)),
    ("neg.infinity", FloatValue(-1.0/0.0)),
    ("nan", FloatValue(0.0/0.0))
  ]
  
  let resource_with_extreme_attrs = Resource::with_attributes(resource, extreme_attrs)
  
  // æµ‹è¯•åŒ…å«æå€¼æ•°ç»„çš„å±æ€§
  let large_string_array = ArrayStringValue(["item" + i.to_string() for i in range(0, 10000)])
  let large_int_array = ArrayIntValue([i for i in range(0, 10000)])
  
  let array_attrs = [
    ("large.string.array", large_string_array),
    ("large.int.array", large_int_array),
    ("empty.array", ArrayStringValue([])),
    ("single.item.array", ArrayStringValue(["single"]))
  ]
  
  let resource_with_arrays = Resource::with_attributes(resource, array_attrs)
  
  // æµ‹è¯•èµ„æºåˆå¹¶çš„è¾¹ç•Œæ¡ä»¶
  let resource1 = Resource::with_attributes(Resource::new(), [
    ("attr1", StringValue("value1")),
    ("attr2", StringValue("value2")),
    ("attr3", StringValue("value3"))
  ])
  
  let resource2 = Resource::with_attributes(Resource::new(), [
    ("attr2", StringValue("new_value2")), // è¦†ç›–
    ("attr3", StringValue("new_value3")), // è¦†ç›–
    ("attr4", StringValue("value4")),     // æ–°å¢
    ("attr5", StringValue("value5"))      // æ–°å¢
  ])
  
  let merged_resource = Resource::merge(resource1, resource2)
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å±æ€§
  let missing_attr = Resource::get_attribute(merged_resource, "nonexistent.attr")
  assert_true(missing_attr is None)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}

test "Baggageè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæ¡ä»¶
  let baggage = Baggage::new()
  
  // æµ‹è¯•æé•¿çš„é”®åå’Œå€¼
  let long_key = "very.long.baggage.key." + "segment." * 50
  let long_value = "very.long.baggage.value." + "segment." * 50
  let baggage_with_long = Baggage::set_entry(baggage, long_key, long_value)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®åå’Œå€¼
  let special_key = "special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_value = "special!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let baggage_with_special = Baggage::set_entry(baggage, special_key, special_value)
  
  // æµ‹è¯•Unicodeé”®åå’Œå€¼
  let unicode_key = "unicode.é”®å.ğŸš€"
  let unicode_value = "unicode.å€¼.ğŸŒŸ"
  let baggage_with_unicode = Baggage::set_entry(baggage, unicode_key, unicode_value)
  
  // æµ‹è¯•ç©ºé”®åå’Œå€¼
  let baggage_with_empty_key = Baggage::set_entry(baggage, "", "empty key value")
  let baggage_with_empty_value = Baggage::set_entry(baggage, "empty.value", "")
  
  // æµ‹è¯•å¤§é‡çš„baggageæ¡ç›®
  let many_baggage = Baggage::new()
  for i in range(0, 1000) {
    let key = "baggage.key." + i.to_string()
    let value = "baggage.value." + i.to_string()
    many_baggage = Baggage::set_entry(many_baggage, key, value)
  }
  
  // æµ‹è¯•è¦†ç›–ç°æœ‰æ¡ç›®
  let overwrite_baggage = Baggage::new()
  overwrite_baggage = Baggage::set_entry(overwrite_baggage, "duplicate.key", "first value")
  overwrite_baggage = Baggage::set_entry(overwrite_baggage, "duplicate.key", "second value")
  overwrite_baggage = Baggage::set_entry(overwrite_baggage, "duplicate.key", "third value")
  
  // æµ‹è¯•åˆ é™¤ä¸å­˜åœ¨çš„æ¡ç›®
  let remove_nonexistent = Baggage::remove_entry(baggage, "nonexistent.key")
  
  // æµ‹è¯•åˆ é™¤ç©ºé”®åçš„æ¡ç›®
  let remove_empty_key = Baggage::remove_entry(baggage_with_empty_key, "")
  
  // æµ‹è¯•è·å–å„ç§è¾¹ç•Œæ¡ä»¶çš„æ¡ç›®
  let retrieved_long = Baggage::get_entry(baggage_with_long, long_key)
  let retrieved_special = Baggage::get_entry(baggage_with_special, special_key)
  let retrieved_unicode = Baggage::get_entry(baggage_with_unicode, unicode_key)
  let retrieved_empty_key = Baggage::get_entry(baggage_with_empty_key, "")
  let retrieved_empty_value = Baggage::get_entry(baggage_with_empty_value, "empty.value")
  let retrieved_duplicate = Baggage::get_entry(overwrite_baggage, "duplicate.key")
  let retrieved_nonexistent = Baggage::get_entry(baggage, "nonexistent.key")
  
  // éªŒè¯æ‰€æœ‰æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}