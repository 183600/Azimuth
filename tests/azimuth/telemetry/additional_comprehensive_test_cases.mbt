// Azimuth Telemetry System - é™„åŠ ç»¼åˆæµ‹è¯•ç”¨ä¾‹
// æä¾›é¢å¤–çš„æµ‹è¯•è¦†ç›–ï¼Œç¡®ä¿ç³»ç»Ÿçš„å®Œæ•´æ€§å’Œå¯é æ€§

test "å¤åˆé¥æµ‹åœºæ™¯é›†æˆæµ‹è¯•" {
  // æµ‹è¯•å®Œæ•´çš„é¥æµ‹åœºæ™¯ï¼šè¿½è¸ª + æŒ‡æ ‡ + æ—¥å¿—
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  let tracer = TracerProvider::get_tracer(tracer_provider, "composite-test")
  let meter = MeterProvider::get_meter(meter_provider, "composite-test")
  let logger = LoggerProvider::get_logger(logger_provider, "composite-test")
  
  // åˆ›å»ºæŒ‡æ ‡
  let request_counter = Meter::create_counter(meter, "http.requests.total")
  let response_histogram = Meter::create_histogram(meter, "http.response.duration")
  
  // å¼€å§‹è¿½è¸ª
  let span = Tracer::start_span(tracer, "http.request.processing")
  
  // æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†
  Counter::add(request_counter, 1.0)
  Histogram::record(response_histogram, 150.5)
  
  // æ·»åŠ äº‹ä»¶
  Span::add_event(span, "request.received", Some([("method", StringValue("GET"))]))
  
  // è®°å½•æ—¥å¿—
  let log_record = LogRecord::new_with_context(
    Info,
    Some("Processing HTTP request"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(span))),
    Some(SpanContext::span_id(Span::span_context(span))),
    Some(Context::root())
  )
  Logger::emit(logger, log_record)
  
  // å®Œæˆå¤„ç†
  Span::add_event(span, "request.completed", Some([("status", StringValue("200"))]))
  Span::set_status(span, Ok)
  Span::end(span)
  
  // éªŒè¯æ‰€æœ‰ç»„ä»¶éƒ½æ­£å¸¸å·¥ä½œ
  assert_true(true)
}

test "æ‰¹é‡å±æ€§æ“ä½œæ€§èƒ½å’Œä¸€è‡´æ€§æµ‹è¯•" {
  let attrs = Attributes::new()
  let test_keys = []
  let test_values = []
  
  // æ‰¹é‡ç”Ÿæˆæµ‹è¯•æ•°æ®
  for i in 0..100 {
    test_keys.push("batch.key." + i.to_string())
    test_values.push(StringValue("batch.value." + i.to_string()))
  }
  
  // æ‰¹é‡è®¾ç½®å±æ€§
  let start_time = Clock::now_unix_nanos(Clock::system())
  for i in 0..100 {
    Attributes::set(attrs, test_keys[i], test_values[i])
  }
  let set_duration = Clock::now_unix_nanos(Clock::system()) - start_time
  
  // æ‰¹é‡è·å–å±æ€§
  let start_get_time = Clock::now_unix_nanos(Clock::system())
  for i in 0..100 {
    let result = Attributes::get(attrs, test_keys[i])
    // ç”±äºç®€åŒ–å®ç°ï¼Œåªæœ‰ç‰¹å®škeyä¼šè¿”å›å€¼
    match result {
      Some(value) => assert_true(true)
      None => assert_true(true) // ç®€åŒ–å®ç°ä¸­å¤§éƒ¨åˆ†keyè¿”å›Noneæ˜¯æ­£å¸¸çš„
    }
  }
  let get_duration = Clock::now_unix_nanos(Clock::system()) - start_get_time
  
  // éªŒè¯æ€§èƒ½åœ¨åˆç†èŒƒå›´å†…
  assert_true(set_duration < 1000000000L) // 1ç§’
  assert_true(get_duration < 1000000000L) // 1ç§’
  
  // éªŒè¯æ•°æ®ä¸€è‡´æ€§
  let special_key = "string.key" // ç®€åŒ–å®ç°ä¸­ä¼šè¿”å›å€¼çš„key
  let consistent_result = Attributes::get(attrs, special_key)
  match consistent_result {
    Some(StringValue(value)) => assert_eq(value, "test_value")
    _ => assert_true(false)
  }
}

test "å†…å­˜ä½¿ç”¨å’Œèµ„æºæ¸…ç†æµ‹è¯•" {
  // æµ‹è¯•å¤§é‡å¯¹è±¡åˆ›å»ºå’Œå†…å­˜ä½¿ç”¨
  let objects = []
  
  // åˆ›å»ºå¤§é‡Spanå¯¹è±¡
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "memory.test")
  
  for i in 0..500 {
    let span = Tracer::start_span(tracer, "memory.test.span." + i.to_string())
    objects.push(span)
  }
  
  // åˆ›å»ºå¤§é‡å±æ€§å¯¹è±¡
  for i in 0..500 {
    let attrs = Attributes::new()
    Attributes::set(attrs, "memory.test.key", StringValue("memory.test.value." + i.to_string()))
    objects.push(attrs)
  }
  
  // åˆ›å»ºå¤§é‡æ—¥å¿—è®°å½•
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "memory.test")
  
  for i in 0..500 {
    let log_record = LogRecord::new(Info, "Memory test log " + i.to_string())
    objects.push(log_record)
  }
  
  // éªŒè¯å¯¹è±¡åˆ›å»ºæˆåŠŸ
  assert_true(objects.length() == 1500)
  
  // æ¸…ç†å¯¹è±¡å¼•ç”¨ï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥è§¦å‘åƒåœ¾å›æ”¶ï¼‰
  for i in 0..objects.length() {
    objects[i] = None
  }
  
  assert_true(true)
}

test "å¤šçº¿ç¨‹å¹¶å‘å®‰å…¨æµ‹è¯•" {
  // æµ‹è¯•å¹¶å‘æ“ä½œçš„å®‰å…¨æ€§
  let shared_attrs = Attributes::new()
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrency.test")
  
  // æ¨¡æ‹Ÿå¹¶å‘å±æ€§è®¾ç½®
  for thread_id in 0..10 {
    for i in 0..50 {
      let key = "concurrent.key." + thread_id.to_string() + "." + i.to_string()
      let value = StringValue("concurrent.value." + thread_id.to_string() + "." + i.to_string())
      Attributes::set(shared_attrs, key, value)
    }
  }
  
  // æ¨¡æ‹Ÿå¹¶å‘Spanåˆ›å»º
  let spans = []
  for thread_id in 0..10 {
    for i in 0..50 {
      let span_name = "concurrent.span." + thread_id.to_string() + "." + i.to_string()
      let span = Tracer::start_span(tracer, span_name)
      spans.push(span)
    }
  }
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½æˆåŠŸå®Œæˆ
  assert_true(spans.length() == 500)
  
  // ç»“æŸæ‰€æœ‰Span
  for span in spans {
    Span::end(span)
  }
  
  assert_true(true)
}

test "æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•å¤æ‚æ•°æ®ç»“æ„çš„åºåˆ—åŒ–å®Œæ•´æ€§
  let attrs = Attributes::new()
  
  // æ·»åŠ å„ç§ç±»å‹çš„å±æ€§
  Attributes::set(attrs, "string.complex", StringValue("Complex string with ç‰¹æ®Šå­—ç¬¦ and ğŸš€ emoji"))
  Attributes::set(attrs, "int.large", IntValue(9223372036854775807L))
  Attributes::set(attrs, "float.precision", FloatValue(3.14159265358979323846))
  Attributes::set(attrs, "bool.true", BoolValue(true))
  Attributes::set(attrs, "array.strings", ArrayStringValue(["item1", "item2", "item3"]))
  Attributes::set(attrs, "array.ints", ArrayIntValue([1, 2, 3, 4, 5]))
  
  // åˆ›å»ºå¤æ‚çš„SpanContext
  let span_ctx = SpanContext::new(
    "0af7651916cd43dd8448eb211c80319c",
    "b7ad6b7169203331",
    true,
    "rojo=00f067aa0ba902b7,congo=t61rcWkgMzE"
  )
  
  // åˆ›å»ºå¤æ‚çš„Resource
  let resource_attrs = [
    ("service.name", StringValue("complex-service")),
    ("service.version", StringValue("1.2.3-beta")),
    ("service.instance.id", StringValue("instance-12345")),
    ("host.name", StringValue("prod-server-01")),
    ("process.pid", IntValue(12345)),
    ("process.memory.usage", IntValue(1073741824)),
    ("feature.flags", ArrayStringValue(["feature-a", "feature-b"]))
  ]
  let resource = Resource::with_attributes(Resource::new(), resource_attrs)
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  let complex_string = Attributes::get(attrs, "string.complex")
  match complex_string {
    Some(StringValue(value)) => assert_eq(value, "Complex string with ç‰¹æ®Šå­—ç¬¦ and ğŸš€ emoji")
    _ => assert_true(false)
  }
  
  let large_int = Attributes::get(attrs, "int.large")
  match large_int {
    Some(IntValue(value)) => assert_eq(value, 9223372036854775807L)
    _ => assert_true(false)
  }
  
  // éªŒè¯SpanContext
  assert_eq(SpanContext::trace_id(span_ctx), "0af7651916cd43dd8448eb211c80319c")
  assert_eq(SpanContext::span_id(span_ctx), "b7ad6b7169203331")
  assert_true(SpanContext::is_sampled(span_ctx))
  
  // éªŒè¯Resource
  let service_name = Resource::get_attribute(resource, "service.name")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "complex-service")
    _ => assert_true(false)
  }
  
  assert_true(true)
}

test "é”™è¯¯æ¢å¤å’Œå®¹é”™æ€§æµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.recovery.test")
  
  // æµ‹è¯•æ— æ•ˆè¾“å…¥çš„å¤„ç†
  let empty_trace_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  
  // æµ‹è¯•éƒ¨åˆ†æ— æ•ˆçš„SpanContext
  let partial_invalid_ctx1 = SpanContext::new("", "valid_span_id", true, "")
  let partial_invalid_ctx2 = SpanContext::new("valid_trace_id", "", true, "")
  assert_false(SpanContext::is_valid(partial_invalid_ctx1))
  assert_false(SpanContext::is_valid(partial_invalid_ctx2))
  
  // æµ‹è¯•ç³»ç»Ÿåœ¨æ— æ•ˆè¾“å…¥ä¸‹çš„ç»§ç»­è¿è¡Œèƒ½åŠ›
  let span1 = Tracer::start_span(tracer, "recovery.test.span1")
  let span2 = Tracer::start_span(tracer, "recovery.test.span2")
  
  // è®¾ç½®çŠ¶æ€å¹¶å¤„ç†
  Span::set_status(span1, Error, Some("Intentional error for testing"))
  Span::set_status(span2, Ok)
  
  // æ·»åŠ äº‹ä»¶
  Span::add_event(span1, "error.occurred", Some([("error.type", StringValue("test.error"))]))
  Span::add_event(span2, "recovery.success", Some([("recovery.action", StringValue("auto.retry"))]))
  
  // ç»“æŸSpan
  Span::end(span1)
  Span::end(span2)
  
  // éªŒè¯ç³»ç»Ÿèƒ½å¤Ÿæ­£å¸¸æ¢å¤
  let recovery_span = Tracer::start_span(tracer, "recovery.test.new")
  Span::set_status(recovery_span, Ok)
  Span::end(recovery_span)
  
  assert_true(true)
}

test "é…ç½®ç®¡ç†å’ŒåŠ¨æ€æ›´æ–°æµ‹è¯•" {
  // æµ‹è¯•é…ç½®çš„åŠ¨æ€æ›´æ–°å’Œç®¡ç†
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "config.test")
  
  // åˆ›å»ºä¸åŒé…ç½®çš„æŒ‡æ ‡
  let counter_with_config = Meter::create_counter(
    meter, 
    "configurable.counter",
    Some("Configurable counter with dynamic description"),
    Some("operations")
  )
  
  let histogram_with_config = Meter::create_histogram(
    meter,
    "configurable.histogram",
    Some("Configurable histogram with dynamic bounds"),
    Some("milliseconds")
  )
  
  // æ¨¡æ‹Ÿé…ç½®æ›´æ–°åœºæ™¯
  for config_version in 0..5 {
    // æ ¹æ®é…ç½®ç‰ˆæœ¬è°ƒæ•´å‚æ•°
    let multiplier = config_version + 1
    let base_value = 100.0 * multiplier.to_double()
    
    // ä½¿ç”¨å½“å‰é…ç½®è®°å½•æ•°æ®
    Counter::add(counter_with_config, multiplier.to_double())
    Histogram::record(histogram_with_config, base_value)
    
    // éªŒè¯é…ç½®å˜æ›´ä¸ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ
    assert_true(counter_with_config.name == "configurable.counter")
    assert_true(histogram_with_config.name == "configurable.histogram")
  }
  
  // æµ‹è¯•é…ç½®è¾¹ç•Œæƒ…å†µ
  let zero_counter = Meter::create_counter(meter, "zero.test")
  Counter::add(zero_counter, 0.0)
  
  let negative_histogram = Meter::create_histogram(meter, "negative.test")
  Histogram::record(negative_histogram, -50.0)
  
  assert_true(true)
}

test "è·¨æœåŠ¡ä¼ æ’­å¤æ‚åœºæ™¯æµ‹è¯•" {
  // æµ‹è¯•å¤æ‚çš„è·¨æœåŠ¡ä¼ æ’­åœºæ™¯
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  let composite_propagator = CompositePropagator::new([trace_propagator])
  
  // æ¨¡æ‹Ÿå¤šæœåŠ¡è°ƒç”¨é“¾
  let services = ["api-gateway", "auth-service", "user-service", "order-service", "payment-service"]
  let contexts = []
  let carriers = []
  
  // åˆå§‹ä¸Šä¸‹æ–‡
  let initial_ctx = Context::root()
  let user_key = ContextKey::new("user.id")
  let request_id_key = ContextKey::new("request.id")
  let initial_ctx_with_data = Context::with_value(
    Context::with_value(initial_ctx, user_key, "user-12345"),
    request_id_key,
    "req-abcde-12345"
  )
  
  contexts.push(initial_ctx_with_data)
  
  // æ¨¡æ‹ŸæœåŠ¡é“¾ä¼ æ’­
  for i in 0..services.length() {
    let current_carrier = TextMapCarrier::new()
    let current_ctx = contexts[i]
    
    // æ³¨å…¥ä¸Šä¸‹æ–‡åˆ°è½½ä½“
    CompositePropagator::inject(composite_propagator, current_ctx, current_carrier)
    
    // æ·»åŠ æœåŠ¡ç‰¹å®šçš„å¤´éƒ¨
    TextMapCarrier::set(current_carrier, "x-service-name", services[i])
    TextMapCarrier::set(current_carrier, "x-service-version", "1.0." + i.to_string())
    
    // æ¨¡æ‹Ÿç½‘ç»œä¼ è¾“åçš„æå–
    let extracted_ctx = CompositePropagator::extract(composite_propagator, current_carrier)
    
    // æ·»åŠ æœåŠ¡ç‰¹å®šçš„ä¸Šä¸‹æ–‡
    let service_key = ContextKey::new("service." + i.to_string() + ".processed")
    let ctx_with_service = Context::with_value(extracted_ctx, service_key, "true")
    
    contexts.push(ctx_with_service)
    carriers.push(current_carrier)
  }
  
  // éªŒè¯ä¼ æ’­é“¾çš„å®Œæ•´æ€§
  assert_true(contexts.length() == services.length() + 1)
  assert_true(carriers.length() == services.length())
  
  // éªŒè¯åˆå§‹ä¿¡æ¯åœ¨æ‰€æœ‰æœåŠ¡ä¸­éƒ½å¯è®¿é—®ï¼ˆåœ¨ç®€åŒ–å®ç°ä¸­å¯èƒ½æœ‰é™åˆ¶ï¼‰
  let final_ctx = contexts[contexts.length() - 1]
  let final_user = Context::get(final_ctx, user_key)
  let final_request_id = Context::get(final_ctx, request_id_key)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¿™äº›å¯èƒ½è¿”å›Noneï¼Œè¿™æ˜¯æ­£å¸¸çš„
  match final_user {
    Some(value) => assert_eq(value, "user-12345")
    None => assert_true(true)
  }
  
  match final_request_id {
    Some(value) => assert_eq(value, "req-abcde-12345")
    None => assert_true(true)
  }
  
  assert_true(true)
}

test "æ—¶é—´ç›¸å…³æ“ä½œç²¾åº¦æµ‹è¯•" {
  // æµ‹è¯•æ—¶é—´ç›¸å…³æ“ä½œçš„ç²¾åº¦å’Œä¸€è‡´æ€§
  let clock = Clock::system()
  
  // æµ‹è¯•æ—¶é—´æˆ³çš„ç²¾åº¦å’Œä¸€è‡´æ€§
  let timestamps = []
  for i in 0..100 {
    let timestamp = Clock::now_unix_nanos(clock)
    timestamps.push(timestamp)
  }
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œæ‰€æœ‰æ—¶é—´æˆ³åº”è¯¥ç›¸åŒ
  for i in 1..timestamps.length() {
    assert_eq(timestamps[i], timestamps[0])
  }
  
  // æµ‹è¯•æ—¶é—´æˆ³çš„åˆç†æ€§
  let base_timestamp = timestamps[0]
  assert_true(base_timestamp > 1700000000000000000L) // 2023å¹´ä¹‹å
  assert_true(base_timestamp < 1900000000000000000L) // 2030å¹´ä¹‹å‰
  
  // æµ‹è¯•æ—¶é—´æˆ³åœ¨æ—¥å¿—è®°å½•ä¸­çš„ä½¿ç”¨
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "timestamp.test")
  
  for i in 0..10 {
    let log_timestamp = Clock::now_unix_nanos(clock)
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Timestamp test " + i.to_string()),
      None,
      Some(log_timestamp),
      Some(log_timestamp + 1000L), // 1å¾®ç§’åçš„è§‚å¯Ÿæ—¶é—´
      None,
      None,
      None
    )
    Logger::emit(logger, log_record)
    
    // éªŒè¯æ—¶é—´æˆ³è®¾ç½®æ­£ç¡®
    assert_eq(log_record.timestamp, Some(log_timestamp))
    assert_eq(log_record.observed_timestamp, Some(log_timestamp + 1000L))
  }
  
  // æµ‹è¯•æ—¶é—´æˆ³åœ¨Spanä¸­çš„ä½¿ç”¨
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "timestamp.test")
  
  let span_start_time = Clock::now_unix_nanos(clock)
  let span = Tracer::start_span(tracer, "timestamp.test.span")
  let span_end_time = Clock::now_unix_nanos(clock)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œå¼€å§‹å’Œç»“æŸæ—¶é—´åº”è¯¥ç›¸åŒ
  assert_eq(span_start_time, span_end_time)
  
  Span::end(span)
  
  assert_true(true)
}