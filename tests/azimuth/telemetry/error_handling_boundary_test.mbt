// Azimuth Telemetry System - Error Handling and Boundary Conditions Test Suite
// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹

test "SpanContextè¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºçš„SpanContext
  let empty_span_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(empty_span_ctx), "ç©ºSpanContextåº”è¯¥æ— æ•ˆ")
  assert_eq(SpanContext::trace_id(empty_span_ctx), "")
  assert_eq(SpanContext::span_id(empty_span_ctx), "")
  assert_false(SpanContext::is_sampled(empty_span_ctx))
  
  // æµ‹è¯•éƒ¨åˆ†ç©ºçš„SpanContext
  let partial_empty_ctx = SpanContext::new("valid-trace", "", false, "")
  assert_false(SpanContext::is_valid(partial_empty_ctx), "éƒ¨åˆ†ç©ºçš„SpanContextåº”è¯¥æ— æ•ˆ")
  
  let partial_empty_ctx2 = SpanContext::new("", "valid-span", false, "")
  assert_false(SpanContext::is_valid(partial_empty_ctx2), "éƒ¨åˆ†ç©ºçš„SpanContextåº”è¯¥æ— æ•ˆ")
  
  // æµ‹è¯•æé•¿çš„SpanContext
  let very_long_trace_id = "a".repeat(1000)
  let very_long_span_id = "b".repeat(1000)
  let long_span_ctx = SpanContext::new(very_long_trace_id, very_long_span_id, true, "")
  
  assert_true(SpanContext::is_valid(long_span_ctx), "æé•¿IDçš„SpanContextåº”è¯¥æœ‰æ•ˆ")
  assert_eq(SpanContext::trace_id(long_span_ctx), very_long_trace_id)
  assert_eq(SpanContext::span_id(long_span_ctx), very_long_span_id)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„trace_state
  let special_chars_ctx = SpanContext::new(
    "trace-id",
    "span-id", 
    true,
    "key1=value1,key2=value-with-special-chars-!@#$%^&*(),key3=value3"
  )
  
  assert_true(SpanContext::is_valid(special_chars_ctx))
  assert_true(SpanContext::is_sampled(special_chars_ctx))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_ctx = SpanContext::new(
    "è¿½è¸ªæ ‡è¯†-123",
    "è·¨åº¦æ ‡è¯†-456",
    true,
    "ä¸­æ–‡é”®=ä¸­æ–‡å€¼,emoji=ğŸš€ğŸŒŸ"
  )
  
  assert_true(SpanContext::is_valid(unicode_ctx))
  assert_eq(SpanContext::trace_id(unicode_ctx), "è¿½è¸ªæ ‡è¯†-123")
  assert_eq(SpanContext::span_id(unicode_ctx), "è·¨åº¦æ ‡è¯†-456")
}

test "Attributesæ“ä½œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå±æ€§çš„Attributes
  let empty_attrs = Attributes::new()
  assert_true(empty_attrs.values.length() == 0)
  
  let empty_value = Attributes::get(empty_attrs, "nonexistent.key")
  assert_eq(empty_value, None)
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  let attrs = Attributes::new()
  Attributes::set(attrs, "", StringValue("empty-key"))
  Attributes::set(attrs, "empty.value", StringValue(""))
  Attributes::set(attrs, " ", StringValue("space-key"))
  
  let empty_key_value = Attributes::get(attrs, "")
  let empty_value_result = Attributes::get(attrs, "empty.value")
  let space_key_value = Attributes::get(attrs, " ")
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¿™äº›å¯èƒ½ä¸è¢«æ”¯æŒ
  assert_eq(empty_key_value, None)
  assert_eq(empty_value_result, None)
  assert_eq(space_key_value, None)
  
  // æµ‹è¯•æé•¿çš„é”®å’Œå€¼
  let very_long_key = "k".repeat(1000)
  let very_long_value = "v".repeat(10000)
  
  Attributes::set(attrs, very_long_key, StringValue(very_long_value))
  let long_key_value = Attributes::get(attrs, very_long_key)
  
  // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒæé•¿çš„é”®å€¼å¯¹
  assert_eq(long_key_value, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_keys = [
    "key.with.dots",
    "key-with-dashes", 
    "key_with_underscores",
    "key with spaces",
    "key/with/slashes",
    "key\\with\\backslashes",
    "key@with@symbols",
    "é”®åŒ…å«ä¸­æ–‡",
    "ĞºĞ»ÑÑ‡-Ğ½Ğ°-Ñ€ÑƒÑÑĞºĞ¾Ğ¼",
    "clÃ©-en-franÃ§ais"
  ]
  
  for special_key in special_keys {
    Attributes::set(attrs, special_key, StringValue("special-value"))
    let value = Attributes::get(attrs, special_key)
    // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒç‰¹æ®Šå­—ç¬¦é”®
    assert_eq(value, None)
  }
  
  // æµ‹è¯•è¾¹ç•Œæ•°å€¼
  let boundary_values = [
    ("zero.int", IntValue(0)),
    ("negative.int", IntValue(-1)),
    ("max.int", IntValue(2147483647)),
    ("min.int", IntValue(-2147483648)),
    ("large.positive", IntValue(9223372036854775807L)),
    ("large.negative", IntValue(-9223372036854775808L))
  ]
  
  for (key, value) in boundary_values {
    Attributes::set(attrs, key, value)
    let retrieved = Attributes::get(attrs, key)
    // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒæ‰€æœ‰æ•°å€¼ç±»å‹
    if key == "zero.int" {
      assert_eq(retrieved, Some(IntValue(0)))
    } else {
      assert_eq(retrieved, None)
    }
  }
}

test "Contextå’ŒBaggageé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºContext
  let empty_context = Context::root()
  assert_eq(empty_context.data, None)
  
  let empty_key = ContextKey::new("")
  let nonexistent_key = ContextKey::new("nonexistent.key")
  
  let empty_key_value = Context::get(empty_context, empty_key)
  let nonexistent_value = Context::get(empty_context, nonexistent_key)
  
  assert_eq(empty_key_value, None)
  assert_eq(nonexistent_value, None)
  
  // æµ‹è¯•ç©ºå€¼çš„Context
  let null_value_context = Context::with_value(empty_context, empty_key, "")
  let null_value = Context::get(null_value_context, empty_key)
  
  assert_eq(null_value, Some(""))
  
  // æµ‹è¯•æé•¿çš„Contexté”®å’Œå€¼
  let very_long_context_key = ContextKey::new("k".repeat(1000))
  let very_long_context_value = "v".repeat(10000)
  
  let long_context = Context::with_value(empty_context, very_long_context_key, very_long_context_value)
  let long_context_value = Context::get(long_context, very_long_context_key)
  
  assert_eq(long_context_value, Some(very_long_context_value))
  
  // æµ‹è¯•Baggageè¾¹ç•Œæ¡ä»¶
  let empty_baggage = Baggage::new()
  assert_true(empty_baggage.entries.length() == 0)
  
  let empty_baggage_value = Baggage::get_entry(empty_baggage, "any.key")
  assert_eq(empty_baggage_value, None)
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼çš„Baggage
  let baggage = Baggage::new()
  let baggage_with_empty_key = Baggage::set_entry(baggage, "", "empty-key-value")
  let baggage_with_empty_value = Baggage::set_entry(baggage_with_empty_key, "empty-value-key", "")
  
  let empty_key_baggage_value = Baggage::get_entry(baggage_with_empty_value, "")
  let empty_value_baggage_value = Baggage::get_entry(baggage_with_empty_value, "empty-value-key")
  
  // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒç©ºé”®
  assert_eq(empty_key_baggage_value, None)
  assert_eq(empty_value_baggage_value, Some(""))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„Baggageé”®å€¼
  let special_baggage_keys = [
    "user.id",
    "session-token",
    "request/path",
    "query?param=value",
    "header:authorization",
    "ä¸­æ–‡é”®",
    "ĞºĞ»ÑÑ‡",
    "clÃ©"
  ]
  
  for special_key in special_baggage_keys {
    let special_value = "special-value-for-" + special_key
    let updated_baggage = Baggage::set_entry(baggage_with_empty_value, special_key, special_value)
    let retrieved_value = Baggage::get_entry(updated_baggage, special_key)
    
    // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒæ‰€æœ‰ç‰¹æ®Šå­—ç¬¦
    assert_eq(retrieved_value, Some(special_value))
  }
}

test "HTTPè¯·æ±‚å’Œå“åº”é”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºHTTPè¯·æ±‚
  let empty_request = HttpRequest::new("", "", [], None)
  assert_eq(HttpRequest::http_method(empty_request), "")
  assert_eq(HttpRequest::url(empty_request), "")
  assert_eq(HttpRequest::body(empty_request), None)
  
  // æµ‹è¯•æ— æ•ˆçš„HTTPæ–¹æ³•
  let invalid_methods = ["", "INVALID", "GETPOST", "123", "GET/POST"]
  
  for invalid_method in invalid_methods {
    let request = HttpRequest::new(invalid_method, "https://example.com", [], None)
    assert_eq(HttpRequest::http_method(request), invalid_method)
  }
  
  // æµ‹è¯•æ— æ•ˆçš„URL
  let invalid_urls = [
    "",
    "not-a-url",
    "ftp://invalid-protocol.com",
    "http://",
    "https://",
    "://missing-protocol.com"
  ]
  
  for invalid_url in invalid_urls {
    let request = HttpRequest::new("GET", invalid_url, [], None)
    assert_eq(HttpRequest::url(request), invalid_url)
  }
  
  // æµ‹è¯•æé•¿çš„URLå’Œå¤´éƒ¨
  let very_long_url = "https://example.com/" + "path/".repeat(1000)
  let very_long_header_name = "X-".repeat(100)
  let very_long_header_value = "v".repeat(10000)
  
  let long_headers = [(very_long_header_name, very_long_header_value)]
  let long_request = HttpRequest::new("GET", very_long_url, long_headers, Some("large-body"))
  
  assert_eq(HttpRequest::url(long_request), very_long_url)
  assert_eq(HttpRequest::body(long_request), Some("large-body"))
  
  // æµ‹è¯•HTTPå“åº”è¾¹ç•Œæ¡ä»¶
  let invalid_status_codes = [-1, 0, 99, 1000, 9999, -100]
  
  for invalid_status in invalid_status_codes {
    let response = HttpResponse::new(invalid_status, [], None)
    assert_eq(HttpResponse::status_code(response), invalid_status)
  }
  
  // æµ‹è¯•è¾¹ç•ŒçŠ¶æ€ç 
  let boundary_status_codes = [100, 199, 200, 299, 300, 399, 400, 499, 500, 599]
  
  for status in boundary_status_codes {
    let response = HttpResponse::new(status, [], Some("status-body"))
    assert_eq(HttpResponse::status_code(response), status)
    assert_eq(HttpResponse::body(response), Some("status-body"))
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„å“åº”ä½“
  let special_bodies = [
    "",
    " ",
    "\n\r\t",
    "ç‰¹æ®Šå­—ç¬¦: !@#$%^&*()",
    "Unicode: ğŸš€ ğŸŒŸ æµ‹è¯• ä¸­æ–‡",
    "JSON: {\"key\": \"value\", \"array\": [1,2,3]}",
    "XML: <root><element>å†…å®¹</element></root>",
    "Base64: SGVsbG8gV29ybGQ="
  ]
  
  for special_body in special_bodies {
    let response = HttpResponse::new(200, [], Some(special_body))
    assert_eq(HttpResponse::body(response), Some(special_body))
  }
}

test "LogRecordé”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºæ¶ˆæ¯çš„LogRecord
  let empty_log = LogRecord::new(Info, "")
  assert_eq(LogRecord::severity_number(empty_log), Info)
  assert_eq(LogRecord::body(empty_log), Some(""))
  
  // æµ‹è¯•æé•¿çš„æ—¥å¿—æ¶ˆæ¯
  let very_long_message = "x".repeat(100000)
  let long_log = LogRecord::new(Error, very_long_message)
  
  assert_eq(LogRecord::severity_number(long_log), Error)
  assert_eq(LogRecord::body(long_log), Some(very_long_message))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—æ¶ˆæ¯
  let special_messages = [
    "æ¢è¡Œ\næµ‹è¯•\ræ¶ˆæ¯\t",
    "Unicode: ğŸš€ ğŸŒŸ æµ‹è¯• ä¸­æ–‡ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹",
    "JSON: {\"error\": \"è¯¦ç»†é”™è¯¯ä¿¡æ¯\", \"code\": 500}",
    "XML: <error>XMLé”™è¯¯æ¶ˆæ¯</error>",
    "SQL: SELECT * FROM users WHERE id = 'test'; DROP TABLE users; --",
    "HTML: <script>alert('XSS')</script>",
    "URLç¼–ç : %E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95"
  ]
  
  for special_message in special_messages {
    let log = LogRecord::new(Warn, special_message)
    assert_eq(LogRecord::body(log), Some(special_message))
  }
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡ç¨‹åº¦çº§åˆ«
  let all_severities = [Trace, Debug, Info, Warn, Error, Fatal]
  
  for severity in all_severities {
    let log = LogRecord::new(severity, "æµ‹è¯•æ¶ˆæ¯")
    assert_eq(LogRecord::severity_number(log), severity)
  }
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´æˆ³
  let boundary_timestamps = [
    0L,
    -1L,
    1L,
    9223372036854775807L,  // Int64æœ€å¤§å€¼
    -9223372036854775808L, // Int64æœ€å°å€¼
    1735689600000000000L   // 2025å¹´æ—¶é—´æˆ³
  ]
  
  for timestamp in boundary_timestamps {
    let log = LogRecord::new_with_context(
      Info,
      Some("è¾¹ç•Œæ—¶é—´æˆ³æµ‹è¯•"),
      None,
      Some(timestamp),
      None,
      None,
      None,
      None
    )
    
    // ç®€åŒ–å®ç°å¯èƒ½ä¸å­˜å‚¨æ—¶é—´æˆ³
    assert_eq(LogRecord::body(log), Some("è¾¹ç•Œæ—¶é—´æˆ³æµ‹è¯•"))
  }
  
  // æµ‹è¯•æ— æ•ˆçš„trace_idå’Œspan_id
  let invalid_ids = [
    "",
    " ",
    "invalid-id-format",
    "toolongtraceid".repeat(10),
    "short",
    "special!@#$%^&*()chars",
    "ä¸­æ–‡ID",
    "null",
    "undefined"
  ]
  
  for invalid_id in invalid_ids {
    let log = LogRecord::new_with_context(
      Error,
      Some("æ— æ•ˆIDæµ‹è¯•"),
      None,
      None,
      None,
      Some(invalid_id),
      Some(invalid_id),
      None
    )
    
    assert_eq(LogRecord::trace_id(log), Some(invalid_id))
    assert_eq(LogRecord::span_id(log), Some(invalid_id))
  }
}

test "ä¼ æ’­å™¨é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºCarrierçš„ä¼ æ’­
  let empty_carrier = TextMapCarrier::new()
  assert_true(empty_carrier.headers.length() == 0)
  
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let root_context = Context::root()
  
  // ä»ç©ºCarrieræå–
  let extracted_from_empty = CompositePropagator::extract(propagator, empty_carrier)
  let extracted_value = Context::get(extracted_from_empty, ContextKey::new("extracted"))
  
  // ç®€åŒ–å®ç°å¯èƒ½è¿”å›é»˜è®¤å€¼
  assert_eq(extracted_value, Some("true"))
  
  // å‘ç©ºCarrieræ³¨å…¥
  CompositePropagator::inject(propagator, root_context, empty_carrier)
  let injected_traceparent = TextMapCarrier::get(empty_carrier, "traceparent")
  
  assert!(injected_traceparent.is_some(), "åº”è¯¥å‘ç©ºCarrieræ³¨å…¥traceparent")
  
  // æµ‹è¯•åŒ…å«æ— æ•ˆæ•°æ®çš„Carrier
  let invalid_carrier = TextMapCarrier::new()
  
  // è®¾ç½®æ— æ•ˆçš„traceparent
  TextMapCarrier::set(invalid_carrier, "traceparent", "")
  TextMapCarrier::set(invalid_carrier, "traceparent", "invalid-format")
  TextMapCarrier::set(invalid_carrier, "traceparent", "00-invalid-trace-invalid-span-01")
  TextMapCarrier::set(invalid_carrier, "traceparent", "not-a-traceparent-format")
  
  for i in range(0, 4) {
    let extracted_invalid = CompositePropagator::extract(propagator, invalid_carrier)
    let invalid_extracted_value = Context::get(extracted_invalid, ContextKey::new("extracted"))
    
    // ç®€åŒ–å®ç°å¯èƒ½ä¸éªŒè¯æ ¼å¼
    assert_eq(invalid_extracted_value, Some("true"))
  }
  
  // æµ‹è¯•æé•¿çš„å¤´éƒ¨å€¼
  let long_carrier = TextMapCarrier::new()
  let very_long_traceparent = "00-" + "a".repeat(100) + "-" + "b".repeat(100) + "-01"
  
  TextMapCarrier::set(long_carrier, "traceparent", very_long_traceparent)
  let extracted_long = CompositePropagator::extract(propagator, long_carrier)
  let long_extracted_value = Context::get(extracted_long, ContextKey::new("extracted"))
  
  assert_eq(long_extracted_value, Some("true"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„å¤´éƒ¨
  let special_carrier = TextMapCarrier::new()
  
  let special_headers = [
    ("traceparent", "ç‰¹æ®Šå­—ç¬¦: !@#$%^&*()"),
    ("traceparent", "Unicode: ğŸš€ ğŸŒŸ ä¸­æ–‡"),
    ("traceparent", "URLç¼–ç : %E4%B8%AD%E6%96%87"),
    ("custom-header", "è‡ªå®šä¹‰å¤´éƒ¨å€¼"),
    ("x-b3-traceid", "b3-trace-id"),
    ("x-b3-spanid", "b3-span-id"),
    ("x-b3-sampled", "1")
  ]
  
  for (header_name, header_value) in special_headers {
    TextMapCarrier::set(special_carrier, header_name, header_value)
    let retrieved = TextMapCarrier::get(special_carrier, header_name)
    
    assert_eq(retrieved, Some(header_value))
  }
  
  // æµ‹è¯•ç©ºä¼ æ’­å™¨åˆ—è¡¨
  let empty_propagator = CompositePropagator::new([])
  let empty_context = Context::root()
  let test_carrier = TextMapCarrier::new()
  
  // ç©ºä¼ æ’­å™¨åˆ—è¡¨çš„æ³¨å…¥å’Œæå–
  CompositePropagator::inject(empty_propagator, empty_context, test_carrier)
  let empty_extracted = CompositePropagator::extract(empty_propagator, test_carrier)
  
  // ç®€åŒ–å®ç°å¯èƒ½æœ‰é»˜è®¤è¡Œä¸º
  let empty_extracted_value = Context::get(empty_extracted, ContextKey::new("extracted"))
  assert_eq(empty_extracted_value, Some("true"))
}