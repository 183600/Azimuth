// è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µã€å¼‚å¸¸è¾“å…¥å’Œé”™è¯¯å¤„ç†æœºåˆ¶

test "ç©ºå­—ç¬¦ä¸²å’Œnullå€¼è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²çš„SpanContext
  let empty_trace_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²ä½†æœ‰æ•ˆçš„span_id
  let partial_valid_ctx = SpanContext::new("valid_trace_id", "", true, "")
  assert_false(SpanContext::is_valid(partial_valid_ctx))
  
  // æµ‹è¯•ç©ºçš„å±æ€§
  let empty_attrs = Attributes::new()
  assert_true(empty_attrs.values.length() == 0)
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å±æ€§
  let non_existent = Attributes::get(empty_attrs, "non.existent.key")
  assert_eq(non_existent, None)
}

test "æ•°å€¼è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•æå¤§å€¼å’Œæå°å€¼
  let large_int_attr = IntValue(2147483647)  // Intæœ€å¤§å€¼
  let small_int_attr = IntValue(-2147483648) // Intæœ€å°å€¼
  let zero_int_attr = IntValue(0)
  
  let large_float_attr = FloatValue(1.7976931348623157e+308) // Doubleæœ€å¤§å€¼
  let small_float_attr = FloatValue(-1.7976931348623157e+308) // Doubleæœ€å°å€¼
  let zero_float_attr = FloatValue(0.0)
  let nan_float_attr = FloatValue(0.0/0.0) // NaN
  
  // æµ‹è¯•Counterçš„æå€¼æ“ä½œ
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary_test")
  let counter = Meter::create_counter(meter, "boundary_counter")
  
  // æµ‹è¯•æ·»åŠ æå€¼
  Counter::add(counter, 1.7976931348623157e+308) // æœ€å¤§Doubleå€¼
  Counter::add(counter, -1.7976931348623157e+308) // æœ€å°Doubleå€¼
  Counter::add(counter, 0.0) // é›¶å€¼
}

test "å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let very_long_string = "a" * 10000  // 10000ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²
  let long_attr = StringValue(very_long_string)
  
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²
  let unicode_string = "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸²ğŸš€emojiå’Œç‰¹æ®Šå­—ç¬¦\n\t\r"
  let unicode_attr = StringValue(unicode_string)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_string = StringValue("")
  
  // æµ‹è¯•åªæœ‰ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let whitespace_string = StringValue("   \n\t   ")
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?")
}

test "é›†åˆè¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•ç©ºé›†åˆ
  let empty_array_string = ArrayStringValue([])
  let empty_array_int = ArrayIntValue([])
  
  // æµ‹è¯•å•å…ƒç´ é›†åˆ
  let single_element_string = ArrayStringValue(["single"])
  let single_element_int = ArrayIntValue([1])
  
  // æµ‹è¯•å¤§é‡å…ƒç´ çš„é›†åˆ
  let large_array = Array[String]()
  for i = 0; i < 1000; i = i + 1 {
    large_array.push("element_${i}")
  }
  let large_array_attr = ArrayStringValue(large_array)
}

test "æ—¶é—´æˆ³è¾¹ç•Œæµ‹è¯•" {
  let clock = Clock::system()
  
  // æµ‹è¯•ç³»ç»Ÿæ—¶é’Ÿ
  let current_time = Clock::now_unix_nanos(clock)
  assert_true(current_time > 0L)
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´æˆ³
  let min_timestamp = 0L
  let max_timestamp = 9223372036854775807L // Int64æœ€å¤§å€¼
  let negative_timestamp = -1L
  
  // æµ‹è¯•å¸¦æœ‰è¾¹ç•Œæ—¶é—´æˆ³çš„LogRecord
  let min_time_record = LogRecord::new_with_context(
    Info, 
    Some("æœ€å°æ—¶é—´æˆ³æµ‹è¯•"), 
    None, 
    Some(min_timestamp), 
    None, 
    None, 
    None, 
    None
  )
  
  let max_time_record = LogRecord::new_with_context(
    Error, 
    Some("æœ€å¤§æ—¶é—´æˆ³æµ‹è¯•"), 
    None, 
    Some(max_timestamp), 
    None, 
    None, 
    None, 
    None
  )
}

test "HTTPè¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•è¾¹ç•ŒHTTPçŠ¶æ€ç 
  let min_status_response = HttpResponse::new(0, [], None)
  let max_status_response = HttpResponse::new(999, [], None)
  let negative_status_response = HttpResponse::new(-1, [], None)
  
  assert_eq(HttpResponse::status_code(min_status_response), 0)
  assert_eq(HttpResponse::status_code(max_status_response), 999)
  assert_eq(HttpResponse::status_code(negative_status_response), -1)
  
  // æµ‹è¯•ç©ºURLå’Œç©ºæ–¹æ³•çš„HTTPè¯·æ±‚
  let empty_request = HttpRequest::new("", "", [], None)
  assert_eq(HttpRequest::http_method(empty_request), "")
  assert_eq(HttpRequest::url(empty_request), "")
  assert_eq(HttpRequest::body(empty_request), None)
  
  // æµ‹è¯•è¶…é•¿URL
  let long_url = "https://example.com/" + "a" * 10000
  let long_url_request = HttpRequest::new("GET", long_url, [], Some("test body"))
  assert_eq(HttpRequest::http_method(long_url_request), "GET")
}

test "ä¸Šä¸‹æ–‡è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•æ ¹ä¸Šä¸‹æ–‡
  let root_ctx = Context::root()
  assert_eq(root_ctx.data, None)
  
  // æµ‹è¯•ç©ºé”®çš„ä¸Šä¸‹æ–‡
  let empty_key = ContextKey::new("")
  let ctx_with_empty_key = Context::with_value(root_ctx, empty_key, "value")
  let retrieved_empty = Context::get(ctx_with_empty_key, empty_key)
  assert_eq(retrieved_empty, Some("value"))
  
  // æµ‹è¯•ç©ºå€¼çš„ä¸Šä¸‹æ–‡
  let normal_key = ContextKey::new("test.key")
  let ctx_with_empty_value = Context::with_value(root_ctx, normal_key, "")
  let retrieved_empty_value = Context::get(ctx_with_empty_value, normal_key)
  assert_eq(retrieved_empty_value, Some(""))
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„é”®
  let non_existent_key = ContextKey::new("non.existent.key")
  let non_existent_value = Context::get(root_ctx, non_existent_key)
  assert_eq(non_existent_value, None)
}