// Azimuth Telemetry System - è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•
// æµ‹è¯•ç³»ç»Ÿåœ¨å„ç§è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸º

test "ç©ºå€¼å’ŒNoneå€¼å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å¤„ç†
  let empty_trace_id = ""
  let empty_span_id = ""
  let empty_span_ctx = SpanContext::new(empty_trace_id, empty_span_id, false, "")
  assert_false(SpanContext::is_valid(empty_span_ctx))
  assert_eq(SpanContext::trace_id(empty_span_ctx), "")
  assert_eq(SpanContext::span_id(empty_span_ctx), "")
  
  // æµ‹è¯•Noneå€¼çš„å¤„ç†
  let attrs = Attributes::new()
  let nonexistent_attr = Attributes::get(attrs, "nonexistent.key")
  assert_eq(nonexistent_attr, None)
  
  // æµ‹è¯•Optionç±»å‹ä¸ºNoneçš„æƒ…å†µ
  let no_version = None
  let no_schema_url = None
  let scope = InstrumentationScope::{ 
    name: "test-scope", 
    version: no_version, 
    schema_url: no_schema_url 
  }
  assert_eq(scope.name, "test-scope")
  assert_eq(scope.version, None)
  assert_eq(scope.schema_url, None)
  
  // æµ‹è¯•ç©ºçš„Baggage
  let empty_baggage = Baggage::new()
  let empty_entry = Baggage::get_entry(empty_baggage, "any.key")
  assert_eq(empty_entry, None)
  
  // æµ‹è¯•ç©ºçš„TextMapCarrier
  let empty_carrier = TextMapCarrier::new()
  let empty_header = TextMapCarrier::get(empty_carrier, "any.header")
  assert_eq(empty_header, None)
  
  // æµ‹è¯•LogRecordçš„Noneå€¼å¤„ç†
  let log_with_none_body = LogRecord::new(Info, "")
  let body_result = LogRecord::body(log_with_none_body)
  // æ³¨æ„ï¼šç©ºå­—ç¬¦ä¸²å’ŒNoneçš„å¤„ç†å¯èƒ½æœ‰å·®å¼‚
}

test "æå€¼å’Œè¾¹ç•Œæ•°æ®æµ‹è¯•" {
  // æµ‹è¯•æå¤§çš„æ•°å€¼
  let max_int = Int::max_value()
  let min_int = Int::min_value()
  let max_double = Double::max_value()
  let min_double = Double::min_value()
  
  let attrs = Attributes::new()
  Attributes::set(attrs, "max.int", IntValue(max_int))
  Attributes::set(attrs, "min.int", IntValue(min_int))
  Attributes::set(attrs, "max.double", FloatValue(max_double))
  Attributes::set(attrs, "min.double", FloatValue(min_double))
  
  // æµ‹è¯•è·å–æå€¼å±æ€§
  let max_int_result = Attributes::get(attrs, "max.int")
  let min_int_result = Attributes::get(attrs, "min.int")
  
  // æ³¨æ„ï¼šç®€åŒ–å®ç°å¯èƒ½æ— æ³•å¤„ç†æ‰€æœ‰æå€¼
  
  // æµ‹è¯•é›¶å€¼å’Œè´Ÿå€¼
  Attributes::set(attrs, "zero.int", IntValue(0))
  Attributes::set(attrs, "negative.int", IntValue(-1))
  Attributes::set(attrs, "zero.double", FloatValue(0.0))
  Attributes::set(attrs, "negative.double", FloatValue(-1.0))
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²
  let very_long_string = "a" * 10000
  Attributes::set(attrs, "long.string", StringValue(very_long_string))
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_array = Array[String]::new()
  Attributes::set(attrs, "empty.array", ArrayStringValue(empty_array))
  
  // æµ‹è¯•æå¤§æ•°ç»„
  let large_array = Array[String]::new()
  // æ³¨æ„ï¼šåœ¨å®é™…æµ‹è¯•ä¸­å¯èƒ½éœ€è¦é™åˆ¶æ•°ç»„å¤§å°
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´æˆ³
  let zero_timestamp = 0L
  let max_timestamp = 9223372036854775807L  // Int64::max_value()
  let negative_timestamp = -1L
  
  let log_with_zero_time = LogRecord::new_with_context(
    Info, 
    Some("Zero timestamp"), 
    None, 
    Some(zero_timestamp), 
    None, 
    None, 
    None, 
    None
  )
  
  let log_with_max_time = LogRecord::new_with_context(
    Info, 
    Some("Max timestamp"), 
    None, 
    Some(max_timestamp), 
    None, 
    None, 
    None, 
    None
  )
  
  assert_eq(LogRecord::body(log_with_zero_time), Some("Zero timestamp"))
  assert_eq(LogRecord::body(log_with_max_time), Some("Max timestamp"))
}

test "ç‰¹æ®Šå­—ç¬¦å’Œç¼–ç æµ‹è¯•" {
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸² ğŸš€ emoji"
  let attrs = Attributes::new()
  Attributes::set(attrs, "unicode.key", StringValue(unicode_string))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  Attributes::set(attrs, "special.chars", StringValue(special_chars))
  
  // æµ‹è¯•æ¢è¡Œç¬¦å’Œåˆ¶è¡¨ç¬¦
  let whitespace_chars = "line1\nline2\ttabbed\r\nwindows"
  Attributes::set(attrs, "whitespace.chars", StringValue(whitespace_chars))
  
  // æµ‹è¯•JSONå­—ç¬¦
  let json_chars = "{\"key\":\"value\", \"array\":[1,2,3]}"
  Attributes::set(attrs, "json.chars", StringValue(json_chars))
  
  // æµ‹è¯•URLç¼–ç å­—ç¬¦
  let url_encoded = "https://example.com/path?param=value%20with%20spaces&other=%E4%B8%AD%E6%96%87"
  Attributes::set(attrs, "url.encoded", StringValue(url_encoded))
  
  // æµ‹è¯•Base64ç¼–ç å­—ç¬¦
  let base64_string = "SGVsbG8gV29ybGQh"
  Attributes::set(attrs, "base64.data", StringValue(base64_string))
  
  // æµ‹è¯•äºŒè¿›åˆ¶æ•°æ®ï¼ˆç”¨Byteæ•°ç»„è¡¨ç¤ºï¼‰
  let binary_data = [0x00, 0x01, 0x02, 0xFF, 0xFE]
  // æ³¨æ„ï¼šå½“å‰å®ç°å¯èƒ½ä¸æ”¯æŒç›´æ¥è®¾ç½®äºŒè¿›åˆ¶æ•°æ®
  
  // æµ‹è¯•HTTPå¤´ä¸­çš„ç‰¹æ®Šå­—ç¬¦
  let carrier = TextMapCarrier::new()
  TextMapCarrier::set(carrier, "user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
  TextMapCarrier::set(carrier, "custom-header", "value with spaces and ç‰¹æ®Šå­—ç¬¦")
  
  let user_agent = TextMapCarrier::get(carrier, "user-agent")
  let custom_header = TextMapCarrier::get(carrier, "custom-header")
  
  // æ³¨æ„ï¼šç®€åŒ–å®ç°å¯èƒ½æ— æ³•å¤„ç†æ‰€æœ‰ç‰¹æ®Šå­—ç¬¦
}

test "å¹¶å‘å’Œçº¿ç¨‹å®‰å…¨è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å¤šä¸ªContextçš„åˆ›å»ºå’Œæ“ä½œ
  let ctx1 = Context::root()
  let ctx2 = Context::root()
  let ctx3 = Context::root()
  
  let key1 = ContextKey::new("key1")
  let key2 = ContextKey::new("key2")
  let key3 = ContextKey::new("key3")
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ
  let ctx1_with_key1 = Context::with_value(ctx1, key1, "value1")
  let ctx2_with_key2 = Context::with_value(ctx2, key2, "value2")
  let ctx3_with_key3 = Context::with_value(ctx3, key3, "value3")
  
  // éªŒè¯ä¸Šä¸‹æ–‡éš”ç¦»
  let value1_from_ctx1 = Context::get(ctx1_with_key1, key1)
  let value1_from_ctx2 = Context::get(ctx2_with_key2, key1)
  let value1_from_ctx3 = Context::get(ctx3_with_key3, key1)
  
  assert_eq(value1_from_ctx1, Some("value1"))
  assert_eq(value1_from_ctx2, None)
  assert_eq(value1_from_ctx3, None)
  
  // æµ‹è¯•å¤šä¸ªSpançš„åˆ›å»ºå’Œç®¡ç†
  let span_ctx1 = SpanContext::new("trace1", "span1", true, "")
  let span_ctx2 = SpanContext::new("trace2", "span2", true, "")
  let span_ctx3 = SpanContext::new("trace3", "span3", true, "")
  
  let span1 = Span::new("span1", Internal, span_ctx1)
  let span2 = Span::new("span2", Server, span_ctx2)
  let span3 = Span::new("span3", Client, span_ctx3)
  
  // éªŒè¯Spanç‹¬ç«‹æ€§
  assert_eq(Span::name(span1), "span1")
  assert_eq(Span::name(span2), "span2")
  assert_eq(Span::name(span3), "span3")
  
  assert_eq(Span::kind(span1), Internal)
  assert_eq(Span::kind(span2), Server)
  assert_eq(Span::kind(span3), Client)
  
  // æµ‹è¯•å¤šä¸ªMeterå’ŒCounterçš„åˆ›å»º
  let meter_provider = MeterProvider::default()
  let meter1 = MeterProvider::get_meter(meter_provider, "meter1")
  let meter2 = MeterProvider::get_meter(meter_provider, "meter2")
  let meter3 = MeterProvider::get_meter(meter_provider, "meter3")
  
  let counter1 = Meter::create_counter(meter1, "counter1")
  let counter2 = Meter::create_counter(meter2, "counter2")
  let counter3 = Meter::create_counter(meter3, "counter3")
  
  // éªŒè¯Meterå’ŒCounterç‹¬ç«‹æ€§
  assert_eq(counter1.name, "counter1")
  assert_eq(counter2.name, "counter2")
  assert_eq(counter3.name, "counter3")
  
  // æµ‹è¯•å¹¶å‘è®°å½•æ“ä½œ
  Counter::add(counter1, 1.0)
  Counter::add(counter2, 2.0)
  Counter::add(counter3, 3.0)
  
  // æµ‹è¯•å¤šä¸ªLoggerçš„åˆ›å»ºå’Œä½¿ç”¨
  let logger_provider = LoggerProvider::default()
  let logger1 = LoggerProvider::get_logger(logger_provider, "logger1")
  let logger2 = LoggerProvider::get_logger(logger_provider, "logger2")
  let logger3 = LoggerProvider::get_logger(logger_provider, "logger3")
  
  let log1 = LogRecord::new(Info, "Log from logger1")
  let log2 = LogRecord::new(Warn, "Log from logger2")
  let log3 = LogRecord::new(Error, "Log from logger3")
  
  // æµ‹è¯•å¹¶å‘æ—¥å¿—å‘å°„
  Logger::emit(logger1, log1)
  Logger::emit(logger2, log2)
  Logger::emit(logger3, log3)
}

test "å†…å­˜å’Œèµ„æºé™åˆ¶è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å¤§é‡å±æ€§çš„åˆ›å»º
  let attrs = Attributes::new()
  
  // åˆ›å»ºå¤šä¸ªå±æ€§ï¼ˆæ¨¡æ‹Ÿå†…å­˜å‹åŠ›ï¼‰
  for i = 0; i < 100; i = i + 1 {
    let key = "key." + i.to_string()
    let value = StringValue("value." + i.to_string())
    Attributes::set(attrs, key, value)
  }
  
  // æµ‹è¯•å¤§é‡Baggageæ¡ç›®
  let baggage = Baggage::new()
  
  // åˆ›å»ºå¤šä¸ªBaggageæ¡ç›®
  for i = 0; i < 50; i = i + 1 {
    let key = "baggage.key." + i.to_string()
    let value = "baggage.value." + i.to_string()
    baggage = Baggage::set_entry(baggage, key, value)
  }
  
  // æµ‹è¯•å¤§é‡HTTPå¤´
  let carrier = TextMapCarrier::new()
  
  // åˆ›å»ºå¤šä¸ªHTTPå¤´
  for i = 0; i < 20; i = i + 1 {
    let header_name = "header-" + i.to_string()
    let header_value = "value-" + i.to_string()
    TextMapCarrier::set(carrier, header_name, header_value)
  }
  
  // æµ‹è¯•å¤§é‡Spançš„åˆ›å»º
  let spans = Array[Span]::new()
  
  // åˆ›å»ºå¤šä¸ªSpan
  for i = 0; i < 10; i = i + 1 {
    let trace_id = "trace-" + i.to_string()
    let span_id = "span-" + i.to_string()
    let span_ctx = SpanContext::new(trace_id, span_id, true, "")
    let span = Span::new("span-" + i.to_string(), Internal, span_ctx)
    spans.push(span)
  }
  
  // éªŒè¯æ‰€æœ‰Spanéƒ½è¢«æ­£ç¡®åˆ›å»º
  assert_eq(spans.length(), 10)
  
  // æµ‹è¯•å¤§é‡LogRecordçš„åˆ›å»º
  let log_records = Array[LogRecord]::new()
  
  // åˆ›å»ºå¤šä¸ªLogRecord
  for i = 0; i < 10; i = i + 1 {
    let log = LogRecord::new(Info, "Log message " + i.to_string())
    log_records.push(log)
  }
  
  // éªŒè¯æ‰€æœ‰LogRecordéƒ½è¢«æ­£ç¡®åˆ›å»º
  assert_eq(log_records.length(), 10)
  
  // æµ‹è¯•Resourceçš„å±æ€§åˆå¹¶æ€§èƒ½
  let base_attrs = Array[(String, AttributeValue)]::new()
  for i = 0; i < 50; i = i + 1 {
    base_attrs.push(("base.key." + i.to_string(), StringValue("base.value." + i.to_string())))
  }
  
  let override_attrs = Array[(String, AttributeValue)]::new()
  for i = 0; i < 50; i = i + 1 {
    override_attrs.push(("override.key." + i.to_string(), StringValue("override.value." + i.to_string())))
  }
  
  let base_resource = Resource::with_attributes(Resource::new(), base_attrs)
  let override_resource = Resource::with_attributes(Resource::new(), override_attrs)
  let merged = Resource::merge(base_resource, override_resource)
  
  // éªŒè¯åˆå¹¶æ“ä½œå®Œæˆ
  let merged_attr = Resource::get_attribute(merged, "override.key.0")
  // æ³¨æ„ï¼šç®€åŒ–å®ç°å¯èƒ½æ— æ³•æ­£ç¡®å¤„ç†å¤§é‡å±æ€§
}