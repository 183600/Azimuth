// é«˜çº§åºåˆ—åŒ–å’Œæ•°æ®å®Œæ•´æ€§æµ‹è¯•
// Advanced serialization and data integrity tests

test "å±æ€§å€¼åºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒç±»å‹å±æ€§å€¼çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–å®Œæ•´æ€§
  
  let attrs = Attributes::new()
  
  // æµ‹è¯•æ‰€æœ‰å±æ€§å€¼ç±»å‹çš„åºåˆ—åŒ–
  let test_values = [
    ("string_key", StringValue("test_string_value")),
    ("int_key", IntValue(42)),
    ("float_key", FloatValue(3.14159)),
    ("bool_key", BoolValue(true)),
    ("array_string_key", ArrayStringValue(["item1", "item2", "item3"])),
    ("array_int_key", ArrayIntValue([1, 2, 3, 4, 5]))
  ]
  
  // è®¾ç½®å±æ€§å€¼
  for (key, value) in test_values {
    Attributes::set(attrs, key, value)
  }
  
  // éªŒè¯å±æ€§å€¼çš„å®Œæ•´æ€§
  for (key, expected_value) in test_values {
    let retrieved_value = Attributes::get(attrs, key)
    assert_true(retrieved_value.is_some())
    
    match retrieved_value.unwrap() {
      StringValue(s) => {
        match expected_value {
          StringValue(expected) => assert_eq(s, expected)
          _ => assert_true(false, "Expected StringValue but got different type")
        }
      }
      IntValue(i) => {
        match expected_value {
          IntValue(expected) => assert_eq(i, expected)
          _ => assert_true(false, "Expected IntValue but got different type")
        }
      }
      FloatValue(f) => {
        match expected_value {
          FloatValue(expected) => assert_eq(f, expected)
          _ => assert_true(false, "Expected FloatValue but got different type")
        }
      }
      BoolValue(b) => {
        match expected_value {
          BoolValue(expected) => assert_eq(b, expected)
          _ => assert_true(false, "Expected BoolValue but got different type")
        }
      }
      ArrayStringValue(arr) => {
        match expected_value {
          ArrayStringValue(expected) => {
            assert_eq(arr.length(), expected.length())
            for i = 0; i < arr.length(); i = i + 1 {
              assert_eq(arr[i], expected[i])
            }
          }
          _ => assert_true(false, "Expected ArrayStringValue but got different type")
        }
      }
      ArrayIntValue(arr) => {
        match expected_value {
          ArrayIntValue(expected) => {
            assert_eq(arr.length(), expected.length())
            for i = 0; i < arr.length(); i = i + 1 {
              assert_eq(arr[i], expected[i])
            }
          }
          _ => assert_true(false, "Expected ArrayIntValue but got different type")
        }
      }
    }
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeå€¼çš„å¤„ç†
  let special_values = [
    ("unicode_key", StringValue("æµ‹è¯•å€¼_ğŸš€_ĞºĞ»ÑÑ‡")),
    ("empty_string", StringValue("")),
    ("special_chars", StringValue("\n\t\r\"\'\\")),
    ("max_int", IntValue(2147483647)),
    ("min_int", IntValue(-2147483648)),
    ("max_float", FloatValue(1.7976931348623157e308)),
    ("min_float", FloatValue(-1.7976931348623157e308)),
    ("infinity", FloatValue(1.0 / 0.0)),
    ("neg_infinity", FloatValue(-1.0 / 0.0))
  ]
  
  for (key, value) in special_values {
    Attributes::set(attrs, key, value)
    let retrieved = Attributes::get(attrs, key)
    assert_true(retrieved.is_some())
  }
}

test "Spanä¸Šä¸‹æ–‡åºåˆ—åŒ–æµ‹è¯•" {
  // æµ‹è¯•Spanä¸Šä¸‹æ–‡çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  
  // åˆ›å»ºå„ç§Spanä¸Šä¸‹æ–‡
  let test_contexts = [
    SpanContext::new("trace_1234567890123456", "span_1234567890123456", true, "state=value"),
    SpanContext::new("", "", false, ""), // ç©ºä¸Šä¸‹æ–‡
    SpanContext::new("a" * 32, "b" * 16, false, ""), // æœ‰æ•ˆæ ¼å¼ä½†æœªé‡‡æ ·
    SpanContext::new("trace_with_ç‰¹æ®Šå­—ç¬¦", "span_with_ç‰¹æ®Šå­—ç¬¦", true, "ç‰¹æ®ŠçŠ¶æ€")
  ]
  
  for ctx in test_contexts {
    // åºåˆ—åŒ–ä¸Šä¸‹æ–‡ä¿¡æ¯
    let trace_id = SpanContext::trace_id(ctx)
    let span_id = SpanContext::span_id(ctx)
    let is_sampled = SpanContext::is_sampled(ctx)
    let is_valid = SpanContext::is_valid(ctx)
    
    // ååºåˆ—åŒ–éªŒè¯ï¼ˆé‡æ–°åˆ›å»ºä¸Šä¸‹æ–‡ï¼‰
    let reconstructed_ctx = SpanContext::new(trace_id, span_id, is_sampled, "")
    
    // éªŒè¯é‡æ„åçš„ä¸Šä¸‹æ–‡
    assert_eq(SpanContext::trace_id(reconstructed_ctx), trace_id)
    assert_eq(SpanContext::span_id(reconstructed_ctx), span_id)
    assert_eq(SpanContext::is_sampled(reconstructed_ctx), is_sampled)
    
    // éªŒè¯æœ‰æ•ˆæ€§æ£€æŸ¥
    let original_valid = SpanContext::is_valid(ctx)
    let reconstructed_valid = SpanContext::is_valid(reconstructed_ctx)
    assert_eq(original_valid, reconstructed_valid)
  }
}

test "æ—¥å¿—è®°å½•åºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„åºåˆ—åŒ–å®Œæ•´æ€§
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "serialization_test_logger")
  
  // åˆ›å»ºå¤æ‚çš„æ—¥å¿—è®°å½•
  let attrs = Attributes::new()
  Attributes::set(attrs, "user_id", IntValue(12345))
  Attributes::set(attrs, "operation", StringValue("database_query"))
  Attributes::set(attrs, "duration_ms", FloatValue(150.5))
  
  let complex_log = LogRecord::new_with_context(
    Error,
    Some("Database operation failed"),
    Some(attrs),
    Some(1735689600000000000L),
    Some(1735689600000001000L),
    Some("trace_1234567890123456"),
    Some("span_1234567890123456"),
    Some(Context::with_value(Context::root(), ContextKey::new("request_id"), "req_abcdef"))
  )
  
  // éªŒè¯æ—¥å¿—è®°å½•çš„å®Œæ•´æ€§
  assert_eq(LogRecord::severity_number(complex_log), Error)
  assert_eq(LogRecord::body(complex_log), Some("Database operation failed"))
  
  // éªŒè¯æ—¶é—´æˆ³
  let timestamp = LogRecord::trace_id(complex_log)
  let span_id = LogRecord::span_id(complex_log)
  assert_eq(timestamp, Some("trace_1234567890123456"))
  assert_eq(span_id, Some("span_1234567890123456"))
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let edge_case_logs = [
    LogRecord::new(Trace, ""), // ç©ºæ¶ˆæ¯
    LogRecord::new(Fatal, "a" * 10000), // æé•¿æ¶ˆæ¯
    LogRecord::new_with_context(Info, None, None, None, None, None, None, None) // æœ€å°æ—¥å¿—
  ]
  
  for log in edge_case_logs {
    Logger::emit(logger, log)
    // éªŒè¯æ—¥å¿—ä¸ä¼šå¯¼è‡´åºåˆ—åŒ–é”™è¯¯
    assert_true(true)
  }
}

test "èµ„æºä¿¡æ¯åºåˆ—åŒ–æµ‹è¯•" {
  // æµ‹è¯•èµ„æºä¿¡æ¯çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  
  // åˆ›å»ºå¤æ‚èµ„æºä¿¡æ¯
  let base_resource = Resource::new()
  let resource_attrs = [
    ("service.name", StringValue("payment_service")),
    ("service.version", StringValue("2.1.0")),
    ("service.instance.id", StringValue("instance-12345")),
    ("deployment.environment", StringValue("production")),
    ("host.name", StringValue("prod-server-01")),
    ("host.id", StringValue("host-abcdef")),
    ("process.pid", IntValue(1234)),
    ("process.executable.name", StringValue("payment_service")),
    ("process.command_args", ArrayStringValue(["./payment_service", "--config", "/etc/config.yaml"])),
    ("telemetry.sdk.name", StringValue("azimuth")),
    ("telemetry.sdk.version", StringValue("1.0.0")),
    ("telemetry.sdk.language", StringValue("moonbit"))
  ]
  
  let resource = Resource::with_attributes(base_resource, resource_attrs)
  
  // éªŒè¯èµ„æºå±æ€§çš„å®Œæ•´æ€§
  for (key, expected_value) in resource_attrs {
    let retrieved_value = Resource::get_attribute(resource, key)
    assert_true(retrieved_value.is_some())
    
    match retrieved_value.unwrap() {
      StringValue(s) => {
        match expected_value {
          StringValue(expected) => assert_eq(s, expected)
          _ => assert_true(false, "Expected StringValue for key: " + key)
        }
      }
      IntValue(i) => {
        match expected_value {
          IntValue(expected) => assert_eq(i, expected)
          _ => assert_true(false, "Expected IntValue for key: " + key)
        }
      }
      ArrayStringValue(arr) => {
        match expected_value {
          ArrayStringValue(expected) => {
            assert_eq(arr.length(), expected.length())
            for i = 0; i < arr.length(); i = i + 1 {
              assert_eq(arr[i], expected[i])
            }
          }
          _ => assert_true(false, "Expected ArrayStringValue for key: " + key)
        }
      }
      _ => assert_true(false, "Unexpected value type for key: " + key)
    }
  }
  
  // æµ‹è¯•èµ„æºåˆå¹¶çš„åºåˆ—åŒ–å®Œæ•´æ€§
  let override_resource = Resource::with_attributes(base_resource, [
    ("service.name", StringValue("override_service")),
    ("new.attribute", StringValue("new_value"))
  ])
  
  let merged = Resource::merge(resource, override_resource)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œmergeè¿”å›overrideèµ„æº
  let merged_service_name = Resource::get_attribute(merged, "service.name")
  let merged_new_attr = Resource::get_attribute(merged, "new.attribute")
  let merged_old_attr = Resource::get_attribute(merged, "service.version")
  
  assert_eq(merged_service_name, Some(StringValue("override_service")))
  assert_eq(merged_new_attr, Some(StringValue("new_value")))
  assert_true(merged_old_attr.is_none()) // åœ¨ç®€åŒ–å®ç°ä¸­
}

test "ä»ªå™¨ä¿¡æ¯åºåˆ—åŒ–æµ‹è¯•" {
  // æµ‹è¯•ä»ªå™¨ä¿¡æ¯çš„åºåˆ—åŒ–å®Œæ•´æ€§
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "serialization_test_meter")
  
  // åˆ›å»ºå„ç§ç±»å‹çš„ä»ªå™¨
  let counter = Meter::create_counter(meter, "request_count", Some("Total number of requests"), Some("requests"))
  let histogram = Meter::create_histogram(meter, "request_duration", Some("Request duration in milliseconds"), Some("ms"))
  let updown_counter = Meter::create_counter(meter, "active_connections", Some("Current active connections"), Some("connections"))
  let gauge = Meter::create_counter(meter, "memory_usage", Some("Current memory usage"), Some("bytes"))
  
  // è½¬æ¢ä¸ºInstrumentç±»å‹è¿›è¡Œåºåˆ—åŒ–æµ‹è¯•
  let counter_instrument = Counter(counter.name, counter.description, counter.unit)
  let histogram_instrument = Histogram(histogram.name, histogram.description, histogram.unit)
  let updown_counter_instrument = UpDownCounter(updown_counter.name, updown_counter.description, updown_counter.unit)
  let gauge_instrument = Gauge(gauge.name, gauge.description, gauge.unit)
  
  // éªŒè¯ä»ªå™¨ä¿¡æ¯çš„å®Œæ•´æ€§
  let instruments = [counter_instrument, histogram_instrument, updown_counter_instrument, gauge_instrument]
  
  for instrument in instruments {
    let name = Instrument::name(instrument)
    let description = Instrument::description(instrument)
    let unit = Instrument::unit(instrument)
    
    // éªŒè¯åç§°ä¸ä¸ºç©º
    assert_true(name.length() > 0)
    
    // éªŒè¯æè¿°å’Œå•å…ƒçš„å¯é€‰æ€§
    match description {
      Some(desc) => assert_true(desc.length() > 0)
      None => () // å¯ä»¥ä¸ºNone
    }
    
    match unit {
      Some(u) => assert_true(u.length() > 0)
      None => () // å¯ä»¥ä¸ºNone
    }
  }
  
  // æµ‹è¯•ç‰¹æ®Šä»ªå™¨åç§°
  let special_names = [
    "metric.with.dots",
    "metric-with-dashes", 
    "metric_with_underscores",
    "metric/with/slashes",
    "metric.with.special.chars.ğŸš€"
  ]
  
  for name in special_names {
    let special_counter = Meter::create_counter(meter, name)
    let special_instrument = Counter(special_counter.name, special_counter.description, special_counter.unit)
    assert_eq(Instrument::name(special_instrument), name)
  }
}

test "HTTPè¯·æ±‚å“åº”åºåˆ—åŒ–æµ‹è¯•" {
  // æµ‹è¯•HTTPè¯·æ±‚å’Œå“åº”çš„åºåˆ—åŒ–å®Œæ•´æ€§
  
  // åˆ›å»ºå¤æ‚çš„HTTPè¯·æ±‚
  let request_headers = [
    ("Content-Type", "application/json"),
    ("Authorization", "Bearer token12345"),
    ("User-Agent", "Azimuth-Telemetry/1.0"),
    ("X-Request-ID", "req-abcdef-123456"),
    ("X-Trace-ID", "trace-789012345678")
  ]
  
  let request_body = "{\"operation\":\"test\",\"parameters\":{\"key\":\"value\"}}"
  let request = HttpRequest::new("POST", "https://api.example.com/telemetry", request_headers, Some(request_body))
  
  // éªŒè¯è¯·æ±‚çš„å®Œæ•´æ€§
  assert_eq(HttpRequest::http_method(request), "POST")
  assert_eq(HttpRequest::url(request), "https://api.example.com/telemetry")
  assert_eq(HttpRequest::body(request), Some(request_body))
  
  // åˆ›å»ºå¤æ‚çš„HTTPå“åº”
  let response_headers = [
    ("Content-Type", "application/json"),
    ("X-Response-Time", "150ms"),
    ("X-Server-ID", "server-prod-01"),
    ("Cache-Control", "no-cache")
  ]
  
  let response_body = "{\"status\":\"success\",\"data\":{\"id\":12345,\"result\":\"processed\"}}"
  let response = HttpResponse::new(200, response_headers, Some(response_body))
  
  // éªŒè¯å“åº”çš„å®Œæ•´æ€§
  assert_eq(HttpResponse::status_code(response), 200)
  assert_eq(HttpResponse::body(response), Some(response_body))
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let edge_cases = [
    HttpRequest::new("", "", [], None), // ç©ºè¯·æ±‚
    HttpRequest::new("GET", "https://example.com", [], Some("")), // ç©ºä½“è¯·æ±‚
    HttpResponse::new(0, [], None), // æœ€å°å“åº”
    HttpResponse::new(500, [], Some("Internal Server Error")) // é”™è¯¯å“åº”
  ]
  
  for edge_case in edge_cases {
    // éªŒè¯è¾¹ç•Œæƒ…å†µä¸ä¼šå¯¼è‡´åºåˆ—åŒ–é”™è¯¯
    assert_true(true)
  }
}

test "ä¸Šä¸‹æ–‡æ•°æ®åºåˆ—åŒ–æµ‹è¯•" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡æ•°æ®çš„åºåˆ—åŒ–å®Œæ•´æ€§
  
  // åˆ›å»ºå¤æ‚çš„ä¸Šä¸‹æ–‡å±‚æ¬¡ç»“æ„
  let root_ctx = Context::root()
  
  // ç¬¬ä¸€å±‚ä¸Šä¸‹æ–‡
  let layer1_key = ContextKey::new("service.name")
  let layer1_ctx = Context::with_value(root_ctx, layer1_key, "payment_service")
  
  // ç¬¬äºŒå±‚ä¸Šä¸‹æ–‡
  let layer2_key = ContextKey::new("operation.type")
  let layer2_ctx = Context::with_value(layer1_ctx, layer2_key, "database_transaction")
  
  // ç¬¬ä¸‰å±‚ä¸Šä¸‹æ–‡
  let layer3_key = ContextKey::new("user.id")
  let layer3_ctx = Context::with_value(layer2_ctx, layer3_key, "user_12345")
  
  // éªŒè¯ä¸Šä¸‹æ–‡å±‚æ¬¡ç»“æ„çš„å®Œæ•´æ€§
  let service_name = Context::get(layer3_ctx, layer1_key)
  let operation_type = Context::get(layer3_ctx, layer2_key)
  let user_id = Context::get(layer3_ctx, layer3_key)
  
  assert_eq(service_name, Some("payment_service"))
  assert_eq(operation_type, Some("database_transaction"))
  assert_eq(user_id, Some("user_12345"))
  
  // æµ‹è¯•ç‰¹æ®Šä¸Šä¸‹æ–‡å€¼
  let special_values = [
    ("empty_value", ""),
    ("unicode_value", "æµ‹è¯•å€¼_ğŸš€_ĞºĞ»ÑÑ‡"),
    ("long_value", "x" * 1000),
    ("special_chars", "\n\t\r\"'\\"),
    ("numeric_string", "12345.67890"),
    ("json_string", "{\"key\":\"value\",\"array\":[1,2,3]}")
  ]
  
  for (key_suffix, value) in special_values {
    let key = ContextKey::new("test." + key_suffix)
    let ctx_with_value = Context::with_value(root_ctx, key, value)
    let retrieved = Context::get(ctx_with_value, key)
    assert_eq(retrieved, Some(value))
  }
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡è¦†ç›–çš„åºåˆ—åŒ–è¡Œä¸º
  let override_key = ContextKey::new("override.test")
  let ctx1 = Context::with_value(root_ctx, override_key, "value1")
  let ctx2 = Context::with_value(ctx1, override_key, "value2")
  
  let value1 = Context::get(ctx1, override_key)
  let value2 = Context::get(ctx2, override_key)
  
  assert_eq(value1, Some("value1"))
  assert_eq(value2, Some("value2"))
}

test "Baggageæ•°æ®åºåˆ—åŒ–æµ‹è¯•" {
  // æµ‹è¯•Baggageæ•°æ®çš„åºåˆ—åŒ–å®Œæ•´æ€§
  
  let initial_baggage = Baggage::new()
  
  // æ·»åŠ å„ç§ç±»å‹çš„baggageé¡¹
  let baggage_entries = [
    ("user.id", "user_12345"),
    ("request.id", "req_abcdef123456"),
    ("operation.name", "process_payment"),
    ("service.version", "2.1.0"),
    ("trace.state", "sampled=true"),
    ("custom.metadata", "{\"source\":\"mobile\",\"version\":\"3.0.1\"}"),
    ("unicode.value", "æµ‹è¯•å€¼"),
    ("empty.value", ""),
    ("special.chars", "value=with=equals&and&ampsersands")
  ]
  
  let mut current_baggage = initial_baggage
  
  // é€æ­¥æ·»åŠ baggageé¡¹
  for (key, value) in baggage_entries {
    current_baggage = Baggage::set_entry(current_baggage, key, value)
  }
  
  // éªŒè¯æ‰€æœ‰baggageé¡¹çš„å®Œæ•´æ€§
  for (key, expected_value) in baggage_entries {
    let retrieved_value = Baggage::get_entry(current_baggage, key)
    assert_eq(retrieved_value, Some(expected_value))
  }
  
  // æµ‹è¯•baggageé¡¹ç§»é™¤çš„å®Œæ•´æ€§
  let keys_to_remove = ["user.id", "custom.metadata", "unicode.value"]
  let mut baggage_after_removal = current_baggage
  
  for key in keys_to_remove {
    baggage_after_removal = Baggage::remove_entry(baggage_after_removal, key)
  }
  
  // éªŒè¯ç§»é™¤åçš„çŠ¶æ€
  for key in keys_to_remove {
    let removed_value = Baggage::get_entry(baggage_after_removal, key)
    assert_true(removed_value.is_none())
  }
  
  // éªŒè¯æœªç§»é™¤çš„é¡¹ä»ç„¶å­˜åœ¨
  let remaining_keys = ["request.id", "operation.name", "service.version"]
  for key in remaining_keys {
    let remaining_value = Baggage::get_entry(baggage_after_removal, key)
    assert_true(remaining_value.is_some())
  }
  
  // æµ‹è¯•æé•¿é”®å€¼çš„å¤„ç†
  let long_key = "k" * 500
  let long_value = "v" * 1000
  let baggage_with_long = Baggage::set_entry(baggage_after_removal, long_key, long_value)
  
  let retrieved_long = Baggage::get_entry(baggage_with_long, long_key)
  assert_eq(retrieved_long, Some(long_value))
}