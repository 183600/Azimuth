// Azimuth Telemetry System - è¡¥å……æµ‹è¯•ç”¨ä¾‹
// åŸºæœ¬åŠŸèƒ½æµ‹è¯•ï¼Œä½¿ç”¨MoonBitåŸºæœ¬è¯­æ³•

test "åŸºæœ¬æ–­è¨€å’Œé€»è¾‘æµ‹è¯•" {
  // åŸºæœ¬æ–­è¨€æµ‹è¯•
  assert_true(true)
  assert_false(false)
  assert_eq(1, 1)
  assert_eq("hello", "hello")
  assert_eq(Some(42), Some(42))
  assert_eq(None, None)
}

test "å­—ç¬¦ä¸²æ“ä½œå’Œè¾¹ç•Œæµ‹è¯•" {
  // å­—ç¬¦ä¸²æ“ä½œæµ‹è¯•
  let empty_string = ""
  let normal_string = "hello world"
  let unicode_string = "ä¸­æ–‡æµ‹è¯•"
  let emoji_string = "ğŸš€ ğŸ¯ ğŸ“Š"
  
  assert_eq(empty_string.length(), 0)
  assert_eq(normal_string.length(), 11)
  assert_true(unicode_string.length() > 0)
  assert_true(emoji_string.length() > 0)
  
  // å­—ç¬¦ä¸²è¿æ¥
  let combined = normal_string + " " + unicode_string
  assert_true(combined.contains("hello"))
  assert_true(combined.contains("ä¸­æ–‡"))
  
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  let very_long_string = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•è¾¹ç•Œæƒ…å†µå’Œå¤„ç†èƒ½åŠ›ã€‚"
  assert_true(very_long_string.length() > 20)
}

test "æ•°å€¼æ“ä½œå’Œè¾¹ç•Œæµ‹è¯•" {
  // æ•°å€¼æ“ä½œæµ‹è¯•
  let int_value = 42
  let float_value = 3.14159
  let negative_int = -10
  let negative_float = -2.5
  let zero_int = 0
  let zero_float = 0.0
  
  assert_eq(int_value + zero_int, 42)
  assert_eq(float_value + zero_float, 3.14159)
  assert_eq(negative_int + int_value, 32)
  assert_true((negative_float + float_value - 0.64159).abs() < 0.00001)
  
  // æ¯”è¾ƒæ“ä½œ
  assert_true(int_value > zero_int)
  assert_true(negative_int < zero_int)
  assert_true(float_value > zero_float)
  assert_true(negative_float < zero_float)
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  let max_int = 2147483647
  let min_int = -2147483648
  assert_true(max_int > 0)
  assert_true(min_int < 0)
}

test "æ•°ç»„æ“ä½œå’Œè¾¹ç•Œæµ‹è¯•" {
  // æ•°ç»„æ“ä½œæµ‹è¯•
  let empty_array = []
  let int_array = [1, 2, 3, 4, 5]
  let string_array = ["a", "b", "c"]
  
  assert_eq(empty_array.length(), 0)
  assert_eq(int_array.length(), 5)
  assert_eq(string_array.length(), 3)
  
  // æ•°ç»„è®¿é—®
  assert_eq(int_array[0], 1)
  assert_eq(int_array[4], 5)
  assert_eq(string_array[1], "b")
  
  // æ•°ç»„åŒ…å«
  assert_true(int_array.contains(3))
  assert_false(int_array.contains(10))
  assert_true(string_array.contains("c"))
}

test "Optionç±»å‹å’Œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // Optionç±»å‹æµ‹è¯•
  let some_value = Some(42)
  let none_value = None
  let some_string = Some("hello")
  let none_string = None
  
  assert_eq(some_value, Some(42))
  assert_eq(none_value, None)
  assert_eq(some_string, Some("hello"))
  assert_eq(none_string, None)
  
  // Optionæ£€æŸ¥
  assert_true(some_value.is_some())
  assert_false(some_value.is_none())
  assert_false(none_value.is_some())
  assert_true(none_value.is_none())
  
  // é”™è¯¯å¤„ç†æ¨¡å¼æµ‹è¯•
  let divide = fn(a: Int, b: Int) -> Option[Int] {
    if b == 0 {
      None
    } else {
      Some(a / b)
    }
  }
  
  let result1 = divide(10, 2)
  let result2 = divide(10, 0)
  
  assert_eq(result1, Some(5))
  assert_eq(result2, None)
}

test "å¸ƒå°”é€»è¾‘å’Œæ¡ä»¶æµ‹è¯•" {
  // å¸ƒå°”é€»è¾‘æµ‹è¯•
  let true_val = true
  let false_val = false
  
  // åŸºæœ¬é€»è¾‘
  assert_true(true_val && true_val)
  assert_false(true_val && false_val)
  assert_false(false_val && false_val)
  
  assert_true(true_val || true_val)
  assert_true(true_val || false_val)
  assert_false(false_val || false_val)
  
  // å–å
  assert_false(!true_val)
  assert_true(!false_val)
  
  // æ¡ä»¶é€»è¾‘æµ‹è¯•
  let x = 10
  let y = 20
  
  let result1 = if x > y { "x greater" } else { "y greater or equal" }
  let result2 = if x < y { "x smaller" } else { "y smaller or equal" }
  let result3 = if x == y { "equal" } else { "not equal" }
  
  assert_eq(result1, "y greater or equal")
  assert_eq(result2, "x smaller")
  assert_eq(result3, "not equal")
}

test "å‡½æ•°å’Œä½œç”¨åŸŸæµ‹è¯•" {
  // å‡½æ•°å’Œä½œç”¨åŸŸæµ‹è¯•
  let add = fn(a: Int, b: Int) -> Int {
    a + b
  }
  
  let multiply = fn(a: Int, b: Int) -> Int {
    a * b
  }
  
  assert_eq(add(5, 3), 8)
  assert_eq(multiply(4, 6), 24)
  assert_eq(add(0, 0), 0)
  assert_eq(multiply(0, 5), 0)
  
  // é«˜é˜¶å‡½æ•°
  let apply_twice = fn(f: (Int) -> Int, x: Int) -> Int {
    f(f(x))
  }
  
  let increment = fn(n: Int) -> Int { n + 1 }
  let result = apply_twice(increment, 5)
  assert_eq(result, 7) // 5 -> 6 -> 7
}

test "æ•°æ®ç»“æ„å’Œæ¨¡å¼åŒ¹é…æµ‹è¯•" {
  // æ•°æ®ç»“æ„éªŒè¯æµ‹è¯•
  let person = ("Alice", 30, "Engineer")
  
  // å…ƒç»„è®¿é—®
  assert_eq(person.0, "Alice")
  assert_eq(person.1, 30)
  assert_eq(person.2, "Engineer")
  
  // åˆ›å»ºæ–°çš„å…ƒç»„
  let updated_person = (person.0, person.1 + 1, person.2)
  assert_eq(updated_person.1, 31)
  
  // æµ‹è¯•ç©ºå…ƒç»„
  let empty_tuple = ()
  assert_eq(empty_tuple, ())
  
  // æ¨¡å¼åŒ¹é…æµ‹è¯•
  let describe_number = fn(n: Int) -> String {
    if n > 0 {
      "positive"
    } else if n < 0 {
      "negative"
    } else {
      "zero"
    }
  }
  
  assert_eq(describe_number(10), "positive")
  assert_eq(describe_number(-5), "negative")
  assert_eq(describe_number(0), "zero")
}