// é«˜çº§é”™è¯¯è¾¹ç•Œå’Œå¼‚å¸¸å¤„ç†æµ‹è¯•
// Advanced error boundary and exception handling tests

test "Spanå¼‚å¸¸è¾¹ç•Œä¼ æ’­æµ‹è¯•" {
  // æµ‹è¯•Spanåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„è¾¹ç•Œè¡Œä¸º
  
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error_boundary_tracer")
  
  // æµ‹è¯•æ— æ•ˆSpanåç§°å¤„ç†
  let invalid_names = ["", " ", "\n\t", "valid_span_with_emoji_ğŸš€"]
  for name in invalid_names {
    let span = Tracer::start_span(tracer, name)
    assert_eq(Span::name(span), name)
    Span::set_status(span, Error, Some("Invalid name handled"))
    Span::end(span)
  }
  
  // æµ‹è¯•æé•¿Spanåç§°å¤„ç†
  let long_name = "a" * 1000
  let long_span = Tracer::start_span(tracer, long_name)
  assert_eq(Span::name(long_span), long_name)
  Span::end(long_span)
  
  // æµ‹è¯•SpançŠ¶æ€å¼‚å¸¸æ¢å¤
  let recovery_span = Tracer::start_span(tracer, "recovery_test")
  Span::set_status(recovery_span, Error, Some("Initial error"))
  assert_eq(Span::status(recovery_span), Error)
  
  // å°è¯•ä»é”™è¯¯çŠ¶æ€æ¢å¤
  Span::set_status(recovery_span, Ok, Some("Recovered"))
  assert_eq(Span::status(recovery_span), Ok)
  Span::end(recovery_span)
}

test "å±æ€§ç³»ç»Ÿå¼‚å¸¸å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•å±æ€§ç³»ç»Ÿåœ¨å¼‚å¸¸è¾“å…¥ä¸‹çš„å¤„ç†èƒ½åŠ›
  
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼å¤„ç†
  Attributes::set(attrs, "", StringValue("empty_key"))
  let empty_key_result = Attributes::get(attrs, "")
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å¤„ç†
  let special_keys = ["key with spaces", "key-with-dashes", "key_with_underscores", "key.with.dots", "key/with/slashes"]
  for key in special_keys {
    Attributes::set(attrs, key, StringValue("special_key_value"))
    let result = Attributes::get(attrs, key)
    assert_true(result.is_some())
  }
  
  // æµ‹è¯•Unicodeé”®å¤„ç†
  let unicode_keys = ["é”®å€¼", "ĞºĞ»ÑÑ‡", "clÃ©", "ã‚­ãƒ¼", "Ù…ÙØªØ§Ø­"]
  for key in unicode_keys {
    Attributes::set(attrs, key, StringValue("unicode_value"))
    let result = Attributes::get(attrs, key)
    assert_true(result.is_some())
  }
  
  // æµ‹è¯•æé•¿é”®å€¼å¤„ç†
  let long_key = "k" * 500
  let long_value = "v" * 1000
  Attributes::set(attrs, long_key, StringValue(long_value))
  let long_result = Attributes::get(attrs, long_key)
  assert_true(long_result.is_some())
}

test "æŒ‡æ ‡ç³»ç»Ÿè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æŒ‡æ ‡ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary_test_meter")
  
  // æµ‹è¯•æå€¼æŒ‡æ ‡è®°å½•
  let counter = Meter::create_counter(meter, "extreme_counter")
  let histogram = Meter::create_histogram(meter, "extreme_histogram")
  
  // æµ‹è¯•æå¤§å€¼è®°å½•
  Counter::add(counter, 1e308) // æ¥è¿‘Doubleæœ€å¤§å€¼
  Counter::add(counter, -1e308) // æè´Ÿå€¼
  Counter::add(counter, 0.0) // é›¶å€¼
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  Counter::add(counter, 1.0 / 0.0) // Infinity
  Counter::add(counter, -1.0 / 0.0) // -Infinity
  Counter::add(counter, 0.0 / 0.0) // NaN
  
  // æµ‹è¯•æå°å€¼è®°å½•
  Histogram::record(histogram, 1e-308) // æ¥è¿‘Doubleæœ€å°æ­£å€¼
  Histogram::record(histogram, -1e-308) // æå°è´Ÿå€¼
  
  // æµ‹è¯•æ— æ•ˆæŒ‡æ ‡åç§°å¤„ç†
  let invalid_names = ["", " ", "123invalid", "invalid-name!", "invalid.name"]
  for name in invalid_names {
    let test_counter = Meter::create_counter(meter, name)
    assert_eq(Instrument::name(Counter(test_counter.name, test_counter.description, test_counter.unit)), name)
    Counter::add(test_counter, 1.0)
  }
}

test "æ—¥å¿—ç³»ç»Ÿå¼‚å¸¸å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•æ—¥å¿—ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„å¤„ç†èƒ½åŠ›
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "exception_test_logger")
  
  // æµ‹è¯•æç«¯æ—¥å¿—æ¶ˆæ¯å¤„ç†
  let extreme_messages = [
    "", // ç©ºæ¶ˆæ¯
    " ", // ç©ºæ ¼æ¶ˆæ¯
    "\n\t\r", // æ§åˆ¶å­—ç¬¦æ¶ˆæ¯
    "a" * 10000, // æé•¿æ¶ˆæ¯
    "ğŸš€ğŸ”¥ğŸ’¯ğŸ‰" // Emojiæ¶ˆæ¯
  ]
  
  for message in extreme_messages {
    let log = LogRecord::new(Info, message)
    Logger::emit(logger, log)
    assert_eq(LogRecord::body(log), Some(message))
  }
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡çº§åˆ«
  let severity_levels = [Trace, Debug, Info, Warn, Error, Fatal]
  for severity in severity_levels {
    let log = LogRecord::new(severity, "Test message for severity " + severity.to_string())
    assert_eq(LogRecord::severity_number(log), severity)
    Logger::emit(logger, log)
  }
  
  // æµ‹è¯•æ— æ•ˆæ—¶é—´æˆ³å¤„ç†
  let invalid_timestamps = [
    Some(-1L), // è´Ÿæ—¶é—´æˆ³
    Some(0L), // é›¶æ—¶é—´æˆ³
    Some(9223372036854775807L), // æœ€å¤§Int64å€¼
    Some(-9223372036854775808L), // æœ€å°Int64å€¼
    None // æ— æ—¶é—´æˆ³
  ]
  
  for timestamp in invalid_timestamps {
    let log = LogRecord::new_with_context(
      Info,
      Some("Invalid timestamp test"),
      None,
      timestamp,
      None,
      None,
      None,
      None
    )
    Logger::emit(logger, log)
  }
}

test "ä¼ æ’­ç³»ç»Ÿå¼‚å¸¸æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•ä¼ æ’­ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›
  
  let carrier = TextMapCarrier::new()
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let ctx = Context::root()
  
  // æµ‹è¯•æ— æ•ˆè½½ä½“å¤„ç†
  // è®¾ç½®æ— æ•ˆçš„traceparentæ ¼å¼
  TextMapCarrier::set(carrier, "traceparent", "invalid-format")
  let extracted_ctx = CompositePropagator::extract(propagator, carrier)
  assert_true(extracted_ctx.data.is_some())
  
  // æµ‹è¯•ç©ºè½½ä½“å¤„ç†
  let empty_carrier = TextMapCarrier::new()
  let empty_extracted_ctx = CompositePropagator::extract(propagator, empty_carrier)
  assert_true(empty_extracted_ctx.data.is_some())
  
  // æµ‹è¯•è¶…é•¿è½½ä½“å€¼å¤„ç†
  let long_value = "x" * 10000
  TextMapCarrier::set(carrier, "traceparent", long_value)
  let long_extracted_ctx = CompositePropagator::extract(propagator, carrier)
  assert_true(long_extracted_ctx.data.is_some())
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦è½½ä½“å¤„ç†
  let special_values = ["\n\t\r", "ğŸš€", "é”®å€¼", "ĞºĞ»ÑÑ‡", "clÃ©"]
  for value in special_values {
    TextMapCarrier::set(carrier, "traceparent", value)
    let special_extracted_ctx = CompositePropagator::extract(propagator, carrier)
    assert_true(special_extracted_ctx.data.is_some())
  }
}

test "èµ„æºç³»ç»Ÿå¼‚å¸¸è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•èµ„æºç³»ç»Ÿåœ¨å¼‚å¸¸è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º
  
  // æµ‹è¯•ç©ºèµ„æºå¤„ç†
  let empty_resource = Resource::new()
  let empty_attrs = Resource::get_attribute(empty_resource, "nonexistent")
  assert_true(empty_attrs.is_none())
  
  // æµ‹è¯•æé•¿å±æ€§é”®å€¼å¤„ç†
  let resource = Resource::new()
  let long_key = "k" * 1000
  let long_value = StringValue("v" * 1000)
  let attrs = [(long_key, long_value)]
  let resource_with_long = Resource::with_attributes(resource, attrs)
  
  let retrieved_long = Resource::get_attribute(resource_with_long, long_key)
  assert_true(retrieved_long.is_some())
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§é”®å¤„ç†
  let special_keys = ["key with spaces", "key-with-dashes", "key/with/slashes", "key.with.dots", "é”®å€¼", "ĞºĞ»ÑÑ‡"]
  for key in special_keys {
    let attrs = [(key, StringValue("special_value"))]
    let resource_with_special = Resource::with_attributes(resource, attrs)
    let retrieved = Resource::get_attribute(resource_with_special, key)
    assert_true(retrieved.is_some())
  }
  
  // æµ‹è¯•èµ„æºåˆå¹¶è¾¹ç•Œæ¡ä»¶
  let base_resource = Resource::with_attributes(resource, [("base_key", StringValue("base_value"))])
  let override_resource = Resource::with_attributes(resource, [("override_key", StringValue("override_value"))])
  
  let merged = Resource::merge(base_resource, override_resource)
  let base_check = Resource::get_attribute(merged, "base_key")
  let override_check = Resource::get_attribute(merged, "override_key")
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œmergeè¿”å›overrideèµ„æº
  assert_true(base_check.is_none())
  assert_true(override_check.is_some())
}

test "ä¸Šä¸‹æ–‡ç³»ç»Ÿå¼‚å¸¸å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„å¤„ç†èƒ½åŠ›
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡å¤„ç†
  let empty_ctx = Context::root()
  let empty_key = ContextKey::new("empty_test")
  let empty_result = Context::get(empty_ctx, empty_key)
  assert_true(empty_result.is_none())
  
  // æµ‹è¯•æé•¿ä¸Šä¸‹æ–‡é”®å€¼å¤„ç†
  let long_key = ContextKey::new("k" * 1000)
  let long_value = "v" * 1000
  let long_ctx = Context::with_value(Context::root(), long_key, long_value)
  let long_result = Context::get(long_ctx, long_key)
  assert_eq(long_result, Some(long_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ä¸Šä¸‹æ–‡é”®å¤„ç†
  let special_keys = ["key with spaces", "key-with-dashes", "key/with/slashes", "é”®å€¼", "ĞºĞ»ÑÑ‡", "clÃ©"]
  for key in special_keys {
    let ctx_key = ContextKey::new(key)
    let ctx = Context::with_value(Context::root(), ctx_key, "special_value")
    let result = Context::get(ctx, ctx_key)
    assert_eq(result, Some("special_value"))
  }
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡è¦†ç›–è¡Œä¸º
  let ctx_key = ContextKey::new("override_test")
  let ctx1 = Context::with_value(Context::root(), ctx_key, "value1")
  let ctx2 = Context::with_value(ctx1, ctx_key, "value2")
  let result1 = Context::get(ctx1, ctx_key)
  let result2 = Context::get(ctx2, ctx_key)
  
  assert_eq(result1, Some("value1"))
  assert_eq(result2, Some("value2"))
}

test "SpanContextå¼‚å¸¸éªŒè¯æµ‹è¯•" {
  // æµ‹è¯•SpanContextåœ¨å¼‚å¸¸è¾“å…¥ä¸‹çš„éªŒè¯è¡Œä¸º
  
  // æµ‹è¯•æ— æ•ˆtrace_idå’Œspan_idå¤„ç†
  let invalid_contexts = [
    ("", "", false, ""), // å®Œå…¨ç©ºçš„ä¸Šä¸‹æ–‡
    ("valid_trace_id", "", false, ""), // æ— æ•ˆspan_id
    ("", "valid_span_id", false, ""), // æ— æ•ˆtrace_id
    ("a" * 32, "b" * 16, true, "valid_state"), // æœ‰æ•ˆä¸Šä¸‹æ–‡
    ("a" * 31, "b" * 16, false, ""), // trace_idå¤ªçŸ­
    ("a" * 33, "b" * 16, false, ""), // trace_idå¤ªé•¿
    ("a" * 32, "b" * 15, false, ""), // span_idå¤ªçŸ­
    ("a" * 32, "b" * 17, false, "") // span_idå¤ªé•¿
  ]
  
  for (trace_id, span_id, expected_valid, trace_state) in invalid_contexts {
    let ctx = SpanContext::new(trace_id, span_id, true, trace_state)
    let is_valid = SpanContext::is_valid(ctx)
    let retrieved_trace_id = SpanContext::trace_id(ctx)
    let retrieved_span_id = SpanContext::span_id(ctx)
    let is_sampled = SpanContext::is_sampled(ctx)
    
    assert_eq(retrieved_trace_id, trace_id)
    assert_eq(retrieved_span_id, span_id)
    assert_eq(is_sampled, true) // åœ¨ç®€åŒ–å®ç°ä¸­æ€»æ˜¯è¿”å›true
    
    // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œis_validçš„æ£€æŸ¥å¯èƒ½ä¸åŒ
    // è¿™é‡Œä¸»è¦æµ‹è¯•å‡½æ•°ä¸ä¼šå´©æºƒ
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦trace_idå’Œspan_idå¤„ç†
  let special_ids = [
    ("ğŸš€trace_id", "ğŸ”¥span_id"),
    ("é”®å€¼trace", "é”®å€¼span"),
    ("trace\nwith\nnewlines", "span\twith\ttabs")
  ]
  
  for (trace_id, span_id) in special_ids {
    let ctx = SpanContext::new(trace_id, span_id, true, "special_state")
    let retrieved_trace_id = SpanContext::trace_id(ctx)
    let retrieved_span_id = SpanContext::span_id(ctx)
    
    assert_eq(retrieved_trace_id, trace_id)
    assert_eq(retrieved_span_id, span_id)
  }
}