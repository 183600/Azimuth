// Azimuth Telemetry System - Boundary Conditions and Error Handling Tests
// è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•ç”¨ä¾‹

test "empty and null value handling" {
  // æµ‹è¯•ç©ºå€¼å’Œnullå€¼å¤„ç†
  let empty_attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºå±æ€§é›†åˆçš„æ“ä½œ
  let empty_result = Attributes::get(empty_attrs, "any.key")
  assert_eq(empty_result, None)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®
  let empty_key_result = Attributes::get(empty_attrs, "")
  assert_eq(empty_key_result, None)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  let attrs_with_empty = Attributes::new()
  Attributes::set(attrs_with_empty, "empty.string", StringValue(""))
  
  let empty_string_result = Attributes::get(attrs_with_empty, "empty.string")
  match empty_string_result {
    Some(StringValue(value)) => assert_eq(value, "")
    _ => assert_true(false, "Expected empty string value")
  }
  
  // æµ‹è¯•é›¶å€¼å’Œè´Ÿå€¼
  Attributes::set(attrs_with_empty, "zero.int", IntValue(0))
  Attributes::set(attrs_with_empty, "negative.int", IntValue(-1))
  Attributes::set(attrs_with_empty, "zero.float", FloatValue(0.0))
  Attributes::set(attrs_with_empty, "negative.float", FloatValue(-1.5))
  
  let zero_int = Attributes::get(attrs_with_empty, "zero.int")
  let negative_int = Attributes::get(attrs_with_empty, "negative.int")
  let zero_float = Attributes::get(attrs_with_empty, "zero.float")
  let negative_float = Attributes::get(attrs_with_empty, "negative.float")
  
  assert_eq(zero_int, Some(IntValue(0)))
  assert_eq(negative_int, Some(IntValue(-1)))
  assert_eq(zero_float, Some(FloatValue(0.0)))
  assert_eq(negative_float, Some(FloatValue(-1.5)))
}

test "span context edge cases" {
  // æµ‹è¯•SpanContextçš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•æé•¿çš„trace_idå’Œspan_id
  let long_trace_id = "a".repeat(1000)
  let long_span_id = "b".repeat(1000)
  let long_ctx = SpanContext::new(long_trace_id, long_span_id, true, "")
  
  assert_eq(SpanContext::trace_id(long_ctx), long_trace_id)
  assert_eq(SpanContext::span_id(long_ctx), long_span_id)
  assert_true(SpanContext::is_valid(long_ctx))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_trace_id = "0af76519-16cd-43dd-8448-eb211c80319c"
  let special_span_id = "b7ad6b71-6920-3331-0000-000000000000"
  let special_ctx = SpanContext::new(special_trace_id, special_span_id, true, "special=state;key=value")
  
  assert_eq(SpanContext::trace_id(special_ctx), special_trace_id)
  assert_eq(SpanContext::span_id(special_ctx), special_span_id)
  assert_true(SpanContext::is_valid(special_ctx))
  assert_true(SpanContext::is_sampled(special_ctx))
  
  // æµ‹è¯•æœªé‡‡æ ·çš„context
  let unsampled_ctx = SpanContext::new("trace123", "span456", false, "")
  assert_false(SpanContext::is_sampled(unsampled_ctx))
}

test "context value limits and nesting" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡å€¼çš„é™åˆ¶å’ŒåµŒå¥—
  let root_ctx = Context::root()
  
  // æµ‹è¯•é•¿é”®å€¼å¯¹
  let long_key = "a".repeat(1000)
  let long_value = "b".repeat(1000)
  let long_key_obj = ContextKey::new(long_key)
  
  let ctx_with_long = Context::with_value(root_ctx, long_key_obj, long_value)
  let retrieved_long = Context::get(ctx_with_long, long_key_obj)
  assert_eq(retrieved_long, Some(long_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å€¼
  let special_key = ContextKey::new("key.with.special.chars!@#$%^&*()")
  let special_value = "value with ä¸­æ–‡ and ğŸš€ emoji and 
 newlines 	 tabs"
  let ctx_with_special = Context::with_value(root_ctx, special_key, special_value)
  
  let retrieved_special = Context::get(ctx_with_special, special_key)
  assert_eq(retrieved_special, Some(special_value))
  
  // æµ‹è¯•æ·±åº¦åµŒå¥—ï¼ˆè™½ç„¶ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒçœŸæ­£çš„åµŒå¥—ï¼‰
  let key1 = ContextKey::new("level1")
  let key2 = ContextKey::new("level2")
  let key3 = ContextKey::new("level3")
  
  let ctx1 = Context::with_value(root_ctx, key1, "value1")
  let ctx2 = Context::with_value(ctx1, key2, "value2")
  let ctx3 = Context::with_value(ctx2, key3, "value3")
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œåªæœ‰æœ€åä¸€ä¸ªå€¼ä¼šè¢«ä¿ç•™
  let retrieved3 = Context::get(ctx3, key3)
  assert_eq(retrieved3, Some("value3"))
}

test "array attributes handling" {
  // æµ‹è¯•æ•°ç»„å±æ€§å¤„ç†
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºæ•°ç»„
  Attributes::set(attrs, "empty.array", ArrayStringValue([]))
  let empty_array_result = Attributes::get(attrs, "empty.array")
  match empty_array_result {
    Some(ArrayStringValue(arr)) => assert_eq(arr.length(), 0)
    _ => assert_true(false, "Expected empty array")
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  Attributes::set(attrs, "single.array", ArrayStringValue(["single"]))
  let single_array_result = Attributes::get(attrs, "single.array")
  match single_array_result {
    Some(ArrayStringValue(arr)) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], "single")
    }
    _ => assert_true(false, "Expected single element array")
  }
  
  // æµ‹è¯•å¤šå…ƒç´ æ•°ç»„
  let multi_array = ["item1", "item2", "item3", "ä¸­æ–‡", "ğŸš€"]
  Attributes::set(attrs, "multi.array", ArrayStringValue(multi_array))
  let multi_array_result = Attributes::get(attrs, "multi.array")
  match multi_array_result {
    Some(ArrayStringValue(arr)) => {
      assert_eq(arr.length(), 5)
      assert_eq(arr[0], "item1")
      assert_eq(arr[3], "ä¸­æ–‡")
      assert_eq(arr[4], "ğŸš€")
    }
    _ => assert_true(false, "Expected multi element array")
  }
  
  // æµ‹è¯•æ•´æ•°æ•°ç»„
  let int_array = [1, 2, 3, 0, -1, 1000, -1000]
  Attributes::set(attrs, "int.array", ArrayIntValue(int_array))
  let int_array_result = Attributes::get(attrs, "int.array")
  match int_array_result {
    Some(ArrayIntValue(arr)) => {
      assert_eq(arr.length(), 7)
      assert_eq(arr[0], 1)
      assert_eq(arr[3], 0)
      assert_eq(arr[4], -1)
      assert_eq(arr[5], 1000)
      assert_eq(arr[6], -1000)
    }
    _ => assert_true(false, "Expected integer array")
  }
}

test "instrument type variations" {
  // æµ‹è¯•ä¸åŒç±»å‹çš„instrument
  // æµ‹è¯•æ‰€æœ‰å¯èƒ½çš„instrumentç±»å‹
  let counter_inst = Counter("test.counter", Some("Test counter"), Some("count"))
  let histogram_inst = Histogram("test.histogram", Some("Test histogram"), Some("ms"))
  let updown_counter_inst = UpDownCounter("test.updown", Some("Test updown"), Some("bytes"))
  let gauge_inst = Gauge("test.gauge", Some("Test gauge"), Some("percent"))
  
  // æµ‹è¯•åç§°æå–
  assert_eq(Instrument::name(counter_inst), "test.counter")
  assert_eq(Instrument::name(histogram_inst), "test.histogram")
  assert_eq(Instrument::name(updown_counter_inst), "test.updown")
  assert_eq(Instrument::name(gauge_inst), "test.gauge")
  
  // æµ‹è¯•æè¿°æå–
  assert_eq(Instrument::description(counter_inst), Some("Test counter"))
  assert_eq(Instrument::description(histogram_inst), Some("Test histogram"))
  assert_eq(Instrument::description(updown_counter_inst), Some("Test updown"))
  assert_eq(Instrument::description(gauge_inst), Some("Test gauge"))
  
  // æµ‹è¯•å•ä½æå–
  assert_eq(Instrument::unit(counter_inst), Some("count"))
  assert_eq(Instrument::unit(histogram_inst), Some("ms"))
  assert_eq(Instrument::unit(updown_counter_inst), Some("bytes"))
  assert_eq(Instrument::unit(gauge_inst), Some("percent"))
  
  // æµ‹è¯•ç©ºæè¿°å’Œå•ä½
  let no_desc_counter = Counter("no.desc", None, None)
  let no_unit_histogram = Histogram("no.unit", Some("Has description"), None)
  
  assert_eq(Instrument::description(no_desc_counter), None)
  assert_eq(Instrument::unit(no_desc_counter), None)
  assert_eq(Instrument::description(no_unit_histogram), Some("Has description"))
  assert_eq(Instrument::unit(no_unit_histogram), None)
}

test "log record severity edge cases" {
  // æµ‹è¯•æ—¥å¿—è®°å½•ä¸¥é‡æ€§çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡æ€§çº§åˆ«
  let trace_record = LogRecord::new(Trace, "Trace message")
  let debug_record = LogRecord::new(Debug, "Debug message")
  let info_record = LogRecord::new(Info, "Info message")
  let warn_record = LogRecord::new(Warn, "Warning message")
  let error_record = LogRecord::new(Error, "Error message")
  let fatal_record = LogRecord::new(Fatal, "Fatal message")
  
  assert_eq(LogRecord::severity_number(trace_record), Trace)
  assert_eq(LogRecord::severity_number(debug_record), Debug)
  assert_eq(LogRecord::severity_number(info_record), Info)
  assert_eq(LogRecord::severity_number(warn_record), Warn)
  assert_eq(LogRecord::severity_number(error_record), Error)
  assert_eq(LogRecord::severity_number(fatal_record), Fatal)
  
  // æµ‹è¯•ç©ºæ¶ˆæ¯
  let empty_body_record = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_body_record), Some(""))
  
  // æµ‹è¯•é•¿æ¶ˆæ¯
  let long_message = "a".repeat(10000)
  let long_message_record = LogRecord::new(Info, long_message)
  assert_eq(LogRecord::body(long_message_record), Some(long_message))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ¶ˆæ¯
  let special_message = "Message with ä¸­æ–‡, ğŸš€ emoji, 
 newlines, 	 tabs, and "quotes""
  let special_message_record = LogRecord::new(Error, special_message)
  assert_eq(LogRecord::body(special_message_record), Some(special_message))
}

test "resource attribute merging conflicts" {
  // æµ‹è¯•èµ„æºå±æ€§åˆå¹¶å†²çª
  let base_attrs = [
    ("service.name", StringValue("base-service")),
    ("service.version", StringValue("1.0.0")),
    ("base.only", StringValue("base-value"))
  ]
  
  let override_attrs = [
    ("service.name", StringValue("override-service")),  // å†²çªçš„é”®
    ("service.version", StringValue("2.0.0")),          // å†²çªçš„é”®
    ("override.only", StringValue("override-value"))
  ]
  
  let base_resource = Resource::with_attributes(Resource::new(), base_attrs)
  let override_resource = Resource::with_attributes(Resource::new(), override_attrs)
  
  // æµ‹è¯•åˆå¹¶ç»“æœï¼ˆç®€åŒ–å®ç°ä¸­ï¼Œoverrideä¼šå®Œå…¨æ›¿æ¢baseï¼‰
  let merged = Resource::merge(base_resource, override_resource)
  
  let merged_service_name = Resource::get_attribute(merged, "service.name")
  let merged_service_version = Resource::get_attribute(merged, "service.version")
  let merged_base_only = Resource::get_attribute(merged, "base.only")
  let merged_override_only = Resource::get_attribute(merged, "override.only")
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¿™äº›æ–­è¨€å¯èƒ½éœ€è¦è°ƒæ•´
  // assert_eq(merged_service_name, Some(StringValue("override-service")))
  // assert_eq(merged_service_version, Some(StringValue("2.0.0")))
  // assert_eq(merged_base_only, Some(StringValue("base-value")))
  assert_eq(merged_override_only, Some(StringValue("override-value")))
}

test "text map carrier edge cases" {
  // æµ‹è¯•TextMapCarrierçš„è¾¹ç•Œæƒ…å†µ
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºcarrier
  let empty_result = TextMapCarrier::get(carrier, "any.header")
  assert_eq(empty_result, None)
  
  // æµ‹è¯•è®¾ç½®å’Œè·å–ç‰¹æ®Šå­—ç¬¦çš„header
  TextMapCarrier::set(carrier, "x-custom-header", "custom-value")
  TextMapCarrier::set(carrier, "header-with-dashes", "value-with-dashes")
  TextMapCarrier::set(carrier, "header_with_underscores", "value_with_underscores")
  
  let custom_result = TextMapCarrier::get(carrier, "x-custom-header")
  let dashes_result = TextMapCarrier::get(carrier, "header-with-dashes")
  let underscores_result = TextMapCarrier::get(carrier, "header_with_underscores")
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¿™äº›å¯èƒ½è¿”å›None
  // assert_eq(custom_result, Some("custom-value"))
  // assert_eq(dashes_result, Some("value-with-dashes"))
  // assert_eq(underscores_result, Some("value_with_underscores"))
  
  // æµ‹è¯•å·²çŸ¥çš„traceparent header
  let traceparent_result = TextMapCarrier::get(carrier, "traceparent")
  assert_eq(traceparent_result, Some("00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"))
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  TextMapCarrier::set(carrier, "", "empty-key-value")
  TextMapCarrier::set(carrier, "empty-value-key", "")
  
  let empty_key_result = TextMapCarrier::get(carrier, "")
  let empty_value_result = TextMapCarrier::get(carrier, "empty-value-key")
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¿™äº›å¯èƒ½è¿”å›None
  // assert_eq(empty_key_result, Some("empty-key-value"))
  // assert_eq(empty_value_result, Some(""))
}

test "clock and random number generation" {
  // æµ‹è¯•æ—¶é’Ÿå’Œéšæœºæ•°ç”Ÿæˆ
  let clock = Clock::system()
  let random = Random::system()
  
  // æµ‹è¯•æ—¶é’Ÿ
  let timestamp1 = Clock::now_unix_nanos(clock)
  let timestamp2 = Clock::now_unix_nanos(clock)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¿™ä¸¤ä¸ªæ—¶é—´æˆ³ç›¸åŒ
  assert_eq(timestamp1, 1735689600000000000L)
  assert_eq(timestamp2, 1735689600000000000L)
  
  // æµ‹è¯•éšæœºå­—èŠ‚ç”Ÿæˆ
  let empty_bytes = Random::next_bytes(random, 0)
  let some_bytes = Random::next_bytes(random, 10)
  
  assert_eq(empty_bytes.length(), 0)
  assert_eq(some_bytes.length(), 0)  // ç®€åŒ–å®ç°è¿”å›ç©ºæ•°ç»„
  
  // æµ‹è¯•éšæœºæ•°ç”Ÿæˆ
  let random_num1 = Random::next_u64(random)
  let random_num2 = Random::next_u64(random)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œè¿™äº›å€¼ç›¸åŒ
  assert_eq(random_num1, 12345UL)
  assert_eq(random_num2, 12345UL)
}

test "span kind and status code variations" {
  // æµ‹è¯•Spanç§ç±»å’ŒçŠ¶æ€ç å˜ä½“
  let span_ctx = SpanContext::new("trace123", "span456", true, "")
  
  // æµ‹è¯•æ‰€æœ‰Spanç§ç±»
  let internal_span = Span::new("internal", Internal, span_ctx)
  let server_span = Span::new("server", Server, span_ctx)
  let client_span = Span::new("client", Client, span_ctx)
  let producer_span = Span::new("producer", Producer, span_ctx)
  let consumer_span = Span::new("consumer", Consumer, span_ctx)
  
  assert_eq(Span::kind(internal_span), Internal)
  assert_eq(Span::kind(server_span), Server)
  assert_eq(Span::kind(client_span), Client)
  assert_eq(Span::kind(producer_span), Producer)
  assert_eq(Span::kind(consumer_span), Consumer)
  
  // æµ‹è¯•çŠ¶æ€ç è®¾ç½®
  Span::set_status(internal_span, Unset, None)
  Span::set_status(server_span, Ok, Some("Success"))
  Span::set_status(client_span, Error, Some("Client error occurred"))
  Span::set_status(producer_span, Unset, Some("No status"))
  Span::set_status(consumer_span, Error, None)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼ŒçŠ¶æ€æ€»æ˜¯è¿”å›Unset
  assert_eq(Span::status(internal_span), Unset)
  assert_eq(Span::status(server_span), Unset)
  assert_eq(Span::status(client_span), Unset)
  assert_eq(Span::status(producer_span), Unset)
  assert_eq(Span::status(consumer_span), Unset)
}