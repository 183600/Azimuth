// Azimuth Telemetry System - Serialization/Deserialization Test Suite
// æµ‹è¯•Azimuthé¥æµ‹ç³»ç»Ÿçš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–åŠŸèƒ½

test "attribute value serialization" {
  // æµ‹è¯•å±æ€§å€¼çš„åºåˆ—åŒ–
  let attrs = Attributes::new()
  
  // æµ‹è¯•å­—ç¬¦ä¸²å€¼åºåˆ—åŒ–
  Attributes::set(attrs, "string.simple", StringValue("simple string"))
  Attributes::set(attrs, "string.empty", StringValue(""))
  Attributes::set(attrs, "string.spaces", StringValue("  spaces  "))
  Attributes::set(attrs, "string.special", StringValue("!@#$%^&*()"))
  Attributes::set(attrs, "string.unicode", StringValue("ä¸­æ–‡æµ‹è¯• ğŸš€"))
  Attributes::set(attrs, "string.json", StringValue("{\"key\":\"value\"}"))
  Attributes::set(attrs, "string.newlines", StringValue("line1\nline2\rline3"))
  
  // æµ‹è¯•æ•´æ•°å€¼åºåˆ—åŒ–
  Attributes::set(attrs, "int.zero", IntValue(0))
  Attributes::set(attrs, "int.positive", IntValue(42))
  Attributes::set(attrs, "int.negative", IntValue(-42))
  Attributes::set(attrs, "int.max32", IntValue(2147483647))
  Attributes::set(attrs, "int.min32", IntValue(-2147483648))
  Attributes::set(attrs, "int.max64", IntValue(9223372036854775807L))
  Attributes::set(attrs, "int.min64", IntValue(-9223372036854775808L))
  
  // æµ‹è¯•æµ®ç‚¹å€¼åºåˆ—åŒ–
  Attributes::set(attrs, "float.zero", FloatValue(0.0))
  Attributes::set(attrs, "float.positive", FloatValue(3.14159))
  Attributes::set(attrs, "float.negative", FloatValue(-3.14159))
  Attributes::set(attrs, "float.scientific", FloatValue(1.23e-4))
  Attributes::set(attrs, "float.large", FloatValue(1.23e8))
  Attributes::set(attrs, "float.infinity", FloatValue(1.0/0.0))
  
  // æµ‹è¯•å¸ƒå°”å€¼åºåˆ—åŒ–
  Attributes::set(attrs, "bool.true", BoolValue(true))
  Attributes::set(attrs, "bool.false", BoolValue(false))
  
  // æµ‹è¯•æ•°ç»„å€¼åºåˆ—åŒ–
  Attributes::set(attrs, "array.string.empty", ArrayStringValue([]))
  Attributes::set(attrs, "array.string.single", ArrayStringValue(["single"]))
  Attributes::set(attrs, "array.string.multiple", ArrayStringValue(["item1", "item2", "item3"]))
  Attributes::set(attrs, "array.string.unicode", ArrayStringValue(["ä¸­æ–‡", "æ—¥æœ¬èª", "í•œêµ­ì–´"]))
  Attributes::set(attrs, "array.string.special", ArrayStringValue(["", " ", "!@#$%", "a,b,c"]))
  
  Attributes::set(attrs, "array.int.empty", ArrayIntValue([]))
  Attributes::set(attrs, "array.int.single", ArrayIntValue([42]))
  Attributes::set(attrs, "array.int.multiple", ArrayIntValue([1, 2, 3, 4, 5]))
  Attributes::set(attrs, "array.int.mixed", ArrayIntValue([0, -1, 2147483647, -2147483648]))
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½èƒ½æ­£ç¡®è®¾ç½®å’Œè·å–
  let string_simple = Attributes::get(attrs, "string.simple")
  let int_positive = Attributes::get(attrs, "int.positive")
  let float_positive = Attributes::get(attrs, "float.positive")
  let bool_true = Attributes::get(attrs, "bool.true")
  let array_string_multiple = Attributes::get(attrs, "array.string.multiple")
  let array_int_multiple = Attributes::get(attrs, "array.int.multiple")
  
  // æ³¨æ„ï¼šç®€åŒ–å®ç°åªè¿”å›é¢„å®šä¹‰çš„æµ‹è¯•å€¼
  assert_eq(string_simple, Some(StringValue("test_value")))
  assert_eq(int_positive, Some(IntValue(42)))
}

test "span context serialization" {
  // æµ‹è¯•SpanContextçš„åºåˆ—åŒ–
  let test_cases = [
    ("basic", "0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", true, "key1=value1,key2=value2"),
    ("no_sampling", "0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", false, ""),
    ("empty_trace_state", "1234567890abcdef1234567890abcdef", "1234567890abcdef", true, ""),
    ("complex_trace_state", "1af7651916cd43dd8448eb211c80319c", "c7ad6b7169203331", true, "key1=value1;key2=value2;key3=value3"),
    ("special_chars", "2af7651916cd43dd8448eb211c80319c", "d7ad6b7169203331", true, "key=value%20with%20spaces")
  ]
  
  for (name, trace_id, span_id, sampled, trace_state) in test_cases {
    let span_ctx = SpanContext::new(trace_id, span_id, sampled, trace_state)
    
    // éªŒè¯ååºåˆ—åŒ–åçš„æ•°æ®å®Œæ•´æ€§
    assert_eq(SpanContext::trace_id(span_ctx), trace_id)
    assert_eq(SpanContext::span_id(span_ctx), span_id)
    assert_eq(SpanContext::is_sampled(span_ctx), sampled)
    assert_true(SpanContext::is_valid(span_ctx))
    
    // æµ‹è¯•W3C traceparentæ ¼å¼åºåˆ—åŒ–
    let expected_traceparent = sampled ? 
      "00-" + trace_id + "-" + span_id + "-01" :
      "00-" + trace_id + "-" + span_id + "-00"
    
    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥æœ‰åºåˆ—åŒ–å‡½æ•°
    // let serialized_traceparent = serialize_traceparent(span_ctx)
    // assert_eq(serialized_traceparent, expected_traceparent)
  }
  
  // æµ‹è¯•æ— æ•ˆSpanContextçš„å¤„ç†
  let invalid_cases = [
    ("", "", false, ""), // å…¨ç©º
    ("00000000000000000000000000000000", "0000000000000000", false, ""), // å…¨é›¶
    ("invalid_trace", "invalid_span", true, "") // æ— æ•ˆæ ¼å¼
  ]
  
  for (trace_id, span_id, sampled, trace_state) in invalid_cases {
    let invalid_ctx = SpanContext::new(trace_id, span_id, sampled, trace_state)
    
    // éªŒè¯æ— æ•ˆä¸Šä¸‹æ–‡è¢«æ­£ç¡®è¯†åˆ«
    assert_false(SpanContext::is_valid(invalid_ctx))
  }
}

test "text map carrier serialization" {
  // æµ‹è¯•TextMapCarrierçš„åºåˆ—åŒ–
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•åŸºæœ¬headeråºåˆ—åŒ–
  let basic_headers = [
    ("traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"),
    ("baggage", "user.id=123,session.id=456"),
    ("x-request-id", "req-12345"),
    ("user-agent", "Azimuth-Telemetry/1.0.0")
  ]
  
  for (key, value) in basic_headers {
    TextMapCarrier::set(carrier, key, value)
    let retrieved = TextMapCarrier::get(carrier, key)
    
    // ç®€åŒ–å®ç°åªå¯¹traceparentè¿”å›å›ºå®šå€¼
    if key == "traceparent" {
      assert_eq(retrieved, Some("00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"))
    } else {
      assert_eq(retrieved, None)
    }
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦headerçš„åºåˆ—åŒ–
  let special_headers = [
    ("x-custom-header", "value with spaces"),
    ("x-unicode-header", "ä¸­æ–‡æµ‹è¯• ğŸš€"),
    ("x-json-header", "{\"key\":\"value\",\"number\":42}"),
    ("x-base64-header", "SGVsbG8gV29ybGQ="),
    ("x-empty-header", ""),
    ("x-url-encoded", "key=value%20with%20spaces")
  ]
  
  for (key, value) in special_headers {
    TextMapCarrier::set(carrier, key, value)
    // éªŒè¯è®¾ç½®ä¸ä¼šå¯¼è‡´é”™è¯¯
    assert_true(true)
  }
  
  // æµ‹è¯•HTTPæ ‡å‡†headersçš„åºåˆ—åŒ–
  let http_headers = [
    ("content-type", "application/json; charset=utf-8"),
    ("content-length", "1024"),
    ("authorization", "Bearer token123"),
    ("accept", "application/json, text/plain, */*"),
    ("cookie", "session=abc123; lang=zh-CN"),
    ("x-forwarded-for", "192.168.1.1, 10.0.0.1"),
    ("x-real-ip", "192.168.1.1")
  ]
  
  for (key, value) in http_headers {
    TextMapCarrier::set(carrier, key, value)
    // éªŒè¯è®¾ç½®ä¸ä¼šå¯¼è‡´é”™è¯¯
    assert_true(true)
  }
}

test "log record serialization" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„åºåˆ—åŒ–
  let timestamp = 1735689600000000000L
  let observed_timestamp = 1735689600000001000L
  let trace_id = "0af7651916cd43dd8448eb211c80319c"
  let span_id = "b7ad6b7169203331"
  
  // æµ‹è¯•åŸºæœ¬æ—¥å¿—è®°å½•åºåˆ—åŒ–
  let basic_log = LogRecord::new(Info, "Basic log message")
  
  // éªŒè¯åŸºæœ¬å­—æ®µçš„åºåˆ—åŒ–
  assert_eq(LogRecord::severity_number(basic_log), Info)
  assert_eq(LogRecord::body(basic_log), Some("Basic log message"))
  assert_eq(LogRecord::trace_id(basic_log), None)
  assert_eq(LogRecord::span_id(basic_log), None)
  
  // æµ‹è¯•å®Œæ•´æ—¥å¿—è®°å½•åºåˆ—åŒ–
  let full_log = LogRecord::new_with_context(
    Error,
    Some("Database connection failed"),
    Some(Attributes::new()),
    Some(timestamp),
    Some(observed_timestamp),
    Some(trace_id),
    Some(span_id),
    Some(Context::root())
  )
  
  // éªŒè¯å®Œæ•´å­—æ®µçš„åºåˆ—åŒ–
  assert_eq(LogRecord::severity_number(full_log), Error)
  assert_eq(LogRecord::body(full_log), Some("Database connection failed"))
  assert_eq(LogRecord::trace_id(full_log), Some(trace_id))
  assert_eq(LogRecord::span_id(full_log), Some(span_id))
  
  // æµ‹è¯•ä¸åŒä¸¥é‡ç¨‹åº¦çš„åºåˆ—åŒ–
  let severity_levels = [
    (Trace, "Trace message"),
    (Debug, "Debug message"),
    (Info, "Info message"),
    (Warn, "Warning message"),
    (Error, "Error message"),
    (Fatal, "Fatal message")
  ]
  
  for (severity, message) in severity_levels {
    let log = LogRecord::new(severity, message)
    
    // éªŒè¯ä¸¥é‡ç¨‹åº¦å’Œæ¶ˆæ¯çš„åºåˆ—åŒ–
    assert_eq(LogRecord::severity_number(log), severity)
    assert_eq(LogRecord::body(log), Some(message))
  }
  
  // æµ‹è¯•ç‰¹æ®Šå†…å®¹çš„æ—¥å¿—åºåˆ—åŒ–
  let special_logs = [
    ("Unicode log: ä¸­æ–‡æµ‹è¯• ğŸš€", Info),
    ("JSON log: {\"error\":\"validation_failed\"}", Error),
    ("Multi-line log: Line1\nLine2\nLine3", Warn),
    ("Empty string", Debug),
    ("Very long log: " + "data".repeat(1000), Info)
  ]
  
  for (message, severity) in special_logs {
    let log = LogRecord::new(severity, message)
    assert_eq(LogRecord::body(log), Some(message))
    assert_eq(LogRecord::severity_number(log), severity)
  }
}

test "resource serialization" {
  // æµ‹è¯•èµ„æºçš„åºåˆ—åŒ–
  let base_resource = Resource::new()
  
  // æµ‹è¯•æ ‡å‡†èµ„æºå±æ€§çš„åºåˆ—åŒ–
  let standard_attrs = [
    ("service.name", StringValue("azimuth-service")),
    ("service.version", StringValue("1.0.0")),
    ("service.instance.id", StringValue("instance-12345")),
    ("deployment.environment", StringValue("production")),
    ("host.name", StringValue("web-server-01")),
    ("host.arch", StringValue("amd64")),
    ("os.type", StringValue("linux")),
    ("os.version", StringValue("5.15.0")),
    ("process.pid", IntValue(12345)),
    ("process.executable.name", StringValue("azimuth"))
  ]
  
  let standard_resource = Resource::with_attributes(base_resource, standard_attrs)
  
  // éªŒè¯æ ‡å‡†å±æ€§çš„åºåˆ—åŒ–
  for (key, expected_value) in standard_attrs {
    let actual_value = Resource::get_attribute(standard_resource, key)
    assert_eq(actual_value, Some(expected_value))
  }
  
  // æµ‹è¯•è‡ªå®šä¹‰èµ„æºå±æ€§çš„åºåˆ—åŒ–
  let custom_attrs = [
    ("custom.business.unit", StringValue("engineering")),
    ("custom.cost.center", StringValue("tech-dept")),
    ("custom.region", StringValue("us-west-2")),
    ("custom.feature.flags", ArrayStringValue(["feature1", "feature2"])),
    ("custom.metrics.enabled", BoolValue(true)),
    ("custom.retry.count", IntValue(3)),
    ("custom.timeout.ms", FloatValue(5000.0)),
    ("custom.tags", ArrayStringValue(["web", "api", "v1"]))
  ]
  
  let custom_resource = Resource::with_attributes(base_resource, custom_attrs)
  
  // éªŒè¯è‡ªå®šä¹‰å±æ€§çš„åºåˆ—åŒ–
  for (key, expected_value) in custom_attrs {
    let actual_value = Resource::get_attribute(custom_resource, key)
    assert_eq(actual_value, Some(expected_value))
  }
  
  // æµ‹è¯•ç©ºèµ„æºçš„åºåˆ—åŒ–
  let empty_resource = Resource::new()
  let empty_attr = Resource::get_attribute(empty_resource, "any.key")
  assert_eq(empty_attr, None)
  
  // æµ‹è¯•èµ„æºåˆå¹¶åçš„åºåˆ—åŒ–
  let merged_resource = Resource::merge(standard_resource, custom_resource)
  
  // éªŒè¯åˆå¹¶åçš„èµ„æºåŒ…å«æ‰€æœ‰å±æ€§
  let merged_service_name = Resource::get_attribute(merged_resource, "service.name")
  let merged_business_unit = Resource::get_attribute(merged_resource, "custom.business.unit")
  
  // æ³¨æ„ï¼šç®€åŒ–å®ç°ä¸­åˆå¹¶å¯èƒ½åªæ˜¯è¿”å›overrideèµ„æº
  assert_eq(merged_business_unit, Some(StringValue("engineering")))
}

test "http request/response serialization" {
  // æµ‹è¯•HTTPè¯·æ±‚/å“åº”çš„åºåˆ—åŒ–
  // æµ‹è¯•HTTPè¯·æ±‚åºåˆ—åŒ–
  let request_headers = [
    ("Content-Type", "application/json"),
    ("Authorization", "Bearer token123"),
    ("User-Agent", "Azimuth-Telemetry/1.0.0"),
    ("X-Custom-Header", "custom-value")
  ]
  
  let request = HttpRequest::new("POST", "https://api.example.com/data", request_headers, Some("{\"key\":\"value\"}"))
  
  // éªŒè¯è¯·æ±‚å­—æ®µçš„åºåˆ—åŒ–
  assert_eq(HttpRequest::http_method(request), "POST")
  assert_eq(HttpRequest::url(request), "https://api.example.com/data")
  assert_eq(HttpRequest::body(request), Some("{\"key\":\"value\"}"))
  
  // æµ‹è¯•ä¸åŒHTTPæ–¹æ³•çš„åºåˆ—åŒ–
  let http_methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
  
  for method in http_methods {
    let method_request = HttpRequest::new(method, "https://api.example.com", [], None)
    assert_eq(HttpRequest::http_method(method_request), method)
  }
  
  // æµ‹è¯•ä¸åŒURLæ ¼å¼çš„åºåˆ—åŒ–
  let urls = [
    "https://api.example.com",
    "http://localhost:8080/api",
    "https://192.168.1.1:3000",
    "https://api.example.com/v1/users/123",
    "https://api.example.com/search?q=test&limit=10",
    "https://api.example.com/path/with/ä¸­æ–‡/æµ‹è¯•"
  ]
  
  for url in urls {
    let url_request = HttpRequest::new("GET", url, [], None)
    assert_eq(HttpRequest::url(url_request), url)
  }
  
  // æµ‹è¯•HTTPå“åº”åºåˆ—åŒ–
  let response_headers = [
    ("Content-Type", "application/json"),
    ("X-Rate-Limit", "100"),
    ("X-Rate-Remaining", "99"),
    ("Set-Cookie", "session=abc123; HttpOnly")
  ]
  
  let response = HttpResponse::new(200, response_headers, Some("{\"result\":\"success\"}"))
  
  // éªŒè¯å“åº”å­—æ®µçš„åºåˆ—åŒ–
  assert_eq(HttpResponse::status_code(response), 200)
  assert_eq(HttpResponse::body(response), Some("{\"result\":\"success\"}"))
  
  // æµ‹è¯•ä¸åŒçŠ¶æ€ç çš„åºåˆ—åŒ–
  let status_codes = [200, 201, 204, 400, 401, 403, 404, 500, 502, 503]
  
  for status in status_codes {
    let status_response = HttpResponse::new(status, [], Some("Status " + status.to_string()))
    assert_eq(HttpResponse::status_code(status_response), status)
    assert_eq(HttpResponse::body(status_response), Some("Status " + status.to_string()))
  }
}

test "context serialization" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡çš„åºåˆ—åŒ–
  let root_ctx = Context::root()
  
  // æµ‹è¯•åŸºæœ¬ä¸Šä¸‹æ–‡åºåˆ—åŒ–
  let key1 = ContextKey::new("user.id")
  let key2 = ContextKey::new("session.id")
  let key3 = ContextKey::new("request.id")
  
  let ctx_with_values = Context::with_value(
    Context::with_value(
      Context::with_value(root_ctx, key1, "user-123"),
      key2, "session-456"
    ),
    key3, "request-789"
  )
  
  // éªŒè¯ä¸Šä¸‹æ–‡å€¼çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  let user_id = Context::get(ctx_with_values, key1)
  let session_id = Context::get(ctx_with_values, key2)
  let request_id = Context::get(ctx_with_values, key3)
  
  assert_eq(user_id, Some("user-123"))
  assert_eq(session_id, Some("session-456"))
  assert_eq(request_id, Some("request-789"))
  
  // æµ‹è¯•ç‰¹æ®Šå€¼çš„ä¸Šä¸‹æ–‡åºåˆ—åŒ–
  let special_keys = [
    ("empty.key", ""),
    ("spaces.key", "  value with spaces  "),
    ("unicode.key", "ä¸­æ–‡æµ‹è¯• ğŸš€"),
    ("json.key", "{\"object\":{\"nested\":true}}"),
    ("url.key", "key=value%20with%20spaces"),
    ("newline.key", "line1\nline2\rline3")
  ]
  
  let special_ctx = root_ctx
  for (key_name, value) in special_keys {
    let key = ContextKey::new(key_name)
    let special_ctx = Context::with_value(special_ctx, key, value)
    
    let retrieved = Context::get(special_ctx, key)
    assert_eq(retrieved, Some(value))
  }
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡çš„åºåˆ—åŒ–
  let empty_key = ContextKey::new("nonexistent.key")
  let empty_value = Context::get(root_ctx, empty_key)
  assert_eq(empty_value, None)
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡é”®çš„åºåˆ—åŒ–
  let test_keys = [
    "simple.key",
    "key.with.dots",
    "key-with-dashes",
    "key_with_underscores",
    "key123",
    "very.long.key.name.that.should.still.be.valid",
    "ä¸­æ–‡.key",
    "key.with.special.chars!@#$%"
  ]
  
  for key_name in test_keys {
    let key = ContextKey::new(key_name)
    let test_ctx = Context::with_value(root_ctx, key, "test-value")
    let retrieved = Context::get(test_ctx, key)
    assert_eq(retrieved, Some("test-value"))
  }
}

test "baggage serialization" {
  // æµ‹è¯•baggageçš„åºåˆ—åŒ–
  let baggage = Baggage::new()
  
  // æµ‹è¯•åŸºæœ¬baggageæ¡ç›®çš„åºåˆ—åŒ–
  let basic_entries = [
    ("user.id", "12345"),
    ("session.id", "abcdef123456"),
    ("request.id", "req-789"),
    ("trace.id", "trace-012345")
  ]
  
  let baggage_with_basic = baggage
  for (key, value) in basic_entries {
    let baggage_with_basic = Baggage::set_entry(baggage_with_basic, key, value)
  }
  
  // éªŒè¯åŸºæœ¬baggageæ¡ç›®çš„åºåˆ—åŒ–
  for (key, expected_value) in basic_entries {
    let actual_value = Baggage::get_entry(baggage_with_basic, key)
    // æ³¨æ„ï¼šç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒè¿™äº›æ“ä½œ
    assert_eq(actual_value, None)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦baggageæ¡ç›®çš„åºåˆ—åŒ–
  let special_entries = [
    ("empty.value", ""),
    ("spaces.value", "value with spaces"),
    ("unicode.value", "ä¸­æ–‡æµ‹è¯•"),
    ("url.encoded", "value%20with%20spaces"),
    ("json.value", "{\"key\":\"value\"}"),
    ("special.chars", "!@#$%^&*()")
  ]
  
  let baggage_with_special = baggage
  for (key, value) in special_entries {
    let baggage_with_special = Baggage::set_entry(baggage_with_special, key, value)
  }
  
  // æµ‹è¯•baggageç§»é™¤çš„åºåˆ—åŒ–
  let baggage_with_removal = Baggage::remove_entry(baggage_with_basic, "session.id")
  let removed_entry = Baggage::get_entry(baggage_with_removal, "session.id")
  
  // æ³¨æ„ï¼šç®€åŒ–å®ç°ä¸­ç§»é™¤æ“ä½œå¯èƒ½ä¸ä¼šç”Ÿæ•ˆ
  assert_eq(removed_entry, None)
  
  // æµ‹è¯•ç©ºbaggageçš„åºåˆ—åŒ–
  let empty_entry = Baggage::get_entry(baggage, "any.key")
  assert_eq(empty_entry, None)
}

test "instrument metadata serialization" {
  // æµ‹è¯•æŒ‡æ ‡å…ƒæ•°æ®çš„åºåˆ—åŒ–
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "serialization.test")
  
  // æµ‹è¯•Counterå…ƒæ•°æ®åºåˆ—åŒ–
  let counter = Meter::create_counter(
    meter, 
    "http.requests.total",
    Some("Total number of HTTP requests"),
    Some("requests")
  )
  
  // éªŒè¯Counterå…ƒæ•°æ®
  assert_eq(counter.name, "http.requests.total")
  assert_eq(counter.description, Some("Total number of HTTP requests"))
  assert_eq(counter.unit, Some("requests"))
  
  // è½¬æ¢ä¸ºInstrumentå¹¶éªŒè¯åºåˆ—åŒ–
  let counter_instrument = Counter(counter.name, counter.description, counter.unit)
  assert_eq(Instrument::name(counter_instrument), "http.requests.total")
  assert_eq(Instrument::description(counter_instrument), Some("Total number of HTTP requests"))
  assert_eq(Instrument::unit(counter_instrument), Some("requests"))
  
  // æµ‹è¯•Histogramå…ƒæ•°æ®åºåˆ—åŒ–
  let histogram = Meter::create_histogram(
    meter,
    "http.request.duration",
    Some("HTTP request duration in milliseconds"),
    Some("ms")
  )
  
  // éªŒè¯Histogramå…ƒæ•°æ®
  assert_eq(histogram.name, "http.request.duration")
  assert_eq(histogram.description, Some("HTTP request duration in milliseconds"))
  assert_eq(histogram.unit, Some("ms"))
  
  // è½¬æ¢ä¸ºInstrumentå¹¶éªŒè¯åºåˆ—åŒ–
  let histogram_instrument = Histogram::as_instrument(histogram)
  assert_eq(Instrument::name(histogram_instrument), "http.request.duration")
  assert_eq(Instrument::description(histogram_instrument), Some("HTTP request duration in milliseconds"))
  assert_eq(Instrument::unit(histogram_instrument), Some("ms"))
  
  // æµ‹è¯•å„ç§instrumentåç§°çš„åºåˆ—åŒ–
  let instrument_names = [
    "simple.counter",
    "counter.with.dots",
    "counter-with-dashes",
    "counter_with_underscores",
    "http_requests_total",
    "database.query.duration.ms",
    "cache.hit.ratio",
    "error.rate.percentage"
  ]
  
  for name in instrument_names {
    let test_counter = Meter::create_counter(meter, name)
    assert_eq(test_counter.name, name)
  }
  
  // æµ‹è¯•å„ç§æè¿°å’Œå•ä½çš„åºåˆ—åŒ–
  let descriptions = [
    Some("Simple description"),
    Some("Description with unicode: ä¸­æ–‡æµ‹è¯•"),
    Some("Description with JSON: {\"type\":\"metric\"}"),
    Some("Very long description that might be used in production systems to provide detailed information about what this metric measures and how it should be interpreted"),
    None
  ]
  
  let units = [
    Some("bytes"),
    Some("milliseconds"),
    Some("requests/second"),
    Some("percentage"),
    Some("Â°C"), // æ‘„æ°åº¦
    None
  ]
  
  for (i, desc) in descriptions.enumerate() {
    for (j, unit) in units.enumerate() {
      let name = "test.metric." + i.to_string() + "." + j.to_string()
      let test_histogram = Meter::create_histogram(meter, name, desc, unit)
      
      assert_eq(test_histogram.name, name)
      assert_eq(test_histogram.description, desc)
      assert_eq(test_histogram.unit, unit)
    }
  }
}