// Azimuth Telemetry System - Boundary Conditions and Exception Recovery Test Suite
// æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æ¢å¤

test "æå€¼æ•°æ®è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿå¤„ç†æå€¼æ•°æ®çš„èƒ½åŠ›
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary.test")
  
  // æµ‹è¯•æå¤§æ•°å€¼
  let max_double = 1.7976931348623157E+308
  let min_positive_double = 4.9E-324
  let max_int64 = 9223372036854775807L
  let min_int64 = -9223372036854775808L
  
  let counter = Meter::create_counter(meter, "extreme.values")
  let histogram = Meter::create_histogram(meter, "extreme.histogram")
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(counter, max_double)
  Histogram::record(histogram, max_double)
  
  // æµ‹è¯•æå°æ­£å€¼
  Counter::add(counter, min_positive_double)
  Histogram::record(histogram, min_positive_double)
  
  // æµ‹è¯•è´Ÿå€¼
  Counter::add(counter, -1.0)
  Histogram::record(histogram, -1000.0)
  
  // æµ‹è¯•é›¶å€¼
  Counter::add(counter, 0.0)
  Histogram::record(histogram, 0.0)
  
  // æµ‹è¯•æ— ç©·å¤§ï¼ˆå¦‚æœæ”¯æŒï¼‰
  Counter::add(counter, 1.0 / 0.0) // +Infinity
  Histogram::record(histogram, -1.0 / 0.0) // -Infinity
  
  // æµ‹è¯•NaNï¼ˆå¦‚æœæ”¯æŒï¼‰
  Counter::add(counter, 0.0 / 0.0) // NaN
  Histogram::record(histogram, 0.0 / 0.0) // NaN
  
  // éªŒè¯æŒ‡æ ‡ç»“æ„æœªè¢«ç ´å
  assert_eq(counter.name, "extreme.values")
  assert_eq(histogram.name, "extreme.histogram")
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "boundary.logger")
  
  let max_timestamp_log = LogRecord::new_with_context(
    Info,
    Some("Max timestamp test"),
    None,
    Some(max_int64),
    None,
    None,
    None,
    None
  )
  
  let min_timestamp_log = LogRecord::new_with_context(
    Info,
    Some("Min timestamp test"),
    None,
    Some(min_int64),
    None,
    None,
    None,
    None
  )
  
  Logger::emit(logger, max_timestamp_log)
  Logger::emit(logger, min_timestamp_log)
  
  // éªŒè¯æ—¶é—´æˆ³è®¾ç½®æ­£ç¡®
  assert_eq(max_timestamp_log.timestamp, Some(max_int64))
  assert_eq(min_timestamp_log.timestamp, Some(min_int64))
}

test "å†…å­˜å‹åŠ›è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿåœ¨å†…å­˜å‹åŠ›ä¸‹çš„è¡Œä¸º
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "memory.pressure")
  
  // åˆ›å»ºå¤§é‡å¯¹è±¡æµ‹è¯•å†…å­˜è¾¹ç•Œ
  let large_object_count = 10000
  
  // å¤§é‡Span
  let spans = Array.make(large_object_count, Span::new("", Internal, SpanContext::new("", "", false, "")))
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "memory.test")
  
  for i = 0; i < large_object_count; i++ {
    spans[i] = Tracer::start_span(tracer, "memory.pressure.span." + i.to_string())
  }
  
  // å¤§é‡Attributes
  let attributes_array = Array.make(large_object_count, Attributes::new())
  
  for i = 0; i < large_object_count; i++ {
    attributes_array[i] = Attributes::new()
    Attributes::set(attributes_array[i], "large.array.key." + i.to_string(), StringValue("large.array.value." + i.to_string()))
  }
  
  // å¤§é‡Context
  let contexts = Array.make(large_object_count, Context::root())
  let keys = Array.make(large_object_count, ContextKey::new(""))
  
  for i = 0; i < large_object_count; i++ {
    keys[i] = ContextKey::new("memory.pressure.key." + i.to_string())
    contexts[i] = Context::with_value(Context::root(), keys[i], "memory.pressure.value." + i.to_string())
  }
  
  // å¤§é‡Resource
  let resources = Array.make(1000, Resource::new())
  
  for i = 0; i < 1000; i++ {
    let attrs = [
      ("resource.index", IntValue(i)),
      ("resource.name", StringValue("memory.pressure.resource." + i.to_string())),
      ("resource.description", StringValue("Large resource for memory pressure testing " + i.to_string()))
    ]
    resources[i] = Resource::with_attributes(Resource::new(), attrs)
  }
  
  // å¤§é‡LogRecord
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "memory.pressure.logger")
  
  for i = 0; i < 5000; i++ {
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Memory pressure log " + i.to_string()),
      Some(Attributes::new()),
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      Some("memory-pressure-trace"),
      Some("memory-pressure-span-" + i.to_string()),
      None
    )
    Logger::emit(logger, log_record)
  }
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  assert_eq(Span::name(spans[0]), "memory.pressure.span.0")
  assert_eq(Span::name(spans[large_object_count - 1]), "memory.pressure.span." + (large_object_count - 1).to_string())
  
  let first_attr = Attributes::get(attributes_array[0], "large.array.key.0")
  match first_attr {
    Some(StringValue(value)) => assert_eq(value, "large.array.value.0")
    _ => assert_true(true) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  let first_context = Context::get(contexts[0], keys[0])
  match first_context {
    Some(value) => assert_eq(value, "memory.pressure.value.0")
    _ => assert_true(false)
  }
  
  // æ¸…ç†èµ„æº
  for i = 0; i < large_object_count; i++ {
    Span::end(spans[i])
  }
  
  // éªŒè¯æ¸…ç†åç³»ç»Ÿä»æ­£å¸¸
  let cleanup_counter = Meter::create_counter(meter, "cleanup.test")
  assert_eq(cleanup_counter.name, "cleanup.test")
}

test "ç½‘ç»œå¼‚å¸¸æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•ç½‘ç»œå¼‚å¸¸æƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›
  
  let client = HttpClient::new()
  
  // æ¨¡æ‹Ÿå„ç§ç½‘ç»œå¼‚å¸¸åœºæ™¯
  
  // 1. è¿æ¥è¶…æ—¶
  let timeout_request = HttpRequest::new(
    "GET",
    "https://timeout.example.com/slow-resource",
    [("Timeout", StringValue("5000"))],
    None
  )
  
  // 2. è¿æ¥æ‹’ç»
  let refused_request = HttpRequest::new(
    "POST",
    "https://refused.example.com/unavailable",
    [("Content-Type", StringValue("application/json"))],
    Some("{\"test\": \"data\"}")
  )
  
  // 3. DNSè§£æå¤±è´¥
  let dns_request = HttpRequest::new(
    "GET",
    "https://nonexistent-domain-12345.invalid.com/resource",
    [],
    None
  )
  
  // 4. æœåŠ¡å™¨é”™è¯¯
  let server_error_request = HttpRequest::new(
    "GET",
    "https://server-error.example.com/error",
    [],
    None
  )
  
  // æ¨¡æ‹Ÿå¼‚å¸¸å“åº”
  let timeout_response = HttpResponse::new(408, [("Error", StringValue("Request Timeout"))], Some("Timeout occurred"))
  let refused_response = HttpResponse::new(503, [("Error", StringValue("Service Unavailable"))], Some("Connection refused"))
  let dns_response = HttpResponse::new(0, [("Error", StringValue("DNS Resolution Failed"))], Some("DNS lookup failed"))
  let server_error_response = HttpResponse::new(500, [("Error", StringValue("Internal Server Error"))], Some("Server error occurred"))
  
  // éªŒè¯å¼‚å¸¸å“åº”å¤„ç†
  assert_eq(HttpResponse::status_code(timeout_response), 408)
  assert_eq(HttpResponse::status_code(refused_response), 503)
  assert_eq(HttpResponse::status_code(dns_response), 0)
  assert_eq(HttpResponse::status_code(server_error_response), 500)
  
  // æµ‹è¯•é‡è¯•æœºåˆ¶
  let retry_count = 3
  let successful_response = HttpResponse::new(200, [("Retry-After", StringValue("0"))], Some("Success after retry"))
  
  // æ¨¡æ‹Ÿé‡è¯•é€»è¾‘
  for attempt = 1; attempt <= retry_count; attempt++ {
    if attempt == retry_count {
      // æœ€åä¸€æ¬¡å°è¯•æˆåŠŸ
      assert_eq(HttpResponse::status_code(successful_response), 200)
      break
    }
    
    // å‰å‡ æ¬¡å°è¯•å¤±è´¥
    let retry_response = HttpResponse::new(503, [("Retry-Attempt", StringValue(attempt.to_string()))], Some("Retry later"))
    assert_eq(HttpResponse::status_code(retry_response), 503)
  }
  
  // æµ‹è¯•æ–­è·¯å™¨æ¨¡å¼
  let circuit_breaker_threshold = 5
  let failure_count = 0
  
  // æ¨¡æ‹Ÿè¿ç»­å¤±è´¥
  for i = 0; i < circuit_breaker_threshold; i++ {
    let failure_response = HttpResponse::new(503, [("Circuit-Breaker", StringValue("Open"))], Some("Service unavailable"))
    assert_eq(HttpResponse::status_code(failure_response), 503)
    // failure_count++ // åœ¨çœŸå®å®ç°ä¸­ä¼šè®°å½•å¤±è´¥æ¬¡æ•°
  }
  
  // æ–­è·¯å™¨åº”è¯¥æ‰“å¼€ï¼Œåç»­è¯·æ±‚ç›´æ¥å¤±è´¥
  let circuit_open_response = HttpResponse::new(503, [("Circuit-Breaker", StringValue("Open"))], Some("Circuit breaker is open"))
  assert_eq(HttpResponse::status_code(circuit_open_response), 503)
  
  // éªŒè¯è¯·æ±‚ç»“æ„åœ¨å¼‚å¸¸æƒ…å†µä¸‹ä¿æŒå®Œæ•´
  assert_eq(HttpRequest::http_method(timeout_request), "GET")
  assert_eq(HttpRequest::url(refused_request), "https://refused.example.com/unavailable")
  assert_eq(HttpRequest::http_method(dns_request), "GET")
  assert_eq(HttpRequest::http_method(server_error_request), "GET")
}

test "æ•°æ®æŸåæ¢å¤æµ‹è¯•" {
  // æµ‹è¯•æ•°æ®æŸåæƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›
  
  // æµ‹è¯•æŸåçš„SpanContext
  let corrupted_trace_ids = [
    "",                    // ç©ºtrace_id
    "invalid",             // éåå…­è¿›åˆ¶
    "123",                 // é•¿åº¦ä¸è¶³
    "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz", // éæ³•å­—ç¬¦
    "a".repeat(100)        // è¿‡é•¿
  ]
  
  for corrupted_id in corrupted_trace_ids {
    let corrupted_ctx = SpanContext::new(corrupted_id, "valid_span_id", true, "")
    assert_false(SpanContext::is_valid(corrupted_ctx))
    
    // å³ä½¿ä¸Šä¸‹æ–‡æ— æ•ˆï¼ŒSpanåˆ›å»ºä¹Ÿä¸åº”è¯¥å´©æºƒ
    let tracer = TracerProvider::get_tracer(TracerProvider::default(), "corruption.test")
    let span = Tracer::start_span(tracer, "corruption.test.span")
    Span::end(span)
  }
  
  // æµ‹è¯•æŸåçš„å±æ€§å€¼
  let attrs = Attributes::new()
  
  // æµ‹è¯•æé•¿çš„å­—ç¬¦ä¸²
  let very_long_string = "a".repeat(1000000)
  Attributes::set(attrs, "very.long.key", StringValue(very_long_string))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = "\x00\x01\x02\x03\x04\x05" // æ§åˆ¶å­—ç¬¦
  Attributes::set(attrs, "special.chars", StringValue(special_chars))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_chars = "æµ‹è¯•ğŸš€ğŸŒŸğŸ’«âœ¨ğŸ‰"
  Attributes::set(attrs, "unicode.chars", StringValue(unicode_chars))
  
  // éªŒè¯å±æ€§æ“ä½œä¸ä¼šå´©æºƒ
  let _result1 = Attributes::get(attrs, "very.long.key")
  let _result2 = Attributes::get(attrs, "special.chars")
  let _result3 = Attributes::get(attrs, "unicode.chars")
  
  // æµ‹è¯•æŸåçš„Resourceå±æ€§
  let corrupted_resource_attrs = [
    ("", StringValue("empty.key")), // ç©ºé”®å
    ("normal.key", StringValue("")), // ç©ºå€¼
    ("very.long.key." + "a".repeat(1000), StringValue("value")), // é•¿é”®å
    ("key", StringValue("a".repeat(1000000))) // é•¿å€¼
  ]
  
  let corrupted_resource = Resource::with_attributes(Resource::new(), corrupted_resource_attrs)
  
  // éªŒè¯Resourceæ“ä½œä¸ä¼šå´©æºƒ
  for attr in corrupted_resource_attrs {
    let _result = Resource::get_attribute(corrupted_resource, attr.0)
  }
  
  // æµ‹è¯•æŸåçš„æ—¥å¿—è®°å½•
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "corruption.logger")
  
  let corrupted_logs = [
    LogRecord::new(Info, ""), // ç©ºæ¶ˆæ¯
    LogRecord::new(Info, "a".repeat(1000000)), // æé•¿æ¶ˆæ¯
    LogRecord::new_with_context(Error, None, None, None, None, None, None, None), // å…¨éƒ¨ä¸ºNone
    LogRecord::new_with_context(Info, Some("normal"), Some(Attributes::new()), Some(-1L), Some(-2L), Some(""), Some(""), Some(Context::root())) // è´Ÿæ—¶é—´æˆ³å’Œç©ºID
  ]
  
  for log in corrupted_logs {
    Logger::emit(logger, log)
    // éªŒè¯æ—¥å¿—è®°å½•ä¸ä¼šå´©æºƒ
  }
}

test "ç³»ç»Ÿèµ„æºè€—å°½æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿèµ„æºè€—å°½æƒ…å†µä¸‹çš„æ¢å¤
  
  // æ¨¡æ‹Ÿæ–‡ä»¶æè¿°ç¬¦è€—å°½
  let file_handle_count = 1000
  let file_handles = Array.make(file_handle_count, "")
  
  for i = 0; i < file_handle_count; i++ {
    file_handles[i] = "file_handle_" + i.to_string()
    // åœ¨çœŸå®å®ç°ä¸­ä¼šæ‰“å¼€æ–‡ä»¶
  }
  
  // å³ä½¿åœ¨èµ„æºç´§å¼ æƒ…å†µä¸‹ï¼Œé¥æµ‹æ“ä½œä»åº”å·¥ä½œ
  let meter = MeterProvider::get_meter(MeterProvider::default(), "resource.exhaustion")
  let counter = Meter::create_counter(meter, "operations.under.pressure")
  
  Counter::add(counter, 1.0)
  assert_eq(counter.name, "operations.under.pressure")
  
  // æ¨¡æ‹Ÿå†…å­˜ä¸è¶³
  let large_allocations = Array.make(100, Array.make(1000000, 0))
  
  for i = 0; i < large_allocations.length(); i++ {
    for j = 0; j < large_allocations[i].length(); j++ {
      large_allocations[i][j] = i * j
    }
  }
  
  // åœ¨å†…å­˜å‹åŠ›ä¸‹ç»§ç»­æ“ä½œ
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "memory.pressure")
  let pressure_log = LogRecord::new(Warn, "Operating under memory pressure")
  Logger::emit(logger, pressure_log)
  
  // æ¨¡æ‹ŸCPUè¿‡è½½
  let cpu_intensive_operations = 1000000
  
  for i = 0; i < cpu_intensive_operations; i++ {
    // ç®€å•çš„CPUå¯†é›†å‹æ“ä½œ
    let _result = i * i + i / 2 + i % 3
    
    // æ¯1000æ¬¡æ“ä½œè®°å½•ä¸€æ¬¡æŒ‡æ ‡
    if i % 1000 == 0 {
      Counter::add(counter, 1.0)
    }
  }
  
  // éªŒè¯ç³»ç»Ÿä»èƒ½æ­£å¸¸å·¥ä½œ
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "recovery.test")
  let recovery_span = Tracer::start_span(tracer, "resource.recovery.span")
  Span::set_status(recovery_span, Ok)
  Span::end(recovery_span)
  
  assert_eq(Span::name(recovery_span), "resource.recovery.span")
  
  // æ¸…ç†èµ„æº
  for i = 0; i < file_handle_count; i++ {
    file_handles[i] = "" // åœ¨çœŸå®å®ç°ä¸­ä¼šå…³é—­æ–‡ä»¶
  }
  
  // éªŒè¯æ¸…ç†åç³»ç»Ÿæ¢å¤æ­£å¸¸
  let cleanup_span = Tracer::start_span(tracer, "post.cleanup.span")
  assert_eq(Span::name(cleanup_span), "post.cleanup.span")
  Span::end(cleanup_span)
}

test "çº§è”æ•…éšœæ¢å¤æµ‹è¯•" {
  // æµ‹è¯•çº§è”æ•…éšœæƒ…å†µä¸‹çš„æ¢å¤
  
  // æ¨¡æ‹ŸæœåŠ¡é“¾ä¸­çš„çº§è”æ•…éšœ
  
  // Service A -> Service B -> Service C -> Service D
  
  // Service D æ•…éšœ
  let service_d_logger = LoggerProvider::get_logger(LoggerProvider::default(), "service-d")
  let service_d_failure = LogRecord::new(Error, "Service D database connection failed")
  Logger::emit(service_d_logger, service_d_failure)
  
  // Service C å—å½±å“
  let service_c_logger = LoggerProvider::get_logger(LoggerProvider::default(), "service-c")
  let service_c_failure = LogRecord::new(Error, "Service C: Downstream service D unavailable")
  Logger::emit(service_c_logger, service_c_failure)
  
  // Service B å—å½±å“
  let service_b_logger = LoggerProvider::get_logger(LoggerProvider::default(), "service-b")
  let service_b_failure = LogRecord::new(Error, "Service B: Circuit breaker opened for service C")
  Logger::emit(service_b_logger, service_b_failure)
  
  // Service A å—å½±å“
  let service_a_logger = LoggerProvider::get_logger(LoggerProvider::default(), "service-a")
  let service_a_failure = LogRecord::new(Error, "Service A: Request timeout waiting for service B")
  Logger::emit(service_a_logger, service_a_failure)
  
  // æµ‹è¯•æ•…éšœæ¢å¤è¿‡ç¨‹
  
  // 1. Service D æ¢å¤
  let service_d_recovery = LogRecord::new(Info, "Service D: Database connection restored")
  Logger::emit(service_d_logger, service_d_recovery)
  
  // 2. Service C æ£€æµ‹åˆ°æ¢å¤
  let service_c_recovery = LogRecord::new(Info, "Service C: Downstream service D responding normally")
  Logger::emit(service_c_logger, service_c_recovery)
  
  // 3. Service B é‡ç½®æ–­è·¯å™¨
  let service_b_recovery = LogRecord::new(Info, "Service B: Circuit breaker reset for service C")
  Logger::emit(service_b_logger, service_b_recovery)
  
  // 4. Service A æ¢å¤æ­£å¸¸
  let service_a_recovery = LogRecord::new(Info, "Service A: All downstream services operational")
  Logger::emit(service_a_logger, service_a_recovery)
  
  // éªŒè¯æ•…éšœæ¢å¤æŒ‡æ ‡
  let meter = MeterProvider::get_meter(MeterProvider::default(), "cascade.failure")
  
  let failure_counter = Meter::create_counter(meter, "cascade.failures")
  let recovery_counter = Meter::create_counter(meter, "cascade.recoveries")
  let recovery_time = Meter::create_histogram(meter, "cascade.recovery.time")
  
  // è®°å½•æ•…éšœå’Œæ¢å¤æŒ‡æ ‡
  Counter::add(failure_counter, 4.0) // 4ä¸ªæœåŠ¡å—å½±å“
  Counter::add(recovery_counter, 4.0) // 4ä¸ªæœåŠ¡æ¢å¤
  Histogram::record(recovery_time, 30000.0) // 30ç§’æ¢å¤æ—¶é—´
  
  // éªŒè¯æŒ‡æ ‡æ­£å¸¸
  assert_eq(failure_counter.name, "cascade.failures")
  assert_eq(recovery_counter.name, "cascade.recoveries")
  assert_eq(recovery_time.name, "cascade.recovery.time")
  
  // æµ‹è¯•æ•…éšœåçš„ç³»ç»ŸçŠ¶æ€
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "cascade.recovery")
  let post_recovery_span = Tracer::start_span(tracer, "post.recovery.operation")
  
  Span::add_event(post_recovery_span, "system.healthy", Some([
    ("service.a.status", StringValue("healthy")),
    ("service.b.status", StringValue("healthy")),
    ("service.c.status", StringValue("healthy")),
    ("service.d.status", StringValue("healthy"))
  ]))
  
  Span::set_status(post_recovery_span, Ok)
  Span::end(post_recovery_span)
  
  assert_eq(Span::name(post_recovery_span), "post.recovery.operation")
}

test "ä¼˜é›…é™çº§æµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿåœ¨éƒ¨åˆ†åŠŸèƒ½å¤±æ•ˆæ—¶çš„ä¼˜é›…é™çº§
  
  // æ¨¡æ‹Ÿå„ç§åŠŸèƒ½å¤±æ•ˆåœºæ™¯
  
  // 1. æŒ‡æ ‡é‡‡é›†å¤±æ•ˆï¼Œä½†è¿½è¸ªä»å·¥ä½œ
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "graceful.degradation")
  let span = Tracer::start_span(tracer, "degradation.test")
  
  // æŒ‡æ ‡æ“ä½œå¯èƒ½å¤±è´¥ï¼Œä½†ä¸åº”è¯¥å½±å“è¿½è¸ª
  let meter = MeterProvider::get_meter(MeterProvider::default(), "degradation.test")
  let counter = Meter::create_counter(meter, "failing.metric")
  
  // æ¨¡æ‹ŸæŒ‡æ ‡å¤±è´¥ï¼Œä½†ç»§ç»­å…¶ä»–æ“ä½œ
  Counter::add(counter, 1.0) // å¯èƒ½å¤±è´¥ä½†ä¸åº”è¯¥å´©æºƒ
  
  Span::add_event(span, "metric.failed.but.tracing.works")
  Span::end(span)
  
  // 2. æ—¥å¿—ç³»ç»Ÿå¤±æ•ˆï¼Œä½†æŒ‡æ ‡å’Œè¿½è¸ªä»å·¥ä½œ
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "failing.logger")
  let log_record = LogRecord::new(Error, "This log might fail but shouldn't crash")
  
  // æ¨¡æ‹Ÿæ—¥å¿—å¤±è´¥ï¼Œä½†ç»§ç»­å…¶ä»–æ“ä½œ
  Logger::emit(logger, log_record) // å¯èƒ½å¤±è´¥ä½†ä¸åº”è¯¥å´©æºƒ
  
  // ç»§ç»­è®°å½•æŒ‡æ ‡
  Counter::add(counter, 1.0)
  
  // ç»§ç»­è¿½è¸ªæ“ä½œ
  let fallback_span = Tracer::start_span(tracer, "fallback.operation")
  Span::end(fallback_span)
  
  // 3. ä¼ æ’­å™¨å¤±æ•ˆï¼Œä½†æœ¬åœ°æ“ä½œä»å·¥ä½œ
  let carrier = TextMapCarrier::new()
  TextMapCarrier::set(carrier, "test-header", "test-value")
  
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  
  // ä¼ æ’­å¯èƒ½å¤±è´¥ï¼Œä½†æœ¬åœ°ä¸Šä¸‹æ–‡ä»å·¥ä½œ
  let ctx = Context::with_value(Context::root(), ContextKey::new("local.key"), "local.value")
  let _extracted = Context::get(ctx, ContextKey::new("local.key"))
  
  // éªŒè¯æœ¬åœ°æ“ä½œä»æ­£å¸¸
  let local_span = Tracer::start_span(tracer, "local.operation")
  Span::end(local_span)
  
  // 4. éƒ¨åˆ†å±æ€§å¤±æ•ˆï¼Œä½†æ ¸å¿ƒåŠŸèƒ½ä¿æŒ
  let attrs = Attributes::new()
  
  // è®¾ç½®ä¸€äº›å¯èƒ½æˆåŠŸçš„å±æ€§
  Attributes::set(attrs, "working.key", StringValue("working.value"))
  Attributes::set(attrs, "number.key", IntValue(42))
  
  // å°è¯•è®¾ç½®å¯èƒ½å¤±è´¥çš„å±æ€§ï¼ˆå¦‚æé•¿å­—ç¬¦ä¸²ï¼‰
  Attributes::set(attrs, "potentially.failing.key", StringValue("a".repeat(1000000)))
  
  // éªŒè¯å¯ä»¥è¯»å–æˆåŠŸçš„å±æ€§
  let working_value = Attributes::get(attrs, "working.key")
  match working_value {
    Some(StringValue(value)) => assert_eq(value, "working.value")
    _ => assert_true(false)
  }
  
  // 5. éªŒè¯é™çº§åçš„ç³»ç»Ÿä»èƒ½æä¾›åŸºæœ¬åŠŸèƒ½
  let degradation_counter = Meter::create_counter(meter, "degradation.operations")
  let degradation_histogram = Meter::create_histogram(meter, "degradation.latency")
  
  Counter::add(degradation_counter, 1.0)
  Histogram::record(degradation_histogram, 100.0)
  
  let degradation_log = LogRecord::new(Warn, "System operating in degraded mode")
  Logger::emit(logger, degradation_log)
  
  let degradation_span = Tracer::start_span(tracer, "degraded.operation")
  Span::set_status(degradation_span, Ok, Some("Operation completed in degraded mode"))
  Span::end(degradation_span)
  
  // éªŒè¯åŸºæœ¬åŠŸèƒ½ä»ç„¶å·¥ä½œ
  assert_eq(degradation_counter.name, "degradation.operations")
  assert_eq(degradation_histogram.name, "degradation.latency")
  assert_eq(Span::name(degradation_span), "degraded.operation")
}