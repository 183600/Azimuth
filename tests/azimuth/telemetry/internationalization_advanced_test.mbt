// é«˜çº§å›½é™…åŒ–å’Œæœ¬åœ°åŒ–é…ç½®æµ‹è¯•
// Advanced internationalization and localization configuration tests

test "å¤šè¯­è¨€å±æ€§é”®å€¼æµ‹è¯•" {
  // æµ‹è¯•å„ç§è¯­è¨€çš„å±æ€§é”®å’Œå€¼å¤„ç†
  
  let attrs = Attributes::new()
  
  // æµ‹è¯•å¤šè¯­è¨€å±æ€§é”®
  let multilingual_keys = [
    ("chinese_key", StringValue("ä¸­æ–‡å€¼")),
    ("russian_key", StringValue("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ")),
    ("arabic_key", StringValue("Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©")),
    ("japanese_key", StringValue("æ—¥æœ¬èªã®å€¤")),
    ("korean_key", StringValue("í•œêµ­ì–´ ê°’")),
    ("hebrew_key", StringValue("×¢×¨×š ×¢×‘×¨×™")),
    ("thai_key", StringValue("à¸„à¹ˆà¸²à¸ à¸²à¸©à¸²à¹„à¸—à¸¢")),
    ("hindi_key", StringValue("à¤¹à¤¿à¤‚à¤¦à¥€ à¤®à¥‚à¤²à¥à¤¯")),
    ("emoji_key", StringValue("ğŸš€ğŸ”¥ğŸ’¯ğŸ‰æµ‹è¯•å€¼"))
  ]
  
  for (key, value) in multilingual_keys {
    Attributes::set(attrs, key, value)
    let retrieved = Attributes::get(attrs, key)
    assert_true(retrieved.is_some())
    
    match retrieved.unwrap() {
      StringValue(s) => assert_eq(s, match value { StringValue(str) => str, _ => "" })
      _ => assert_true(false, "Expected StringValue for multilingual key: " + key)
    }
  }
  
  // æµ‹è¯•æ··åˆè¯­è¨€å±æ€§é”®
  let mixed_language_keys = [
    ("service.åç§°", StringValue("æ”¯ä»˜æœåŠ¡")),
    ("user.Ğ¸Ğ¼Ñ", StringValue("Ğ˜Ğ²Ğ°Ğ½ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²")),
    ("operation.Ù†ÙˆØ¹", StringValue("Ø¹Ù…Ù„ÙŠØ© Ø¯ÙØ¹")),
    ("metric.å˜ä½", StringValue("ãƒŸãƒªç§’")),
    ("error.ë©”ì‹œì§€", StringValue("ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì‹¤íŒ¨"))
  ]
  
  for (key, value) in mixed_language_keys {
    Attributes::set(attrs, key, value)
    let retrieved = Attributes::get(attrs, key)
    assert_true(retrieved.is_some())
  }
}

test "æœ¬åœ°åŒ–æ—¥å¿—æ¶ˆæ¯æµ‹è¯•" {
  // æµ‹è¯•æœ¬åœ°åŒ–æ—¥å¿—æ¶ˆæ¯çš„å¤„ç†
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "i18n_test_logger")
  
  // æµ‹è¯•å¤šè¯­è¨€æ—¥å¿—æ¶ˆæ¯
  let multilingual_messages = [
    (Info, "æ“ä½œæˆåŠŸå®Œæˆ"),
    (Warn, "è­¦å‘Šï¼šå†…å­˜ä½¿ç”¨ç‡è¿‡é«˜"),
    (Error, "é”™è¯¯ï¼šæ•°æ®åº“è¿æ¥å¤±è´¥"),
    (Debug, "è°ƒè¯•ä¿¡æ¯ï¼šç”¨æˆ·è®¤è¯æˆåŠŸ"),
    (Trace, "è·Ÿè¸ªï¼šè¯·æ±‚å¤„ç†å¼€å§‹"),
    (Fatal, "ä¸¥é‡é”™è¯¯ï¼šç³»ç»Ÿæ— æ³•æ¢å¤"),
    (Info, "Operation completed successfully"),
    (Error, "ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ"),
    (Warn, "Advertencia: uso elevado de memoria"),
    (Info, "æ“ä½œã¯æ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ"),
    (Error, "ì˜¤ë¥˜: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨")
  ]
  
  for (severity, message) in multilingual_messages {
    let log = LogRecord::new(severity, message)
    assert_eq(LogRecord::severity_number(log), severity)
    assert_eq(LogRecord::body(log), Some(message))
    Logger::emit(logger, log)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—æ¶ˆæ¯
  let special_char_messages = [
    "Line 1
Line 2
Line 3", // å¤šè¡Œæ¶ˆæ¯
    "Tab	Separated	Values", // åˆ¶è¡¨ç¬¦åˆ†éš”
    "Quote: \"Test Message\"", // å¼•å·
    "Apostrophe: 'Test Message'", // æ’‡å·
    "Backslash: C:\\Users\\Test", // åæ–œæ 
    "Unicode: æµ‹è¯• ğŸš€ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© æ—¥æœ¬èª í•œêµ­×™" // æ··åˆUnicode
  ]
  
  for message in special_char_messages {
    let log = LogRecord::new(Info, message)
    assert_eq(LogRecord::body(log), Some(message))
    Logger::emit(logger, log)
  }
  
  // æµ‹è¯•æé•¿çš„å¤šè¯­è¨€æ¶ˆæ¯
  let long_multilingual_message = "è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„ä¸­æ–‡æ¶ˆæ¯" * 100 + 
                                 "This is a long English message" * 100 +
                                 "Ğ­Ñ‚Ğ¾ Ğ´Ğ»Ğ¸Ğ½Ğ½Ğ¾Ğµ Ñ€ÑƒÑÑĞºĞ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ" * 50
  let long_log = LogRecord::new(Info, long_multilingual_message)
  assert_eq(LogRecord::body(long_log), Some(long_multilingual_message))
  Logger::emit(logger, long_log)
}

test "å›½é™…åŒ–èµ„æºå±æ€§æµ‹è¯•" {
  // æµ‹è¯•å›½é™…åŒ–èµ„æºå±æ€§çš„å¤„ç†
  
  let resource = Resource::new()
  
  // æµ‹è¯•å¤šè¯­è¨€èµ„æºå±æ€§
  let i18n_resource_attrs = [
    ("service.name", StringValue("æ”¯ä»˜æœåŠ¡")),
    ("service.description", StringValue("å¤„ç†ç”¨æˆ·æ”¯ä»˜è¯·æ±‚çš„å¾®æœåŠ¡")),
    ("service.owner", StringValue("å¼ ä¸‰")),
    ("deployment.region", StringValue("äºšå¤ªåœ°åŒº")),
    ("deployment.zone", StringValue("åä¸œ-ä¸Šæµ·")),
    ("host.name", StringValue("ç”Ÿäº§æœåŠ¡å™¨-01")),
    ("host.location", StringValue("æ•°æ®ä¸­å¿ƒA-æœºæŸœB-æœåŠ¡å™¨C")),
    ("process.name", StringValue("æ”¯ä»˜å¤„ç†å™¨"),
    ("telemetry.sdk.name", StringValue("æ–¹ä½è§’é¥æµ‹ç³»ç»Ÿ")),
    ("telemetry.sdk.description", StringValue("é«˜æ€§èƒ½åˆ†å¸ƒå¼é¥æµ‹æ•°æ®æ”¶é›†ç³»ç»Ÿ"))
  ]
  
  let i18n_resource = Resource::with_attributes(resource, i18n_resource_attrs)
  
  // éªŒè¯å¤šè¯­è¨€èµ„æºå±æ€§
  for (key, expected_value) in i18n_resource_attrs {
    let retrieved_value = Resource::get_attribute(i18n_resource, key)
    assert_true(retrieved_value.is_some())
    
    match retrieved_value.unwrap() {
      StringValue(s) => {
        match expected_value {
          StringValue(expected) => assert_eq(s, expected)
          _ => assert_true(false, "Expected StringValue for key: " + key)
        }
      }
      _ => assert_true(false, "Expected StringValue for key: " + key)
    }
  }
  
  // æµ‹è¯•æ··åˆè¯­è¨€çš„èµ„æºæè¿°
  let mixed_language_attrs = [
    ("service.name", StringValue("Payment Service")),
    ("service.description", StringValue("æ”¯ä»˜å¤„ç†æœåŠ¡ - Handles payment transactions")),
    ("service.version", StringValue("ç‰ˆæœ¬ 2.1.0"),
    ("service.owner", StringValue("å›¢é˜Ÿè´Ÿè´£äºº: æå›› (Team Lead: Li Si)"))
  ]
  
  let mixed_resource = Resource::with_attributes(resource, mixed_language_attrs)
  
  for (key, expected_value) in mixed_language_attrs {
    let retrieved_value = Resource::get_attribute(mixed_resource, key)
    assert_true(retrieved_value.is_some())
  }
}

test "å¤šè¯­è¨€Spanåç§°å’Œäº‹ä»¶æµ‹è¯•" {
  // æµ‹è¯•å¤šè¯­è¨€Spanåç§°å’Œäº‹ä»¶å¤„ç†
  
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "i18n_test_tracer")
  
  // æµ‹è¯•å¤šè¯­è¨€Spanåç§°
  let multilingual_span_names = [
    "æ•°æ®åº“æŸ¥è¯¢æ“ä½œ",
    "HTTPè¯·æ±‚å¤„ç†",
    "ç”¨æˆ·è®¤è¯éªŒè¯",
    "æ”¯ä»˜äº¤æ˜“å¤„ç†",
    "Database Query Operation",
    "ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…",
    "Procesamiento de base de datos",
    "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªæ“ä½œ",
    "ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì‘ì—…",
    "Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"
  ]
  
  for span_name in multilingual_span_names {
    let span = Tracer::start_span(tracer, span_name)
    assert_eq(Span::name(span), span_name)
    
    // è®¾ç½®å¤šè¯­è¨€çŠ¶æ€
    Span::set_status(span, Ok, Some("æ“ä½œæˆåŠŸ"))
    Span::end(span)
  }
  
  // æµ‹è¯•å¤šè¯­è¨€Spanäº‹ä»¶
  let span_with_events = Tracer::start_span(tracer, "å¤šè¯­è¨€äº‹ä»¶æµ‹è¯•")
  
  let multilingual_events = [
    ("å¼€å§‹å¤„ç†", [("å¼€å§‹æ—¶é—´", StringValue("2025-01-01 00:00:00"))]),
    ("éªŒè¯ç”¨æˆ·", [("ç”¨æˆ·ID", IntValue(12345))]),
    ("æŸ¥è¯¢æ•°æ®åº“", [("æŸ¥è¯¢è¯­å¥", StringValue("SELECT * FROM users WHERE id = ?"))]),
    ("å¤„ç†å®Œæˆ", [("å¤„ç†ç»“æœ", StringValue("æˆåŠŸ"))])
  ]
  
  for (event_name, event_attrs) in multilingual_events {
    Span::add_event(span_with_events, event_name, Some(event_attrs))
  }
  
  Span::end(span_with_events)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„Spanåç§°
  let special_span_names = [
    "Span with spaces and ç‰¹æ®Šå­—ç¬¦",
    "Span-with-dashes-and-ä¸‹åˆ’çº¿",
    "Span/with/slashes/and/æ–œæ ",
    "Span.with.dots.and.ç‚¹å·",
    "SpanğŸš€withğŸ”¥emojiğŸ’¯andğŸ‰è¡¨æƒ…"
  ]
  
  for span_name in special_span_names {
    let span = Tracer::start_span(tracer, span_name)
    assert_eq(Span::name(span), span_name)
    Span::end(span)
  }
}

test "å›½é™…åŒ–æŒ‡æ ‡åç§°å’Œæè¿°æµ‹è¯•" {
  // æµ‹è¯•å›½é™…åŒ–æŒ‡æ ‡åç§°å’Œæè¿°çš„å¤„ç†
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "i18n_test_meter")
  
  // æµ‹è¯•å¤šè¯­è¨€æŒ‡æ ‡åç§°
  let multilingual_metrics = [
    ("è¯·æ±‚æ•°é‡", "æ€»è¯·æ±‚æ•°é‡", "ä¸ª"),
    ("å“åº”æ—¶é—´", "å¹³å‡å“åº”æ—¶é—´", "æ¯«ç§’"),
    ("é”™è¯¯ç‡", "é”™è¯¯è¯·æ±‚ç™¾åˆ†æ¯”", "%"),
    ("å¹¶å‘ç”¨æˆ·æ•°", "å½“å‰åœ¨çº¿ç”¨æˆ·æ•°", "äºº"),
    ("request_count", "Total number of requests", "requests"),
    ("response_time_rus", "Ğ¡Ñ€ĞµĞ´Ğ½ĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ°", "Ğ¼Ğ¸Ğ»Ğ»Ğ¸ÑĞµĞºÑƒĞ½Ğ´Ñ‹"),
    ("error_rate_jp", "ã‚¨ãƒ©ãƒ¼ç‡", "ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆ"),
    ("active_connections_ko", "í™œì„± ì—°ê²° ìˆ˜", "ê°œ"),
    ("throughput_ar", "Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù†Ù‚Ù„", "Ø·Ù„Ø¨ ÙÙŠ Ø§Ù„Ø«Ø§Ù†ÙŠØ©")
  ]
  
  for (name, description, unit) in multilingual_metrics {
    let counter = Meter::create_counter(meter, name)
    let instrument = Counter(counter.name, Some(description), Some(unit))
    
    assert_eq(Instrument::name(instrument), name)
    assert_eq(Instrument::description(instrument), Some(description))
    assert_eq(Instrument::unit(instrument), Some(unit))
    
    // è®°å½•æŒ‡æ ‡å€¼
    Counter::add(counter, 1.0)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æŒ‡æ ‡åç§°
  let special_metric_names = [
    "metric.with.dots.and.ç‚¹å·",
    "metric-with-dashes-and-ç ´æŠ˜å·",
    "metric/with/slashes/and/æ–œæ ",
    "metric_with_underscores_and_ä¸‹åˆ’çº¿",
    "metricğŸš€withğŸ”¥emojiğŸ’¯andğŸ‰è¡¨æƒ…"
  ]
  
  for name in special_metric_names {
    let counter = Meter::create_counter(meter, name)
    let instrument = Counter(counter.name, Some("ç‰¹æ®Šå­—ç¬¦æŒ‡æ ‡æè¿°"), Some("å•ä½"))
    assert_eq(Instrument::name(instrument), name)
    Counter::add(counter, 1.0)
  }
}

test "å›½é™…åŒ–ä¸Šä¸‹æ–‡ä¼ æ’­æµ‹è¯•" {
  // æµ‹è¯•å›½é™…åŒ–ä¸Šä¸‹æ–‡çš„ä¼ æ’­å’Œå¤„ç†
  
  // åˆ›å»ºå¤šè¯­è¨€ä¸Šä¸‹æ–‡
  let ctx = Context::root()
  
  // æ·»åŠ å¤šè¯­è¨€ä¸Šä¸‹æ–‡å€¼
  let i18n_context_keys = [
    ("ç”¨æˆ·è¯­è¨€", "zh-CN"),
    ("æœåŠ¡åç§°", "æ”¯ä»˜æœåŠ¡"),
    ("æ“ä½œç±»å‹", "æ•°æ®åº“æŸ¥è¯¢"),
    ("ç”¨æˆ·åŒºåŸŸ", "äºšå¤ªåœ°åŒº"),
    ("request.language", "en-US"),
    ("service.name.rus", "ÑĞ»ÑƒĞ¶Ğ±Ğ° Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹"),
    ("operation.type.jp", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒª"),
    ("user.region.ko", "ì•„ì‹œì•„ íƒœí‰ì–‘")
  ]
  
  let mut current_ctx = ctx
  for (key_suffix, value) in i18n_context_keys {
    let key = ContextKey::new(key_suffix)
    current_ctx = Context::with_value(current_ctx, key, value)
  }
  
  // éªŒè¯å¤šè¯­è¨€ä¸Šä¸‹æ–‡å€¼
  for (key_suffix, expected_value) in i18n_context_keys {
    let key = ContextKey::new(key_suffix)
    let retrieved_value = Context::get(current_ctx, key)
    assert_eq(retrieved_value, Some(expected_value))
  }
  
  // æµ‹è¯•å¤šè¯­è¨€Baggageä¼ æ’­
  let baggage = Baggage::new()
  let mut current_baggage = baggage
  
  let i18n_baggage_entries = [
    ("user.locale", "zh-CN"),
    ("service.name", "æ”¯ä»˜æœåŠ¡"),
    ("operation.name", "process_payment"),
    ("user.timezone", "Asia/Shanghai"),
    ("request.encoding", "UTF-8"),
    ("error.message", "æ•°æ®åº“è¿æ¥å¤±è´¥")
  ]
  
  for (key, value) in i18n_baggage_entries {
    current_baggage = Baggage::set_entry(current_baggage, key, value)
  }
  
  // éªŒè¯å¤šè¯­è¨€Baggageé¡¹
  for (key, expected_value) in i18n_baggage_entries {
    let retrieved_value = Baggage::get_entry(current_baggage, key)
    assert_eq(retrieved_value, Some(expected_value))
  }
}

test "æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯æµ‹è¯•" {
  // æµ‹è¯•æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯çš„å¤„ç†å’Œä¼ æ’­
  
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "i18n_error_tracer")
  
  // æµ‹è¯•å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  let i18n_error_messages = [
    ("zh-CN", "æ•°æ®åº“è¿æ¥å¤±è´¥"),
    ("en-US", "Database connection failed"),
    ("ru-RU", "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"),
    ("ja-JP", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ"),
    ("ko-KR", "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤"),
    ("ar-SA", "ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"),
    ("es-ES", "Error en la conexiÃ³n a la base de datos"),
    ("de-DE", "Datenbankverbindung fehlgeschlagen"),
    ("fr-FR", "Ã‰chec de la connexion Ã  la base de donnÃ©es")
  ]
  
  for (locale, error_message) in i18n_error_messages {
    let span = Tracer::start_span(tracer, "error_operation_" + locale)
    
    // è®¾ç½®æœ¬åœ°åŒ–é”™è¯¯çŠ¶æ€
    let localized_error = "[" + locale + "] " + error_message
    Span::set_status(span, Error, Some(localized_error))
    assert_eq(Span::status(span), Error)
    
    Span::end(span)
  }
  
  // æµ‹è¯•é”™è¯¯ä¸Šä¸‹æ–‡ä¼ æ’­
  let error_span = Tracer::start_span(tracer, "æœ¬åœ°åŒ–é”™è¯¯ä¼ æ’­")
  
  // åˆ›å»ºé”™è¯¯ä¸Šä¸‹æ–‡
  let error_locale_key = ContextKey::new("error.locale")
  let error_code_key = ContextKey::new("error.code")
  let error_message_key = ContextKey::new("error.message")
  
  let error_ctx = Context::with_value(Context::root(), error_locale_key, "zh-CN")
  let error_ctx_with_code = Context::with_value(error_ctx, error_code_key, "DB_CONN_ERROR")
  let error_ctx_with_message = Context::with_value(error_ctx_with_code, error_message_key, "æ•°æ®åº“è¿æ¥å¤±è´¥")
  
  // éªŒè¯é”™è¯¯ä¸Šä¸‹æ–‡
  let locale = Context::get(error_ctx_with_message, error_locale_key)
  let code = Context::get(error_ctx_with_message, error_code_key)
  let message = Context::get(error_ctx_with_message, error_message_key)
  
  assert_eq(locale, Some("zh-CN"))
  assert_eq(code, Some("DB_CONN_ERROR"))
  assert_eq(message, Some("æ•°æ®åº“è¿æ¥å¤±è´¥"))
  
  Span::end(error_span)
}

test "æ—¶åŒºå’Œæ—¶é—´æ ¼å¼å›½é™…åŒ–æµ‹è¯•" {
  // æµ‹è¯•æ—¶åŒºå’Œæ—¶é—´æ ¼å¼çš„å›½é™…åŒ–å¤„ç†
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "i18n_time_logger")
  
  // æµ‹è¯•ä¸åŒæ—¶åŒºçš„æ—¶é—´æˆ³
  let base_timestamp = 1735689600000000000L // 2025-01-01 00:00:00 UTC
  
  let timezone_offsets = [
    ("UTC", 0L),
    ("Asia/Shanghai", 8L * 3600L * 1000000000L),
    ("America/New_York", -5L * 3600L * 1000000000L),
    ("Europe/London", 0L),
    ("Asia/Tokyo", 9L * 3600L * 1000000000L),
    ("America/Los_Angeles", -8L * 3600L * 1000000000L)
  ]
  
  for (timezone, offset) in timezone_offsets {
    let localized_timestamp = base_timestamp + offset
    
    let log = LogRecord::new_with_context(
      Info,
      Some("Localized timestamp for " + timezone),
      None,
      Some(localized_timestamp),
      Some(base_timestamp),
      None,
      None,
      None
    )
    
    Logger::emit(logger, log)
  }
  
  // æµ‹è¯•å¤šè¯­è¨€æ—¥æœŸæ ¼å¼æ¶ˆæ¯
  let date_format_messages = [
    "2025å¹´1æœˆ1æ—¥ 00:00:00 (åŒ—äº¬æ—¶é—´)",
    "January 1, 2025 00:00:00 (UTC)",
    "1 ÑĞ½Ğ²Ğ°Ñ€Ñ 2025 Ğ³. 00:00:00 (ĞœĞ¾ÑĞºĞ²Ğ°)",
    "2025å¹´1æœˆ1æ—¥ 0æ™‚0åˆ†0ç§’ (æ—¥æœ¬æ¨™æº–æ™‚)",
    "2025ë…„ 1ì›” 1ì¼ 00:00:00 (í•œêµ­ í‘œì¤€ì‹œ)",
    "Ù¡ ÙŠÙ†Ø§ÙŠØ± Ù¢Ù Ù¢Ù¥ Ù Ù :Ù Ù :Ù Ù  (ØªÙˆÙ‚ÙŠØª Ù…ÙƒØ©)"
  ]
  
  for message in date_format_messages {
    let log = LogRecord::new(Info, message)
    assert_eq(LogRecord::body(log), Some(message))
    Logger::emit(logger, log)
  }
  
  // æµ‹è¯•ç›¸å¯¹æ—¶é—´æ¶ˆæ¯
  let relative_time_messages = [
    "æ“ä½œåœ¨5ç§’å‰å®Œæˆ",
    "Operation completed 5 seconds ago",
    "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ° 5 ÑĞµĞºÑƒĞ½Ğ´ Ğ½Ğ°Ğ·Ğ°Ğ´",
    "æ“ä½œã¯5ç§’å‰ã«å®Œäº†ã—ã¾ã—ãŸ",
    "ì‘ì—…ì´ 5ì´ˆ ì „ì— ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤",
    "Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù‚Ø¨Ù„ 5 Ø«ÙˆØ§Ù†Ù"
  ]
  
  for message in relative_time_messages {
    let log = LogRecord::new(Info, message)
    Logger::emit(logger, log)
  }
}