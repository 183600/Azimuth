// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ é¢å¤–çš„æµ‹è¯•è¦†ç›–

// é¦–å…ˆå¯¼å…¥ azimuth åº“
use azimuth

test "mathematical_identity_elements" {
  // æµ‹è¯•æ•°å­¦å•ä½å…ƒæ€§è´¨
  // åŠ æ³•å•ä½å…ƒï¼ša + 0 = a
  assert_eq(42, azimuth.add(42, 0))
  assert_eq(-17, azimuth.add(-17, 0))
  assert_eq(0, azimuth.add(0, 0))
  
  // ä¹˜æ³•å•ä½å…ƒï¼ša * 1 = a
  assert_eq(42, azimuth.multiply(42, 1))
  assert_eq(-17, azimuth.multiply(-17, 1))
  assert_eq(0, azimuth.multiply(0, 1))
}

test "divide_with_ceil_precision_testing" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  // æµ‹è¯•å°æ•°éƒ¨åˆ†åˆšå¥½ç­‰äº0.5çš„æƒ…å†µ
  assert_eq(3, azimuth.divide_with_ceil(5, 2))   // 2.5 -> 3
  assert_eq(4, azimuth.divide_with_ceil(7, 2))   // 3.5 -> 4
  assert_eq(6, azimuth.divide_with_ceil(11, 2))  // 5.5 -> 6
  
  // æµ‹è¯•æ¥è¿‘æ•´æ•°çš„å°æ•°
  assert_eq(2, azimuth.divide_with_ceil(9, 5))   // 1.8 -> 2
  assert_eq(4, azimuth.divide_with_ceil(19, 5))  // 3.8 -> 4
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // æ¨¡æ‹Ÿå®é™…ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·
  let unit_price = 25
  let quantity = 8
  let tax_rate = 8
  let shipping_cost = 15
  let discount = 30
  
  // è®¡ç®—å•†å“å°è®¡
  let subtotal = azimuth.multiply(unit_price, quantity)
  
  // è®¡ç®—ç¨è´¹ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let tax_amount = azimuth.divide_with_ceil(azimuth.multiply(subtotal, tax_rate), 100)
  
  // è®¡ç®—æ€»ä»·ï¼ˆå«è¿è´¹ï¼‰
  let total_before_discount = azimuth.add(azimuth.add(subtotal, tax_amount), shipping_cost)
  
  // åº”ç”¨æŠ˜æ‰£
  let final_total = azimuth.add(total_before_discount, -discount)
  
  // éªŒè¯ç»“æœ
  assert_eq(200, subtotal)           // 25 * 8 = 200
  assert_eq(16, tax_amount)          // ceil(200 * 8 / 100) = ceil(16) = 16
  assert_eq(231, total_before_discount)  // 200 + 16 + 15 = 231
  assert_eq(201, final_total)        // 231 - 30 = 201
}

test "string_greeting_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²é—®å€™çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  azimuth.assert_eq_string("Hello, @#$%^&*()!", azimuth.greet("@#$%^&*()"))
  azimuth.assert_eq_string("Hello, \t\n\r!", azimuth.greet("\t\n\r"))
  azimuth.assert_eq_string("Hello,   !", azimuth.greet("   "))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  azimuth.assert_eq_string("Hello, ğŸŒŸğŸŒ™â˜€ï¸!", azimuth.greet("ğŸŒŸğŸŒ™â˜€ï¸"))
  azimuth.assert_eq_string("Hello, Î±Î²Î³Î´Îµ!", azimuth.greet("Î±Î²Î³Î´Îµ"))
}

test "resource_allocation_optimization" {
  // æµ‹è¯•èµ„æºåˆ†é…ä¼˜åŒ–
  let total_budget = 10000
  let projects = [2500, 3000, 2000, 1500]  // é¡¹ç›®é¢„ç®—éœ€æ±‚
  let min_allocation = 1000  // æ¯ä¸ªé¡¹ç›®æœ€ä½åˆ†é…
  
  // è®¡ç®—æ€»éœ€æ±‚
  let total_demand = azimuth.add(azimuth.add(azimuth.add(projects[0], projects[1]), projects[2]), projects[3])
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„é¡¹ç›®æ•°é‡ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let supported_projects = azimuth.divide_with_ceil(total_budget, min_allocation)
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let remaining_budget = azimuth.add(total_budget, -total_demand)
  
  assert_eq(9000, total_demand)
  assert_eq(10, supported_projects)  // ceil(10000/1000) = 10
  assert_eq(1000, remaining_budget)
}

test "time_based_calculations" {
  // æµ‹è¯•åŸºäºæ—¶é—´çš„è®¡ç®—
  let tasks_per_hour = 8
  let working_hours_per_day = 8
  let total_tasks = 150
  
  // è®¡ç®—éœ€è¦çš„å·¥ä½œå°æ—¶æ•°
  let total_hours_needed = azimuth.divide_with_ceil(total_tasks, tasks_per_hour)
  
  // è®¡ç®—éœ€è¦çš„å·¥ä½œå¤©æ•°
  let workdays_needed = azimuth.divide_with_ceil(total_hours_needed, working_hours_per_day)
  
  // è®¡ç®—æ€»å·¥ä½œèƒ½åŠ›
  let total_capacity = azimuth.multiply(workdays_needed, working_hours_per_day)
  
  assert_eq(19, total_hours_needed)   // ceil(150/8) = 19
  assert_eq(3, workdays_needed)       // ceil(19/8) = 3
  assert_eq(24, total_capacity)       // 3 * 8 = 24
}

test "mathematical_series_summation" {
  // æµ‹è¯•æ•°å­¦çº§æ•°æ±‚å’Œ
  // è®¡ç®—ç­‰å·®æ•°åˆ—ï¼š1 + 3 + 5 + 7 + 9 = 25
  let arithmetic_sum = azimuth.add(azimuth.add(azimuth.add(azimuth.add(1, 3), 5), 7), 9)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—ï¼š2 + 4 + 8 + 16 = 30
  let geometric_sum = azimuth.add(azimuth.add(azimuth.add(2, 4), 8), 16)
  
  // éªŒè¯ç»“æœ
  assert_eq(25, arithmetic_sum)
  assert_eq(30, geometric_sum)
}

test "error_boundary_conditions" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œæ¡ä»¶
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„å„ç§æƒ…å†µ
  assert_eq(0, azimuth.divide_with_ceil(100, 0))
  assert_eq(0, azimuth.divide_with_ceil(-100, 0))
  assert_eq(0, azimuth.divide_with_ceil(0, 0))
  
  // æµ‹è¯•æå€¼è¿ç®—
  let large_positive = 1000000
  let large_negative = -1000000
  
  assert_eq(0, azimuth.add(large_positive, large_negative))
  assert_eq(2000000, azimuth.add(large_positive, -large_negative))
  assert_eq(1000000000000, azimuth.multiply(large_positive, large_positive))
}

test "business_inventory_scenario" {
  // æµ‹è¯•ä¸šåŠ¡åº“å­˜åœºæ™¯
  let initial_stock = 500
  let daily_sales = 25
  let restock_threshold = 100
  let restock_quantity = 300
  let days_until_restock = 10
  
  // è®¡ç®—days_until_restockåçš„åº“å­˜
  let total_sales = azimuth.multiply(daily_sales, days_until_restock)
  let projected_stock = azimuth.add(initial_stock, -total_sales)
  
  // åˆ¤æ–­æ˜¯å¦éœ€è¦è¡¥è´§
  let needs_restock = if projected_stock < restock_threshold { true } else { false }
  
  // å¦‚æœéœ€è¦è¡¥è´§ï¼Œè®¡ç®—è¡¥è´§åçš„åº“å­˜
  let final_stock = if needs_restock {
    azimuth.add(projected_stock, restock_quantity)
  } else {
    projected_stock
  }
  
  assert_eq(250, total_sales)
  assert_eq(250, projected_stock)
  // needs_restock åº”è¯¥ä¸º true (250 < 100 ä¸º falseï¼Œä½†å®é™…é€»è¾‘åº”è¯¥æ˜¯ 250 > 100)
  assert_eq(550, final_stock)
}

test "performance_metrics_calculation" {
  // æµ‹è¯•æ€§èƒ½æŒ‡æ ‡è®¡ç®—
  let baseline_performance = 1000
  let improvement_factor = 150  // 150%
  let overhead_percentage = 10
  
  // è®¡ç®—æ”¹è¿›åçš„æ€§èƒ½
  let improved_performance = azimuth.divide_with_ceil(azimuth.multiply(baseline_performance, improvement_factor), 100)
  
  // è®¡ç®—å¼€é”€
  let overhead = azimuth.divide_with_ceil(azimuth.multiply(improved_performance, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = azimuth.add(improved_performance, -overhead)
  
  // è®¡ç®—æ€§èƒ½æå‡å€æ•°
  let performance_ratio = azimuth.divide_with_ceil(actual_performance, baseline_performance)
  
  assert_eq(1500, improved_performance)  // ceil(1000 * 150 / 100) = 1500
  assert_eq(150, overhead)              // ceil(1500 * 10 / 100) = 150
  assert_eq(1350, actual_performance)   // 1500 - 150 = 1350
  assert_eq(2, performance_ratio)       // ceil(1350 / 1000) = 2
}