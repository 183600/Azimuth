// Azimuth é¡¹ç›®é™„åŠ æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•

test "add_with_floating_point_conversion" {
  // æµ‹è¯•æ•´æ•°åŠ æ³•çš„ç²¾åº¦
  let result1 = azimuth::add(1000, 2000)
  assert_eq(result1, 3000)
  
  let result2 = azimuth::add(-500, 250)
  assert_eq(result2, -250)
}

test "multiply_by_negative_one" {
  // æµ‹è¯•ä¹˜ä»¥-1çš„ç¬¦å·å˜åŒ–
  let positive = 42
  let negative = -42
  
  let result1 = azimuth::multiply(positive, -1)
  assert_eq(result1, -42)
  
  let result2 = azimuth::multiply(negative, -1)
  assert_eq(result2, 42)
}

test "greet_with_whitespace" {
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let result1 = azimuth::greet("John Doe")
  assert_eq(result1, "Hello, John Doe!")
  
  let result2 = azimuth::greet("  spaced  ")
  assert_eq(result2, "Hello,   spaced  !")
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­è¿ç®—
  let start = 10
  let step1 = azimuth::add(start, 5)  // 15
  let step2 = azimuth::multiply(step1, 2)  // 30
  let step3 = azimuth::add(step2, -10)  // 20
  
  assert_eq(step3, 20)
}

test "identity_operations" {
  // æµ‹è¯•å•ä½å…ƒè¿ç®—
  let value = 123
  
  // åŠ æ³•å•ä½å…ƒ
  let add_identity = azimuth::add(value, 0)
  assert_eq(add_identity, value)
  
  // ä¹˜æ³•å•ä½å…ƒ
  let mult_identity = azimuth::multiply(value, 1)
  assert_eq(mult_identity, value)
}

test "string_length_cases" {
  // æµ‹è¯•ä¸åŒé•¿åº¦çš„å­—ç¬¦ä¸²
  let short = "Hi"
  let medium = "MoonBit"
  let long = "This is a very long string for testing purposes"
  
  let result1 = azimuth::greet(short)
  assert_eq(result1, "Hello, Hi!")
  
  let result2 = azimuth::greet(medium)
  assert_eq(result2, "Hello, MoonBit!")
  
  let result3 = azimuth::greet(long)
  assert_eq(result3, "Hello, This is a very long string for testing purposes!")
}

test "negative_zero_operations" {
  // æµ‹è¯•è´Ÿé›¶ç›¸å…³è¿ç®—
  let positive = 15
  let negative = -15
  
  let result1 = azimuth::add(positive, -15)
  assert_eq(result1, 0)
  
  let result2 = azimuth::add(negative, 15)
  assert_eq(result2, 0)
}

test "multiply_by_zero_variations" {
  // æµ‹è¯•å„ç§é›¶çš„ä¹˜æ³•
  let positive = 100
  let negative = -100
  
  let result1 = azimuth::multiply(positive, 0)
  assert_eq(result1, 0)
  
  let result2 = azimuth::multiply(negative, 0)
  assert_eq(result2, 0)
  
  let result3 = azimuth::multiply(0, 0)
  assert_eq(result3, 0)
}

test "greet_with_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let result1 = azimuth::greet("CafÃ©")
  assert_eq(result1, "Hello, CafÃ©!")
  
  let result2 = azimuth::greet("æµ‹è¯•")
  assert_eq(result2, "Hello, æµ‹è¯•!")
  
  let result3 = azimuth::greet("ğŸŒ™")
  assert_eq(result3, "Hello, ğŸŒ™!")
}

test "additive_inverse_property" {
  // æµ‹è¯•åŠ æ³•é€†å…ƒæ€§è´¨
  let values = [0, 1, -1, 42, -100, 999999]
  
  for value in values {
    let inverse = azimuth::multiply(value, -1)
    let result = azimuth::add(value, inverse)
    assert_eq(result, 0)
  }
}