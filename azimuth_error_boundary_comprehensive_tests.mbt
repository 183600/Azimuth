// Azimuth é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿåœ¨å„ç§å¼‚å¸¸æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º

test "ç©ºå€¼å’ŒNoneå¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å±žæ€§å€¼
  let empty_string_attr = azimuth::AttributeValue::StringValue("")
  match empty_string_attr {
    azimuth::AttributeValue::StringValue(s) => assert_eq(s, "")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•Noneé€‰é¡¹ç±»åž‹
  let none_option : Option<String> = None
  match none_option {
    Some(_) => assert_true(false)
    None => assert_true(true)
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_array = []
  assert_eq(empty_array.length(), 0)
  
  // æµ‹è¯•ç©ºå±žæ€§é›†åˆ
  let empty_attrs = azimuth::Attributes { values: [] }
  assert_eq(empty_attrs.values.length(), 0)
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_context = azimuth::Context { data: None }
  match empty_context.data {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
}

test "æ•°å€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æœ€å¤§æ•´æ•°å€¼
  let max_int = 2147483647
  let max_int_attr = azimuth::AttributeValue::IntValue(max_int)
  match max_int_attr {
    azimuth::AttributeValue::IntValue(v) => assert_eq(v, max_int)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æœ€å°æ•´æ•°å€¼
  let min_int = -2147483648
  let min_int_attr = azimuth::AttributeValue::IntValue(min_int)
  match min_int_attr {
    azimuth::AttributeValue::IntValue(v) => assert_eq(v, min_int)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é›¶å€¼
  let zero_int = azimuth::AttributeValue::IntValue(0)
  match zero_int {
    azimuth::AttributeValue::IntValue(v) => assert_eq(v, 0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œå€¼
  let max_float = azimuth::AttributeValue::FloatValue(1.7976931348623157e+308) // æœ€å¤§åŒç²¾åº¦æµ®ç‚¹æ•°
  match max_float {
    azimuth::AttributeValue::FloatValue(v) => assert_true(v > 1.0e+308)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æœ€å°æ­£æµ®ç‚¹æ•°
  let min_positive_float = azimuth::AttributeValue::FloatValue(2.2250738585072014e-308)
  match min_positive_float {
    azimuth::AttributeValue::FloatValue(v) => assert_true(v > 0.0 && v < 1.0e-307)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•è´Ÿé›¶
  let negative_zero = azimuth::AttributeValue::FloatValue(-0.0)
  match negative_zero {
    azimuth::AttributeValue::FloatValue(v) => assert_eq(v, -0.0)
    _ => assert_true(false)
  }
}

test "å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_str = azimuth::AttributeValue::StringValue("")
  match empty_str {
    azimuth::AttributeValue::StringValue(s) => assert_eq(s.length(), 0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å•å­—ç¬¦å­—ç¬¦ä¸²
  let single_char = azimuth::AttributeValue::StringValue("a")
  match single_char {
    azimuth::AttributeValue::StringValue(s) => assert_eq(s.length(), 1)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²ï¼ˆ1000ä¸ªå­—ç¬¦ï¼‰
  let mut long_str = ""
  for i in 0..1000 {
    long_str = long_str + "a"
  }
  let long_str_attr = azimuth::AttributeValue::StringValue(long_str)
  match long_str_attr {
    azimuth::AttributeValue::StringValue(s) => assert_eq(s.length(), 1000)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²
  let special_chars = azimuth::AttributeValue::StringValue("\n\t\r\\\"'")
  match special_chars {
    azimuth::AttributeValue::StringValue(s) => {
      assert_true(s.contains("\n"))
      assert_true(s.contains("\t"))
      assert_true(s.contains("\r"))
      assert_true(s.contains("\\"))
      assert_true(s.contains("\""))
      assert_true(s.contains("'"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_str = azimuth::AttributeValue::StringValue("æµ‹è¯•ä¸­æ–‡ðŸš€emoji")
  match unicode_str {
    azimuth::AttributeValue::StringValue(s) => {
      assert_true(s.contains("æµ‹è¯•"))
      assert_true(s.contains("ä¸­æ–‡"))
      assert_true(s.contains("ðŸš€"))
      assert_true(s.contains("emoji"))
    }
    _ => assert_true(false)
  }
}

test "æ•°ç»„è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_array = azimuth::AttributeValue::ArrayStringValue([])
  match empty_array {
    azimuth::AttributeValue::ArrayStringValue(arr) => assert_eq(arr.length(), 0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_element = azimuth::AttributeValue::ArrayIntValue([42])
  match single_element {
    azimuth::AttributeValue::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 1)
      assert_eq(arr[0], 42)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¤§æ•°ç»„ï¼ˆ1000ä¸ªå…ƒç´ ï¼‰
  let mut large_int_array = []
  for i in 0..1000 {
    large_int_array = large_int_array + [i]
  }
  let large_array_attr = azimuth::AttributeValue::ArrayIntValue(large_int_array)
  match large_array_attr {
    azimuth::AttributeValue::ArrayIntValue(arr) => {
      assert_eq(arr.length(), 1000)
      assert_eq(arr[0], 0)
      assert_eq(arr[999], 999)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ··åˆç±»åž‹æ•°ç»„ï¼ˆé€šè¿‡å­—ç¬¦ä¸²è¡¨ç¤ºï¼‰
  let mixed_array = azimuth::AttributeValue::ArrayStringValue([
    "string_value",
    "42",
    "3.14",
    "true",
    ""
  ])
  match mixed_array {
    azimuth::AttributeValue::ArrayStringValue(arr) => {
      assert_eq(arr.length(), 5)
      assert_eq(arr[0], "string_value")
      assert_eq(arr[1], "42")
      assert_eq(arr[2], "3.14")
      assert_eq(arr[3], "true")
      assert_eq(arr[4], "")
    }
    _ => assert_true(false)
  }
}

test "å¼‚å¸¸æƒ…å†µå¤„ç†æµ‹è¯•" {
  // æµ‹è¯•æ— æ•ˆçš„è¿½è¸ªID
  let invalid_trace_id = ""
  let invalid_span_context = azimuth::SpanContext {
    trace_id: invalid_trace_id,
    span_id: "valid_span_id",
    sampled: true,
    trace_state: "test_state"
  }
  assert_false(invalid_trace_id.length() > 0)
  
  // æµ‹è¯•æ— æ•ˆçš„è·¨åº¦ID
  let invalid_span_id = ""
  let invalid_span_context2 = azimuth::SpanContext {
    trace_id: "valid_trace_id",
    span_id: invalid_span_id,
    sampled: true,
    trace_state: "test_state"
  }
  assert_false(invalid_span_id.length() > 0)
  
  // æµ‹è¯•è´Ÿæ•°æ•°ç»„ç´¢å¼•å¤„ç†
  let test_array = [1, 2, 3, 4, 5]
  let array_length = test_array.length()
  
  // æµ‹è¯•è¾¹ç•Œè®¿é—®
  if array_length > 0 {
    assert_eq(test_array[0], 1) // ç¬¬ä¸€ä¸ªå…ƒç´ 
    assert_eq(test_array[array_length - 1], 5) // æœ€åŽä¸€ä¸ªå…ƒç´ 
  }
  
  // æµ‹è¯•é™¤é›¶é”™è¯¯å¤„ç†
  let numerator = 10
  let denominator = 0
  
  // å®‰å…¨çš„é™¤æ³•æ“ä½œ
  let result = if denominator != 0 {
    numerator / denominator
  } else {
    0 // é»˜è®¤å€¼æˆ–é”™è¯¯å¤„ç†
  }
  assert_eq(result, 0) // å› ä¸ºåˆ†æ¯ä¸º0ï¼Œè¿”å›žé»˜è®¤å€¼
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²æ“ä½œ
  let empty_string = ""
  let string_length = empty_string.length()
  assert_eq(string_length, 0)
  
  // æµ‹è¯•å­—ç¬¦ä¸²ç´¢å¼•è®¿é—®
  let test_string = "hello"
  if test_string.length() > 2 {
    let char_at_index = test_string[2] // å‡è®¾çš„å­—ç¬¦ä¸²ç´¢å¼•è®¿é—®
    // å®žé™…å®žçŽ°å¯èƒ½éœ€è¦ä¸åŒçš„æ–¹æ³•
    assert_true(true) // å¦‚æžœèƒ½å¤Ÿè®¿é—®ï¼Œåˆ™æµ‹è¯•é€šè¿‡
  }
}

test "èµ„æºé™åˆ¶æµ‹è¯•" {
  // æµ‹è¯•å†…å­˜ä½¿ç”¨é™åˆ¶
  let mut large_data_structure = []
  
  // åˆ›å»ºå¤§é‡æ•°æ®ï¼Œä½†æŽ§åˆ¶åœ¨åˆç†èŒƒå›´å†…
  for i in 0..10000 {
    large_data_structure = large_data_structure + [
      ("key-" + i.to_string(), azimuth::AttributeValue::StringValue("value-" + i.to_string()))
    ]
  }
  
  assert_eq(large_data_structure.length(), 10000)
  
  // æµ‹è¯•æ·±åº¦åµŒå¥—ç»“æž„
  let nested_attr = azimuth::AttributeValue::StringValue("deeply_nested_value")
  
  // éªŒè¯åµŒå¥—å±žæ€§å¯ä»¥æ­£ç¡®è®¿é—®
  match nested_attr {
    azimuth::AttributeValue::StringValue(s) => assert_eq(s, "deeply_nested_value")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é€’å½’ç»“æž„é™åˆ¶
  let mut recursive_attrs = azimuth::Attributes { values: [] }
  
  // æ·»åŠ å¤šå±‚å±žæ€§ï¼Œä½†ä¸é€ æˆæ ˆæº¢å‡º
  for i in 0..100 {
    recursive_attrs.values = recursive_attrs.values + [
      ("level-" + i.to_string(), azimuth::AttributeValue::StringValue("level_value"))
    ]
  }
  
  assert_eq(recursive_attrs.values.length(), 100)
  
  // éªŒè¯å¯ä»¥è®¿é—®æ·±å±‚å±žæ€§
  match recursive_attrs.values[99] {
    (key, azimuth::AttributeValue::StringValue(value)) => {
      assert_eq(key, "level-99")
      assert_eq(value, "level_value")
    }
    _ => assert_true(false)
  }
}

test "å¹¶å‘è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•å…±äº«èµ„æºçš„å¹¶å‘è®¿é—®
  
  // åˆ›å»ºå…±äº«å±žæ€§é›†åˆ
  let shared_attrs = azimuth::Attributes { values: [] }
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œï¼ˆå•çº¿ç¨‹çŽ¯å¢ƒä¸­çš„æ¨¡æ‹Ÿï¼‰
  let mut operations_count = 0
  
  // æ¨¡æ‹Ÿå¤šä¸ª"å¹¶å‘"æ“ä½œ
  for i in 0..100 {
    // æ¨¡æ‹Ÿæ“ä½œ1ï¼šæ·»åŠ å±žæ€§
    let new_attrs = azimuth::Attributes {
      values: shared_attrs.values + [
        ("concurrent_key_" + i.to_string(), azimuth::AttributeValue::StringValue("concurrent_value"))
      ]
    }
    
    // æ¨¡æ‹Ÿæ“ä½œ2ï¼šè¯»å–å±žæ€§
    let attrs_length = new_attrs.values.length()
    
    // æ¨¡æ‹Ÿæ“ä½œ3ï¼šæ›´æ–°å±žæ€§
    let updated_attrs = azimuth::Attributes {
      values: new_attrs.values + [
        ("updated_key_" + i.to_string(), azimuth::AttributeValue::StringValue("updated_value"))
      ]
    }
    
    operations_count = operations_count + 1
    shared_attrs.values = updated_attrs.values
  }
  
  assert_eq(operations_count, 100)
  assert_eq(shared_attrs.values.length(), 200) // æ¯æ¬¡å¾ªçŽ¯æ·»åŠ 2ä¸ªå±žæ€§
  
  // éªŒè¯æ•°æ®ä¸€è‡´æ€§
  match shared_attrs.values[0] {
    (key, azimuth::AttributeValue::StringValue(value)) => {
      assert_eq(key, "concurrent_key_0")
      assert_eq(value, "concurrent_value")
    }
    _ => assert_true(false)
  }
  
  match shared_attrs.values[1] {
    (key, azimuth::AttributeValue::StringValue(value)) => {
      assert_eq(key, "updated_key_0")
      assert_eq(value, "updated_value")
    }
    _ => assert_true(false)
  }
}

test "å¼‚å¸¸æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿä»Žå¼‚å¸¸çŠ¶æ€çš„æ¢å¤èƒ½åŠ›
  
  // æ¨¡æ‹Ÿéƒ¨åˆ†å¤±è´¥çš„å±žæ€§æ“ä½œ
  let mut recovery_attrs = azimuth::Attributes { values: [] }
  
  // æ·»åŠ ä¸€äº›æ­£å¸¸å±žæ€§
  recovery_attrs.values = [
    ("normal_key1", azimuth::AttributeValue::StringValue("normal_value1")),
    ("normal_key2", azimuth::AttributeValue::StringValue("normal_value2"))
  ]
  
  // æ¨¡æ‹Ÿæ·»åŠ "å¼‚å¸¸"å±žæ€§ï¼ˆç©ºé”®æˆ–ç‰¹æ®Šå€¼ï¼‰
  recovery_attrs.values = recovery_attrs.values + [
    ("", azimuth::AttributeValue::StringValue("empty_key_value")), // ç©ºé”®
    ("special_key", azimuth::AttributeValue::StringValue("")), // ç©ºå€¼
    ("null_key", azimuth::AttributeValue::StringValue("null_value")) // ç‰¹æ®Šå€¼
  ]
  
  // éªŒè¯ç³»ç»Ÿä»ç„¶å¯ä»¥æ­£å¸¸å·¥ä½œ
  assert_eq(recovery_attrs.values.length(), 5)
  
  // æµ‹è¯•è¿‡æ»¤å¼‚å¸¸å±žæ€§
  let mut filtered_attrs = []
  for (key, value) in recovery_attrs.values {
    if key.length() > 0 { // è¿‡æ»¤æŽ‰ç©ºé”®
      match value {
        azimuth::AttributeValue::StringValue(s) => {
          if s.length() > 0 { // è¿‡æ»¤æŽ‰ç©ºå€¼
            filtered_attrs = filtered_attrs + [(key, value)]
          }
        }
        _ => filtered_attrs = filtered_attrs + [(key, value)] // ä¿ç•™éžå­—ç¬¦ä¸²å€¼
      }
    }
  }
  
  assert_eq(filtered_attrs.length(), 2) // åªå‰©ä¸‹ä¸¤ä¸ªæ­£å¸¸å±žæ€§
  
  // éªŒè¯è¿‡æ»¤åŽçš„å±žæ€§
  match filtered_attrs[0] {
    (key, azimuth::AttributeValue::StringValue(value)) => {
      assert_eq(key, "normal_key1")
      assert_eq(value, "normal_value1")
    }
    _ => assert_true(false)
  }
  
  match filtered_attrs[1] {
    (key, azimuth::AttributeValue::StringValue(value)) => {
      assert_eq(key, "normal_key2")
      assert_eq(value, "normal_value2")
    }
    _ => assert_true(false)
  }
}