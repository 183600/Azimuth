// Azimuth Premium Quality Test Suite
// é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹é›†åˆ - æ¶µç›–æ€§èƒ½ã€å¹¶å‘ã€é”™è¯¯å¤„ç†ã€æ•°æ®å®Œæ•´æ€§ç­‰å¤šä¸ªæ–¹é¢

// æµ‹è¯•1: æ€§èƒ½åŸºå‡†æµ‹è¯•
test "performance benchmark tests" {
  // æµ‹è¯•å¤§é‡Spanåˆ›å»ºå’Œé”€æ¯çš„æ€§èƒ½
  let start_time = Time::now()
  let mut spans = []
  
  // åˆ›å»º1000ä¸ªSpan
  for i in 0..<1000 {
    let span_ctx = SpanContext::new("trace_" + i.to_string(), "span_" + i.to_string(), true, "")
    let span = Span::new("performance_test_span", Internal, span_ctx)
    spans.push(span)
  }
  
  // ç»“æŸæ‰€æœ‰Span
  for span in spans {
    Span::end(span)
  }
  
  let end_time = Time::now()
  let duration = end_time - start_time
  
  // éªŒè¯æ€§èƒ½åœ¨åˆç†èŒƒå›´å†…ï¼ˆåº”è¯¥åœ¨100mså†…å®Œæˆï¼‰
  assert_true(duration < 100)
  
  // æµ‹è¯•å¤§é‡å±æ€§è®¾ç½®çš„æ€§èƒ½
  let attrs = Attributes::new()
  let attr_start_time = Time::now()
  
  for i in 0..<500 {
    Attributes::set(attrs, "key_" + i.to_string(), StringValue("value_" + i.to_string()))
  }
  
  let attr_end_time = Time::now()
  let attr_duration = attr_end_time - attr_start_time
  
  // éªŒè¯å±æ€§è®¾ç½®æ€§èƒ½åœ¨åˆç†èŒƒå›´å†…
  assert_true(attr_duration < 50)
}

// æµ‹è¯•2: å¹¶å‘å®‰å…¨æµ‹è¯•
test "concurrent safety tests" {
  // æµ‹è¯•å¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„Spanæ“ä½œå®‰å…¨æ€§
  let span_ctx = SpanContext::new("concurrent_trace", "concurrent_span", true, "")
  let shared_span = Span::new("concurrent_test_span", Internal, span_ctx)
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ
  let mut results = []
  for i in 0..<10 {
    // åœ¨å®é™…ç¯å¢ƒä¸­ï¼Œè¿™äº›æ“ä½œä¼šå¹¶å‘æ‰§è¡Œ
    Span::add_event(shared_span, "concurrent_event_" + i.to_string(), None)
    Span::set_attribute(shared_span, "attr_" + i.to_string(), IntValue(i))
    results.push(i)
  }
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½æˆåŠŸå®Œæˆ
  assert_eq(results.length(), 10)
  assert_true(Span::is_recording(shared_span))
  
  // æµ‹è¯•å¹¶å‘å±æ€§æ“ä½œ
  let attrs = Attributes::new()
  for i in 0..<20 {
    Attributes::set(attrs, "concurrent_key_" + i.to_string(), StringValue("concurrent_value_" + i.to_string()))
  }
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½æ­£ç¡®è®¾ç½®
  for i in 0..<20 {
    let result = Attributes::get(attrs, "concurrent_key_" + i.to_string())
    match result {
      Some(StringValue(value)) => assert_eq(value, "concurrent_value_" + i.to_string())
      _ => assert_true(false)
    }
  }
  
  Span::end(shared_span)
}

// æµ‹è¯•3: é”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•
test "error handling and recovery tests" {
  // æµ‹è¯•æ— æ•ˆè¾“å…¥çš„é”™è¯¯å¤„ç†
  let invalid_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(invalid_ctx))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å±æ€§çš„å¤„ç†
  let attrs = Attributes::new()
  Attributes::set(attrs, "", StringValue("empty_key_test"))
  let result = Attributes::get(attrs, "")
  
  // æ ¹æ®å®ç°ï¼Œç©ºé”®å¯èƒ½è¢«æ¥å—æˆ–æ‹’ç»
  match result {
    Some(_) => assert_true(true) // å¦‚æœå®ç°æ¥å—ç©ºé”®
    None => assert_true(true)    // å¦‚æœå®ç°æ‹’ç»ç©ºé”®
  }
  
  // æµ‹è¯•å¤§å®¹é‡æ•°æ®å¤„ç†
  let large_value = "x" * 10000 // 10KBçš„å­—ç¬¦ä¸²
  Attributes::set(attrs, "large_value", StringValue(large_value))
  let large_result = Attributes::get(attrs, "large_value")
  
  match large_result {
    Some(StringValue(value)) => assert_eq(value.length(), 10000)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¼‚å¸¸æƒ…å†µä¸‹çš„Spanæ¢å¤
  let span_ctx = SpanContext::new("error_trace", "error_span", true, "")
  let span = Span::new("error_test_span", Internal, span_ctx)
  
  // è®¾ç½®é”™è¯¯çŠ¶æ€
  Span::set_status(span, Error, Some("Simulated error for testing"))
  assert_eq(Span::status(span), Error)
  
  // æ¢å¤åˆ°æ­£å¸¸çŠ¶æ€
  Span::set_status(span, Ok, Some("Error recovered"))
  assert_eq(Span::status(span), Ok)
  
  Span::end(span)
}

// æµ‹è¯•4: æ•°æ®å®Œæ•´æ€§æµ‹è¯•
test "data integrity tests" {
  // æµ‹è¯•æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  let original_attrs = Attributes::new()
  Attributes::set(original_attrs, "int_key", IntValue(42))
  Attributes::set(original_attrs, "string_key", StringValue("test_string"))
  Attributes::set(original_attrs, "float_key", FloatValue(3.14159))
  Attributes::set(original_attrs, "bool_key", BoolValue(true))
  
  // æ¨¡æ‹Ÿåºåˆ—åŒ–è¿‡ç¨‹
  let serialized_data = Attributes::serialize(original_attrs)
  assert_true(serialized_data.length() > 0)
  
  // æ¨¡æ‹Ÿååºåˆ—åŒ–è¿‡ç¨‹
  let deserialized_attrs = Attributes::deserialize(serialized_data)
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  let int_result = Attributes::get(deserialized_attrs, "int_key")
  match int_result {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  let string_result = Attributes::get(deserialized_attrs, "string_key")
  match string_result {
    Some(StringValue(value)) => assert_eq(value, "test_string")
    _ => assert_true(false)
  }
  
  let float_result = Attributes::get(deserialized_attrs, "float_key")
  match float_result {
    Some(FloatValue(value)) => assert_true(value > 3.14 && value < 3.15)
    _ => assert_true(false)
  }
  
  let bool_result = Attributes::get(deserialized_attrs, "bool_key")
  match bool_result {
    Some(BoolValue(value)) => assert_true(value)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•è·¨è¿›ç¨‹æ•°æ®ä¼ è¾“å®Œæ•´æ€§
  let trace_id = "0af7651916cd43dd8448eb211c80319c"
  let span_id = "b7ad6b7169203331"
  let original_ctx = SpanContext::new(trace_id, span_id, true, "test_state")
  
  // æ¨¡æ‹Ÿè·¨è¿›ç¨‹ä¼ è¾“
  let transmitted_ctx = SpanContext::transmit(original_ctx)
  let received_ctx = SpanContext::receive(transmitted_ctx)
  
  // éªŒè¯ä¼ è¾“åçš„æ•°æ®å®Œæ•´æ€§
  assert_eq(SpanContext::trace_id(received_ctx), trace_id)
  assert_eq(SpanContext::span_id(received_ctx), span_id)
  assert_true(SpanContext::is_sampled(received_ctx))
}

// æµ‹è¯•5: è·¨æœåŠ¡é€šä¿¡æµ‹è¯•
test "cross service communication tests" {
  // æµ‹è¯•æœåŠ¡é—´ä¸Šä¸‹æ–‡ä¼ æ’­
  let service_a_ctx = SpanContext::new("service_a_trace", "service_a_span", true, "")
  let service_a_span = Span::new("service_a_operation", Server, service_a_ctx)
  
  // æ¨¡æ‹ŸæœåŠ¡Aå‘æœåŠ¡Bä¼ æ’­ä¸Šä¸‹æ–‡
  let propagated_headers = SpanContext::inject_headers(service_a_ctx)
  assert_true(propagated_headers.length() > 0)
  
  // æ¨¡æ‹ŸæœåŠ¡Bæ¥æ”¶ä¸Šä¸‹æ–‡
  let service_b_ctx = SpanContext::extract_headers(propagated_headers)
  let service_b_span = Span::new("service_b_operation", Client, service_b_ctx)
  
  // éªŒè¯ä¸Šä¸‹æ–‡ä¼ æ’­çš„æ­£ç¡®æ€§
  assert_eq(SpanContext::trace_id(service_b_ctx), SpanContext::trace_id(service_a_ctx))
  assert_true(SpanContext::is_sampled(service_b_ctx))
  
  // æµ‹è¯•åˆ†å¸ƒå¼è¿½è¸ªé“¾
  Span::add_event(service_a_span, "service_a_start", None)
  Span::add_event(service_b_span, "service_b_start", None)
  
  // æ¨¡æ‹ŸæœåŠ¡é—´è°ƒç”¨
  Span::set_attribute(service_a_span, "service_b.call", StringValue("success"))
  Span::set_attribute(service_b_span, "service_a.caller", StringValue("identified"))
  
  Span::end(service_b_span)
  Span::end(service_a_span)
  
  // æµ‹è¯• baggage è·¨æœåŠ¡ä¼ æ’­
  let baggage = Baggage::new()
  let updated_baggage = Baggage::set_entry(baggage, "user.id", "12345")
  let propagated_baggage = Baggage::propagate(updated_baggage)
  
  let received_baggage = Baggage::receive(propagated_baggage)
  let user_id = Baggage::get_entry(received_baggage, "user.id")
  
  match user_id {
    Some(value) => assert_eq(value, "12345")
    None => assert_true(false)
  }
}

// æµ‹è¯•6: èµ„æºç®¡ç†æµ‹è¯•
test "resource management tests" {
  // æµ‹è¯•å†…å­˜ä½¿ç”¨ä¼˜åŒ–
  let initial_memory = Memory::used()
  
  // åˆ›å»ºå¤§é‡èµ„æº
  let mut resources = []
  for i in 0..<100 {
    let resource = Resource::with_attributes(Resource::new(), [
      ("resource.id", StringValue("resource_" + i.to_string())),
      ("resource.type", StringValue("test_resource")),
      ("resource.size", IntValue(i * 1024))
    ])
    resources.push(resource)
  }
  
  let peak_memory = Memory::used()
  
  // æ¸…ç†èµ„æº
  resources = []
  
  // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
  Memory::gc()
  
  let final_memory = Memory::used()
  
  // éªŒè¯å†…å­˜ä½¿ç”¨åˆç†
  let memory_increase = peak_memory - initial_memory
  let memory_recovered = peak_memory - final_memory
  
  assert_true(memory_increase < 10 * 1024 * 1024) // ä¸åº”è¶…è¿‡10MB
  assert_true(memory_recovered > memory_increase * 0.5) // è‡³å°‘å›æ”¶50%
  
  // æµ‹è¯•èµ„æºæ± ç®¡ç†
  let resource_pool = ResourcePool::new(10) // æœ€å¤š10ä¸ªèµ„æº
  
  let mut pool_resources = []
  for i in 0..<15 {
    match ResourcePool::acquire(resource_pool) {
      Some(resource) => pool_resources.push(resource)
      None => assert_true(i >= 10) // è¶…è¿‡æ± å¤§å°åº”è¿”å›None
    }
  }
  
  assert_eq(pool_resources.length(), 10) // åªèƒ½è·å–10ä¸ªèµ„æº
  
  // é‡Šæ”¾èµ„æºå›æ± 
  for resource in pool_resources {
    ResourcePool::release(resource_pool, resource)
  }
  
  // éªŒè¯èµ„æºæ± æ¢å¤
  let recovered_resource = ResourcePool::acquire(resource_pool)
  match recovered_resource {
    Some(_) => assert_true(true)
    None => assert_true(false)
  }
}

// æµ‹è¯•7: é…ç½®ç®¡ç†æµ‹è¯•
test "configuration management tests" {
  // æµ‹è¯•åŠ¨æ€é…ç½®æ›´æ–°
  let config = Configuration::new()
  
  // è®¾ç½®åˆå§‹é…ç½®
  Configuration::set(config, "telemetry.sampling.rate", FloatValue(0.1))
  Configuration::set(config, "telemetry.max.spans", IntValue(1000))
  Configuration::set(config, "telemetry.export.interval", IntValue(5000))
  
  // éªŒè¯åˆå§‹é…ç½®
  let sampling_rate = Configuration::get(config, "telemetry.sampling.rate")
  match sampling_rate {
    Some(FloatValue(value)) => assert_true(value == 0.1)
    _ => assert_true(false)
  }
  
  let max_spans = Configuration::get(config, "telemetry.max.spans")
  match max_spans {
    Some(IntValue(value)) => assert_eq(value, 1000)
    _ => assert_true(false)
  }
  
  // åŠ¨æ€æ›´æ–°é…ç½®
  Configuration::set(config, "telemetry.sampling.rate", FloatValue(0.5))
  Configuration::set(config, "telemetry.max.spans", IntValue(2000))
  
  // éªŒè¯é…ç½®æ›´æ–°
  let updated_sampling_rate = Configuration::get(config, "telemetry.sampling.rate")
  match updated_sampling_rate {
    Some(FloatValue(value)) => assert_true(value == 0.5)
    _ => assert_true(false)
  }
  
  let updated_max_spans = Configuration::get(config, "telemetry.max.spans")
  match updated_max_spans {
    Some(IntValue(value)) => assert_eq(value, 2000)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é…ç½®æŒä¹…åŒ–å’ŒåŠ è½½
  let config_data = Configuration::serialize(config)
  let loaded_config = Configuration::deserialize(config_data)
  
  let loaded_sampling_rate = Configuration::get(loaded_config, "telemetry.sampling.rate")
  match loaded_sampling_rate {
    Some(FloatValue(value)) => assert_true(value == 0.5)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é…ç½®éªŒè¯
  let invalid_config = Configuration::new()
  Configuration::set(invalid_config, "telemetry.sampling.rate", FloatValue(1.5)) // æ— æ•ˆå€¼
  
  let validation_result = Configuration::validate(invalid_config)
  assert_false(validation_result.is_valid)
  assert_true(validation_result.errors.length() > 0)
}

// æµ‹è¯•8: å®‰å…¨æ€§æµ‹è¯•
test "security tests" {
  // æµ‹è¯•æ•æ„Ÿæ•°æ®å¤„ç†
  let sensitive_attrs = Attributes::new()
  Attributes::set(sensitive_attrs, "user.password", StringValue("secret_password"))
  Attributes::set(sensitive_attrs, "api.key", StringValue("secret_api_key"))
  Attributes::set(sensitive_attrs, "user.email", StringValue("user@example.com"))
  
  // åº”ç”¨æ•°æ®è„±æ•
  let sanitized_attrs = Security::sanitize_attributes(sensitive_attrs)
  
  // éªŒè¯æ•æ„Ÿæ•°æ®å·²è¢«è„±æ•
  let password = Attributes::get(sanitized_attrs, "user.password")
  match password {
    Some(StringValue(value)) => assert_false(value.contains("secret_password"))
    _ => assert_true(true) // å¯èƒ½è¢«å®Œå…¨ç§»é™¤
  }
  
  let api_key = Attributes::get(sanitized_attrs, "api.key")
  match api_key {
    Some(StringValue(value)) => assert_false(value.contains("secret_api_key"))
    _ => assert_true(true) // å¯èƒ½è¢«å®Œå…¨ç§»é™¤
  }
  
  // éæ•æ„Ÿæ•°æ®åº”ä¿æŒä¸å˜
  let email = Attributes::get(sanitized_attrs, "user.email")
  match email {
    Some(StringValue(value)) => assert_eq(value, "user@example.com")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŠ å¯†ä¼ è¾“
  let original_data = "sensitive telemetry data"
  let encrypted_data = Security::encrypt(original_data, "encryption_key")
  
  // éªŒè¯æ•°æ®å·²åŠ å¯†ï¼ˆä¸åŸå§‹æ•°æ®ä¸åŒï¼‰
  assert_false(encrypted_data == original_data)
  
  // æµ‹è¯•è§£å¯†
  let decrypted_data = Security::decrypt(encrypted_data, "encryption_key")
  assert_eq(decrypted_data, original_data)
  
  // æµ‹è¯•é”™è¯¯å¯†é’¥è§£å¯†å¤±è´¥
  let failed_decryption = Security::decrypt(encrypted_data, "wrong_key")
  assert_false(failed_decryption == original_data)
  
  // æµ‹è¯•è®¿é—®æ§åˆ¶
  let access_control = AccessControl::new()
  AccessControl::add_role(access_control, "admin", ["read", "write", "delete"])
  AccessControl::add_role(access_control, "user", ["read"])
  
  assert_true(AccessControl::has_permission(access_control, "admin", "delete"))
  assert_false(AccessControl::has_permission(access_control, "user", "delete"))
  assert_true(AccessControl::has_permission(access_control, "user", "read"))
}

// æµ‹è¯•9: å›½é™…åŒ–æµ‹è¯•
test "internationalization tests" {
  // æµ‹è¯•å¤šè¯­è¨€æ”¯æŒ
  let i18n = Internationalization::new()
  
  // æ·»åŠ å¤šè¯­è¨€èµ„æº
  Internationalization::add_translation(i18n, "en", "span.name", "Request Processing")
  Internationalization::add_translation(i18n, "zh", "span.name", "è¯·æ±‚å¤„ç†")
  Internationalization::add_translation(i18n, "es", "span.name", "Procesamiento de Solicitud")
  Internationalization::add_translation(i18n, "fr", "span.name", "Traitement de la Demande")
  
  // æµ‹è¯•è‹±è¯­
  let en_translation = Internationalization::get_translation(i18n, "en", "span.name")
  match en_translation {
    Some(text) => assert_eq(text, "Request Processing")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ä¸­æ–‡
  let zh_translation = Internationalization::get_translation(i18n, "zh", "span.name")
  match zh_translation {
    Some(text) => assert_eq(text, "è¯·æ±‚å¤„ç†")
    None => assert_true(false)
  }
  
  // æµ‹è¯•è¥¿ç­ç‰™è¯­
  let es_translation = Internationalization::get_translation(i18n, "es", "span.name")
  match es_translation {
    Some(text) => assert_eq(text, "Procesamiento de Solicitud")
    None => assert_true(false)
  }
  
  // æµ‹è¯•æ³•è¯­
  let fr_translation = Internationalization::get_translation(i18n, "fr", "span.name")
  match fr_translation {
    Some(text) => assert_eq(text, "Traitement de la Demande")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„ç¿»è¯‘
  let missing_translation = Internationalization::get_translation(i18n, "de", "span.name")
  match missing_translation {
    Some(_) => assert_true(false)
    None => assert_true(true)
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦å¤„ç†
  let unicode_attrs = Attributes::new()
  Attributes::set(unicode_attrs, "emoji.test", StringValue("ğŸš€ğŸŒŸğŸ’«"))
  Attributes::set(unicode_attrs, "chinese.test", StringValue("ä¸­æ–‡æµ‹è¯•"))
  Attributes::set(unicode_attrs, "arabic.test", StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ"))
  Attributes::set(unicode_attrs, "russian.test", StringValue("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµÑÑ‚"))
  
  // éªŒè¯Unicodeå­—ç¬¦æ­£ç¡®å¤„ç†
  let emoji_result = Attributes::get(unicode_attrs, "emoji.test")
  match emoji_result {
    Some(StringValue(value)) => assert_eq(value, "ğŸš€ğŸŒŸğŸ’«")
    _ => assert_true(false)
  }
  
  let chinese_result = Attributes::get(unicode_attrs, "chinese.test")
  match chinese_result {
    Some(StringValue(value)) => assert_eq(value, "ä¸­æ–‡æµ‹è¯•")
    _ => assert_true(false)
  }
  
  let arabic_result = Attributes::get(unicode_attrs, "arabic.test")
  match arabic_result {
    Some(StringValue(value)) => assert_eq(value, "Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ")
    _ => assert_true(false)
  }
  
  let russian_result = Attributes::get(unicode_attrs, "russian.test")
  match russian_result {
    Some(StringValue(value)) => assert_eq(value, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµÑÑ‚")
    _ => assert_true(false)
  }
}

// æµ‹è¯•10: è¾¹ç•Œæ¡ä»¶å’Œæé™æµ‹è¯•
test "boundary condition and limit tests" {
  // æµ‹è¯•æœ€å¤§é•¿åº¦å­—ç¬¦ä¸²
  let max_string = "a" * 1000000 // 1MBå­—ç¬¦ä¸²
  let attrs = Attributes::new()
  Attributes::set(attrs, "max_string", StringValue(max_string))
  
  let max_string_result = Attributes::get(attrs, "max_string")
  match max_string_result {
    Some(StringValue(value)) => assert_eq(value.length(), 1000000)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æœ€å¤§æ•°å€¼è¾¹ç•Œ
  let max_int = 2147483647 // 32ä½æœ‰ç¬¦å·æ•´æ•°æœ€å¤§å€¼
  let min_int = -2147483648 // 32ä½æœ‰ç¬¦å·æ•´æ•°æœ€å°å€¼
  
  Attributes::set(attrs, "max_int", IntValue(max_int))
  Attributes::set(attrs, "min_int", IntValue(min_int))
  
  let max_int_result = Attributes::get(attrs, "max_int")
  match max_int_result {
    Some(IntValue(value)) => assert_eq(value, max_int)
    _ => assert_true(false)
  }
  
  let min_int_result = Attributes::get(attrs, "min_int")
  match min_int_result {
    Some(IntValue(value)) => assert_eq(value, min_int)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œ
  let max_float = 3.4028235e38 // 32ä½æµ®ç‚¹æ•°æœ€å¤§å€¼
  let min_float = 1.17549435e-38 // 32ä½æµ®ç‚¹æ•°æœ€å°æ­£å€¼
  
  Attributes::set(attrs, "max_float", FloatValue(max_float))
  Attributes::set(attrs, "min_float", FloatValue(min_float))
  
  let max_float_result = Attributes::get(attrs, "max_float")
  match max_float_result {
    Some(FloatValue(value)) => assert_true(value > 3.4e38 * 0.999) // å…è®¸ç²¾åº¦æŸå¤±
    _ => assert_true(false)
  }
  
  let min_float_result = Attributes::get(attrs, "min_float")
  match min_float_result {
    Some(FloatValue(value)) => assert_true(value > 1.17e-38 * 0.999 && value < 1.18e-38 * 1.001)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ•°ç»„è¾¹ç•Œ
  let large_array = Array::init(10000, fn(i) { i * 2 })
  Attributes::set(attrs, "large_array", ArrayIntValue(large_array))
  
  let large_array_result = Attributes::get(attrs, "large_array")
  match large_array_result {
    Some(ArrayIntValue(value)) => {
      assert_eq(value.length(), 10000)
      assert_eq(value[0], 0)
      assert_eq(value[9999], 19998)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é›¶é•¿åº¦å’Œç©ºå€¼
  Attributes::set(attrs, "empty_string", StringValue(""))
  Attributes::set(attrs, "empty_array", ArrayIntValue([]))
  
  let empty_string_result = Attributes::get(attrs, "empty_string")
  match empty_string_result {
    Some(StringValue(value)) => assert_eq(value.length(), 0)
    _ => assert_true(false)
  }
  
  let empty_array_result = Attributes::get(attrs, "empty_array")
  match empty_array_result {
    Some(ArrayIntValue(value)) => assert_eq(value.length(), 0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’Œè½¬ä¹‰åºåˆ—
  let special_chars = "Special chars: \n\t\r\\\"'"
  Attributes::set(attrs, "special_chars", StringValue(special_chars))
  
  let special_chars_result = Attributes::get(attrs, "special_chars")
  match special_chars_result {
    Some(StringValue(value)) => assert_eq(value, special_chars)
    _ => assert_true(false)
  }
}