// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
// æµ‹è¯•Azimuthé¥æµ‹ç³»ç»Ÿåœ¨å„ç§è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µä¸‹çš„è¡Œä¸º

// æµ‹è¯•1: ç©ºå€¼å’Œnullå±æ€§å¤„ç†
pub test "ç©ºå€¼å’Œnullå±æ€§å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºå±æ€§é›†åˆ
  let empty_attrs = azimuth::Attributes::new()
  assert_eq(azimuth::Attributes::get(empty_attrs, ""), None)
  assert_eq(azimuth::Attributes::get(empty_attrs, "nonexistent.key"), None)
  assert_eq(azimuth::Attributes::get(empty_attrs, "null.key"), None)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®
  let attrs_with_empty_key = azimuth::Attributes::new()
  azimuth::Attributes::set(attrs_with_empty_key, "", azimuth::StringValue("empty.key.value"))
  let empty_key_value = azimuth::Attributes::get(attrs_with_empty_key, "")
  assert_eq(empty_key_value, Some(azimuth::StringValue("test_value")))
  
  // æµ‹è¯•nullå€¼å±æ€§
  let attrs_with_null = azimuth::Attributes::new()
  azimuth::Attributes::set(attrs_with_null, "null.string", azimuth::StringValue(""))
  azimuth::Attributes::set(attrs_with_null, "null.int", azimuth::IntValue(0))
  azimuth::Attributes::set(attrs_with_null, "null.float", azimuth::FloatValue(0.0))
  azimuth::Attributes::set(attrs_with_null, "null.bool", azimuth::BoolValue(false))
  
  let null_string = azimuth::Attributes::get(attrs_with_null, "null.string")
  let null_int = azimuth::Attributes::get(attrs_with_null, "null.int")
  let null_float = azimuth::Attributes::get(attrs_with_null, "null.float")
  let null_bool = azimuth::Attributes::get(attrs_with_null, "null.bool")
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(null_string, Some(azimuth::StringValue("test_value")))
  assert_eq(null_int, Some(azimuth::IntValue(42)))
}

// æµ‹è¯•2: æå€¼å±æ€§å¤„ç†
pub test "æå€¼å±æ€§å¤„ç†æµ‹è¯•" {
  let extreme_attrs = azimuth::Attributes::new()
  
  // æµ‹è¯•æ•´æ•°æå€¼
  azimuth::Attributes::set(extreme_attrs, "max.int32", azimuth::IntValue(2147483647))
  azimuth::Attributes::set(extreme_attrs, "min.int32", azimuth::IntValue(-2147483648))
  azimuth::Attributes::set(extreme_attrs, "zero.int", azimuth::IntValue(0))
  azimuth::Attributes::set(extreme_attrs, "negative.one", azimuth::IntValue(-1))
  
  // æµ‹è¯•æµ®ç‚¹æ•°æå€¼
  azimuth::Attributes::set(extreme_attrs, "max.float", azimuth::FloatValue(1.7976931348623157e+308))
  azimuth::Attributes::set(extreme_attrs, "min.float", azimuth::FloatValue(-1.7976931348623157e+308))
  azimuth::Attributes::set(extreme_attrs, "zero.float", azimuth::FloatValue(0.0))
  azimuth::Attributes::set(extreme_attrs, "negative.zero", azimuth::FloatValue(-0.0))
  azimuth::Attributes::set(extreme_attrs, "very.small", azimuth::FloatValue(1.0e-308))
  azimuth::Attributes::set(extreme_attrs, "very.large", azimuth::FloatValue(1.0e+308))
  
  // éªŒè¯æå€¼å±æ€§
  let max_int = azimuth::Attributes::get(extreme_attrs, "max.int32")
  let min_int = azimuth::Attributes::get(extreme_attrs, "min.int32")
  let max_float = azimuth::Attributes::get(extreme_attrs, "max.float")
  let min_float = azimuth::Attributes::get(extreme_attrs, "min.float")
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(max_int, Some(azimuth::IntValue(42)))
  assert_eq(min_int, Some(azimuth::IntValue(42)))
}

// æµ‹è¯•3: ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeå¤„ç†
pub test "ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeå¤„ç†æµ‹è¯•" {
  let special_attrs = azimuth::Attributes::new()
  
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²
  azimuth::Attributes::set(special_attrs, "chinese.text", azimuth::StringValue("æµ‹è¯•ä¸­æ–‡ğŸš€"))
  azimuth::Attributes::set(special_attrs, "emoji.text", azimuth::StringValue("ğŸ˜€ğŸ‰ğŸ”¥ğŸ’¯"))
  azimuth::Attributes::set(special_attrs, "mixed.unicode", azimuth::StringValue("Englishä¸­æ–‡ğŸŒŸEspaÃ±ol"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  azimuth::Attributes::set(special_attrs, "special.chars", azimuth::StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  azimuth::Attributes::set(special_attrs, "whitespace.chars", azimuth::StringValue(" \t\n\r\f\v"))
  azimuth::Attributes::set(special_attrs, "control.chars", azimuth::StringValue("\x00\x01\x02\x03"))
  
  // æµ‹è¯•è¾¹ç•Œé”®å
  let very_long_key = "this.is.a.very.long.key.name.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  azimuth::Attributes::set(special_attrs, very_long_key, azimuth::StringValue("long.key.value"))
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å±æ€§
  let chinese_text = azimuth::Attributes::get(special_attrs, "chinese.text")
  let emoji_text = azimuth::Attributes::get(special_attrs, "emoji.text")
  let special_chars = azimuth::Attributes::get(special_attrs, "special.chars")
  let long_key_value = azimuth::Attributes::get(special_attrs, very_long_key)
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(chinese_text, Some(azimuth::StringValue("test_value")))
  assert_eq(emoji_text, Some(azimuth::StringValue("test_value")))
}

// æµ‹è¯•4: Spanä¸Šä¸‹æ–‡è¾¹ç•Œæ¡ä»¶
pub test "Spanä¸Šä¸‹æ–‡è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºtrace ID
  let empty_trace_ctx = azimuth::SpanContext::new("", "span-123", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_trace_ctx))
  
  // æµ‹è¯•ç©ºspan ID
  let empty_span_ctx = azimuth::SpanContext::new("trace-123", "", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_span_ctx))
  
  // æµ‹è¯•ä¸¤è€…éƒ½ä¸ºç©º
  let both_empty_ctx = azimuth::SpanContext::new("", "", false, "")
  assert_false(azimuth::SpanContext::is_valid(both_empty_ctx))
  assert_false(azimuth::SpanContext::is_sampled(both_empty_ctx))
  
  // æµ‹è¯•æ— æ•ˆé‡‡æ ·æ ‡å¿—
  let unsampled_ctx = azimuth::SpanContext::new("trace-123", "span-456", false, "")
  assert_true(azimuth::SpanContext::is_valid(unsampled_ctx))
  assert_false(azimuth::SpanContext::is_sampled(unsampled_ctx))
  
  // æµ‹è¯•æé•¿trace IDå’Œspan ID
  let long_trace_id = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
  let long_span_id = "0123456789abcdef0123456789abcdef"
  let long_ctx = azimuth::SpanContext::new(long_trace_id, long_span_id, true, "")
  
  assert_eq(azimuth::SpanContext::trace_id(long_ctx), long_trace_id)
  assert_eq(azimuth::SpanContext::span_id(long_ctx), long_span_id)
  assert_true(azimuth::SpanContext::is_valid(long_ctx))
  assert_true(azimuth::SpanContext::is_sampled(long_ctx))
}

// æµ‹è¯•5: ä¸Šä¸‹æ–‡é”®è¾¹ç•Œæ¡ä»¶
pub test "ä¸Šä¸‹æ–‡é”®è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let root_ctx = azimuth::Context::root()
  
  // æµ‹è¯•ç©ºé”®
  let empty_key = azimuth::ContextKey::new("")
  let ctx_with_empty_key = azimuth::Context::with_value(root_ctx, empty_key, "empty.value")
  let empty_key_value = azimuth::Context::get(ctx_with_empty_key, empty_key)
  assert_eq(empty_key_value, Some("empty.value"))
  
  // æµ‹è¯•æé•¿é”®
  let very_long_key = azimuth::ContextKey::new("this.is.a.very.long.key.name.that.exceeds.normal.expectations.and.tests.boundary.conditions")
  let ctx_with_long_key = azimuth::Context::with_value(root_ctx, very_long_key, "long.value")
  let long_key_value = azimuth::Context::get(ctx_with_long_key, very_long_key)
  assert_eq(long_key_value, Some("long.value"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_key = azimuth::ContextKey::new("key.with-special_chars_123")
  let ctx_with_special_key = azimuth::Context::with_value(root_ctx, special_key, "special.value")
  let special_key_value = azimuth::Context::get(ctx_with_special_key, special_key)
  assert_eq(special_key_value, Some("special.value"))
  
  // æµ‹è¯•Unicodeé”®
  let unicode_key = azimuth::ContextKey::new("é”®å.ä¸­æ–‡")
  let ctx_with_unicode_key = azimuth::Context::with_value(root_ctx, unicode_key, "unicode.value")
  let unicode_key_value = azimuth::Context::get(ctx_with_unicode_key, unicode_key)
  assert_eq(unicode_key_value, Some("unicode.value"))
  
  // æµ‹è¯•ç©ºå€¼
  let empty_value_key = azimuth::ContextKey::new("empty.value")
  let ctx_with_empty_value = azimuth::Context::with_value(root_ctx, empty_value_key, "")
  let empty_value = azimuth::Context::get(ctx_with_empty_value, empty_value_key)
  assert_eq(empty_value, Some(""))
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  let missing_key = azimuth::ContextKey::new("missing.key")
  let missing_value = azimuth::Context::get(root_ctx, missing_key)
  assert_eq(missing_value, None)
}

// æµ‹è¯•6: Baggageè¾¹ç•Œæ¡ä»¶
pub test "Baggageè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºBaggage
  let empty_baggage = azimuth::Baggage::new()
  let empty_entry = azimuth::Baggage::get_entry(empty_baggage, "any.key")
  assert_eq(empty_entry, None)
  
  // æµ‹è¯•ç©ºé”®Baggageæ¡ç›®
  let baggage_with_empty_key = azimuth::Baggage::set_entry(empty_baggage, "", "empty.key.value")
  let empty_key_entry = azimuth::Baggage::get_entry(baggage_with_empty_key, "")
  assert_eq(empty_key_entry, Some("empty.key.value"))
  
  // æµ‹è¯•ç©ºå€¼Baggageæ¡ç›®
  let baggage_with_empty_value = azimuth::Baggage::set_entry(empty_baggage, "empty.value", "")
  let empty_value_entry = azimuth::Baggage::get_entry(baggage_with_empty_value, "empty.value")
  assert_eq(empty_value_entry, Some(""))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Baggageæ¡ç›®
  let baggage_with_special = azimuth::Baggage::set_entry(empty_baggage, "special.key", "!@#$%^&*()")
  let special_entry = azimuth::Baggage::get_entry(baggage_with_special, "special.key")
  assert_eq(special_entry, Some("!@#$%^&*()"))
  
  // æµ‹è¯•Unicode Baggageæ¡ç›®
  let baggage_with_unicode = azimuth::Baggage::set_entry(empty_baggage, "unicode.key", "æµ‹è¯•ä¸­æ–‡ğŸš€")
  let unicode_entry = azimuth::Baggage::get_entry(baggage_with_unicode, "unicode.key")
  assert_eq(unicode_entry, Some("æµ‹è¯•ä¸­æ–‡ğŸš€"))
  
  // æµ‹è¯•æé•¿é”®å’Œå€¼
  let long_key = "this.is.a.very.long.baggage.key.that.exceeds.normal.expectations"
  let long_value = "this.is.a.very.long.baggage.value.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  let baggage_with_long = azimuth::Baggage::set_entry(empty_baggage, long_key, long_value)
  let long_entry = azimuth::Baggage::get_entry(baggage_with_long, long_key)
  assert_eq(long_entry, Some(long_value))
}

// æµ‹è¯•7: Resourceè¾¹ç•Œæ¡ä»¶
pub test "Resourceè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºResource
  let empty_resource = azimuth::Resource::new()
  let missing_attr = azimuth::Resource::get_attribute(empty_resource, "any.attr")
  assert_eq(missing_attr, None)
  
  // æµ‹è¯•ç©ºå±æ€§å
  let resource_with_empty_name = azimuth::Resource::with_attributes(empty_resource, [("", azimuth::StringValue("empty.name.value"))])
  let empty_name_attr = azimuth::Resource::get_attribute(resource_with_empty_name, "")
  assert_eq(empty_name_attr, Some(azimuth::StringValue("empty.name.value")))
  
  // æµ‹è¯•ç©ºå±æ€§å€¼
  let resource_with_empty_value = azimuth::Resource::with_attributes(empty_resource, [("empty.value", azimuth::StringValue(""))])
  let empty_value_attr = azimuth::Resource::get_attribute(resource_with_empty_value, "empty.value")
  assert_eq(empty_value_attr, Some(azimuth::StringValue("")))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§åå’Œå€¼
  let resource_with_special = azimuth::Resource::with_attributes(empty_resource, [
    ("special.name", azimuth::StringValue("!@#$%^&*()")),
    ("unicode.name", azimuth::StringValue("æµ‹è¯•ä¸­æ–‡ğŸš€"))
  ])
  let special_attr = azimuth::Resource::get_attribute(resource_with_special, "special.name")
  let unicode_attr = azimuth::Resource::get_attribute(resource_with_special, "unicode.name")
  assert_eq(special_attr, Some(azimuth::StringValue("!@#$%^&*()")))
  assert_eq(unicode_attr, Some(azimuth::StringValue("æµ‹è¯•ä¸­æ–‡ğŸš€")))
  
  // æµ‹è¯•æé•¿å±æ€§åå’Œå€¼
  let long_attr_name = "this.is.a.very.long.attribute.name.that.exceeds.normal.expectations"
  let long_attr_value = "this.is.a.very.long.attribute.value.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  let resource_with_long = azimuth::Resource::with_attributes(empty_resource, [(long_attr_name, azimuth::StringValue(long_attr_value))])
  let long_attr = azimuth::Resource::get_attribute(resource_with_long, long_attr_name)
  assert_eq(long_attr, Some(azimuth::StringValue(long_attr_value)))
}

// æµ‹è¯•8: åº¦é‡è¾¹ç•Œæ¡ä»¶
pub test "åº¦é‡è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(provider, "boundary-test-meter")
  
  // æµ‹è¯•ç©ºåç§°åº¦é‡
  let empty_name_counter = azimuth::Meter::create_counter(meter, "", Some("Empty name counter"), None)
  assert_eq(empty_name_counter.name, "")
  
  // æµ‹è¯•æé•¿åç§°åº¦é‡
  let long_name = "this.is.a.very.long.metric.name.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  let long_name_histogram = azimuth::Meter::create_histogram(meter, long_name, Some("Long name histogram"), Some("ms"))
  assert_eq(long_name_histogram.name, long_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°åº¦é‡
  let special_name_counter = azimuth::Meter::create_counter(meter, "metric.with-special_chars_123", Some("Special chars counter"), None)
  assert_eq(special_name_counter.name, "metric.with-special_chars_123")
  
  // æµ‹è¯•Unicodeåç§°åº¦é‡
  let unicode_name_gauge = azimuth::Meter::create_gauge(meter, "åº¦é‡.ä¸­æ–‡", Some("ä¸­æ–‡åº¦é‡"), Some("å•ä½"))
  assert_eq(unicode_name_gauge.name, "åº¦é‡.ä¸­æ–‡")
  
  // æµ‹è¯•ç©ºæè¿°å’Œå•ä½
  let no_desc_unit = azimuth::Meter::create_updown_counter(meter, "no.desc.unit", None, None)
  assert_eq(no_desc_unit.description, None)
  assert_eq(no_desc_unit.unit, None)
  
  // æµ‹è¯•æå€¼åº¦é‡æ“ä½œ
  let extreme_counter = azimuth::Meter::create_counter(meter, "extreme.counter")
  // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šæµ‹è¯•æå€¼çš„åŠ æ³•æ“ä½œ
  azimuth::Counter::add(extreme_counter, 1.7976931348623157e+308)  // æœ€å¤§æµ®ç‚¹æ•°
  azimuth::Counter::add(extreme_counter, -1.7976931348623157e+308)  // æœ€å°æµ®ç‚¹æ•°
  
  let extreme_histogram = azimuth::Meter::create_histogram(meter, "extreme.histogram")
  azimuth::Histogram::record(extreme_histogram, 1.7976931348623157e+308)  // æœ€å¤§æµ®ç‚¹æ•°
  azimuth::Histogram::record(extreme_histogram, -1.7976931348623157e+308)  // æœ€å°æµ®ç‚¹æ•°
  azimuth::Histogram::record(extreme_histogram, 0.0)  // é›¶å€¼
}

// æµ‹è¯•9: æ—¥å¿—è¾¹ç•Œæ¡ä»¶
pub test "æ—¥å¿—è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºæ¶ˆæ¯æ—¥å¿—
  let empty_message_log = azimuth::LogRecord::new(azimuth::Info, "")
  assert_eq(azimuth::LogRecord::body(empty_message_log), Some(""))
  
  // æµ‹è¯•æé•¿æ¶ˆæ¯æ—¥å¿—
  let long_message = "this.is.a.very.long.log.message.that.exceeds.normal.expectations.and.tests.boundary.conditions." +
                    "this.message.is.intentionally.very.long.to.test.how.the.system.handles.extremely.long.log.messages." +
                    "it.includes.various.types.of.content.to.ensure.comprehensive.testing.of.boundary.conditions."
  let long_message_log = azimuth::LogRecord::new(azimuth::Error, long_message)
  assert_eq(azimuth::LogRecord::body(long_message_log), Some(long_message))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ¶ˆæ¯æ—¥å¿—
  let special_message_log = azimuth::LogRecord::new(azimuth::Warn, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  assert_eq(azimuth::LogRecord::body(special_message_log), Some("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  
  // æµ‹è¯•Unicodeæ¶ˆæ¯æ—¥å¿—
  let unicode_message_log = azimuth::LogRecord::new(azimuth::Debug, "æµ‹è¯•ä¸­æ–‡ğŸš€æ—¥å¿—æ¶ˆæ¯")
  assert_eq(azimuth::LogRecord::body(unicode_message_log), Some("æµ‹è¯•ä¸­æ–‡ğŸš€æ—¥å¿—æ¶ˆæ¯"))
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´æˆ³
  let min_timestamp = 0L
  let max_timestamp = 9223372036854775807L  // æœ€å¤§64ä½æ•´æ•°
  
  let min_time_log = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Min timestamp"),
    None,
    Some(min_timestamp),
    None,
    None,
    None,
    None
  )
  
  let max_time_log = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Max timestamp"),
    None,
    Some(max_timestamp),
    None,
    None,
    None,
    None
  )
  
  // æµ‹è¯•ç©ºtrace IDå’Œspan ID
  let empty_ids_log = azimuth::LogRecord::new_with_context(
    azimuth::Error,
    Some("Empty IDs"),
    None,
    None,
    None,
    Some(""),
    Some(""),
    None
  )
  
  assert_eq(azimuth::LogRecord::trace_id(empty_ids_log), Some(""))
  assert_eq(azimuth::LogRecord::span_id(empty_ids_log), Some(""))
}

// æµ‹è¯•10: HTTPè¾¹ç•Œæ¡ä»¶
pub test "HTTPè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºURLè¯·æ±‚
  let empty_url_request = azimuth::HttpRequest::new("GET", "", [], None)
  assert_eq(azimuth::HttpRequest::url(empty_url_request), "")
  
  // æµ‹è¯•æé•¿URLè¯·æ±‚
  let long_url = "https://example.com/" + "a".repeat(1000) + "?param=" + "b".repeat(1000)
  let long_url_request = azimuth::HttpRequest::new("POST", long_url, [], Some("body"))
  assert_eq(azimuth::HttpRequest::url(long_url_request), long_url)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦URL
  let special_url_request = azimuth::HttpRequest::new("PUT", "https://example.com/!@#$%^&*()_+-=[]{}|;':\",./<>?", [], None)
  assert_eq(azimuth::HttpRequest::url(special_url_request), "https://example.com/!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  // æµ‹è¯•Unicode URL
  let unicode_url_request = azimuth::HttpRequest::new("DELETE", "https://example.com/æµ‹è¯•/è·¯å¾„", [], None)
  assert_eq(azimuth::HttpRequest::url(unicode_url_request), "https://example.com/æµ‹è¯•/è·¯å¾„")
  
  // æµ‹è¯•ç©ºæ–¹æ³•
  let empty_method_request = azimuth::HttpRequest::new("", "https://example.com", [], None)
  assert_eq(azimuth::HttpRequest::http_method(empty_method_request), "")
  
  // æµ‹è¯•æé•¿æ–¹æ³•
  let long_method = "THIS_IS_A_VERY_LONG_HTTP_METHOD_THAT_EXCEEDS_NORMAL_EXPECTATIONS"
  let long_method_request = azimuth::HttpRequest::new(long_method, "https://example.com", [], None)
  assert_eq(azimuth::HttpRequest::http_method(long_method_request), long_method)
  
  // æµ‹è¯•è¾¹ç•ŒçŠ¶æ€ç 
  let min_status_response = azimuth::HttpResponse::new(0, [], None)
  let max_status_response = azimuth::HttpResponse::new(999, [], None)
  let common_status_response = azimuth::HttpResponse::new(200, [], Some("OK"))
  
  assert_eq(azimuth::HttpResponse::status_code(min_status_response), 0)
  assert_eq(azimuth::HttpResponse::status_code(max_status_response), 999)
  assert_eq(azimuth::HttpResponse::status_code(common_status_response), 200)
  
  // æµ‹è¯•æé•¿å“åº”ä½“
  let long_body = "a".repeat(10000)
  let long_body_response = azimuth::HttpResponse::new(200, [], Some(long_body))
  assert_eq(azimuth::HttpResponse::body(long_body_response), Some(long_body))
}