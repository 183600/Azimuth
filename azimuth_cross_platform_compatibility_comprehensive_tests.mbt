// Azimuth è·¨å¹³å°å…¼å®¹æ€§ç»¼åˆæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•è·¨å¹³å°å…¼å®¹æ€§åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ“ä½œç³»ç»Ÿã€æ¶æ„å’Œè¿è¡Œæ—¶ç¯å¢ƒé€‚é…

// æµ‹è¯•1: æ“ä½œç³»ç»Ÿå…¼å®¹æ€§
test "æ“ä½œç³»ç»Ÿå…¼å®¹æ€§åŠŸèƒ½" {
  // åˆ›å»ºå¹³å°æ£€æµ‹å™¨
  let platform_detector = PlatformDetector::new()
  
  // æ£€æµ‹å½“å‰æ“ä½œç³»ç»Ÿ
  let current_os = PlatformDetector::detect_os(platform_detector)
  assert_true(current_os == OSType::Linux || 
              current_os == OSType::Windows || 
              current_os == OSType::MacOS || 
              current_os == OSType::Other)
  
  // åˆ›å»ºæ“ä½œç³»ç»Ÿé€‚é…å™¨
  let os_adapter = OSAdapter::new(current_os)
  
  // æµ‹è¯•è·¯å¾„åˆ†éš”ç¬¦é€‚é…
  let path_separator = OSAdapter::get_path_separator(os_adapter)
  let expected_separator = match current_os {
    OSType::Windows => "\\",
    _ => "/"
  }
  assert_eq(path_separator, expected_separator)
  
  // æµ‹è¯•è·¯å¾„ç»„åˆ
  let path_parts = ["home", "user", "documents", "telemetry.data"]
  let combined_path = OSAdapter::combine_paths(os_adapter, path_parts)
  
  if current_os == OSType::Windows {
    assert_true(combined_path.contains("\\"))
    assert_false(combined_path.contains("/"))
  } else {
    assert_true(combined_path.contains("/"))
    assert_false(combined_path.contains("\\"))
  }
  
  // æµ‹è¯•æ–‡ä»¶æƒé™å¤„ç†
  let test_file = OSAdapter::combine_paths(os_adapter, ["tmp", "azimuth_test.txt"])
  let write_result = OSAdapter::create_file_with_permissions(os_adapter, test_file, "test content", 0o644)
  assert_true(write_result)
  
  let read_result = OSAdapter::read_file(os_adapter, test_file)
  assert_eq(read_result, "test content")
  
  // æµ‹è¯•ç¯å¢ƒå˜é‡å¤„ç†
  let env_var_name = if current_os == OSType::Windows { "AZIMUTH_TEST" } else { "AZIMUTH_TEST" }
  OSAdapter::set_environment_variable(os_adapter, env_var_name, "test_value")
  
  let env_value = OSAdapter::get_environment_variable(os_adapter, env_var_name)
  assert_eq(env_value, "test_value")
  
  // æµ‹è¯•è¿›ç¨‹ç®¡ç†
  let process_info = OSAdapter::get_process_info(os_adapter)
  assert_true(process_info.pid > 0)
  assert_true(process_info.memory_usage > 0)
  
  // æµ‹è¯•ç³»ç»Ÿèµ„æºç›‘æ§
  let system_info = OSAdapter::get_system_info(os_adapter)
  assert_true(system_info.cpu_count > 0)
  assert_true(system_info.total_memory > 0)
  assert_true(system_info.available_memory > 0)
  assert_true(system_info.available_memory <= system_info.total_memory)
  
  // æ¸…ç†æµ‹è¯•æ–‡ä»¶
  OSAdapter::delete_file(os_adapter, test_file)
}

// æµ‹è¯•2: æ¶æ„å…¼å®¹æ€§
test "æ¶æ„å…¼å®¹æ€§åŠŸèƒ½" {
  // åˆ›å»ºæ¶æ„æ£€æµ‹å™¨
  let arch_detector = ArchitectureDetector::new()
  
  // æ£€æµ‹å½“å‰æ¶æ„
  let current_arch = ArchitectureDetector::detect_architecture(arch_detector)
  assert_true(current_arch == ArchType::X86_64 || 
              current_arch == ArchType::ARM64 || 
              current_arch == ArchType::X86 || 
              current_arch == ArchType::ARM || 
              current_arch == ArchType::Other)
  
  // åˆ›å»ºæ¶æ„é€‚é…å™¨
  let arch_adapter = ArchAdapter::new(current_arch)
  
  // æµ‹è¯•å­—èŠ‚åºå¤„ç†
  let endianness = ArchAdapter::get_endianness(arch_adapter)
  assert_true(endianness == Endianness::Little || endianness == Endianness::Big)
  
  // æµ‹è¯•æ•´æ•°å¤§å°
  let int_size = ArchAdapter::get_int_size(arch_adapter)
  let pointer_size = ArchAdapter::get_pointer_size(arch_adapter)
  
  if current_arch == ArchType::X86_64 || current_arch == ArchType::ARM64 {
    assert_eq(pointer_size, 8) // 64ä½æ¶æ„æŒ‡é’ˆå¤§å°ä¸º8å­—èŠ‚
  } else {
    assert_eq(pointer_size, 4) // 32ä½æ¶æ„æŒ‡é’ˆå¤§å°ä¸º4å­—èŠ‚
  }
  
  // æµ‹è¯•æ•°æ®å¯¹é½
  let alignment_requirements = ArchAdapter::get_alignment_requirements(arch_adapter)
  assert_true(alignment_requirements.int_alignment > 0)
  assert_true(alignment_requirements.double_alignment > 0)
  assert_true(alignment_requirements.pointer_alignment > 0)
  
  // æµ‹è¯•åŸå­æ“ä½œæ”¯æŒ
  let atomic_support = ArchAdapter::get_atomic_support(arch_adapter)
  assert_true(atomic_support.has_32bit_atomic)
  if current_arch == ArchType::X86_64 || current_arch == ArchType::ARM64 {
    assert_true(atomic_support.has_64bit_atomic)
  }
  
  // æµ‹è¯•CPUç‰¹æ€§
  let cpu_features = ArchAdapter::get_cpu_features(arch_adapter)
  assert_true(cpu_features.has_basic_instructions)
  
  // æ ¹æ®æ¶æ„æµ‹è¯•ç‰¹å®šç‰¹æ€§
  match current_arch {
    ArchType::X86_64 => {
      assert_true(cpu_features.has_sse || cpu_features.has_avx) // x86_64åº”è¯¥æœ‰SIMDæ”¯æŒ
    }
    ArchType::ARM64 => {
      assert_true(cpu_features.has_neon) // ARM64åº”è¯¥æœ‰NEON
    }
    _ => {} // å…¶ä»–æ¶æ„ä¸æ£€æŸ¥ç‰¹å®šç‰¹æ€§
  }
  
  // æµ‹è¯•æ€§èƒ½è®¡æ•°å™¨
  let perf_counters = ArchAdapter::get_performance_counters(arch_adapter)
  if perf_counters.has_cycle_counter {
    let cycle_count = ArchAdapter::read_cycle_counter(arch_adapter)
    assert_true(cycle_count > 0)
  }
}

// æµ‹è¯•3: è¿è¡Œæ—¶ç¯å¢ƒå…¼å®¹æ€§
test "è¿è¡Œæ—¶ç¯å¢ƒå…¼å®¹æ€§åŠŸèƒ½" {
  // åˆ›å»ºè¿è¡Œæ—¶æ£€æµ‹å™¨
  let runtime_detector = RuntimeDetector::new()
  
  // æ£€æµ‹å½“å‰è¿è¡Œæ—¶
  let current_runtime = RuntimeDetector::detect_runtime(runtime_detector)
  assert_true(current_runtime == RuntimeType::Native || 
              current_runtime == RuntimeType::WebAssembly || 
              current_runtime == RuntimeType::JVM || 
              current_runtime == RuntimeType::Other)
  
  // åˆ›å»ºè¿è¡Œæ—¶é€‚é…å™¨
  let runtime_adapter = RuntimeAdapter::new(current_runtime)
  
  // æµ‹è¯•å†…å­˜ç®¡ç†
  let memory_info = RuntimeAdapter::get_memory_info(runtime_adapter)
  assert_true(memory_info.heap_size >= 0)
  assert_true(memory_info.heap_used >= 0)
  assert_true(memory_info.heap_used <= memory_info.heap_size)
  
  // æµ‹è¯•åƒåœ¾å›æ”¶
  if current_runtime == RuntimeType::JVM || current_runtime == RuntimeType::Native {
    let gc_info = RuntimeAdapter::get_gc_info(runtime_adapter)
    assert_true(gc_info.collection_count >= 0)
    assert_true(gc_info.collection_time >= 0)
    
    // è§¦å‘åƒåœ¾å›æ”¶
    RuntimeAdapter::trigger_gc(runtime_adapter)
    
    let gc_info_after = RuntimeAdapter::get_gc_info(runtime_adapter)
    assert_true(gc_info_after.collection_count >= gc_info.collection_count)
  }
  
  // æµ‹è¯•çº¿ç¨‹æ”¯æŒ
  let thread_info = RuntimeAdapter::get_thread_info(runtime_adapter)
  assert_true(thread_info.thread_count > 0)
  assert_true(thread_info.current_thread_id >= 0)
  
  // æµ‹è¯•å¹¶å‘æ”¯æŒ
  let concurrency_support = RuntimeAdapter::get_concurrency_support(runtime_adapter)
  assert_true(concurrency_support.has_threads || concurrency_support.has_async)
  
  // æµ‹è¯•ç½‘ç»œæ”¯æŒ
  let network_support = RuntimeAdapter::get_network_support(runtime_adapter)
  assert_true(network_support.has_tcp || network_support.has_http)
  
  // æµ‹è¯•æ–‡ä»¶ç³»ç»Ÿæ”¯æŒ
  let fs_support = RuntimeAdapter::get_filesystem_support(runtime_adapter)
  assert_true(fs_support.has_file_read || fs_support.has_file_write)
  
  // æµ‹è¯•æ—¶é—´ç²¾åº¦
  let time_precision = RuntimeAdapter::get_time_precision(runtime_adapter)
  assert_true(time_precision.milliseconds_supported)
  if current_runtime != RuntimeType::WebAssembly {
    assert_true(time_precision.microseconds_supported)
  }
  
  // æµ‹è¯•é«˜ç²¾åº¦è®¡æ—¶
  let start_time = RuntimeAdapter::get_high_precision_time(runtime_adapter)
  Thread::sleep(10) // ç­‰å¾…10æ¯«ç§’
  let end_time = RuntimeAdapter::get_high_precision_time(runtime_adapter)
  
  assert_true(end_time > start_time)
  let elapsed = end_time - start_time
  assert_true(elapsed >= 10.0) // è‡³å°‘ç»è¿‡10æ¯«ç§’
}

// æµ‹è¯•4: WebAssemblyå…¼å®¹æ€§
test "WebAssemblyå…¼å®¹æ€§åŠŸèƒ½" {
  // åˆ›å»ºWebAssemblyæ£€æµ‹å™¨
  let wasm_detector = WASMDetector::new()
  
  // æ£€æµ‹æ˜¯å¦åœ¨WebAssemblyç¯å¢ƒ
  let is_wasm_env = WASMDetector::is_wasm_environment(wasm_detector)
  
  if is_wasm_env {
    // åˆ›å»ºWebAssemblyé€‚é…å™¨
    let wasm_adapter = WASMAdapter::new()
    
    // æµ‹è¯•å†…å­˜è®¿é—®
    let memory_info = WASMAdapter::get_memory_info(wasm_adapter)
    assert_true(memory_info.memory_pages > 0)
    assert_true(memory_info.memory_size > 0)
    
    // æµ‹è¯•JavaScriptäº’æ“ä½œ
    let js_support = WASMAdapter::get_js_interop_support(wasm_adapter)
    if js_support.available {
      // æµ‹è¯•å‡½æ•°è°ƒç”¨
      let test_result = WASMAdapter::call_js_function(wasm_adapter, "console.log", ["WASM test"])
      assert_true(test_result)
      
      // æµ‹è¯•å¯¹è±¡è®¿é—®
      let window_obj = WASMAdapter::get_js_object(wasm_adapter, "window")
      assert_true(window_obj.is_valid)
    }
    
    // æµ‹è¯•WebAssemblyç‰¹æ€§
    let wasm_features = WASMAdapter::get_wasm_features(wasm_adapter)
    assert_true(wasm_features.has_basic_instructions)
    
    // æµ‹è¯•æ€§èƒ½é™åˆ¶
    let perf_limits = WASMAdapter::get_performance_limits(wasm_adapter)
    assert_true(perf_limits.max_memory > 0)
    assert_true(perf_limits.max_table_size > 0)
  } else {
    // éWebAssemblyç¯å¢ƒçš„æµ‹è¯•
    assert_true(true) // è·³è¿‡WASMç‰¹å®šæµ‹è¯•
  }
}

// æµ‹è¯•5: è·¨å¹³å°æ•°æ®æ ¼å¼å…¼å®¹æ€§
test "è·¨å¹³å°æ•°æ®æ ¼å¼å…¼å®¹æ€§åŠŸèƒ½" {
  // åˆ›å»ºè·¨å¹³å°åºåˆ—åŒ–å™¨
  let cross_platform_serializer = CrossPlatformSerializer::new()
  
  // åˆ›å»ºæµ‹è¯•æ•°æ®
  let span_data = SpanData::new("cross.platform.test", 1000, 1100, [
    ("platform", "test"),
    ("timestamp", "2023-01-01T00:00:00Z"),
    ("binary.data", "\x00\x01\x02\x03\xFF\xFE\xFD")
  ])
  
  // åºåˆ—åŒ–ä¸ºè·¨å¹³å°æ ¼å¼
  let platform_agnostic_data = CrossPlatformSerializer::serialize(cross_platform_serializer, span_data)
  assert_true(platform_agnostic_data.length() > 0)
  
  // ååºåˆ—åŒ–
  let deserialized_span = CrossPlatformSerializer::deserialize_span(cross_platform_serializer, platform_agnostic_data)
  assert_eq(SpanData::name(deserialized_span), SpanData::name(span_data))
  
  // æµ‹è¯•å­—èŠ‚åºè½¬æ¢
  let test_int = 0x12345678
  let little_endian_bytes = CrossPlatformSerializer::int_to_little_endian(cross_platform_serializer, test_int)
  let big_endian_bytes = CrossPlatformSerializer::int_to_big_endian(cross_platform_serializer, test_int)
  
  assert_ne(little_endian_bytes, big_endian_bytes)
  
  let converted_int1 = CrossPlatformSerializer::little_endian_to_int(cross_platform_serializer, little_endian_bytes)
  let converted_int2 = CrossPlatformSerializer::big_endian_to_int(cross_platform_serializer, big_endian_bytes)
  
  assert_eq(converted_int1, test_int)
  assert_eq(converted_int2, test_int)
  
  // æµ‹è¯•æµ®ç‚¹æ•°æ ¼å¼è½¬æ¢
  let test_float = 3.14159265359
  let float_bytes = CrossPlatformSerializer::float_to_bytes(cross_platform_serializer, test_float)
  let converted_float = CrossPlatformSerializer::bytes_to_float(cross_platform_serializer, float_bytes)
  
  assert_true((converted_float - test_float).abs() < 0.000001)
  
  // æµ‹è¯•å­—ç¬¦ä¸²ç¼–ç è½¬æ¢
  let test_string = "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸² ğŸš€ Unicode"
  let utf8_bytes = CrossPlatformSerializer::string_to_utf8(cross_platform_serializer, test_string)
  let utf16_bytes = CrossPlatformSerializer::string_to_utf16(cross_platform_serializer, test_string)
  
  let converted_utf8 = CrossPlatformSerializer::utf8_to_string(cross_platform_serializer, utf8_bytes)
  let converted_utf16 = CrossPlatformSerializer::utf16_to_string(cross_platform_serializer, utf16_bytes)
  
  assert_eq(converted_utf8, test_string)
  assert_eq(converted_utf16, test_string)
  
  // æµ‹è¯•æ—¶é—´æˆ³æ ¼å¼è½¬æ¢
  let timestamp = 1672531200 // 2023-01-01 00:00:00 UTC
  let iso_string = CrossPlatformSerializer::timestamp_to_iso_string(cross_platform_serializer, timestamp)
  let converted_timestamp = CrossPlatformSerializer::iso_string_to_timestamp(cross_platform_serializer, iso_string)
  
  assert_eq(converted_timestamp, timestamp)
  assert_true(iso_string.contains("2023-01-01"))
}

// æµ‹è¯•6: å¹³å°ç‰¹å®šä¼˜åŒ–
test "å¹³å°ç‰¹å®šä¼˜åŒ–åŠŸèƒ½" {
  // åˆ›å»ºå¹³å°ä¼˜åŒ–å™¨
  let platform_optimizer = PlatformOptimizer::new()
  
  // æ£€æµ‹å½“å‰å¹³å°
  let current_platform = platform_optimizer.detect_platform()
  
  // è·å–å¹³å°ç‰¹å®šä¼˜åŒ–é…ç½®
  let optimization_config = PlatformOptimizer::get_optimization_config(platform_optimizer, current_platform)
  
  // éªŒè¯ä¼˜åŒ–é…ç½®
  assert_true(optimization_config.memory_alignment > 0)
  assert_true(optimization_config.cache_line_size > 0)
  assert_true(optimization_config.vector_size > 0)
  
  // æµ‹è¯•å†…å­˜å¯¹é½ä¼˜åŒ–
  let aligned_data = PlatformOptimizer::allocate_aligned_memory(platform_optimizer, 1024, optimization_config.memory_alignment)
  assert_true(aligned_data.is_valid)
  
  let address = PlatformOptimizer::get_memory_address(platform_optimizer, aligned_data)
  assert_eq(address % optimization_config.memory_alignment, 0) // éªŒè¯å¯¹é½
  
  // æµ‹è¯•SIMDä¼˜åŒ–ï¼ˆå¦‚æœæ”¯æŒï¼‰
  let simd_support = PlatformOptimizer::get_simd_support(platform_optimizer)
  if simd_support.available {
    let simd_result = PlatformOptimizer::run_simd_operation(platform_optimizer, 
      fn(data, size) { /* SIMDæ“ä½œ */ return 42 }, 
      aligned_data, 1024)
    assert_eq(simd_result, 42)
  }
  
  // æµ‹è¯•ç¼“å­˜ä¼˜åŒ–
  let cache_config = PlatformOptimizer::get_cache_config(platform_optimizer)
  assert_true(cache_config.l1_size > 0)
  assert_true(cache_config.l2_size > 0)
  assert_true(cache_config.l3_size >= 0) // L3å¯èƒ½ä¸å­˜åœ¨
  
  // æµ‹è¯•é¢„å–ä¼˜åŒ–
  let test_array = Array::create(1000, 0)
  PlatformOptimizer::prefetch_memory(platform_optimizer, test_array, 0, 1000)
  
  // æµ‹è¯•çº¿ç¨‹äº²å’Œæ€§ä¼˜åŒ–ï¼ˆå¦‚æœæ”¯æŒï¼‰
  let thread_affinity_support = PlatformOptimizer::get_thread_affinity_support(platform_optimizer)
  if thread_affinity_support.available {
    let current_thread = Thread::current()
    let affinity_result = PlatformOptimizer::set_thread_affinity(platform_optimizer, current_thread, 0)
    assert_true(affinity_result)
  }
  
  // æµ‹è¯•CPUé¢‘ç‡ä¼˜åŒ–
  let cpu_info = PlatformOptimizer::get_cpu_info(platform_optimizer)
  assert_true(cpu_info.base_frequency > 0)
  
  if cpu_info.has_turbo_boost {
    assert_true(cpu_info.max_frequency >= cpu_info.base_frequency)
  }
  
  // æµ‹è¯•NUMAä¼˜åŒ–ï¼ˆå¦‚æœæ”¯æŒï¼‰
  let numa_support = PlatformOptimizer::get_numa_support(platform_optimizer)
  if numa_support.available {
    let node_count = PlatformOptimizer::get_numa_node_count(platform_optimizer)
    assert_true(node_count > 0)
    
    let local_memory = PlatformOptimizer::allocate_numa_local_memory(platform_optimizer, 1024, 0)
    assert_true(local_memory.is_valid)
  }
  
  // æ¸…ç†
  PlatformOptimizer::free_aligned_memory(platform_optimizer, aligned_data)
}