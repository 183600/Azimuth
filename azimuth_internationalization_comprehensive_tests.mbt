// Azimuth å›½é™…åŒ–æ”¯æŒæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿå¯¹ä¸åŒè¯­è¨€ã€åœ°åŒºå’Œæ–‡åŒ–çš„æ”¯æŒèƒ½åŠ›

test "å¤šè¯­è¨€å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ä¸­æ–‡æ”¯æŒ
  let chinese_attr = azimuth::AttributeValue::StringValue("æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸²å¤„ç†èƒ½åŠ›")
  match chinese_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸²å¤„ç†èƒ½åŠ›")
      assert_eq(s.length(), 10) // ä¸­æ–‡å­—ç¬¦é•¿åº¦è®¡ç®—
      assert_true(s.contains("æµ‹è¯•"))
      assert_true(s.contains("ä¸­æ–‡"))
      assert_true(s.contains("å­—ç¬¦ä¸²"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ—¥æ–‡æ”¯æŒ
  let japanese_attr = azimuth::AttributeValue::StringValue("æ—¥æœ¬èªæ–‡å­—åˆ—å‡¦ç†æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ")
  match japanese_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "æ—¥æœ¬èªæ–‡å­—åˆ—å‡¦ç†æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ")
      assert_true(s.contains("æ—¥æœ¬èª"))
      assert_true(s.contains("æ–‡å­—åˆ—"))
      assert_true(s.contains("ãƒ†ã‚¹ãƒˆ"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•éŸ©æ–‡æ”¯æŒ
  let korean_attr = azimuth::AttributeValue::StringValue("í•œêµ­ì–´ ë¬¸ìì—´ ì²˜ë¦¬ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸")
  match korean_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "í•œêµ­ì–´ ë¬¸ìì—´ ì²˜ë¦¬ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸")
      assert_true(s.contains("í•œêµ­ì–´"))
      assert_true(s.contains("ë¬¸ìì—´"))
      assert_true(s.contains("í…ŒìŠ¤íŠ¸"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•é˜¿æ‹‰ä¼¯æ–‡æ”¯æŒ
  let arabic_attr = azimuth::AttributeValue::StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø¹Ø§Ù„Ø¬Ø© Ø³Ù„Ø§Ø³Ù„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  match arabic_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø¹Ø§Ù„Ø¬Ø© Ø³Ù„Ø§Ø³Ù„ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
      assert_true(s.contains("Ø§Ø®ØªØ¨Ø§Ø±"))
      assert_true(s.contains("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ä¿„æ–‡æ”¯æŒ
  let russian_attr = azimuth::AttributeValue::StringValue("Ğ¢ĞµÑÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ÑÑ‚Ñ€Ğ¾Ğº Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ")
  match russian_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "Ğ¢ĞµÑÑ‚ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ ÑÑ‚Ñ€Ğ¾Ğº Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ")
      assert_true(s.contains("Ğ¢ĞµÑÑ‚"))
      assert_true(s.contains("Ñ€ÑƒÑÑĞºĞ¾Ğ¼"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ··åˆè¯­è¨€
  let mixed_attr = azimuth::AttributeValue::StringValue("Mixed å¤šêµ­ì–´ Mixed Ø¹Ø±Ø¨ÙŠ Mixed Ğ ÑƒÑÑĞºĞ¸Ğ¹")
  match mixed_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "Mixed å¤šêµ­ì–´ Mixed Ø¹Ø±Ø¨ÙŠ Mixed Ğ ÑƒÑÑĞºĞ¸Ğ¹")
      assert_true(s.contains("Mixed"))
      assert_true(s.contains("ë‹¤êµ­ì–´"))
      assert_true(s.contains("Ø¹Ø±Ø¨ÙŠ"))
      assert_true(s.contains("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
    }
    _ => assert_true(false)
  }
}

test "Unicodeå­—ç¬¦å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•Emojiå­—ç¬¦
  let emoji_attr = azimuth::AttributeValue::StringValue("æµ‹è¯•Emojiæ”¯æŒ ğŸš€ğŸ‰ğŸ’»ğŸŒ")
  match emoji_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "æµ‹è¯•Emojiæ”¯æŒ ğŸš€ğŸ‰ğŸ’»ğŸŒ")
      assert_true(s.contains("ğŸš€"))
      assert_true(s.contains("ğŸ‰"))
      assert_true(s.contains("ğŸ’»"))
      assert_true(s.contains("ğŸŒ"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ•°å­¦ç¬¦å·
  let math_attr = azimuth::AttributeValue::StringValue("æ•°å­¦ç¬¦å·æµ‹è¯• âˆ‘âˆâˆ«âˆ‚âˆ‡âˆ†")
  match math_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "æ•°å­¦ç¬¦å·æµ‹è¯• âˆ‘âˆâˆ«âˆ‚âˆ‡âˆ†")
      assert_true(s.contains("âˆ‘"))
      assert_true(s.contains("âˆ"))
      assert_true(s.contains("âˆ«"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•è´§å¸ç¬¦å·
  let currency_attr = azimuth::AttributeValue::StringValue("è´§å¸ç¬¦å·æµ‹è¯• Â¥â‚¬Â£$â‚¹â‚½â‚©")
  match currency_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "è´§å¸ç¬¦å·æµ‹è¯• Â¥â‚¬Â£$â‚¹â‚½â‚©")
      assert_true(s.contains("Â¥"))
      assert_true(s.contains("â‚¬"))
      assert_true(s.contains("Â£"))
      assert_true(s.contains("$"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®ŠUnicodeå­—ç¬¦
  let special_attr = azimuth::AttributeValue::StringValue("ç‰¹æ®Šå­—ç¬¦æµ‹è¯• Â©Â®â„¢â„ Â§Â¶â€ â€¡â€¢â€¦â€°â€±")
  match special_attr {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "ç‰¹æ®Šå­—ç¬¦æµ‹è¯• Â©Â®â„¢â„ Â§Â¶â€ â€¡â€¢â€¦â€°â€±")
      assert_true(s.contains("Â©"))
      assert_true(s.contains("Â®"))
      assert_true(s.contains("â„¢"))
    }
    _ => assert_true(false)
  }
}

test "åœ°åŒºæ ¼å¼åŒ–æµ‹è¯•" {
  // æµ‹è¯•æ—¥æœŸæ ¼å¼åŒ–
  let date_str = "2023-12-25T10:30:00Z"
  
  // ç¾å›½æ ¼å¼
  let us_date = "12/25/2023, 10:30:00 AM"
  assert_true(us_date.contains("12/25/2023"))
  assert_true(us_date.contains("10:30:00 AM"))
  
  // æ¬§æ´²æ ¼å¼
  let eu_date = "25/12/2023, 10:30:00"
  assert_true(eu_date.contains("25/12/2023"))
  assert_true(eu_date.contains("10:30:00"))
  
  // ä¸­å›½æ ¼å¼
  let cn_date = "2023å¹´12æœˆ25æ—¥ 10:30:00"
  assert_true(cn_date.contains("2023å¹´12æœˆ25æ—¥"))
  assert_true(cn_date.contains("10:30:00"))
  
  // æ—¥æœ¬æ ¼å¼
  let jp_date = "2023å¹´12æœˆ25æ—¥ 10æ™‚30åˆ†00ç§’"
  assert_true(jp_date.contains("2023å¹´12æœˆ25æ—¥"))
  assert_true(jp_date.contains("10æ™‚30åˆ†00ç§’"))
  
  // æµ‹è¯•æ•°å­—æ ¼å¼åŒ–
  let number = 1234567.89
  
  // ç¾å›½æ ¼å¼
  let us_number = "1,234,567.89"
  assert_true(us_number.contains("1,234,567.89"))
  
  // æ¬§æ´²æ ¼å¼
  let eu_number = "1.234.567,89"
  assert_true(eu_number.contains("1.234.567,89"))
  
  // ä¸­å›½æ ¼å¼
  let cn_number = "1,234,567.89"
  assert_true(cn_number.contains("1,234,567.89"))
  
  // æµ‹è¯•è´§å¸æ ¼å¼åŒ–
  let currency = 1234.56
  
  // ç¾å…ƒ
  let usd = "$1,234.56"
  assert_true(usd.contains("$1,234.56"))
  
  // æ¬§å…ƒ
  let eur = "â‚¬1.234,56"
  assert_true(eur.contains("â‚¬1.234,56"))
  
  // äººæ°‘å¸
  let cny = "Â¥1,234.56"
  assert_true(cny.contains("Â¥1,234.56"))
  
  // æ—¥å…ƒ
  let jpy = "Â¥1,235"
  assert_true(jpy.contains("Â¥1,235"))
}

test "æœ¬åœ°åŒ–å±æ€§æµ‹è¯•" {
  // åˆ›å»ºå¤šè¯­è¨€å±æ€§é›†åˆ
  let localized_attrs = azimuth::Attributes {
    values: [
      // è‹±æ–‡å±æ€§
      ("en.user.name", azimuth::AttributeValue::StringValue("John Doe")),
      ("en.operation.name", azimuth::AttributeValue::StringValue("User Authentication")),
      ("en.error.message", azimuth::AttributeValue::StringValue("Invalid credentials provided")),
      
      // ä¸­æ–‡å±æ€§
      ("zh.user.name", azimuth::AttributeValue::StringValue("å¼ ä¸‰")),
      ("zh.operation.name", azimuth::AttributeValue::StringValue("ç”¨æˆ·è®¤è¯")),
      ("zh.error.message", azimuth::AttributeValue::StringValue("æä¾›çš„å‡­æ®æ— æ•ˆ")),
      
      // æ—¥æ–‡å±æ€§
      ("ja.user.name", azimuth::AttributeValue::StringValue("ç”°ä¸­å¤ªéƒ")),
      ("ja.operation.name", azimuth::AttributeValue::StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼")),
      ("ja.error.message", azimuth::AttributeValue::StringValue("ç„¡åŠ¹ãªè³‡æ ¼æƒ…å ±ãŒæä¾›ã•ã‚Œã¾ã—ãŸ")),
      
      // éŸ©æ–‡å±æ€§
      ("ko.user.name", azimuth::AttributeValue::StringValue("ê¹€ì² ìˆ˜")),
      ("ko.operation.name", azimuth::AttributeValue::StringValue("ì‚¬ìš©ì ì¸ì¦")),
      ("ko.error.message", azimuth::AttributeValue::StringValue("ì˜ëª»ëœ ìê²© ì¦ëª…ì´ ì œê³µë˜ì—ˆìŠµë‹ˆë‹¤"))
    ]
  }
  
  // éªŒè¯å±æ€§æ•°é‡
  assert_eq(localized_attrs.values.length(), 12)
  
  // éªŒè¯è‹±æ–‡å±æ€§
  let mut en_attrs_found = 0
  for (key, value) in localized_attrs.values {
    if key.starts_with("en.") {
      match value {
        azimuth::AttributeValue::StringValue(v) => {
          match key {
            "en.user.name" => assert_eq(v, "John Doe")
            "en.operation.name" => assert_eq(v, "User Authentication")
            "en.error.message" => assert_eq(v, "Invalid credentials provided")
            _ => assert_true(false)
          }
          en_attrs_found = en_attrs_found + 1
        }
        _ => assert_true(false)
      }
    }
  }
  assert_eq(en_attrs_found, 3)
  
  // éªŒè¯ä¸­æ–‡å±æ€§
  let mut zh_attrs_found = 0
  for (key, value) in localized_attrs.values {
    if key.starts_with("zh.") {
      match value {
        azimuth::AttributeValue::StringValue(v) => {
          match key {
            "zh.user.name" => assert_eq(v, "å¼ ä¸‰")
            "zh.operation.name" => assert_eq(v, "ç”¨æˆ·è®¤è¯")
            "zh.error.message" => assert_eq(v, "æä¾›çš„å‡­æ®æ— æ•ˆ")
            _ => assert_true(false)
          }
          zh_attrs_found = zh_attrs_found + 1
        }
        _ => assert_true(false)
      }
    }
  }
  assert_eq(zh_attrs_found, 3)
  
  // éªŒè¯æ—¥æ–‡å±æ€§
  let mut ja_attrs_found = 0
  for (key, value) in localized_attrs.values {
    if key.starts_with("ja.") {
      match value {
        azimuth::AttributeValue::StringValue(v) => {
          match key {
            "ja.user.name" => assert_eq(v, "ç”°ä¸­å¤ªéƒ")
            "ja.operation.name" => assert_eq(v, "ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼")
            "ja.error.message" => assert_eq(v, "ç„¡åŠ¹ãªè³‡æ ¼æƒ…å ±ãŒæä¾›ã•ã‚Œã¾ã—ãŸ")
            _ => assert_true(false)
          }
          ja_attrs_found = ja_attrs_found + 1
        }
        _ => assert_true(false)
      }
    }
  }
  assert_eq(ja_attrs_found, 3)
  
  // éªŒè¯éŸ©æ–‡å±æ€§
  let mut ko_attrs_found = 0
  for (key, value) in localized_attrs.values {
    if key.starts_with("ko.") {
      match value {
        azimuth::AttributeValue::StringValue(v) => {
          match key {
            "ko.user.name" => assert_eq(v, "ê¹€ì² ìˆ˜")
            "ko.operation.name" => assert_eq(v, "ì‚¬ìš©ì ì¸ì¦")
            "ko.error.message" => assert_eq(v, "ì˜ëª»ëœ ìê²© ì¦ëª…ì´ ì œê³µë˜ì—ˆìŠµë‹ˆë‹¤")
            _ => assert_true(false)
          }
          ko_attrs_found = ko_attrs_found + 1
        }
        _ => assert_true(false)
      }
    }
  }
  assert_eq(ko_attrs_found, 3)
}

test "æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯æµ‹è¯•" {
  // åˆ›å»ºå¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  let error_messages = [
    // è‹±æ–‡é”™è¯¯
    ("en.error.invalid_input", "Invalid input provided"),
    ("en.error.network_failure", "Network connection failed"),
    ("en.error.timeout", "Operation timed out"),
    ("en.error.permission_denied", "Permission denied"),
    
    // ä¸­æ–‡é”™è¯¯
    ("zh.error.invalid_input", "æä¾›çš„è¾“å…¥æ— æ•ˆ"),
    ("zh.error.network_failure", "ç½‘ç»œè¿æ¥å¤±è´¥"),
    ("zh.error.timeout", "æ“ä½œè¶…æ—¶"),
    ("zh.error.permission_denied", "æƒé™è¢«æ‹’ç»"),
    
    // æ—¥æ–‡é”™è¯¯
    ("ja.error.invalid_input", "ç„¡åŠ¹ãªå…¥åŠ›ãŒæä¾›ã•ã‚Œã¾ã—ãŸ"),
    ("ja.error.network_failure", "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãŒå¤±æ•—ã—ã¾ã—ãŸ"),
    ("ja.error.timeout", "æ“ä½œãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ"),
    ("ja.error.permission_denied", "ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ"),
    
    // éŸ©æ–‡é”™è¯¯
    ("ko.error.invalid_input", "ì˜ëª»ëœ ì…ë ¥ì´ ì œê³µë˜ì—ˆìŠµë‹ˆë‹¤"),
    ("ko.error.network_failure", "ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤"),
    ("ko.error.timeout", "ì‘ì—…ì´ ì‹œê°„ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤"),
    ("ko.error.permission_denied", "ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤")
  ]
  
  // åˆ›å»ºé”™è¯¯æ¶ˆæ¯å±æ€§é›†åˆ
  let mut error_attrs = azimuth::Attributes { values: [] }
  for (key, value) in error_messages {
    error_attrs.values = error_attrs.values + [(key, azimuth::AttributeValue::StringValue(value))]
  }
  
  // éªŒè¯é”™è¯¯æ¶ˆæ¯æ•°é‡
  assert_eq(error_attrs.values.length(), 16)
  
  // éªŒè¯å„è¯­è¨€çš„é”™è¯¯æ¶ˆæ¯
  let languages = ["en", "zh", "ja", "ko"]
  let error_types = ["invalid_input", "network_failure", "timeout", "permission_denied"]
  
  for lang in languages {
    let mut lang_errors_found = 0
    for error_type in error_types {
      let error_key = lang + ".error." + error_type
      let mut found = false
      
      for (key, value) in error_attrs.values {
        if key == error_key {
          match value {
            azimuth::AttributeValue::StringValue(message) => {
              assert_not_eq(message.length(), 0)
              found = true
            }
            _ => assert_true(false)
          }
          break
        }
      }
      
      assert_true(found) // ç¡®ä¿æ¯ä¸ªé”™è¯¯æ¶ˆæ¯éƒ½å­˜åœ¨
      lang_errors_found = lang_errors_found + 1
    }
    
    assert_eq(lang_errors_found, 4) // æ¯ç§è¯­è¨€åº”è¯¥æœ‰4ä¸ªé”™è¯¯æ¶ˆæ¯
  }
}

test "æ—¶åŒºå’Œæœ¬åœ°åŒ–æ—¶é—´æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒæ—¶åŒºçš„æ—¶é—´è¡¨ç¤º
  let base_time = "2023-12-25T10:30:00Z" // UTCæ—¶é—´
  
  // ä¸åŒæ—¶åŒºçš„æ—¶é—´
  let time_zones = [
    ("UTC", "2023-12-25T10:30:00Z"),
    ("America/New_York", "2023-12-25T05:30:00-05:00"),
    ("Europe/London", "2023-12-25T10:30:00Z"),
    ("Europe/Paris", "2023-12-25T11:30:00+01:00"),
    ("Asia/Tokyo", "2023-12-25T19:30:00+09:00"),
    ("Asia/Shanghai", "2023-12-25T18:30:00+08:00"),
    ("Asia/Seoul", "2023-12-25T19:30:00+09:00"),
    ("Australia/Sydney", "2023-12-25T21:30:00+11:00")
  ]
  
  // åˆ›å»ºæ—¶åŒºå±æ€§
  let mut timezone_attrs = azimuth::Attributes { values: [] }
  for (zone, time) in time_zones {
    timezone_attrs.values = timezone_attrs.values + [
      ("timezone." + zone, azimuth::AttributeValue::StringValue(time))
    ]
  }
  
  // éªŒè¯æ—¶åŒºå±æ€§
  assert_eq(timezone_attrs.values.length(), 8)
  
  // éªŒè¯ç‰¹å®šæ—¶åŒº
  let tokyo_time = None
  for (key, value) in timezone_attrs.values {
    if key == "timezone.Asia/Tokyo" {
      match value {
        azimuth::AttributeValue::StringValue(time) => {
          assert_eq(time, "2023-12-25T19:30:00+09:00")
        }
        _ => assert_true(false)
      }
    }
  }
  
  // æµ‹è¯•æœ¬åœ°åŒ–æ—¶é—´æ ¼å¼
  let localized_times = [
    ("en", "Monday, December 25, 2023 10:30:00 AM"),
    ("zh", "2023å¹´12æœˆ25æ—¥æ˜ŸæœŸä¸€ ä¸Šåˆ10:30:00"),
    ("ja", "2023å¹´12æœˆ25æ—¥æœˆæ›œæ—¥ 10æ™‚30åˆ†00ç§’"),
    ("ko", "2023ë…„ 12ì›” 25ì¼ ì›”ìš”ì¼ ì˜¤ì „ 10:30:00"),
    ("fr", "lundi 25 dÃ©cembre 2023 Ã  10:30:00"),
    ("de", "Montag, 25. Dezember 2023, 10:30:00 Uhr"),
    ("es", "lunes, 25 de diciembre de 2023, 10:30:00"),
    ("ru", "Ğ¿Ğ¾Ğ½ĞµĞ´ĞµĞ»ÑŒĞ½Ğ¸Ğº, 25 Ğ´ĞµĞºĞ°Ğ±Ñ€Ñ 2023 Ğ³., 10:30:00")
  ]
  
  // åˆ›å»ºæœ¬åœ°åŒ–æ—¶é—´å±æ€§
  let mut localized_time_attrs = azimuth::Attributes { values: [] }
  for (lang, time) in localized_times {
    localized_time_attrs.values = localized_time_attrs.values + [
      ("time." + lang, azimuth::AttributeValue::StringValue(time))
    ]
  }
  
  // éªŒè¯æœ¬åœ°åŒ–æ—¶é—´å±æ€§
  assert_eq(localized_time_attrs.values.length(), 8)
  
  // éªŒè¯ç‰¹å®šè¯­è¨€çš„æ—¶é—´æ ¼å¼
  for (key, value) in localized_time_attrs.values {
    if key == "time.zh" {
      match value {
        azimuth::AttributeValue::StringValue(time) => {
          assert_eq(time, "2023å¹´12æœˆ25æ—¥æ˜ŸæœŸä¸€ ä¸Šåˆ10:30:00")
          assert_true(time.contains("2023å¹´"))
          assert_true(time.contains("ä¸Šåˆ"))
        }
        _ => assert_true(false)
      }
    }
  }
}

test "æ–‡åŒ–ç‰¹å®šæ•°æ®æµ‹è¯•" {
  // æµ‹è¯•æ–‡åŒ–ç‰¹å®šçš„æ•°æ®æ ¼å¼å’Œçº¦å®š
  
  // å§“åæ ¼å¼
  let name_formats = [
    ("en.western", "John Doe"), // å å§“
    ("zh.eastern", "å¼ ä¸‰"), // å§“ å
    ("ja.eastern", "ç”°ä¸­å¤ªéƒ"), // å§“ å
    ("ko.eastern", "ê¹€ì² ìˆ˜"), // å§“ å
    ("hu.eastern", "Nagy JÃ¡nos"), // å§“ å
    ("es.western", "Juan GarcÃ­a"), // å å§“
    ("ru.eastern", "Ğ˜Ğ²Ğ°Ğ½ Ğ˜Ğ²Ğ°Ğ½Ğ¾Ğ²"), // å å§“
    ("ar.eastern", "Ù…Ø­Ù…Ø¯ Ø£Ø­Ù…Ø¯") // å å§“
  ]
  
  // åˆ›å»ºå§“åæ ¼å¼å±æ€§
  let mut name_attrs = azimuth::Attributes { values: [] }
  for (culture, name) in name_formats {
    name_attrs.values = name_attrs.values + [
      ("name." + culture, azimuth::AttributeValue::StringValue(name))
    ]
  }
  
  // éªŒè¯å§“åæ ¼å¼å±æ€§
  assert_eq(name_attrs.values.length(), 8)
  
  // åœ°å€æ ¼å¼
  let address_formats = [
    ("en.us", "123 Main St, New York, NY 10001"),
    ("zh.cn", "ä¸­å›½åŒ—äº¬å¸‚æœé˜³åŒºå»ºå›½è·¯123å·"),
    ("ja.jp", "ã€’100-0001 æ±äº¬éƒ½åƒä»£ç”°åŒºåƒä»£ç”°1-1"),
    ("ko.kr", "ì„œìš¸íŠ¹ë³„ì‹œ ì¢…ë¡œêµ¬ ì¢…ë¡œ1ê°€ 123"),
    ("de.de", "MusterstraÃŸe 123, 12345 Berlin"),
    ("fr.fr", "123 Rue de la Paix, 75001 Paris"),
    ("ru.ru", "123456, Ğ³. ĞœĞ¾ÑĞºĞ²Ğ°, ÑƒĞ». Ğ¢Ğ²ĞµÑ€ÑĞºĞ°Ñ, Ğ´. 1"),
    ("ar.sa", "12345 Ø§Ù„Ø±ÙŠØ§Ø¶ØŒ Ø´Ø§Ø±Ø¹ Ø§Ù„Ù…Ù„Ùƒ ÙÙ‡Ø¯ØŒ Øµ. Ø¨. 1234")
  ]
  
  // åˆ›å»ºåœ°å€æ ¼å¼å±æ€§
  let mut address_attrs = azimuth::Attributes { values: [] }
  for (culture, address) in address_formats {
    address_attrs.values = address_attrs.values + [
      ("address." + culture, azimuth::AttributeValue::StringValue(address))
    ]
  }
  
  // éªŒè¯åœ°å€æ ¼å¼å±æ€§
  assert_eq(address_attrs.values.length(), 8)
  
  // ç”µè¯å·ç æ ¼å¼
  let phone_formats = [
    ("en.us", "+1 (555) 123-4567"),
    ("zh.cn", "+86 138 0013 8000"),
    ("ja.jp", "+81-3-1234-5678"),
    ("ko.kr", "+82-2-1234-5678"),
    ("de.de", "+49 30 12345678"),
    ("fr.fr", "+33 1 23 45 67 89"),
    ("ru.ru", "+7 495 123-45-67"),
    ("gb.uk", "+44 20 7946 0958")
  ]
  
  // åˆ›å»ºç”µè¯å·ç æ ¼å¼å±æ€§
  let mut phone_attrs = azimuth::Attributes { values: [] }
  for (culture, phone) in phone_formats {
    phone_attrs.values = phone_attrs.values + [
      ("phone." + culture, azimuth::AttributeValue::StringValue(phone))
    ]
  }
  
  // éªŒè¯ç”µè¯å·ç æ ¼å¼å±æ€§
  assert_eq(phone_attrs.values.length(), 8)
  
  // éªŒè¯ç‰¹å®šæ ¼å¼çš„ç”µè¯å·ç 
  for (key, value) in phone_attrs.values {
    if key == "phone.zh.cn" {
      match value {
        azimuth::AttributeValue::StringValue(phone) => {
          assert_eq(phone, "+86 138 0013 8000")
          assert_true(phone.starts_with("+86"))
        }
        _ => assert_true(false)
      }
    }
  }
}

test "æ–‡æœ¬æ–¹å‘å’Œä¹¦å†™ç³»ç»Ÿæµ‹è¯•" {
  // æµ‹è¯•ä»å·¦åˆ°å³çš„ä¹¦å†™ç³»ç»Ÿ
  let ltr_text = azimuth::AttributeValue::StringValue("Hello World! This is left-to-right text.")
  match ltr_text {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "Hello World! This is left-to-right text.")
      assert_true(s.starts_with("Hello"))
      assert_true(s.ends_with("text."))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ä»å³åˆ°å·¦çš„ä¹¦å†™ç³»ç»Ÿ
  let rtl_text = azimuth::AttributeValue::StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…! Ù‡Ø°Ø§ Ù†Øµ Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±.")
  match rtl_text {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…! Ù‡Ø°Ø§ Ù†Øµ Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±.")
      assert_true(s.contains("Ù…Ø±Ø­Ø¨Ø§"))
      assert_true(s.contains("Ø§Ù„Ø¹Ø§Ù„Ù…"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒå‘æ–‡æœ¬
  let bidi_text = azimuth::AttributeValue::StringValue("English text Ù…Ø¹ Ø§Ù„Ù†Øµ Ø§Ù„Ø¹Ø±Ø¨ÙŠ more English")
  match bidi_text {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "English text Ù…Ø¹ Ø§Ù„Ù†Øµ Ø§Ù„Ø¹Ø±Ø¨ÙŠ more English")
      assert_true(s.contains("English text"))
      assert_true(s.contains("Ù…Ø¹ Ø§Ù„Ù†Øµ Ø§Ù„Ø¹Ø±Ø¨ÙŠ"))
      assert_true(s.contains("more English"))
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å‚ç›´ä¹¦å†™ç³»ç»Ÿ
  let vertical_text = azimuth::AttributeValue::StringValue("ç¸¦æ›¸ãã®\nãƒ†ã‚­ã‚¹ãƒˆã§ã™")
  match vertical_text {
    azimuth::AttributeValue::StringValue(s) => {
      assert_eq(s, "ç¸¦æ›¸ãã®\nãƒ†ã‚­ã‚¹ãƒˆã§ã™")
      assert_true(s.contains("ç¸¦æ›¸ãã®"))
      assert_true(s.contains("ãƒ†ã‚­ã‚¹ãƒˆã§ã™"))
    }
    _ => assert_true(false)
  }
  
  // åˆ›å»ºæ–‡æœ¬æ–¹å‘å±æ€§
  let text_direction_attrs = azimuth::Attributes {
    values: [
      ("en.direction", azimuth::AttributeValue::StringValue("ltr")),
      ("ar.direction", azimuth::AttributeValue::StringValue("rtl")),
      ("he.direction", azimuth::AttributeValue::StringValue("rtl")),
      ("zh.direction", azimuth::AttributeValue::StringValue("ltr")),
      ("ja.direction", azimuth::AttributeValue::StringValue("ltr")),
      ("ko.direction", azimuth::AttributeValue::StringValue("ltr")),
      ("fa.direction", azimuth::AttributeValue::StringValue("rtl")),
      ("ur.direction", azimuth::AttributeValue::StringValue("rtl"))
    ]
  }
  
  // éªŒè¯æ–‡æœ¬æ–¹å‘å±æ€§
  assert_eq(text_direction_attrs.values.length(), 8)
  
  // éªŒè¯ç‰¹å®šè¯­è¨€çš„æ–‡æœ¬æ–¹å‘
  let mut ltr_count = 0
  let mut rtl_count = 0
  
  for (key, value) in text_direction_attrs.values {
    match value {
      azimuth::AttributeValue::StringValue(direction) => {
        if direction == "ltr" {
          ltr_count = ltr_count + 1
        } else if direction == "rtl" {
          rtl_count = rtl_count + 1
        } else {
          assert_true(false) // ä¸åº”è¯¥æœ‰å…¶ä»–æ–¹å‘
        }
      }
      _ => assert_true(false)
    }
  }
  
  assert_eq(ltr_count, 4) // è‹±è¯­ã€ä¸­æ–‡ã€æ—¥è¯­ã€éŸ©è¯­
  assert_eq(rtl_count, 4) // é˜¿æ‹‰ä¼¯è¯­ã€å¸Œä¼¯æ¥è¯­ã€æ³¢æ–¯è¯­ã€ä¹Œå°”éƒ½è¯­
}