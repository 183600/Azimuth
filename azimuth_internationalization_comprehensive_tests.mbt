// Azimuth å›½é™…åŒ–ç»¼åˆæµ‹è¯•
// å…¨é¢æµ‹è¯•å¤šè¯­è¨€å’Œæœ¬åœ°åŒ–åŠŸèƒ½

// æµ‹è¯•1: åŸºæœ¬è¯­è¨€æ£€æµ‹
test "åŸºæœ¬è¯­è¨€æ£€æµ‹" {
  // æ”¯æŒçš„è¯­è¨€åˆ—è¡¨
  let supported_languages = ["en", "zh", "es", "fr", "de", "ja"]
  
  // è¯­è¨€ä»£ç æ˜ å°„
  let language_names = {
    "en": "English",
    "zh": "ä¸­æ–‡",
    "es": "EspaÃ±ol",
    "fr": "FranÃ§ais",
    "de": "Deutsch",
    "ja": "æ—¥æœ¬èª"
  }
  
  // æ£€æµ‹è¯­è¨€æ˜¯å¦æ”¯æŒ
  let is_language_supported = fn(lang_code) {
    supported_languages.contains(lang_code)
  }
  
  // è·å–è¯­è¨€åç§°
  let get_language_name = fn(lang_code) {
    if language_names.contains(lang_code) {
      language_names[lang_code]
    } else {
      "Unknown"
    }
  }
  
  // æµ‹è¯•è¯­è¨€æ£€æµ‹
  assert_true(is_language_supported("en"))
  assert_true(is_language_supported("zh"))
  assert_false(is_language_supported("ru"))
  assert_false(is_language_supported("invalid"))
  
  assert_eq(get_language_name("en"), "English")
  assert_eq(get_language_name("zh"), "ä¸­æ–‡")
  assert_eq(get_language_name("invalid"), "Unknown")
}

// æµ‹è¯•2: æ–‡æœ¬ç¿»è¯‘
test "æ–‡æœ¬ç¿»è¯‘" {
  // ç¿»è¯‘å­—å…¸
  let translations = {
    "en": {
      "welcome": "Welcome",
      "login": "Login",
      "logout": "Logout",
      "username": "Username",
      "password": "Password",
      "submit": "Submit"
    },
    "zh": {
      "welcome": "æ¬¢è¿",
      "login": "ç™»å½•",
      "logout": "ç™»å‡º",
      "username": "ç”¨æˆ·å",
      "password": "å¯†ç ",
      "submit": "æäº¤"
    },
    "es": {
      "welcome": "Bienvenido",
      "login": "Iniciar sesiÃ³n",
      "logout": "Cerrar sesiÃ³n",
      "username": "Nombre de usuario",
      "password": "ContraseÃ±a",
      "submit": "Enviar"
    }
  }
  
  // ç¿»è¯‘å‡½æ•°
  let translate = fn(key, language) {
    if translations.contains(language) && translations[language].contains(key) {
      translations[language][key]
    } else if translations.contains("en") && translations["en"].contains(key) {
      // å›é€€åˆ°è‹±è¯­
      translations["en"][key]
    } else {
      "[" + key + "]" // æ˜¾ç¤ºé”®åä½œä¸ºå›é€€
    }
  }
  
  // æµ‹è¯•ç¿»è¯‘
  assert_eq(translate("welcome", "en"), "Welcome")
  assert_eq(translate("welcome", "zh"), "æ¬¢è¿")
  assert_eq(translate("welcome", "es"), "Bienvenido")
  
  assert_eq(translate("login", "zh"), "ç™»å½•")
  assert_eq(translate("password", "es"), "ContraseÃ±a")
  
  // æµ‹è¯•å›é€€æœºåˆ¶
  assert_eq(translate("welcome", "fr"), "Welcome") // å›é€€åˆ°è‹±è¯­
  assert_eq(translate("nonexistent", "en"), "[nonexistent]") // ä¸å­˜åœ¨çš„é”®
}

// æµ‹è¯•3: å¤æ•°å½¢å¼å¤„ç†
test "å¤æ•°å½¢å¼å¤„ç†" {
  // å¤æ•°è§„åˆ™
  let plural_rules = {
    "en": fn(count) {
      if count == 1 { "one" } else { "other" }
    },
    "zh": fn(count) { "other" }, // ä¸­æ–‡æ²¡æœ‰å¤æ•°å½¢å¼
    "ru": fn(count) {
      let mod10 = count % 10
      let mod100 = count % 100
      
      if mod10 == 1 && mod100 != 11 {
        "one"
      } else if mod10 >= 2 && mod10 <= 4 && (mod100 < 10 || mod100 >= 20) {
        "few"
      } else {
        "other"
      }
    }
  }
  
  // å¤æ•°ç¿»è¯‘
  let plural_translations = {
    "en": {
      "item": {
        "one": "item",
        "other": "items"
      },
      "message": {
        "one": "message",
        "other": "messages"
      }
    },
    "zh": {
      "item": {
        "other": "é¡¹ç›®"
      },
      "message": {
        "other": "æ¶ˆæ¯"
      }
    },
    "ru": {
      "item": {
        "one": "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚",
        "few": "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°",
        "other": "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²"
      }
    }
  }
  
  // å¤æ•°ç¿»è¯‘å‡½æ•°
  let translate_plural = fn(key, count, language) {
    if plural_rules.contains(language) {
      let rule = plural_rules[language]
      let plural_form = rule(count)
      
      if plural_translations.contains(language) && 
         plural_translations[language].contains(key) && 
         plural_translations[language][key].contains(plural_form) {
        plural_translations[language][key][plural_form]
      } else {
        count.to_string() + " " + key
      }
    } else {
      count.to_string() + " " + key
    }
  }
  
  // æµ‹è¯•å¤æ•°å½¢å¼
  assert_eq(translate_plural("item", 1, "en"), "item")
  assert_eq(translate_plural("item", 5, "en"), "items")
  
  assert_eq(translate_plural("item", 1, "zh"), "é¡¹ç›®")
  assert_eq(translate_plural("item", 5, "zh"), "é¡¹ç›®") // ä¸­æ–‡æ²¡æœ‰å¤æ•°
  
  assert_eq(translate_plural("item", 1, "ru"), "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚")
  assert_eq(translate_plural("item", 3, "ru"), "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°")
  assert_eq(translate_plural("item", 5, "ru"), "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²")
  assert_eq(translate_plural("item", 11, "ru"), "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²") // 11æ˜¯ç‰¹æ®Šæƒ…å†µ
}

// æµ‹è¯•4: æ—¥æœŸå’Œæ—¶é—´æ ¼å¼åŒ–
test "æ—¥æœŸå’Œæ—¶é—´æ ¼å¼åŒ–" {
  // æ—¥æœŸæ ¼å¼
  let date_formats = {
    "en": "MM/DD/YYYY",
    "zh": "YYYYå¹´MMæœˆDDæ—¥",
    "de": "DD.MM.YYYY",
    "ja": "YYYYå¹´MMæœˆDDæ—¥"
  }
  
  // æ—¶é—´æ ¼å¼
  let time_formats = {
    "en": "h:mm:ss A",
    "zh": "HH:mm:ss",
    "de": "HH:mm:ss",
    "ja": "HH:mm:ss"
  }
  
  // æ ¼å¼åŒ–æ—¥æœŸ
  let format_date = fn(year, month, day, language) {
    let format = if date_formats.contains(language) {
      date_formats[language]
    } else {
      "YYYY-MM-DD" // é»˜è®¤æ ¼å¼
    }
    
    match format {
      "MM/DD/YYYY" => month.to_string() + "/" + day.to_string() + "/" + year.to_string(),
      "YYYYå¹´MMæœˆDDæ—¥" => year.to_string() + "å¹´" + month.to_string() + "æœˆ" + day.to_string() + "æ—¥",
      "DD.MM.YYYY" => day.to_string() + "." + month.to_string() + "." + year.to_string(),
      _ => year.to_string() + "-" + month.to_string() + "-" + day.to_string()
    }
  }
  
  // æ ¼å¼åŒ–æ—¶é—´
  let format_time = fn(hour, minute, second, language) {
    let format = if time_formats.contains(language) {
      time_formats[language]
    } else {
      "HH:mm:ss" // é»˜è®¤æ ¼å¼
    }
    
    match format {
      "h:mm:ss A" => {
        let hour_12 = if hour > 12 { hour - 12 } else { if hour == 0 { 12 } else { hour } }
        let am_pm = if hour >= 12 { "PM" } else { "AM" }
        hour_12.to_string() + ":" + minute.to_string() + ":" + second.to_string() + " " + am_pm
      },
      _ => hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
    }
  }
  
  // æµ‹è¯•æ—¥æœŸæ ¼å¼åŒ–
  assert_eq(format_date(2023, 1, 15, "en"), "1/15/2023")
  assert_eq(format_date(2023, 1, 15, "zh"), "2023å¹´1æœˆ15æ—¥")
  assert_eq(format_date(2023, 1, 15, "de"), "15.1.2023")
  
  // æµ‹è¯•æ—¶é—´æ ¼å¼åŒ–
  assert_eq(format_time(14, 30, 45, "en"), "2:30:45 PM")
  assert_eq(format_time(14, 30, 45, "zh"), "14:30:45")
  assert_eq(format_time(9, 5, 30, "en"), "9:05:30 AM")
}

// æµ‹è¯•5: æ•°å­—æ ¼å¼åŒ–
test "æ•°å­—æ ¼å¼åŒ–" {
  // æ•°å­—æ ¼å¼é…ç½®
  let number_formats = {
    "en": {
      decimal_separator: ".",
      thousands_separator: ",",
      currency_symbol: "$",
      currency_position: "before"
    },
    "de": {
      decimal_separator: ",",
      thousands_separator: ".",
      currency_symbol: "â‚¬",
      currency_position: "after"
    },
    "zh": {
      decimal_separator: ".",
      thousands_separator: ",",
      currency_symbol: "Â¥",
      currency_position: "before"
    }
  }
  
  // æ ¼å¼åŒ–æ•°å­—
  let format_number = fn(number, language) {
    if number_formats.contains(language) {
      let format = number_formats[language]
      let decimal_part = ""
      let integer_part = ""
      
      // åˆ†ç¦»æ•´æ•°å’Œå°æ•°éƒ¨åˆ†
      let number_str = number.to_string()
      if number_str.contains(".") {
        let parts = number_str.split(".")
        integer_part = parts[0]
        decimal_part = format.decimal_separator + parts[1]
      } else {
        integer_part = number_str
      }
      
      // æ·»åŠ åƒä½åˆ†éš”ç¬¦
      let formatted_integer = ""
      let mut count = 0
      
      for i in integer_part.length() - 1 ..= 0 {
        formatted_integer = integer_part[i] + formatted_integer
        count = count + 1
        
        if count == 3 && i > 0 {
          formatted_integer = format.thousands_separator + formatted_integer
          count = 0
        }
      }
      
      formatted_integer + decimal_part
    } else {
      number.to_string()
    }
  }
  
  // æ ¼å¼åŒ–è´§å¸
  let format_currency = fn(amount, language) {
    if number_formats.contains(language) {
      let format = number_formats[language]
      let formatted_number = format_number(amount, language)
      
      if format.currency_position == "before" {
        format.currency_symbol + formatted_number
      } else {
        formatted_number + " " + format.currency_symbol
      }
    } else {
      amount.to_string()
    }
  }
  
  // æµ‹è¯•æ•°å­—æ ¼å¼åŒ–
  assert_eq(format_number(1234567.89, "en"), "1,234,567.89")
  assert_eq(format_number(1234567.89, "de"), "1.234.567,89")
  assert_eq(format_number(1234567.89, "zh"), "1,234,567.89")
  
  // æµ‹è¯•è´§å¸æ ¼å¼åŒ–
  assert_eq(format_currency(1234.56, "en"), "$1234.56")
  assert_eq(format_currency(1234.56, "de"), "1234,56 â‚¬")
  assert_eq(format_currency(1234.56, "zh"), "Â¥1234.56")
}

// æµ‹è¯•6: æ–‡æœ¬æ–¹å‘å’ŒRTLæ”¯æŒ
test "æ–‡æœ¬æ–¹å‘å’ŒRTLæ”¯æŒ" {
  // è¯­è¨€æ–¹å‘
  let language_directions = {
    "en": "ltr",
    "zh": "ltr",
    "ar": "rtl",
    "he": "rtl",
    "fa": "rtl"
  }
  
  // è·å–æ–‡æœ¬æ–¹å‘
  let get_text_direction = fn(language) {
    if language_directions.contains(language) {
      language_directions[language]
    } else {
      "ltr" // é»˜è®¤ä»å·¦åˆ°å³
    }
  }
  
  // æ£€æŸ¥æ˜¯å¦ä¸ºRTLè¯­è¨€
  let is_rtl_language = fn(language) {
    get_text_direction(language) == "rtl"
  }
  
  // è°ƒæ•´æ–‡æœ¬å¯¹é½
  let adjust_text_align = fn(align, language) {
    if is_rtl_language(language) {
      match align {
        "left" => "right",
        "right" => "left",
        "center" => "center",
        _ => align
      }
    } else {
      align
    }
  }
  
  // æµ‹è¯•æ–‡æœ¬æ–¹å‘
  assert_eq(get_text_direction("en"), "ltr")
  assert_eq(get_text_direction("zh"), "ltr")
  assert_eq(get_text_direction("ar"), "rtl")
  assert_eq(get_text_direction("he"), "rtl")
  
  assert_false(is_rtl_language("en"))
  assert_false(is_rtl_language("zh"))
  assert_true(is_rtl_language("ar"))
  assert_true(is_rtl_language("he"))
  
  // æµ‹è¯•æ–‡æœ¬å¯¹é½è°ƒæ•´
  assert_eq(adjust_text_align("left", "en"), "left")
  assert_eq(adjust_text_align("left", "ar"), "right")
  assert_eq(adjust_text_align("right", "ar"), "left")
  assert_eq(adjust_text_align("center", "he"), "center")
}

// æµ‹è¯•7: æ—¶åŒºå¤„ç†
test "æ—¶åŒºå¤„ç†" {
  // æ—¶åŒºåç§»é‡ï¼ˆå°æ—¶ï¼‰
  let timezone_offsets = {
    "UTC": 0,
    "EST": -5,
    "PST": -8,
    "CST": 8, // ä¸­å›½æ ‡å‡†æ—¶é—´
    "JST": 9, // æ—¥æœ¬æ ‡å‡†æ—¶é—´
    "CET": 1  // ä¸­æ¬§æ—¶é—´
  }
  
  // è½¬æ¢æ—¶åŒº
  let convert_timezone = fn(timestamp, from_tz, to_tz) {
    if timezone_offsets.contains(from_tz) && timezone_offsets.contains(to_tz) {
      let from_offset = timezone_offsets[from_tz]
      let to_offset = timezone_offsets[to_tz]
      let offset_diff = to_offset - from_offset
      
      timestamp + (offset_diff * 3600) // è½¬æ¢ä¸ºç§’
    } else {
      timestamp
    }
  }
  
  // æ ¼å¼åŒ–æ—¶é—´æˆ³ä¸ºå¯è¯»æ—¶é—´
  let format_timestamp = fn(timestamp) {
    let hours = (timestamp / 3600) % 24
    let minutes = (timestamp % 3600) / 60
    let seconds = timestamp % 60
    
    hours.to_string() + ":" + 
    (if minutes < 10 { "0" } else { "" }) + minutes.to_string() + ":" +
    (if seconds < 10 { "0" } else { "" }) + seconds.to_string()
  }
  
  // æµ‹è¯•æ—¶åŒºè½¬æ¢
  let utc_time = 12 * 3600 // 12:00:00 UTC
  
  let est_time = convert_timezone(utc_time, "UTC", "EST")
  let cst_time = convert_timezone(utc_time, "UTC", "CST")
  let jst_time = convert_timezone(utc_time, "UTC", "JST")
  
  assert_eq(format_timestamp(est_time), "7:00:00") // UTC-5
  assert_eq(format_timestamp(cst_time), "20:00:00") // UTC+8
  assert_eq(format_timestamp(jst_time), "21:00:00") // UTC+9
  
  // æµ‹è¯•æ—¶åŒºä¹‹é—´è½¬æ¢
  let est_to_cst = convert_timezone(est_time, "EST", "CST")
  assert_eq(format_timestamp(est_to_cst), "20:00:00")
}

// æµ‹è¯•8: æœ¬åœ°åŒ–æ’åº
test "æœ¬åœ°åŒ–æ’åº" {
  // æœ¬åœ°åŒ–æ’åºè§„åˆ™
  let localized_sort = fn(strings, language) {
    match language {
      "zh" => {
        // ä¸­æ–‡æŒ‰æ‹¼éŸ³æ’åºï¼ˆç®€åŒ–ç‰ˆï¼‰
        strings.sort(fn(a, b) { a < b })
      }
      "de" => {
        // å¾·è¯­ç‰¹æ®Šå­—ç¬¦æ’åºï¼ˆç®€åŒ–ç‰ˆï¼‰
        strings.sort(fn(a, b) {
          // å°†Ã¤æ›¿æ¢ä¸ºaeï¼ŒÃ¶æ›¿æ¢ä¸ºoeï¼ŒÃ¼æ›¿æ¢ä¸ºue
          let normalize = fn(s) {
            s.replace("Ã¤", "ae").replace("Ã¶", "oe").replace("Ã¼", "ue")
          }
          normalize(a) < normalize(b)
        })
      }
      _ => {
        // é»˜è®¤æ’åº
        strings.sort(fn(a, b) { a < b })
      }
    }
  }
  
  // æµ‹è¯•ä¸­æ–‡æ’åº
  let chinese_names = ["å¼ ä¸‰", "æå››", "ç‹äº”", "èµµå…­"]
  let sorted_chinese = localized_sort(chinese_names, "zh")
  
  // æµ‹è¯•å¾·è¯­æ’åº
  let german_words = ["Ã¤pfel", "Ã¶fen", "Ã¼bung", "banana"]
  let sorted_german = localized_sort(german_words, "de")
  
  // æµ‹è¯•è‹±æ–‡æ’åº
  let english_words = ["apple", "banana", "cherry", "date"]
  let sorted_english = localized_sort(english_words, "en")
  
  // éªŒè¯æ’åºç»“æœ
  assert_eq(sorted_chinese.length(), 4)
  assert_eq(sorted_german.length(), 4)
  assert_eq(sorted_english.length(), 4)
  
  // è‹±æ–‡æ’åºéªŒè¯
  assert_eq(sorted_english[0], "apple")
  assert_eq(sorted_english[1], "banana")
  assert_eq(sorted_english[2], "cherry")
  assert_eq(sorted_english[3], "date")
}

// æµ‹è¯•9: è¯­è¨€å›é€€æœºåˆ¶
test "è¯­è¨€å›é€€æœºåˆ¶" {
  // æ”¯æŒçš„è¯­è¨€å±‚æ¬¡ç»“æ„
  let language_hierarchy = {
    "zh-CN": ["zh-CN", "zh", "en"],
    "zh-TW": ["zh-TW", "zh", "en"],
    "en-US": ["en-US", "en"],
    "es-ES": ["es-ES", "es", "en"],
    "fr-FR": ["fr-FR", "fr", "en"]
  }
  
  // å¯ç”¨ç¿»è¯‘
  let available_translations = ["en", "zh", "es"]
  
  // æŸ¥æ‰¾æœ€ä½³åŒ¹é…è¯­è¨€
  let find_best_language = fn(preferred) {
    if language_hierarchy.contains(preferred) {
      let hierarchy = language_hierarchy[preferred]
      
      for lang in hierarchy {
        if available_translations.contains(lang) {
          return lang
        }
      }
    }
    
    // é»˜è®¤å›é€€åˆ°è‹±è¯­
    "en"
  }
  
  // æµ‹è¯•è¯­è¨€å›é€€
  assert_eq(find_best_language("zh-CN"), "zh") // zh-CNä¸å¯ç”¨ï¼Œå›é€€åˆ°zh
  assert_eq(find_best_language("zh-TW"), "zh") // zh-TWä¸å¯ç”¨ï¼Œå›é€€åˆ°zh
  assert_eq(find_best_language("en-US"), "en") // en-USä¸å¯ç”¨ï¼Œå›é€€åˆ°en
  assert_eq(find_best_language("es-ES"), "es") // es-ESä¸å¯ç”¨ï¼Œå›é€€åˆ°es
  assert_eq(find_best_language("fr-FR"), "en") // frå’Œfr-FRéƒ½ä¸å¯ç”¨ï¼Œå›é€€åˆ°en
  assert_eq(find_best_language("ja-JP"), "en") // ä¸åœ¨å±‚æ¬¡ç»“æ„ä¸­ï¼Œå›é€€åˆ°en
}

// æµ‹è¯•10: å­—ç¬¦ç¼–ç å¤„ç†
test "å­—ç¬¦ç¼–ç å¤„ç†" {
  // ä¸åŒè¯­è¨€çš„æ–‡æœ¬æ ·æœ¬
  let text_samples = {
    "en": "Hello, World!",
    "zh": "ä½ å¥½ï¼Œä¸–ç•Œï¼",
    "ja": "ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œï¼",
    "ar": "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…!",
    "ru": "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚, Ğ¼Ğ¸Ñ€!",
    "emoji": "Hello ğŸŒğŸš€ğŸ‘‹"
  }
  
  // è®¡ç®—å­—ç¬¦é•¿åº¦ï¼ˆè€ƒè™‘Unicodeï¼‰
  let unicode_length = fn(text) {
    let mut count = 0
    let mut i = 0
    
    while i < text.length() {
      let ch = text[i]
      
      // ç®€åŒ–çš„Unicodeå­—ç¬¦é•¿åº¦è®¡ç®—
      if ch >= '\u{D800}' && ch <= '\u{DFFF}' {
        // ä»£ç†å¯¹ï¼ˆUTF-16ï¼‰
        i = i + 2
      } else {
        i = i + 1
      }
      
      count = count + 1
    }
    
    count
  }
  
  // æ£€æµ‹æ˜¯å¦åŒ…å«éASCIIå­—ç¬¦
  let has_non_ascii = fn(text) {
    for ch in text.to_char_array() {
      if ch.to_int() > 127 {
        return true
      }
    }
    false
  }
  
  // æ£€æµ‹æ˜¯å¦åŒ…å«è¡¨æƒ…ç¬¦å·
  let has_emoji = fn(text) {
    // ç®€åŒ–çš„è¡¨æƒ…ç¬¦å·æ£€æµ‹
    text.contains("ğŸŒ") || text.contains("ğŸš€") || text.contains("ğŸ‘‹") || 
    text.contains("ğŸ˜€") || text.contains("â¤ï¸")
  }
  
  // æµ‹è¯•å­—ç¬¦ç¼–ç å¤„ç†
  assert_eq(unicode_length(text_samples["en"]), 13)
  assert_eq(unicode_length(text_samples["zh"]), 6) // ä¸­æ–‡å­—ç¬¦
  assert_eq(unicode_length(text_samples["ja"]), 9) // æ—¥æ–‡å­—ç¬¦
  assert_eq(unicode_length(text_samples["ar"]), 14) // é˜¿æ‹‰ä¼¯å­—ç¬¦
  assert_eq(unicode_length(text_samples["ru"]), 12) // è¥¿é‡Œå°”å­—ç¬¦
  assert_eq(unicode_length(text_samples["emoji"]), 11) // åŒ…å«è¡¨æƒ…ç¬¦å·
  
  assert_false(has_non_ascii(text_samples["en"]))
  assert_true(has_non_ascii(text_samples["zh"]))
  assert_true(has_non_ascii(text_samples["ja"]))
  assert_true(has_non_ascii(text_samples["ar"]))
  assert_true(has_non_ascii(text_samples["ru"]))
  assert_true(has_non_ascii(text_samples["emoji"]))
  
  assert_false(has_emoji(text_samples["en"]))
  assert_false(has_emoji(text_samples["zh"]))
  assert_true(has_emoji(text_samples["emoji"]))
}