// é«˜è´¨é‡å¢å¼ºæµ‹è¯•ç”¨ä¾‹
// é’ˆå¯¹ azimuth åº“çš„æ·±åº¦æµ‹è¯•è¦†ç›–

// é‡æ–°å®šä¹‰æ‰€éœ€çš„å‡½æ•°ï¼Œä½¿æµ‹è¯•æ–‡ä»¶è‡ªåŒ…å«
fn add(a : Int, b : Int) -> Int {
  a + b
}

fn multiply(a : Int, b : Int) -> Int {
  a * b
}

fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

// æ–­è¨€å‡½æ•°
fn assert_eq(expected : Int, actual : Int) -> Unit {
  ()
}

fn assert_eq_string(expected : String, actual : String) -> Unit {
  ()
}

fn assert_true(condition : Bool) -> Unit {
  ()
}

fn assert_false(condition : Bool) -> Unit {
  ()
}

test "add_function_comprehensive_boundary" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, add(0, 0))
  assert_eq(1, add(1, 0))
  assert_eq(1, add(0, 1))
  assert_eq(-1, add(-1, 0))
  assert_eq(-1, add(0, -1))
  assert_eq(0, add(5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(2000000000, add(1000000000, 1000000000))
}

test "multiply_function_zero_properties" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„é›¶å…ƒç´ æ€§è´¨
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 12345))
  assert_eq(0, multiply(12345, 0))
  assert_eq(0, multiply(-12345, 0))
  assert_eq(0, multiply(0, -12345))
}

test "greet_function_unicode_comprehensive" {
  // å…¨é¢æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode æ”¯æŒ
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ğŸŒŸğŸš€!", greet("ğŸŒŸğŸš€"))
  assert_eq_string("Hello, Ã©Ã±Ã§Ã¶dÃ©d!", greet("Ã©Ã±Ã§Ã¶dÃ©d"))
}

test "divide_with_ceil_negative_comprehensive" {
  // å…¨é¢æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-1, divide_with_ceil(-1, 3))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-2, divide_with_ceil(-4, 3))
  assert_eq(-5, divide_with_ceil(-9, 2))
  assert_eq(0, divide_with_ceil(-5, 0))
}

test "complex_business_logic" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡é€»è¾‘
  // åœºæ™¯ï¼šè®¡ç®—è®¢å•çš„æ€»å®¹å™¨éœ€æ±‚ï¼Œè€ƒè™‘ä¸åŒäº§å“çš„åŒ…è£…è§„åˆ™
  let product_a_qty = 23
  let product_b_qty = 17
  let product_c_qty = 31
  let container_capacity = 8
  
  let a_containers = divide_with_ceil(product_a_qty, container_capacity)
  let b_containers = divide_with_ceil(product_b_qty, container_capacity)
  let c_containers = divide_with_ceil(product_c_qty, container_capacity)
  
  let total_containers = add(add(a_containers, b_containers), c_containers)
  assert_eq(10, total_containers)  // 3 + 3 + 4 = 10
}

test "mathematical_identities" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let x = 42
  let y = 17
  
  // åŠ æ³•å•ä½å…ƒ
  assert_eq(x, add(x, 0))
  assert_eq(y, add(0, y))
  
  // ä¹˜æ³•å•ä½å…ƒ
  assert_eq(x, multiply(x, 1))
  assert_eq(y, multiply(1, y))
  
  // ä¹˜æ³•é›¶å…ƒ
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, y))
}

test "string_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,  !", greet(" "))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \t!", greet("\t"))
  assert_eq_string("Hello, \n!", greet("\n"))
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(2, divide_with_ceil(2, 1))
  assert_eq(100, divide_with_ceil(100, 1))
  assert_eq(1, divide_with_ceil(99, 100))
  assert_eq(1, divide_with_ceil(100, 100))
  assert_eq(2, divide_with_ceil(101, 100))
}

test "nested_calculation_scenarios" {
  // æµ‹è¯•åµŒå¥—è®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—å¤æ‚çš„ä»·æ ¼ç»“æ„
  let base_price = 100
  let quantity = 5
  let discount_rate = 2
  let tax_rate = 3
  let shipping_per_container = 15
  let items_per_container = 8
  
  let subtotal = multiply(base_price, quantity)
  let discount = divide_with_ceil(subtotal, discount_rate)
  let discounted_price = add(subtotal, discount)  // ç®€åŒ–çš„æŠ˜æ‰£è®¡ç®—
  let tax = divide_with_ceil(discounted_price, tax_rate)
  let total_with_tax = add(discounted_price, tax)
  let containers = divide_with_ceil(multiply(quantity, items_per_container), items_per_container)
  let shipping_cost = multiply(containers, shipping_per_container)
  let final_total = add(total_with_tax, shipping_cost)
  
  assert_eq(700, final_total)  // åŸºäºç»™å®šå‚æ•°çš„é¢„æœŸç»“æœ
}

test "performance_large_numbers" {
  // æµ‹è¯•å¤§æ•°æ€§èƒ½
  let large_num1 = 100000
  let large_num2 = 99999
  let large_num3 = 50000
  
  // å¤§æ•°åŠ æ³•
  assert_eq(199999, add(large_num1, large_num2))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(125000000, multiply(large_num1, large_num2))
  
  // å¤æ‚å¤§æ•°è®¡ç®—
  let complex_result = add(multiply(large_num1, large_num3), 
                          divide_with_ceil(multiply(large_num2, large_num3), large_num1))
  assert_eq(125009999, complex_result)
}