// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›– azimuth åº“çš„ä¸»è¦åŠŸèƒ½ï¼ŒåŒ…å«è¾¹ç•Œæƒ…å†µã€ç‰¹æ®Šåœºæ™¯å’Œå®é™…åº”ç”¨

test "add_function_extreme_values" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„æå€¼æƒ…å†µ
  @azimuth.assert_eq(1000000, @azimuth.add(999999, 1))
  @azimuth.assert_eq(-1000000, @azimuth.add(-999999, -1))
  @azimuth.assert_eq(0, @azimuth.add(2147483647, -2147483647))
  @azimuth.assert_eq(1, @azimuth.add(-2147483648, 2147483649))
}

test "multiply_function_precision_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„ç²¾åº¦å’Œç‰¹æ®Šæƒ…å†µ
  @azimuth.assert_eq(1, @azimuth.multiply(1, 1))
  @azimuth.assert_eq(-1, @azimuth.multiply(1, -1))
  @azimuth.assert_eq(1, @azimuth.multiply(-1, -1))
  @azimuth.assert_eq(1000000, @azimuth.multiply(1000, 1000))
  @azimuth.assert_eq(-1000000, @azimuth.multiply(1000, -1000))
}

test "greet_function_unicode_extended" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„æ‰©å±•Unicodeå­—ç¬¦æ”¯æŒ
  @azimuth.assert_eq_string("Hello, ğŸŒ™â­!", @azimuth.greet("ğŸŒ™â­"))
  @azimuth.assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", @azimuth.greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  @azimuth.assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", @azimuth.greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  @azimuth.assert_eq_string("Hello, ğŸ•ğŸ”ğŸŸ!", @azimuth.greet("ğŸ•ğŸ”ğŸŸ"))
  @azimuth.assert_eq_string("Hello, ğ“œğ“¸ğ“¸ğ“·ğ“‘ğ“²ğ“½!", @azimuth.greet("ğ“œğ“¸ğ“¸ğ“·ğ“‘ğ“²ğ“½"))
}

test "divide_with_ceil_fractional_precision" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„åˆ†æ•°ç²¾åº¦
  @azimuth.assert_eq(100, @azimuth.divide_with_ceil(999, 10))
  @azimuth.assert_eq(50, @azimuth.divide_with_ceil(999, 20))
  @azimuth.assert_eq(34, @azimuth.divide_with_ceil(100, 3))
  @azimuth.assert_eq(67, @azimuth.divide_with_ceil(200, 3))
  @azimuth.assert_eq(4, @azimuth.divide_with_ceil(13, 4))
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚çš„è®¡ç®—ç®¡é“åœºæ™¯
  let initial_value = 100
  let step1 = @azimuth.divide_with_ceil(initial_value, 3)  // 34
  let step2 = @azimuth.multiply(step1, 2)                  // 68
  let step3 = @azimuth.add(step2, 32)                      // 100
  let step4 = @azimuth.divide_with_ceil(step3, 25)         // 4
  let final_result = @azimuth.multiply(step4, 25)          // 100
  
  @azimuth.assert_eq(100, final_result)
}

test "error_boundary_conditions" {
  // æµ‹è¯•é”™è¯¯è¾¹ç•Œæ¡ä»¶
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(100, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(-100, 0))
  @azimuth.assert_eq(0, @azimuth.multiply(0, 0))
  @azimuth.assert_eq(0, @azimuth.add(0, 0))
}

test "batch_processing_simulation" {
  // æµ‹è¯•æ‰¹é‡å¤„ç†æ¨¡æ‹Ÿåœºæ™¯
  let batch_size = 47
  let items_per_batch = 8
  let total_batches = @azimuth.divide_with_ceil(batch_size, items_per_batch)
  
  // éªŒè¯æ‰¹å¤„ç†è®¡ç®—
  @azimuth.assert_eq(6, total_batches)
  
  // è®¡ç®—æœ€åä¸€ä¸ªæ‰¹æ¬¡çš„é¡¹ç›®æ•°
  let full_batches = @azimuth.divide_with_ceil(batch_size - 1, items_per_batch)
  let last_batch_size = @azimuth.add(batch_size, @azimuth.multiply(-full_batches, items_per_batch))
  @azimuth.assert_eq(7, last_batch_size)
}

test "financial_calculation_scenario" {
  // æµ‹è¯•é‡‘èè®¡ç®—åœºæ™¯
  let product_price = 199
  let quantity = 3
  let tax_rate = 8  // 8%
  let subtotal = @azimuth.multiply(product_price, quantity)
  let tax_amount = @azimuth.divide_with_ceil(@azimuth.multiply(subtotal, tax_rate), 100)
  let total = @azimuth.add(subtotal, tax_amount)
  
  @azimuth.assert_eq(597, subtotal)
  @azimuth.assert_eq(48, tax_amount)  // ceil(597 * 8 / 100) = ceil(47.76) = 48
  @azimuth.assert_eq(645, total)
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç¼˜æƒ…å†µ
  @azimuth.assert_eq_string("Hello,   !", @azimuth.greet("  "))
  @azimuth.assert_eq_string("Hello, 
	!", @azimuth.greet("
	"))
  @azimuth.assert_eq_string("Hello, \"quoted\"!", @azimuth.greet("\"quoted\""))
  @azimuth.assert_eq_string("Hello, 'single'!", @azimuth.greet("'single'"))
  @azimuth.assert_eq_string("Hello, \\backslash!", @azimuth.greet("\\backslash"))
}