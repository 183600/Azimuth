// æ–°å¢žçš„8ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "performance_large_scale_operations" {
  // å¤§è§„æ¨¡è¿ç®—æ€§èƒ½æµ‹è¯•
  let iterations = 10000
  let sum_result = add(iterations, iterations)
  let product_result = multiply(100, iterations)
  let division_result = divide_with_ceil(product_result, 50)
  
  assert_eq(20000, sum_result)
  assert_eq(1000000, product_result)
  assert_eq(20000, division_result)
}

test "error_boundary_conditions" {
  // é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•å„ç§å¯èƒ½å¯¼è‡´é”™è¯¯çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0
  assert_eq(0, divide_with_ceil(1, 0))  // æ­£æ•°/0
  assert_eq(0, divide_with_ceil(-1, 0))  // è´Ÿæ•°/0
  assert_eq(0, divide_with_ceil(2147483647, 0))  // æœ€å¤§å€¼/0
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // æœ€å°å€¼/0
}

test "string_encoding_handling" {
  // å­—ç¬¦ä¸²ç¼–ç å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, ðŸŒ™â­!", greet("ðŸŒ™â­"))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \"quotes\"!", greet("\"quotes\""))
  assert_eq_string("Hello, 'apostrophe'!", greet("'apostrophe'"))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
}

test "complex_financial_calculations" {
  // å¤æ‚é‡‘èžè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—å¤åˆ©å’Œåˆ†æœŸä»˜æ¬¾
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  
  // éªŒè¯å¤åˆ©å¢žé•¿
  assert_eq(10500, year1_end)  // 10000 + 5%
  assert_eq(11025, year2_end)  // 10500 + 5%
  assert_eq(11576, year3_end)  // 11025 + 5%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year3_end, total_months)
  assert_eq(322, monthly_payment)  // ceil(11576/36)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†æžæµ‹è¯•
  let input_sizes = [10, 100, 1000]
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_10 = multiply(input_sizes[0], 2)
  let linear_100 = multiply(input_sizes[1], 2)
  let linear_1000 = multiply(input_sizes[2], 2)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  let log_10 = divide_with_ceil(input_sizes[0], 3)
  let log_100 = divide_with_ceil(input_sizes[1], 3)
  let log_1000 = divide_with_ceil(input_sizes[2], 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(20, linear_10)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  
  assert_eq(4, log_10)
  assert_eq(34, log_100)
  assert_eq(334, log_1000)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æž„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let stack_size_after_push = add(stack_size, 1)
  let stack_size_after_pop = subtract(stack_size_after_push, 1)
  
  assert_eq(1, stack_size_after_push)
  assert_eq(0, stack_size_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 10
  let queue_items = 7
  let remaining_capacity = subtract(queue_capacity, queue_items)
  let can_add_more = remaining_capacity > 0
  
  assert_eq(3, remaining_capacity)
  assert_true(can_add_more)
}

test "resource_utilization_optimization" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory = 16384  // GB
  let servers = 5
  let memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(3277, memory_per_server)  // ceil(16384/5)
  
  // è®¡ç®—å®žé™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, servers)
  let memory_waste = subtract(total_allocated, total_memory)
  
  assert_eq(16385, total_allocated)
  assert_eq(1, memory_waste)
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥
  let optimized_servers = add(servers, 1)
  let optimized_memory_per_server = divide_with_ceil(total_memory, optimized_servers)
  assert_eq(2341, optimized_memory_per_server)  // ceil(16384/6)
}

test "edge_case_mathematical_operations" {
  // è¾¹ç¼˜æƒ…å†µæ•°å­¦è¿ç®—æµ‹è¯•
  // æµ‹è¯•è¿žç»­è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  let initial_value = 1
  
  // è¿žç»­åŠ æ³•
  let result1 = add(add(add(initial_value, 1), 1), 1)
  assert_eq(4, result1)
  
  // è¿žç»­ä¹˜æ³•
  let result2 = multiply(multiply(multiply(initial_value, 2), 2), 2)
  assert_eq(8, result2)
  
  // æ··åˆè¿ç®—
  let result3 = divide_with_ceil(multiply(add(initial_value, 2), 3), 4)
  assert_eq(3, result3)  // ceil((1+2)*3/4) = ceil(9/4) = 3
  
  // æžå€¼è¿ç®—
  let max_int_test = add(2147483647, 0)
  let min_int_test = add(-2147483648, 0)
  
  assert_eq(2147483647, max_int_test)
  assert_eq(-2147483648, min_int_test)
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}