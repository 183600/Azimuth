// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›–æ›´å¤æ‚çš„åœºæ™¯å’Œè¾¹ç•Œæƒ…å†µ

test "large_number_precision_test" {
  // å¤§æ•°ç²¾åº¦æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„ç²¾åº¦å’Œç¨³å®šæ€§
  let large_num1 = 1000000
  let large_num2 = 999999
  
  // å¤§æ•°åŠ æ³•æµ‹è¯•
  let sum_result = add(large_num1, large_num2)
  assert_eq(1999999, sum_result)
  
  // å¤§æ•°ä¹˜æ³•æµ‹è¯•
  let product_result = multiply(1000, 1000)
  assert_eq(1000000, product_result)
  
  // å¤§æ•°é™¤æ³•æµ‹è¯•
  let division_result = divide_with_ceil(large_num1, 3)
  assert_eq(333334, division_result)  // ceil(1000000/3)
  
  // å¤æ‚å¤§æ•°è¿ç®—
  let complex_result = divide_with_ceil(
    add(multiply(large_num1, 2), multiply(large_num2, 3)),
    5
  )
  assert_eq(999999, complex_result)  // ceil((2000000 + 2999997)/5)
}

test "string_encoding_comprehensive_test" {
  // å­—ç¬¦ä¸²ç¼–ç ç»¼åˆæµ‹è¯•
  // æµ‹è¯•å„ç§ç¼–ç å’Œç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_eq_string("Hello, ğŸŒ™â­ğŸŒŸ!", greet("ğŸŒ™â­ğŸŒŸ"))
  assert_eq_string("Hello, cafÃ©_mÃ¼nchen!", greet("cafÃ©_mÃ¼nchen"))
  assert_eq_string("Hello, åŒ—äº¬_ä¸œäº¬!", greet("åŒ—äº¬_ä¸œäº¬"))
  assert_eq_string("Hello, \n\r\t\v\f!", greet("\n\r\t\v\f"))
  assert_eq_string("Hello, \"quotes\"'apostrophe'!", greet("\"quotes\"'apostrophe'"))
  assert_eq_string("Hello, \\backslash\\forward/slash!", greet("\\backslash\\forward/slash"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦!", greet("ğŸ³ï¸â€ğŸŒˆğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"))
  assert_eq_string("Hello, mathâˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚!", greet("mathâˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚"))
}

test "financial_compound_interest_test" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—å¤åˆ©æŠ•èµ„å›æŠ¥
  let principal = 50000
  let annual_rate = 8  // 8% å¹´åˆ©ç‡
  let years = 5
  let compound_frequency = 12  // æœˆå¤åˆ©
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œä½¿ç”¨æ•´æ•°è¿ç®—ï¼‰
  let monthly_rate = divide_with_ceil(annual_rate, compound_frequency)
  let total_months = multiply(years, compound_frequency)
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆé€å¹´è®¡ç®—ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  let year4_end = add(year3_end, divide_with_ceil(multiply(year3_end, annual_rate), 100))
  let year5_end = add(year4_end, divide_with_ceil(multiply(year4_end, annual_rate), 100))
  
  // éªŒè¯æ¯å¹´çš„å¢é•¿
  assert_eq(54000, year1_end)  // 50000 + 8%
  assert_eq(58320, year2_end)  // 54000 + 8%
  assert_eq(62986, year3_end)  // 58320 + 8%
  assert_eq(68025, year4_end)  // 62986 + 8%
  assert_eq(73467, year5_end)  // 68025 + 8%
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_return = subtract(year5_end, principal)
  assert_eq(23467, total_return)
  
  // è®¡ç®—æœˆä¾›ï¼ˆå¦‚æœåˆ†æœŸå¿è¿˜ï¼‰
  let monthly_payment = divide_with_ceil(year5_end, total_months)
  assert_eq(1223, monthly_payment)  // ceil(73467/60)
}

test "algorithm_complexity_simulation_test" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ç‰¹å¾
  let input_sizes = [10, 100, 1000]
  
  // æ¨¡æ‹ŸO(1)ç®—æ³• - å¸¸æ•°æ—¶é—´
  let constant_10 = 5
  let constant_100 = 5
  let constant_1000 = 5
  
  // æ¨¡æ‹ŸO(n)ç®—æ³• - çº¿æ€§æ—¶é—´
  let linear_10 = multiply(10, 3)
  let linear_100 = multiply(100, 3)
  let linear_1000 = multiply(1000, 3)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³• - å¯¹æ•°æ—¶é—´
  let log_10 = divide_with_ceil(10, 2)
  let log_100 = divide_with_ceil(100, 7)
  let log_1000 = divide_with_ceil(1000, 10)
  
  // æ¨¡æ‹ŸO(nÂ²)ç®—æ³• - å¹³æ–¹æ—¶é—´
  let quadratic_10 = multiply(10, 10)
  let quadratic_100 = multiply(100, 100)
  let quadratic_1000 = multiply(1000, 1000)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_10)
  assert_eq(5, constant_100)
  assert_eq(5, constant_1000)
  
  assert_eq(30, linear_10)
  assert_eq(300, linear_100)
  assert_eq(3000, linear_1000)
  
  assert_eq(5, log_10)
  assert_eq(15, log_100)
  assert_eq(100, log_1000)
  
  assert_eq(100, quadratic_10)
  assert_eq(10000, quadratic_100)
  assert_eq(1000000, quadratic_1000)
  
  // éªŒè¯æ•ˆç‡æ¯”ç‡
  let efficiency_linear_vs_constant_1000 = divide_with_ceil(linear_1000, constant_1000)
  let efficiency_quadratic_vs_linear_1000 = divide_with_ceil(quadratic_1000, linear_1000)
  
  assert_eq(600, efficiency_linear_vs_constant_1000)
  assert_eq(334, efficiency_quadratic_vs_linear_1000)
}

test "data_structure_simulation_test" {
  // æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿå¸¸è§æ•°æ®ç»“æ„çš„æ“ä½œ
  
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼ˆLIFOï¼‰
  let stack_size = 0
  let stack_push1 = add(stack_size, 1)  // push
  let stack_push2 = add(stack_push1, 1)  // push
  let stack_push3 = add(stack_push2, 1)  // push
  let stack_pop1 = subtract(stack_push3, 1)  // pop
  let stack_pop2 = subtract(stack_pop1, 1)  // pop
  let stack_pop3 = subtract(stack_pop2, 1)  // pop
  
  assert_eq(3, stack_push3)
  assert_eq(0, stack_pop3)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼ˆFIFOï¼‰
  let queue_capacity = 20
  let queue_items = 0
  let queue_enqueue1 = add(queue_items, 5)  // enqueue 5 items
  let queue_enqueue2 = add(queue_enqueue1, 3)  // enqueue 3 items
  let queue_dequeue1 = subtract(queue_enqueue2, 4)  // dequeue 4 items
  let queue_remaining = subtract(queue_capacity, queue_dequeue1)
  
  assert_eq(8, queue_enqueue2)
  assert_eq(4, queue_dequeue1)
  assert_eq(16, queue_remaining)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨è´Ÿè½½å› å­
  let hash_table_capacity = 16
  let hash_table_items = 12
  let load_factor = multiply(divide_with_ceil(multiply(hash_table_items, 100), hash_table_capacity), 1)
  assert_eq(75, load_factor)  // ceil(12/16 * 100) = 75%
  
  // æ¨¡æ‹Ÿæ ‘çš„é«˜åº¦è®¡ç®—
  let tree_nodes = 31
  let tree_height = divide_with_ceil(tree_nodes, 8)
  assert_eq(4, tree_height)  // è¿‘ä¼¼å®Œå…¨äºŒå‰æ ‘é«˜åº¦
}

test "resource_utilization_optimization_test" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šäº‘è®¡ç®—èµ„æºåˆ†é…ä¼˜åŒ–
  
  // åœºæ™¯1ï¼šè™šæ‹ŸæœºCPUåˆ†é…
  let total_cpu_cores = 64
  let vm_instances = 9
  let cpu_per_vm = divide_with_ceil(total_cpu_cores, vm_instances)
  assert_eq(8, cpu_per_vm)  // ceil(64/9) = 8
  
  let total_allocated_cpu = multiply(cpu_per_vm, vm_instances)
  let cpu_waste = subtract(total_allocated_cpu, total_cpu_cores)
  assert_eq(8, cpu_waste)
  
  // åœºæ™¯2ï¼šå†…å­˜åˆ†é…ä¼˜åŒ–
  let total_memory_gb = 256
  let memory_per_vm = 32
  let max_vms_by_memory = divide_with_ceil(total_memory_gb, memory_per_vm)
  assert_eq(8, max_vms_by_memory)
  
  // åœºæ™¯3ï¼šå­˜å‚¨ç©ºé—´åˆ†é…
  let total_storage_tb = 100
  let storage_per_vm = 15
  let vms_by_storage = divide_with_ceil(total_storage_tb, storage_per_vm)
  assert_eq(7, vms_by_storage)
  
  // ç»¼åˆçº¦æŸï¼šå–æœ€å°å€¼
  let optimal_vm_count = vm_instances
  if max_vms_by_memory < optimal_vm_count {
    optimal_vm_count = max_vms_by_memory
  }
  if vms_by_storage < optimal_vm_count {
    optimal_vm_count = vms_by_storage
  }
  assert_eq(7, optimal_vm_count)
  
  // è®¡ç®—èµ„æºåˆ©ç”¨ç‡
  let actual_cpu_usage = multiply(optimal_vm_count, cpu_per_vm)
  let cpu_utilization = divide_with_ceil(multiply(actual_cpu_usage, 100), total_cpu_cores)
  assert_eq(88, cpu_utilization)  // ceil(7*8/64 * 100) = 88%
}

test "mathematical_edge_cases_test" {
  // æ•°å­¦è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§æ•°å­¦è¿ç®—çš„è¾¹ç¼˜æƒ…å†µ
  
  // è¿ç»­è¿ç®—çš„ç´¯ç§¯è¯¯å·®æµ‹è¯•
  let initial_value = 1
  let iterations = 10
  
  // è¿ç»­åŠ æ³•
  let sum_result = initial_value
  let i = 1
  while i <= iterations {
    sum_result = add(sum_result, 1)
    i = i + 1
  }
  assert_eq(11, sum_result)
  
  // è¿ç»­ä¹˜æ³•ï¼ˆæŒ‡æ•°å¢é•¿ï¼‰
  let product_result = 1
  let j = 1
  while j <= 5 {
    product_result = multiply(product_result, 2)
    j = j + 1
  }
  assert_eq(32, product_result)  // 2^5 = 32
  
  // æ··åˆè¿ç®—çš„ä¼˜å…ˆçº§æµ‹è¯•
  let complex1 = add(multiply(2, 3), multiply(4, 5))  // 2*3 + 4*5 = 6 + 20 = 26
  let complex2 = multiply(add(2, 3), add(4, 5))      // (2+3)*(4+5) = 5*9 = 45
  let complex3 = divide_with_ceil(multiply(7, 3), 4)  // ceil(7*3/4) = ceil(21/4) = 6
  
  assert_eq(26, complex1)
  assert_eq(45, complex2)
  assert_eq(6, complex3)
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  let boundary1 = divide_with_ceil(1, 1000)
  let boundary2 = divide_with_ceil(1000, 1)
  let boundary3 = divide_with_ceil(999, 1000)
  let boundary4 = divide_with_ceil(1001, 1000)
  
  assert_eq(1, boundary1)
  assert_eq(1000, boundary2)
  assert_eq(1, boundary3)
  assert_eq(2, boundary4)
}

test "internationalization_localization_test" {
  // å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•
  // æµ‹è¯•ä¸åŒè¯­è¨€å’Œåœ°åŒºçš„å­—ç¬¦ä¸²å¤„ç†
  
  // äºšæ´²è¯­è¨€æµ‹è¯•
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ!", greet("æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ"))
  assert_eq_string("Hello, í•œêµ­ì–´í…ŒìŠ¤íŠ¸!", greet("í•œêµ­ì–´í…ŒìŠ¤íŠ¸"))
  assert_eq_string("Hello, tiáº¿ng Viá»‡t!", greet("tiáº¿ng Viá»‡t"))
  assert_eq_string("Hello, à¹„à¸—à¸¢à¹€à¸—à¸ª!", greet("à¹„à¸—à¸¢à¹€à¸—à¸ª"))
  
  // æ¬§æ´²è¯­è¨€æµ‹è¯•
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, FranÃ§ais!", greet("FranÃ§ais"))
  assert_eq_string("Hello, Deutsch!", greet("Deutsch"))
  assert_eq_string("Hello, Italiano!", greet("Italiano"))
  assert_eq_string("Hello, PortuguÃªs!", greet("PortuguÃªs"))
  assert_eq_string("Hello, Ğ ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ğ ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, Polski!", greet("Polski"))
  assert_eq_string("Hello, ÄŒeÅ¡tina!", greet("ÄŒeÅ¡tina"))
  
  // ä¸­ä¸œè¯­è¨€æµ‹è¯•
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
  assert_eq_string("Hello, ÙØ§Ø±Ø³ÛŒ!", greet("ÙØ§Ø±Ø³ÛŒ"))
  
  // ç‰¹æ®Šç¬¦å·å’Œè¡¨æƒ…ç¬¦å·æµ‹è¯•
  assert_eq_string("Hello, ğŸ‰ğŸŠğŸˆ!", greet("ğŸ‰ğŸŠğŸˆ"))
  assert_eq_string("Hello, â¤ï¸ğŸ’™ğŸ’šğŸ’›ğŸ’œ!", greet("â¤ï¸ğŸ’™ğŸ’šğŸ’›ğŸ’œ"))
  assert_eq_string("Hello, ğŸğŸŠğŸ‹ğŸŒğŸ‰!", greet("ğŸğŸŠğŸ‹ğŸŒğŸ‰"))
  assert_eq_string("Hello, âš¡ğŸ”¥ğŸ’§ğŸŒ!", greet("âš¡ğŸ”¥ğŸ’§ğŸŒ"))
  
  // æ•°å­—å’Œç¬¦å·æ··åˆæµ‹è¯•
  assert_eq_string("Hello, Test123!", greet("Test123"))
  assert_eq_string("Hello, 2024å¹´!", greet("2024å¹´"))
  assert_eq_string("Hello, v1.0.0!", greet("v1.0.0"))
  assert_eq_string("Hello, C++/Java/Python!", greet("C++/Java/Python"))
}

test "performance_stress_test" {
  // æ€§èƒ½å‹åŠ›æµ‹è¯•
  // æµ‹è¯•å¤§é‡æ•°æ®å¤„ç†çš„æ€§èƒ½ç‰¹å¾
  
  // å¤§é‡åŠ æ³•æ“ä½œæ¨¡æ‹Ÿ
  let batch_size = 10000
  let batch_sum = 0
  let k = 1
  while k <= 10 {
    batch_sum = add(batch_sum, batch_size)
    k = k + 1
  }
  assert_eq(100000, batch_sum)
  
  // å¤§é‡ä¹˜æ³•æ“ä½œæ¨¡æ‹Ÿ
  let multiplication_base = 2
  let multiplication_result = 1
  let m = 1
  while m <= 15 {
    multiplication_result = multiply(multiplication_result, multiplication_base)
    m = m + 1
  }
  assert_eq(32768, multiplication_result)  // 2^15 = 32768
  
  // å¤æ‚è¿ç®—é“¾æµ‹è¯•
  let chain_result = 1
  let n = 1
  while n <= 100 {
    chain_result = add(chain_result, divide_with_ceil(multiply(n, 2), 3))
    n = n + 1
  }
  assert_eq(3434, chain_result)
  
  // å†…å­˜åˆ†é…æ¨¡æ‹Ÿï¼ˆä½¿ç”¨è®¡æ•°å™¨ï¼‰
  let memory_allocations = 0
  let p = 1
  while p <= 1000 {
    memory_allocations = add(memory_allocations, 1)
    p = p + 1
  }
  assert_eq(1000, memory_allocations)
  
  // æ‰¹é‡å¤„ç†æ¨¡æ‹Ÿ
  let total_items = 50000
  let batch_size_2 = 100
  let number_of_batches = divide_with_ceil(total_items, batch_size_2)
  assert_eq(500, number_of_batches)
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´ï¼ˆæ¨¡æ‹Ÿï¼‰
  let time_per_batch = 5  // æ¯æ‰¹5æ¯«ç§’
  let total_time = multiply(number_of_batches, time_per_batch)
  assert_eq(2500, total_time)
}

test "comprehensive_business_workflow_test" {
  // ç»¼åˆä¸šåŠ¡æµç¨‹æµ‹è¯•
  // æ¨¡æ‹Ÿå®Œæ•´çš„ä¸šåŠ¡æµç¨‹ï¼šä»è®¢å•åˆ°äº¤ä»˜
  
  // é˜¶æ®µ1ï¼šè®¢å•å¤„ç†
  let customer_orders = [120, 85, 200, 45, 180]
  let order1 = 120
  let order2 = 85
  let order3 = 200
  let order4 = 45
  let order5 = 180
  
  let total_orders = add(add(add(add(order1, order2), order3), order4), order5)
  assert_eq(630, total_orders)
  
  // é˜¶æ®µ2ï¼šåº“å­˜æ£€æŸ¥å’Œåˆ†é…
  let warehouse_capacity = 1000
  let available_inventory = 750
  let backorder_quantity = subtract(total_orders, available_inventory)
  
  if backorder_quantity > 0 {
    // éœ€è¦è¡¥å……åº“å­˜
    let supplier_batch_size = 500
    let batches_needed = divide_with_ceil(backorder_quantity, supplier_batch_size)
    assert_eq(1, batches_needed)  // ceil(630-750)/500 = ceil(-120/500) = 1 (å¤„ç†ä¸ºæ­£æ•°)
  } else {
    // åº“å­˜å……è¶³
    assert_eq(1, 1)
  }
  
  // é˜¶æ®µ3ï¼šç”Ÿäº§è®¡åˆ’
  let production_capacity_per_day = 50
  let days_needed = divide_with_ceil(total_orders, production_capacity_per_day)
  assert_eq(13, days_needed)  // ceil(630/50) = 13
  
  // é˜¶æ®µ4ï¼šè´¨é‡æ§åˆ¶
  let quality_check_rate = 5  // 5% è´¨æ£€ç‡
  let items_to_check = divide_with_ceil(multiply(total_orders, quality_check_rate), 100)
  assert_eq(32, items_to_check)  // ceil(630*5/100) = ceil(3150/100) = 32
  
  // é˜¶æ®µ5ï¼šåŒ…è£…å’Œè¿è¾“
  let items_per_box = 25
  let boxes_needed = divide_with_ceil(total_orders, items_per_box)
  assert_eq(26, boxes_needed)  // ceil(630/25) = 26
  
  let cost_per_box = 3
  let total_packaging_cost = multiply(boxes_needed, cost_per_box)
  assert_eq(78, total_packaging_cost)
  
  // é˜¶æ®µ6ï¼šè¿è¾“å®‰æ’
  let boxes_per_truck = 10
  let trucks_needed = divide_with_ceil(boxes_needed, boxes_per_truck)
  assert_eq(3, trucks_needed)  // ceil(26/10) = 3
  
  let cost_per_truck = 150
  let total_shipping_cost = multiply(trucks_needed, cost_per_truck)
  assert_eq(450, total_shipping_cost)
  
  // é˜¶æ®µ7ï¼šæœ€ç»ˆæˆæœ¬è®¡ç®—
  let production_cost_per_item = 2
  let total_production_cost = multiply(total_orders, production_cost_per_item)
  let total_cost = add(add(total_production_cost, total_packaging_cost), total_shipping_cost)
  
  assert_eq(1260, total_production_cost)  // 630 * 2
  assert_eq(1788, total_cost)  // 1260 + 78 + 450
  
  // é˜¶æ®µ8ï¼šäº¤ä»˜æ—¶é—´é¢„ä¼°
  let production_days = days_needed
  let packaging_days = 2
  let shipping_days = 3
  let total_delivery_days = add(production_days, add(packaging_days, shipping_days))
  assert_eq(18, total_delivery_days)  // 13 + 2 + 3
  
  // é˜¶æ®µ9ï¼šå®¢æˆ·æ»¡æ„åº¦æŒ‡æ ‡
  let on_time_delivery_target = 95
  let actual_on_time_rate = 98
  let satisfaction_score = divide_with_ceil(multiply(actual_on_time_rate, 100), on_time_delivery_target)
  assert_eq(104, satisfaction_score)  // ceil(98*100/95) = 104
  
  // éªŒè¯æ•´ä¸ªæµç¨‹çš„åˆç†æ€§
  assert_eq(1, if (total_delivery_days <= 30) { 1 } else { 0 })  // äº¤ä»˜æ—¶é—´ä¸è¶…è¿‡30å¤©
  assert_eq(1, if (total_cost < multiply(total_orders, 5)) { 1 } else { 0 })  // å•ä½æˆæœ¬ä¸è¶…è¿‡5å…ƒ
  assert_eq(1, if (satisfaction_score >= 100) { 1 } else { 0 })  // å®¢æˆ·æ»¡æ„åº¦è¾¾æ ‡
}