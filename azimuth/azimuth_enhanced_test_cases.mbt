// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•ï¼Œè¦†ç›–æ›´å¤šè¾¹ç•Œæƒ…å†µå’ŒåŠŸèƒ½ç»„åˆ

test "divide_with_ceil_basic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„åŸºæœ¬åŠŸèƒ½
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(10, 3))
  @azimuth.assert_eq(4, @azimuth.divide_with_ceil(11, 3))
  @azimuth.assert_eq(2, @azimuth.divide_with_ceil(6, 3))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(2, 5))
}

test "divide_with_ceil_negative_numbers" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿæ•°å¤„ç†
  @azimuth.assert_eq(-3, @azimuth.divide_with_ceil(-10, 3))
  @azimuth.assert_eq(-3, @azimuth.divide_with_ceil(-11, 3))
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(-6, 3))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(-2, 5))
}

test "add_large_numbers" {
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let large_num = 1000000
  @azimuth.assert_eq(2000000, @azimuth.add(large_num, large_num))
  @azimuth.assert_eq(1001000, @azimuth.add(large_num, 1000))
  @azimuth.assert_eq(0, @azimuth.add(large_num, -large_num))
}

test "multiply_large_numbers" {
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  let large_num = 10000
  @azimuth.assert_eq(100000000, @azimuth.multiply(large_num, large_num))
  @azimuth.assert_eq(-100000000, @azimuth.multiply(large_num, -large_num))
  @azimuth.assert_eq(0, @azimuth.multiply(large_num, 0))
}

test "add_sequence_operations" {
  // æµ‹è¯•åŠ æ³•çš„åºåˆ—è¿ç®—
  let result = @azimuth.add(@azimuth.add(1, 2), @azimuth.add(3, 4))
  @azimuth.assert_eq(10, result)
  
  let result2 = @azimuth.add(@azimuth.add(-5, 10), @azimuth.add(-3, 8))
  @azimuth.assert_eq(10, result2)
}

test "multiply_sequence_operations" {
  // æµ‹è¯•ä¹˜æ³•çš„åºåˆ—è¿ç®—
  let result = @azimuth.multiply(@azimuth.multiply(2, 3), @azimuth.multiply(4, 5))
  @azimuth.assert_eq(120, result)
  
  let result2 = @azimuth.multiply(@azimuth.multiply(-2, 3), @azimuth.multiply(4, -5))
  @azimuth.assert_eq(120, result2)
}

test "mixed_operations" {
  // æµ‹è¯•æ··åˆè¿ç®—
  let a = 10
  let b = 20
  let c = 30
  
  // (a + b) * c
  let sum = @azimuth.add(a, b)
  let result = @azimuth.multiply(sum, c)
  @azimuth.assert_eq(900, result)
  
  // a * b + c
  let product = @azimuth.multiply(a, b)
  let result2 = @azimuth.add(product, c)
  @azimuth.assert_eq(230, result2)
}

test "greet_unicode_characters" {
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„é—®å€™
  @azimuth.assert_eq_string("Hello, ä¸–ç•Œ!", @azimuth.greet("ä¸–ç•Œ"))
  @azimuth.assert_eq_string("Hello, ğŸš€!", @azimuth.greet("ğŸš€"))
  @azimuth.assert_eq_string("Hello, cafÃ©!", @azimuth.greet("cafÃ©"))
}

test "edge_case_min_max_operations" {
  // æµ‹è¯•æœ€å°å€¼å’Œæœ€å¤§å€¼çš„è¿ç®—
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸-1çš„åŠ æ³•
  @azimuth.assert_eq(max_val - 1, @azimuth.add(max_val, -1))
  
  // æœ€å°å€¼ä¸1çš„åŠ æ³•
  @azimuth.assert_eq(min_val + 1, @azimuth.add(min_val, 1))
  
  // æœ€å¤§å€¼ä¸1çš„ä¹˜æ³•
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, 1))
  
  // æœ€å°å€¼ä¸1çš„ä¹˜æ³•
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, 1))
}

test "complex_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯
  // è®¡ç®— (10 * 20) + (30 * 40) - (50 / 10) çš„å‘ä¸Šå–æ•´
  let product1 = @azimuth.multiply(10, 20)  // 200
  let product2 = @azimuth.multiply(30, 40)  // 1200
  let sum = @azimuth.add(product1, product2)  // 1400
  let division = @azimuth.divide_with_ceil(50, 10)  // 5
  let final_result = @azimuth.add(sum, -division)  // 1395
  
  @azimuth.assert_eq(1395, final_result)
}