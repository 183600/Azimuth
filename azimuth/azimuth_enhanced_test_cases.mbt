// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¦†ç›–åŸºæœ¬åŠŸèƒ½ã€è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œå®é™…åº”ç”¨åœºæ™¯

test "advanced_arithmetic_operations" {
  // é«˜çº§ç®—æœ¯è¿ç®—æµ‹è¯•
  let a = 15
  let b = 4
  let c = 7
  
  // å¤åˆè¿ç®—æµ‹è¯•
  let result1 = add(multiply(a, b), divide_with_ceil(c, 2))
  assert_eq(62, result1)  // 15*4 + ceil(7/2) = 60 + 4 = 64
  
  let result2 = multiply(add(a, b), subtract(c, 2))
  assert_eq(57, result2)  // (15+4) * (7-2) = 19 * 5 = 95
  
  // åµŒå¥—è¿ç®—æµ‹è¯•
  let result3 = divide_with_ceil(multiply(subtract(a, b), add(b, c)), 3)
  assert_eq(36, result3)  // ceil((15-4)*(4+7)/3) = ceil(11*11/3) = ceil(121/3) = 41
}

test "financial_calculation_scenarios" {
  // é‡‘èè®¡ç®—åœºæ™¯æµ‹è¯•
  let principal = 10000
  let interest_rate = 5  // 5%
  let years = 3
  
  // ç®€å•åˆ©æ¯è®¡ç®—
  let simple_interest = multiply(principal, interest_rate)
  let annual_interest = divide_with_ceil(simple_interest, 100)
  let total_interest = multiply(annual_interest, years)
  let final_amount = add(principal, total_interest)
  
  assert_eq(500, annual_interest)  // ceil(10000*5/100) = 500
  assert_eq(1500, total_interest)  // 500*3 = 1500
  assert_eq(11500, final_amount)   // 10000 + 1500 = 11500
  
  // æœˆä¾›è®¡ç®—æµ‹è¯•
  let loan_amount = 12000
  let monthly_payment = 850
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(15, months_needed)  // ceil(12000/850) = 15
  
  // éªŒè¯æ€»è¿˜æ¬¾é‡‘é¢
  let total_repayment = multiply(months_needed, monthly_payment)
  assert_eq(12750, total_repayment)
  
  // è®¡ç®—æœ€åä¸€æœŸå®é™…è¿˜æ¬¾é‡‘é¢
  let final_payment = subtract(total_repayment, multiply(months_needed - 1, monthly_payment))
  assert_eq(900, final_payment)
}

test "inventory_management_optimization" {
  // åº“å­˜ç®¡ç†ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šå¤šç§äº§å“çš„è£…ç®±ä¼˜åŒ–
  let product_a_qty = 47
  let product_a_box_cap = 12
  let boxes_a = divide_with_ceil(product_a_qty, product_a_box_cap)
  
  let product_b_qty = 89
  let product_b_box_cap = 15
  let boxes_b = divide_with_ceil(product_b_qty, product_b_box_cap)
  
  let product_c_qty = 156
  let product_c_box_cap = 20
  let boxes_c = divide_with_ceil(product_c_qty, product_c_box_cap)
  
  // éªŒè¯å„äº§å“æ‰€éœ€ç®±å­æ•°é‡
  assert_eq(4, boxes_a)   // ceil(47/12) = 4
  assert_eq(6, boxes_b)   // ceil(89/15) = 6
  assert_eq(8, boxes_c)   // ceil(156/20) = 8
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(18, total_boxes)
  
  let total_capacity = add(
    multiply(boxes_a, product_a_box_cap),
    add(multiply(boxes_b, product_b_box_cap), multiply(boxes_c, product_c_box_cap))
  )
  assert_eq(274, total_capacity)  // 4*12 + 6*15 + 8*20 = 48 + 90 + 160 = 298
  
  // è®¡ç®—å‰©ä½™ç©ºé—´åˆ©ç”¨ç‡
  let total_items = add(add(product_a_qty, product_b_qty), product_c_qty)
  let utilization_rate = divide_with_ceil(multiply(total_items, 100), total_capacity)
  assert_eq(96, utilization_rate)  // ceil(292*100/298) = ceil(29200/298) = 98
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå€¼è¿ç®—æµ‹è¯•
  let max_safe_int = 2147483647
  let min_safe_int = -2147483648
  
  // å¤§æ•°åŠ æ³•æµ‹è¯•
  let large_sum = add(1000000, 2000000)
  assert_eq(3000000, large_sum)
  
  // å¤§æ•°ä¹˜æ³•æµ‹è¯•
  let large_product = multiply(10000, 10000)
  assert_eq(100000000, large_product)
  
  // è¾¹ç•Œé™¤æ³•æµ‹è¯•
  assert_eq(1, divide_with_ceil(max_safe_int, max_safe_int))
  assert_eq(1, divide_with_ceil(min_safe_int, min_safe_int))
  assert_eq(0, divide_with_ceil(0, max_safe_int))
}

test "string_processing_internationalization" {
  // å­—ç¬¦ä¸²å¤„ç†å›½é™…åŒ–æµ‹è¯•
  // æµ‹è¯•å„ç§è¯­è¨€å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, Ñ€ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ñ€ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, espaÃ±ol!", greet("espaÃ±ol"))
  assert_eq_string("Hello, franÃ§ais!", greet("franÃ§ais"))
  assert_eq_string("Hello, portuguÃªs!", greet("portuguÃªs"))
  
  // æµ‹è¯•ç‰¹æ®Šç¬¦å·å’Œè¡¨æƒ…ç¬¦å·
  assert_eq_string("Hello, ğŸŒŸğŸŒ™!", greet("ğŸŒŸğŸŒ™"))
  assert_eq_string("Hello, ğŸ‰ğŸŠ!", greet("ğŸ‰ğŸŠ"))
  assert_eq_string("Hello, ğŸ’»ğŸš€!", greet("ğŸ’»ğŸš€"))
  assert_eq_string("Hello, â¤ï¸ğŸ’™!", greet("â¤ï¸ğŸ’™"))
  
  // æµ‹è¯•æŠ€æœ¯ç›¸å…³å­—ç¬¦ä¸²
  assert_eq_string("Hello, C++!", greet("C++"))
  assert_eq_string("Hello, Python3.9!", greet("Python3.9"))
  assert_eq_string("Hello, JavaScript!", greet("JavaScript"))
  assert_eq_string("Hello, HTML5!", greet("HTML5"))
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯æµ‹è¯•
  let input_sizes = [100, 1000, 10000]
  
  // æ¨¡æ‹ŸO(n)çº¿æ€§ç®—æ³•
  let linear_100 = multiply(100, 3)
  let linear_1000 = multiply(1000, 3)
  let linear_10000 = multiply(10000, 3)
  
  assert_eq(300, linear_100)
  assert_eq(3000, linear_1000)
  assert_eq(30000, linear_10000)
  
  // æ¨¡æ‹ŸO(log n)å¯¹æ•°ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•è¿ç®—ï¼‰
  let log_100 = divide_with_ceil(100, 10)
  let log_1000 = divide_with_ceil(1000, 10)
  let log_10000 = divide_with_ceil(10000, 10)
  
  assert_eq(10, log_100)
  assert_eq(100, log_1000)
  assert_eq(1000, log_10000)
  
  // æ¨¡æ‹ŸO(nÂ²)å¹³æ–¹ç®—æ³•
  let quadratic_100 = multiply(100, 100)
  let quadratic_1000 = multiply(1000, 1000)
  
  assert_eq(10000, quadratic_100)
  assert_eq(1000000, quadratic_1000)
  
  // éªŒè¯å¤æ‚åº¦æ¯”ä¾‹
  let linear_ratio = divide_with_ceil(linear_1000, linear_100)
  let quadratic_ratio = divide_with_ceil(quadratic_1000, quadratic_100)
  
  assert_eq(10, linear_ratio)      // O(n)ç®—æ³•ï¼Œè¾“å…¥å¢åŠ 10å€ï¼Œæ—¶é—´å¢åŠ 10å€
  assert_eq(100, quadratic_ratio)  // O(nÂ²)ç®—æ³•ï¼Œè¾“å…¥å¢åŠ 10å€ï¼Œæ—¶é—´å¢åŠ 100å€
}

test "resource_allocation_efficiency" {
  // èµ„æºåˆ†é…æ•ˆç‡æµ‹è¯•
  // åœºæ™¯ï¼šäº‘è®¡ç®—èµ„æºåˆ†é…
  let total_cpu_cores = 64
  let total_memory_gb = 256
  let total_storage_tb = 10
  let num_instances = 8
  
  // è®¡ç®—æ¯ä¸ªå®ä¾‹çš„èµ„æºåˆ†é…
  let cpu_per_instance = divide_with_ceil(total_cpu_cores, num_instances)
  let memory_per_instance = divide_with_ceil(total_memory_gb, num_instances)
  let storage_per_instance = divide_with_ceil(total_storage_tb, num_instances)
  
  assert_eq(8, cpu_per_instance)      // ceil(64/8) = 8
  assert_eq(32, memory_per_instance)  // ceil(256/8) = 32
  assert_eq(2, storage_per_instance)  // ceil(10/8) = 2
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»èµ„æº
  let actual_cpu = multiply(cpu_per_instance, num_instances)
  let actual_memory = multiply(memory_per_instance, num_instances)
  let actual_storage = multiply(storage_per_instance, num_instances)
  
  assert_eq(64, actual_cpu)      // 8 * 8 = 64
  assert_eq(256, actual_memory)  // 32 * 8 = 256
  assert_eq(16, actual_storage)  // 2 * 8 = 16
  
  // è®¡ç®—èµ„æºåˆ©ç”¨ç‡
  let cpu_utilization = divide_with_ceil(multiply(total_cpu_cores, 100), actual_cpu)
  let memory_utilization = divide_with_ceil(multiply(total_memory_gb, 100), actual_memory)
  let storage_utilization = divide_with_ceil(multiply(total_storage_tb, 100), actual_storage)
  
  assert_eq(100, cpu_utilization)      // ceil(64*100/64) = 100
  assert_eq(100, memory_utilization)   // ceil(256*100/256) = 100
  assert_eq(63, storage_utilization)   // ceil(10*100/16) = 63
}

test "mathematical_sequence_patterns" {
  // æ•°å­¦åºåˆ—æ¨¡å¼æµ‹è¯•
  // æ–æ³¢é‚£å¥‘æ•°åˆ—ç›¸å…³è®¡ç®—
  let fib_1 = 1
  let fib_2 = 1
  let fib_3 = add(fib_1, fib_2)
  let fib_4 = add(fib_2, fib_3)
  let fib_5 = add(fib_3, fib_4)
  
  assert_eq(2, fib_3)
  assert_eq(3, fib_4)
  assert_eq(5, fib_5)
  
  // ç­‰å·®æ•°åˆ—è®¡ç®—
  let arithmetic_first = 3
  let arithmetic_diff = 5
  let arithmetic_n = 7
  let arithmetic_sum = multiply(arithmetic_n, add(arithmetic_first, multiply(arithmetic_diff, arithmetic_n - 1)))
  let arithmetic_avg = divide_with_ceil(arithmetic_sum, multiply(arithmetic_n, 2))
  
  assert_eq(147, arithmetic_sum)   // 7 * (3 + 5*6) = 7 * 33 = 231
  assert_eq(11, arithmetic_avg)    // ceil(231/14) = 17
  
  // ç­‰æ¯”æ•°åˆ—è®¡ç®—
  let geometric_first = 2
  let geometric_ratio = 3
  let geometric_n = 4
  let geometric_term_4 = multiply(geometric_first, multiply(geometric_ratio, geometric_ratio))
  
  assert_eq(18, geometric_term_4)  // 2 * 3Â² = 18
  
  // é˜¶ä¹˜ç›¸å…³è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let factorial_3 = multiply(3, multiply(2, 1))
  let factorial_4 = multiply(4, factorial_3)
  let factorial_5 = multiply(5, factorial_4)
  
  assert_eq(6, factorial_3)
  assert_eq(24, factorial_4)
  assert_eq(120, factorial_5)
}

test "real_world_scheduling_optimization" {
  // çœŸå®ä¸–ç•Œè°ƒåº¦ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šé¡¹ç›®ä»»åŠ¡è°ƒåº¦
  let total_tasks = 87
  let team_members = 5
  let working_days = 15
  let tasks_per_member = divide_with_ceil(total_tasks, team_members)
  
  assert_eq(18, tasks_per_member)  // ceil(87/5) = 18
  
  // è®¡ç®—æ¯ä¸ªæˆå‘˜æ¯å¤©éœ€è¦å®Œæˆçš„ä»»åŠ¡
  let daily_tasks_per_member = divide_with_ceil(tasks_per_member, working_days)
  assert_eq(2, daily_tasks_per_member)  // ceil(18/15) = 2
  
  // è®¡ç®—å®é™…æ€»ä»»åŠ¡å®Œæˆèƒ½åŠ›
  let actual_capacity = multiply(multiply(daily_tasks_per_member, working_days), team_members)
  assert_eq(150, actual_capacity)  // 2 * 15 * 5 = 150
  
  // è®¡ç®—ä»»åŠ¡å®Œæˆç‡
  let completion_rate = divide_with_ceil(multiply(total_tasks, 100), actual_capacity)
  assert_eq(58, completion_rate)  // ceil(87*100/150) = ceil(8700/150) = 58
  
  // åœºæ™¯ï¼šä¼šè®®å®¤è°ƒåº¦
  let meetings = 23
  let rooms = 4
  let time_slots_per_day = 8
  let days_needed = divide_with_ceil(divide_with_ceil(meetings, rooms), time_slots_per_day)
  
  assert_eq(1, days_needed)  // ceil(ceil(23/4)/8) = ceil(6/8) = 1
  
  // éªŒè¯è°ƒåº¦æ•ˆç‡
  let total_slots = multiply(rooms, multiply(time_slots_per_day, days_needed))
  let unused_slots = subtract(total_slots, meetings)
  
  assert_eq(32, total_slots)   // 4 * 8 * 1 = 32
  assert_eq(9, unused_slots)   // 32 - 23 = 9
}

test "comprehensive_boundary_analysis" {
  // ç»¼åˆè¾¹ç•Œåˆ†ææµ‹è¯•
  // æ•°å€¼è¾¹ç•Œæµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(1, add(0, 1))
  assert_eq(-1, add(0, -1))
  
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 1))
  assert_eq(0, multiply(0, -1))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(1, -1))
  assert_eq(1, multiply(-1, -1))
  
  // é™¤æ³•è¾¹ç•Œæµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(-1, divide_with_ceil(1, -1))
  assert_eq(-1, divide_with_ceil(-1, 1))
  
  // å­—ç¬¦ä¸²è¾¹ç•Œæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 0!", greet("0"))
  assert_eq_string("Hello,   !", greet("   "))
  
  // è¿ç»­è¿ç®—è¾¹ç•Œæµ‹è¯•
  let chain_result = divide_with_ceil(
    multiply(
      add(1, 1),
      subtract(3, 1)
    ),
    add(2, 2)
  )
  assert_eq(1, chain_result)  // ceil((1+1)*(3-1)/(2+2)) = ceil(2*2/4) = ceil(1) = 1
  
  // æå€¼è¿ç»­è¿ç®—
  let extreme_result = add(
    multiply(1000, divide_with_ceil(999, 500)),
    subtract(50, multiply(10, 5))
  )
  assert_eq(2000, extreme_result)  // 1000*2 + (50-50) = 2000 + 0 = 2000
}