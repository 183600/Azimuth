// Internationalization and Unicode Support Test Suite
// Testing comprehensive i18n features and Unicode handling

test "unicode_string_handling_in_attributes" {
  let attrs = Attributes::new()
  
  # Test with various Unicode scripts
  let unicode_values = [
    ("chinese.simple", StringValue("ä¸­æ–‡æµ‹è¯•")),
    ("chinese.traditional", StringValue("ç¹é«”ä¸­æ–‡æ¸¬è©¦")),
    ("japanese.hiragana", StringValue("ã²ã‚‰ãŒãª")),
    ("japanese.katakana", StringValue("ã‚«ã‚¿ã‚«ãƒŠ")),
    ("japanese.kanji", StringValue("æ¼¢å­—")),
    ("korean.hangul", StringValue("í•œê¸€")),
    ("arabic", StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ")),
    ("hebrew", StringValue("×‘×“×™×§×” ×¢×‘×¨×™×ª")),
    ("russian", StringValue("Ñ€ÑƒÑÑÐºÐ¸Ð¹ Ñ‚ÐµÑÑ‚")),
    ("thai", StringValue("à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢")),
    ("hindi", StringValue("à¤¹à¤¿à¤‚à¤¦à¥€ à¤ªà¤°à¥€à¤•à¥à¤·à¤£")),
    ("tamil", StringValue("à®¤à®®à®¿à®´à¯ à®šà¯‹à®¤à®©à¯ˆ"))
  ]
  
  # Set Unicode attributes
  for (key, value) in unicode_values {
    Attributes::set(attrs, key, value)
  }
  
  # Test retrieval of Unicode attributes
  let chinese_result = Attributes::get(attrs, "chinese.simple")
  let japanese_result = Attributes::get(attrs, "japanese.hiragana")
  let arabic_result = Attributes::get(attrs, "arabic")
  let russian_result = Attributes::get(attrs, "russian")
  
  # Verify Unicode handling
  match chinese_result {
    Some(StringValue(s)) => assert_true(s.contains("ä¸­æ–‡"))
    _ => assert_false(true, "Expected Chinese string")
  }
  
  match japanese_result {
    Some(StringValue(s)) => assert_true(s.contains("ã²ã‚‰ãŒãª"))
    _ => assert_false(true, "Expected Japanese hiragana")
  }
  
  match arabic_result {
    Some(StringValue(s)) => assert_true(s.contains("Ø¹Ø±Ø¨ÙŠ"))
    _ => assert_false(true, "Expected Arabic string")
  }
  
  match russian_result {
    Some(StringValue(s)) => assert_true(s.contains("Ñ€ÑƒÑÑÐºÐ¸Ð¹"))
    _ => assert_false(true, "Expected Russian string")
  }
}

test "emoji_and_symbol_handling" {
  let attrs = Attributes::new()
  
  # Test with various emojis and symbols
  let emoji_values = [
    ("emoji.faces", StringValue("ðŸ˜€ðŸ˜ƒðŸ˜„ðŸ˜ðŸ˜†ðŸ˜…ðŸ˜‚ðŸ¤£ðŸ˜ŠðŸ˜‡")),
    ("emoji.animals", StringValue("ðŸ¶ðŸ±ðŸ­ðŸ¹ðŸ°ðŸ¦ŠðŸ»ðŸ¼ðŸ¨ðŸ¯")),
    ("emoji.food", StringValue("ðŸŽðŸŠðŸ‹ðŸŒðŸ‰ðŸ‡ðŸ“ðŸ«ðŸˆðŸ’")),
    ("emoji.travel", StringValue("ðŸš—ðŸš•ðŸš™ðŸšŒðŸšŽðŸŽï¸ðŸš“ðŸš‘ðŸš’ðŸš")),
    ("emoji.activities", StringValue("âš½ï¸ðŸ€ðŸˆâš¾ï¸ðŸ¥ŽðŸŽ¾ðŸðŸ‰ðŸ¥ðŸŽ±")),
    ("math.symbols", StringValue("âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚âˆšâˆžâ‰ˆâ‰ â‰¤â‰¥Â±")),
    ("currency.symbols", StringValue("ï¿¥â‚¬Â£$â‚¹â‚½â‚©â‚ªâ‚«â‚¡â‚¦â‚¨â‚±â‚²â‚´â‚¸â‚¼")),
    ("arrows.symbols", StringValue("â†â†’â†‘â†“â†–â†—â†˜â†™â‡â‡’â‡‘â‡“")),
    ("technical.symbols", StringValue("âš¡ðŸ”¥ðŸ’¡âš™ï¸ðŸ”§ðŸ”©âš—ï¸ðŸ§ªðŸ§¬ðŸ”¬"))
  ]
  
  # Set emoji and symbol attributes
  for (key, value) in emoji_values {
    Attributes::set(attrs, key, value)
  }
  
  # Test retrieval
  let faces_result = Attributes::get(attrs, "emoji.faces")
  let math_result = Attributes::get(attrs, "math.symbols")
  let currency_result = Attributes::get(attrs, "currency.symbols")
  
  # Verify emoji and symbol handling
  match faces_result {
    Some(StringValue(s)) => assert_true(s.contains("ðŸ˜€"))
    _ => assert_false(true, "Expected emoji faces")
  }
  
  match math_result {
    Some(StringValue(s)) => assert_true(s.contains("âˆ‘"))
    _ => assert_false(true, "Expected math symbols")
  }
  
  match currency_result {
    Some(StringValue(s)) => assert_true(s.contains("â‚¬"))
    _ => assert_false(true, "Expected currency symbols")
  }
}

test "unicode_in_context_operations" {
  let ctx = Context::root()
  
  # Test with Unicode keys and values
  let chinese_key = ContextKey::new("ä¸­æ–‡ä¸Šä¸‹æ–‡é”®")
  let japanese_key = ContextKey::new("æ—¥æœ¬èªžã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚­ãƒ¼")
  let arabic_key = ContextKey::new("Ù…ÙØªØ§Ø­ Ø§Ù„Ø³ÙŠØ§Ù‚ Ø§Ù„Ø¹Ø±Ø¨ÙŠ")
  let emoji_key = ContextKey::new("ðŸš€emoji.keyðŸŒŸ")
  
  # Set Unicode context values
  let ctx_with_chinese = Context::with_value(ctx, chinese_key, "ä¸­æ–‡ä¸Šä¸‹æ–‡å€¼")
  let ctx_with_japanese = Context::with_value(ctx_with_chinese, japanese_key, "æ—¥æœ¬èªžã®å€¤")
  let ctx_with_arabic = Context::with_value(ctx_with_japanese, arabic_key, "Ù‚ÙŠÙ…Ø© Ø§Ù„Ø³ÙŠØ§Ù‚")
  let ctx_with_emoji = Context::with_value(ctx_with_arabic, emoji_key, "ðŸŽ‰emoji valueðŸŽŠ")
  
  # Test retrieval of Unicode context values
  let chinese_result = Context::get(ctx_with_emoji, chinese_key)
  let japanese_result = Context::get(ctx_with_emoji, japanese_key)
  let arabic_result = Context::get(ctx_with_emoji, arabic_key)
  let emoji_result = Context::get(ctx_with_emoji, emoji_key)
  
  # Verify Unicode context operations
  assert_eq(chinese_result, Some("ä¸­æ–‡ä¸Šä¸‹æ–‡å€¼"))
  assert_eq(japanese_result, Some("æ—¥æœ¬èªžã®å€¤"))
  assert_eq(arabic_result, Some("Ù‚ÙŠÙ…Ø© Ø§Ù„Ø³ÙŠØ§Ù‚"))
  assert_eq(emoji_result, Some("ðŸŽ‰emoji valueðŸŽŠ"))
}

test "unicode_in_baggage_operations" {
  let baggage = Baggage::new()
  
  # Test with Unicode baggage entries
  let unicode_entries = [
    ("ç”¨æˆ·.æ ‡è¯†", "user-ä¸­æ–‡-12345"),
    ("ä¼šè¯.æ ‡è¯†", "session-æ—¥æœ¬èªž-abcdef"),
    ("æœåŠ¡.åç§°", "payment-service-Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"),
    ("çŽ¯å¢ƒ.ç±»åž‹", "production-ðŸš€"),
    ("åœ°åŒº.ä»£ç ", "US-ä¸­æ–‡-ðŸŒ"),
    ("è¯­è¨€.è®¾ç½®", "zh-CN-ç¹é«”"),
    ("æ—¶åŒº.ä¿¡æ¯", "Asia/Shanghai-åŒ—äº¬æ—¶é—´"),
    ("ç‰¹æ®Š.å­—ç¬¦", "special!@#$%^&*()-ç‰¹æ®Š"),
    ("æ··åˆ.å†…å®¹", "mixed-ä¸­æ–‡-English-æ—¥æœ¬èªž-ðŸŽ¯-Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  ]
  
  # Set Unicode baggage entries
  let mut current_baggage = baggage
  for (key, value) in unicode_entries {
    current_baggage = Baggage::set_entry(current_baggage, key, value)
  }
  
  # Test retrieval of Unicode baggage entries
  let user_id = Baggage::get_entry(current_baggage, "ç”¨æˆ·.æ ‡è¯†")
  let session_id = Baggage::get_entry(current_baggage, "ä¼šè¯.æ ‡è¯†")
  let service_name = Baggage::get_entry(current_baggage, "æœåŠ¡.åç§°")
  let environment = Baggage::get_entry(current_baggage, "çŽ¯å¢ƒ.ç±»åž‹")
  let mixed_content = Baggage::get_entry(current_baggage, "æ··åˆ.å†…å®¹")
  
  # Verify Unicode baggage operations (simplified implementation returns None)
  assert_eq(user_id, None)
  assert_eq(session_id, None)
  assert_eq(service_name, None)
  assert_eq(environment, None)
  assert_eq(mixed_content, None)
}

test "unicode_in_logging_operations" {
  let provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(provider, "unicode-logger-ðŸŒ")
  
  # Test log records with Unicode content
  let chinese_log = LogRecord::new(Info, "ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯ï¼šç”¨æˆ·ç™»å½•æˆåŠŸ")
  let japanese_log = LogRecord::new(Warn, "æ—¥æœ¬èªžãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼šè­¦å‘ŠãŒç™ºç”Ÿã—ã¾ã—ãŸ")
  let arabic_log = LogRecord::new(Error, "Ø±Ø³Ø§Ù„Ø© Ø³Ø¬Ù„ Ø¹Ø±Ø¨ÙŠØ©: Ø­Ø¯Ø« Ø®Ø·Ø£")
  let emoji_log = LogRecord::new(Debug, "ðŸš€ Emoji log message: System startup completed ðŸŽ‰")
  let mixed_log = LogRecord::new(Info, "Mixed: ä¸­æ–‡ English æ—¥æœ¬èªž Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ðŸŒ")
  
  # Create Unicode attributes for logging
  let unicode_attrs = Attributes::new()
  Attributes::set(unicode_attrs, "ç”¨æˆ·.åç§°", StringValue("å¼ ä¸‰"))
  Attributes::set(unicode_attrs, "ç”¨æˆ·.é‚®ç®±", StringValue("å¼ ä¸‰@example.com"))
  Attributes::set(unicode_attrs, "æ“ä½œ.ç±»åž‹", StringValue("æ–‡ä»¶ä¸Šä¼ "))
  Attributes::set(unicode_attrs, "çŠ¶æ€.ä¿¡æ¯", StringValue("æˆåŠŸ âœ…"))
  Attributes::set(unicode_attrs, "emoji.çŠ¶æ€", StringValue("ðŸŽ‰"))
  
  # Create log record with Unicode attributes
  let complex_unicode_log = LogRecord::new_with_context(
    Error,
    Some("å¤æ‚Unicodeæ—¥å¿—ï¼šå¤„ç†ç”¨æˆ·è¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯"),
    Some(unicode_attrs),
    Some(1735689600000000000L),
    None,
    Some("ä¸­æ–‡-trace-id"),
    Some("æ—¥æœ¬èªž-span-id"),
    None
  )
  
  # Emit all Unicode log records
  Logger::emit(logger, chinese_log)
  Logger::emit(logger, japanese_log)
  Logger::emit(logger, arabic_log)
  Logger::emit(logger, emoji_log)
  Logger::emit(logger, mixed_log)
  Logger::emit(logger, complex_unicode_log)
  
  # Verify operations complete
  assert_true(true)
}

test "unicode_in_span_operations" {
  let provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(provider, "unicode-tracer-ðŸš€")
  
  # Test spans with Unicode names
  let chinese_span = Tracer::start_span(tracer, "ä¸­æ–‡æ“ä½œå¤„ç†")
  let japanese_span = Tracer::start_span(tracer, "æ—¥æœ¬èªžæ“ä½œå‡¦ç†")
  let emoji_span = Tracer::start_span(tracer, "ðŸŽ¯ Emoji Operation ðŸŽ¯")
  let mixed_span = Tracer::start_span(tracer, "Mixed ä¸­æ–‡ English æ—¥æœ¬èªž ðŸŒ")
  
  # Test Unicode span attributes
  let unicode_span_attrs = [
    ("ç”¨æˆ·.æ ‡è¯†", StringValue("user-ä¸­æ–‡-123")),
    ("è¯·æ±‚.è·¯å¾„", StringValue("/api/ç”¨æˆ·/ä¿¡æ¯")),
    ("æœåŠ¡.åç§°", StringValue("ç”¨æˆ·æœåŠ¡-ðŸ‘¤")),
    ("æ“ä½œ.çŠ¶æ€", StringValue("å¤„ç†ä¸­...")),
    ("emoji.æŒ‡ç¤ºå™¨", StringValue("âš¡ðŸ”„âš¡"))
  ]
  
  let complex_span = Tracer::start_span(tracer, "å¤æ‚Unicodeæ“ä½œ", Some(unicode_span_attrs))
  
  # Test Unicode span events
  Span::add_event(chinese_span, "æ“ä½œå¼€å§‹", Some([("æ­¥éª¤", StringValue("åˆå§‹åŒ–"))]))
  Span::add_event(japanese_span, "å‡¦ç†é–‹å§‹", Some([("æ®µéšŽ", StringValue("åˆæœŸåŒ–"))]))
  Span::add_event(emoji_span, "ðŸš€ Operation Started ðŸš€", Some([("status", StringValue("âš¡ active âš¡"))]))
  Span::add_event(complex_span, "å¤æ‚äº‹ä»¶", Some([
    ("ç”¨æˆ·", StringValue("å¼ ä¸‰")),
    ("æ“ä½œ", StringValue("æ–‡ä»¶ä¸Šä¼ ")),
    ("çŠ¶æ€", StringValue("è¿›è¡Œä¸­ ðŸ”„")),
    ("è¯¦ç»†ä¿¡æ¯", StringValue("å¤„ç†ç”¨æˆ·ä¸Šä¼ çš„ä¸­æ–‡æ–‡ä»¶"))
  ]))
  
  # Set Unicode span status
  Span::set_status(chinese_span, Ok, Some("ä¸­æ–‡æ“ä½œæˆåŠŸå®Œæˆ"))
  Span::set_status(japanese_span, Error, Some("æ—¥æœ¬èªžã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ"))
  Span::set_status(emoji_span, Ok, Some("ðŸŽ‰ Emoji operation completed successfully ðŸŽ‰"))
  Span::set_status(complex_span, Ok, Some("å¤æ‚Unicodeæ“ä½œå·²å®Œæˆ âœ…"))
  
  # End all spans
  Span::end(chinese_span)
  Span::end(japanese_span)
  Span::end(emoji_span)
  Span::end(mixed_span)
  Span::end(complex_span)
  
  # Verify operations complete
  assert_true(true)
}

test "unicode_in_metrics_operations" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "unicode-metrics-ðŸŒ")
  
  # Test metrics with Unicode names
  let chinese_counter = Meter::create_counter(meter, "ä¸­æ–‡.è¯·æ±‚.è®¡æ•°å™¨", Some("ä¸­æ–‡è¯·æ±‚è®¡æ•°å™¨æè¿°"), Some("è¯·æ±‚"))
  let japanese_gauge = Meter::create_gauge(meter, "æ—¥æœ¬èªž.ãƒ¡ãƒ¢ãƒª.ä½¿ç”¨é‡", Some("æ—¥æœ¬èªžãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡"), Some("MB"))
  let arabic_histogram = Meter::create_histogram(meter, "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.ÙˆÙ‚Øª.Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©", Some("ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"), Some("ms"))
  let emoji_updown = Meter::create_updown_counter(meter, "ðŸš€.active.connections", Some("Active connections ðŸš€"), Some("connections"))
  
  # Test Unicode metric attributes
  let chinese_attrs = Attributes::new()
  Attributes::set(chinese_attrs, "ç«¯ç‚¹", StringValue("/api/ç”¨æˆ·"))
  Attributes::set(chinese_attrs, "æ–¹æ³•", StringValue("POST"))
  Attributes::set(chinese_attrs, "çŠ¶æ€", StringValue("æˆåŠŸ"))
  
  let japanese_attrs = Attributes::new()
  Attributes::set(japanese_attrs, "ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ", StringValue("/api/ãƒ¦ãƒ¼ã‚¶ãƒ¼"))
  Attributes::set(japanese_attrs, "ãƒ¡ã‚½ãƒƒãƒ‰", StringValue("GET"))
  Attributes::set(japanese_attrs, "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", StringValue("æˆåŠŸ"))
  
  let emoji_attrs = Attributes::new()
  Attributes::set(emoji_attrs, "service", StringValue("payment-service-ðŸ’³"))
  Attributes::set(emoji_attrs, "region", StringValue("asia-ðŸŒ"))
  Attributes::set(emoji_attrs, "status", StringValue("healthy-âœ…"))
  
  # Record metrics with Unicode attributes
  Counter::add(chinese_counter, 10.0, Some(chinese_attrs))
  Counter::add(chinese_counter, 5.0, Some(chinese_attrs))
  
  UpDownCounter::add(japanese_gauge, 1024.0, Some(japanese_attrs))
  UpDownCounter::add(japanese_gauge, 512.0, Some(japanese_attrs))
  UpDownCounter::add(japanese_gauge, -256.0, Some(japanese_attrs))
  
  Histogram::record(arabic_histogram, 100.0)
  Histogram::record(arabic_histogram, 150.0)
  Histogram::record(arabic_histogram, 200.0)
  
  UpDownCounter::add(emoji_updown, 50.0, Some(emoji_attrs))
  UpDownCounter::add(emoji_updown, 25.0, Some(emoji_attrs))
  UpDownCounter::add(emoji_updown, -10.0, Some(emoji_attrs))
  
  # Verify operations complete
  assert_true(true)
}

test "unicode_in_propagator_operations" {
  let composite = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let carrier = TextMapCarrier::new()
  
  # Test propagating Unicode context
  let ctx = Context::root()
  let chinese_key = ContextKey::new("ä¸­æ–‡.è·Ÿè¸ª.æ ‡è¯†")
  let japanese_key = ContextKey::new("æ—¥æœ¬èªž.ãƒˆãƒ¬ãƒ¼ã‚¹.ID")
  let arabic_key = ContextKey::new("Ù…Ø¹Ø±Ù.Ø§Ù„ØªØªØ¨Ø¹.Ø§Ù„Ø¹Ø±Ø¨ÙŠ")
  
  let ctx_with_unicode = Context::with_value(
    Context::with_value(
      Context::with_value(ctx, chinese_key, "ä¸­æ–‡-trace-12345"),
      japanese_key, "æ—¥æœ¬èªž-trace-abcdef"
    ),
    arabic_key, "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©-trace-67890"
  )
  
  # Test Unicode baggage in headers
  TextMapCarrier::set(carrier, "baggage", "ç”¨æˆ·=å¼ ä¸‰,ã‚µãƒ¼ãƒ“ã‚¹=æ—¥æœ¬èªž,Ù…Ø³ØªØ®Ø¯Ù…=Ø¹Ø±Ø¨ÙŠ,emoji=ðŸš€")
  TextMapCarrier::set(carrier, "x-unicode-header", "ä¸­æ–‡å€¼-æ—¥æœ¬èªžå€¤-Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©-emoji ðŸŽ‰")
  TextMapCarrier::set(carrier, "x-multilingual", "æ··åˆå†…å®¹: ä¸­æ–‡ English æ—¥æœ¬èªž Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ðŸŒ")
  
  # Test injection and extraction with Unicode
  CompositePropagator::inject(composite, ctx_with_unicode, carrier)
  let extracted_ctx = CompositePropagator::extract(composite, carrier)
  
  # Test complex Unicode headers
  let complex_carrier = TextMapCarrier::new()
  TextMapCarrier::set(complex_carrier, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  TextMapCarrier::set(complex_carrier, "x-chinese-trace", "ä¸­æ–‡è·Ÿè¸ªä¿¡æ¯: ç”¨æˆ·æ“ä½œå¤„ç†")
  TextMapCarrier::set(complex_carrier, "x-japanese-trace", "æ—¥æœ¬èªžãƒˆãƒ¬ãƒ¼ã‚¹æƒ…å ±ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå‡¦ç†")
  TextMapCarrier::set(complex_carrier, "x-arabic-trace", "Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØªØ¨Ø¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©: Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
  TextMapCarrier::set(complex_carrier, "x-emoji-trace", "ðŸš€ Emoji trace: User operation processing ðŸŽ¯")
  
  let complex_extracted_ctx = CompositePropagator::extract(composite, complex_carrier)
  
  # Verify Unicode propagation
  let extracted_value = Context::get(extracted_ctx, ContextKey::new("extracted"))
  let complex_extracted_value = Context::get(complex_extracted_ctx, ContextKey::new("extracted"))
  
  assert_eq(extracted_value, Some("true"))
  assert_eq(complex_extracted_value, Some("true"))
  
  # Verify operations complete
  assert_true(true)
}

test "unicode_in_resource_operations" {
  # Test resources with Unicode attributes
  let unicode_attrs = [
    ("æœåŠ¡.åç§°", StringValue("æ”¯ä»˜æœåŠ¡")),
    ("æœåŠ¡.ç‰ˆæœ¬", StringValue("1.2.3-ä¸­æ–‡ç‰ˆ")),
    ("éƒ¨ç½².çŽ¯å¢ƒ", StringValue("ç”Ÿäº§çŽ¯å¢ƒ-ðŸš€")),
    ("ä¸»æœº.åç§°", StringValue("ä¸»æœº-ä¸­æ–‡-01")),
    ("æ•°æ®ä¸­å¿ƒ", StringValue("åŒ—äº¬æ•°æ®ä¸­å¿ƒ-ðŸ‡¨ðŸ‡³")),
    ("ç®¡ç†å‘˜", StringValue("ç®¡ç†å‘˜-å¼ ä¸‰")),
    ("è”ç³».æ–¹å¼", StringValue("å¼ ä¸‰@example.com")),
    ("æ—¶åŒº", StringValue("Asia/Shanghai-åŒ—äº¬æ—¶é—´")),
    ("è¯­è¨€.è®¾ç½®", StringValue("zh-CN,ja-JP,ar-SA")),
    ("ç‰¹æ®Š.æ ‡è®°", StringValue("é‡è¦æœåŠ¡-â­-é«˜ä¼˜å…ˆçº§"))
  ]
  
  let unicode_resource = Resource::with_attributes(Resource::new(), unicode_attrs)
  
  # Test resource merging with Unicode
  let override_attrs = [
    ("æœåŠ¡.ç‰ˆæœ¬", StringValue("2.0.0-å›½é™…ç‰ˆ")),
    ("éƒ¨ç½².çŽ¯å¢ƒ", StringValue("staging-ðŸ§ª")),
    ("æ–°.åŠŸèƒ½", StringValue("å›½é™…åŒ–æ”¯æŒ-ðŸŒ")),
    ("emoji.çŠ¶æ€", StringValue("è¿è¡Œæ­£å¸¸ âœ…"))
  ]
  
  let override_resource = Resource::with_attributes(Resource::new(), override_attrs)
  let merged_unicode = Resource::merge(unicode_resource, override_resource)
  
  # Test retrieval of Unicode resource attributes
  let service_name = Resource::get_attribute(unicode_resource, "æœåŠ¡.åç§°")
  let datacenter = Resource::get_attribute(unicode_resource, "æ•°æ®ä¸­å¿ƒ")
  let admin = Resource::get_attribute(unicode_resource, "ç®¡ç†å‘˜")
  let timezone = Resource::get_attribute(unicode_resource, "æ—¶åŒº")
  let special_mark = Resource::get_attribute(unicode_resource, "ç‰¹æ®Š.æ ‡è®°")
  
  # Verify Unicode resource operations
  assert_eq(service_name, Some(StringValue("æ”¯ä»˜æœåŠ¡")))
  assert_eq(datacenter, Some(StringValue("åŒ—äº¬æ•°æ®ä¸­å¿ƒ-ðŸ‡¨ðŸ‡³")))
  assert_eq(admin, Some(StringValue("ç®¡ç†å‘˜-å¼ ä¸‰")))
  assert_eq(timezone, Some(StringValue("Asia/Shanghai-åŒ—äº¬æ—¶é—´")))
  assert_eq(special_mark, Some(StringValue("é‡è¦æœåŠ¡-â­-é«˜ä¼˜å…ˆçº§")))
  
  # Verify merged results
  let merged_version = Resource::get_attribute(merged_unicode, "æœåŠ¡.ç‰ˆæœ¬")
  let merged_env = Resource::get_attribute(merged_unicode, "éƒ¨ç½².çŽ¯å¢ƒ")
  let merged_feature = Resource::get_attribute(merged_unicode, "æ–°.åŠŸèƒ½")
  
  assert_eq(merged_version, Some(StringValue("2.0.0-å›½é™…ç‰ˆ")))
  assert_eq(merged_env, Some(StringValue("staging-ðŸ§ª")))
  assert_eq(merged_feature, Some(StringValue("å›½é™…åŒ–æ”¯æŒ-ðŸŒ")))
}

test "unicode_edge_cases_and_boundary_conditions" {
  # Test with edge case Unicode characters
  let edge_case_attrs = [
    ("zero.width.space", StringValue("text\u200Bwith\u200Bzero\u200Bwidth")),
    ("combining.diacritics", StringValue("e\u0301a\u0300o\u0302u\u0308")),
    ("rtl.text", StringValue("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ù†Øµ Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±")),
    ("bidi.text", StringValue("Hello \u202BØ§Ù„Ø¹Ø±Ø¨ÙŠØ©\u202C World")),
    ("control.chars", StringValue("text\nwith\tcontrol\rchars")),
    ("surrogate.pairs", StringValue("ð„žð„¢ð„¡ð„ ")),  # Musical symbols
    ("variation.selectors", StringValue("â¤ï¸ðŸ’”ðŸ’•ðŸ’–ðŸ’—ðŸ’™ðŸ’šðŸ’›ðŸ’œ")),
    ("zero.width.joiner", StringValue("ðŸ‘¨\u200DðŸ‘©\u200DðŸ‘§\u200DðŸ‘¦")),  # Family emoji
    ("soft.hyphens", StringValue("soft\u00ADhy\u00ADphen\u00ADtest")),
    ("private.use", StringValue("\uE000\uE001\uE002"))  # Private use area
  ]
  
  let edge_case_resource = Resource::with_attributes(Resource::new(), edge_case_attrs)
  
  # Test with extremely long Unicode strings
  let long_unicode = "è¶…é•¿Unicodeå­—ç¬¦ä¸²æµ‹è¯•".repeat(100) + "ðŸš€".repeat(50)
  let long_attrs = [("long.unicode", StringValue(long_unicode))]
  let long_unicode_resource = Resource::with_attributes(Resource::new(), long_attrs)
  
  # Test with mixed script content
  let mixed_script = "ä¸­æ–‡ English æ—¥æœ¬èªž Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ð ÑƒÑÑÐºÐ¸Ð¹ à¤¹à¤¿à¤¨à¥à¤¦à¥€ à¹„à¸—à¸¢ ðŸŒðŸš€ðŸŽ‰"
  let mixed_attrs = [("mixed.script", StringValue(mixed_script))]
  let mixed_script_resource = Resource::with_attributes(Resource::new(), mixed_attrs)
  
  # Test merging edge case resources
  let merged_edge_cases = Resource::merge(edge_case_resource, long_unicode_resource)
  let final_merged = Resource::merge(merged_edge_cases, mixed_script_resource)
  
  # Verify edge case handling
  let zero_width = Resource::get_attribute(edge_case_resource, "zero.width.space")
  let combining = Resource::get_attribute(edge_case_resource, "combining.diacritics")
  let rtl = Resource::get_attribute(edge_case_resource, "rtl.text")
  let surrogate = Resource::get_attribute(edge_case_resource, "surrogate.pairs")
  let family_emoji = Resource::get_attribute(edge_case_resource, "zero.width.joiner")
  
  # Verify edge case Unicode handling
  match zero_width {
    Some(StringValue(s)) => assert_true(s.contains("text"))
    _ => assert_false(true, "Expected zero-width space string")
  }
  
  match combining {
    Some(StringValue(s)) => assert_true(s.contains("e"))
    _ => assert_false(true, "Expected combining diacritics")
  }
  
  match rtl {
    Some(StringValue(s)) => assert_true(s.contains("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
    _ => assert_false(true, "Expected RTL text")
  }
  
  match surrogate {
    Some(StringValue(s)) => assert_true(s.contains("ð„ž"))
    _ => assert_false(true, "Expected surrogate pairs")
  }
  
  match family_emoji {
    Some(StringValue(s)) => assert_true(s.contains("ðŸ‘¨"))
    _ => assert_false(true, "Expected family emoji")
  }
  
  # Verify operations complete
  assert_true(true)
}