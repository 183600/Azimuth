// é¢å¤–çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ æ›´å¤šæµ‹è¯•è¦†ç›–

// æµ‹è¯•æ•°å­¦è¿ç®—çš„ç»“åˆå¾‹
test "mathematical_associativity" {
  let a = 5
  let b = 3
  let c = 2
  
  // åŠ æ³•ç»“åˆå¾‹ï¼š(a + b) + c = a + (b + c)
  assert_eq(
    add(add(a, b), c),
    add(a, add(b, c))
  )
  
  // ä¹˜æ³•ç»“åˆå¾‹ï¼š(a * b) * c = a * (b * c)
  assert_eq(
    multiply(multiply(a, b), c),
    multiply(a, multiply(b, c))
  )
}

// æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
test "division_boundary_cases" {
  // æµ‹è¯•é™¤æ•°ä¸º1çš„æƒ…å†µ
  assert_eq(10, divide_with_ceil(10, 1))
  assert_eq(-10, divide_with_ceil(-10, 1))
  
  // æµ‹è¯•é™¤æ•°ä¸º-1çš„æƒ…å†µ
  assert_eq(-10, divide_with_ceil(10, -1))
  assert_eq(10, divide_with_ceil(-10, -1))
  
  // æµ‹è¯•è¢«é™¤æ•°ä¸º0çš„æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
}

// æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç¼˜æƒ…å†µ
test "string_edge_cases" {
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello,  leading space!", greet(" leading space"))
  assert_eq_string("Hello, trailing space !", greet("trailing space "))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, \t\n!", greet("\t\n"))
}

// æµ‹è¯•å¤æ‚ä¸šåŠ¡é€»è¾‘è®¡ç®—
test "business_logic_calculation" {
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_members = 8
  let hours_per_day = 8
  let working_days = 5
  let total_hours = multiply(team_members, multiply(hours_per_day, working_days))
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°ï¼ˆæ¯å‘¨40å°æ—¶ï¼‰
  let hours_per_week = 40
  let weeks_needed = divide_with_ceil(total_hours, hours_per_week)
  
  assert_eq(8, weeks_needed)  // ceil(320/40) = 8
}

// æµ‹è¯•æ•°å­¦æ’ç­‰å¼
test "mathematical_identities" {
  let x = 15
  
  // åŠ æ³•æ’ç­‰å¼ï¼šx + 0 = x
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼ï¼šx * 1 = x
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  
  // ä¹˜æ³•é›¶å¾‹ï¼šx * 0 = 0
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
}

// æµ‹è¯•è´Ÿæ•°è¿ç®—çš„å…¨é¢æ€§
test "negative_numbers_comprehensive" {
  // è´Ÿæ•°åŠ æ³•
  assert_eq(-10, add(-5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(5, add(-10, 15))
  
  // è´Ÿæ•°ä¹˜æ³•
  assert_eq(25, multiply(-5, -5))
  assert_eq(-25, multiply(-5, 5))
  assert_eq(-25, multiply(5, -5))
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-2, divide_with_ceil(-7, 3))
  assert_eq(2, divide_with_ceil(-7, -3))
}

// æµ‹è¯•å¤§æ•°è¿ç®—
test "large_number_operations" {
  // å¤§æ•°åŠ æ³•
  assert_eq(2000000, add(1000000, 1000000))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(1000000, multiply(1000, 1000))
  
  // å¤§æ•°é™¤æ³•
  assert_eq(1001, divide_with_ceil(1000000, 999))
  assert_eq(1000, divide_with_ceil(1000000, 1000))
}

// æµ‹è¯•è¿ç»­è¿ç®—çš„å‡†ç¡®æ€§
test "sequential_operations" {
  let initial = 10
  
  // è¿ç»­åŠ æ³•
  let result1 = add(add(initial, 5), 3)
  assert_eq(18, result1)
  
  // è¿ç»­ä¹˜æ³•
  let result2 = multiply(multiply(initial, 2), 3)
  assert_eq(60, result2)
  
  // æ··åˆè¿ç®—
  let result3 = divide_with_ceil(
    multiply(add(initial, 5), 2),
    3
  )
  assert_eq(10, result3)  // ceil((10+5)*2/3) = ceil(30/3) = 10
}

// æµ‹è¯•Unicodeå­—ç¬¦å¤„ç†
test "unicode_handling" {
  // æµ‹è¯•å„ç§Unicodeå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, ğŸŒ™!", greet("ğŸŒ™"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

// æµ‹è¯•å®é™…åº”ç”¨åœºæ™¯
test "real_world_scenario" {
  // åœºæ™¯ï¼šè®¡ç®—è¿è¾“éœ€æ±‚
  let total_weight = 1250  // kg
  let truck_capacity = 300  // kg
  let trucks_needed = divide_with_ceil(total_weight, truck_capacity)
  
  assert_eq(5, trucks_needed)  // ceil(1250/300) = 5
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, truck_capacity)
  assert_eq(1500, total_capacity)
  
  // è®¡ç®—å‰©ä½™è¿åŠ›
  let remaining_capacity = subtract(total_capacity, total_weight)
  assert_eq(250, remaining_capacity)
}