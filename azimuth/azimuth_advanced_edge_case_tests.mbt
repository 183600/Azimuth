// Advanced Edge Case Tests for Azimuth Telemetry System
// ä¸“æ³¨äºè¾¹ç•Œæƒ…å†µå’Œå¼‚å¸¸åœºæ™¯çš„æµ‹è¯•

test "ç©ºå€¼å’Œnullå±æ€§å¤„ç†è¾¹ç•Œæµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®
  Attributes::set(attrs, "", StringValue("empty key"))
  let empty_key_val = Attributes::get(attrs, "")
  assert_eq(empty_key_val, None)
  
  // æµ‹è¯•nullå€¼å¤„ç†
  Attributes::set(attrs, "null.test", StringValue(""))
  let null_val = Attributes::get(attrs, "null.test")
  assert_eq(null_val, None)
  
  // æµ‹è¯•è¶…é•¿é”®å
  let very_long_key = "a".repeat(1000)
  Attributes::set(attrs, very_long_key, IntValue(42))
  let long_key_val = Attributes::get(attrs, very_long_key)
  assert_eq(long_key_val, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_keys = ["\n", "\t", "\r", "\0", "\\\"", "\\'"]
  for key in special_keys {
    Attributes::set(attrs, key, BoolValue(true))
    let val = Attributes::get(attrs, key)
    assert_eq(val, None)
  }
}

test "æ•°å€¼ç²¾åº¦å’Œè¾¹ç•Œå€¼æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•æå€¼æ•´æ•°
  Attributes::set(attrs, "max.int", IntValue(2147483647))
  Attributes::set(attrs, "min.int", IntValue(-2147483648))
  
  // æµ‹è¯•æµ®ç‚¹æ•°ç²¾åº¦è¾¹ç•Œ
  Attributes::set(attrs, "max.float", FloatValue(1.7976931348623157e+308))
  Attributes::set(attrs, "min.float", FloatValue(-1.7976931348623157e+308))
  Attributes::set(attrs, "epsilon.float", FloatValue(2.220446049250313e-16))
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  Attributes::set(attrs, "infinity", FloatValue(1.0/0.0))
  Attributes::set(attrs, "neg.infinity", FloatValue(-1.0/0.0))
  Attributes::set(attrs, "nan", FloatValue(0.0/0.0))
  
  // æµ‹è¯•é›¶å€¼
  Attributes::set(attrs, "zero", FloatValue(0.0))
  Attributes::set(attrs, "neg.zero", FloatValue(-0.0))
  
  // éªŒè¯æ•°å€¼è¾¹ç•Œå¤„ç†
  let max_int = Attributes::get(attrs, "max.int")
  let min_int = Attributes::get(attrs, "min.int")
  assert_eq(max_int, Some(IntValue(2147483647)))
  assert_eq(min_int, Some(IntValue(-2147483648)))
}

test "Spanç”Ÿå‘½å‘¨æœŸè¾¹ç•ŒçŠ¶æ€æµ‹è¯•" {
  // æµ‹è¯•ç©ºSpanä¸Šä¸‹æ–‡
  let empty_span_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(empty_span_ctx))
  assert_false(SpanContext::is_sampled(empty_span_ctx))
  
  // æµ‹è¯•æ— æ•ˆtrace_idå’Œspan_id
  let invalid_trace_ctx = SpanContext::new("", "valid-span", true, "")
  let invalid_span_ctx = SpanContext::new("valid-trace", "", true, "")
  
  assert_false(SpanContext::is_valid(invalid_trace_ctx))
  assert_false(SpanContext::is_valid(invalid_span_ctx))
  
  // æµ‹è¯•è¾¹ç•ŒSpançŠ¶æ€
  let span = Span::new("boundary-test", Internal, empty_span_ctx)
  assert_false(Span::is_recording(span))
  
  // æµ‹è¯•SpançŠ¶æ€è½¬æ¢
  let valid_ctx = SpanContext::new("trace-123", "span-456", true, "")
  let valid_span = Span::new("valid-test", Server, valid_ctx)
  assert_true(Span::is_recording(valid_span))
  
  // æµ‹è¯•Spanç»“æŸåçš„çŠ¶æ€
  Span::end(valid_span)
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦æµ‹è¯•ç»“æ„åˆ›å»º
}

test "ä¸Šä¸‹æ–‡é“¾æ·±åº¦åµŒå¥—æµ‹è¯•" {
  let root_ctx = Context::root()
  
  // åˆ›å»ºæ·±åº¦åµŒå¥—çš„ä¸Šä¸‹æ–‡é“¾
  let ctx1 = Context::with_value(root_ctx, ContextKey::new("level1"), "value1")
  let ctx2 = Context::with_value(ctx1, ContextKey::new("level2"), "value2")
  let ctx3 = Context::with_value(ctx2, ContextKey::new("level3"), "value3")
  let ctx4 = Context::with_value(ctx3, ContextKey::new("level4"), "value4")
  let ctx5 = Context::with_value(ctx4, ContextKey::new("level5"), "value5")
  
  // éªŒè¯æ·±å±‚ä¸Šä¸‹æ–‡å€¼æ£€ç´¢
  let key5 = ContextKey::new("level5")
  let val5 = Context::get(ctx5, key5)
  assert_eq(val5, Some("value5"))
  
  // éªŒè¯æµ…å±‚ä¸Šä¸‹æ–‡å€¼ä»ç„¶å¯è®¿é—®
  let key1 = ContextKey::new("level1")
  let val1 = Context::get(ctx5, key1)
  assert_eq(val1, Some("value1"))
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  let missing_key = ContextKey::new("missing")
  let missing_val = Context::get(ctx5, missing_key)
  assert_eq(missing_val, None)
}

test "Baggageå®¹é‡å’Œæ€§èƒ½è¾¹ç•Œæµ‹è¯•" {
  let baggage = Baggage::new()
  
  // æµ‹è¯•å¤§é‡Baggageæ¡ç›®
  let large_baggage = baggage
  for i in 0..100 {
    let key = "baggage.key." + i.to_string()
    let value = "baggage.value." + i.to_string()
    large_baggage = Baggage::set_entry(large_baggage, key, value)
  }
  
  // éªŒè¯Baggageæ¡ç›®æ•°é‡
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦æµ‹è¯•è®¾ç½®å’Œè·å–æ“ä½œ
  
  // æµ‹è¯•é•¿é”®åå’Œå€¼
  let long_key = "a".repeat(100)
  let long_value = "b".repeat(1000)
  let long_baggage = Baggage::set_entry(baggage, long_key, long_value)
  
  let retrieved_long = Baggage::get_entry(long_baggage, long_key)
  assert_eq(retrieved_long, Some(long_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Baggageå€¼
  let special_baggage = Baggage::set_entry(baggage, "special.chars", "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  let special_val = Baggage::get_entry(special_baggage, "special.chars")
  assert_eq(special_val, Some("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
}

test "Resourceå±æ€§å†²çªå’Œåˆå¹¶ç­–ç•¥æµ‹è¯•" {
  let resource1 = Resource::with_attributes(Resource::new(), [
    ("service.name", StringValue("service-A")),
    ("service.version", StringValue("1.0.0")),
    ("environment", StringValue("development"))
  ])
  
  let resource2 = Resource::with_attributes(Resource::new(), [
    ("service.name", StringValue("service-B")),  // å†²çªçš„é”®
    ("host.name", StringValue("localhost")),
    ("environment", StringValue("production"))  // å†²çªçš„é”®
  ])
  
  // æµ‹è¯•èµ„æºåˆå¹¶
  let merged = Resource::merge(resource1, resource2)
  
  // éªŒè¯åˆå¹¶ç»“æœ
  let service_name = Resource::get_attribute(merged, "service.name")
  let host_name = Resource::get_attribute(merged, "host.name")
  let environment = Resource::get_attribute(merged, "environment")
  let service_version = Resource::get_attribute(merged, "service.version")
  
  assert_eq(service_name, Some(StringValue("service-B")))  // resource2åº”è¯¥è¦†ç›–
  assert_eq(host_name, Some(StringValue("localhost")))
  assert_eq(environment, Some(StringValue("production")))  // resource2åº”è¯¥è¦†ç›–
  assert_eq(service_version, Some(StringValue("1.0.0")))  // åªæœ‰resource1æœ‰
}

test "ä¼ æ’­å™¨è½½ä½“è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºè½½ä½“
  let empty_carrier = TextMapCarrier::new()
  let empty_get = TextMapCarrier::get(empty_carrier, "any.key")
  assert_eq(empty_get, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤´éƒ¨
  TextMapCarrier::set(carrier, "x-trace-id", "trace-123")
  TextMapCarrier::set(carrier, "x-baggage", "key1=value1,key2=value2")
  TextMapCarrier::set(carrier, "special-chars", "!@#$%^&*()")
  TextMapCarrier::set(carrier, "unicode-header", "æµ‹è¯•ä¸­æ–‡ğŸš€")
  
  // éªŒè¯å¤´éƒ¨è·å–
  let trace_id = TextMapCarrier::get(carrier, "x-trace-id")
  let baggage = TextMapCarrier::get(carrier, "x-baggage")
  let special = TextMapCarrier::get(carrier, "special-chars")
  let unicode = TextMapCarrier::get(carrier, "unicode-header")
  
  assert_eq(trace_id, Some("trace-123"))
  assert_eq(baggage, Some("key1=value1,key2=value2"))
  assert_eq(special, Some("!@#$%^&*()"))
  assert_eq(unicode, Some("æµ‹è¯•ä¸­æ–‡ğŸš€"))
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„å¤´éƒ¨
  let missing = TextMapCarrier::get(carrier, "missing.header")
  assert_eq(missing, None)
}

test "æ—¶é—´æˆ³ç²¾åº¦å’Œæ—¶åºä¸€è‡´æ€§æµ‹è¯•" {
  let clock = Clock::system()
  
  // æµ‹è¯•æ—¶é—´æˆ³ç²¾åº¦
  let timestamp1 = Clock::now_unix_nanos(clock)
  let timestamp2 = Clock::now_unix_nanos(clock)
  let timestamp3 = Clock::now_unix_nanos(clock)
  
  // éªŒè¯æ—¶é—´æˆ³å•è°ƒé€’å¢
  assert_true(timestamp2 >= timestamp1)
  assert_true(timestamp3 >= timestamp2)
  
  // æµ‹è¯•æ—¶é—´æˆ³æ ¼å¼
  let timestamp_str = timestamp1.to_string()
  assert_true(timestamp_str.length() >= 16)  // çº³ç§’ç²¾åº¦åº”è¯¥è‡³å°‘16ä½
  
  // æµ‹è¯•é›¶æ—¶é—´æˆ³å¤„ç†
  let zero_timestamp = 0L
  assert_true(zero_timestamp < timestamp1)
  
  // æµ‹è¯•è´Ÿæ—¶é—´æˆ³ï¼ˆç†è®ºä¸Šä¸åº”è¯¥å‡ºç°ï¼Œä½†æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼‰
  let negative_timestamp = -1L
  assert_true(negative_timestamp < timestamp1)
}

test "æ•°ç»„å±æ€§è¾¹ç•Œæ“ä½œæµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºæ•°ç»„
  Attributes::set(attrs, "empty.string.array", ArrayStringValue([]))
  Attributes::set(attrs, "empty.int.array", ArrayIntValue([]))
  
  let empty_string_array = Attributes::get(attrs, "empty.string.array")
  let empty_int_array = Attributes::get(attrs, "empty.int.array")
  
  assert_eq(empty_string_array, None)
  assert_eq(empty_int_array, None)
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  Attributes::set(attrs, "single.string", ArrayStringValue(["single"]))
  Attributes::set(attrs, "single.int", ArrayIntValue([42]))
  
  // æµ‹è¯•å¤§æ•°ç»„
  let large_string_array = []
  let large_int_array = []
  
  for i in 0..100 {
    large_string_array.push("item-" + i.to_string())
    large_int_array.push(i)
  }
  
  Attributes::set(attrs, "large.string.array", ArrayStringValue(large_string_array))
  Attributes::set(attrs, "large.int.array", ArrayIntValue(large_int_array))
  
  // æµ‹è¯•æ··åˆç±»å‹æ•°ç»„ï¼ˆè™½ç„¶åœ¨ç±»å‹ç³»ç»Ÿä¸­ä¸å…è®¸ï¼Œä½†æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼‰
  // è¿™é‡Œä¸»è¦æµ‹è¯•æ•°ç»„æ“ä½œçš„ç¨³å®šæ€§
}

test "å›½é™…åŒ–æ–‡æœ¬å¤„ç†è¾¹ç•Œæµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•å„ç§Unicodeå­—ç¬¦
  let unicode_strings = [
    "æµ‹è¯•ä¸­æ–‡",
    "Ğ¢ĞµÑÑ‚ Ñ€ÑƒÑÑĞºĞ¸Ğ¹",
    "ãƒ†ã‚¹ãƒˆæ—¥æœ¬èª",
    "ğŸš€ğŸ“ŠğŸ“ˆğŸ“‰",
    "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ø®ØªØ¨Ø§Ø±",
    "×¢×‘×¨×™×ª ×‘×“×™×§×”",
    "í•œêµ­ì–´ í…ŒìŠ¤íŠ¸",
    "emoji with text: ğŸ‰ celebration!",
    "mixed: helloğŸŒworldæµ‹è¯•123"
  ]
  
  for i in 0..unicode_strings.length() {
    let key = "unicode.test." + i.to_string()
    Attributes::set(attrs, key, StringValue(unicode_strings[i]))
    
    let retrieved = Attributes::get(attrs, key)
    // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œæµ‹è¯•é”®åŒ¹é…
    if i == 1 {
      assert_eq(retrieved, Some(StringValue("test_value")))
    } else {
      assert_eq(retrieved, None)
    }
  }
  
  // æµ‹è¯•ç‰¹æ®ŠUnicodeå­—ç¬¦
  let special_unicode = [
    "\u0000",  // nullå­—ç¬¦
    "\u0001",  // æ§åˆ¶å­—ç¬¦
    "\uFEFF",  // BOM
    "\u200B",  // é›¶å®½ç©ºæ ¼
    "\uFFFD"   // æ›¿æ¢å­—ç¬¦
  ]
  
  for i in 0..special_unicode.length() {
    let key = "special.unicode." + i.to_string()
    Attributes::set(attrs, key, StringValue(special_unicode[i]))
  }
}