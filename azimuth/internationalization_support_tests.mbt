// Internationalization Support Tests
// This file contains comprehensive tests for internationalization and Unicode support

test "unicode handling in log messages" {
  // Test Unicode handling in log messages
  let provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(provider, "unicode-logger")
  
  // Test various Unicode characters
  let chinese_message = "è¿™æ˜¯ä¸€ä¸ªä¸­æ–‡æ—¥å¿—æ¶ˆæ¯"
  let japanese_message = "ã“ã‚Œã¯æ—¥æœ¬èªã®ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã™"
  let korean_message = "ì´ê²ƒì€ í•œêµ­ì–´ ë¡œê·¸ ë©”ì‹œì§€ì…ë‹ˆë‹¤"
  let arabic_message = "Ù‡Ø°Ù‡ Ø±Ø³Ø§Ù„Ø© Ø³Ø¬Ù„ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  let russian_message = "Ğ­Ñ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¶ÑƒÑ€Ğ½Ğ°Ğ»Ğ° Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ"
  let emoji_message = "Log message with emojis: ğŸš€ ğŸ‰ âœ¨ ğŸŒŸ"
  let mixed_message = "Mixed language: ä¸­æ–‡ English æ—¥æœ¬èª ğŸŒ"
  
  // Create log records with Unicode content
  let chinese_record = LogRecord::new(Info, chinese_message)
  let japanese_record = LogRecord::new(Info, japanese_message)
  let korean_record = LogRecord::new(Info, korean_message)
  let arabic_record = LogRecord::new(Info, arabic_message)
  let russian_record = LogRecord::new(Info, russian_message)
  let emoji_record = LogRecord::new(Info, emoji_message)
  let mixed_record = LogRecord::new(Info, mixed_message)
  
  // Emit Unicode log records
  Logger::emit(logger, chinese_record)
  Logger::emit(logger, japanese_record)
  Logger::emit(logger, korean_record)
  Logger::emit(logger, arabic_record)
  Logger::emit(logger, russian_record)
  Logger::emit(logger, emoji_record)
  Logger::emit(logger, mixed_record)
  
  // Verify Unicode content is preserved
  assert_eq(LogRecord::body(chinese_record), Some(chinese_message))
  assert_eq(LogRecord::body(japanese_record), Some(japanese_message))
  assert_eq(LogRecord::body(korean_record), Some(korean_message))
  assert_eq(LogRecord::body(arabic_record), Some(arabic_message))
  assert_eq(LogRecord::body(russian_record), Some(russian_message))
  assert_eq(LogRecord::body(emoji_record), Some(emoji_message))
  assert_eq(LogRecord::body(mixed_record), Some(mixed_message))
}

test "unicode attribute keys and values" {
  // Test Unicode attribute keys and values
  let attrs = Attributes::new()
  
  // Set Unicode attributes
  Attributes::set(attrs, "æœåŠ¡åç§°", StringValue("ç”¨æˆ·æœåŠ¡"))
  Attributes::set(attrs, "ãƒãƒ¼ã‚¸ãƒ§ãƒ³", StringValue("1.0.0"))
  Attributes::set(attrs, "í™˜ê²½", StringValue("í”„ë¡œë•ì…˜"))
  Attributes::set(attrs, "Ø§Ù„Ø¨ÙŠØ¦Ø©", StringValue("Ø§Ù„Ø¥Ù†ØªØ§Ø¬"))
  Attributes::set(attrs, "Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ğµ", StringValue("Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ‚"))
  Attributes::set(attrs, "emoji.ğŸš€", StringValue("rocket value"))
  Attributes::set(attrs, "mixed.é”®å€¼", StringValue("mixed value æµ‹è¯• ğŸŒŸ"))
  
  // Retrieve Unicode attributes
  let service_name = Attributes::get(attrs, "æœåŠ¡åç§°")
  let version = Attributes::get(attrs, "ãƒãƒ¼ã‚¸ãƒ§ãƒ³")
  let environment = Attributes::get(attrs, "í™˜ê²½")
  let arabic_env = Attributes::get(attrs, "Ø§Ù„Ø¨ÙŠØ¦Ø©")
  let russian_env = Attributes::get(attrs, "Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ğµ")
  let emoji_attr = Attributes::get(attrs, "emoji.ğŸš€")
  let mixed_attr = Attributes::get(attrs, "mixed.é”®å€¼")
  
  // Verify Unicode attributes are preserved
  assert_eq(service_name, Some(StringValue("ç”¨æˆ·æœåŠ¡")))
  assert_eq(version, Some(StringValue("1.0.0")))
  assert_eq(environment, Some(StringValue("í”„ë¡œë•ì…˜")))
  assert_eq(arabic_env, Some(StringValue("Ø§Ù„Ø¥Ù†ØªØ§Ø¬")))
  assert_eq(russian_env, Some(StringValue("Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ‚")))
  assert_eq(emoji_attr, Some(StringValue("rocket value")))
  assert_eq(mixed_attr, Some(StringValue("mixed value æµ‹è¯• ğŸŒŸ")))
}

test "unicode in span names and events" {
  // Test Unicode in span names and events
  let provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(provider, "unicode-tracer")
  
  // Create spans with Unicode names
  let chinese_span = Tracer::start_span(tracer, "ä¸­æ–‡æ“ä½œ")
  let japanese_span = Tracer::start_span(tracer, "æ—¥æœ¬èªæ“ä½œ")
  let korean_span = Tracer::start_span(tracer, "í•œêµ­ì–´ ì‘ì—…")
  let emoji_span = Tracer::start_span(tracer, "emoji operation ğŸš€")
  let mixed_span = Tracer::start_span(tracer, "mixed ä¸­æ–‡ English ğŸŒ")
  
  // Add Unicode events to spans
  Span::add_event(chinese_span, "ä¸­æ–‡äº‹ä»¶")
  Span::add_event(japanese_span, "æ—¥æœ¬èªã‚¤ãƒ™ãƒ³ãƒˆ")
  Span::add_event(korean_span, "í•œêµ­ì–´ ì´ë²¤íŠ¸")
  Span::add_event(emoji_span, "emoji event ğŸ‰")
  Span::add_event(mixed_span, "mixed event ä¸­æ–‡ ğŸŒŸ")
  
  // Verify Unicode span names
  assert_eq(Span::name(chinese_span), "ä¸­æ–‡æ“ä½œ")
  assert_eq(Span::name(japanese_span), "æ—¥æœ¬èªæ“ä½œ")
  assert_eq(Span::name(korean_span), "í•œêµ­ì–´ ì‘ì—…")
  assert_eq(Span::name(emoji_span), "emoji operation ğŸš€")
  assert_eq(Span::name(mixed_span), "mixed ä¸­æ–‡ English ğŸŒ")
  
  // End spans
  Span::end(chinese_span)
  Span::end(japanese_span)
  Span::end(korean_span)
  Span::end(emoji_span)
  Span::end(mixed_span)
}

test "unicode in baggage entries" {
  // Test Unicode in baggage entries
  let baggage = Baggage::new()
  
  // Set Unicode baggage entries
  baggage = Baggage::set_entry(baggage, "ç”¨æˆ·ID", "ç”¨æˆ·123")
  baggage = Baggage::set_entry(baggage, "ã‚»ãƒƒã‚·ãƒ§ãƒ³ID", "ã‚»ãƒƒã‚·ãƒ§ãƒ³456")
  baggage = Baggage::set_entry(baggage, "ì„¸ì…˜ID", "ì„¸ì…˜789")
  baggage = Baggage::set_entry(baggage, "Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", "Ù…Ø³ØªØ®Ø¯Ù…123")
  baggage = Baggage::set_entry(baggage, "Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", "Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ456")
  baggage = Baggage::set_entry(baggage, "emoji.ğŸ”‘", "emoji-value ğŸš€")
  baggage = Baggage::set_entry(baggage, "æ··åˆ.é”®", "æ··åˆå€¼ æµ‹è¯• ğŸŒŸ")
  
  // Retrieve Unicode baggage entries
  let user_id = Baggage::get_entry(baggage, "ç”¨æˆ·ID")
  let session_id_ja = Baggage::get_entry(baggage, "ã‚»ãƒƒã‚·ãƒ§ãƒ³ID")
  let session_id_ko = Baggage::get_entry(baggage, "ì„¸ì…˜ID")
  let arabic_user = Baggage::get_entry(baggage, "Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
  let russian_user = Baggage::get_entry(baggage, "Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ")
  let emoji_baggage = Baggage::get_entry(baggage, "emoji.ğŸ”‘")
  let mixed_baggage = Baggage::get_entry(baggage, "æ··åˆ.é”®")
  
  // Verify Unicode baggage entries are preserved
  assert_eq(user_id, Some("ç”¨æˆ·123"))
  assert_eq(session_id_ja, Some("ã‚»ãƒƒã‚·ãƒ§ãƒ³456"))
  assert_eq(session_id_ko, Some("ì„¸ì…˜789"))
  assert_eq(arabic_user, Some("Ù…Ø³ØªØ®Ø¯Ù…123"))
  assert_eq(russian_user, Some("Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ456"))
  assert_eq(emoji_baggage, Some("emoji-value ğŸš€"))
  assert_eq(mixed_baggage, Some("æ··åˆå€¼ æµ‹è¯• ğŸŒŸ"))
}

test "unicode in resource attributes" {
  // Test Unicode in resource attributes
  let resource = Resource::new()
  
  // Create resource with Unicode attributes
  let unicode_attrs = [
    ("æœåŠ¡åç§°", StringValue("ç”¨æˆ·æœåŠ¡")),
    ("ã‚µãƒ¼ãƒ“ã‚¹å", StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹")),
    ("ì„œë¹„ìŠ¤ ì´ë¦„", StringValue("ì‚¬ìš©ì ì„œë¹„ìŠ¤")),
    ("Ø§Ø³Ù… Ø§Ù„Ø®Ø¯Ù…Ø©", StringValue("Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")),
    ("Ğ¸Ğ¼Ñ ÑĞ»ÑƒĞ¶Ğ±Ñ‹", StringValue("Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ°Ñ ÑĞ»ÑƒĞ¶Ğ±Ğ°")),
    ("emoji.ğŸ·ï¸", StringValue("emoji service ğŸš€")),
    ("æ··åˆ.æ ‡ç­¾", StringValue("æ··åˆæ ‡ç­¾ æµ‹è¯• ğŸŒŸ"))
  ]
  let resource_with_unicode = Resource::with_attributes(resource, unicode_attrs)
  
  // Retrieve Unicode resource attributes
  let service_name_zh = Resource::get_attribute(resource_with_unicode, "æœåŠ¡åç§°")
  let service_name_ja = Resource::get_attribute(resource_with_unicode, "ã‚µãƒ¼ãƒ“ã‚¹å")
  let service_name_ko = Resource::get_attribute(resource_with_unicode, "ì„œë¹„ìŠ¤ ì´ë¦„")
  let service_name_ar = Resource::get_attribute(resource_with_unicode, "Ø§Ø³Ù… Ø§Ù„Ø®Ø¯Ù…Ø©")
  let service_name_ru = Resource::get_attribute(resource_with_unicode, "Ğ¸Ğ¼Ñ ÑĞ»ÑƒĞ¶Ğ±Ñ‹")
  let emoji_service = Resource::get_attribute(resource_with_unicode, "emoji.ğŸ·ï¸")
  let mixed_service = Resource::get_attribute(resource_with_unicode, "æ··åˆ.æ ‡ç­¾")
  
  // Verify Unicode resource attributes are preserved
  assert_eq(service_name_zh, Some(StringValue("ç”¨æˆ·æœåŠ¡")))
  assert_eq(service_name_ja, Some(StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹")))
  assert_eq(service_name_ko, Some(StringValue("ì‚¬ìš©ì ì„œë¹„ìŠ¤")))
  assert_eq(service_name_ar, Some(StringValue("Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")))
  assert_eq(service_name_ru, Some(StringValue("Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ°Ñ ÑĞ»ÑƒĞ¶Ğ±Ğ°")))
  assert_eq(emoji_service, Some(StringValue("emoji service ğŸš€")))
  assert_eq(mixed_service, Some(StringValue("æ··åˆæ ‡ç­¾ æµ‹è¯• ğŸŒŸ")))
}

test "unicode in text map carrier headers" {
  // Test Unicode in text map carrier headers
  let carrier = TextMapCarrier::new()
  
  // Set Unicode headers
  TextMapCarrier::set(carrier, "traceparent", "00-11112222333344445555666677778888-aaaabbbbccccdddd-01")
  TextMapCarrier::set(carrier, "ç”¨æˆ·ä¿¡æ¯", "ç”¨æˆ·123")
  TextMapCarrier::set(carrier, "ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±", "ãƒ¦ãƒ¼ã‚¶ãƒ¼456")
  TextMapCarrier::set(carrier, "ì‚¬ìš©ì ì •ë³´", "ì‚¬ìš©ì789")
  TextMapCarrier::set(carrier, "Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", "Ù…Ø³ØªØ®Ø¯Ù…123")
  TextMapCarrier::set(carrier, "Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ", "Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ456")
  TextMapCarrier::set(carrier, "emoji.ğŸ“‹", "emoji header ğŸš€")
  TextMapCarrier::set(carrier, "æ··åˆ.å¤´", "æ··åˆå¤´ä¿¡æ¯ æµ‹è¯• ğŸŒŸ")
  
  // Retrieve Unicode headers
  let traceparent = TextMapCarrier::get(carrier, "traceparent")
  let user_info_zh = TextMapCarrier::get(carrier, "ç”¨æˆ·ä¿¡æ¯")
  let user_info_ja = TextMapCarrier::get(carrier, "ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±")
  let user_info_ko = TextMapCarrier::get(carrier, "ì‚¬ìš©ì ì •ë³´")
  let user_info_ar = TextMapCarrier::get(carrier, "Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
  let user_info_ru = TextMapCarrier::get(carrier, "Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ")
  let emoji_header = TextMapCarrier::get(carrier, "emoji.ğŸ“‹")
  let mixed_header = TextMapCarrier::get(carrier, "æ··åˆ.å¤´")
  
  // Verify Unicode headers are preserved
  assert_eq(traceparent, Some("00-11112222333344445555666677778888-aaaabbbbccccdddd-01"))
  assert_eq(user_info_zh, Some("ç”¨æˆ·123"))
  assert_eq(user_info_ja, Some("ãƒ¦ãƒ¼ã‚¶ãƒ¼456"))
  assert_eq(user_info_ko, Some("ì‚¬ìš©ì789"))
  assert_eq(user_info_ar, Some("Ù…Ø³ØªØ®Ø¯Ù…123"))
  assert_eq(user_info_ru, Some("Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ456"))
  assert_eq(emoji_header, Some("emoji header ğŸš€"))
  assert_eq(mixed_header, Some("æ··åˆå¤´ä¿¡æ¯ æµ‹è¯• ğŸŒŸ"))
}

test "unicode in context keys and values" {
  // Test Unicode in context keys and values
  let ctx = Context::root()
  
  // Create context keys with Unicode
  let chinese_key = ContextKey::new("ä¸­æ–‡é”®")
  let japanese_key = ContextKey::new("æ—¥æœ¬èªã‚­ãƒ¼")
  let korean_key = ContextKey::new("í•œêµ­ì–´ í‚¤")
  let arabic_key = ContextKey::new("Ù…ÙØªØ§Ø­ Ø¹Ø±Ø¨ÙŠ")
  let russian_key = ContextKey::new("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡")
  let emoji_key = ContextKey::new("emoji.ğŸ”‘")
  let mixed_key = ContextKey::new("æ··åˆ.é”®")
  
  // Set context values with Unicode
  let ctx_with_chinese = Context::with_value(ctx, chinese_key, "ä¸­æ–‡å€¼")
  let ctx_with_japanese = Context::with_value(ctx_with_chinese, japanese_key, "æ—¥æœ¬èªå€¤")
  let ctx_with_korean = Context::with_value(ctx_with_japanese, korean_key, "í•œêµ­ì–´ ê°’")
  let ctx_with_arabic = Context::with_value(ctx_with_korean, arabic_key, "Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©")
  let ctx_with_russian = Context::with_value(ctx_with_arabic, russian_key, "Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ")
  let ctx_with_emoji = Context::with_value(ctx_with_russian, emoji_key, "emoji value ğŸš€")
  let ctx_with_mixed = Context::with_value(ctx_with_emoji, mixed_key, "æ··åˆå€¼ æµ‹è¯• ğŸŒŸ")
  
  // Retrieve Unicode context values
  let chinese_value = Context::get(ctx_with_mixed, chinese_key)
  let japanese_value = Context::get(ctx_with_mixed, japanese_key)
  let korean_value = Context::get(ctx_with_mixed, korean_key)
  let arabic_value = Context::get(ctx_with_mixed, arabic_key)
  let russian_value = Context::get(ctx_with_mixed, russian_key)
  let emoji_value = Context::get(ctx_with_mixed, emoji_key)
  let mixed_value = Context::get(ctx_with_mixed, mixed_key)
  
  // Verify Unicode context values are preserved
  assert_eq(chinese_value, Some("ä¸­æ–‡å€¼"))
  assert_eq(japanese_value, Some("æ—¥æœ¬èªå€¤"))
  assert_eq(korean_value, Some("í•œêµ­ì–´ ê°’"))
  assert_eq(arabic_value, Some("Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq(russian_value, Some("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"))
  assert_eq(emoji_value, Some("emoji value ğŸš€"))
  assert_eq(mixed_value, Some("æ··åˆå€¼ æµ‹è¯• ğŸŒŸ"))
}

test "unicode in metric names and descriptions" {
  // Test Unicode in metric names and descriptions
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "unicode-metrics")
  
  // Create metrics with Unicode names
  let chinese_counter = Meter::create_counter(meter, "ä¸­æ–‡è®¡æ•°å™¨")
  let japanese_histogram = Meter::create_histogram(meter, "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ")
  let korean_updown = Meter::create_updown_counter(meter, "í•œêµ­ì–´ ì—…ë‹¤ìš´ ì¹´ìš´í„°")
  let emoji_gauge = Meter::create_gauge(meter, "emoji.ğŸ“Š")
  let mixed_counter = Meter::create_counter(meter, "mixed.è®¡æ•°å™¨")
  
  // Verify Unicode metric names
  assert_eq(chinese_counter.name, "ä¸­æ–‡è®¡æ•°å™¨")
  assert_eq(japanese_histogram.name, "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ")
  assert_eq(korean_updown.name, "í•œêµ­ì–´ ì—…ë‹¤ìš´ ì¹´ìš´í„°")
  assert_eq(emoji_gauge.name, "emoji.ğŸ“Š")
  assert_eq(mixed_counter.name, "mixed.è®¡æ•°å™¨")
  
  // Test metric operations with Unicode metrics
  Counter::add(chinese_counter, 1.0)
  Histogram::record(japanese_histogram, 42.0)
  UpDownCounter::add(korean_updown, 10.0)
  
  // Verify operations complete without errors
  assert_true(true)
}

test "complex unicode scenarios" {
  // Test complex Unicode scenarios with mixed languages and special characters
  let provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(provider, "complex-unicode")
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "complex-unicode")
  
  // Create complex Unicode scenario
  let complex_span = Tracer::start_span(tracer, "å¤æ‚æ“ä½œ ğŸŒ ä¸­æ–‡ English æ—¥æœ¬è¯­")
  
  // Add complex Unicode events
  Span::add_event(complex_span, "äº‹ä»¶ with mixed: ä¸­æ–‡ ğŸš€ English æ—¥æœ¬è¯­ í•œêµ­ì–´ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹")
  
  // Create complex Unicode log record
  let complex_message = "å¤æ‚æ—¥å¿—æ¶ˆæ¯ with multiple languages: ä¸­æ–‡æµ‹è¯• ğŸŒŸ English test æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ í•œêµ­ì–´ í…ŒìŠ¤íŠ¸ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ø®ØªØ¨Ø§Ø± Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµÑÑ‚"
  let complex_record = LogRecord::new(Warn, complex_message)
  
  // Add complex Unicode attributes
  let attrs = Attributes::new()
  Attributes::set(attrs, "å¤æ‚.å±æ€§.é”®", StringValue("å¤æ‚å±æ€§å€¼ with ğŸš€ emojis and mixed languages"))
  
  // Create complex Unicode baggage
  let baggage = Baggage::new()
  baggage = Baggage::set_entry(baggage, "å¤æ‚.è¡Œæ.é”®", "å¤æ‚è¡Œæå€¼ with ğŸŒ mixed content")
  
  // Create complex Unicode resource
  let resource = Resource::new()
  let complex_attrs = [
    ("å¤æ‚.èµ„æº.æ ‡ç­¾", StringValue("å¤æ‚èµ„æºå€¼ with mixed languages and emojis ğŸ‰")),
    ("æœåŠ¡.åç§°", StringValue("å¤šè¯­è¨€æœåŠ¡ ğŸš€")),
    ("ãƒãƒ¼ã‚¸ãƒ§ãƒ³", StringValue("1.0.0-æµ‹è¯• ğŸŒŸ"))
  ]
  let complex_resource = Resource::with_attributes(resource, complex_attrs)
  
  // Verify complex Unicode scenario
  assert_eq(Span::name(complex_span), "å¤æ‚æ“ä½œ ğŸŒ ä¸­æ–‡ English æ—¥æœ¬è¯­")
  assert_eq(LogRecord::body(complex_record), Some(complex_message))
  
  let complex_attr = Attributes::get(attrs, "å¤æ‚.å±æ€§.é”®")
  assert_eq(complex_attr, Some(StringValue("å¤æ‚å±æ€§å€¼ with ğŸš€ emojis and mixed languages")))
  
  let complex_baggage = Baggage::get_entry(baggage, "å¤æ‚.è¡Œæ.é”®")
  assert_eq(complex_baggage, Some("å¤æ‚è¡Œæå€¼ with ğŸŒ mixed content"))
  
  let complex_resource_attr = Resource::get_attribute(complex_resource, "å¤æ‚.èµ„æº.æ ‡ç­¾")
  assert_eq(complex_resource_attr, Some(StringValue("å¤æ‚èµ„æºå€¼ with mixed languages and emojis ğŸ‰")))
  
  // End span and emit log
  Span::end(complex_span)
  Logger::emit(logger, complex_record)
}