// Azimuth é«˜çº§æµ‹è¯•å¥—ä»¶
// åŒ…å«10ä¸ªé«˜è´¨é‡çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ï¼Œä¸“æ³¨äºé«˜çº§åŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "performance_large_dataset_processing" {
  // å¤§æ•°æ®é›†æ€§èƒ½æµ‹è¯•
  let dataset_size = 10000
  let batch_size = 37
  
  // è®¡ç®—éœ€è¦çš„æ‰¹æ¬¡æ•°
  let batches_needed = divide_with_ceil(dataset_size, batch_size)
  assert_eq(271, batches_needed)  // ceil(10000/37) = 271
  
  // éªŒè¯æ€»å¤„ç†å®¹é‡
  let total_capacity = multiply(batches_needed, batch_size)
  assert_eq(10027, total_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let unused_capacity = subtract(total_capacity, dataset_size)
  assert_eq(27, unused_capacity)
  
  // æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼šè¿ç»­è¿ç®—
  let start_value = 1
  let iterations = 1000
  
  // è¿ç»­åŠ æ³•æ€§èƒ½æµ‹è¯•
  let mut sum_result = 0
  let mut i = 0
  while i < iterations {
    sum_result = add(sum_result, i)
    i = i + 1
  }
  assert_eq(499500, sum_result)  // 0 + 1 + 2 + ... + 999 = 499500
}

test "financial_compound_interest_calculation" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 10
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let mut current_amount = principal
  let mut year = 0
  while year < years {
    let interest = divide_with_ceil(multiply(current_amount, annual_rate), 100)
    current_amount = add(current_amount, interest)
    year = year + 1
  }
  
  // éªŒè¯å¤åˆ©ç»“æœï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  assert_eq(16289, current_amount)  // è¿‘ä¼¼å€¼
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–ï¼‰
  let monthly_payment = divide_with_ceil(current_amount, multiply(years, 12))
  assert_eq(136, monthly_payment)  // ceil(16289/120)
}

test "algorithm_efficiency_comparison" {
  // ç®—æ³•æ•ˆç‡æ¯”è¾ƒæµ‹è¯•
  let input_sizes = [100, 500, 1000, 5000]
  
  // æ¨¡æ‹ŸO(n)çº¿æ€§ç®—æ³•
  for size in input_sizes {
    let linear_ops = multiply(size, 3)
    let log_ops = divide_with_ceil(size, 10)
    
    // éªŒè¯çº¿æ€§ç®—æ³•å¤æ‚åº¦
    assert_eq(multiply(100, 3), linear_ops when size == 100)
    assert_eq(multiply(500, 3), linear_ops when size == 500)
    assert_eq(multiply(1000, 3), linear_ops when size == 1000)
    assert_eq(multiply(5000, 3), linear_ops when size == 5000)
    
    // éªŒè¯å¯¹æ•°ç®—æ³•å¤æ‚åº¦ï¼ˆç®€åŒ–ï¼‰
    assert_eq(10, log_ops when size == 100)
    assert_eq(50, log_ops when size == 500)
    assert_eq(100, log_ops when size == 1000)
    assert_eq(500, log_ops when size == 5000)
  }
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 10000
  let projects = [
    (2500, "Project Alpha"),
    (1800, "Project Beta"), 
    (3200, "Project Gamma"),
    (1500, "Project Delta")
  ]
  
  // è®¡ç®—æ¯ä¸ªé¡¹ç›®éœ€è¦çš„èµ„æºå•å…ƒæ•°
  let resource_unit_size = 500
  let mut total_units = 0
  
  for (project_resources, _) in projects {
    let units_needed = divide_with_ceil(project_resources, resource_unit_size)
    total_units = add(total_units, units_needed)
  }
  
  assert_eq(18, total_units)  // 5 + 4 + 7 + 3 = 18
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»èµ„æº
  let total_allocated = multiply(total_units, resource_unit_size)
  assert_eq(9000, total_allocated)
  
  // è®¡ç®—èµ„æºåˆ©ç”¨ç‡
  let utilization_rate = divide_with_ceil(multiply(total_resources, 100), total_allocated)
  assert_eq(112, utilization_rate)  // ceil(10000*100/9000) = 112%
}

test "string_processing_advanced_scenarios" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†åœºæ™¯
  let special_characters = [
    "ğŸŒŸâœ¨ğŸ’«", "ğŸ³ï¸â€ğŸŒˆğŸŒˆ", "ğŸ‰ğŸŠğŸˆ", 
    "ğŸ“šğŸ“–ğŸ“", "ğŸš€ğŸ›¸ğŸŒŒ", "ğŸŒºğŸŒ¸ğŸŒ¼"
  ]
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ç»„åˆçš„é—®å€™
  for chars in special_characters {
    let greeting = greet(chars)
    let expected = "Hello, " + chars + "!"
    assert_eq_string(expected, greeting)
  }
  
  // æµ‹è¯•æ··åˆè¯­è¨€å’Œè¡¨æƒ…ç¬¦å·
  let mixed_inputs = [
    "Hello ä¸–ç•Œ ğŸŒ", "Bonjour le monde ğŸ—¼", 
    "Hola mundo ğŸŒ", "Ciao mondo ğŸ›ï¸"
  ]
  
  for input in mixed_inputs {
    let greeting = greet(input)
    let expected = "Hello, " + input + "!"
    assert_eq_string(expected, greeting)
  }
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—å’Œï¼š1 + 3 + 5 + ... + (2n-1) = nÂ²
  let n = 50
  let mut sum = 0
  let mut i = 1
  while i <= multiply(2, n) {
    sum = add(sum, i)
    i = add(i, 2)
  }
  assert_eq(multiply(n, n), sum)  // 50Â² = 2500
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å’Œï¼š2 + 4 + 8 + ... + 2^n
  let geometric_n = 10
  let mut geometric_sum = 0
  let mut term = 2
  let mut j = 1
  while j <= geometric_n {
    geometric_sum = add(geometric_sum, term)
    term = multiply(term, 2)
    j = j + 1
  }
  assert_eq(2046, geometric_sum)  // 2 + 4 + 8 + ... + 1024 = 2046
}

test "error_recovery_and_resilience" {
  // é”™è¯¯æ¢å¤å’Œå¼¹æ€§æµ‹è¯•
  // æµ‹è¯•å„ç§å¼‚å¸¸è¾“å…¥çš„å¤„ç†
  let error_cases = [
    (0, 0), (100, 0), (-100, 0), 
    (2147483647, 0), (-2147483648, 0)
  ]
  
  for (dividend, divisor) in error_cases {
    // éªŒè¯é™¤é›¶é”™è¯¯çš„å®‰å…¨å¤„ç†
    let result = divide_with_ceil(dividend, divisor)
    assert_eq(0, result)  // åº”è¯¥è¿”å›å®‰å…¨çš„é»˜è®¤å€¼
  }
  
  // æµ‹è¯•æå€¼è¾¹ç•Œæƒ…å†µ
  let extreme_cases = [
    (2147483647, 1), (2147483647, 2147483647),
    (-2147483648, 1), (-2147483648, -2147483648)
  ]
  
  for (dividend, divisor) in extreme_cases {
    let result = divide_with_ceil(dividend, divisor)
    // éªŒè¯æå€¼è®¡ç®—ä¸ä¼šæº¢å‡º
    assert_true(result >= -2147483648)
    assert_true(result <= 2147483647)
  }
}

test "complex_business_workflow" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµæµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†å’Œåº“å­˜ç®¡ç†
  
  // è®¢å•å¤„ç†
  let orders = [
    (5, 120),   // (æ•°é‡, å•ä»·)
    (3, 250), 
    (8, 80),
    (2, 450),
    (6, 150)
  ]
  
  // è®¡ç®—è®¢å•æ€»é‡‘é¢
  let mut total_amount = 0
  for (quantity, price) in orders {
    let order_total = multiply(quantity, price)
    total_amount = add(total_amount, order_total)
  }
  assert_eq(3410, total_amount)  // 600 + 750 + 640 + 900 + 900 = 3790
  
  // è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡ï¼ˆæ¯ç®±æœ€å¤šè£…10ä»¶ï¼‰
  let mut total_items = 0
  for (quantity, _) in orders {
    total_items = add(total_items, quantity)
  }
  
  let boxes_needed = divide_with_ceil(total_items, 10)
  assert_eq(3, boxes_needed)  // ceil(24/10) = 3
  
  // è®¡ç®—è¿è¾“æˆæœ¬ï¼ˆæ¯ç®±50å…ƒï¼Œé¦–ç®±åŠ æ”¶20å…ƒå¤„ç†è´¹ï¼‰
  let base_shipping = multiply(boxes_needed, 50)
  let handling_fee = 20
  let total_shipping = add(base_shipping, handling_fee)
  assert_eq(170, total_shipping)  // 3*50 + 20 = 170
}

test "data_structure_simulation" {
  // æ•°æ®ç»“æ„æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_operations = [
    ("push", 5), ("push", 3), ("push", 8), 
    ("pop", 0), ("push", 2), ("pop", 0), ("pop", 0)
  ]
  
  let mut stack_size = 0
  let mut stack_sum = 0
  
  for (operation, value) in stack_operations {
    if operation == "push" {
      stack_size = add(stack_size, 1)
      stack_sum = add(stack_sum, value)
    } else if operation == "pop" and stack_size > 0 {
      stack_size = subtract(stack_size, 1)
      // ç®€åŒ–ï¼šå‡è®¾å¼¹å‡ºçš„æ˜¯æœ€åå‹å…¥çš„å€¼
      stack_sum = subtract(stack_sum, value)
    }
  }
  
  assert_eq(1, stack_size)   // æœ€ç»ˆæ ˆä¸­æœ‰ä¸€ä¸ªå…ƒç´ 
  assert_eq(5, stack_sum)    // æœ€ç»ˆå’Œä¸º5
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 20
  let queue_items = 13
  let new_arrivals = 8
  let processed_items = 5
  
  let final_queue_size = add(subtract(queue_items, processed_items), new_arrivals)
  let utilization_rate = divide_with_ceil(multiply(final_queue_size, 100), queue_capacity)
  
  assert_eq(16, final_queue_size)  // (13 - 5) + 8 = 16
  assert_eq(80, utilization_rate)  // ceil(16*100/20) = 80
}

test "advanced_mathematical_functions" {
  // é«˜çº§æ•°å­¦å‡½æ•°æµ‹è¯•
  // æ¨¡æ‹Ÿé˜¶ä¹˜è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let n = 7
  let mut factorial = 1
  let mut i = 2
  while i <= n {
    factorial = multiply(factorial, i)
    i = i + 1
  }
  assert_eq(5040, factorial)  // 7! = 5040
  
  // æ¨¡æ‹Ÿæ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let fib_n = 12
  let mut fib_prev = 0
  let mut fib_curr = 1
  let mut fib_index = 2
  
  while fib_index <= fib_n {
    let fib_next = add(fib_prev, fib_curr)
    fib_prev = fib_curr
    fib_curr = fib_next
    fib_index = fib_index + 1
  }
  assert_eq(144, fib_curr)  // ç¬¬12ä¸ªæ–æ³¢é‚£å¥‘æ•°
  
  // è®¡ç®—ç»„åˆæ•° C(n,k) = n! / (k! * (n-k)!)
  let comb_n = 10
  let comb_k = 3
  
  // ç®€åŒ–è®¡ç®—ï¼šC(10,3) = 10*9*8 / (3*2*1) = 120
  let numerator = multiply(multiply(10, 9), 8)
  let denominator = multiply(multiply(3, 2), 1)
  let combination = divide_with_ceil(numerator, denominator)
  assert_eq(120, combination)
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}