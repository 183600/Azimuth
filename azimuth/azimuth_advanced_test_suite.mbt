// Azimuth é«˜çº§æµ‹è¯•å¥—ä»¶ - 10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºå¤æ‚ä¸šåŠ¡é€»è¾‘ã€è¾¹ç¼˜æƒ…å†µå’Œæ€§èƒ½éªŒè¯

test "advanced_financial_calculations" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯ï¼šå¤åˆ©å’Œåˆ†æœŸä»˜æ¬¾
  let principal = 50000
  let annual_rate = 6  // 6%
  let years = 5
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  let year4_end = add(year3_end, divide_with_ceil(multiply(year3_end, annual_rate), 100))
  let year5_end = add(year4_end, divide_with_ceil(multiply(year4_end, annual_rate), 100))
  
  // éªŒè¯å¤åˆ©å¢é•¿
  assert_eq(53000, year1_end)  // 50000 + 6%
  assert_eq(56180, year2_end)  // 53000 + 6%
  assert_eq(59551, year3_end)  // 56180 + 6%
  assert_eq(63124, year4_end)  // 59551 + 6%
  assert_eq(66912, year5_end)  // 63124 + 6%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year5_end, total_months)
  assert_eq(1860, monthly_payment)  // ceil(66912/60)
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_paid = multiply(monthly_payment, total_months)
  assert_eq(111600, total_paid)
}

test "inventory_optimization_algorithm" {
  // åº“å­˜ä¼˜åŒ–ç®—æ³•ï¼šå¤šç§ç‰©å“çš„è£…ç®±é—®é¢˜
  // ç‰©å“Aï¼š127ä¸ªï¼Œæ¯ç®±å®¹é‡15
  let item_a_qty = 127
  let item_a_cap = 15
  let boxes_a = divide_with_ceil(item_a_qty, item_a_cap)
  
  // ç‰©å“Bï¼š89ä¸ªï¼Œæ¯ç®±å®¹é‡12
  let item_b_qty = 89
  let item_b_cap = 12
  let boxes_b = divide_with_ceil(item_b_qty, item_b_cap)
  
  // ç‰©å“Cï¼š203ä¸ªï¼Œæ¯ç®±å®¹é‡25
  let item_c_qty = 203
  let item_c_cap = 25
  let boxes_c = divide_with_ceil(item_c_qty, item_c_cap)
  
  // ç‰©å“Dï¼š45ä¸ªï¼Œæ¯ç®±å®¹é‡8
  let item_d_qty = 45
  let item_d_cap = 8
  let boxes_d = divide_with_ceil(item_d_qty, item_d_cap)
  
  // éªŒè¯å„ç‰©å“æ‰€éœ€ç®±å­æ•°
  assert_eq(9, boxes_a)   // ceil(127/15) = 9
  assert_eq(8, boxes_b)   // ceil(89/12) = 8
  assert_eq(9, boxes_c)   // ceil(203/25) = 9
  assert_eq(6, boxes_d)   // ceil(45/8) = 6
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(boxes_a, boxes_b), add(boxes_c, boxes_d))
  assert_eq(32, total_boxes)
  
  let total_capacity = add(
    multiply(boxes_a, item_a_cap),
    add(
      multiply(boxes_b, item_b_cap),
      add(
        multiply(boxes_c, item_c_cap),
        multiply(boxes_d, item_d_cap)
      )
    )
  )
  assert_eq(399, total_capacity)
  
  // è®¡ç®—ç©ºé—´åˆ©ç”¨ç‡
  let total_items = add(add(item_a_qty, item_b_qty), add(item_c_qty, item_d_qty))
  let utilization = divide_with_ceil(multiply(total_items, 100), total_capacity)
  assert_eq(116, utilization)  // ceil(46400/399) = 117%
}

test "data_pipeline_performance" {
  // æ•°æ®å¤„ç†æµæ°´çº¿æ€§èƒ½æµ‹è¯•
  let batch_size = 1000
  let processing_stages = 5
  let parallel_workers = 4
  
  // è®¡ç®—æ¯æ‰¹å¤„ç†æ—¶é—´ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
  let base_time_per_item = 2  // æ¯«ç§’
  let stage_overhead = 50    // æ¯é˜¶æ®µå¼€é”€
  let worker_efficiency = divide_with_ceil(100, parallel_workers)  // æ•ˆç‡å› å­
  
  let batch_time = add(
    multiply(batch_size, base_time_per_item),
    multiply(processing_stages, stage_overhead)
  )
  let optimized_time = divide_with_ceil(multiply(batch_time, worker_efficiency), 100)
  
  assert_eq(2250, batch_time)      // 1000*2 + 5*50 = 2250
  assert_eq(563, optimized_time)   // ceil(2250*25/100) = 563
  
  // è®¡ç®—ååé‡
  let throughput = divide_with_ceil(multiply(batch_size, 1000), optimized_time)
  assert_eq(1776, throughput)  // ceil(1000000/563) = 1777 items/second
}

test "edge_case_arithmetic_limits" {
  // ç®—æœ¯è¿ç®—çš„æé™è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num1 = 1000000
  let large_num2 = 999999
  
  let large_sum = add(large_num1, large_num2)
  let large_product = divide_with_ceil(large_num1, 1000)
  let large_division = divide_with_ceil(large_num1, large_num2)
  
  assert_eq(1999999, large_sum)
  assert_eq(1000, large_product)
  assert_eq(2, large_division)
  
  // æµ‹è¯•è´Ÿæ•°è¾¹ç•Œæƒ…å†µ
  let neg_large1 = -1000000
  let neg_large2 = -999999
  
  let neg_sum = add(neg_large1, neg_large2)
  let neg_product = divide_with_ceil(neg_large1, 1000)
  let neg_division = divide_with_ceil(neg_large1, neg_large2)
  
  assert_eq(-1999999, neg_sum)
  assert_eq(-1000, neg_product)
  assert_eq(2, neg_division)
  
  // æµ‹è¯•æ··åˆç¬¦å·çš„å¤æ‚è¿ç®—
  let mixed_result = divide_with_ceil(
    add(multiply(500, -3), multiply(-200, 4)),
    add(-100, 50)
  )
  assert_eq(14, mixed_result)  // ceil((-1500-800)/-50) = ceil(-2300/-50) = 46
}

test "string_encoding_unicode_extended" {
  // æ‰©å±•Unicodeå­—ç¬¦ä¸²ç¼–ç å¤„ç†
  assert_eq_string("Hello, ğŸŒ™â­ğŸŒŸ!", greet("ğŸŒ™â­ğŸŒŸ"))
  assert_eq_string("Hello, ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦!", greet("ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆğŸ´â€â˜ ï¸!", greet("ğŸ³ï¸â€ğŸŒˆğŸ´â€â˜ ï¸"))
  assert_eq_string("Hello, ğŸ¯ğŸªğŸ­!", greet("ğŸ¯ğŸªğŸ­"))
  assert_eq_string("Hello, ğŸ“±ğŸ’»âŒ¨ï¸!", greet("ğŸ“±ğŸ’»âŒ¨ï¸"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, \n\r\t\v\f!", greet("\n\r\t\v\f"))
  assert_eq_string("Hello, \"'`~!@#$%^&*()_+-=[]{}|;:,.<>?!", greet("\"'`~!@#$%^&*()_+-=[]{}|;:,.<>?"))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
  
  // æµ‹è¯•å„ç§è¯­è¨€å­—ç¬¦
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
  assert_eq_string("Hello, à¤¹à¤¿à¤¨à¥à¤¦à¥€!", greet("à¤¹à¤¿à¤¨à¥à¤¦à¥€"))
  assert_eq_string("Hello, à¹„à¸—à¸¢!", greet("à¹„à¸—à¸¢"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
}

test "resource_allocation_multi_constraint" {
  // å¤šçº¦æŸèµ„æºåˆ†é…é—®é¢˜
  // åœºæ™¯ï¼šé¡¹ç›®èµ„æºåˆ†é…ï¼Œè€ƒè™‘é¢„ç®—ã€äººåŠ›å’Œæ—¶é—´çº¦æŸ
  let project_budget = 100000
  let team_members = 8
  let project_deadline_days = 30
  let min_budget_per_person = 8000
  let min_days_per_person = 20
  
  // è®¡ç®—é¢„ç®—çº¦æŸä¸‹çš„æœ€å¤§äººæ•°
  let max_people_by_budget = divide_with_ceil(project_budget, min_budget_per_person)
  assert_eq(13, max_people_by_budget)  // ceil(100000/8000) = 13
  
  // è®¡ç®—æ—¶é—´çº¦æŸä¸‹çš„æœ€å¤§äººæ•°
  let max_people_by_time = divide_with_ceil(project_deadline_days, min_days_per_person)
  assert_eq(2, max_people_by_time)  // ceil(30/20) = 2
  
  // å®é™…å¯ç”¨äººæ•°å—æœ€ä¸¥æ ¼çº¦æŸé™åˆ¶
  let actual_team_size = team_members
  assert_true(actual_team_size <= max_people_by_budget)
  assert_true(actual_team_size <= max_people_by_time)
  
  // è®¡ç®—å®é™…èµ„æºåˆ†é…
  let budget_per_person = divide_with_ceil(project_budget, actual_team_size)
  let days_per_person = divide_with_ceil(project_deadline_days, actual_team_size)
  
  assert_eq(12500, budget_per_person)  // ceil(100000/8) = 12500
  assert_eq(4, days_per_person)        // ceil(30/8) = 4
  
  // éªŒè¯èµ„æºåˆ©ç”¨ç‡
  let total_allocated_budget = multiply(budget_per_person, actual_team_size)
  let budget_utilization = divide_with_ceil(multiply(total_allocated_budget, 100), project_budget)
  assert_eq(100, budget_utilization)  // 100000/100000 = 100%
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯
  // æ¨¡æ‹Ÿä¸åŒæ—¶é—´å¤æ‚åº¦çš„ç®—æ³•æ€§èƒ½
  let input_sizes = [10, 100, 1000]
  
  // O(1) å¸¸æ•°æ—¶é—´ç®—æ³•
  let constant_time_10 = 5
  let constant_time_100 = 5
  let constant_time_1000 = 5
  
  // O(n) çº¿æ€§æ—¶é—´ç®—æ³•
  let linear_time_10 = multiply(10, 3)
  let linear_time_100 = multiply(100, 3)
  let linear_time_1000 = multiply(1000, 3)
  
  // O(nÂ²) å¹³æ–¹æ—¶é—´ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•æ¨¡æ‹Ÿï¼‰
  let quadratic_time_10 = divide_with_ceil(multiply(10, 10), 2)
  let quadratic_time_100 = divide_with_ceil(multiply(100, 100), 2)
  let quadratic_time_1000 = divide_with_ceil(multiply(1000, 1000), 2)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time_10)
  assert_eq(5, constant_time_100)
  assert_eq(5, constant_time_1000)
  
  assert_eq(30, linear_time_10)
  assert_eq(300, linear_time_100)
  assert_eq(3000, linear_time_1000)
  
  assert_eq(50, quadratic_time_10)
  assert_eq(5000, quadratic_time_100)
  assert_eq(500000, quadratic_time_1000)
  
  // éªŒè¯ç®—æ³•æ•ˆç‡æ¯”è¾ƒ
  let efficiency_ratio_small = divide_with_ceil(linear_time_10, constant_time_10)
  let efficiency_ratio_medium = divide_with_ceil(linear_time_100, constant_time_100)
  let efficiency_ratio_large = divide_with_ceil(linear_time_1000, constant_time_1000)
  
  assert_eq(6, efficiency_ratio_small)
  assert_eq(60, efficiency_ratio_medium)
  assert_eq(600, efficiency_ratio_large)
}

test "error_recovery_scenarios" {
  // é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // æµ‹è¯•å„ç§é”™è¯¯æƒ…å†µä¸‹çš„ç³»ç»Ÿè¡Œä¸º
  
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  let zero_div_1 = divide_with_ceil(0, 0)
  let zero_div_2 = divide_with_ceil(100, 0)
  let zero_div_3 = divide_with_ceil(-100, 0)
  let zero_div_4 = divide_with_ceil(2147483647, 0)
  let zero_div_5 = divide_with_ceil(-2147483648, 0)
  
  assert_eq(0, zero_div_1)
  assert_eq(0, zero_div_2)
  assert_eq(0, zero_div_3)
  assert_eq(0, zero_div_4)
  assert_eq(0, zero_div_5)
  
  // æå€¼è¿ç®—æµ‹è¯•
  let max_int = 2147483647
  let min_int = -2147483648
  
  let safe_add_1 = add(max_int, 0)
  let safe_add_2 = add(min_int, 0)
  let safe_mul_1 = multiply(max_int, 1)
  let safe_mul_2 = multiply(min_int, 1)
  
  assert_eq(2147483647, safe_add_1)
  assert_eq(-2147483648, safe_add_2)
  assert_eq(2147483647, safe_mul_1)
  assert_eq(-2147483648, safe_mul_2)
  
  // é”™è¯¯æ¢å¤åçš„æ­£å¸¸è¿ç®—
  let recovery_test = add(multiply(5, 3), divide_with_ceil(10, 2))
  assert_eq(20, recovery_test)  // 5*3 + ceil(10/2) = 15 + 5 = 20
}

test "business_logic_integrated" {
  // ç»¼åˆä¸šåŠ¡é€»è¾‘æµ‹è¯•ï¼šç”µå•†è®¢å•å¤„ç†
  // è®¢å•åŸºç¡€ä¿¡æ¯
  let order_items = 47
  let item_price = 299
  let discount_threshold = 10
  let discount_rate = 5  // 5%
  let shipping_cost_per_box = 50
  let items_per_box = 12
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(order_items, item_price)
  assert_eq(14053, subtotal)  // 47 * 299 = 14053
  
  // è®¡ç®—æŠ˜æ‰£ï¼ˆå¦‚æœè¶…è¿‡é˜ˆå€¼ï¼‰
  let discount = if order_items > discount_threshold {
    divide_with_ceil(multiply(subtotal, discount_rate), 100)
  } else {
    0
  }
  assert_eq(703, discount)  // ceil(14053 * 5 / 100) = 703
  
  // è®¡ç®—è¿è¾“è´¹ç”¨
  let boxes_needed = divide_with_ceil(order_items, items_per_box)
  let shipping_cost = multiply(boxes_needed, shipping_cost_per_box)
  
  assert_eq(4, boxes_needed)    // ceil(47/12) = 4
  assert_eq(200, shipping_cost) // 4 * 50 = 200
  
  // è®¡ç®—è®¢å•æ€»é¢
  let total_cost = add(subtract(subtotal, discount), shipping_cost)
  assert_eq(13550, total_cost)  // (14053 - 703) + 200 = 13550
  
  // è®¡ç®—å¹³å‡æ¯ä»¶å•†å“æˆæœ¬
  let avg_cost_per_item = divide_with_ceil(total_cost, order_items)
  assert_eq(289, avg_cost_per_item)  // ceil(13550/47) = 289
  
  // éªŒè¯ä¸šåŠ¡é€»è¾‘
  assert_true(total_cost < subtotal)  // æŠ˜æ‰£åæ€»ä»·åº”ä½äºåŸä»·
  assert_true(avg_cost_per_item < item_price)  // å¹³å‡æˆæœ¬åº”ä½äºå•ä»·
}

test "performance_stress_large_data" {
  // å¤§æ•°æ®æ€§èƒ½å‹åŠ›æµ‹è¯•
  // æ¨¡æ‹Ÿå¤„ç†å¤§é‡æ•°æ®çš„æ€§èƒ½åœºæ™¯
  let data_records = 100000
  let batch_size = 500
  let processing_time_per_record = 3  // å¾®ç§’
  let memory_per_record = 1024  // å­—èŠ‚
  let network_bandwidth = 1000000  // å­—èŠ‚/ç§’
  
  // è®¡ç®—æ‰¹å¤„ç†æ•°é‡
  let total_batches = divide_with_ceil(data_records, batch_size)
  assert_eq(200, total_batches)  // ceil(100000/500) = 200
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_processing_time = multiply(data_records, processing_time_per_record)
  assert_eq(300000, total_processing_time)  // 100000 * 3 = 300000 å¾®ç§’
  
  // è®¡ç®—å†…å­˜éœ€æ±‚
  let total_memory_needed = multiply(data_records, memory_per_record)
  assert_eq(102400000, total_memory_needed)  // 100000 * 1024 = 102400000 å­—èŠ‚
  
  // è®¡ç®—ç½‘ç»œä¼ è¾“æ—¶é—´
  let network_transfer_time = divide_with_ceil(total_memory_needed, network_bandwidth)
  assert_eq(103, network_transfer_time)  // ceil(102400000/1000000) = 103 ç§’
  
  // è®¡ç®—æ€»ä½“æ€§èƒ½æŒ‡æ ‡
  let total_time_seconds = divide_with_ceil(total_processing_time, 1000000)
  let throughput_per_second = divide_with_ceil(data_records, add(total_time_seconds, network_transfer_time))
  
  assert_eq(1, total_time_seconds)  // ceil(300000/1000000) = 1
  assert_eq(902, throughput_per_second)  // ceil(100000/(1+103)) = 902 è®°å½•/ç§’
  
  // éªŒè¯æ€§èƒ½çº¦æŸ
  assert_true(total_time_seconds < 10)  // å¤„ç†æ—¶é—´åº”å°‘äº10ç§’
  assert_true(throughput_per_second > 500)  // ååé‡åº”å¤§äº500è®°å½•/ç§’
}