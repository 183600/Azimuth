// Azimuth é«˜çº§æµ‹è¯•å¥—ä»¶
// åŒ…å«10ä¸ªç²¾å¿ƒè®¾è®¡çš„æµ‹è¯•ç”¨ä¾‹ï¼Œä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•

test "mathematical_series_and_sequences" {
  // æ•°å­¦çº§æ•°å’Œåºåˆ—æµ‹è¯•
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰å‡ é¡¹
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  let fib6 = add(fib4, fib5)  // 8
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
  
  // éªŒè¯é»„é‡‘æ¯”ä¾‹è¿‘ä¼¼
  let ratio1 = divide_with_ceil(multiply(fib5, 100), fib4)
  let ratio2 = divide_with_ceil(multiply(fib6, 100), fib5)
  
  assert_eq(166, ratio1)  // 5/3 â‰ˆ 1.66
  assert_eq(160, ratio2)  // 8/5 = 1.6
}

test "business_inventory_optimization" {
  // ä¸šåŠ¡åº“å­˜ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šå¤šäº§å“åº“å­˜åˆ†é…ä¼˜åŒ–
  let product_a_demand = 127
  let product_b_demand = 89
  let product_c_demand = 156
  
  let pallet_capacity_a = 24
  let pallet_capacity_b = 16
  let pallet_capacity_c = 32
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„æ‰˜ç›˜æ•°
  let pallets_a = divide_with_ceil(product_a_demand, pallet_capacity_a)
  let pallets_b = divide_with_ceil(product_b_demand, pallet_capacity_b)
  let pallets_c = divide_with_ceil(product_c_demand, pallet_capacity_c)
  
  assert_eq(6, pallets_a)  // ceil(127/24) = 6
  assert_eq(6, pallets_b)  // ceil(89/16) = 6
  assert_eq(5, pallets_c)  // ceil(156/32) = 5
  
  // è®¡ç®—æ€»æ‰˜ç›˜æ•°å’Œæ€»å®¹é‡
  let total_pallets = add(add(pallets_a, pallets_b), pallets_c)
  let total_capacity = add(
    multiply(pallets_a, pallet_capacity_a),
    add(multiply(pallets_b, pallet_capacity_b), multiply(pallets_c, pallet_capacity_c))
  )
  let total_demand = add(add(product_a_demand, product_b_demand), product_c_demand)
  
  assert_eq(17, total_pallets)
  assert_eq(352, total_capacity)
  assert_eq(372, total_demand)
}

test "financial_investment_calculations" {
  // é‡‘èæŠ•èµ„è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šå¤åˆ©æŠ•èµ„è®¡ç®—
  
  let principal = 10000
  let annual_rate = 7  // 7%
  let years = 5
  
  // é€å¹´è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  let year4_end = add(year3_end, divide_with_ceil(multiply(year3_end, annual_rate), 100))
  let year5_end = add(year4_end, divide_with_ceil(multiply(year4_end, annual_rate), 100))
  
  assert_eq(10700, year1_end)
  assert_eq(11449, year2_end)
  assert_eq(12250, year3_end)
  assert_eq(13107, year4_end)
  assert_eq(14024, year5_end)
  
  // è®¡ç®—æœˆå®šæŠ•è®¡åˆ’
  let monthly_investment = 500
  let investment_months = multiply(years, 12)
  let total_invested = multiply(monthly_investment, investment_months)
  let final_value = year5_end
  
  assert_eq(60000, total_invested)
  assert_eq(14024, final_value)
}

test "string_processing_international" {
  // å›½é™…åŒ–å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•å¤šè¯­è¨€å’Œç‰¹æ®Šå­—ç¬¦æ”¯æŒ
  
  let inputs = ["MoonBit", "ä¸–ç•Œ", "ğŸš€", "cafÃ©", "ĞœĞ¾ÑĞºĞ²Ğ°"]
  
  // å¤„ç†å„ç§è¾“å…¥
  let output1 = greet(inputs[0])
  let output2 = greet(inputs[1])
  let output3 = greet(inputs[2])
  let output4 = greet(inputs[3])
  let output5 = greet(inputs[4])
  
  assert_eq_string("Hello, MoonBit!", output1)
  assert_eq_string("Hello, ä¸–ç•Œ!", output2)
  assert_eq_string("Hello, ğŸš€!", output3)
  assert_eq_string("Hello, cafÃ©!", output4)
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", output5)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  let empty_output = greet("")
  let special_output = greet("!@#$%^&*()")
  
  assert_eq_string("Hello, !", empty_output)
  assert_eq_string("Hello, !@#$%^&*()!", special_output)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•çš„æ€§èƒ½ç‰¹å¾
  
  let input_size = 1000
  
  // O(1) å¸¸æ•°æ—¶é—´ç®—æ³•
  let constant_time = 5
  
  // O(n) çº¿æ€§æ—¶é—´ç®—æ³•
  let linear_time = multiply(input_size, 2)
  
  // O(nÂ²) äºŒæ¬¡æ—¶é—´ç®—æ³•ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let quadratic_time = multiply(input_size, divide_with_ceil(input_size, 100))
  
  // O(log n) å¯¹æ•°æ—¶é—´ç®—æ³•ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let log_time = divide_with_ceil(input_size, 10)
  
  assert_eq(5, constant_time)
  assert_eq(2000, linear_time)
  assert_eq(10000, quadratic_time)
  assert_eq(100, log_time)
  
  // éªŒè¯å¤æ‚åº¦å…³ç³»
  assert_true(linear_time > constant_time)
  assert_true(quadratic_time > linear_time)
  assert_true(log_time < linear_time)
}

test "resource_scheduling_optimization" {
  // èµ„æºè°ƒåº¦ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šä»»åŠ¡è°ƒåº¦å’Œèµ„æºåˆ†é…
  
  let total_tasks = 87
  let available_workers = 8
  let working_hours = 8
  let task_complexity_factor = 2
  
  // è®¡ç®—åŸºç¡€ä»»åŠ¡åˆ†é…
  let tasks_per_worker = divide_with_ceil(total_tasks, available_workers)
  assert_eq(11, tasks_per_worker)  // ceil(87/8) = 11
  
  // è®¡ç®—æ¯ä¸ªå·¥äººçš„å·¥ä½œè´Ÿè½½
  let workload_per_worker = multiply(tasks_per_worker, task_complexity_factor)
  assert_eq(22, workload_per_worker)
  
  // è®¡ç®—æ€»å·¥ä½œæ—¶é—´å’Œéœ€è¦çš„å¤©æ•°
  let total_work_hours = multiply(workload_per_worker, available_workers)
  let days_needed = divide_with_ceil(total_work_hours, multiply(available_workers, working_hours))
  
  assert_eq(176, total_work_hours)  // 22 * 8
  assert_eq(3, days_needed)  // ceil(176/(8*8)) = 3
  
  // éªŒè¯æ‰€æœ‰ä»»åŠ¡éƒ½è¢«åˆ†é…
  let total_assigned_tasks = multiply(tasks_per_worker, available_workers)
  assert_true(total_assigned_tasks >= total_tasks)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿå¸¸è§æ•°æ®ç»“æ„æ“ä½œ
  
  // æ ˆæ“ä½œæ¨¡æ‹Ÿ
  let stack_size = 0
  let stack_push1 = add(stack_size, 1)
  let stack_push2 = add(stack_push1, 1)
  let stack_push3 = add(stack_push2, 1)
  let stack_pop1 = subtract(stack_push3, 1)
  let stack_pop2 = subtract(stack_pop1, 1)
  
  assert_eq(1, stack_push1)
  assert_eq(2, stack_push2)
  assert_eq(3, stack_push3)
  assert_eq(2, stack_pop1)
  assert_eq(1, stack_pop2)
  
  // é˜Ÿåˆ—æ“ä½œæ¨¡æ‹Ÿ
  let queue_capacity = 10
  let queue_size = 7
  let queue_remaining = subtract(queue_capacity, queue_size)
  let can_enqueue = queue_remaining > 0
  
  assert_eq(3, queue_remaining)
  assert_true(can_enqueue)
  
  // å“ˆå¸Œè¡¨è´Ÿè½½å› å­è®¡ç®—
  let hash_table_size = 16
  let hash_table_entries = 12
  let load_factor = divide_with_ceil(multiply(hash_table_entries, 100), hash_table_size)
  
  assert_eq(75, load_factor)  // 12/16 = 0.75 = 75%
}

test "error_handling_and_robustness" {
  // é”™è¯¯å¤„ç†å’Œå¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µ
  
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå€¼è¿ç®—æµ‹è¯•
  let large_positive = 1000000
  let large_negative = -1000000
  
  assert_eq(2000000, add(large_positive, large_positive))
  assert_eq(-2000000, add(large_negative, large_negative))
  assert_eq(0, add(large_positive, large_negative))
  
  assert_eq(1000000000000, multiply(large_positive, large_positive))
  assert_eq(1000000000000, multiply(large_negative, large_negative))
  assert_eq(-1000000000000, multiply(large_positive, large_negative))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
}

test "performance_benchmark_scenarios" {
  // æ€§èƒ½åŸºå‡†æµ‹è¯•åœºæ™¯
  // æ¨¡æ‹Ÿä¸åŒè§„æ¨¡çš„æ•°æ®å¤„ç†
  
  let small_dataset = 100
  let medium_dataset = 1000
  let large_dataset = 10000
  
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•åœ¨ä¸åŒæ•°æ®é›†ä¸Šçš„æ€§èƒ½
  // çº¿æ€§ç®—æ³• O(n)
  let linear_small = multiply(small_dataset, 5)
  let linear_medium = multiply(medium_dataset, 5)
  let linear_large = multiply(large_dataset, 5)
  
  // å¯¹æ•°ç®—æ³• O(log n) - ç®€åŒ–æ¨¡æ‹Ÿ
  let log_small = divide_with_ceil(small_dataset, 10)
  let log_medium = divide_with_ceil(medium_dataset, 10)
  let log_large = divide_with_ceil(large_dataset, 10)
  
  // éªŒè¯æ€§èƒ½ç‰¹å¾
  assert_eq(500, linear_small)
  assert_eq(5000, linear_medium)
  assert_eq(50000, linear_large)
  
  assert_eq(10, log_small)
  assert_eq(100, log_medium)
  assert_eq(1000, log_large)
  
  // è®¡ç®—æ€§èƒ½æå‡æ¯”ä¾‹
  let improvement_small_to_medium = divide_with_ceil(linear_medium, linear_small)
  let improvement_medium_to_large = divide_with_ceil(linear_large, linear_medium)
  
  assert_eq(10, improvement_small_to_medium)
  assert_eq(10, improvement_medium_to_large)
}

test "real_world_application_integration" {
  // çœŸå®ä¸–ç•Œåº”ç”¨é›†æˆæµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ
  
  let order_items = 47
  let warehouse_capacity_per_box = 8
  let shipping_boxes_per_pallet = 12
  let processing_time_per_box = 15  // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°
  let boxes_needed = divide_with_ceil(order_items, warehouse_capacity_per_box)
  assert_eq(6, boxes_needed)  // ceil(47/8) = 6
  
  // è®¡ç®—éœ€è¦çš„æ‰˜ç›˜æ•°
  let pallets_needed = divide_with_ceil(boxes_needed, shipping_boxes_per_pallet)
  assert_eq(1, pallets_needed)  // ceil(6/12) = 1
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_processing_time = multiply(boxes_needed, processing_time_per_box)
  assert_eq(90, total_processing_time)  // 6 * 15 = 90åˆ†é’Ÿ
  
  // è®¡ç®—æ¯å°æ—¶å¤„ç†èƒ½åŠ›
  let hourly_capacity = divide_with_ceil(multiply(60, warehouse_capacity_per_box), processing_time_per_box)
  assert_eq(32, hourly_capacity)  // ceil(60*8/15) = 32ä»¶/å°æ—¶
  
  // è®¡ç®—å®Œæˆæ—¶é—´
  let completion_hours = divide_with_ceil(total_processing_time, 60)
  assert_eq(2, completion_hours)  // ceil(90/60) = 2å°æ—¶
  
  // éªŒè¯å¤„ç†èƒ½åŠ›æ»¡è¶³éœ€æ±‚
  let daily_capacity = multiply(hourly_capacity, 8)  // 8å°æ—¶å·¥ä½œæ—¥
  assert_true(daily_capacity >= order_items)
}