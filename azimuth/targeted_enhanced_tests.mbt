// ç›®æ ‡å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ç‰¹å®šé«˜çº§åŠŸèƒ½çš„æµ‹è¯•

test "InstrumentationScopeå®Œæ•´åŠŸèƒ½æµ‹è¯•" {
  // æµ‹è¯•åˆ›å»ºå¸¦æœ‰å®Œæ•´ä¿¡æ¯çš„InstrumentationScope
  let scope1 = InstrumentationScope::{ 
    name: "azimuth.tracer", 
    version: Some("1.2.3"), 
    schema_url: Some("https://opentelemetry.io/schemas/1.20.0") 
  }
  
  assert_eq(scope1.name, "azimuth.tracer")
  match scope1.version {
    Some(v) => assert_eq(v, "1.2.3")
    None => assert_true(false)
  }
  match scope1.schema_url {
    Some(url) => assert_eq(url, "https://opentelemetry.io/schemas/1.20.0")
    None => assert_true(false)
  }
  
  // æµ‹è¯•æœ€å°é…ç½®çš„InstrumentationScope
  let scope2 = InstrumentationScope::{ 
    name: "minimal.scope", 
    version: None, 
    schema_url: None 
  }
  
  assert_eq(scope2.name, "minimal.scope")
  assert_true(scope2.version is None)
  assert_true(scope2.schema_url is None)
  
  // æµ‹è¯•åªæœ‰ç‰ˆæœ¬çš„InstrumentationScope
  let scope3 = InstrumentationScope::{ 
    name: "version.only.scope", 
    version: Some("2.0.0"), 
    schema_url: None 
  }
  
  assert_eq(scope3.name, "version.only.scope")
  match scope3.version {
    Some(v) => assert_eq(v, "2.0.0")
    None => assert_true(false)
  }
  assert_true(scope3.schema_url is None)
  
  // æµ‹è¯•åœ¨Tracerä¸­ä½¿ç”¨InstrumentationScope
  let tracer = Tracer::{ scope: scope1 }
  let retrieved_scope = Tracer::instrumentation_scope(tracer)
  assert_eq(retrieved_scope.name, "azimuth.tracer")
  match retrieved_scope.version {
    Some(v) => assert_eq(v, "1.2.3")
    None => assert_true(false)
  }
  
  // æµ‹è¯•åœ¨Loggerä¸­ä½¿ç”¨InstrumentationScope
  let logger = Logger::{ scope: scope2 }
  assert_eq(logger.scope.name, "minimal.scope")
  assert_true(logger.scope.version is None)
  
  // æµ‹è¯•åœ¨Meterä¸­ä½¿ç”¨InstrumentationScope
  let meter = Meter::{ scope: scope3 }
  assert_eq(meter.scope.name, "version.only.scope")
  match meter.scope.version {
    Some(v) => assert_eq(v, "2.0.0")
    None => assert_true(false)
  }
}

test "å¤åˆä¼ æ’­å™¨é«˜çº§åŠŸèƒ½æµ‹è¯•" {
  // åˆ›å»ºå¤šä¸ªä¼ æ’­å™¨
  let trace_propagator1 = W3CTraceContextPropagator::new()
  let trace_propagator2 = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  
  // æµ‹è¯•å•ä¸ªä¼ æ’­å™¨çš„å¤åˆ
  let single_composite = CompositePropagator::new([trace_propagator1])
  let carrier1 = TextMapCarrier::new()
  
  let ctx1 = Context::with_value(Context::root(), ContextKey::new("test.key"), "test.value")
  CompositePropagator::inject(single_composite, ctx1, carrier1)
  
  let injected_trace = TextMapCarrier::get(carrier1, "traceparent")
  assert_true(injected_trace is Some)
  
  let extracted_ctx1 = CompositePropagator::extract(single_composite, carrier1)
  let extracted_value = Context::get(extracted_ctx1, ContextKey::new("extracted"))
  match extracted_value {
    Some(v) => assert_eq(v, "true")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¤šä¸ªä¼ æ’­å™¨çš„å¤åˆ
  let multi_composite = CompositePropagator::new([trace_propagator1, trace_propagator2])
  let carrier2 = TextMapCarrier::new()
  
  let ctx2 = Context::with_value(Context::root(), ContextKey::new("multi.key"), "multi.value")
  CompositePropagator::inject(multi_composite, ctx2, carrier2)
  
  let extracted_ctx2 = CompositePropagator::extract(multi_composite, carrier2)
  let extracted_multi = Context::get(extracted_ctx2, ContextKey::new("extracted"))
  match extracted_multi {
    Some(v) => assert_eq(v, "true")
    None => assert_true(false)
  }
  
  // æµ‹è¯•é“¾å¼ä¼ æ’­æ“ä½œ
  let carrier3 = TextMapCarrier::new()
  TextMapCarrier::set(carrier3, "existing.header", "existing.value")
  
  CompositePropagator::inject(multi_composite, ctx2, carrier3)
  let existing_header = TextMapCarrier::get(carrier3, "existing.header")
  // æ³¨æ„ï¼šç®€åŒ–å®ç°å¯èƒ½ä¸ä¼šä¿ç•™ç°æœ‰å¤´éƒ¨
  
  // æµ‹è¯•ç©ºä¼ æ’­å™¨åˆ—è¡¨ï¼ˆå¦‚æœæ”¯æŒï¼‰
  // let empty_composite = CompositePropagator::new([])
  // let carrier4 = TextMapCarrier::new()
  // CompositePropagator::inject(empty_composite, ctx1, carrier4)
  
  assert_true(true)
}

test "åº¦é‡ä»ªå™¨é›†æˆæ“ä½œæµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "integration.test.meter", Some("1.0.0"))
  
  // æµ‹è¯•åˆ›å»ºå¤šç§ç±»å‹çš„åº¦é‡ä»ªå™¨
  let counter = Meter::create_counter(meter, "request.count", Some("Total requests"), Some("requests"))
  let histogram = Meter::create_histogram(meter, "response.time", Some("Response time"), Some("ms"))
  let updown_counter = Meter::create_updown_counter(meter, "active.connections", Some("Active connections"), Some("connections"))
  let gauge = Meter::create_gauge(meter, "memory.usage", Some("Memory usage"), Some("bytes"))
  
  // æµ‹è¯•æ‰€æœ‰åº¦é‡ä»ªå™¨çš„åŸºæœ¬æ“ä½œ
  Counter::add(counter, 10.0)
  Histogram::record(histogram, 150.5)
  UpDownCounter::add(updown_counter, 5.0)
  // Gaugeé€šå¸¸ç”¨äºè®°å½•å½“å‰å€¼ï¼Œç®€åŒ–å®ç°å¯èƒ½æ²¡æœ‰recordæ–¹æ³•
  
  // æµ‹è¯•å¸¦å±æ€§çš„åº¦é‡æ“ä½œ
  let attrs = Attributes::new()
  Attributes::set(attrs, "http.method", StringValue("GET"))
  Attributes::set(attrs, "http.status_code", IntValue(200))
  
  Counter::add(counter, 1.0, Some(attrs))
  Histogram::record(histogram, 85.2, Some(attrs))
  UpDownCounter::add(updown_counter, -2.0, Some(attrs))
  
  // æµ‹è¯•ä¸åŒæ•°å€¼ç±»å‹çš„åº¦é‡æ“ä½œ
  Counter::add(counter, 0.0)  // é›¶å€¼
  Counter::add(counter, -5.0) // è´Ÿå€¼ï¼ˆå¦‚æœå…è®¸ï¼‰
  Counter::add(counter, 999999.999) // å¤§æ•°å€¼
  
  Histogram::record(histogram, 0.001) // æå°å€¼
  Histogram::record(histogram, 1000000.0) // æå¤§å€¼
  
  // æµ‹è¯•UpDownCounterçš„å¢åŠ å’Œå‡å°‘
  UpDownCounter::add(updown_counter, 10.0)  // å¢åŠ 
  UpDownCounter::add(updown_counter, -3.0)  // å‡å°‘
  UpDownCounter::add(updown_counter, 0.0)   // é›¶å˜åŒ–
  
  // æµ‹è¯•ä»ªå™¨å…ƒæ•°æ®
  assert_eq(counter.name, "request.count")
  assert_eq(counter.description, Some("Total requests"))
  assert_eq(counter.unit, Some("requests"))
  
  assert_eq(histogram.name, "response.time")
  assert_eq(histogram.description, Some("Response time"))
  assert_eq(histogram.unit, Some("ms"))
  
  assert_eq(updown_counter.name, "active.connections")
  assert_eq(updown_counter.description, Some("Active connections"))
  assert_eq(updown_counter.unit, Some("connections"))
  
  assert_eq(gauge.name, "memory.usage")
  assert_eq(gauge.description, Some("Memory usage"))
  assert_eq(gauge.unit, Some("bytes"))
  
  assert_true(true)
}

test "æ—¥å¿—è®°å½•æ‰¹é‡æ“ä½œæµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "batch.test.logger", Some("1.0.0"))
  
  // æµ‹è¯•åˆ›å»ºä¸åŒç±»å‹çš„æ—¥å¿—è®°å½•
  let info_record = LogRecord::new(Info, "Information message")
  let warn_record = LogRecord::new(Warn, "Warning message")
  let error_record = LogRecord::new(Error, "Error message")
  
  // æµ‹è¯•æ‰¹é‡å‘é€æ—¥å¿—è®°å½•
  Logger::emit(logger, info_record)
  Logger::emit(logger, warn_record)
  Logger::emit(logger, error_record)
  
  // æµ‹è¯•åˆ›å»ºå¸¦æœ‰å±æ€§çš„å¤æ‚æ—¥å¿—è®°å½•
  let attrs = Attributes::new()
  Attributes::set(attrs, "user.id", StringValue("12345"))
  Attributes::set(attrs, "session.id", StringValue("session-67890"))
  Attributes::set(attrs, "request.id", StringValue("req-abc123"))
  Attributes::set(attrs, "duration.ms", IntValue(250))
  
  let complex_record = LogRecord::new_with_context(
    Info,
    Some("User operation completed successfully"),
    Some(attrs),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some("trace123456789"),
    Some("span987654321"),
    Some(Context::with_value(Context::root(), ContextKey::new("operation"), "login"))
  )
  
  Logger::emit(logger, complex_record)
  
  // æµ‹è¯•åˆ›å»ºå¤šä¸ªä¸åŒä¸¥é‡çº§åˆ«çš„æ—¥å¿—è®°å½•
  let trace_record = LogRecord::new_with_context(
    Trace,
    Some("Detailed trace information"),
    Some(attrs),
    Some(1735689600000000000L),
    Some(1735689600000000001L),
    Some("trace123"),
    Some("span123"),
    None
  )
  
  let debug_record = LogRecord::new_with_context(
    Debug,
    Some("Debug information for troubleshooting"),
    Some(attrs),
    Some(1735689600000000002L),
    Some(1735689600000000003L),
    Some("trace456"),
    Some("span456"),
    None
  )
  
  let fatal_record = LogRecord::new_with_context(
    Fatal,
    Some("Critical system error"),
    Some(attrs),
    Some(1735689600000000004L),
    Some(1735689600000000005L),
    Some("trace789"),
    Some("span789"),
    Some(Context::with_value(Context::root(), ContextKey::new("error.code"), "500"))
  )
  
  // æ‰¹é‡å‘é€ä¸åŒçº§åˆ«çš„æ—¥å¿—
  Logger::emit(logger, trace_record)
  Logger::emit(logger, debug_record)
  Logger::emit(logger, fatal_record)
  
  // æµ‹è¯•ç©ºå†…å®¹å’Œç‰¹æ®Šå†…å®¹çš„æ—¥å¿—è®°å½•
  let empty_body_record = LogRecord::new_with_context(
    Info,
    None,
    None,
    Some(1735689600000000006L),
    None,
    None,
    None,
    None
  )
  
  let long_body_record = LogRecord::new_with_context(
    Warn,
    Some("This is a very long log message that contains detailed information about a warning condition that occurred in the system. " * 10),
    None,
    Some(1735689600000000007L),
    None,
    None,
    None,
    None
  )
  
  let unicode_body_record = LogRecord::new_with_context(
    Error,
    Some("é”™è¯¯ä¿¡æ¯åŒ…å«ä¸­æ–‡å’Œç‰¹æ®Šå­—ç¬¦ï¼šæµ‹è¯•ğŸš€emojiå’Œç‰¹æ®Šç¬¦å·!@#$%"),
    None,
    Some(1735689600000000008L),
    None,
    None,
    None,
    None
  )
  
  Logger::emit(logger, empty_body_record)
  Logger::emit(logger, long_body_record)
  Logger::emit(logger, unicode_body_record)
  
  assert_true(true)
}

test "è·¨æœåŠ¡è¿½è¸ªç«¯åˆ°ç«¯æµ‹è¯•" {
  // æ¨¡æ‹ŸæœåŠ¡Açš„è¿½è¸ª
  let service_a_tracer = TracerProvider::get_tracer(TracerProvider::default(), "service-a", Some("1.0.0"))
  let service_a_span = Tracer::start_span(service_a_tracer, "service-a.operation")
  
  let service_a_context = Span::span_context(service_a_span)
  assert_true(SpanContext::is_valid(service_a_context))
  
  // æ¨¡æ‹Ÿä¼ æ’­åˆ°æœåŠ¡B
  let carrier = TextMapCarrier::new()
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let context_a = Context::with_value(Context::root(), ContextKey::new("service"), "A")
  
  CompositePropagator::inject(propagator, context_a, carrier)
  
  // æœåŠ¡Bæ¥æ”¶å¹¶ç»§ç»­è¿½è¸ª
  let extracted_context = CompositePropagator::extract(propagator, carrier)
  let service_b_tracer = TracerProvider::get_tracer(TracerProvider::default(), "service-b", Some("1.0.0"))
  let service_b_span = Tracer::start_span(service_b_tracer, "service-b.operation")
  
  // æœåŠ¡Bæ·»åŠ äº‹ä»¶
  Span::add_event(service_b_span, "service.b.start", Some([("service", StringValue("B")), ("timestamp", StringValue("2025-01-01T00:00:00Z"))]))
  
  // æ¨¡æ‹ŸæœåŠ¡Bè°ƒç”¨æœåŠ¡C
  let carrier_b = TextMapCarrier::new()
  let context_b = Context::with_value(extracted_context, ContextKey::new("service"), "B")
  CompositePropagator::inject(propagator, context_b, carrier_b)
  
  // æœåŠ¡Cå¤„ç†è¯·æ±‚
  let extracted_context_c = CompositePropagator::extract(propagator, carrier_b)
  let service_c_tracer = TracerProvider::get_tracer(TracerProvider::default(), "service-c", Some("1.0.0"))
  let service_c_span = Tracer::start_span(service_c_tracer, "service.c.operation")
  
  Span::add_event(service_c_span, "service.c.processing", Some([("service", StringValue("C")), ("processing.time.ms", IntValue(150))]))
  Span::set_status(service_c_span, Ok)
  Span::end(service_c_span)
  
  // æœåŠ¡Bå®Œæˆå¤„ç†
  Span::add_event(service_b_span, "service.b.complete", Some([("service", StringValue("B")), ("result", StringValue("success"))]))
  Span::set_status(service_b_span, Ok)
  Span::end(service_b_span)
  
  // æœåŠ¡Aå®Œæˆå¤„ç†
  Span::add_event(service_a_span, "service.a.complete", Some([("service", StringValue("A")), ("total.duration.ms", IntValue(500))]))
  Span::set_status(service_a_span, Ok)
  Span::end(service_a_span)
  
  // éªŒè¯æ‰€æœ‰spanéƒ½å·²æ­£ç¡®ç»“æŸ
  assert_false(Span::is_recording(service_a_span))
  assert_false(Span::is_recording(service_b_span))
  assert_false(Span::is_recording(service_c_span))
  
  // æµ‹è¯•é”™è¯¯åœºæ™¯çš„è¿½è¸ª
  let error_tracer = TracerProvider::get_tracer(TracerProvider::default(), "error.service", Some("1.0.0"))
  let error_span = Tracer::start_span(error_tracer, "error.operation")
  
  Span::add_event(error_span, "error.detected", Some([("error.code", StringValue("500")), ("error.message", StringValue("Internal server error"))]))
  Span::set_status(error_span, Error, Some("Processing failed due to database connection timeout"))
  Span::end(error_span)
  
  assert_true(true)
}

test "æ€§èƒ½ç›‘æ§å’Œèµ„æºä½¿ç”¨æµ‹è¯•" {
  // æµ‹è¯•Clockæ€§èƒ½
  let clock = Clock::system()
  let start_time = Clock::now_unix_nanos(clock)
  
  // æ¨¡æ‹Ÿä¸€äº›æ“ä½œ
  let attrs = Attributes::new()
  for i = 0; i < 100; i = i + 1 {
    Attributes::set(attrs, "key." + i.to_string(), StringValue("value." + i.to_string()))
  }
  
  let end_time = Clock::now_unix_nanos(clock)
  let duration = end_time - start_time
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œæ—¶é—´æˆ³å¯èƒ½ç›¸åŒï¼Œä½†éªŒè¯æ“ä½œå®Œæˆ
  assert_true(duration >= 0L)
  
  // æµ‹è¯•Randomç”Ÿæˆæ€§èƒ½
  let random = Random::system()
  let random_start = Clock::now_unix_nanos(clock)
  
  let random_arrays = []
  for i = 0; i < 10; i = i + 1 {
    let bytes = Random::next_bytes(random, 16)
    random_arrays.push(bytes)
  }
  
  let random_end = Clock::now_unix_nanos(clock)
  let random_duration = random_end - random_start
  
  assert_true(random_arrays.length() == 10)
  assert_true(random_duration >= 0L)
  
  // æµ‹è¯•èµ„æºå±æ€§æ“ä½œæ€§èƒ½
  let resource = Resource::new()
  let large_attributes = []
  
  let resource_start = Clock::now_unix_nanos(clock)
  for i = 0; i < 50; i = i + 1 {
    large_attributes.push(("attr." + i.to_string(), StringValue("value." + i.to_string())))
  }
  
  let resource_with_attrs = Resource::with_attributes(resource, large_attributes)
  let resource_end = Clock::now_unix_nanos(clock)
  let resource_duration = resource_end - resource_start
  
  assert_true(resource_duration >= 0L)
  
  // æµ‹è¯•Baggageæ“ä½œæ€§èƒ½
  let baggage = Baggage::new()
  let baggage_start = Clock::now_unix_nanos(clock)
  
  let current_baggage = baggage
  for i = 0; i < 25; i = i + 1 {
    current_baggage = Baggage::set_entry(current_baggage, "baggage." + i.to_string(), "value." + i.to_string())
  }
  
  let baggage_end = Clock::now_unix_nanos(clock)
  let baggage_duration = baggage_end - baggage_start
  
  assert_true(baggage_duration >= 0L)
  
  // æµ‹è¯•åº¦é‡æ“ä½œæ€§èƒ½
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "performance.test.meter")
  let counter = Meter::create_counter(meter, "performance.counter")
  
  let metrics_start = Clock::now_unix_nanos(clock)
  for i = 0; i < 100; i = i + 1 {
    Counter::add(counter, i.to_double())
  }
  let metrics_end = Clock::now_unix_nanos(clock)
  let metrics_duration = metrics_end - metrics_start
  
  assert_true(metrics_duration >= 0L)
  
  // æµ‹è¯•æ—¥å¿—æ“ä½œæ€§èƒ½
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "performance.test.logger")
  
  let logging_start = Clock::now_unix_nanos(clock)
  for i = 0; i < 50; i = i + 1 {
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Performance test log " + i.to_string()),
      None,
      Some(Clock::now_unix_nanos(clock)),
      None,
      None,
      None,
      None
    )
    Logger::emit(logger, log_record)
  }
  let logging_end = Clock::now_unix_nanos(clock)
  let logging_duration = logging_end - logging_start
  
  assert_true(logging_duration >= 0L)
  
  assert_true(true)
}

test "é…ç½®ç®¡ç†å’Œå›½é™…åŒ–æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒè¯­è¨€çš„é”™è¯¯æ¶ˆæ¯
  let error_span = TracerProvider::get_tracer(TracerProvider::default(), "i18n.test.tracer")
  let span = Tracer::start_span(error_span, "i18n.test.operation")
  
  // æ¨¡æ‹Ÿä¸­æ–‡é”™è¯¯æ¶ˆæ¯
  Span::add_event(span, "é”™è¯¯äº‹ä»¶", Some([
    ("é”™è¯¯ä»£ç ", StringValue("500")),
    ("é”™è¯¯æ¶ˆæ¯", StringValue("å†…éƒ¨æœåŠ¡å™¨é”™è¯¯")),
    ("è¯¦ç»†ä¿¡æ¯", StringValue("æ•°æ®åº“è¿æ¥è¶…æ—¶"))
  ]))
  
  // æ¨¡æ‹Ÿè‹±æ–‡é”™è¯¯æ¶ˆæ¯
  Span::add_event(span, "error.event", Some([
    ("error.code", StringValue("500")),
    ("error.message", StringValue("Internal server error")),
    ("error.details", StringValue("Database connection timeout"))
  ]))
  
  // æ¨¡æ‹Ÿæ—¥æ–‡é”™è¯¯æ¶ˆæ¯
  Span::add_event(span, "ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ", Some([
    ("ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰", StringValue("500")),
    ("ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸", StringValue("å†…éƒ¨ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼")),
    ("è©³ç´°æƒ…å ±", StringValue("ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"))
  ]))
  
  // æµ‹è¯•å›½é™…åŒ–æ—¥å¿—è®°å½•
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "i18n.test.logger")
  
  let chinese_log = LogRecord::new_with_context(
    Error,
    Some("ä¸­æ–‡é”™è¯¯æ—¥å¿—ï¼šç”¨æˆ·ç™»å½•å¤±è´¥ï¼Œå¯†ç ä¸æ­£ç¡®"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some("trace123"),
    Some("span123"),
    Some(Context::with_value(Context::root(), ContextKey::new("è¯­è¨€"), "ä¸­æ–‡"))
  )
  
  let english_log = LogRecord::new_with_context(
    Error,
    Some("English error log: User login failed, incorrect password"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some("trace456"),
    Some("span456"),
    Some(Context::with_value(Context::root(), ContextKey::new("language"), "English"))
  )
  
  let japanese_log = LogRecord::new_with_context(
    Error,
    Some("æ—¥æœ¬èªã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some("trace789"),
    Some("span789"),
    Some(Context::with_value(Context::root(), ContextKey::new("è¨€èª"), "æ—¥æœ¬èª"))
  )
  
  Logger::emit(logger, chinese_log)
  Logger::emit(logger, english_log)
  Logger::emit(logger, japanese_log)
  
  // æµ‹è¯•é…ç½®å±æ€§
  let config_resource = Resource::new()
  let config_attributes = [
    ("service.name", StringValue("azimuth-service")),
    ("service.version", StringValue("1.0.0")),
    ("service.environment", StringValue("production")),
    ("service.region", StringValue("us-west-2")),
    ("service.language", StringValue("en-US")),
    ("service.timezone", StringValue("UTC")),
    ("service.encoding", StringValue("UTF-8")),
    ("feature.flags", StringValue("experimental,debug,verbose")),
    ("log.level", StringValue("INFO")),
    ("metrics.enabled", BoolValue(true)),
    ("tracing.enabled", BoolValue(true)),
    ("sampling.rate", FloatValue(0.1)),
    ("timeout.seconds", IntValue(30)),
    ("max.connections", IntValue(100))
  ]
  
  let configured_resource = Resource::with_attributes(config_resource, config_attributes)
  
  // éªŒè¯é…ç½®å±æ€§
  let service_name = Resource::get_attribute(configured_resource, "service.name")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "azimuth-service")
    _ => assert_true(false)
  }
  
  let service_env = Resource::get_attribute(configured_resource, "service.environment")
  match service_env {
    Some(StringValue(value)) => assert_eq(value, "production")
    _ => assert_true(false)
  }
  
  let metrics_enabled = Resource::get_attribute(configured_resource, "metrics.enabled")
  match metrics_enabled {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  let sampling_rate = Resource::get_attribute(configured_resource, "sampling.rate")
  match sampling_rate {
    Some(FloatValue(value)) => assert_eq(value, 0.1)
    _ => assert_true(false)
  }
  
  let timeout_seconds = Resource::get_attribute(configured_resource, "timeout.seconds")
  match timeout_seconds {
    Some(IntValue(value)) => assert_eq(value, 30)
    _ => assert_true(false)
  }
  
  Span::set_status(span, Ok, Some("å›½é™…åŒ–æµ‹è¯•å®Œæˆ"))
  Span::end(span)
  
  assert_true(true)
}

test "å¹¶å‘å®‰å…¨æ€§å’Œçº¿ç¨‹éš”ç¦»æµ‹è¯•" {
  // æµ‹è¯•å¤šä¸ªTracerçš„å¹¶å‘æ“ä½œ
  let tracer_provider = TracerProvider::default()
  let tracer1 = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer.1")
  let tracer2 = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer.2")
  let tracer3 = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer.3")
  
  // åˆ›å»ºå¤šä¸ªspan
  let span1 = Tracer::start_span(tracer1, "concurrent.operation.1")
  let span2 = Tracer::start_span(tracer2, "concurrent.operation.2")
  let span3 = Tracer::start_span(tracer3, "concurrent.operation.3")
  
  // éªŒè¯spançš„ç‹¬ç«‹æ€§
  assert_eq(Span::name(span1), "concurrent.operation.1")
  assert_eq(Span::name(span2), "concurrent.operation.2")
  assert_eq(Span::name(span3), "concurrent.operation.3")
  
  // ä¸ºæ¯ä¸ªspanæ·»åŠ ä¸åŒçš„äº‹ä»¶
  Span::add_event(span1, "event.1", Some([("tracer", StringValue("tracer1"))]))
  Span::add_event(span2, "event.2", Some([("tracer", StringValue("tracer2"))]))
  Span::add_event(span3, "event.3", Some([("tracer", StringValue("tracer3"))]))
  
  // æµ‹è¯•å¤šä¸ªMeterçš„å¹¶å‘æ“ä½œ
  let meter_provider = MeterProvider::default()
  let meter1 = MeterProvider::get_meter(meter_provider, "concurrent.meter.1")
  let meter2 = MeterProvider::get_meter(meter_provider, "concurrent.meter.2")
  
  let counter1 = Meter::create_counter(meter1, "concurrent.counter.1")
  let counter2 = Meter::create_counter(meter2, "concurrent.counter.2")
  let histogram1 = Meter::create_histogram(meter1, "concurrent.histogram.1")
  let histogram2 = Meter::create_histogram(meter2, "concurrent.histogram.2")
  
  // å¹¶å‘è®°å½•åº¦é‡
  Counter::add(counter1, 1.0)
  Counter::add(counter2, 2.0)
  Histogram::record(histogram1, 100.0)
  Histogram::record(histogram2, 200.0)
  
  // æµ‹è¯•å¤šä¸ªLoggerçš„å¹¶å‘æ“ä½œ
  let logger_provider = LoggerProvider::default()
  let logger1 = LoggerProvider::get_logger(logger_provider, "concurrent.logger.1")
  let logger2 = LoggerProvider::get_logger(logger_provider, "concurrent.logger.2")
  
  let log1 = LogRecord::new(Info, "Concurrent log message 1")
  let log2 = LogRecord::new(Warn, "Concurrent log message 2")
  
  Logger::emit(logger1, log1)
  Logger::emit(logger2, log2)
  
  // æµ‹è¯•Contextçš„éš”ç¦»æ€§
  let context1 = Context::with_value(Context::root(), ContextKey::new("key1"), "value1")
  let context2 = Context::with_value(Context::root(), ContextKey::new("key2"), "value2")
  let context3 = Context::with_value(Context::root(), ContextKey::new("key3"), "value3")
  
  let value1 = Context::get(context1, ContextKey::new("key1"))
  let value2 = Context::get(context2, ContextKey::new("key2"))
  let value3 = Context::get(context3, ContextKey::new("key3"))
  
  match value1 {
    Some(v) => assert_eq(v, "value1")
    None => assert_true(false)
  }
  
  match value2 {
    Some(v) => assert_eq(v, "value2")
    None => assert_true(false)
  }
  
  match value3 {
    Some(v) => assert_eq(v, "value3")
    None => assert_true(false)
  }
  
  // æµ‹è¯•Baggageçš„éš”ç¦»æ€§
  let baggage1 = Baggage::new()
  let baggage2 = Baggage::new()
  let baggage3 = Baggage::new()
  
  let updated_baggage1 = Baggage::set_entry(baggage1, "baggage1", "value1")
  let updated_baggage2 = Baggage::set_entry(baggage2, "baggage2", "value2")
  let updated_baggage3 = Baggage::set_entry(baggage3, "baggage3", "value3")
  
  let baggage_value1 = Baggage::get_entry(updated_baggage1, "baggage1")
  let baggage_value2 = Baggage::get_entry(updated_baggage2, "baggage2")
  let baggage_value3 = Baggage::get_entry(updated_baggage3, "baggage3")
  
  match baggage_value1 {
    Some(v) => assert_eq(v, "value1")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  match baggage_value2 {
    Some(v) => assert_eq(v, "value2")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  match baggage_value3 {
    Some(v) => assert_eq(v, "value3")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  // å®Œæˆæ‰€æœ‰span
  Span::set_status(span1, Ok)
  Span::set_status(span2, Ok)
  Span::set_status(span3, Ok)
  
  Span::end(span1)
  Span::end(span2)
  Span::end(span3)
  
  assert_true(true)
}