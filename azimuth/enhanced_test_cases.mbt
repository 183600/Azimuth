// Azimuth åº“å¢å¼ºæµ‹è¯•ç”¨ä¾‹
// åŒ…å«10ä¸ªé«˜è´¨é‡çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "extreme_value_boundary_testing" {
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼
  let max_safe_int = 2147483647
  let min_safe_int = -2147483648
  
  // æµ‹è¯•æ¥è¿‘æœ€å¤§å€¼çš„åŠ æ³•
  assert_eq(2147483646, add(max_safe_int - 1, 1))
  
  // æµ‹è¯•æ¥è¿‘æœ€å°å€¼çš„åŠ æ³•
  assert_eq(-2147483647, add(min_safe_int + 1, -1))
  
  // æµ‹è¯•å¤§æ•°é™¤æ³•
  assert_eq(1, divide_with_ceil(max_safe_int, max_safe_int))
  assert_eq(1, divide_with_ceil(min_safe_int, min_safe_int))
}

test "complex_function_composition" {
  // æµ‹è¯•å¤æ‚çš„å‡½æ•°ç»„åˆ
  let initial_value = 100
  
  // åµŒå¥—å‡½æ•°è°ƒç”¨é“¾
  let result = add(
    multiply(
      divide_with_ceil(initial_value, 5),
      3
    ),
    subtract(initial_value, 80)
  )
  
  // æ‰‹åŠ¨è®¡ç®—éªŒè¯ï¼šceil(100/5) * 3 + (100-80) = 20*3 + 20 = 80
  assert_eq(80, result)
}

test "string_formatting_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²æ ¼å¼åŒ–çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, 'single'!", greet("'single'"))
  assert_eq_string("Hello, \\backslash!", greet("\\backslash"))
  assert_eq_string("Hello, ğŸŒ™ğŸŒŸğŸŒ™!", greet("ğŸŒ™ğŸŒŸğŸŒ™"))
}

test "performance_large_scale_calculations" {
  // æµ‹è¯•å¤§è§„æ¨¡è®¡ç®—æ€§èƒ½
  let large_number = 100000
  
  // è¿ç»­è¿ç®—æµ‹è¯•
  let sum_result = add(large_number, large_number)
  let product_result = multiply(large_number, 100)
  let division_result = divide_with_ceil(product_result, large_number)
  
  assert_eq(200000, sum_result)
  assert_eq(10000000, product_result)
  assert_eq(100, division_result)
}

test "advanced_business_logic_scenario" {
  // é«˜çº§ä¸šåŠ¡é€»è¾‘åœºæ™¯ï¼šç”Ÿäº§è®¡åˆ’ä¼˜åŒ–
  let total_orders = 487
  let machines = 8
  let production_per_machine_per_day = 15
  let days_available = 5
  
  // è®¡ç®—æ¯æ—¥æ€»äº§èƒ½
  let daily_capacity = multiply(machines, production_per_machine_per_day)
  
  // è®¡ç®—éœ€è¦çš„ç”Ÿäº§å¤©æ•°
  let days_needed = divide_with_ceil(total_orders, daily_capacity)
  
  // éªŒè¯èƒ½åœ¨å¯ç”¨æ—¶é—´å†…å®Œæˆ
  assert_true(days_needed <= days_available)
  
  // è®¡ç®—å®é™…ç”Ÿäº§å¤©æ•°
  let actual_days = days_needed
  assert_eq(5, actual_days)
  
  // è®¡ç®—æ€»äº§èƒ½
  let total_production = multiply(actual_days, daily_capacity)
  assert_eq(600, total_production)
  
  // è®¡ç®—å‰©ä½™äº§èƒ½
  let remaining_capacity = subtract(total_production, total_orders)
  assert_eq(113, remaining_capacity)
}

test "mathematical_sequence_calculations" {
  // æ•°å­¦åºåˆ—è®¡ç®—æµ‹è¯•
  let sequence_length = 10
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—å’Œï¼š1+2+3+...+10
  let arithmetic_sum = divide_with_ceil(
    multiply(sequence_length, add(sequence_length, 1)),
    2
  )
  assert_eq(55, arithmetic_sum)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—ï¼š2^1 + 2^2 + 2^3 + 2^4
  let geometric_sum = add(
    add(
      multiply(2, 1),  // 2^1
      multiply(2, 2)   // 2^2
    ),
    add(
      multiply(2, 4),  // 2^3
      multiply(2, 8)   // 2^4
    )
  )
  assert_eq(30, geometric_sum)
}

test "resource_allocation_with_constraints" {
  // å¸¦çº¦æŸçš„èµ„æºåˆ†é…æµ‹è¯•
  let total_budget = 50000
  let departments = 7
  let min_budget_per_dept = 5000
  
  // è®¡ç®—å¹³å‡åˆ†é…
  let avg_budget = divide_with_ceil(total_budget, departments)
  assert_eq(7143, avg_budget)
  
  // éªŒè¯æ¯ä¸ªéƒ¨é—¨éƒ½èƒ½è·å¾—æœ€ä½é¢„ç®—
  assert_true(avg_budget >= min_budget_per_dept)
  
  // è®¡ç®—å®é™…åˆ†é…æ€»é¢
  let total_allocated = multiply(avg_budget, departments)
  assert_eq(50001, total_allocated)
  
  // è®¡ç®—é¢„ç®—æº¢å‡º
  let budget_overflow = subtract(total_allocated, total_budget)
  assert_eq(1, budget_overflow)
}

test "error_resilience_and_recovery" {
  // é”™è¯¯æ¢å¤å’Œå¼¹æ€§æµ‹è¯•
  // æµ‹è¯•å„ç§é”™è¯¯è¾“å…¥çš„å¤„ç†
  
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå°é™¤æ•°æµ‹è¯•
  assert_eq(100000, divide_with_ceil(99999, 1))
  assert_eq(-99999, divide_with_ceil(-99999, 1))
  
  // æ··åˆç¬¦å·è¿ç®—
  let mixed_result = add(
    multiply(-5, 10),
    divide_with_ceil(15, -3)
  )
  assert_eq(-60, mixed_result)  // -5*10 + ceil(15/-3) = -50 + (-5) = -55
}

test "data_transformation_pipeline" {
  // æ•°æ®è½¬æ¢æµæ°´çº¿æµ‹è¯•
  let raw_data = 12345
  
  // æ•°æ®å¤„ç†æ­¥éª¤
  let step1_normalized = divide_with_ceil(raw_data, 1000)      // æ ‡å‡†åŒ–
  let step2_scaled = multiply(step1_normalized, 3)             // ç¼©æ”¾
  let step3_adjusted = add(step2_scaled, 10)                   // è°ƒæ•´
  let step4_final = divide_with_ceil(step3_adjusted, 5)        // æœ€ç»ˆå¤„ç†
  
  // éªŒè¯è½¬æ¢ç»“æœ
  assert_eq(13, step4_final)  // ceil(ceil(12345/1000)*3+10)/5 = ceil(13*3+10)/5 = ceil(49/5) = 10
  
  // éªŒè¯è½¬æ¢çš„åˆç†æ€§
  assert_true(step4_final > 0)
  assert_true(step4_final < 100)
}

test "complex_conditional_calculations" {
  // å¤æ‚æ¡ä»¶è®¡ç®—æµ‹è¯•
  let base_value = 42
  let multiplier = 3
  let threshold = 100
  
  // æ¡ä»¶è®¡ç®—ï¼šå¦‚æœç»“æœè¶…è¿‡é˜ˆå€¼ï¼Œåˆ™è¿›è¡Œç‰¹æ®Šå¤„ç†
  let initial_result = multiply(base_value, multiplier)
  let final_result = if (initial_result > threshold) {
    divide_with_ceil(initial_result, 10)
  } else {
    add(initial_result, 10)
  }
  
  // éªŒè¯æ¡ä»¶é€»è¾‘
  assert_eq(13, final_result)  // 42*3 = 126 > 100, æ‰€ä»¥æ‰§è¡Œ ceil(126/10) = 13
  
  // æµ‹è¯•å¦ä¸€ç§æƒ…å†µ
  let small_value = 20
  let small_result = if (small_value > threshold) {
    divide_with_ceil(small_value, 10)
  } else {
    add(small_value, 10)
  }
  
  assert_eq(30, small_result)  // 20 <= 100, æ‰€ä»¥æ‰§è¡Œ 20+10 = 30
}