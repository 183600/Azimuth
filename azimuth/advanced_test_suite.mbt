// æ–°çš„é«˜çº§ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºæ€§èƒ½ã€è¾¹ç•Œæ¡ä»¶å’Œå®é™…åº”ç”¨åœºæ™¯

test "performance_stress_test" {
  // æ€§èƒ½å‹åŠ›æµ‹è¯•ï¼šå¤§é‡è¿ç»­æ“ä½œ
  let base = 1000
  
  // è¿ç»­åŠ æ³•æ“ä½œ
  let mut sum = 0
  for i = 1; i <= 100; i = i + 1 {
    sum = add(sum, i)
  }
  assert_eq(5050, sum)
  
  // è¿ç»­ä¹˜æ³•æ“ä½œ
  let mut product = 1
  for i = 1; i <= 5; i = i + 1 {
    product = multiply(product, i)
  }
  assert_eq(120, product)
  
  // æ··åˆè¿ç»­æ“ä½œ
  let mut result = base
  for i = 1; i <= 10; i = i + 1 {
    result = add(multiply(result, 2), divide_with_ceil(i, 3))
  }
  assert_eq(2047020, result)
}

test "extreme_boundary_combinations" {
  // æç«¯è¾¹ç•Œå€¼ç»„åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ç³»åˆ—è¿ç®—
  let result1 = add(max_val, min_val)
  let result2 = multiply(max_val, 0)
  let result3 = multiply(max_val, 1)
  let result4 = multiply(max_val, -1)
  
  assert_eq(-1, result1)
  assert_eq(0, result2)
  assert_eq(max_val, result3)
  assert_eq(-2147483647, result4)
  
  // æœ€å°å€¼ç³»åˆ—è¿ç®—
  let result5 = add(min_val, max_val)
  let result6 = multiply(min_val, 0)
  let result7 = multiply(min_val, 1)
  let result8 = multiply(min_val, -1)
  
  assert_eq(-1, result5)
  assert_eq(0, result6)
  assert_eq(min_val, result7)
  assert_eq(min_val, result8) // ç‰¹æ®Šæƒ…å†µï¼šæœ€å°å€¼ä¹˜ä»¥-1ä»ä¸ºæœ€å°å€¼
}

test "real_world_financial_calculations" {
  // å®é™…é‡‘èè®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—å¤åˆ©
  let principal = 10000  // æœ¬é‡‘
  let rate = 5           // åˆ©ç‡ 20% (1/5)
  let years = 3          // å¹´æ•°
  
  // è®¡ç®—å¤åˆ©ï¼šprincipal * (1 + rate)^years
  let year1 = add(principal, divide_with_ceil(multiply(principal, 1), rate))
  let year2 = add(year1, divide_with_ceil(multiply(year1, 1), rate))
  let year3 = add(year2, divide_with_ceil(multiply(year2, 1), rate))
  
  assert_eq(12000, year1)  // 10000 + 2000
  assert_eq(14400, year2)  // 12000 + 2400
  assert_eq(17280, year3)  // 14400 + 2880
  
  // åœºæ™¯ï¼šè®¡ç®—è´·æ¬¾åˆ†æœŸ
  let loan_amount = 50000
  let months = 12
  let monthly_payment = divide_with_ceil(loan_amount, months)
  let total_payment = multiply(monthly_payment, months)
  
  assert_eq(4167, monthly_payment)
  assert_eq(50004, total_payment)
}

test "advanced_string_processing" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’ŒUnicode
  assert_eq_string("Hello, \n\t\r\0!", greet("\n\t\r\0"))
  assert_eq_string("Hello, ğŸš€ğŸŒŸâ­!", greet("ğŸš€ğŸŒŸâ­"))
  assert_eq_string("Hello, æ•°å­¦å…¬å¼âˆ‘âˆâˆ«!", greet("æ•°å­¦å…¬å¼âˆ‘âˆâˆ«"))
  assert_eq_string("Hello, Mixed123ABC!", greet("Mixed123ABC"))
  assert_eq_string("Hello, Special@#$%!", greet("Special@#$%"))
  
  // æµ‹è¯•ç©ºæ ¼å’Œåˆ¶è¡¨ç¬¦ç»„åˆ
  assert_eq_string("Hello, \t   \t!", greet("\t   \t"))
  assert_eq_string("Hello, \n\n\n!", greet("\n\n\n"))
  
  // æµ‹è¯•å¼•å·å’Œè½¬ä¹‰å­—ç¬¦
  assert_eq_string("Hello, \"\'!", greet("\"\'"))
}

test "mathematical_sequence_validation" {
  // æ•°å­¦åºåˆ—éªŒè¯æµ‹è¯•
  // æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)
  let fib4 = add(fib2, fib3)
  let fib5 = add(fib3, fib4)
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  
  // é˜¶ä¹˜è®¡ç®—
  let fact1 = 1
  let fact2 = multiply(fact1, 2)
  let fact3 = multiply(fact2, 3)
  let fact4 = multiply(fact3, 4)
  let fact5 = multiply(fact4, 5)
  
  assert_eq(2, fact2)
  assert_eq(6, fact3)
  assert_eq(24, fact4)
  assert_eq(120, fact5)
  
  // å¹‚è¿ç®—ï¼ˆé€šè¿‡é‡å¤ä¹˜æ³•ï¼‰
  let power2_3 = multiply(multiply(2, 2), 2)
  let power3_4 = multiply(multiply(multiply(3, 3), 3), 3)
  
  assert_eq(8, power2_3)
  assert_eq(81, power3_4)
}

test "error_boundary_and_recovery" {
  // é”™è¯¯è¾¹ç•Œå’Œæ¢å¤æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è§¦å‘å„ç§æº¢å‡ºæƒ…å†µ
  let overflow1 = add(max_val, 1000)
  let overflow2 = add(min_val, -1000)
  let overflow3 = multiply(max_val, 100)
  let overflow4 = multiply(min_val, 100)
  let overflow5 = multiply(-1, min_val)
  
  // éªŒè¯æº¢å‡ºåçš„æ­£å¸¸æ“ä½œ
  let normal1 = add(100, 200)
  let normal2 = multiply(10, 20)
  let normal3 = divide_with_ceil(25, 4)
  let normal4 = greet("Recovery")
  
  assert_eq(max_val, overflow1)
  assert_eq(min_val, overflow2)
  assert_eq(max_val, overflow3)
  assert_eq(min_val, overflow4)
  assert_eq(min_val, overflow5)
  
  assert_eq(300, normal1)
  assert_eq(200, normal2)
  assert_eq(7, normal3)
  assert_eq_string("Hello, Recovery!", normal4)
}

test "precision_and_accuracy_validation" {
  // ç²¾åº¦å’Œå‡†ç¡®æ€§éªŒè¯æµ‹è¯•
  // é™¤æ³•ç²¾åº¦æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(2, 2))
  assert_eq(1, divide_with_ceil(3, 3))
  assert_eq(1, divide_with_ceil(100, 100))
  
  // å°æ•°ç²¾åº¦æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(1, divide_with_ceil(2, 3))
  assert_eq(1, divide_with_ceil(3, 4))
  assert_eq(1, divide_with_ceil(4, 5))
  
  // å¤§æ•°ç²¾åº¦æµ‹è¯•
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(500000, divide_with_ceil(1000000, 2))
  assert_eq(333334, divide_with_ceil(1000000, 3))
  assert_eq(250000, divide_with_ceil(1000000, 4))
  
  // è´Ÿæ•°ç²¾åº¦æµ‹è¯•
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-1, divide_with_ceil(-2, 3))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(-2, divide_with_ceil(-5, 3))
}

test "complex_business_logic" {
  // å¤æ‚ä¸šåŠ¡é€»è¾‘æµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•è®¡ç®—
  let item_price = 199
  let quantity = 3
  let shipping_fee = 50
  let tax_rate = 10  // 10% ç¨ç‡ (1/10)
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(item_price, quantity)
  assert_eq(597, subtotal)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(subtotal, tax_rate)
  assert_eq(60, tax_amount)
  
  // è®¡ç®—æœ€ç»ˆæ€»ä»·
  let total_before_shipping = add(subtotal, tax_amount)
  let final_total = add(total_before_shipping, shipping_fee)
  
  assert_eq(657, total_before_shipping)
  assert_eq(707, final_total)
  
  // åœºæ™¯ï¼šåº“å­˜ç®¡ç†
  let initial_stock = 1000
  let sales = multiply(50, 3)  // 50ä¸ªå•ä½ï¼Œå–3æ¬¡
  let returns = 15
  let new_stock = 200
  
  let current_stock = add(subtract(initial_stock, sales), returns)
  let final_stock = add(current_stock, new_stock)
  
  assert_eq(150, sales)
  assert_eq(865, current_stock)
  assert_eq(1065, final_stock)
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•ï¼ˆé€šè¿‡åŠ è´Ÿæ•°å®ç°ï¼‰
fn subtract(a : Int, b : Int) -> Int {
  add(a, multiply(b, -1))
}