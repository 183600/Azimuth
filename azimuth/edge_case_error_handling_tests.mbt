// Edge Case Error Handling Tests - è¾¹ç•Œæƒ…å†µé”™è¯¯å¤„ç†æµ‹è¯•
// ä¸“æ³¨äºé¥æµ‹ç³»ç»Ÿä¸­çš„è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯æ¡ä»¶å¤„ç†

test "ç©ºå€¼å’ŒNoneè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå€¼å’ŒNoneæƒ…å†µä¸‹çš„é¥æµ‹æ“ä½œ
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "edge.case.test")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²spanåç§°
  let empty_name_span = Tracer::start_span(tracer, "")
  assert_true(Span::is_recording(empty_name_span))
  Span::end(empty_name_span)
  
  // æµ‹è¯•Noneå±æ€§å€¼
  let span = Tracer::start_span(tracer, "edge.test.span")
  
  // è®¾ç½®Noneå±æ€§å€¼åº”è¯¥è¢«æ­£ç¡®å¤„ç†
  Span::set_attribute(span, "empty.string", StringValue(""))
  Span::set_attribute(span, "zero.int", IntValue(0))
  Span::set_attribute(span, "zero.float", FloatValue(0.0))
  Span::set_attribute(span, "false.bool", BoolValue(false))
  
  // æµ‹è¯•ç©ºæ•°ç»„å±æ€§
  Span::set_attribute(span, "empty.array", ArrayStringValue([]))
  Span::set_attribute(span, "empty.int.array", ArrayIntValue([]))
  
  // éªŒè¯å±æ€§è®¾ç½®ä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_true(Span::is_recording(span))
  Span::end(span)
  
  // æµ‹è¯•ç©ºå±æ€§é›†åˆ
  let empty_attrs = Attributes::new()
  let span_with_empty_attrs = Tracer::start_span(tracer, "empty.attrs.span")
  Span::set_attributes(span_with_empty_attrs, empty_attrs)
  Span::end(span_with_empty_attrs)
  
  // æµ‹è¯•Loggerçš„Noneå€¼å¤„ç†
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "edge.case.logger")
  
  let empty_body_log = LogRecord::new(Info, None)
  Logger::emit(logger, empty_body_log)
  
  let empty_attrs_log = LogRecord::new_with_context(
    Warn,
    Some("Warning with empty attrs"),
    None,
    None,
    None,
    None,
    None,
    None
  )
  Logger::emit(logger, empty_attrs_log)
  
  // æµ‹è¯•Meterçš„Noneå€¼å¤„ç†
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "edge.case.meter")
  
  let empty_name_counter = Meter::create_counter(meter, "", None, None)
  Counter::add(empty_name_counter, 1.0, None)
  
  let counter = Meter::create_counter(meter, "test.counter")
  Counter::add(counter, 0.0, None)  // é›¶å€¼
  Counter::add(counter, -1.0, None) // è´Ÿå€¼
  
  assert_true(true)
}

test "æå€¼å’Œæº¢å‡ºè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æå€¼å’Œæº¢å‡ºæƒ…å†µä¸‹çš„é¥æµ‹æ“ä½œ
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "extreme.value.test")
  
  let span = Tracer::start_span(tracer, "extreme.values.span")
  
  // æµ‹è¯•æå€¼æ•´æ•°
  Span::set_attribute(span, "max.int32", IntValue(2147483647))
  Span::set_attribute(span, "min.int32", IntValue(-2147483648))
  Span::set_attribute(span, "max.int64", IntValue(9223372036854775807L))
  Span::set_attribute(span, "min.int64", IntValue(-9223372036854775808L))
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°
  Span::set_attribute(span, "max.float", FloatValue(1.7976931348623157e+308))
  Span::set_attribute(span, "min.float", FloatValue(-1.7976931348623157e+308))
  Span::set_attribute(span, "positive.infinity", FloatValue(1.0/0.0))
  Span::set_attribute(span, "negative.infinity", FloatValue(-1.0/0.0))
  Span::set_attribute(span, "nan.value", FloatValue(0.0/0.0))
  
  // æµ‹è¯•æå€¼å­—ç¬¦ä¸²
  let very_long_string = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨æ¥æµ‹è¯•ç³»ç»Ÿåœ¨å¤„ç†æé•¿å­—ç¬¦ä¸²æ—¶çš„ç¨³å®šæ€§å’Œæ€§èƒ½ã€‚" +
    "è¿™ä¸ªå­—ç¬¦ä¸²åŒ…å«äº†å¾ˆå¤šå†…å®¹ï¼ŒåŒ…æ‹¬ä¸­æ–‡ã€Englishã€æ•°å­—123456ã€ç‰¹æ®Šç¬¦å·!@#$%^&*()ç­‰ã€‚" +
    "é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥éªŒè¯ç³»ç»Ÿåœ¨å„ç§è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡¨ç°æ˜¯å¦æ­£å¸¸ã€‚" +
    "è¿™å¯¹äºç¡®ä¿é¥æµ‹ç³»ç»Ÿçš„å¯é æ€§å’Œç¨³å®šæ€§éå¸¸é‡è¦ã€‚"
  
  Span::set_attribute(span, "very.long.string", StringValue(very_long_string))
  
  // æµ‹è¯•Unicodeå’Œç‰¹æ®Šå­—ç¬¦
  Span::set_attribute(span, "unicode.chars", StringValue("æµ‹è¯•ä¸­æ–‡ğŸš€âœ¨ğŸ’¡ğŸ¯"))
  Span::set_attribute(span, "special.chars", StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  Span::set_attribute(span, "control.chars", StringValue("Tab:\t Newline:\n Return:\r"))
  
  // æµ‹è¯•æå€¼æ•°ç»„
  let large_string_array = []
  for i = 0; i < 100; i = i + 1 {
    large_string_array.push("item." + i.to_string())
  }
  Span::set_attribute(span, "large.array", ArrayStringValue(large_string_array))
  
  let large_int_array = []
  for i = 0; i < 100; i = i + 1 {
    large_int_array.push(i * 1000)
  }
  Span::set_attribute(span, "large.int.array", ArrayIntValue(large_int_array))
  
  Span::end(span)
  
  // æµ‹è¯•Metricsçš„æå€¼
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "extreme.metrics")
  
  let counter = Meter::create_counter(meter, "extreme.counter")
  Counter::add(counter, 1.7976931348623157e+308) // æœ€å¤§æµ®ç‚¹æ•°
  Counter::add(counter, -1.7976931348623157e+308) // æœ€å°æµ®ç‚¹æ•°
  
  let histogram = Meter::create_histogram(meter, "extreme.histogram")
  Histogram::record(histogram, 1.7976931348623157e+308)
  Histogram::record(histogram, -1.7976931348623157e+308)
  Histogram::record(histogram, 0.0/0.0) // NaN
  
  assert_true(true)
}

test "å¹¶å‘å’Œç«æ€æ¡ä»¶è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å¹¶å‘æ“ä½œå’Œç«æ€æ¡ä»¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrent.edge.test")
  
  // åˆ›å»ºå¤šä¸ªå¹¶å‘span
  let spans = []
  for i = 0; i < 50; i = i + 1 {
    let span = Tracer::start_span(tracer, "concurrent.span." + i.to_string())
    spans.push(span)
  }
  
  // å¹¶å‘è®¾ç½®å±æ€§
  for i = 0; i < spans.length(); i = i + 1 {
    let span = spans[i]
    Span::set_attribute(span, "concurrent.index", IntValue(i))
    Span::set_attribute(span, "thread.id", StringValue("thread." + (i % 5).to_string()))
  }
  
  // å¹¶å‘æ·»åŠ äº‹ä»¶
  for i = 0; i < spans.length(); i = i + 1 {
    let span = spans[i]
    Span::add_event(span, "concurrent.event", Some([
      ("event.id", StringValue("event-" + i.to_string())),
      ("timestamp", IntValue(1735689600000000000L + i.to_int64()))
    ]))
  }
  
  // å¹¶å‘è®¾ç½®çŠ¶æ€
  for i = 0; i < spans.length(); i = i + 1 {
    let span = spans[i]
    if i % 3 == 0 {
      Span::set_status(span, Ok)
    } else if i % 3 == 1 {
      Span::set_status(span, Error, Some("Concurrent error " + i.to_string()))
    } else {
      // ä¿æŒUnsetçŠ¶æ€
    }
  }
  
  // å¹¶å‘ç»“æŸspan
  for span in spans {
    Span::end(span)
  }
  
  // æµ‹è¯•å¹¶å‘Attributesæ“ä½œ
  let shared_attrs = Attributes::new()
  for i = 0; i < 100; i = i + 1 {
    let key = "concurrent.key." + i.to_string()
    let value = "concurrent.value." + i.to_string()
    Attributes::set(shared_attrs, key, StringValue(value))
  }
  
  // æµ‹è¯•å¹¶å‘Baggageæ“ä½œ
  let shared_baggage = Baggage::new()
  for i = 0; i < 50; i = i + 1 {
    let key = "baggage.key." + i.to_string()
    let value = "baggage.value." + i.to_string()
    shared_baggage = Baggage::set_entry(shared_baggage, key, value)
  }
  
  // æµ‹è¯•å¹¶å‘Contextæ“ä½œ
  let root_ctx = Context::root()
  let contexts = []
  for i = 0; i < 25; i = i + 1 {
    let key = ContextKey::new("context.key." + i.to_string())
    let value = "context.value." + i.to_string()
    let ctx = Context::with_value(root_ctx, key, value)
    contexts.push(ctx)
  }
  
  assert_true(true)
}

test "èµ„æºè€—å°½å’Œæ¢å¤è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•èµ„æºè€—å°½æƒ…å†µä¸‹çš„é¥æµ‹æ“ä½œ
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "resource.exhaustion.test")
  
  // åˆ›å»ºå¤§é‡spanä»¥æµ‹è¯•èµ„æºç®¡ç†
  let many_spans = []
  for i = 0; i < 200; i = i + 1 {
    let span = Tracer::start_span(tracer, "resource.test.span." + i.to_string())
    
    // ä¸ºæ¯ä¸ªspanæ·»åŠ å¤§é‡å±æ€§
    Span::set_attribute(span, "span.index", IntValue(i))
    Span::set_attribute(span, "span.name", StringValue("resource.test.span." + i.to_string()))
    Span::set_attribute(span, "creation.time", IntValue(1735689600000000000L + i.to_int64()))
    
    // æ·»åŠ å¤šä¸ªäº‹ä»¶
    for j = 0; j < 5; j = j + 1 {
      Span::add_event(span, "event." + j.to_string(), Some([
        ("event.index", IntValue(j)),
        ("span.index", IntValue(i))
      ]))
    }
    
    many_spans.push(span)
  }
  
  // æ‰¹é‡ç»“æŸspanä»¥æµ‹è¯•èµ„æºé‡Šæ”¾
  for span in many_spans {
    Span::end(span)
  }
  
  // æµ‹è¯•å¤§é‡Attributesçš„åˆ›å»ºå’Œé”€æ¯
  let many_attrs = []
  for i = 0; i < 100; i = i + 1 {
    let attrs = Attributes::new()
    for j = 0; j < 10; j = j + 1 {
      let key = "attr." + j.to_string()
      let value = "value." + i.to_string() + "." + j.to_string()
      Attributes::set(attrs, key, StringValue(value))
    }
    many_attrs.push(attrs)
  }
  
  // æµ‹è¯•å¤§é‡Baggageçš„åˆ›å»ºå’Œé”€æ¯
  let many_baggages = []
  for i = 0; i < 50; i = i + 1 {
    let baggage = Baggage::new()
    for j = 0; j < 20; j = j + 1 {
      let key = "baggage." + j.to_string()
      let value = "value." + i.to_string() + "." + j.to_string()
      baggage = Baggage::set_entry(baggage, key, value)
    }
    many_baggages.push(baggage)
  }
  
  // æµ‹è¯•å¤§é‡LogRecordçš„åˆ›å»ºå’Œå¤„ç†
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "resource.test.logger")
  
  for i = 0; i < 100; i = i + 1 {
    let log = LogRecord::new_with_context(
      if i % 5 == 0 { Error } else if i % 3 == 0 { Warn } else { Info },
      Some("Resource test log " + i.to_string()),
      Some(Attributes::with_attributes(Attributes::new(), [
        ("log.index", IntValue(i)),
        ("log.type", StringValue("resource.test"))
      ])),
      Some(1735689600000000000L + i.to_int64()),
      Some(1735689600000000001L + i.to_int64()),
      Some("trace-" + i.to_string()),
      Some("span-" + i.to_string()),
      Some(Context::root())
    )
    Logger::emit(logger, log)
  }
  
  // æµ‹è¯•å¤§é‡Metricsçš„åˆ›å»ºå’Œè®°å½•
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "resource.test.meter")
  
  let counters = []
  for i = 0; i < 20; i = i + 1 {
    let counter = Meter::create_counter(meter, "resource.counter." + i.to_string())
    counters.push(counter)
  }
  
  // ä¸ºæ¯ä¸ªcounterè®°å½•å¤§é‡æ•°æ®
  for i = 0; i < counters.length(); i = i + 1 {
    let counter = counters[i]
    for j = 0; j < 100; j = j + 1 {
      Counter::add(counter, j.to_double(), Some(Attributes::with_attributes(Attributes::new(), [
        ("counter.index", IntValue(i)),
        ("measurement.index", IntValue(j))
      ])))
    }
  }
  
  assert_true(true)
}

test "æ— æ•ˆè¾“å…¥å’Œæ ¼å¼è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•æ— æ•ˆè¾“å…¥å’Œæ ¼å¼çš„å¤„ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "invalid.input.test")
  
  // æµ‹è¯•æ— æ•ˆçš„spanåç§°
  let invalid_names = [
    "",  // ç©ºå­—ç¬¦ä¸²
    " ", // åªæœ‰ç©ºæ ¼
    "\t\n\r", // åªæœ‰æ§åˆ¶å­—ç¬¦
    "span/name/with/slashes", // åŒ…å«æ–œæ 
    "span.name.with.dots", // åŒ…å«ç‚¹å·
    "span name with spaces", // åŒ…å«ç©ºæ ¼
    "span@name#with$special%chars", // åŒ…å«ç‰¹æ®Šå­—ç¬¦
    "ä¸­æ–‡åç§°.span", // åŒ…å«ä¸­æ–‡
    StringValue("a".repeat(1000)) // è¶…é•¿åç§°
  ]
  
  for name in invalid_names {
    let span = Tracer::start_span(tracer, name)
    Span::set_attribute(span, "original.name", StringValue(name))
    Span::end(span)
  }
  
  // æµ‹è¯•æ— æ•ˆçš„å±æ€§é”®å’Œå€¼
  let span = Tracer::start_span(tracer, "invalid.attrs.test")
  
  let invalid_keys = [
    "",  // ç©ºé”®
    " ", // åªæœ‰ç©ºæ ¼çš„é”®
    "key.with.dots", // åŒ…å«ç‚¹çš„é”®
    "key/with/slashes", // åŒ…å«æ–œæ çš„é”®
    "key with spaces", // åŒ…å«ç©ºæ ¼çš„é”®
    "é”®å.ä¸­æ–‡", // ä¸­æ–‡é”®å
    StringValue("k".repeat(500)) // è¶…é•¿é”®å
  ]
  
  for key in invalid_keys {
    Span::set_attribute(span, key, StringValue("test.value"))
  }
  
  // æµ‹è¯•æ— æ•ˆçš„å±æ€§å€¼
  let valid_keys = ["empty.string", "normal.string", "unicode.string", "special.chars"]
  let invalid_values = [
    StringValue(""),
    StringValue(" "),
    StringValue("\t\n\r"),
    StringValue("æµ‹è¯•ä¸­æ–‡ğŸš€âœ¨"),
    StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"),
    StringValue("a".repeat(10000))
  ]
  
  for i = 0; i < valid_keys.length(); i = i + 1 {
    if i < invalid_values.length() {
      Span::set_attribute(span, valid_keys[i], invalid_values[i])
    }
  }
  
  Span::end(span)
  
  // æµ‹è¯•æ— æ•ˆçš„Contexté”®
  let root_ctx = Context::root()
  let invalid_context_keys = [
    "",  // ç©ºé”®
    " ", // åªæœ‰ç©ºæ ¼
    "key.with.special@chars",
    "ä¸­æ–‡å­—ç¬¦é”®",
    StringValue("k".repeat(200))
  ]
  
  for key_name in invalid_context_keys {
    let key = ContextKey::new(key_name)
    let ctx = Context::with_value(root_ctx, key, "test.value")
    // éªŒè¯æ“ä½œä¸ä¼šå´©æºƒ
    assert_true(true)
  }
  
  // æµ‹è¯•æ— æ•ˆçš„Baggageæ¡ç›®
  let baggage = Baggage::new()
  let invalid_baggage_keys = [
    "",  // ç©ºé”®
    " ", // åªæœ‰ç©ºæ ¼
    "key=with=equals",
    "key,with,commas",
    "ä¸­æ–‡å­—ç¬¦é”®",
    StringValue("k".repeat(100))
  ]
  
  for key in invalid_baggage_keys {
    baggage = Baggage::set_entry(baggage, key, "test.value")
  }
  
  let invalid_baggage_values = [
    "",  // ç©ºå€¼
    " ", // åªæœ‰ç©ºæ ¼
    "value=with=equals",
    "value,with,commas",
    "å€¼åŒ…å«ä¸­æ–‡",
    StringValue("v".repeat(1000))
  ]
  
  for i = 0; i < invalid_baggage_keys.length() && i < invalid_baggage_values.length(); i = i + 1 {
    baggage = Baggage::set_entry(baggage, invalid_baggage_keys[i], invalid_baggage_values[i])
  }
  
  // æµ‹è¯•æ— æ•ˆçš„Resourceå±æ€§
  let resource = Resource::new()
  let invalid_resource_attrs = []
  
  for i = 0; i < invalid_keys.length() && i < invalid_values.length(); i = i + 1 {
    invalid_resource_attrs.push((invalid_keys[i], invalid_values[i]))
  }
  
  let resource_with_invalid = Resource::with_attributes(resource, invalid_resource_attrs)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½ä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_true(true)
}

test "å†…å­˜æ³„æ¼å’Œèµ„æºæ¸…ç†è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å†…å­˜æ³„æ¼å’Œèµ„æºæ¸…ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "memory.leak.test")
  
  // åˆ›å»ºå’Œé”€æ¯å¤§é‡å¯¹è±¡ä»¥æµ‹è¯•å†…å­˜ç®¡ç†
  for round = 0; round < 5; round = round + 1 {
    // åˆ›å»ºå¤§é‡span
    let spans = []
    for i = 0; i < 100; i = i + 1 {
      let span = Tracer::start_span(tracer, "memory.test.span." + i.to_string())
      
      // æ·»åŠ å¤§é‡å±æ€§
      for j = 0; j < 10; j = j + 1 {
        Span::set_attribute(span, "attr." + j.to_string(), StringValue("value." + i.to_string() + "." + j.to_string()))
      }
      
      // æ·»åŠ å¤§é‡äº‹ä»¶
      for j = 0; j < 5; j = j + 1 {
        Span::add_event(span, "event." + j.to_string(), Some([
          ("event.data", StringValue("data." + i.to_string() + "." + j.to_string()))
        ]))
      }
      
      spans.push(span)
    }
    
    // ç»“æŸæ‰€æœ‰span
    for span in spans {
      Span::end(span)
    }
    
    // åˆ›å»ºå¤§é‡Attributes
    let attrs_list = []
    for i = 0; i < 50; i = i + 1 {
      let attrs = Attributes::new()
      for j = 0; j < 20; j = j + 1 {
        Attributes::set(attrs, "key." + j.to_string(), StringValue("value." + i.to_string() + "." + j.to_string()))
      }
      attrs_list.push(attrs)
    }
    
    // åˆ›å»ºå¤§é‡Baggage
    let baggages = []
    for i = 0; i < 25; i = i + 1 {
      let baggage = Baggage::new()
      for j = 0; j < 15; j = j + 1 {
        baggage = Baggage::set_entry(baggage, "key." + j.to_string(), "value." + i.to_string() + "." + j.to_string())
      }
      baggages.push(baggage)
    }
    
    // åˆ›å»ºå¤§é‡Context
    let contexts = []
    for i = 0; i < 30; i = i + 1 {
      let ctx = Context::root()
      for j = 0; j < 10; j = j + 1 {
        let key = ContextKey::new("key." + j.to_string())
        ctx = Context::with_value(ctx, key, "value." + i.to_string() + "." + j.to_string())
      }
      contexts.push(ctx)
    }
    
    // åˆ›å»ºå¤§é‡LogRecord
    let logger_provider = LoggerProvider::default()
    let logger = LoggerProvider::get_logger(logger_provider, "memory.test.logger")
    
    for i = 0; i < 50; i = i + 1 {
      let attrs = Attributes::new()
      for j = 0; j < 5; j = j + 1 {
        Attributes::set(attrs, "log.attr." + j.to_string(), StringValue("log.value." + i.to_string() + "." + j.to_string()))
      }
      
      let log = LogRecord::new_with_context(
        Info,
        Some("Memory test log " + i.to_string()),
        Some(attrs),
        Some(1735689600000000000L + i.to_int64()),
        Some(1735689600000000001L + i.to_int64()),
        Some("trace-" + i.to_string()),
        Some("span-" + i.to_string()),
        Some(Context::root())
      )
      Logger::emit(logger, log)
    }
    
    // åˆ›å»ºå¤§é‡Metrics
    let meter_provider = MeterProvider::default()
    let meter = MeterProvider::get_meter(meter_provider, "memory.test.meter")
    
    let counters = []
    for i = 0; i < 10; i = i + 1 {
      let counter = Meter::create_counter(meter, "memory.counter." + i.to_string())
      counters.push(counter)
    }
    
    for i = 0; i < counters.length(); i = i + 1 {
      let counter = counters[i]
      for j = 0; j < 50; j = j + 1 {
        Counter::add(counter, j.to_double())
      }
    }
  }
  
  // éªŒè¯æ‰€æœ‰æ“ä½œå®Œæˆä¸”æ²¡æœ‰å´©æºƒ
  assert_true(true)
}