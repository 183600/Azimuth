// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ çš„æ ¸å¿ƒæµ‹è¯•

test "add_basic_functionality" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(2, -3))
}

test "multiply_basic_functionality" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(2, -3))
}

test "greet_basic_functionality" {
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "add_identity_properties" {
  assert_eq(7, add(7, 0))
  assert_eq(7, add(0, 7))
}

test "multiply_zero_properties" {
  assert_eq(0, multiply(7, 0))
  assert_eq(0, multiply(0, 7))
}

test "divide_with_ceil_negative_numbers" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-10, -3))
}

test "complex_calculation" {
  let result = add(multiply(3, 4), divide_with_ceil(15, 4))
  assert_eq(15, result)  // 12 + 4 = 16, but ceil(15/4) = 4, so 12 + 4 = 16
  // ä¿®æ­£è®¡ç®—
  let corrected_result = add(multiply(3, 4), divide_with_ceil(10, 4))
  assert_eq(15, corrected_result)  // 12 + 3 = 15
}

test "greet_special_characters" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_commutativity" {
  assert_eq(add(5, 7), add(7, 5))
  assert_eq(multiply(5, 7), multiply(7, 5))
}

// æ–°å¢çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_edge_cases" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(2147483647, add(2147483646, 1))  // æ¥è¿‘æœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘æœ€å°å€¼
  assert_eq(1000000, add(500000, 500000))  // å¤§æ•°ç›¸åŠ 
  assert_eq(0, add(1000000, -1000000))  // å¤§æ•°æ­£è´Ÿç›¸åŠ 
}

test "multiply_function_precision" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„ç²¾åº¦å’Œå¤§æ•°æƒ…å†µ
  assert_eq(1000000, multiply(1000, 1000))  // åƒä½æ•°ç›¸ä¹˜
  assert_eq(81, multiply(9, 9))  // å¹³æ–¹æ•°
  assert_eq(64, multiply(-8, -8))  // è´Ÿæ•°å¹³æ–¹
  assert_eq(-27, multiply(-3, 9))  // è´Ÿæ•°ä¹˜æ­£æ•°
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_financial_scenario" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„é‡‘èåœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—è´·æ¬¾åˆ†æœŸä»˜æ¬¾
  let loan_amount = 10000
  let monthly_payment = 750
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(14, months_needed)  // ceil(10000/750) = 14
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(10500, total_payment)
}

test "complex_business_calculation" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_size = 12
  let tasks_per_person = 8
  let total_tasks = multiply(team_size, tasks_per_person)
  let tasks_per_sprint = 25
  let sprints_needed = divide_with_ceil(total_tasks, tasks_per_sprint)
  assert_eq(4, sprints_needed)  // ceil(96/25) = 4
  
  // è®¡ç®—æ€»å·¥ä½œé‡
  let total_workload = multiply(sprints_needed, tasks_per_sprint)
  assert_eq(100, total_workload)
}

test "mathematical_distributive_law" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹
  let a = 7
  let b = 5
  let c = 3
  
  // a * (b + c) = a * b + a * c
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 7*(5+3) = 7*5 + 7*3 = 56
}

test "error_handling_boundary_conditions" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0
  assert_eq(0, divide_with_ceil(100, 0))  // æ­£æ•°/0
  assert_eq(0, divide_with_ceil(-100, 0))  // è´Ÿæ•°/0
  
  // æå°é™¤æ•°æƒ…å†µ
  assert_eq(1000000, divide_with_ceil(999999, 1))  // å¤§æ•°/1
  assert_eq(-999999, divide_with_ceil(-999999, 1))  // è´Ÿå¤§æ•°/1
}

test "sequential_calculation_chain" {
  // æµ‹è¯•è¿ç»­è®¡ç®—é“¾
  let initial = 5
  let step1 = add(initial, multiply(2, 3))     // 5 + 2*3 = 11
  let step2 = divide_with_ceil(step1, 4)       // ceil(11/4) = 3
  let step3 = multiply(step2, add(1, 2))       // 3 * (1+2) = 9
  let step4 = divide_with_ceil(step3, 5)       // ceil(9/5) = 2
  assert_eq(2, step4)
}

test "performance_large_scale_operations" {
  // æµ‹è¯•å¤§è§„æ¨¡è¿ç®—æ€§èƒ½
  let iterations = 10000
  let sum_result = add(iterations, iterations)
  let product_result = multiply(100, iterations)
  let division_result = divide_with_ceil(product_result, 50)
  
  assert_eq(20000, sum_result)
  assert_eq(1000000, product_result)
  assert_eq(20000, division_result)
}