// è¾¹ç•Œæ¡ä»¶é”™è¯¯å¤„ç†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æƒ…å†µä¸‹çš„å¤„ç†èƒ½åŠ›

test "boundary_condition_empty_strings" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶
  let empty_trace_id = ""
  let empty_span_id = ""
  let empty_name = ""
  
  // åˆ›å»ºå¸¦æœ‰ç©ºå­—ç¬¦ä¸²çš„spanä¸Šä¸‹æ–‡
  let empty_span_ctx = SpanContext::new(empty_trace_id, empty_span_id, true, "")
  
  // éªŒè¯ç©ºå­—ç¬¦ä¸²å¤„ç†
  assert_eq(SpanContext::trace_id(empty_span_ctx), empty_trace_id)
  assert_eq(SpanContext::span_id(empty_span_ctx), empty_span_id)
  assert_false(SpanContext::is_valid(empty_span_ctx))  // ç©ºå­—ç¬¦ä¸²åº”è¯¥ä½¿ä¸Šä¸‹æ–‡æ— æ•ˆ
  
  // åˆ›å»ºå¸¦æœ‰ç©ºåç§°çš„span
  let empty_span = Span::new(empty_name, Internal, empty_span_ctx)
  assert_eq(Span::name(empty_span), empty_name)
  
  // æµ‹è¯•å±æ€§ä¸­çš„ç©ºå­—ç¬¦ä¸²
  let attrs = Attributes::new()
  Attributes::set(attrs, "empty.key", StringValue(""))
  
  let empty_value = Attributes::get(attrs, "empty.key")
  match empty_value {
    Some(StringValue(value)) => assert_eq(value.length(), 0)
    _ => assert_false(true, "Expected empty StringValue")
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²æ—¥å¿—
  let empty_log = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_log), Some(""))
}

test "boundary_condition_null_values" {
  // æµ‹è¯•None/nullå€¼è¾¹ç•Œæ¡ä»¶
  let none_string : Option[String] = None
  let none_int : Option[Int] = None
  let none_float : Option[Double] = None
  let none_bool : Option[Bool] = None
  
  // æµ‹è¯•Noneå±æ€§å€¼
  let attrs = Attributes::new()
  
  // æµ‹è¯•Noneæ—¥å¿—è®°å½•
  let log_with_none_body = LogRecord::new_with_context(
    Info,
    none_string,
    None,
    None,
    None,
    None,
    None,
    None
  )
  
  assert_eq(LogRecord::body(log_with_none_body), None)
  
  // æµ‹è¯•Noneæ—¶é—´æˆ³
  let log_with_none_timestamp = LogRecord::new_with_context(
    Warn,
    Some("Test"),
    None,
    none_string.map(fn(s) { s.length().to_int64() }),
    None,
    None,
    None,
    None
  )
  
  assert_eq(log_with_none_timestamp.timestamp, None)
  
  // æµ‹è¯•Noneä¸Šä¸‹æ–‡
  let log_with_none_context = LogRecord::new_with_context(
    Error,
    Some("Error"),
    None,
    None,
    None,
    none_string,
    none_string,
    None
  )
  
  assert_eq(LogRecord::trace_id(log_with_none_context), None)
  assert_eq(LogRecord::span_id(log_with_none_context), None)
}

test "boundary_condition_extreme_values" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæ¡ä»¶
  let max_int = 2147483647
  let min_int = -2147483648
  let max_float = 1.7976931348623157e+308
  let min_float = -1.7976931348623157e+308
  let zero_float = 0.0
  
  // æµ‹è¯•æå€¼å±æ€§
  let attrs = Attributes::new()
  Attributes::set(attrs, "max.int", IntValue(max_int))
  Attributes::set(attrs, "min.int", IntValue(min_int))
  Attributes::set(attrs, "max.float", FloatValue(max_float))
  Attributes::set(attrs, "min.float", FloatValue(min_float))
  Attributes::set(attrs, "zero.float", FloatValue(zero_float))
  
  let retrieved_max_int = Attributes::get(attrs, "max.int")
  let retrieved_min_int = Attributes::get(attrs, "min.int")
  let retrieved_max_float = Attributes::get(attrs, "max.float")
  let retrieved_min_float = Attributes::get(attrs, "min.float")
  let retrieved_zero_float = Attributes::get(attrs, "zero.float")
  
  match retrieved_max_int {
    Some(IntValue(value)) => assert_eq(value, max_int)
    _ => assert_false(true, "Expected max IntValue")
  }
  
  match retrieved_min_int {
    Some(IntValue(value)) => assert_eq(value, min_int)
    _ => assert_false(true, "Expected min IntValue")
  }
  
  match retrieved_max_float {
    Some(FloatValue(value)) => assert_true(value > 1.0e+308)
    _ => assert_false(true, "Expected max FloatValue")
  }
  
  match retrieved_min_float {
    Some(FloatValue(value)) => assert_true(value < -1.0e+308)
    _ => assert_false(true, "Expected min FloatValue")
  }
  
  match retrieved_zero_float {
    Some(FloatValue(value)) => assert_eq(value, 0.0)
    _ => assert_false(true, "Expected zero FloatValue")
  }
  
  // æµ‹è¯•æå€¼æŒ‡æ ‡
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "extreme-values-meter")
  let counter = Meter::create_counter(meter, "extreme.counter")
  let histogram = Meter::create_histogram(meter, "extreme.histogram")
  
  Counter::add(counter, max_int.to_double())
  Histogram::record(histogram, max_float)
  Histogram::record(histogram, min_float)
}

test "boundary_condition_very_long_strings" {
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶
  let very_long_string = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" +
                        "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚"
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²ä½œä¸ºå±æ€§å€¼
  let attrs = Attributes::new()
  Attributes::set(attrs, "long.string", StringValue(very_long_string))
  
  let retrieved_long_string = Attributes::get(attrs, "long.string")
  match retrieved_long_string {
    Some(StringValue(value)) => {
      assert_true(value.length() > 200)  // ç¡®ä¿å­—ç¬¦ä¸²è¶³å¤Ÿé•¿
      assert_eq(value, very_long_string)
    }
    _ => assert_false(true, "Expected long StringValue")
  }
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²ä½œä¸ºspanåç§°
  let long_span_ctx = SpanContext::new("trace_001", "span_001", true, "")
  let long_span = Span::new(very_long_string, Internal, long_span_ctx)
  assert_eq(Span::name(long_span), very_long_string)
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²ä½œä¸ºæ—¥å¿—æ¶ˆæ¯
  let long_log = LogRecord::new(Info, very_long_string)
  assert_eq(LogRecord::body(long_log), Some(very_long_string))
}

test "boundary_condition_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦è¾¹ç•Œæ¡ä»¶
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~\n\t\r\\"
  let unicode_chars = "ç‰¹æ®Šå­—ç¬¦æµ‹è¯• Î±Î²Î³Î´ÎµÎ¶Î·Î¸ Ã±Ã¡Ã©Ã­Ã³Ãº ğŸŒŸğŸš€ğŸ’¡"
  let sql_injection = "'; DROP TABLE users; --"
  let xss_payload = "<script>alert('xss')</script>"
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ä½œä¸ºå±æ€§å€¼
  let attrs = Attributes::new()
  Attributes::set(attrs, "special.chars", StringValue(special_chars))
  Attributes::set(attrs, "unicode.chars", StringValue(unicode_chars))
  Attributes::set(attrs, "sql.injection", StringValue(sql_injection))
  Attributes::set(attrs, "xss.payload", StringValue(xss_payload))
  
  let retrieved_special = Attributes::get(attrs, "special.chars")
  let retrieved_unicode = Attributes::get(attrs, "unicode.chars")
  let retrieved_sql = Attributes::get(attrs, "sql.injection")
  let retrieved_xss = Attributes::get(attrs, "xss.payload")
  
  assert_eq(retrieved_special, Some(StringValue(special_chars)))
  assert_eq(retrieved_unicode, Some(StringValue(unicode_chars)))
  assert_eq(retrieved_sql, Some(StringValue(sql_injection)))
  assert_eq(retrieved_xss, Some(StringValue(xss_payload)))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ä½œä¸ºspanåç§°
  let special_span_ctx = SpanContext::new("trace_002", "span_002", true, "")
  let special_span = Span::new(special_chars, Internal, special_span_ctx)
  assert_eq(Span::name(special_span), special_chars)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦ä½œä¸ºæ—¥å¿—æ¶ˆæ¯
  let special_log = LogRecord::new(Warn, special_chars)
  assert_eq(LogRecord::body(special_log), Some(special_chars))
}

test "error_handling_invalid_operations" {
  // æµ‹è¯•æ— æ•ˆæ“ä½œé”™è¯¯å¤„ç†
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "error-test-meter")
  let counter = Meter::create_counter(meter, "error.test.counter")
  
  // æµ‹è¯•è´Ÿæ•°counterå€¼
  Counter::add(counter, -10.0)  // åº”è¯¥èƒ½å¤„ç†è´Ÿæ•°
  
  // æµ‹è¯•NaNå’Œæ— ç©·å¤§
  let nan_value = 0.0 / 0.0
  let inf_value = 1.0 / 0.0
  let neg_inf_value = -1.0 / 0.0
  
  Counter::add(counter, nan_value)  // åº”è¯¥èƒ½å¤„ç†NaN
  Counter::add(counter, inf_value)  // åº”è¯¥èƒ½å¤„ç†æ— ç©·å¤§
  Counter::add(counter, neg_inf_value)  // åº”è¯¥èƒ½å¤„ç†è´Ÿæ— ç©·å¤§
  
  // æµ‹è¯•histogramçš„æå€¼
  let histogram = Meter::create_histogram(meter, "error.test.histogram")
  Histogram::record(histogram, nan_value)
  Histogram::record(histogram, inf_value)
  Histogram::record(histogram, neg_inf_value)
  
  // æµ‹è¯•æ— æ•ˆçš„spanä¸Šä¸‹æ–‡
  let invalid_span_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(invalid_span_ctx))
  
  let invalid_span = Span::new("invalid.span", Internal, invalid_span_ctx)
  assert_eq(Span::name(invalid_span), "invalid.span")
  assert_false(SpanContext::is_valid(Span::span_context(invalid_span)))
}

test "error_handling_resource_constraints" {
  // æµ‹è¯•èµ„æºçº¦æŸé”™è¯¯å¤„ç†
  // åˆ›å»ºå¤§é‡èµ„æºæµ‹è¯•å†…å­˜ä½¿ç”¨
  let resources = []
  
  for i in 0..100 {
    let resource = Resource::new()
    let attrs = [
      ("resource.id", StringValue("resource_" + i.to_string())),
      ("resource.index", IntValue(i)),
      ("resource.data", StringValue("data_" + i.to_string()))
    ]
    let resource_with_attrs = Resource::with_attributes(resource, attrs)
    resources.push(resource_with_attrs)
  }
  
  // éªŒè¯èµ„æºåˆ›å»º
  assert_eq(resources.length(), 100)
  
  // éªŒè¯æ¯ä¸ªèµ„æºçš„å±æ€§
  for i in 0..resources.length() {
    let resource = resources[i]
    let resource_id = Resource::get_attribute(resource, "resource.id")
    let resource_index = Resource::get_attribute(resource, "resource.index")
    let resource_data = Resource::get_attribute(resource, "resource.data")
    
    match resource_id {
      Some(StringValue(id)) => assert_eq(id, "resource_" + i.to_string())
      _ => assert_false(true, "Expected resource.id")
    }
    
    match resource_index {
      Some(IntValue(index)) => assert_eq(index, i)
      _ => assert_false(true, "Expected resource.index")
    }
    
    match resource_data {
      Some(StringValue(data)) => assert_eq(data, "data_" + i.to_string())
      _ => assert_false(true, "Expected resource.data")
    }
  }
  
  // åˆ›å»ºå¤§é‡spanæµ‹è¯•
  let spans = []
  let trace_id = "resource_constraint_trace"
  
  for i in 0..100 {
    let span_ctx = SpanContext::new(trace_id, "span_" + i.to_string(), true, "")
    let span = Span::new("operation_" + i.to_string(), Internal, span_ctx)
    spans.push(span)
  }
  
  // éªŒè¯spanåˆ›å»º
  assert_eq(spans.length(), 100)
  
  // éªŒè¯æ¯ä¸ªspançš„å”¯ä¸€æ€§
  for i in 0..spans.length() {
    let span = spans[i]
    let span_ctx = Span::span_context(span)
    
    assert_eq(SpanContext::span_id(span_ctx), "span_" + i.to_string())
    assert_eq(Span::name(span), "operation_" + i.to_string())
    assert_true(SpanContext::is_valid(span_ctx))
  }
}

test "error_handling_corrupted_data" {
  // æµ‹è¯•æŸåæ•°æ®å¤„ç†
  // æµ‹è¯•åŒ…å«nullå­—ç¬¦çš„å­—ç¬¦ä¸²
  let string_with_null = "string_with_\0_null_character"
  
  let attrs = Attributes::new()
  Attributes::set(attrs, "null.string", StringValue(string_with_null))
  
  let retrieved_null_string = Attributes::get(attrs, "null.string")
  assert_eq(retrieved_null_string, Some(StringValue(string_with_null)))
  
  // æµ‹è¯•æ ¼å¼é”™è¯¯çš„trace_id
  let malformed_trace_id = "not-a-valid-trace-id"
  let malformed_span_id = "not-a-valid-span-id"
  
  let malformed_span_ctx = SpanContext::new(malformed_trace_id, malformed_span_id, true, "")
  
  // å³ä½¿æ ¼å¼é”™è¯¯ï¼Œç³»ç»Ÿä»åº”èƒ½å¤„ç†
  assert_eq(SpanContext::trace_id(malformed_span_ctx), malformed_trace_id)
  assert_eq(SpanContext::span_id(malformed_span_ctx), malformed_span_id)
  assert_true(SpanContext::is_sampled(malformed_span_ctx))
  
  // æµ‹è¯•åŒ…å«æ§åˆ¶å­—ç¬¦çš„å­—ç¬¦ä¸²
  let control_chars = "\x01\x02\x03\x04\x05\x06\x07\x08\x0B\x0C\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F"
  let control_char_log = LogRecord::new(Error, control_chars)
  
  assert_eq(LogRecord::body(control_char_log), Some(control_chars))
  assert_eq(LogRecord::severity_number(control_char_log), Error)
}