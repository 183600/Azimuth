// Advanced MoonBit Test Suite for Azimuth Telemetry System
// This file contains advanced test cases focusing on edge cases, error handling, and comprehensive scenarios

// Test 1: è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸å¤„ç†æµ‹è¯•
test "è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œnullå€¼å¤„ç†
  let empty_trace_id = ""
  let empty_span_id = ""
  let empty_ctx = SpanContext::new(empty_trace_id, empty_span_id, false, "")
  assert_false(SpanContext::is_valid(empty_ctx))
  
  // æµ‹è¯•æå¤§å€¼å¤„ç†
  let max_int_value = IntValue(9223372036854775807L)
  let min_int_value = IntValue(-9223372036854775808L)
  let max_float_value = FloatValue(1.7976931348623157e+308)
  let min_float_value = FloatValue(-1.7976931348623157e+308)
  
  let attrs = Attributes::new()
  Attributes::set(attrs, "max.int", max_int_value)
  Attributes::set(attrs, "min.int", min_int_value)
  Attributes::set(attrs, "max.float", max_float_value)
  Attributes::set(attrs, "min.float", min_float_value)
  
  // éªŒè¯æå€¼å±æ€§è®¾ç½®æˆåŠŸ
  assert_true(true)
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²å¤„ç†
  let long_string = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹è¶…é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" + 
                   "è¿™ä¸ªå­—ç¬¦ä¸²åŒ…å«äº†å¾ˆå¤šä¸­æ–‡å­—ç¬¦å’Œè‹±æ–‡å­—ç¬¦çš„æ··åˆï¼Œ" +
                   "ä»¥ç¡®ä¿ç³»ç»Ÿåœ¨ä¸åŒå­—ç¬¦ç¼–ç ä¸‹çš„ç¨³å®šæ€§ã€‚" +
                   "æˆ‘ä»¬è¿˜éœ€è¦æµ‹è¯•ä¸€äº›ç‰¹æ®Šå­—ç¬¦ï¼Œå¦‚ï¼š!@#$%^&*()_+-={}[]|\\:;\"'<>?,./" +
                   "ä»¥åŠä¸€äº›Unicodeå­—ç¬¦ï¼Œå¦‚ï¼šğŸš€ğŸ‰ğŸ”¥ğŸ’¯â­"
  
  Attributes::set(attrs, "long.string", StringValue(long_string))
  let retrieved_long = Attributes::get(attrs, "long.string")
  assert_true(retrieved_long.is_some())
}

// Test 2: æ•°æ®ç±»å‹è½¬æ¢å’ŒéªŒè¯æµ‹è¯•
test "æ•°æ®ç±»å‹è½¬æ¢å’ŒéªŒè¯æµ‹è¯•" {
  // æµ‹è¯•å„ç§æ•°æ®ç±»å‹çš„è½¬æ¢
  let attrs = Attributes::new()
  
  // å­—ç¬¦ä¸²åˆ°æ•°å­—çš„è½¬æ¢æµ‹è¯•
  Attributes::set(attrs, "numeric.string", StringValue("12345"))
  Attributes::set(attrs, "float.string", StringValue("3.14159"))
  Attributes::set(attrs, "boolean.string", StringValue("true"))
  Attributes::set(attrs, "invalid.number", StringValue("not_a_number"))
  
  // æ•°å­—åˆ°å­—ç¬¦ä¸²çš„è½¬æ¢æµ‹è¯•
  Attributes::set(attrs, "int.value", IntValue(42))
  Attributes::set(attrs, "float.value", FloatValue(3.14159))
  Attributes::set(attrs, "bool.value", BoolValue(true))
  
  // æµ‹è¯•æ•°ç»„ç±»å‹
  Attributes::set(attrs, "string.array", ArrayStringValue(["item1", "item2", "item3"]))
  Attributes::set(attrs, "int.array", ArrayIntValue([1, 2, 3, 4, 5]))
  Attributes::set(attrs, "float.array", ArrayFloatValue([1.1, 2.2, 3.3]))
  Attributes::set(attrs, "bool.array", ArrayBoolValue([true, false, true]))
  
  // æµ‹è¯•æ··åˆç±»å‹æ•°ç»„
  Attributes::set(attrs, "mixed.array", ArrayStringValue(["123", "true", "3.14"]))
  
  // éªŒè¯æ‰€æœ‰å±æ€§è®¾ç½®æˆåŠŸ
  let string_attr = Attributes::get(attrs, "numeric.string")
  let int_attr = Attributes::get(attrs, "int.value")
  let float_attr = Attributes::get(attrs, "float.value")
  let bool_attr = Attributes::get(attrs, "bool.value")
  let string_array = Attributes::get(attrs, "string.array")
  let int_array = Attributes::get(attrs, "int.array")
  
  assert_true(string_attr.is_some())
  assert_true(int_attr.is_some())
  assert_true(float_attr.is_some())
  assert_true(bool_attr.is_some())
  assert_true(string_array.is_some())
  assert_true(int_array.is_some())
}

// Test 3: èµ„æºç®¡ç†å’Œå†…å­˜æ³„æ¼æµ‹è¯•
test "èµ„æºç®¡ç†å’Œå†…å­˜æ³„æ¼æµ‹è¯•" {
  // åˆ›å»ºå¤§é‡èµ„æºå¯¹è±¡
  let resources = []
  for i in 0..1000 {
    let resource = Resource::with_attributes(Resource::new(), [
      ("service.name", StringValue("service-" + i.to_string())),
      ("service.instance.id", StringValue("instance-" + i.to_string())),
      ("service.version", StringValue("1.0." + i.to_string())),
      ("environment", StringValue("test")),
      ("host.name", StringValue("host-" + i.to_string())),
      ("process.pid", IntValue(i))
    ])
    resources.push(resource)
  }
  
  // åˆ›å»ºå¤§é‡spanå¯¹è±¡
  let spans = []
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "resource-test")
  
  for i in 0..1000 {
    let span = Tracer::start_span(tracer, "resource-span-" + i.to_string(), Some([
      ("resource.index", IntValue(i))
    ]))
    spans.push(span)
  }
  
  // åˆ›å»ºå¤§é‡å±æ€§å¯¹è±¡
  let attrs_list = []
  for i in 0..1000 {
    let attrs = Attributes::new()
    Attributes::set(attrs, "index", IntValue(i))
    Attributes::set(attrs, "name", StringValue("attr-" + i.to_string()))
    Attributes::set(attrs, "value", FloatValue(i.to_double()))
    attrs_list.push(attrs)
  }
  
  // æ‰§è¡Œèµ„æºæ¸…ç†æ“ä½œ
  for span in spans {
    Span::end(span)
  }
  
  // éªŒè¯æ‰€æœ‰å¯¹è±¡åˆ›å»ºæˆåŠŸ
  assert_eq(resources.length(), 1000)
  assert_eq(spans.length(), 1000)
  assert_eq(attrs_list.length(), 1000)
}

// Test 4: å¹¶å‘å®‰å…¨å’Œç«æ€æ¡ä»¶æµ‹è¯•
test "å¹¶å‘å®‰å…¨å’Œç«æ€æ¡ä»¶æµ‹è¯•" {
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ
  let shared_attrs = Attributes::new()
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrency-test")
  
  // æ¨¡æ‹Ÿå¤šä¸ªçº¿ç¨‹åŒæ—¶æ“ä½œå…±äº«èµ„æº
  for i in 0..100 {
    // å¹¶å‘è®¾ç½®å±æ€§
    Attributes::set(shared_attrs, "concurrent.key." + i.to_string(), StringValue("value-" + i.to_string()))
    
    // å¹¶å‘åˆ›å»ºspan
    let span = Tracer::start_span(tracer, "concurrent-span-" + i.to_string())
    
    // å¹¶å‘æ·»åŠ äº‹ä»¶
    Span::add_event(span, "concurrent-event", Some([
      ("thread.id", IntValue(i)),
      ("operation", StringValue("concurrent.test"))
    ]))
    
    // å¹¶å‘è®¾ç½®çŠ¶æ€
    Span::set_status(span, Ok, Some("Concurrent operation completed"))
    
    // ç»“æŸspan
    Span::end(span)
  }
  
  // éªŒè¯å¹¶å‘æ“ä½œåçš„çŠ¶æ€
  for i in 0..100 {
    let attr_value = Attributes::get(shared_attrs, "concurrent.key." + i.to_string())
    assert_true(attr_value.is_some())
  }
  
  // éªŒè¯å…±äº«å±æ€§çš„å®Œæ•´æ€§
  assert_true(true)
}

// Test 5: æ€§èƒ½åŸºå‡†æµ‹è¯•
test "æ€§èƒ½åŸºå‡†æµ‹è¯•" {
  let start_time = Clock::now_unix_nanos(Clock::system())
  
  // æµ‹è¯•spanåˆ›å»ºæ€§èƒ½
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "performance-test")
  
  let spans = []
  for i in 0..5000 {
    let span = Tracer::start_span(tracer, "perf-span-" + i.to_string())
    spans.push(span)
  }
  
  let span_creation_time = Clock::now_unix_nanos(Clock::system())
  
  // æµ‹è¯•å±æ€§æ“ä½œæ€§èƒ½
  let attrs = Attributes::new()
  for i in 0..10000 {
    Attributes::set(attrs, "perf.key." + i.to_string(), StringValue("perf.value." + i.to_string()))
    let _ = Attributes::get(attrs, "perf.key." + i.to_string())
  }
  
  let attrs_operation_time = Clock::now_unix_nanos(Clock::system())
  
  // æµ‹è¯•åº¦é‡æ“ä½œæ€§èƒ½
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "perf-meter")
  let counter = Meter::create_counter(meter, "perf-counter")
  
  for i in 0..10000 {
    Counter::add(counter, 1.0)
  }
  
  let metrics_operation_time = Clock::now_unix_nanos(Clock::system())
  
  // ç»“æŸæ‰€æœ‰span
  for span in spans {
    Span::end(span)
  }
  
  let end_time = Clock::now_unix_nanos(Clock::system())
  
  // è®¡ç®—å„é˜¶æ®µè€—æ—¶
  let span_creation_duration = span_creation_time - start_time
  let attrs_operation_duration = attrs_operation_time - span_creation_time
  let metrics_operation_duration = metrics_operation_time - attrs_operation_time
  let span_end_duration = end_time - metrics_operation_time
  let total_duration = end_time - start_time
  
  // éªŒè¯æ€§èƒ½æŒ‡æ ‡
  assert_true(span_creation_duration < 5000000000L)  // 5ç§’å†…å®Œæˆspanåˆ›å»º
  assert_true(attrs_operation_duration < 3000000000L)  // 3ç§’å†…å®Œæˆå±æ€§æ“ä½œ
  assert_true(metrics_operation_duration < 2000000000L)  // 2ç§’å†…å®Œæˆåº¦é‡æ“ä½œ
  assert_true(span_end_duration < 3000000000L)  // 3ç§’å†…å®Œæˆspanç»“æŸ
  assert_true(total_duration < 13000000000L)  // æ€»æ—¶é—´ä¸è¶…è¿‡13ç§’
}

// Test 6: é›†æˆæµ‹è¯•å’Œç«¯åˆ°ç«¯å·¥ä½œæµ
test "é›†æˆæµ‹è¯•å’Œç«¯åˆ°ç«¯å·¥ä½œæµ" {
  // åˆ›å»ºå®Œæ•´çš„é¥æµ‹å·¥ä½œæµ
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  let tracer = TracerProvider::get_tracer(tracer_provider, "integration-test")
  let meter = MeterProvider::get_meter(meter_provider, "integration-test")
  let logger = LoggerProvider::get_logger(logger_provider, "integration-test")
  
  // åˆ›å»ºåº¦é‡ä»ªå™¨
  let request_counter = Meter::create_counter(meter, "integration.requests", Some("Integration requests"), Some("count"))
  let duration_histogram = Meter::create_histogram(meter, "integration.duration", Some("Integration duration"), Some("ms"))
  let error_counter = Meter::create_counter(meter, "integration.errors", Some("Integration errors"), Some("count"))
  
  // åˆ›å»ºèµ„æº
  let resource = Resource::with_attributes(Resource::new(), [
    ("service.name", StringValue("integration-service")),
    ("service.version", StringValue("2.0.0")),
    ("environment", StringValue("test"))
  ])
  
  // æ¨¡æ‹Ÿå®Œæ•´çš„è¯·æ±‚å¤„ç†æµç¨‹
  for i in 0..100 {
    // å¼€å§‹è¯·æ±‚span
    let span = Tracer::start_span(tracer, "integration-request", Some([
      ("request.id", StringValue("req-" + i.to_string())),
      ("user.id", StringValue("user-" + i.to_string()))
    ]))
    
    // è®°å½•è¯·æ±‚å¼€å§‹
    Counter::add(request_counter, 1.0)
    
    // æ·»åŠ è¯·æ±‚å¼€å§‹äº‹ä»¶
    Span::add_event(span, "request.started", Some([
      ("timestamp", IntValue(Clock::now_unix_nanos(Clock::system()))),
      ("request.size", IntValue(1024))
    ]))
    
    // æ¨¡æ‹Ÿå¤„ç†è¿‡ç¨‹
    let processing_attrs = Attributes::new()
    Attributes::set(processing_attrs, "processing.step", StringValue("validation"))
    Attributes::set(processing_attrs, "processing.time", IntValue(50))
    
    // è®°å½•å¤„ç†æ—¥å¿—
    let processing_log = LogRecord::new_with_context(
      Info,
      Some("Processing request " + i.to_string()),
      Some(processing_attrs),
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      Some(SpanContext::trace_id(Span::span_context(span))),
      Some(SpanContext::span_id(Span::span_context(span))),
      Some(Context::root())
    )
    Logger::emit(logger, processing_log)
    
    // æ¨¡æ‹Ÿé”™è¯¯æƒ…å†µï¼ˆ10%çš„æ¦‚ç‡ï¼‰
    if i % 10 == 0 {
      Counter::add(error_counter, 1.0)
      Span::set_status(span, Error, Some("Simulated processing error"))
      
      let error_log = LogRecord::new_with_context(
        Error,
        Some("Processing failed for request " + i.to_string()),
        Some([("error.code", IntValue(500)), ("error.type", StringValue("ProcessingError"))]),
        Some(Clock::now_unix_nanos(Clock::system())),
        None,
        Some(SpanContext::trace_id(Span::span_context(span))),
        Some(SpanContext::span_id(Span::span_context(span))),
        Some(Context::root())
      )
      Logger::emit(logger, error_log)
    } else {
      // è®°å½•æˆåŠŸå¤„ç†
      Histogram::record(duration_histogram, 100.0 + (i % 200).to_double())
      Span::set_status(span, Ok, Some("Request processed successfully"))
      
      let success_log = LogRecord::new_with_context(
        Info,
        Some("Request " + i.to_string() + " processed successfully"),
        Some([("response.size", IntValue(2048)), ("processing.time", IntValue(100 + i % 200))]),
        Some(Clock::now_unix_nanos(Clock::system())),
        None,
        Some(SpanContext::trace_id(Span::span_context(span))),
        Some(SpanContext::span_id(Span::span_context(span))),
        Some(Context::root())
      )
      Logger::emit(logger, success_log)
    }
    
    // æ·»åŠ è¯·æ±‚å®Œæˆäº‹ä»¶
    Span::add_event(span, "request.completed", Some([
      ("timestamp", IntValue(Clock::now_unix_nanos(Clock::system()))),
      ("response.size", IntValue(2048))
    ]))
    
    // ç»“æŸspan
    Span::end(span)
  }
  
  // éªŒè¯é›†æˆæµ‹è¯•å®Œæˆ
  assert_true(true)
}

// Test 7: å…¼å®¹æ€§å’Œç‰ˆæœ¬æµ‹è¯•
test "å…¼å®¹æ€§å’Œç‰ˆæœ¬æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒç‰ˆæœ¬çš„æ•°æ®æ ¼å¼å…¼å®¹æ€§
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "compatibility-test")
  
  // åˆ›å»ºä¸åŒç‰ˆæœ¬çš„span
  let v1_span = Tracer::start_span(tracer, "v1.operation", Some([
    ("version", StringValue("1.0")),
    ("legacy.field", StringValue("legacy.value"))
  ]))
  
  let v2_span = Tracer::start_span(tracer, "v2.operation", Some([
    ("version", StringValue("2.0")),
    ("new.field", StringValue("new.value")),
    ("enhanced.field", StringValue("enhanced.value"))
  ]))
  
  // æµ‹è¯•å‘åå…¼å®¹æ€§
  Span::add_event(v1_span, "v1.event", Some([
    ("legacy.data", StringValue("old.format.data"))
  ]))
  
  Span::add_event(v2_span, "v2.event", Some([
    ("new.data", StringValue("new.format.data")),
    ("metadata", StringValue("enhanced.metadata"))
  ]))
  
  // æµ‹è¯•å±æ€§å…¼å®¹æ€§
  let attrs = Attributes::new()
  
  // è®¾ç½®æ—§ç‰ˆæœ¬å±æ€§
  Attributes::set(attrs, "old.style.attribute", StringValue("old.value"))
  Attributes::set(attrs, "deprecated.field", StringValue("deprecated.value"))
  
  // è®¾ç½®æ–°ç‰ˆæœ¬å±æ€§
  Attributes::set(attrs, "new.style.attribute", StringValue("new.value"))
  Attributes::set(attrs, "enhanced.field", StringValue("enhanced.value"))
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½å¯ä»¥æ­£ç¡®è®¿é—®
  let old_attr = Attributes::get(attrs, "old.style.attribute")
  let deprecated_attr = Attributes::get(attrs, "deprecated.field")
  let new_attr = Attributes::get(attrs, "new.style.attribute")
  let enhanced_attr = Attributes::get(attrs, "enhanced.field")
  
  assert_true(old_attr.is_some())
  assert_true(deprecated_attr.is_some())
  assert_true(new_attr.is_some())
  assert_true(enhanced_attr.is_some())
  
  // ç»“æŸspan
  Span::end(v1_span)
  Span::end(v2_span)
}

// Test 8: å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•
test "å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•" {
  // æµ‹è¯•å¤šè¯­è¨€æ”¯æŒ
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "i18n-test")
  
  // åˆ›å»ºä¸åŒè¯­è¨€çš„span
  let chinese_span = Tracer::start_span(tracer, "ä¸­æ–‡æ“ä½œ", Some([
    ("æ“ä½œåç§°", StringValue("ç”¨æˆ·æ³¨å†Œ")),
    ("ç”¨æˆ·ç±»å‹", StringValue("æ™®é€šç”¨æˆ·")),
    ("çŠ¶æ€", StringValue("æˆåŠŸ"))
  ]))
  
  let english_span = Tracer::start_span(tracer, "english.operation", Some([
    ("operation.name", StringValue("user.registration")),
    ("user.type", StringValue("regular.user")),
    ("status", StringValue("success"))
  ]))
  
  let japanese_span = Tracer::start_span(tracer, "æ—¥æœ¬èªæ“ä½œ", Some([
    ("æ“ä½œå", StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²")),
    ("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¿ã‚¤ãƒ—", StringValue("ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼")),
    ("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", StringValue("æˆåŠŸ"))
  ]))
  
  // æµ‹è¯•å¤šè¯­è¨€æ—¥å¿—è®°å½•
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "i18n-logger")
  
  let chinese_log = LogRecord::new(Info, "ç”¨æˆ·æ“ä½œå®Œæˆ")
  let english_log = LogRecord::new(Info, "User operation completed")
  let japanese_log = LogRecord::new(Info, "ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå®Œäº†ã—ã¾ã—ãŸ")
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’Œè¡¨æƒ…ç¬¦å·
  let emoji_span = Tracer::start_span(tracer, "emoji.test ğŸš€", Some([
    ("status.emoji", StringValue("âœ…")),
    ("error.emoji", StringValue("âŒ")),
    ("warning.emoji", StringValue("âš ï¸")),
    ("info.emoji", StringValue("â„¹ï¸"))
  ]))
  
  // æµ‹è¯•RTLè¯­è¨€ï¼ˆé˜¿æ‹‰ä¼¯è¯­ï¼‰
  let arabic_span = Tracer::start_span(tracer, "Ø¹Ù…Ù„ÙŠØ© Ø¹Ø±Ø¨ÙŠØ©", Some([
    ("Ø§Ø³Ù… Ø§Ù„Ø¹Ù…Ù„ÙŠØ©", StringValue("ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")),
    ("Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", StringValue("Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø§Ø¯ÙŠ")),
    ("Ø§Ù„Ø­Ø§Ù„Ø©", StringValue("Ù†Ø¬Ø§Ø­"))
  ]))
  
  // å‘é€æ‰€æœ‰æ—¥å¿—
  Logger::emit(logger, chinese_log)
  Logger::emit(logger, english_log)
  Logger::emit(logger, japanese_log)
  
  // ç»“æŸæ‰€æœ‰span
  Span::end(chinese_span)
  Span::end(english_span)
  Span::end(japanese_span)
  Span::end(emoji_span)
  Span::end(arabic_span)
  
  // éªŒè¯å›½é™…åŒ–æµ‹è¯•å®Œæˆ
  assert_true(true)
}

// Test 9: å¯æ‰©å±•æ€§å’Œæ’ä»¶æµ‹è¯•
test "å¯æ‰©å±•æ€§å’Œæ’ä»¶æµ‹è¯•" {
  // æµ‹è¯•è‡ªå®šä¹‰å±æ€§ç±»å‹
  let attrs = Attributes::new()
  
  // æ¨¡æ‹Ÿè‡ªå®šä¹‰å±æ€§ç±»å‹
  Attributes::set(attrs, "custom.object", StringValue("{\"type\":\"custom\",\"data\":{\"field1\":\"value1\",\"field2\":42}}"))
  Attributes::set(attrs, "binary.data", StringValue("base64:encoded:binary:data"))
  Attributes::set(attrs, "json.array", StringValue("[1,2,3,\"four\",{\"five\":5}]"))
  Attributes::set(attrs, "timestamp.iso", StringValue("2025-01-02T12:00:00Z"))
  Attributes::set(attrs, "uuid", StringValue("550e8400-e29b-41d4-a716-446655440000"))
  
  // æµ‹è¯•è‡ªå®šä¹‰åº¦é‡ç±»å‹
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "extensibility-test")
  
  let custom_counter = Meter::create_counter(meter, "custom.counter", Some("Custom counter for extensibility"), Some("custom.unit"))
  let custom_histogram = Meter::create_histogram(meter, "custom.histogram", Some("Custom histogram"), Some("custom.unit"))
  
  // æµ‹è¯•è‡ªå®šä¹‰spanç±»å‹
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "extensibility-test")
  
  let custom_span = Tracer::start_span(tracer, "custom.operation", Some([
    ("custom.type", StringValue("plugin.operation")),
    ("plugin.version", StringValue("1.0.0")),
    ("plugin.config", StringValue("{\"option1\":\"value1\",\"option2\":true}"))
  ]))
  
  // æ·»åŠ è‡ªå®šä¹‰äº‹ä»¶
  Span::add_event(custom_span, "custom.event", Some([
    ("event.type", StringValue("plugin.lifecycle")),
    ("event.data", StringValue("{\"phase\":\"initialization\",\"status\":\"success\"}"))
  ]))
  
  // æµ‹è¯•è‡ªå®šä¹‰æ—¥å¿—æ ¼å¼
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "extensibility-logger")
  
  let custom_log = LogRecord::new_with_context(
    Info,
    Some("Custom log with structured data"),
    Some([
      ("log.format", StringValue("structured.json")),
      ("log.version", StringValue("2.0")),
      ("custom.fields", StringValue("{\"field1\":\"value1\",\"field2\":42,\"field3\":true}"))
    ]),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(custom_span))),
    Some(SpanContext::span_id(Span::span_context(custom_span))),
    Some(Context::root())
  )
  
  // æ‰§è¡Œè‡ªå®šä¹‰åº¦é‡æ“ä½œ
  Counter::add(custom_counter, 1.0)
  Histogram::record(custom_histogram, 123.45)
  
  // å‘é€è‡ªå®šä¹‰æ—¥å¿—
  Logger::emit(logger, custom_log)
  
  // ç»“æŸè‡ªå®šä¹‰span
  Span::end(custom_span)
  
  // éªŒè¯å¯æ‰©å±•æ€§æµ‹è¯•å®Œæˆ
  assert_true(true)
}

// Test 10: æ•…éšœæ¢å¤å’Œå¼¹æ€§æµ‹è¯•
test "æ•…éšœæ¢å¤å’Œå¼¹æ€§æµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿåœ¨å„ç§æ•…éšœæƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "resilience-test")
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "resilience-test")
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "resilience-logger")
  
  // åˆ›å»ºæ•…éšœåº¦é‡
  let failure_counter = Meter::create_counter(meter, "resilience.failures", Some("Failure count"), Some("count"))
  let recovery_counter = Meter::create_counter(meter, "resilience.recoveries", Some("Recovery count"), Some("count"))
  let retry_histogram = Meter::create_histogram(meter, "resilience.retries", Some("Retry attempts"), Some("count"))
  
  // æ¨¡æ‹Ÿå„ç§æ•…éšœåœºæ™¯
  for i in 0..50 {
    let span = Tracer::start_span(tracer, "resilience.operation", Some([
      ("operation.id", StringValue("op-" + i.to_string())),
      ("attempt", IntValue(1))
    ]))
    
    // æ¨¡æ‹Ÿç½‘ç»œæ•…éšœ
    if i % 5 == 0 {
      Counter::add(failure_counter, 1.0)
      Span::add_event(span, "network.failure", Some([
        ("error.type", StringValue("NetworkTimeout")),
        ("retry.count", IntValue(3))
      ]))
      
      // æ¨¡æ‹Ÿé‡è¯•é€»è¾‘
      for retry in 1..=3 {
        Histogram::record(retry_histogram, retry.to_double())
        Span::add_event(span, "retry.attempt", Some([
          ("retry.number", IntValue(retry)),
          ("retry.reason", StringValue("network.timeout"))
        ]))
      }
      
      // æ¨¡æ‹Ÿæœ€ç»ˆæ¢å¤
      Counter::add(recovery_counter, 1.0)
      Span::set_status(span, Ok, Some("Recovered after retries"))
      
      let recovery_log = LogRecord::new_with_context(
        Warn,
        Some("Operation recovered after " + i.to_string() + " failures"),
        Some([
          ("failure.count", IntValue(3)),
          ("recovery.time", IntValue(5000)),
          ("final.status", StringValue("success"))
        ]),
        Some(Clock::now_unix_nanos(Clock::system())),
        None,
        Some(SpanContext::trace_id(Span::span_context(span))),
        Some(SpanContext::span_id(Span::span_context(span))),
        Some(Context::root())
      )
      Logger::emit(logger, recovery_log)
    }
    // æ¨¡æ‹Ÿæ•°æ®åº“æ•…éšœ
    else if i % 7 == 0 {
      Counter::add(failure_counter, 1.0)
      Span::add_event(span, "database.failure", Some([
        ("error.type", StringValue("DatabaseConnectionLost")),
        ("error.code", IntValue(503))
      ]))
      
      // æ¨¡æ‹Ÿè¿æ¥æ± æ¢å¤
      Span::add_event(span, "connection.pool.recovery", Some([
        ("recovery.strategy", StringValue("reconnect")),
        ("pool.size", IntValue(10))
      ]))
      
      Counter::add(recovery_counter, 1.0)
      Span::set_status(span, Ok, Some("Database connection restored"))
    }
    // æ¨¡æ‹Ÿå†…å­˜ä¸è¶³æ•…éšœ
    else if i % 11 == 0 {
      Counter::add(failure_counter, 1.0)
      Span::add_event(span, "memory.pressure", Some([
        ("error.type", StringValue("OutOfMemory")),
        ("memory.usage", StringValue("95%"))
      ]))
      
      // æ¨¡æ‹Ÿåƒåœ¾å›æ”¶å’Œå†…å­˜é‡Šæ”¾
      Span::add_event(span, "memory.cleanup", Some([
        ("cleanup.strategy", StringValue("garbage.collection")),
        ("memory.freed", IntValue(1048576))  // 1MB
      ]))
      
      Counter::add(recovery_counter, 1.0)
      Span::set_status(span, Ok, Some("Memory pressure resolved"))
    }
    // æ­£å¸¸æƒ…å†µ
    else {
      Span::set_status(span, Ok, Some("Operation completed successfully"))
    }
    
    Span::end(span)
  }
  
  // éªŒè¯æ•…éšœæ¢å¤æµ‹è¯•å®Œæˆ
  assert_true(true)
}