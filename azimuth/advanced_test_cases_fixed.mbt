// é«˜çº§ MoonBit æµ‹è¯•ç”¨ä¾‹ - azimuth åº“
// åŒ…å« 8 ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼Œæ¶µç›–é«˜çº§åŠŸèƒ½å’Œç‰¹æ®Šåœºæ™¯

test "performance_stress_test" {
  // æ€§èƒ½å‹åŠ›æµ‹è¯• - æµ‹è¯•å¤§é‡è®¡ç®—çš„æ‰§è¡Œ
  let iterations = 1000
  
  // æ‰¹é‡åŠ æ³•æµ‹è¯•
  let mut sum = 0
  let mut i = 0
  while i < iterations {
    sum = add(sum, i)
    i = i + 1
  }
  assert_eq(499500, sum)  // 0+1+2+...+999 = 999*1000/2 = 499500
  
  // æ‰¹é‡ä¹˜æ³•æµ‹è¯•
  let mut product = 1
  let mut j = 1
  while j < 6 {  // åªè®¡ç®—å‰5ä¸ªæ•°çš„ä¹˜ç§¯ï¼Œé¿å…æº¢å‡º
    product = multiply(product, j)
    j = j + 1
  }
  assert_eq(120, product)  // 1*2*3*4*5 = 120
  
  // æ‰¹é‡é™¤æ³•æµ‹è¯•
  let mut division_result = 0
  let mut k = 1
  while k < 11 {
    division_result = add(division_result, divide_with_ceil(multiply(k, 10), 3))
    k = k + 1
  }
  assert_eq(185, division_result)  // ceil(10/3) + ceil(20/3) + ... + ceil(100/3)
}

test "numerical_precision_analysis" {
  // æ•°å€¼ç²¾åº¦åˆ†ææµ‹è¯•
  // æµ‹è¯•è¿ç»­è¿ç®—çš„ç²¾åº¦ä¿æŒ
  let precision_test_1 = divide_with_ceil(multiply(100, 3), 10)  // ceil(300/10) = 30
  let precision_test_2 = divide_with_ceil(multiply(100, 7), 10)  // ceil(700/10) = 70
  let precision_test_3 = divide_with_ceil(multiply(100, 11), 10)  // ceil(1100/10) = 110
  
  assert_eq(30, precision_test_1)
  assert_eq(70, precision_test_2)
  assert_eq(110, precision_test_3)
  
  // æµ‹è¯•ç²¾åº¦æŸå¤±åœºæ™¯
  let small_number = 1
  let large_divisor = 1000
  let precision_loss_test = divide_with_ceil(small_number, large_divisor)
  assert_eq(1, precision_loss_test)  // ceil(1/1000) = 1 (å‘ä¸Šå–æ•´ç‰¹æ€§)
  
  // æµ‹è¯•ç´¯ç§¯ç²¾åº¦
  let mut accumulated_precision = 0
  let precision_steps = 100
  let mut step = 1
  while step <= precision_steps {
    accumulated_precision = add(accumulated_precision, divide_with_ceil(step, 10))
    step = step + 1
  }
  assert_eq(550, accumulated_precision)  // ç´¯ç§¯ç²¾åº¦éªŒè¯
}

test "function_composition_advanced" {
  // é«˜çº§å‡½æ•°ç»„åˆæµ‹è¯•
  // å¤æ‚æ•°å­¦è¡¨è¾¾å¼ï¼š(a+b)*(c+d)/e çš„å‘ä¸Šå–æ•´
  let a = 15
  let b = 25
  let c = 8
  let d = 12
  let e = 7
  
  let step1 = add(a, b)  // 40
  let step2 = add(c, d)  // 20
  let step3 = multiply(step1, step2)  // 800
  let final_result = divide_with_ceil(step3, e)  // ceil(800/7) = 115
  
  assert_eq(40, step1)
  assert_eq(20, step2)
  assert_eq(800, step3)
  assert_eq(115, final_result)
  
  // åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let nested_result = divide_with_ceil(
    multiply(
      add(5, 3),
      divide_with_ceil(multiply(4, 7), 3)
    ),
    subtract(10, 2)
  )
  // æ‰‹åŠ¨è®¡ç®—ï¼š(5+3) * ceil(4*7/3) / (10-2) = 8 * ceil(28/3) / 8 = 8 * 10 / 8 = 10
  assert_eq(10, nested_result)
}

test "boundary_condition_comprehensive" {
  // ç»¼åˆè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•æå€¼è¿ç®—
  let max_safe_int = 1000000
  let min_safe_int = -1000000
  
  // æå€¼åŠ æ³•
  assert_eq(2000000, add(max_safe_int, max_safe_int))
  assert_eq(-2000000, add(min_safe_int, min_safe_int))
  assert_eq(0, add(max_safe_int, min_safe_int))
  
  // æå€¼ä¹˜æ³•ï¼ˆä½¿ç”¨è¾ƒå°çš„å€¼é¿å…æº¢å‡ºï¼‰
  assert_eq(1000000000000, multiply(1000000, 1000000))
  assert_eq(1000000000000, multiply(-1000000, -1000000))
  assert_eq(-1000000000000, multiply(1000000, -1000000))
  
  // æå€¼é™¤æ³•
  assert_eq(1, divide_with_ceil(max_safe_int, max_safe_int))
  assert_eq(1, divide_with_ceil(min_safe_int, min_safe_int))
  assert_eq(-1, divide_with_ceil(min_safe_int, max_safe_int))
  assert_eq(0, divide_with_ceil(max_safe_int, min_safe_int))
  
  // é›¶å€¼è¾¹ç•Œæµ‹è¯•
  assert_eq(0, divide_with_ceil(0, max_safe_int))
  assert_eq(0, divide_with_ceil(0, min_safe_int))
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(max_safe_int, 0))
  assert_eq(0, divide_with_ceil(min_safe_int, 0))
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", greet(special_chars))
  
  // æµ‹è¯•æ•°å­—å­—ç¬¦ä¸²
  let numeric_string = "1234567890"
  assert_eq_string("Hello, 1234567890!", greet(numeric_string))
  
  // æµ‹è¯•æ··åˆå­—ç¬¦ä¸²
  let mixed_string = "ABC123!@#abc"
  assert_eq_string("Hello, ABC123!@#abc!", greet(mixed_string))
  
  // æµ‹è¯•ç©ºç™½å­—ç¬¦å¤„ç†
  let whitespace_string = "   \\t\\n\\r   "
  assert_eq_string("Hello,    \\t\\n\\r   !", greet(whitespace_string))
  
  // æµ‹è¯•Unicodeè¡¨æƒ…ç¬¦å·
  let emoji_string = "ğŸ‰ğŸš€ğŸŒŸğŸ’»ğŸ“š"
  assert_eq_string("Hello, ğŸ‰ğŸš€ğŸŒŸğŸ’»ğŸ“š!", greet(emoji_string))
}

test "mathematical_properties_verification" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  // éªŒè¯åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  
  // æµ‹è¯•ç¬¬ä¸€ç»„å€¼
  let a1 = 2
  let b1 = 3
  let c1 = 5
  let left_result1 = multiply(a1, add(b1, c1))
  let right_result1 = add(multiply(a1, b1), multiply(a1, c1))
  assert_eq(left_result1, right_result1)
  
  // æµ‹è¯•ç¬¬äºŒç»„å€¼
  let a2 = 10
  let b2 = 7
  let c2 = 13
  let left_result2 = multiply(a2, add(b2, c2))
  let right_result2 = add(multiply(a2, b2), multiply(a2, c2))
  assert_eq(left_result2, right_result2)
  
  // æµ‹è¯•ç¬¬ä¸‰ç»„å€¼
  let a3 = 25
  let b3 = 4
  let c3 = 9
  let left_result3 = multiply(a3, add(b3, c3))
  let right_result3 = add(multiply(a3, b3), multiply(a3, c3))
  assert_eq(left_result3, right_result3)
  
  // éªŒè¯ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  let assoc_a = 15
  let assoc_b = 25
  let assoc_c = 35
  let assoc_left = add(add(assoc_a, assoc_b), assoc_c)
  let assoc_right = add(assoc_a, add(assoc_b, assoc_c))
  assert_eq(assoc_left, assoc_right)
  
  // éªŒè¯ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  let mult_assoc_a = 4
  let mult_assoc_b = 6
  let mult_assoc_c = 8
  let mult_assoc_left = multiply(multiply(mult_assoc_a, mult_assoc_b), mult_assoc_c)
  let mult_assoc_right = multiply(mult_assoc_a, multiply(mult_assoc_b, mult_assoc_c))
  assert_eq(mult_assoc_left, mult_assoc_right)
}

test "real_world_application_scenarios" {
  // çœŸå®ä¸–ç•Œåº”ç”¨åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šé¡¹ç›®ç®¡ç† - è®¡ç®—é¡¹ç›®èµ„æºå’Œæ—¶é—´
  let project_tasks = 125
  let team_members = 8
  let tasks_per_person_per_week = 5
  let weeks_per_sprint = 2
  
  // è®¡ç®—å›¢é˜Ÿæ¯å‘¨å¤„ç†èƒ½åŠ›
  let weekly_capacity = multiply(team_members, tasks_per_person_per_week)
  assert_eq(40, weekly_capacity)
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ•°
  let sprints_needed = divide_with_ceil(project_tasks, multiply(weekly_capacity, weeks_per_sprint))
  assert_eq(2, sprints_needed)  // ceil(125/(40*2)) = 2
  
  // è®¡ç®—æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(sprints_needed, multiply(weekly_capacity, weeks_per_sprint))
  assert_eq(160, total_capacity)
  
  // åœºæ™¯2ï¼šåº“å­˜ç®¡ç† - å¤šäº§å“è£…ç®±ä¼˜åŒ–
  let product_a = 47  // æ¯ç®±è£…8ä¸ª
  let product_b = 63  // æ¯ç®±è£…12ä¸ª
  let product_c = 89  // æ¯ç®±è£…15ä¸ª
  
  let boxes_a = divide_with_ceil(product_a, 8)   // ceil(47/8) = 6
  let boxes_b = divide_with_ceil(product_b, 12)  // ceil(63/12) = 6
  let boxes_c = divide_with_ceil(product_c, 15)  // ceil(89/15) = 6
  
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(18, total_boxes)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity_a = multiply(boxes_a, 8)   // 6 * 8 = 48
  let total_capacity_b = multiply(boxes_b, 12)  // 6 * 12 = 72
  let total_capacity_c = multiply(boxes_c, 15)  // 6 * 15 = 90
  let total_storage_capacity = add(add(total_capacity_a, total_capacity_b), total_capacity_c)
  assert_eq(210, total_storage_capacity)
  
  // åœºæ™¯3ï¼šé‡‘èè®¡ç®— - è´·æ¬¾åˆ†æœŸ
  let loan_amount = 50000
  let monthly_payment_max = 2500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment_max)
  assert_eq(20, months_needed)  // ceil(50000/2500) = 20
  
  // è®¡ç®—å®é™…æœˆä¾›
  let actual_monthly_payment = divide_with_ceil(loan_amount, months_needed)
  assert_eq(2500, actual_monthly_payment)
  
  // è®¡ç®—æ€»æ”¯ä»˜é¢
  let total_payment = multiply(actual_monthly_payment, months_needed)
  assert_eq(50000, total_payment)
}

test "error_handling_and_recovery" {
  // é”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•
  // æµ‹è¯•å„ç§é”™è¯¯åœºæ™¯çš„å¤„ç†
  
  // é™¤é›¶é”™è¯¯å¤„ç†
  let positive_dividend = 100
  let negative_dividend = -100
  let zero_dividend = 0
  let zero_divisor = 0
  
  assert_eq(0, divide_with_ceil(positive_dividend, zero_divisor))
  assert_eq(0, divide_with_ceil(negative_dividend, zero_divisor))
  assert_eq(0, divide_with_ceil(zero_dividend, zero_divisor))
  
  // è¾¹ç•Œå€¼é”™è¯¯å¤„ç†
  let extreme_positive = 2147483647
  let extreme_negative = -2147483648
  
  assert_eq(0, divide_with_ceil(extreme_positive, 0))
  assert_eq(0, divide_with_ceil(extreme_negative, 0))
  
  // æ•°å€¼æº¢å‡ºé¢„é˜²æµ‹è¯•
  let safe_large_number = 46340  // sqrt(2^31-1) çš„è¿‘ä¼¼å€¼ï¼Œé¿å…ä¹˜æ³•æº¢å‡º
  let safe_multiplication = multiply(safe_large_number, safe_large_number)
  assert_true(safe_multiplication > 0)  // ç¡®ä¿ä¹˜æ³•ç»“æœä¸ºæ­£æ•°
  
  // å­—ç¬¦ä¸²é”™è¯¯å¤„ç†
  let empty_string = ""
  let null_like_string = "null"
  let undefined_like_string = "undefined"
  
  assert_eq_string("Hello, !", greet(empty_string))
  assert_eq_string("Hello, null!", greet(null_like_string))
  assert_eq_string("Hello, undefined!", greet(undefined_like_string))
  
  // å¤åˆé”™è¯¯æ¢å¤æµ‹è¯•
  let error_recovery_1 = add(divide_with_ceil(10, 0), 5)  // 0 + 5 = 5
  let error_recovery_2 = multiply(divide_with_ceil(-10, 0), 3)  // 0 * 3 = 0
  let error_recovery_3 = divide_with_ceil(add(5, multiply(3, 0)), 2)  // ceil(5/2) = 3
  
  assert_eq(5, error_recovery_1)
  assert_eq(0, error_recovery_2)
  assert_eq(3, error_recovery_3)
}