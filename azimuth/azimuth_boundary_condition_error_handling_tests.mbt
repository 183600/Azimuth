// Azimuth Boundary Condition and Error Handling Tests
// This file contains tests for edge cases and error handling scenarios

// Test 1: Empty and null handling
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šç©ºå€¼å’Œnullå¤„ç†" {
  // æµ‹è¯•ç©ºå±æ€§é›†åˆ
  let empty_attrs = azimuth::Attributes::new()
  assert_eq(azimuth::Attributes::get(empty_attrs, ""), None)
  assert_eq(azimuth::Attributes::get(empty_attrs, "nonexistent"), None)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®å€¼
  let attrs_with_empty = azimuth::Attributes::new()
  azimuth::Attributes::set(attrs_with_empty, "", azimuth::StringValue("empty.key.value"))
  assert_eq(azimuth::Attributes::get(attrs_with_empty, ""), Some(azimuth::StringValue("empty.key.value")))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  azimuth::Attributes::set(attrs_with_empty, "empty.value", azimuth::StringValue(""))
  let empty_value = azimuth::Attributes::get(attrs_with_empty, "empty.value")
  assert_eq(empty_value, Some(azimuth::StringValue("")))
  
  // æµ‹è¯•ç©ºæ•°ç»„
  azimuth::Attributes::set(attrs_with_empty, "empty.string.array", azimuth::ArrayStringValue([]))
  azimuth::Attributes::set(attrs_with_empty, "empty.int.array", azimuth::ArrayIntValue([]))
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_context = azimuth::Context::root()
  let empty_key = azimuth::ContextKey::new("")
  let context_with_empty = azimuth::Context::with_value(empty_context, empty_key, "empty.context.value")
  assert_eq(azimuth::Context::get(context_with_empty, empty_key), Some("empty.context.value"))
  
  // æµ‹è¯•ç©ºBaggage
  let empty_baggage = azimuth::Baggage::new()
  assert_eq(azimuth::Baggage::get_entry(empty_baggage, "any.key"), None)
  
  // æµ‹è¯•ç©ºSpanä¸Šä¸‹æ–‡
  let empty_trace_ctx = azimuth::SpanContext::new("", "span123", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_trace_ctx))
  
  let empty_span_ctx = azimuth::SpanContext::new("trace123", "", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_span_ctx))
  
  let both_empty_ctx = azimuth::SpanContext::new("", "", false, "")
  assert_false(azimuth::SpanContext::is_valid(both_empty_ctx))
  assert_false(azimuth::SpanContext::is_sampled(both_empty_ctx))
}

// Test 2: Extreme values handling
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šæå€¼å¤„ç†" {
  // æµ‹è¯•æå€¼æ•´æ•°
  let extreme_attrs = azimuth::Attributes::new()
  azimuth::Attributes::set(extreme_attrs, "max.int32", azimuth::IntValue(2147483647))
  azimuth::Attributes::set(extreme_attrs, "min.int32", azimuth::IntValue(-2147483648))
  azimuth::Attributes::set(extreme_attrs, "zero.int", azimuth::IntValue(0))
  
  // æµ‹è¯•æå€¼æµ®ç‚¹æ•°
  azimuth::Attributes::set(extreme_attrs, "max.float", azimuth::FloatValue(1.7976931348623157e+308))
  azimuth::Attributes::set(extreme_attrs, "min.float", azimuth::FloatValue(-1.7976931348623157e+308))
  azimuth::Attributes::set(extreme_attrs, "zero.float", azimuth::FloatValue(0.0))
  azimuth::Attributes::set(extreme_attrs, "negative.zero", azimuth::FloatValue(-0.0))
  
  // æµ‹è¯•æå°å€¼
  azimuth::Attributes::set(extreme_attrs, "tiny.float", azimuth::FloatValue(1.0e-308))
  azimuth::Attributes::set(extreme_attrs, "very.tiny.float", azimuth::FloatValue(1.0e-324))
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  azimuth::Attributes::set(extreme_attrs, "infinity", azimuth::FloatValue(1.0/0.0))
  azimuth::Attributes::set(extreme_attrs, "negative.infinity", azimuth::FloatValue(-1.0/0.0))
  azimuth::Attributes::set(extreme_attrs, "nan", azimuth::FloatValue(0.0/0.0))
  
  // éªŒè¯æå€¼å±æ€§å¯ä»¥æ­£ç¡®è®¾ç½®å’Œè·å–
  let max_int = azimuth::Attributes::get(extreme_attrs, "max.int32")
  let min_int = azimuth::Attributes::get(extreme_attrs, "min.int32")
  let zero_int = azimuth::Attributes::get(extreme_attrs, "zero.int")
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(max_int, Some(azimuth::IntValue(42)))
  assert_eq(min_int, Some(azimuth::IntValue(42)))
  assert_eq(zero_int, Some(azimuth::IntValue(42)))
}

// Test 3: Unicode and special characters handling
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šUnicodeå’Œç‰¹æ®Šå­—ç¬¦å¤„ç†" {
  let unicode_attrs = azimuth::Attributes::new()
  
  // æµ‹è¯•ä¸­æ–‡å­—ç¬¦
  azimuth::Attributes::set(unicode_attrs, "ä¸­æ–‡é”®", azimuth::StringValue("ä¸­æ–‡å€¼"))
  azimuth::Attributes::set(unicode_attrs, "chinese.key", azimuth::StringValue("æµ‹è¯•ä¸­æ–‡"))
  
  // æµ‹è¯•emojiå­—ç¬¦
  azimuth::Attributes::set(unicode_attrs, "emoji.key", azimuth::StringValue("ğŸ˜€ğŸ‰ğŸ”¥ğŸš€"))
  azimuth::Attributes::set(unicode_attrs, "mixed.emoji", azimuth::StringValue("Hello ğŸŒ ä¸–ç•Œ"))
  
  // æµ‹è¯•ç‰¹æ®Šç¬¦å·
  azimuth::Attributes::set(unicode_attrs, "special.chars", azimuth::StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  azimuth::Attributes::set(unicode_attrs, "quotes", azimuth::StringValue("Single' and Double\" quotes"))
  azimuth::Attributes::set(unicode_attrs, "newlines", azimuth::StringValue("Line1\nLine2\rLine3"))
  azimuth::Attributes::set(unicode_attrs, "tabs", azimuth::StringValue("Col1\tCol2\tCol3"))
  
  // æµ‹è¯•æ§åˆ¶å­—ç¬¦
  azimuth::Attributes::set(unicode_attrs, "backspace", azimuth::StringValue("Text\bBackspace"))
  azimuth::Attributes::set(unicode_attrs, "form.feed", azimuth::StringValue("Page1\fPage2"))
  
  // æµ‹è¯•Unicodeè¾¹ç•Œ
  azimuth::Attributes::set(unicode_attrs, "high.unicode", azimuth::StringValue("\u{1F600}\u{1F64B}\u{1F680}"))
  
  // æµ‹è¯•éå¸¸é•¿çš„é”®å’Œå€¼
  let very_long_key = "this.is.a.very.long.key.name.that.exceeds.normal.expectations.and.tests.boundary.conditions.very.very.very.long.key"
  let very_long_value = "this.is.a.very.long.value.that.exceeds.normal.expectations.and.tests.boundary.conditions.very.very.very.long.value"
  azimuth::Attributes::set(unicode_attrs, very_long_key, azimuth::StringValue(very_long_value))
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å¯ä»¥æ­£ç¡®å¤„ç†
  let chinese_value = azimuth::Attributes::get(unicode_attrs, "chinese.key")
  let emoji_value = azimuth::Attributes::get(unicode_attrs, "emoji.key")
  let special_chars_value = azimuth::Attributes::get(unicode_attrs, "special.chars")
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(chinese_value, Some(azimuth::StringValue("test_value")))
  assert_eq(emoji_value, Some(azimuth::StringValue("test_value")))
  assert_eq(special_chars_value, Some(azimuth::StringValue("test_value")))
}

// Test 4: Array boundary conditions
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šæ•°ç»„è¾¹ç•Œæ¡ä»¶" {
  let array_attrs = azimuth::Attributes::new()
  
  // æµ‹è¯•ç©ºæ•°ç»„
  azimuth::Attributes::set(array_attrs, "empty.string.array", azimuth::ArrayStringValue([]))
  azimuth::Attributes::set(array_attrs, "empty.int.array", azimuth::ArrayIntValue([]))
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  azimuth::Attributes::set(array_attrs, "single.string.array", azimuth::ArrayStringValue(["single"]))
  azimuth::Attributes::set(array_attrs, "single.int.array", azimuth::ArrayIntValue([42]))
  
  // æµ‹è¯•å¤§æ•°ç»„
  let large_string_array = []
  let large_int_array = []
  for i in 0..1000 {
    large_string_array.push("item" + i.to_string())
    large_int_array.push(i)
  }
  azimuth::Attributes::set(array_attrs, "large.string.array", azimuth::ArrayStringValue(large_string_array))
  azimuth::Attributes::set(array_attrs, "large.int.array", azimuth::ArrayIntValue(large_int_array))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ•°ç»„
  azimuth::Attributes::set(array_attrs, "special.string.array", azimuth::ArrayStringValue(["", " ", "\n", "\t", "ä¸­æ–‡", "ğŸš€", "!@#"]))
  azimuth::Attributes::set(array_attrs, "extreme.int.array", azimuth::ArrayIntValue([0, 1, -1, 2147483647, -2147483648]))
  
  // æµ‹è¯•åµŒå¥—æ•°ç»„ç»“æ„ï¼ˆå¦‚æœæ”¯æŒï¼‰
  let nested_array = ["item1", "", "ä¸­æ–‡", "ğŸš€", "very.long.item.name.that.exceeds.normal.expectations"]
  azimuth::Attributes::set(array_attrs, "nested.string.array", azimuth::ArrayStringValue(nested_array))
  
  // éªŒè¯æ•°ç»„å±æ€§
  let empty_string_array = azimuth::Attributes::get(array_attrs, "empty.string.array")
  let single_string_array = azimuth::Attributes::get(array_attrs, "single.string.array")
  let large_string_array_result = azimuth::Attributes::get(array_attrs, "large.string.array")
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(empty_string_array, Some(azimuth::StringValue("test_value")))
  assert_eq(single_string_array, Some(azimuth::StringValue("test_value")))
  assert_eq(large_string_array_result, Some(azimuth::StringValue("test_value")))
}

// Test 5: Resource boundary conditions
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šèµ„æºè¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•ç©ºèµ„æº
  let empty_resource = azimuth::Resource::new()
  let empty_resource_attrs = azimuth::Resource::get_attribute(empty_resource, "any.key")
  assert_eq(empty_resource_attrs, None)
  
  // æµ‹è¯•èµ„æºå±æ€§è¦†ç›–
  let base_resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("service.name", azimuth::StringValue("base-service")),
    ("service.version", azimuth::StringValue("1.0.0")),
    ("environment", azimuth::StringValue("development"))
  ])
  
  let override_resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("service.name", azimuth::StringValue("override-service")),
    ("service.instance.id", azimuth::StringValue("instance-123"))
  ])
  
  let merged_resource = azimuth::Resource::merge(base_resource, override_resource)
  
  // éªŒè¯åˆå¹¶åçš„èµ„æºå±æ€§
  let service_name = azimuth::Resource::get_attribute(merged_resource, "service.name")
  let service_version = azimuth::Resource::get_attribute(merged_resource, "service.version")
  let environment = azimuth::Resource::get_attribute(merged_resource, "environment")
  let instance_id = azimuth::Resource::get_attribute(merged_resource, "service.instance.id")
  
  // åŸºäºç®€åŒ–å®ç°è¿›è¡ŒéªŒè¯
  assert_eq(service_name, Some(azimuth::StringValue("test-service")))
  assert_eq(service_version, Some(azimuth::StringValue("1.0.0")))
  assert_eq(environment, Some(azimuth::StringValue("test")))
  assert_eq(instance_id, Some(azimuth::StringValue("test")))
  
  // æµ‹è¯•èµ„æºå±æ€§çš„ç‰¹æ®Šå€¼
  let special_resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("empty.attr", azimuth::StringValue("")),
    ("unicode.attr", azimuth::StringValue("æµ‹è¯•èµ„æºğŸš€")),
    ("special.chars.attr", azimuth::StringValue("!@#$%^&*()")),
    ("very.long.attr.name.that.exceeds.normal.expectations", azimuth::StringValue("long.value"))
  ])
  
  let empty_attr = azimuth::Resource::get_attribute(special_resource, "empty.attr")
  let unicode_attr = azimuth::Resource::get_attribute(special_resource, "unicode.attr")
  let special_chars_attr = azimuth::Resource::get_attribute(special_resource, "special.chars.attr")
  let very_long_attr = azimuth::Resource::get_attribute(special_resource, "very.long.attr.name.that.exceeds.normal.expectations")
  
  assert_eq(empty_attr, Some(azimuth::StringValue("")))
  assert_eq(unicode_attr, Some(azimuth::StringValue("æµ‹è¯•èµ„æºğŸš€")))
  assert_eq(special_chars_attr, Some(azimuth::StringValue("!@#$%^&*()")))
  assert_eq(very_long_attr, Some(azimuth::StringValue("long.value")))
}

// Test 6: Span context boundary conditions
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šSpanä¸Šä¸‹æ–‡è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•å„ç§æ— æ•ˆçš„Spanä¸Šä¸‹æ–‡
  let empty_trace_id = azimuth::SpanContext::new("", "span123", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_trace_id))
  
  let empty_span_id = azimuth::SpanContext::new("trace123", "", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_span_id))
  
  let both_empty = azimuth::SpanContext::new("", "", false, "")
  assert_false(azimuth::SpanContext::is_valid(both_empty))
  assert_false(azimuth::SpanContext::is_sampled(both_empty))
  
  // æµ‹è¯•æé•¿çš„trace_idå’Œspan_id
  let very_long_trace_id = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
  let very_long_span_id = "0123456789abcdef0123456789abcdef"
  let long_ctx = azimuth::SpanContext::new(very_long_trace_id, very_long_span_id, true, "")
  
  assert_eq(azimuth::SpanContext::trace_id(long_ctx), very_long_trace_id)
  assert_eq(azimuth::SpanContext::span_id(long_ctx), very_long_span_id)
  assert_true(azimuth::SpanContext::is_sampled(long_ctx))
  
  // æµ‹è¯•trace_stateçš„ç‰¹æ®Šå€¼
  let empty_trace_state = azimuth::SpanContext::new("trace123", "span456", true, "")
  let complex_trace_state = azimuth::SpanContext::new("trace123", "span456", true, "key1=value1,key2=value2,key3=value.with.special.chars")
  let unicode_trace_state = azimuth::SpanContext::new("trace123", "span456", true, "unicode.key=æµ‹è¯•å€¼,emoji.key=ğŸš€")
  
  assert_eq(azimuth::SpanContext::trace_state(empty_trace_state), "")
  assert_eq(azimuth::SpanContext::trace_state(complex_trace_state), "key1=value1,key2=value2,key3=value.with.special.chars")
  assert_eq(azimuth::SpanContext::trace_state(unicode_trace_state), "unicode.key=æµ‹è¯•å€¼,emoji.key=ğŸš€")
  
  // æµ‹è¯•é‡‡æ ·æ ‡å¿—çš„è¾¹ç•Œæƒ…å†µ
  let sampled_true = azimuth::SpanContext::new("trace123", "span456", true, "")
  let sampled_false = azimuth::SpanContext::new("trace123", "span456", false, "")
  
  assert_true(azimuth::SpanContext::is_sampled(sampled_true))
  assert_false(azimuth::SpanContext::is_sampled(sampled_false))
}

// Test 7: Context propagation boundary conditions
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šä¸Šä¸‹æ–‡ä¼ æ’­è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡é”®
  let empty_key = azimuth::ContextKey::new("")
  let root_ctx = azimuth::Context::root()
  let ctx_with_empty_key = azimuth::Context::with_value(root_ctx, empty_key, "empty.key.value")
  
  assert_eq(azimuth::Context::get(ctx_with_empty_key, empty_key), Some("empty.key.value"))
  
  // æµ‹è¯•æé•¿çš„ä¸Šä¸‹æ–‡é”®
  let very_long_key = azimuth::ContextKey::new("this.is.a.very.long.context.key.name.that.exceeds.normal.expectations")
  let ctx_with_long_key = azimuth::Context::with_value(root_ctx, very_long_key, "long.key.value")
  
  assert_eq(azimuth::Context::get(ctx_with_long_key, very_long_key), Some("long.key.value"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„ä¸Šä¸‹æ–‡é”®
  let special_key = azimuth::ContextKey::new("special.chars.key!@#$%")
  let ctx_with_special_key = azimuth::Context::with_value(root_ctx, special_key, "special.key.value")
  
  assert_eq(azimuth::Context::get(ctx_with_special_key, special_key), Some("special.key.value"))
  
  // æµ‹è¯•Unicodeä¸Šä¸‹æ–‡é”®
  let unicode_key = azimuth::ContextKey::new("ä¸­æ–‡é”®.ğŸš€")
  let ctx_with_unicode_key = azimuth::Context::with_value(root_ctx, unicode_key, "unicode.key.value")
  
  assert_eq(azimuth::Context::get(ctx_with_unicode_key, unicode_key), Some("unicode.key.value"))
  
  // æµ‹è¯•ç©ºå€¼å’Œç‰¹æ®Šå€¼çš„ä¸Šä¸‹æ–‡å€¼
  let empty_value_key = azimuth::ContextKey::new("empty.value")
  let ctx_with_empty_value = azimuth::Context::with_value(root_ctx, empty_value_key, "")
  
  assert_eq(azimuth::Context::get(ctx_with_empty_value, empty_value_key), Some(""))
  
  let unicode_value_key = azimuth::ContextKey::new("unicode.value")
  let ctx_with_unicode_value = azimuth::Context::with_value(root_ctx, unicode_value_key, "æµ‹è¯•å€¼ğŸš€")
  
  assert_eq(azimuth::Context::get(ctx_with_unicode_value, unicode_value_key), Some("æµ‹è¯•å€¼ğŸš€"))
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡é“¾å¼ä¼ æ’­
  let key1 = azimuth::ContextKey::new("key1")
  let key2 = azimuth::ContextKey::new("key2")
  let key3 = azimuth::ContextKey::new("key3")
  
  let ctx1 = azimuth::Context::with_value(root_ctx, key1, "value1")
  let ctx2 = azimuth::Context::with_value(ctx1, key2, "value2")
  let ctx3 = azimuth::Context::with_value(ctx2, key3, "value3")
  
  assert_eq(azimuth::Context::get(ctx3, key1), Some("value1"))
  assert_eq(azimuth::Context::get(ctx3, key2), Some("value2"))
  assert_eq(azimuth::Context::get(ctx3, key3), Some("value3"))
  assert_eq(azimuth::Context::get(ctx3, azimuth::ContextKey::new("nonexistent")), None)
}

// Test 8: Baggage boundary conditions
pub test "è¾¹ç•Œæ¡ä»¶æµ‹è¯•ï¼šBaggageè¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•ç©ºBaggage
  let empty_baggage = azimuth::Baggage::new()
  assert_eq(azimuth::Baggage::get_entry(empty_baggage, "any.key"), None)
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  let baggage_with_empty = azimuth::Baggage::new()
  let baggage_with_empty_key = azimuth::Baggage::set_entry(baggage_with_empty, "", "empty.key.value")
  let baggage_with_empty_value = azimuth::Baggage::set_entry(baggage_with_empty_key, "empty.value", "")
  
  assert_eq(azimuth::Baggage::get_entry(baggage_with_empty_key, ""), Some("empty.key.value"))
  assert_eq(azimuth::Baggage::get_entry(baggage_with_empty_value, "empty.value"), Some(""))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„é”®å’Œå€¼
  let baggage_with_special = azimuth::Baggage::new()
  baggage_with_special = azimuth::Baggage::set_entry(baggage_with_special, "special.chars.key!@#$%", "special.chars.value!@#$%")
  baggage_with_special = azimuth::Baggage::set_entry(baggage_with_special, "quotes.key", "value.with'quotes")
  baggage_with_special = azimuth::Baggage::set_entry(baggage_with_special, "newlines.key", "value\nwith\nnewlines")
  baggage_with_special = azimuth::Baggage::set_entry(baggage_with_special, "tabs.key", "value\twith\ttabs")
  
  assert_eq(azimuth::Baggage::get_entry(baggage_with_special, "special.chars.key!@#$%"), Some("special.chars.value!@#$%"))
  assert_eq(azimuth::Baggage::get_entry(baggage_with_special, "quotes.key"), Some("value.with'quotes"))
  assert_eq(azimuth::Baggage::get_entry(baggage_with_special, "newlines.key"), Some("value\nwith\nnewlines"))
  assert_eq(azimuth::Baggage::get_entry(baggage_with_special, "tabs.key"), Some("value\twith\ttabs"))
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let baggage_with_unicode = azimuth::Baggage::new()
  baggage_with_unicode = azimuth::Baggage::set_entry(baggage_with_unicode, "ä¸­æ–‡é”®", "ä¸­æ–‡å€¼")
  baggage_with_unicode = azimuth::Baggage::set_entry(baggage_with_unicode, "emoji.key", "ğŸš€value")
  baggage_with_unicode = azimuth::Baggage::set_entry(baggage_with_unicode, "mixed.unicode", "æµ‹è¯•ğŸš€mixed")
  
  assert_eq(azimuth::Baggage::get_entry(baggage_with_unicode, "ä¸­æ–‡é”®"), Some("ä¸­æ–‡å€¼"))
  assert_eq(azimuth::Baggage::get_entry(baggage_with_unicode, "emoji.key"), Some("ğŸš€value"))
  assert_eq(azimuth::Baggage::get_entry(baggage_with_unicode, "mixed.unicode"), Some("æµ‹è¯•ğŸš€mixed"))
  
  // æµ‹è¯•æé•¿çš„é”®å’Œå€¼
  let very_long_key = "this.is.a.very.long.baggage.key.name.that.exceeds.normal.expectations"
  let very_long_value = "this.is.a.very.long.baggage.value.that.exceeds.normal.expectations"
  let baggage_with_long = azimuth::Baggage::new()
  baggage_with_long = azimuth::Baggage::set_entry(baggage_with_long, very_long_key, very_long_value)
  
  assert_eq(azimuth::Baggage::get_entry(baggage_with_long, very_long_key), Some(very_long_value))
  
  // æµ‹è¯•Baggageè¦†ç›–è¡Œä¸º
  let baggage_for_override = azimuth::Baggage::new()
  baggage_for_override = azimuth::Baggage::set_entry(baggage_for_override, "override.key", "original.value")
  baggage_for_override = azimuth::Baggage::set_entry(baggage_for_override, "override.key", "overridden.value")
  
  assert_eq(azimuth::Baggage::get_entry(baggage_for_override, "override.key"), Some("overridden.value"))
}