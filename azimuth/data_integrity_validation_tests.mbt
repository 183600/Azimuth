// æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºé¥æµ‹æ•°æ®çš„å®Œæ•´æ€§ã€ä¸€è‡´æ€§å’Œå‡†ç¡®æ€§éªŒè¯

test "Spanæ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "integrity.tracer")
  
  // åˆ›å»ºå…·æœ‰å®Œæ•´æ•°æ®çš„Span
  let span = Tracer::start_span(tracer, "integrity.test.span")
  let span_ctx = Span::span_context(span)
  
  // éªŒè¯SpanåŸºæœ¬æ•°æ®å®Œæ•´æ€§
  assert_eq(Span::name(span), "integrity.test.span")
  assert_true(Span::is_recording(span))
  assert_true(SpanContext::is_valid(span_ctx))
  assert_true(SpanContext::span_id(span_ctx) != "")
  assert_true(SpanContext::trace_id(span_ctx) != "")
  
  // è®¾ç½®çŠ¶æ€å’Œäº‹ä»¶
  Span::set_status(span, Ok, Some("Integrity test successful"))
  Span::add_event(span, "integrity.start.event", Some([
    ("test.type", StringValue("data.integrity")),
    ("test.timestamp", IntValue(1735689600)),
    ("test.version", StringValue("1.0.0"))
  ]))
  
  // éªŒè¯SpançŠ¶æ€å®Œæ•´æ€§
  assert_true(Span::is_recording(span))
  assert_eq(Span::kind(span), Internal)
  
  // æ·»åŠ æ›´å¤šäº‹ä»¶éªŒè¯æ•°æ®å®Œæ•´æ€§
  for i = 0; i < 10; i = i + 1 {
    Span::add_event(span, "integrity.event." + i.to_string(), Some([
      ("event.sequence", IntValue(i)),
      ("event.data", StringValue("test.data." + i.to_string())),
      ("event.timestamp", IntValue(1735689600 + i))
    ]))
  }
  
  // ç»“æŸSpanå¹¶éªŒè¯æœ€ç»ˆçŠ¶æ€
  Span::end(span)
  assert_false(Span::is_recording(span))
  
  // éªŒè¯Spanä¸Šä¸‹æ–‡æ•°æ®å®Œæ•´æ€§
  let final_ctx = Span::span_context(span)
  assert_eq(SpanContext::trace_id(final_ctx), SpanContext::trace_id(span_ctx))
  assert_eq(SpanContext::span_id(final_ctx), SpanContext::span_id(span_ctx))
}

test "æŒ‡æ ‡æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "integrity.meter")
  
  // åˆ›å»ºå„ç§ç±»å‹çš„æŒ‡æ ‡ä»ªå™¨
  let counter = Meter::create_counter(meter, "integrity.counter")
  let histogram = Meter::create_histogram(meter, "integrity.histogram")
  let updown_counter = Meter::create_updown_counter(meter, "integrity.updown")
  let gauge = Meter::create_gauge(meter, "integrity.gauge")
  
  // éªŒè¯ä»ªå™¨å…ƒæ•°æ®å®Œæ•´æ€§
  assert_eq(counter.name, "integrity.counter")
  assert_eq(histogram.name, "integrity.histogram")
  assert_eq(updown_counter.name, "integrity.updown")
  assert_eq(gauge.name, "integrity.gauge")
  
  // è®°å½•å·²çŸ¥å€¼å¹¶éªŒè¯æ•°æ®å®Œæ•´æ€§
  let test_values = [0.0, 1.0, 42.5, 100.0, -50.0, 3.14159]
  let expected_sum = 0.0
  
  for value in test_values {
    Counter::add(counter, value)
    Histogram::record(histogram, value)
    UpDownCounter::add(updown_counter, value)
    
    // éªŒè¯æ¯æ¬¡æ“ä½œåä»ªå™¨çŠ¶æ€å®Œæ•´æ€§
    assert_eq(counter.name, "integrity.counter")
    assert_eq(histogram.name, "integrity.histogram")
    assert_eq(updown_counter.name, "integrity.updown")
  }
  
  // æµ‹è¯•è¾¹ç•Œå€¼æ•°æ®å®Œæ•´æ€§
  let boundary_values = [
    0.0,                    // é›¶å€¼
    1.7976931348623157e+308, // æœ€å¤§Double
    -1.7976931348623157e+308, // æœ€å°Double
    1.23e-10,               // æå°æ­£å€¼
    -1.23e-10,              // æå°è´Ÿå€¼
    1.0 / 0.0,              // æ­£æ— ç©·
    -1.0 / 0.0,             // è´Ÿæ— ç©·
    0.0 / 0.0               // NaN
  ]
  
  for boundary_value in boundary_values {
    Counter::add(counter, boundary_value)
    Histogram::record(histogram, boundary_value)
    UpDownCounter::add(updown_counter, boundary_value)
    
    // éªŒè¯è¾¹ç•Œå€¼å¤„ç†åä»ªå™¨å®Œæ•´æ€§
    assert_eq(counter.name, "integrity.counter")
    assert_eq(histogram.name, "integrity.histogram")
    assert_eq(updown_counter.name, "integrity.updown")
  }
  
  // éªŒè¯ä»ªå™¨ç±»å‹å®Œæ•´æ€§
  let counter_instrument = Counter(counter.name, counter.description, counter.unit)
  let histogram_instrument = Histogram(histogram.name, histogram.description, histogram.unit)
  
  assert_eq(Instrument::name(counter_instrument), "integrity.counter")
  assert_eq(Instrument::name(histogram_instrument), "integrity.histogram")
}

test "æ—¥å¿—æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "integrity.logger")
  
  // æµ‹è¯•ä¸åŒä¸¥é‡æ€§çº§åˆ«çš„æ—¥å¿—æ•°æ®å®Œæ•´æ€§
  let severities = [Trace, Debug, Info, Warn, Error, Fatal]
  let test_messages = [
    "Trace level integrity test",
    "Debug level integrity test",
    "Info level integrity test",
    "Warning level integrity test",
    "Error level integrity test",
    "Fatal level integrity test"
  ]
  
  for i = 0; i < severities.length(); i = i + 1 {
    let record = LogRecord::new(severities[i], test_messages[i])
    
    // éªŒè¯æ—¥å¿—è®°å½•åŸºæœ¬å®Œæ•´æ€§
    assert_eq(LogRecord::severity_number(record), severities[i])
    assert_eq(LogRecord::body(record), Some(test_messages[i]))
    
    Logger::emit(logger, record)
  }
  
  // æµ‹è¯•å¸¦å®Œæ•´ä¸Šä¸‹æ–‡çš„æ—¥å¿—è®°å½•
  let attrs = Attributes::new()
  Attributes::set(attrs, "log.test.type", StringValue("data.integrity"))
  Attributes::set(attrs, "log.test.version", StringValue("1.0.0"))
  Attributes::set(attrs, "log.test.sequence", IntValue(1))
  
  let contextual_record = LogRecord::new_with_context(
    Error,
    Some("Contextual integrity test log"),
    Some(attrs),
    Some(1735689600000000000L),
    Some(1735689600000001000L),
    Some("integrity-trace-12345"),
    Some("integrity-span-67890"),
    Some(Context::with_value(Context::root(), ContextKey::new("test.context"), "integrity.value"))
  )
  
  // éªŒè¯å®Œæ•´ä¸Šä¸‹æ–‡æ—¥å¿—è®°å½•
  assert_eq(LogRecord::severity_number(contextual_record), Error)
  assert_eq(LogRecord::body(contextual_record), Some("Contextual integrity test log"))
  assert_eq(LogRecord::trace_id(contextual_record), Some("integrity-trace-12345"))
  assert_eq(LogRecord::span_id(contextual_record), Some("integrity-span-67890"))
  assert_eq(LogRecord::trace_id(contextual_record), Some("integrity-trace-12345"))
  
  Logger::emit(logger, contextual_record)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeæ—¥å¿—å®Œæ•´æ€§
  let special_messages = [
    "Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?",
    "Unicode test: æµ‹è¯•ğŸš€Ğ¢ĞµÑÑ‚Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
    "Mixed: Hello æµ‹è¯• ğŸš€ World 123 !@#",
    "Newlines:\nLine1\nLine2\nLine3",
    "Tabs:\tCol1\tCol2\tCol3"
  ]
  
  for special_msg in special_messages {
    let special_record = LogRecord::new(Info, special_msg)
    assert_eq(LogRecord::body(special_record), Some(special_msg))
    Logger::emit(logger, special_record)
  }
}

test "å±æ€§æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // æµ‹è¯•å„ç§å±æ€§ç±»å‹çš„å®Œæ•´æ€§
  let attrs = Attributes::new()
  
  // å­—ç¬¦ä¸²å±æ€§å®Œæ•´æ€§æµ‹è¯•
  let string_values = [
    "",
    "hello",
    "hello world",
    "1234567890",
    "special!@#$%^&*()",
    "unicodeæµ‹è¯•ğŸš€",
    "a" * 1000  // é•¿å­—ç¬¦ä¸²
  ]
  
  for i = 0; i < string_values.length(); i = i + 1 {
    let key = "string.attr." + i.to_string()
    let value = StringValue(string_values[i])
    Attributes::set(attrs, key, value)
    
    // éªŒè¯è®¾ç½®å’Œè·å–ä¸€è‡´æ€§
    let retrieved = Attributes::get(attrs, key)
    assert_true(retrieved is Some)
    match retrieved {
      Some(StringValue(retrieved_string)) => assert_eq(retrieved_string, string_values[i])
      _ => assert_true(false)
    }
  }
  
  // æ•´æ•°å±æ€§å®Œæ•´æ€§æµ‹è¯•
  let int_values = [0, 1, -1, 42, -42, 2147483647, -2147483648]
  
  for i = 0; i < int_values.length(); i = i + 1 {
    let key = "int.attr." + i.to_string()
    let value = IntValue(int_values[i])
    Attributes::set(attrs, key, value)
    
    let retrieved = Attributes::get(attrs, key)
    assert_true(retrieved is Some)
    match retrieved {
      Some(IntValue(retrieved_int)) => assert_eq(retrieved_int, int_values[i])
      _ => assert_true(false)
    }
  }
  
  // æµ®ç‚¹æ•°å±æ€§å®Œæ•´æ€§æµ‹è¯•
  let float_values = [0.0, 1.0, -1.0, 3.14159, -3.14159, 1.7976931348623157e+308, -1.7976931348623157e+308]
  
  for i = 0; i < float_values.length(); i = i + 1 {
    let key = "float.attr." + i.to_string()
    let value = FloatValue(float_values[i])
    Attributes::set(attrs, key, value)
    
    let retrieved = Attributes::get(attrs, key)
    assert_true(retrieved is Some)
    match retrieved {
      Some(FloatValue(retrieved_float)) => {
        // æµ®ç‚¹æ•°æ¯”è¾ƒä½¿ç”¨è¿‘ä¼¼ç›¸ç­‰
        let diff = retrieved_float - float_values[i]
        assert_true(diff.abs() < 0.000001 || diff.is_nan() && float_values[i].is_nan())
      }
      _ => assert_true(false)
    }
  }
  
  // å¸ƒå°”å±æ€§å®Œæ•´æ€§æµ‹è¯•
  let bool_values = [true, false]
  
  for i = 0; i < bool_values.length(); i = i + 1 {
    let key = "bool.attr." + i.to_string()
    let value = BoolValue(bool_values[i])
    Attributes::set(attrs, key, value)
    
    let retrieved = Attributes::get(attrs, key)
    assert_true(retrieved is Some)
    match retrieved {
      Some(BoolValue(retrieved_bool)) => assert_eq(retrieved_bool, bool_values[i])
      _ => assert_true(false)
    }
  }
  
  // æ•°ç»„å±æ€§å®Œæ•´æ€§æµ‹è¯•
  let string_array_value = ArrayStringValue(["item1", "item2", "item3", "æµ‹è¯•", "ğŸš€"])
  let int_array_value = ArrayIntValue([1, 2, 3, 42, -42])
  
  Attributes::set(attrs, "string.array.attr", string_array_value)
  Attributes::set(attrs, "int.array.attr", int_array_value)
  
  let retrieved_string_array = Attributes::get(attrs, "string.array.attr")
  let retrieved_int_array = Attributes::get(attrs, "int.array.attr")
  
  assert_true(retrieved_string_array is Some)
  assert_true(retrieved_int_array is Some)
}

test "ä¸Šä¸‹æ–‡ä¼ æ’­æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡æ•°æ®å®Œæ•´æ€§
  let root_ctx = Context::root()
  
  // è®¾ç½®å¤šä¸ªä¸Šä¸‹æ–‡å€¼
  let ctx1 = Context::with_value(root_ctx, ContextKey::new("test.key.1"), "test.value.1")
  let ctx2 = Context::with_value(ctx1, ContextKey::new("test.key.2"), "test.value.2")
  let ctx3 = Context::with_value(ctx2, ContextKey::new("test.key.3"), "test.value.3")
  
  // éªŒè¯ä¸Šä¸‹æ–‡å€¼è·å–å®Œæ•´æ€§
  let value1 = Context::get(ctx3, ContextKey::new("test.key.1"))
  let value2 = Context::get(ctx3, ContextKey::new("test.key.2"))
  let value3 = Context::get(ctx3, ContextKey::new("test.key.3"))
  
  assert_eq(value1, Some("test.value.1"))
  assert_eq(value2, Some("test.value.2"))
  assert_eq(value3, Some("test.value.3"))
  
  // æµ‹è¯•ä¼ æ’­å™¨æ•°æ®å®Œæ•´æ€§
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let carrier = TextMapCarrier::new()
  
  // æ³¨å…¥ä¸Šä¸‹æ–‡
  CompositePropagator::inject(propagator, ctx3, carrier)
  
  // è®¾ç½®é¢å¤–å¤´éƒ¨
  TextMapCarrier::set(carrier, "custom.header.1", "custom.value.1")
  TextMapCarrier::set(carrier, "custom.header.2", "custom.value.2")
  
  // éªŒè¯è½½ä½“æ•°æ®å®Œæ•´æ€§
  let trace_value = TextMapCarrier::get(carrier, "traceparent")
  let custom1 = TextMapCarrier::get(carrier, "custom.header.1")
  let custom2 = TextMapCarrier::get(carrier, "custom.header.2")
  
  assert_true(trace_value is Some)
  assert_eq(custom1, Some("custom.value.1"))
  assert_eq(custom2, Some("custom.value.2"))
  
  // æå–ä¸Šä¸‹æ–‡å¹¶éªŒè¯å®Œæ•´æ€§
  let extracted_ctx = CompositePropagator::extract(propagator, carrier)
  let extracted_value = Context::get(extracted_ctx, ContextKey::new("extracted"))
  
  assert_true(extracted_value is Some)
  
  // æµ‹è¯•Baggageæ•°æ®å®Œæ•´æ€§
  let baggage = Baggage::new()
  
  // è®¾ç½®å¤šä¸ªBaggageæ¡ç›®
  let baggage1 = Baggage::set_entry(baggage, "baggage.key.1", "baggage.value.1")
  let baggage2 = Baggage::set_entry(baggage1, "baggage.key.2", "baggage.value.2")
  let baggage3 = Baggage::set_entry(baggage2, "baggage.key.3", "baggage.value.3")
  
  // éªŒè¯Baggageæ¡ç›®å®Œæ•´æ€§
  let bag_value1 = Baggage::get_entry(baggage3, "baggage.key.1")
  let bag_value2 = Baggage::get_entry(baggage3, "baggage.key.2")
  let bag_value3 = Baggage::get_entry(baggage3, "baggage.key.3")
  
  assert_eq(bag_value1, Some("baggage.value.1"))
  assert_eq(bag_value2, Some("baggage.value.2"))
  assert_eq(bag_value3, Some("baggage.value.3"))
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  let missing_bag_value = Baggage::get_entry(baggage3, "nonexistent.key")
  assert_eq(missing_bag_value, None)
}

test "èµ„æºæ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // æµ‹è¯•èµ„æºå±æ€§å®Œæ•´æ€§
  let resource = Resource::new()
  
  // è®¾ç½®å„ç§ç±»å‹çš„èµ„æºå±æ€§
  let resource_attrs = [
    ("service.name", StringValue("integrity-test-service")),
    ("service.version", StringValue("1.0.0")),
    ("service.instance.id", StringValue("integrity-instance-123")),
    ("deployment.environment", StringValue("test")),
    ("host.name", StringValue("integrity-test-host")),
    ("process.id", IntValue(12345)),
    ("process.start.time", IntValue(1735689600)),
    ("cpu.count", IntValue(4)),
    ("memory.total", IntValue(8589934592)),
    ("service.uptime", FloatValue(3600.5)),
    ("service.debug.enabled", BoolValue(true))
  ]
  
  let enriched_resource = Resource::with_attributes(resource, resource_attrs)
  
  // éªŒè¯æ¯ä¸ªèµ„æºå±æ€§å®Œæ•´æ€§
  for (key, expected_value) in resource_attrs {
    let actual_value = Resource::get_attribute(enriched_resource, key)
    assert_true(actual_value is Some)
    
    match expected_value {
      StringValue(expected_str) => {
        match actual_value {
          Some(StringValue(actual_str)) => assert_eq(actual_str, expected_str)
          _ => assert_true(false)
        }
      }
      IntValue(expected_int) => {
        match actual_value {
          Some(IntValue(actual_int)) => assert_eq(actual_int, expected_int)
          _ => assert_true(false)
        }
      }
      FloatValue(expected_float) => {
        match actual_value {
          Some(FloatValue(actual_float)) => {
            let diff = actual_float - expected_float
            assert_true(diff.abs() < 0.000001)
          }
          _ => assert_true(false)
        }
      }
      BoolValue(expected_bool) => {
        match actual_value {
          Some(BoolValue(actual_bool)) => assert_eq(actual_bool, expected_bool)
          _ => assert_true(false)
        }
      }
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•èµ„æºåˆå¹¶å®Œæ•´æ€§
  let base_resource = Resource::with_attributes(Resource::new(), [
    ("base.attr.1", StringValue("base.value.1")),
    ("base.attr.2", StringValue("base.value.2"))
  ])
  
  let override_resource = Resource::with_attributes(Resource::new(), [
    ("override.attr.1", StringValue("override.value.1")),
    ("override.attr.2", StringValue("override.value.2"))
  ])
  
  let merged_resource = Resource::merge(base_resource, override_resource)
  
  // éªŒè¯åˆå¹¶ç»“æœå®Œæ•´æ€§
  let override1 = Resource::get_attribute(merged_resource, "override.attr.1")
  let override2 = Resource::get_attribute(merged_resource, "override.attr.2")
  
  assert_true(override1 is Some)
  assert_true(override2 is Some)
  
  match override1 {
    Some(StringValue(value)) => assert_eq(value, "override.value.1")
    _ => assert_true(false)
  }
  
  match override2 {
    Some(StringValue(value)) => assert_eq(value, "override.value.2")
    _ => assert_true(false)
  }
}