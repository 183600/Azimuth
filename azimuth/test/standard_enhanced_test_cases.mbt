// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// è¿™äº›æµ‹è¯•ç”¨ä¾‹è¡¥å……ç°æœ‰æµ‹è¯•ï¼Œæä¾›æ›´å…¨é¢çš„è¦†ç›–

test "performance_stress_test" {
  // æ€§èƒ½å‹åŠ›æµ‹è¯• - å¤§é‡è¿ç»­è¿ç®—
  let mut result = 1
  result = @azimuth.add(result, 1)
  result = @azimuth.multiply(result, 2)
  result = @azimuth.add(result, 3)
  result = @azimuth.multiply(result, 4)
  result = @azimuth.add(result, 5)
  result = @azimuth.multiply(result, 6)
  result = @azimuth.add(result, 7)
  result = @azimuth.multiply(result, 8)
  result = @azimuth.add(result, 9)
  result = @azimuth.multiply(result, 10)
  @azimuth.assert_eq(3628800, result)
}

test "function_composition_complex" {
  // å¤æ‚å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 100
  
  // é“¾å¼è¿ç®—ï¼š(base + 50) * 2 - 30
  let step1 = @azimuth.add(base_value, 50)
  let step2 = @azimuth.multiply(step1, 2)
  let step3 = @azimuth.add(step2, -30)
  @azimuth.assert_eq(220, step3)
  
  // åµŒå¥—è¿ç®—ï¼š((10 + 20) * (5 + 3)) + 15
  let inner_sum1 = @azimuth.add(10, 20)
  let inner_sum2 = @azimuth.add(5, 3)
  let product = @azimuth.multiply(inner_sum1, inner_sum2)
  let final_result = @azimuth.add(product, 15)
  @azimuth.assert_eq(175, final_result)
}

test "divide_with_ceil_edge_cases_comprehensive" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„ç»¼åˆè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶ä¿æŠ¤
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(10, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(-10, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  @azimuth.assert_eq(2147483647, @azimuth.divide_with_ceil(max_val, 1))
  @azimuth.assert_eq(1073741824, @azimuth.divide_with_ceil(max_val, 2))
  @azimuth.assert_eq(-2147483648, @azimuth.divide_with_ceil(min_val, 1))
  @azimuth.assert_eq(-1073741824, @azimuth.divide_with_ceil(min_val, 2))
  
  // ç‰¹æ®Šä½™æ•°æƒ…å†µ
  @azimuth.assert_eq(2, @azimuth.divide_with_ceil(3, 2))
  @azimuth.assert_eq(2, @azimuth.divide_with_ceil(4, 2))
  @azimuth.assert_eq(3, @azimuth.divide_with_ceil(5, 2))
  @azimuth.assert_eq(-1, @azimuth.divide_with_ceil(-1, 2))
  @azimuth.assert_eq(-2, @azimuth.divide_with_ceil(-3, 2))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  // é•¿å­—ç¬¦ä¸²å¤„ç†
  let long_string = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  let long_result = @azimuth.greet(long_string)
  @azimuth.assert_eq_string("Hello, ABCDEFGHIJKLMNOPQRSTUVWXYZ!", long_result)
  
  // ç‰¹æ®Šç©ºç™½å­—ç¬¦ç»„åˆ
  @azimuth.assert_eq_string("Hello, \t\n\r !", @azimuth.greet("\t\n\r "))
  
  // Unicodeè¡¨æƒ…ç¬¦å·
  @azimuth.assert_eq_string("Hello, ğŸš€ğŸŒ™â­!", @azimuth.greet("ğŸš€ğŸŒ™â­"))
  
  // æ··åˆå†…å®¹å­—ç¬¦ä¸²
  @azimuth.assert_eq_string("Hello, Test123ä¸­æ–‡!@#!", @azimuth.greet("Test123ä¸­æ–‡!@#"))
  
  // æ•°å­—å’Œç¬¦å·ç»„åˆ
  @azimuth.assert_eq_string("Hello, 123-456-7890!", @azimuth.greet("123-456-7890"))
}

test "arithmetic_properties_verification" {
  // ç®—æœ¯æ€§è´¨éªŒè¯æµ‹è¯•
  // åˆ†é…å¾‹æµ‹è¯•ï¼š(a + b) * c = a * c + b * c
  let a = 12
  let b = 8
  let c = 5
  
  let left_side = @azimuth.multiply(@azimuth.add(a, b), c)
  let right_side = @azimuth.add(@azimuth.multiply(a, c), @azimuth.multiply(b, c))
  @azimuth.assert_eq(left_side, right_side)
  
  // ç»“åˆå¾‹æµ‹è¯•ï¼š(a + b) + c = a + (b + c)
  let x = 15
  let y = 25
  let z = 35
  
  let add_left = @azimuth.add(@azimuth.add(x, y), z)
  let add_right = @azimuth.add(x, @azimuth.add(y, z))
  @azimuth.assert_eq(add_left, add_right)
  
  // ä¹˜æ³•ç»“åˆå¾‹ï¼š(a * b) * c = a * (b * c)
  let mult_left = @azimuth.multiply(@azimuth.multiply(x, y), z)
  let mult_right = @azimuth.multiply(x, @azimuth.multiply(y, z))
  @azimuth.assert_eq(mult_left, mult_right)
}

test "real_world_business_scenarios" {
  // çœŸå®ä¸šåŠ¡åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè®¡ç®—è®¢å•æ€»ä»·ï¼ˆå•†å“ä»·æ ¼ Ã— æ•°é‡ + è¿è´¹ - æŠ˜æ‰£ï¼‰
  let item_price = 199
  let quantity = 3
  let shipping = 25
  let discount = -50
  
  let subtotal = @azimuth.multiply(item_price, quantity)
  let total_with_shipping = @azimuth.add(subtotal, shipping)
  let final_total = @azimuth.add(total_with_shipping, discount)
  @azimuth.assert_eq(622, final_total)
  
  // åœºæ™¯2ï¼šè®¡ç®—å‘˜å·¥æœˆè–ªï¼ˆåŸºæœ¬å·¥èµ„ + åŠ ç­è´¹ - æ‰£æ¬¾ï¼‰
  let base_salary = 5000
  let overtime_pay = 800
  let deductions = -300
  
  let gross_pay = @azimuth.add(base_salary, overtime_pay)
  let net_pay = @azimuth.add(gross_pay, deductions)
  @azimuth.assert_eq(5500, net_pay)
  
  // åœºæ™¯3ï¼šè®¡ç®—é¡¹ç›®å·¥æœŸï¼ˆå·¥ä½œæ—¥æ•° + å‡æœŸå¤©æ•°ï¼‰
  let work_days = 20
  let holidays = 3
  let buffer_days = 2
  
  let base_duration = @azimuth.add(work_days, holidays)
  let total_duration = @azimuth.add(base_duration, buffer_days)
  @azimuth.assert_eq(25, total_duration)
  
  // åœºæ™¯4ï¼šä¸ªæ€§åŒ–ç”¨æˆ·é—®å€™
  let user_role = "ç®¡ç†å‘˜"
  let user_name = "å¼ ä¸‰"
  let full_title = user_role + " " + user_name
  let greeting = @azimuth.greet(full_title)
  @azimuth.assert_eq_string("Hello, ç®¡ç†å‘˜ å¼ ä¸‰!", greeting)
}

test "boundary_combination_stress" {
  // è¾¹ç•Œç»„åˆå‹åŠ›æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // ç»„åˆ1ï¼šæœ€å¤§å€¼ä¸æœ€å°å€¼çš„è¿ç®—
  let sum1 = @azimuth.add(max_val, min_val)
  let product1 = @azimuth.multiply(max_val, 1)
  let product2 = @azimuth.multiply(min_val, 1)
  @azimuth.assert_eq(-1, sum1)
  @azimuth.assert_eq(max_val, product1)
  @azimuth.assert_eq(min_val, product2)
  
  // ç»„åˆ2ï¼šè¿ç»­è¾¹ç•Œè¿ç®—
  let step1 = @azimuth.add(max_val - 1000, 500)
  let step2 = @azimuth.add(step1, 500)
  let step3 = @azimuth.multiply(step2, 1)
  @azimuth.assert_eq(max_val, step3)
  
  // ç»„åˆ3ï¼šè¾¹ç•Œå€¼ä¸ä¸­é—´å€¼çš„æ··åˆè¿ç®—
  let mid_val = 1000000
  let mixed_sum = @azimuth.add(@azimuth.add(max_val - mid_val, mid_val), 0)
  let mixed_product = @azimuth.multiply(@azimuth.divide_with_ceil(mid_val, 1000), 1000)
  @azimuth.assert_eq(max_val, mixed_sum)
  @azimuth.assert_eq(1000000, mixed_product)
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å„ç§æƒ…å†µ
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(100, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(-100, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(0, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(max_val, 0))
  @azimuth.assert_eq(0, @azimuth.divide_with_ceil(min_val, 0))
  
  // æç«¯å€¼ç»„åˆçš„ç¨³å®šæ€§
  let extreme_sum1 = @azimuth.add(max_val, max_val)
  let extreme_sum2 = @azimuth.add(min_val, min_val)
  let extreme_product1 = @azimuth.multiply(max_val, max_val)
  let extreme_product2 = @azimuth.multiply(min_val, min_val)
  
  // éªŒè¯ç³»ç»Ÿä¸ä¼šå´©æºƒï¼Œè€Œæ˜¯è¿”å›åˆç†çš„è¾¹ç•Œå€¼
  @azimuth.assert_true(extreme_sum1 <= max_val)
  @azimuth.assert_true(extreme_sum2 >= min_val)
  @azimuth.assert_true(extreme_product1 <= max_val)
  @azimuth.assert_true(extreme_product2 >= min_val)
}