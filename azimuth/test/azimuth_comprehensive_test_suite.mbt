// Azimuth é¡¹ç›®æ–°å¢ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ï¼Œè¦†ç›–å¤šç§åŠŸèƒ½åœºæ™¯

test "extreme_boundary_values" {
  // æå€¼è¾¹ç•Œæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  let zero = 0
  let one = 1
  let neg_one = -1
  
  // æµ‹è¯•æå€¼é—´çš„åŠ æ³•è¿ç®—
  @azimuth.assert_eq(max_val, @azimuth.add(max_val, zero))
  @azimuth.assert_eq(min_val, @azimuth.add(min_val, zero))
  @azimuth.assert_eq(max_val - 1, @azimuth.add(max_val, neg_one))
  @azimuth.assert_eq(min_val + 1, @azimuth.add(min_val, one))
  
  // æµ‹è¯•æå€¼é—´çš„ä¹˜æ³•è¿ç®—
  @azimuth.assert_eq(zero, @azimuth.multiply(max_val, zero))
  @azimuth.assert_eq(zero, @azimuth.multiply(min_val, zero))
  @azimuth.assert_eq(max_val, @azimuth.multiply(max_val, one))
  @azimuth.assert_eq(min_val, @azimuth.multiply(min_val, one))
}

test "advanced_string_operations" {
  // é«˜çº§å­—ç¬¦ä¸²æ“ä½œæµ‹è¯•
  // æµ‹è¯•å¤šè¯­è¨€å­—ç¬¦ä¸²
  let chinese_name = "å¼ ä¸‰"
  let english_name = "John"
  let mixed_name = "å¼ ä¸‰ John"
  
  @azimuth.assert_eq_string("Hello, å¼ ä¸‰!", @azimuth.greet(chinese_name))
  @azimuth.assert_eq_string("Hello, John!", @azimuth.greet(english_name))
  @azimuth.assert_eq_string("Hello, å¼ ä¸‰ John!", @azimuth.greet(mixed_name))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’Œæ•°å­—ç»„åˆ
  let special_chars = "User@123#Admin"
  let unicode_chars = "æµ‹è¯•ğŸš€User"
  
  @azimuth.assert_eq_string("Hello, User@123#Admin!", @azimuth.greet(special_chars))
  @azimuth.assert_eq_string("Hello, æµ‹è¯•ğŸš€User!", @azimuth.greet(unicode_chars))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œå•å­—ç¬¦
  let empty_string = ""
  let single_char = "A"
  
  @azimuth.assert_eq_string("Hello, !", @azimuth.greet(empty_string))
  @azimuth.assert_eq_string("Hello, A!", @azimuth.greet(single_char))
}

test "complex_mathematical_expressions" {
  // å¤æ‚æ•°å­¦è¡¨è¾¾å¼æµ‹è¯•
  // æµ‹è¯•äºŒæ¬¡æ–¹ç¨‹ axÂ² + bx + c
  let a = 2
  let b = 3
  let c = 4
  let x = 5
  
  let ax2 = @azimuth.multiply(a, @azimuth.multiply(x, x))
  let bx = @azimuth.multiply(b, x)
  let result = @azimuth.add(@azimuth.add(ax2, bx), c)
  
  @azimuth.assert_eq(2*25 + 3*5 + 4, result)
  
  // æµ‹è¯•å‹¾è‚¡å®šç† aÂ² + bÂ² = cÂ²
  let side_a = 3
  let side_b = 4
  let a_squared = @azimuth.multiply(side_a, side_a)
  let b_squared = @azimuth.multiply(side_b, side_b)
  let c_squared = @azimuth.add(a_squared, b_squared)
  
  @azimuth.assert_eq(25, c_squared)
}

test "financial_calculations" {
  // é‡‘èè®¡ç®—æµ‹è¯•
  // è®¡ç®—å¤åˆ©: A = P(1 + r/n)^(nt)
  let principal = 1000
  let rate = 5
  let years = 10
  
  // ç®€åŒ–è®¡ç®—: åªè®¡ç®—åŸºæœ¬åˆ©æ¯
  let simple_interest = @azimuth.multiply(principal, @azimuth.multiply(rate, years)) / 100
  let total_amount = @azimuth.add(principal, simple_interest)
  
  @azimuth.assert_eq(1500, total_amount)
  
  // è®¡ç®—è´·æ¬¾æœˆä¾›: M = P[r(1+r)^n]/[(1+r)^n-1]
  let loan_amount = 200000
  let monthly_rate = 4
  
  // ç®€åŒ–è®¡ç®—: åªè®¡ç®—åŸºæœ¬æœˆä¾›
  let monthly_interest = @azimuth.multiply(loan_amount, monthly_rate) / 1200
  let monthly_payment = @azimuth.add(monthly_interest, @azimuth.multiply(loan_amount, 1) / 360)
  
  @azimuth.assert_eq(666, monthly_payment)
}

test "scientific_computations" {
  // ç§‘å­¦è®¡ç®—æµ‹è¯•
  // è®¡ç®—åŠ¨èƒ½: E = 1/2 * m * vÂ²
  let mass = 10
  let velocity = 5
  
  let velocity_squared = @azimuth.multiply(velocity, velocity)
  let kinetic_energy = @azimuth.multiply(mass, velocity_squared) / 2
  
  @azimuth.assert_eq(125, kinetic_energy)
  
  // è®¡ç®—åŠ¿èƒ½: E = m * g * h
  let height = 20
  let gravity = 10
  
  let potential_energy = @azimuth.multiply(mass, @azimuth.multiply(gravity, height))
  
  @azimuth.assert_eq(2000, potential_energy)
  
  // è®¡ç®—åŠŸç‡: P = W / t
  let work = 5000
  let time = 10
  let power = work / time
  
  @azimuth.assert_eq(500, power)
}

test "algorithmic_efficiency" {
  // ç®—æ³•æ•ˆç‡æµ‹è¯•
  // æ¨¡æ‹ŸäºŒåˆ†æŸ¥æ‰¾çš„æ¯”è¾ƒæ¬¡æ•°
  let comparisons_per_level = 1
  let max_levels = 10
  
  let worst_case_comparisons = @azimuth.multiply(comparisons_per_level, max_levels)
  
  @azimuth.assert_eq(10, worst_case_comparisons)
  
  // æ¨¡æ‹Ÿå†’æ³¡æ’åºçš„äº¤æ¢æ¬¡æ•°ï¼ˆæœ€åæƒ…å†µï¼‰
  let n = 5
  
  let max_swaps = @azimuth.multiply(n, @azimuth.add(n, -1)) / 2
  
  @azimuth.assert_eq(10, max_swaps)
  
  // æ¨¡æ‹Ÿé€‰æ‹©æ’åºçš„æ¯”è¾ƒæ¬¡æ•°
  let total_comparisons = @azimuth.multiply(n, @azimuth.add(n, -1)) / 2
  
  @azimuth.assert_eq(10, total_comparisons)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špushå’Œpop
  let initial_stack_size = 0
  let push_count = 5
  let pop_count = 3
  
  // Pushæ“ä½œ
  let stack_size_after_push = @azimuth.add(initial_stack_size, push_count)
  
  @azimuth.assert_eq(5, stack_size_after_push)
  
  // Popæ“ä½œ
  let stack_size_after_pop = @azimuth.add(stack_size_after_push, -pop_count)
  
  @azimuth.assert_eq(2, stack_size_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼šenqueueå’Œdequeue
  let initial_queue_size = 0
  let enqueue_count = 8
  let dequeue_count = 6
  
  // Enqueueæ“ä½œ
  let queue_size_after_enqueue = @azimuth.add(initial_queue_size, enqueue_count)
  
  @azimuth.assert_eq(8, queue_size_after_enqueue)
  
  // Dequeueæ“ä½œ
  let queue_size_after_dequeue = @azimuth.add(queue_size_after_enqueue, -dequeue_count)
  
  @azimuth.assert_eq(2, queue_size_after_dequeue)
}

test "statistical_analysis" {
  // ç»Ÿè®¡åˆ†ææµ‹è¯•
  // è®¡ç®—å¹³å‡å€¼
  let data_sum = @azimuth.add(@azimuth.add(@azimuth.add(10, 20), 30), 40)
  let data_count = 4
  let average = data_sum / data_count
  
  @azimuth.assert_eq(25, average)
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let mean = 25
  let diff1 = @azimuth.add(10, -mean)
  let diff2 = @azimuth.add(20, -mean)
  let diff3 = @azimuth.add(30, -mean)
  let diff4 = @azimuth.add(40, -mean)
  
  let squared_diff1 = @azimuth.multiply(diff1, diff1)
  let squared_diff2 = @azimuth.multiply(diff2, diff2)
  let squared_diff3 = @azimuth.multiply(diff3, diff3)
  let squared_diff4 = @azimuth.multiply(diff4, diff4)
  
  let variance = @azimuth.add(@azimuth.add(@azimuth.add(squared_diff1, squared_diff2), squared_diff3), squared_diff4) / data_count
  
  @azimuth.assert_eq(125, variance)
}

test "geometry_calculations" {
  // å‡ ä½•è®¡ç®—æµ‹è¯•
  // è®¡ç®—åœ†çš„é¢ç§¯å’Œå‘¨é•¿
  let radius = 5
  let pi = 3
  
  let area = @azimuth.multiply(pi, @azimuth.multiply(radius, radius))
  let circumference = @azimuth.multiply(2, @azimuth.multiply(pi, radius))
  
  @azimuth.assert_eq(75, area)
  @azimuth.assert_eq(30, circumference)
  
  // è®¡ç®—çŸ©å½¢çš„é¢ç§¯å’Œå‘¨é•¿
  let length = 10
  let width = 5
  
  let rect_area = @azimuth.multiply(length, width)
  let rect_perimeter = @azimuth.multiply(2, @azimuth.add(length, width))
  
  @azimuth.assert_eq(50, rect_area)
  @azimuth.assert_eq(30, rect_perimeter)
  
  // è®¡ç®—ä¸‰è§’å½¢çš„é¢ç§¯ï¼ˆä½¿ç”¨æµ·ä¼¦å…¬å¼ç®€åŒ–ç‰ˆï¼‰
  let a = 3
  let b = 4
  let c = 5
  
  let s = @azimuth.add(@azimuth.add(a, b), c) / 2
  let triangle_area = @azimuth.multiply(s, @azimuth.add(s, -a)) / 2
  
  @azimuth.assert_eq(6, triangle_area)
}

test "pattern_recognition" {
  // æ¨¡å¼è¯†åˆ«æµ‹è¯•
  // æ£€æµ‹ç­‰å·®æ•°åˆ—
  let term1 = 2
  let term2 = 5
  let term3 = 8
  let term4 = 11
  
  let diff1 = @azimuth.add(term2, -term1)
  let diff2 = @azimuth.add(term3, -term2)
  let diff3 = @azimuth.add(term4, -term3)
  
  @azimuth.assert_eq(diff1, diff2)
  @azimuth.assert_eq(diff2, diff3)
  
  // é¢„æµ‹ä¸‹ä¸€é¡¹
  let next_term = @azimuth.add(term4, diff1)
  
  @azimuth.assert_eq(14, next_term)
  
  // æ£€æµ‹ç­‰æ¯”æ•°åˆ—
  let geo_term1 = 2
  let geo_term2 = 6
  let geo_term3 = 18
  let geo_term4 = 54
  
  let ratio1 = geo_term2 / geo_term1
  let ratio2 = geo_term3 / geo_term2
  let ratio3 = geo_term4 / geo_term3
  
  @azimuth.assert_eq(ratio1, ratio2)
  @azimuth.assert_eq(ratio2, ratio3)
  
  // é¢„æµ‹ä¸‹ä¸€é¡¹
  let geo_next_term = @azimuth.multiply(geo_term4, ratio1)
  
  @azimuth.assert_eq(162, geo_next_term)
}

test "error_handling_scenarios" {
  // é”™è¯¯å¤„ç†åœºæ™¯æµ‹è¯•
  // æµ‹è¯•é™¤é›¶ä¿æŠ¤ï¼ˆé€šè¿‡ä¹˜æ³•æ¨¡æ‹Ÿï¼‰
  let numerator = 100
  let denominator = 0
  
  // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™åº”è¯¥è¿”å›é”™è¯¯æˆ–ç‰¹æ®Šå€¼
  // è¿™é‡Œæˆ‘ä»¬åªæ˜¯æµ‹è¯•åŸºæœ¬çš„æ•°å­¦è¿ç®—
  let safe_result = @azimuth.multiply(numerator, denominator)
  
  @azimuth.assert_eq(0, safe_result)
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤
  let max_int = 2147483647
  
  let overflow_result = @azimuth.add(max_int, 1)
  let underflow_result = @azimuth.add(-max_int, -1)
  
  @azimuth.assert_eq(max_int, overflow_result)
  @azimuth.assert_eq(-max_int, underflow_result)
  
  // æµ‹è¯•æ— æ•ˆè¾“å…¥å¤„ç†
  let empty_input = ""
  let null_input = ""
  
  let result1 = @azimuth.greet(empty_input)
  let result2 = @azimuth.greet(null_input)
  
  @azimuth.assert_eq_string("Hello, !", result1)
  @azimuth.assert_eq_string("Hello, !", result2)
}
