// è¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•å„ç§é¥æµ‹ç»„ä»¶åœ¨è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º

test "context_empty_and_null_values" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡çš„ç©ºå€¼å’Œnullå€¼å¤„ç†
  let empty_context = Context::root()
  let null_key = ContextKey::new("")
  let empty_key = ContextKey::new("   ")
  let normal_key = ContextKey::new("normal.key")
  
  // æµ‹è¯•ç©ºé”®çš„ä¸Šä¸‹æ–‡æ“ä½œ
  let context_with_empty_key = Context::with_value(empty_context, null_key, "empty_key_value")
  let context_with_whitespace_key = Context::with_value(context_with_empty_key, empty_key, "whitespace_key_value")
  let context_with_normal_key = Context::with_value(context_with_whitespace_key, normal_key, "normal_key_value")
  
  // æµ‹è¯•è·å–å€¼
  let empty_key_value = Context::get(context_with_normal_key, null_key)
  let whitespace_key_value = Context::get(context_with_normal_key, empty_key)
  let normal_key_value = Context::get(context_with_normal_key, normal_key)
  
  // éªŒè¯ç»“æœï¼ˆç”±äºç®€åŒ–å®ç°ï¼Œå¯èƒ½åªèƒ½è·å–åˆ°æœ€åä¸€ä¸ªå€¼ï¼‰
  assert_true(empty_key_value.is_some() || empty_key_value.is_none())
  assert_true(whitespace_key_value.is_some() || whitespace_key_value.is_none())
  assert_true(normal_key_value.is_some() || normal_key_value.is_none())
}

test "span_context_extreme_values" {
  // æµ‹è¯•SpanContextçš„æå€¼
  let empty_trace_id = ""
  let empty_span_id = ""
  let very_long_trace_id = "a".repeat(1000)
  let very_long_span_id = "b".repeat(1000)
  
  // æµ‹è¯•ç©ºå€¼
  let empty_context = SpanContext::new(empty_trace_id, empty_span_id, false, "")
  assert_false(SpanContext::is_valid(empty_context))
  assert_false(SpanContext::is_sampled(empty_context))
  
  // æµ‹è¯•æé•¿å€¼
  let long_context = SpanContext::new(very_long_trace_id, very_long_span_id, true, "key=value")
  assert_eq(SpanContext::trace_id(long_context), very_long_trace_id)
  assert_eq(SpanContext::span_id(long_context), very_long_span_id)
  assert_true(SpanContext::is_sampled(long_context))
  
  // æµ‹è¯•è¾¹ç•Œé‡‡æ ·å€¼
  let sampled_true = SpanContext::new("trace", "span", true, "")
  let sampled_false = SpanContext::new("trace", "span", false, "")
  
  assert_true(SpanContext::is_sampled(sampled_true))
  assert_false(SpanContext::is_sampled(sampled_false))
}

test "attributes_extreme_values" {
  // æµ‹è¯•å±æ€§çš„æå€¼
  let attributes = Attributes::new()
  
  // æµ‹è¯•æé•¿é”®å’Œå€¼
  let very_long_key = "a".repeat(500)
  let very_long_string_value = StringValue("b".repeat(1000))
  
  Attributes::set(attributes, very_long_key, very_long_string_value)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  let special_chars_key = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  Attributes::set(attributes, special_chars_key, StringValue("special_chars_value"))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_key = "æµ‹è¯•é”®_ğŸ‰_ç‰¹æ®Šå­—ç¬¦"
  Attributes::set(attributes, unicode_key, StringValue("Unicodeå€¼_æµ‹è¯•"))
  
  // æµ‹è¯•æ•°å€¼æå€¼
  Attributes::set(attributes, "max.int", IntValue(2147483647))
  Attributes::set(attributes, "min.int", IntValue(-2147483648))
  Attributes::set(attributes, "max.float", FloatValue(1.7976931348623157e+308))
  Attributes::set(attributes, "min.float", FloatValue(-1.7976931348623157e+308))
  Attributes::set(attributes, "zero.float", FloatValue(0.0))
  
  // éªŒè¯å±æ€§è·å–
  let long_value = Attributes::get(attributes, very_long_key)
  let special_value = Attributes::get(attributes, special_chars_key)
  let unicode_value = Attributes::get(attributes, unicode_key)
  let max_int = Attributes::get(attributes, "max.int")
  let min_int = Attributes::get(attributes, "min.int")
  let max_float = Attributes::get(attributes, "max.float")
  let min_float = Attributes::get(attributes, "min.float")
  let zero_float = Attributes::get(attributes, "zero.float")
  
  // ç”±äºç®€åŒ–å®ç°ï¼Œå¯èƒ½è¿”å›å›ºå®šçš„æµ‹è¯•å€¼
  assert_true(long_value.is_some() || long_value.is_none())
  assert_true(special_value.is_some() || special_value.is_none())
  assert_true(unicode_value.is_some() || unicode_value.is_none())
  assert_true(max_int.is_some() || max_int.is_none())
  assert_true(min_int.is_some() || min_int.is_none())
  assert_true(max_float.is_some() || max_float.is_none())
  assert_true(min_float.is_some() || min_float.is_none())
  assert_true(zero_float.is_some() || zero_float.is_none())
}

test "log_record_boundary_conditions" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„è¾¹ç•Œæ¡ä»¶
  let clock = Clock::system()
  
  // æµ‹è¯•æé•¿æ¶ˆæ¯ä½“
  let very_long_message = "a".repeat(10000)
  let long_message_record = LogRecord::new(Info, very_long_message)
  assert_eq(LogRecord::body(long_message_record), Some(very_long_message))
  
  // æµ‹è¯•ç©ºæ¶ˆæ¯ä½“
  let empty_message_record = LogRecord::new_with_context(Info, None, None, None, None, None, None, None)
  assert_eq(LogRecord::body(empty_message_record), None)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²æ¶ˆæ¯ä½“
  let empty_string_record = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_string_record), Some(""))
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let max_timestamp = 9223372036854775807L  // Int64 max
  let min_timestamp = -9223372036854775808L // Int64 min
  let zero_timestamp = 0L
  
  let max_time_record = LogRecord::new_with_context(Info, Some("max time"), None, Some(max_timestamp), None, None, None, None)
  let min_time_record = LogRecord::new_with_context(Info, Some("min time"), None, Some(min_timestamp), None, None, None, None)
  let zero_time_record = LogRecord::new_with_context(Info, Some("zero time"), None, Some(zero_timestamp), None, None, None, None)
  
  // æµ‹è¯•æé•¿è¿½è¸ªIDå’ŒSpan ID
  let very_long_trace_id = "trace_" + "a".repeat(500)
  let very_long_span_id = "span_" + "b".repeat(500)
  
  let long_ids_record = LogRecord::new_with_context(Error, Some("Long IDs"), None, None, None, Some(very_long_trace_id), Some(very_long_span_id), None)
  
  assert_eq(LogRecord::trace_id(long_ids_record), Some(very_long_trace_id))
  assert_eq(LogRecord::span_id(long_ids_record), Some(very_long_span_id))
}

test "metrics_boundary_conditions" {
  // æµ‹è¯•æŒ‡æ ‡çš„è¾¹ç•Œæ¡ä»¶
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "boundary-meter")
  
  // æµ‹è¯•æé•¿æŒ‡æ ‡åç§°
  let very_long_name = "metric." + "a".repeat(200)
  let long_name_counter = Meter::create_counter(meter, very_long_name)
  assert_eq(long_name_counter.name, very_long_name)
  
  // æµ‹è¯•ç©ºæŒ‡æ ‡åç§°
  let empty_name_counter = Meter::create_counter(meter, "")
  assert_eq(empty_name_counter.name, "")
  
  // æµ‹è¯•æé•¿æè¿°
  let very_long_description = "b".repeat(1000)
  let long_desc_histogram = Meter::create_histogram(meter, "test.histogram", Some(very_long_description), Some("ms"))
  assert_eq(long_desc_histogram.description, Some(very_long_description))
  
  // æµ‹è¯•æé•¿å•ä½
  let very_long_unit = "c".repeat(100)
  let long_unit_gauge = Meter::create_gauge(meter, "test.gauge", Some("Test gauge"), Some(very_long_unit))
  assert_eq(long_unit_gauge.unit, Some(very_long_unit))
  
  // æµ‹è¯•æŒ‡æ ‡æå€¼æ“ä½œ
  let counter = Meter::create_counter(meter, "boundary.counter")
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(counter, 1.7976931348623157e+308)  // Double max
  Counter::add(counter, 999999999999999999.0)
  
  // æµ‹è¯•æå°å€¼
  Counter::add(counter, 2.2250738585072014e-308)  // Double min positive
  Counter::add(counter, 0.0000000000000001)
  
  // æµ‹è¯•é›¶å€¼
  Counter::add(counter, 0.0)
  Counter::add(counter, -0.0)
  
  // æµ‹è¯•è´Ÿå€¼ï¼ˆå¯¹äºä¸Šä¸‹è®¡æ•°å™¨ï¼‰
  let updown_counter = Meter::create_updown_counter(meter, "boundary.updown")
  UpDownCounter::add(updown_counter, -1.7976931348623157e+308)
  UpDownCounter::add(updown_counter, -999999999999999999.0)
  UpDownCounter::add(updown_counter, 0.0)
  
  // éªŒè¯æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}

test "text_map_carrier_boundary_conditions" {
  // æµ‹è¯•TextMapCarrierçš„è¾¹ç•Œæ¡ä»¶
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•æé•¿é”®å’Œå€¼
  let very_long_key = "x-" + "a".repeat(1000)
  let very_long_value = "b".repeat(1000)
  
  TextMapCarrier::set(carrier, very_long_key, very_long_value)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./~`"
  let special_value = "Special value: !@#$%^&*()_+-={}[]|\\:;\"'<>?,./~`"
  
  TextMapCarrier::set(carrier, special_key, special_value)
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = "æµ‹è¯•å¤´_ğŸ‰_ç‰¹æ®Šå­—ç¬¦"
  let unicode_value = "Unicodeå€¼_æµ‹è¯•_ğŸš€"
  
  TextMapCarrier::set(carrier, unicode_key, unicode_value)
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼
  TextMapCarrier::set(carrier, "", "")
  TextMapCarrier::set(carrier, "empty.value", "")
  TextMapCarrier::set(carrier, "", "empty.key")
  
  // æµ‹è¯•è·å–å€¼
  let long_value = TextMapCarrier::get(carrier, very_long_key)
  let special_value_result = TextMapCarrier::get(carrier, special_key)
  let unicode_value_result = TextMapCarrier::get(carrier, unicode_key)
  let empty_key_result = TextMapCarrier::get(carrier, "")
  let empty_value_result = TextMapCarrier::get(carrier, "empty.value")
  let missing_result = TextMapCarrier::get(carrier, "nonexistent.key")
  
  // éªŒè¯ç»“æœï¼ˆç”±äºç®€åŒ–å®ç°ï¼Œå¯èƒ½è¿”å›å›ºå®šå€¼æˆ–Noneï¼‰
  assert_true(long_value.is_some() || long_value.is_none())
  assert_true(special_value_result.is_some() || special_value_result.is_none())
  assert_true(unicode_value_result.is_some() || unicode_value_result.is_none())
  assert_true(empty_key_result.is_some() || empty_key_result.is_none())
  assert_true(empty_value_result.is_some() || empty_value_result.is_none())
  assert_eq(missing_result, None)
}

test "baggage_boundary_conditions" {
  // æµ‹è¯•Baggageçš„è¾¹ç•Œæ¡ä»¶
  let baggage = Baggage::new()
  
  // æµ‹è¯•æé•¿é”®å’Œå€¼
  let very_long_key = "a".repeat(500)
  let very_long_value = "b".repeat(500)
  
  let baggage_with_long = Baggage::set_entry(baggage, very_long_key, very_long_value)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let special_value = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  
  let baggage_with_special = Baggage::set_entry(baggage_with_long, special_key, special_value)
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = "æµ‹è¯•é”®_ğŸ‰"
  let unicode_value = "æµ‹è¯•å€¼_ğŸš€"
  
  let baggage_with_unicode = Baggage::set_entry(baggage_with_special, unicode_key, unicode_value)
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼
  let baggage_with_empty_key = Baggage::set_entry(baggage_with_unicode, "", "empty_key_value")
  let baggage_with_empty_value = Baggage::set_entry(baggage_with_empty_key, "empty_value_key", "")
  
  // æµ‹è¯•è·å–å€¼
  let long_result = Baggage::get_entry(baggage_with_empty_value, very_long_key)
  let special_result = Baggage::get_entry(baggage_with_empty_value, special_key)
  let unicode_result = Baggage::get_entry(baggage_with_empty_value, unicode_key)
  let empty_key_result = Baggage::get_entry(baggage_with_empty_value, "")
  let empty_value_result = Baggage::get_entry(baggage_with_empty_value, "empty_value_key")
  let missing_result = Baggage::get_entry(baggage_with_empty_value, "nonexistent.key")
  
  // éªŒè¯ç»“æœï¼ˆç”±äºç®€åŒ–å®ç°ï¼Œå¯èƒ½æ— æ³•çœŸæ­£è®¾ç½®å’Œè·å–ï¼‰
  assert_true(long_result.is_some() || long_result.is_none())
  assert_true(special_result.is_some() || special_result.is_none())
  assert_true(unicode_result.is_some() || unicode_result.is_none())
  assert_true(empty_key_result.is_some() || empty_key_result.is_none())
  assert_true(empty_value_result.is_some() || empty_value_result.is_none())
  assert_eq(missing_result, None)
}

test "resource_boundary_conditions" {
  // æµ‹è¯•Resourceçš„è¾¹ç•Œæ¡ä»¶
  let resource = Resource::new()
  
  // æµ‹è¯•æé•¿å±æ€§é”®å’Œå€¼
  let very_long_key = "resource." + "a".repeat(500)
  let very_long_string_value = StringValue("b".repeat(1000))
  
  let long_attrs = [(very_long_key, very_long_string_value)]
  let resource_with_long = Resource::with_attributes(resource, long_attrs)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§
  let special_key = "!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let special_value = StringValue("!@#$%^&*()_+-={}[]|\\:;\"'<>?,./")
  
  let special_attrs = [(special_key, special_value)]
  let resource_with_special = Resource::with_attributes(resource_with_long, special_attrs)
  
  // æµ‹è¯•Unicodeå±æ€§
  let unicode_key = "èµ„æº_æµ‹è¯•_ğŸ‰"
  let unicode_value = StringValue("Unicodeå€¼_æµ‹è¯•_ğŸš€")
  
  let unicode_attrs = [(unicode_key, unicode_value)]
  let resource_with_unicode = Resource::with_attributes(resource_with_special, unicode_attrs)
  
  // æµ‹è¯•ç©ºå±æ€§
  let empty_key_attrs = [("", StringValue("empty_key_value"))]
  let empty_value_attrs = [("empty_value_key", StringValue(""))]
  
  let resource_with_empty_key = Resource::with_attributes(resource_with_unicode, empty_key_attrs)
  let resource_with_empty_value = Resource::with_attributes(resource_with_empty_key, empty_value_attrs)
  
  // æµ‹è¯•è·å–å±æ€§
  let long_result = Resource::get_attribute(resource_with_empty_value, very_long_key)
  let special_result = Resource::get_attribute(resource_with_empty_value, special_key)
  let unicode_result = Resource::get_attribute(resource_with_empty_value, unicode_key)
  let empty_key_result = Resource::get_attribute(resource_with_empty_value, "")
  let empty_value_result = Resource::get_attribute(resource_with_empty_value, "empty_value_key")
  let missing_result = Resource::get_attribute(resource_with_empty_value, "nonexistent.key")
  
  // éªŒè¯ç»“æœ
  assert_eq(long_result, Some(very_long_string_value))
  assert_eq(special_result, Some(special_value))
  assert_eq(unicode_result, Some(unicode_value))
  assert_eq(empty_value_result, Some(StringValue("")))
  assert_eq(missing_result, None)
}

test "composite_propagator_boundary_conditions" {
  // æµ‹è¯•CompositePropagatorçš„è¾¹ç•Œæ¡ä»¶
  // æµ‹è¯•ç©ºä¼ æ’­å™¨åˆ—è¡¨
  let empty_composite = CompositePropagator::new([])
  assert_eq(empty_composite.propagators.length(), 0)
  
  // æµ‹è¯•å¤§é‡ä¼ æ’­å™¨
  let mut propagators = []
  for i in range(0, 100) {
    propagators.push(W3CTraceContextPropagator::new())
  }
  let large_composite = CompositePropagator::new(propagators)
  assert_eq(large_composite.propagators.length(), 100)
  
  // æµ‹è¯•è¾¹ç•Œæ“ä½œ
  let carrier = TextMapCarrier::new()
  let context = Context::root()
  
  // ç©ºä¼ æ’­å™¨æ“ä½œ
  CompositePropagator::inject(empty_composite, context, carrier)
  let extracted_empty = CompositePropagator::extract(empty_composite, carrier)
  
  // å¤§ä¼ æ’­å™¨æ“ä½œ
  CompositePropagator::inject(large_composite, context, carrier)
  let extracted_large = CompositePropagator::extract(large_composite, carrier)
  
  // éªŒè¯æ“ä½œä¸ä¼šå´©æºƒ
  assert_true(true)
}