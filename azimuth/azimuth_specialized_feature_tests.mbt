// Azimuth Specialized Feature Tests
// This file contains specialized test cases for specific Azimuth telemetry features

// Test 1: TextMapCarrier edge cases
test "æ–‡æœ¬æ˜ å°„è½½ä½“è¾¹ç•Œæƒ…å†µæµ‹è¯•" {
  // æµ‹è¯•ç©ºè½½ä½“
  let empty_carrier = TextMapCarrier::new()
  assert_eq(TextMapCarrier::get(empty_carrier, "nonexistent"), None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å€¼
  let special_carrier = TextMapCarrier::new()
  TextMapCarrier::set(special_carrier, "special-key!@#$%", "ç‰¹æ®Šå€¼&*(){}")
  assert_eq(TextMapCarrier::get(special_carrier, "special-key!@#$%"), Some("ç‰¹æ®Šå€¼&*(){}"))
  
  // æµ‹è¯•é•¿é”®å€¼
  let long_carrier = TextMapCarrier::new()
  let long_key = "this.is.a.very.long.key.name.that.exceeds.normal.expectations"
  let long_value = "this.is.a.very.long.value.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  TextMapCarrier::set(long_carrier, long_key, long_value)
  assert_eq(TextMapCarrier::get(long_carrier, long_key), Some(long_value))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_carrier = TextMapCarrier::new()
  TextMapCarrier::set(unicode_carrier, "unicodeé”®", "unicodeå€¼ğŸš€æµ‹è¯•")
  assert_eq(TextMapCarrier::get(unicode_carrier, "unicodeé”®"), Some("unicodeå€¼ğŸš€æµ‹è¯•"))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®å€¼
  let empty_string_carrier = TextMapCarrier::new()
  TextMapCarrier::set(empty_string_carrier, "", "")
  assert_eq(TextMapCarrier::get(empty_string_carrier, ""), Some(""))
}

// Test 2: Span lifecycle edge cases
test "Spanç”Ÿå‘½å‘¨æœŸè¾¹ç•Œæƒ…å†µæµ‹è¯•" {
  // æµ‹è¯•åˆ›å»ºå’Œç«‹å³ç»“æŸçš„Span
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "lifecycle-test")
  let quick_span = Tracer::start_span(tracer, "quick-span")
  Span::end(quick_span)
  
  // æµ‹è¯•é‡å¤ç»“æŸSpan
  let repeat_span = Tracer::start_span(tracer, "repeat-span")
  Span::end(repeat_span)
  Span::end(repeat_span)  // åº”è¯¥å®‰å…¨å¤„ç†
  
  // æµ‹è¯•å·²ç»“æŸSpançš„æ“ä½œ
  let ended_span = Tracer::start_span(tracer, "ended-span")
  Span::end(ended_span)
  Span::add_event(ended_span, "after-end", None)  // åº”è¯¥å®‰å…¨å¤„ç†
  Span::set_status(ended_span, Ok)  // åº”è¯¥å®‰å…¨å¤„ç†
  
  // æµ‹è¯•åµŒå¥—Spanç”Ÿå‘½å‘¨æœŸ
  let parent_span = Tracer::start_span(tracer, "parent-span")
  let child_span = Tracer::start_span(tracer, "child-span")
  let grandchild_span = Tracer::start_span(tracer, "grandchild-span")
  
  // é€†åºç»“æŸSpan
  Span::end(grandchild_span)
  Span::end(child_span)
  Span::end(parent_span)
  
  // æµ‹è¯•Spanå±æ€§åœ¨ç»“æŸåçš„æ“ä½œ
  let attrs_span = Tracer::start_span(tracer, "attrs-span")
  Span::set_attribute(attrs_span, "test.attr", StringValue("test-value"))
  Span::end(attrs_span)
  Span::set_attribute(attrs_span, "after.end", StringValue("should-not-crash"))
}

// Test 3: Metric instrument precision and accuracy
test "åº¦é‡å·¥å…·ç²¾åº¦å’Œå‡†ç¡®æ€§æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "precision-test")
  
  // æµ‹è¯•Counterç²¾åº¦
  let precise_counter = Meter::create_counter(meter, "precise.counter")
  
  // æµ‹è¯•å°æ•°å€¼
  Counter::add(precise_counter, 0.1)
  Counter::add(precise_counter, 0.2)
  Counter::add(precise_counter, 0.3)
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(precise_counter, 999999999.9)
  
  // æµ‹è¯•æå°å€¼
  Counter::add(precise_counter, 0.000001)
  
  // æµ‹è¯•è´Ÿå€¼ï¼ˆå¯¹äºUpDownCounterï¼‰
  let updown_counter = Meter::create_updown_counter(meter, "updown.counter")
  Counter::add(updown_counter, 100.0)
  Counter::add(updown_counter, -50.0)
  Counter::add(updown_counter, -75.5)
  
  // æµ‹è¯•Histogramç²¾åº¦
  let precise_histogram = Meter::create_histogram(meter, "precise.histogram")
  
  // æµ‹è¯•è¾¹ç•Œå€¼
  Histogram::record(precise_histogram, 0.0)
  Histogram::record(precise_histogram, -0.0)
  Histogram::record(precise_histogram, 1.7976931348623157e+308)  // æœ€å¤§doubleå€¼
  Histogram::record(precise_histogram, -1.7976931348623157e+308)  // æœ€å°doubleå€¼
  Histogram::record(precise_histogram, 1.0/0.0)  // æ­£æ— ç©·
  Histogram::record(precise_histogram, -1.0/0.0)  // è´Ÿæ— ç©·
  
  // æµ‹è¯•ç§‘å­¦è®¡æ•°æ³•å€¼
  Histogram::record(precise_histogram, 1.23e-10)
  Histogram::record(precise_histogram, 4.56e+20)
  
  // æµ‹è¯•å¾ªç¯å°æ•°
  Histogram::record(precise_histogram, 1.0/3.0)
  Histogram::record(precise_histogram, 2.0/3.0)
}

// Test 4: Context propagation complexity
test "ä¸Šä¸‹æ–‡ä¼ æ’­å¤æ‚æ€§æµ‹è¯•" {
  // æµ‹è¯•æ·±å±‚åµŒå¥—ä¸Šä¸‹æ–‡
  let root_ctx = Context::root()
  
  // åˆ›å»º10å±‚åµŒå¥—ä¸Šä¸‹æ–‡
  let nested_ctx = root_ctx
  for i in 0..10 {
    let key = ContextKey::new("level." + i.to_string())
    nested_ctx = Context::with_value(nested_ctx, key, "value-" + i.to_string())
  }
  
  // éªŒè¯æ‰€æœ‰å±‚çº§çš„å€¼éƒ½å¯ä»¥æ­£ç¡®è·å–
  for i in 0..10 {
    let key = ContextKey::new("level." + i.to_string())
    let value = Context::get(nested_ctx, key)
    assert_eq(value, Some("value-" + i.to_string()))
  }
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡è¦†ç›–
  let override_key = ContextKey::new("override.test")
  let ctx1 = Context::with_value(root_ctx, override_key, "initial-value")
  let ctx2 = Context::with_value(ctx1, override_key, "overridden-value")
  let ctx3 = Context::with_value(ctx2, override_key, "final-value")
  
  // éªŒè¯æœ€ç»ˆå€¼
  let final_value = Context::get(ctx3, override_key)
  assert_eq(final_value, Some("final-value"))
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡åˆå¹¶åœºæ™¯
  let ctx_a = Context::with_value(root_ctx, ContextKey::new("a.key"), "a.value")
  let ctx_b = Context::with_value(root_ctx, ContextKey::new("b.key"), "b.value")
  let ctx_c = Context::with_value(root_ctx, ContextKey::new("c.key"), "c.value")
  
  // åˆ›å»ºåŒ…å«æ‰€æœ‰é”®çš„å¤åˆä¸Šä¸‹æ–‡
  let merged_ctx = Context::with_value(
    Context::with_value(
      Context::with_value(root_ctx, ContextKey::new("a.key"), "a.value"),
      ContextKey::new("b.key"), "b.value"
    ),
    ContextKey::new("c.key"), "c.value"
  )
  
  // éªŒè¯åˆå¹¶ç»“æœ
  assert_eq(Context::get(merged_ctx, ContextKey::new("a.key")), Some("a.value"))
  assert_eq(Context::get(merged_ctx, ContextKey::new("b.key")), Some("b.value"))
  assert_eq(Context::get(merged_ctx, ContextKey::new("c.key")), Some("c.value"))
}

// Test 5: Resource merge strategies
test "èµ„æºåˆå¹¶ç­–ç•¥æµ‹è¯•" {
  // æµ‹è¯•åŸºæœ¬èµ„æºåˆå¹¶
  let base_resource = Resource::new()
  let base_attrs = [
    ("service.name", StringValue("base-service")),
    ("service.version", StringValue("1.0.0")),
    ("environment", StringValue("development"))
  ]
  let resource_with_base = Resource::with_attributes(base_resource, base_attrs)
  
  // æµ‹è¯•è¦†ç›–ç­–ç•¥
  let override_attrs = [
    ("service.name", StringValue("override-service")),  // è¦†ç›–
    ("service.version", StringValue("2.0.0")),         // è¦†ç›–
    ("new.attr", StringValue("new-value"))             // æ–°å¢
  ]
  let resource_with_override = Resource::with_attributes(base_resource, override_attrs)
  
  // åˆå¹¶èµ„æº
  let merged_resource = Resource::merge(resource_with_base, resource_with_override)
  
  // éªŒè¯åˆå¹¶ç»“æœ
  assert_eq(Resource::get_attribute(merged_resource, "service.name"), Some(StringValue("override-service")))
  assert_eq(Resource::get_attribute(merged_resource, "service.version"), Some(StringValue("2.0.0")))
  assert_eq(Resource::get_attribute(merged_resource, "environment"), Some(StringValue("development")))
  assert_eq(Resource::get_attribute(merged_resource, "new.attr"), Some(StringValue("new-value")))
  
  // æµ‹è¯•å¤šé‡åˆå¹¶
  let additional_attrs = [
    ("additional.attr", StringValue("additional-value")),
    ("service.name", StringValue("final-service"))  // æœ€ç»ˆè¦†ç›–
  ]
  let resource_with_additional = Resource::with_attributes(base_resource, additional_attrs)
  
  // ä¸‰é‡åˆå¹¶
  let triple_merged = Resource::merge(merged_resource, resource_with_additional)
  
  // éªŒè¯ä¸‰é‡åˆå¹¶ç»“æœ
  assert_eq(Resource::get_attribute(triple_merged, "service.name"), Some(StringValue("final-service")))
  assert_eq(Resource::get_attribute(triple_merged, "additional.attr"), Some(StringValue("additional-value")))
  assert_eq(Resource::get_attribute(triple_merged, "environment"), Some(StringValue("development")))
  
  // æµ‹è¯•ç©ºèµ„æºåˆå¹¶
  let empty_resource = Resource::new()
  let merge_with_empty = Resource::merge(resource_with_base, empty_resource)
  
  // éªŒè¯ä¸ç©ºèµ„æºåˆå¹¶ä¸ä¼šä¸¢å¤±å±æ€§
  assert_eq(Resource::get_attribute(merge_with_empty, "service.name"), Some(StringValue("base-service")))
  assert_eq(Resource::get_attribute(merge_with_empty, "service.version"), Some(StringValue("1.0.0")))
}

// Test 6: LogRecord timestamp ordering
test "æ—¥å¿—è®°å½•æ—¶é—´æˆ³æ’åºæµ‹è¯•" {
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "timestamp-test")
  
  // åˆ›å»ºæœ‰åºçš„æ—¥å¿—è®°å½•
  let base_time = Clock::now_unix_nanos(Clock::system())
  let log_records = []
  
  // åˆ›å»º10ä¸ªæ—¥å¿—è®°å½•ï¼Œæ¯ä¸ªé—´éš”1æ¯«ç§’
  for i in 0..10 {
    let timestamp = base_time + (i * 1000000L)  // 1æ¯«ç§’ = 1,000,000çº³ç§’
    let observed_time = timestamp + 1000L  // è§‚å¯Ÿæ—¶é—´ç¨æ™š
    
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Ordered log " + i.to_string()),
      Some(Attributes::new()),
      Some(timestamp),
      Some(observed_time),
      Some("trace-123"),
      Some("span-" + i.to_string()),
      Some(Context::root())
    )
    
    log_records.push((log_record, timestamp, observed_time))
    Logger::emit(logger, log_record)
  }
  
  // éªŒè¯æ—¶é—´æˆ³é¡ºåº
  for i in 1..log_records.length() {
    let prev_timestamp = log_records[i-1].1
    let curr_timestamp = log_records[i].1
    let prev_observed = log_records[i-1].2
    let curr_observed = log_records[i].2
    
    assert_true(curr_timestamp > prev_timestamp)
    assert_true(curr_observed > prev_observed)
  }
  
  // æµ‹è¯•æ— åºæ—¶é—´æˆ³
  let unordered_records = []
  let timestamps = [5000000L, 1000000L, 3000000L, 2000000L, 4000000L]
  
  for i in 0..timestamps.length() {
    let log_record = LogRecord::new_with_context(
      Warning,
      Some("Unordered log " + i.to_string()),
      None,
      Some(base_time + timestamps[i]),
      None,
      None,
      None,
      None
    )
    unordered_records.push(log_record)
    Logger::emit(logger, log_record)
  }
  
  // æµ‹è¯•ç›¸åŒæ—¶é—´æˆ³çš„å¤šä¸ªæ—¥å¿—
  let same_time = base_time + 10000000L
  for i in 0..5 {
    let log_record = LogRecord::new_with_context(
      Error,
      Some("Same time log " + i.to_string()),
      None,
      Some(same_time),
      None,
      None,
      None,
      None
    )
    Logger::emit(logger, log_record)
  }
}

// Test 7: Baggage propagation edge cases
test "Baggageä¼ æ’­è¾¹ç•Œæƒ…å†µæµ‹è¯•" {
  // æµ‹è¯•ç©ºBaggage
  let empty_baggage = Baggage::new()
  assert_eq(Baggage::get_entry(empty_baggage, "any.key"), None)
  
  // æµ‹è¯•å•ä¸ªæ¡ç›®
  let single_baggage = Baggage::set_entry(empty_baggage, "single.key", "single.value")
  assert_eq(Baggage::get_entry(single_baggage, "single.key"), Some("single.value"))
  assert_eq(Baggage::get_entry(single_baggage, "nonexistent"), None)
  
  // æµ‹è¯•å¤šä¸ªæ¡ç›®
  let multi_baggage = Baggage::set_entry(single_baggage, "second.key", "second.value")
  let final_baggage = Baggage::set_entry(multi_baggage, "third.key", "third.value")
  
  assert_eq(Baggage::get_entry(final_baggage, "single.key"), Some("single.value"))
  assert_eq(Baggage::get_entry(final_baggage, "second.key"), Some("second.value"))
  assert_eq(Baggage::get_entry(final_baggage, "third.key"), Some("third.value"))
  
  // æµ‹è¯•è¦†ç›–æ¡ç›®
  let override_baggage = Baggage::set_entry(final_baggage, "second.key", "overridden.value")
  assert_eq(Baggage::get_entry(override_baggage, "second.key"), Some("overridden.value"))
  assert_eq(Baggage::get_entry(override_baggage, "single.key"), Some("single.value"))
  assert_eq(Baggage::get_entry(override_baggage, "third.key"), Some("third.value"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å€¼
  let special_baggage = Baggage::new()
  special_baggage = Baggage::set_entry(special_baggage, "special.key!@#$%", "ç‰¹æ®Šå€¼&*(){}")
  special_baggage = Baggage::set_entry(special_baggage, "unicodeé”®", "unicodeå€¼ğŸš€æµ‹è¯•")
  special_baggage = Baggage::set_entry(special_baggage, "", "ç©ºé”®æµ‹è¯•")
  special_baggage = Baggage::set_entry(special_baggage, "ç©ºå€¼æµ‹è¯•", "")
  
  assert_eq(Baggage::get_entry(special_baggage, "special.key!@#$%"), Some("ç‰¹æ®Šå€¼&*(){}"))
  assert_eq(Baggage::get_entry(special_baggage, "unicodeé”®"), Some("unicodeå€¼ğŸš€æµ‹è¯•"))
  assert_eq(Baggage::get_entry(special_baggage, ""), Some("ç©ºé”®æµ‹è¯•"))
  assert_eq(Baggage::get_entry(special_baggage, "ç©ºå€¼æµ‹è¯•"), Some(""))
  
  // æµ‹è¯•é•¿é”®å€¼
  let long_baggage = Baggage::new()
  let long_key = "this.is.a.very.long.baggage.key.name.that.exceeds.normal.expectations"
  let long_value = "this.is.a.very.long.baggage.value.that.exceeds.normal.expectations.and.tests.boundary.conditions"
  long_baggage = Baggage::set_entry(long_baggage, long_key, long_value)
  
  assert_eq(Baggage::get_entry(long_baggage, long_key), Some(long_value))
}

// Test 8: Instrument metadata consistency
test "å·¥å…·å…ƒæ•°æ®ä¸€è‡´æ€§æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "metadata-test", Some("1.0.0"))
  
  // æµ‹è¯•Counterå…ƒæ•°æ®
  let counter = Meter::create_counter(meter, "test.counter", Some("Test counter description"), Some("count"))
  let counter_instrument = Histogram::as_instrument(Meter::create_histogram(meter, "temp"))
  
  assert_eq(Instrument::name(counter_instrument), "temp")
  
  // æµ‹è¯•Histogramå…ƒæ•°æ®
  let histogram = Meter::create_histogram(meter, "test.histogram", Some("Test histogram description"), Some("ms"))
  let histogram_instrument = Histogram::as_instrument(histogram)
  
  assert_eq(Instrument::name(histogram_instrument), "test.histogram")
  
  // æµ‹è¯•UpDownCounterå…ƒæ•°æ®
  let updown_counter = Meter::create_updown_counter(meter, "test.updown", Some("Test updown counter"), Some("items"))
  let updown_instrument = Histogram::as_instrument(Meter::create_histogram(meter, "temp2"))
  
  assert_eq(Instrument::name(updown_instrument), "temp2")
  
  // æµ‹è¯•Gaugeå…ƒæ•°æ®
  let gauge = Meter::create_gauge(meter, "test.gauge", Some("Test gauge description"), Some("%"))
  let gauge_instrument = Histogram::as_instrument(Meter::create_histogram(meter, "temp3"))
  
  assert_eq(Instrument::name(gauge_instrument), "temp3")
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µ
  let empty_desc_counter = Meter::create_counter(meter, "empty.desc", None, None)
  let long_desc_histogram = Meter::create_histogram(
    meter, 
    "long.desc", 
    Some("This is a very long description that exceeds normal expectations and tests boundary conditions for instrument metadata"), 
    Some("very-long-unit-name")
  )
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°
  let special_counter = Meter::create_counter(meter, "special.counter!@#$%", Some("Special counter &*(){}"), None)
  let unicode_histogram = Meter::create_histogram(meter, "unicode.ç›´æ–¹å›¾", Some("Unicodeæè¿° ğŸš€"), None)
  
  // æµ‹è¯•ç©ºåç§°
  let empty_name_gauge = Meter::create_gauge(meter, "", Some("Empty name gauge"), None)
  
  // éªŒè¯æ‰€æœ‰instrumentéƒ½èƒ½æ­£ç¡®åˆ›å»º
  assert_true(true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œåˆ™æµ‹è¯•é€šè¿‡
}

// Test 9: SpanContext validation rules
test "SpanContextéªŒè¯è§„åˆ™æµ‹è¯•" {
  // æµ‹è¯•æœ‰æ•ˆçš„SpanContext
  let valid_ctx = SpanContext::new("trace-1234567890123456", "span-1234567890123456", true, "key=value")
  assert_true(SpanContext::is_valid(valid_ctx))
  assert_true(SpanContext::is_sampled(valid_ctx))
  assert_eq(SpanContext::trace_id(valid_ctx), "trace-1234567890123456")
  assert_eq(SpanContext::span_id(valid_ctx), "span-1234567890123456")
  
  // æµ‹è¯•æ— æ•ˆçš„trace-id
  let invalid_trace_ctx = SpanContext::new("", "span-1234567890123456", true, "key=value")
  assert_false(SpanContext::is_valid(invalid_trace_ctx))
  
  // æµ‹è¯•æ— æ•ˆçš„span-id
  let invalid_span_ctx = SpanContext::new("trace-1234567890123456", "", true, "key=value")
  assert_false(SpanContext::is_valid(invalid_span_ctx))
  
  // æµ‹è¯•ä¸¤è€…éƒ½æ— æ•ˆ
  let both_invalid_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(both_invalid_ctx))
  assert_false(SpanContext::is_sampled(both_invalid_ctx))
  
  // æµ‹è¯•é‡‡æ ·æ ‡å¿—
  let unsampled_ctx = SpanContext::new("trace-1234567890123456", "span-1234567890123456", false, "key=value")
  assert_true(SpanContext::is_valid(unsampled_ctx))
  assert_false(SpanContext::is_sampled(unsampled_ctx))
  
  // æµ‹è¯•trace-state
  let with_state_ctx = SpanContext::new("trace-1234567890123456", "span-1234567890123456", true, "key1=value1,key2=value2")
  assert_true(SpanContext::is_valid(with_state_ctx))
  assert_true(SpanContext::is_sampled(with_state_ctx))
  
  // æµ‹è¯•ç©ºtrace-state
  let empty_state_ctx = SpanContext::new("trace-1234567890123456", "span-1234567890123456", true, "")
  assert_true(SpanContext::is_valid(empty_state_ctx))
  assert_true(SpanContext::is_sampled(empty_state_ctx))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦trace-state
  let special_state_ctx = SpanContext::new("trace-1234567890123456", "span-1234567890123456", true, "special.key=!@#$%,unicode.key=ä¸­æ–‡å€¼")
  assert_true(SpanContext::is_valid(special_state_ctx))
  assert_true(SpanContext::is_sampled(special_state_ctx))
  
  // æµ‹è¯•é•¿trace-idå’Œspan-id
  let long_trace_ctx = SpanContext::new("very-long-trace-id-that-exceeds-normal-expectations", "span-1234567890123456", true, "")
  let long_span_ctx = SpanContext::new("trace-1234567890123456", "very-long-span-id-that-exceeds-normal-expectations", true, "")
  
  // éªŒè¯é•¿IDä»ç„¶æœ‰æ•ˆï¼ˆåŸºäºå®ç°ï¼‰
  assert_true(SpanContext::is_valid(long_trace_ctx))
  assert_true(SpanContext::is_valid(long_span_ctx))
}

// Test 10: CompositePropagator complex scenarios
test "å¤åˆä¼ æ’­å™¨å¤æ‚åœºæ™¯æµ‹è¯•" {
  // åˆ›å»ºå¤šä¸ªä¼ æ’­å™¨
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  
  // åˆ›å»ºå¤åˆä¼ æ’­å™¨
  let propagators = [trace_propagator, baggage_propagator]
  let composite_propagator = CompositePropagator::new(propagators)
  
  // æµ‹è¯•æ³¨å…¥å’Œæå–å¾ªç¯
  let original_ctx = Context::root()
  let user_key = ContextKey::new("user.id")
  let request_key = ContextKey::new("request.id")
  let ctx_with_values = Context::with_value(
    Context::with_value(original_ctx, user_key, "user-123"),
    request_key, "req-456"
  )
  
  // åˆ›å»ºè½½ä½“å¹¶æ³¨å…¥
  let carrier = TextMapCarrier::new()
  CompositePropagator::inject(composite_propagator, ctx_with_values, carrier)
  
  // éªŒè¯æ³¨å…¥çš„å¤´éƒ¨
  let trace_header = TextMapCarrier::get(carrier, "traceparent")
  let baggage_header = TextMapCarrier::get(carrier, "baggage")
  
  // æå–ä¸Šä¸‹æ–‡
  let extracted_ctx = CompositePropagator::extract(composite_propagator, carrier)
  
  // æµ‹è¯•å¤šæ¬¡æ³¨å…¥
  let carrier2 = TextMapCarrier::new()
  CompositePropagator::inject(composite_propagator, extracted_ctx, carrier2)
  
  // éªŒè¯å¤šæ¬¡æ³¨å…¥çš„ä¸€è‡´æ€§
  let trace_header2 = TextMapCarrier::get(carrier2, "traceparent")
  let baggage_header2 = TextMapCarrier::get(carrier2, "baggage")
  
  // æµ‹è¯•ç©ºä¼ æ’­å™¨åˆ—è¡¨
  let empty_propagators = []
  let empty_composite = CompositePropagator::new(empty_propagators)
  
  let empty_carrier = TextMapCarrier::new()
  CompositePropagator::inject(empty_composite, original_ctx, empty_carrier)
  
  let empty_extracted = CompositePropagator::extract(empty_composite, empty_carrier)
  
  // æµ‹è¯•å•ä¸ªä¼ æ’­å™¨çš„å¤åˆ
  let single_propagators = [trace_propagator]
  let single_composite = CompositePropagator::new(single_propagators)
  
  let single_carrier = TextMapCarrier::new()
  CompositePropagator::inject(single_composite, ctx_with_values, single_carrier)
  
  let single_extracted = CompositePropagator::extract(single_composite, single_carrier)
  
  // æµ‹è¯•é¢„å¡«å……è½½ä½“
  let prefilled_carrier = TextMapCarrier::new()
  TextMapCarrier::set(prefilled_carrier, "existing.header", "existing.value")
  TextMapCarrier::set(prefilled_carrier, "traceparent", "00-existing-trace-id-existing-span-id-01")
  
  let prefilled_extracted = CompositePropagator::extract(composite_propagator, prefilled_carrier)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½èƒ½æ­£å¸¸æ‰§è¡Œ
  assert_true(true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œåˆ™æµ‹è¯•é€šè¿‡
}