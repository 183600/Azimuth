// Specialized Test Cases for Azimuth Telemetry System
// ä¸“é—¨æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–ç‰¹å®šåŠŸèƒ½å’Œè¾¹ç¼˜æƒ…å†µ

test "AttributeValueç±»å‹è½¬æ¢è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å±æ€§å€¼ç±»å‹çš„è¾¹ç•Œè½¬æ¢æƒ…å†µ
  let attrs = Attributes::new()
  
  // æµ‹è¯•æå€¼æ•´æ•°
  Attributes::set(attrs, "int.max", IntValue(2147483647))
  Attributes::set(attrs, "int.min", IntValue(-2147483648))
  Attributes::set(attrs, "int.zero", IntValue(0))
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  Attributes::set(attrs, "float.pi", FloatValue(3.14159265359))
  Attributes::set(attrs, "float.zero", FloatValue(0.0))
  Attributes::set(attrs, "float.negative", FloatValue(-1.0))
  Attributes::set(attrs, "float.scientific", FloatValue(1.23e-4))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦ä¸²
  Attributes::set(attrs, "string.empty", StringValue(""))
  Attributes::set(attrs, "string.spaces", StringValue("   "))
  Attributes::set(attrs, "string.special", StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  Attributes::set(attrs, "string.unicode", StringValue("æµ‹è¯•ğŸš€ğŸ“ŠÎ±Î²Î³Î´ÎµÎ¶Î·Î¸"))
  
  // æµ‹è¯•å¸ƒå°”å€¼çš„è¾¹ç•Œæƒ…å†µ
  Attributes::set(attrs, "bool.true", BoolValue(true))
  Attributes::set(attrs, "bool.false", BoolValue(false))
  
  // æµ‹è¯•æ•°ç»„ç±»å‹çš„è¾¹ç•Œæƒ…å†µ
  Attributes::set(attrs, "array.string.empty", ArrayStringValue([]))
  Attributes::set(attrs, "array.string.single", ArrayStringValue(["single"]))
  Attributes::set(attrs, "array.string.unicode", ArrayStringValue(["æµ‹è¯•", "ğŸš€", "Î±Î²Î³"]))
  
  Attributes::set(attrs, "array.int.empty", ArrayIntValue([]))
  Attributes::set(attrs, "array.int.single", ArrayIntValue([42]))
  Attributes::set(attrs, "array.int.negative", ArrayIntValue([-1, -2, -3]))
  Attributes::set(attrs, "array.int.zero", ArrayIntValue([0, 0, 0]))
  
  // éªŒè¯æ£€ç´¢ç»“æœ
  let int_max = Attributes::get(attrs, "int.max")
  let float_pi = Attributes::get(attrs, "float.pi")
  let string_empty = Attributes::get(attrs, "string.empty")
  let bool_true = Attributes::get(attrs, "bool.true")
  
  // æ³¨æ„ï¼šç®€åŒ–å®ç°åªè¿”å›é¢„å®šä¹‰çš„æµ‹è¯•å€¼
  assert_eq(int_max, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(float_pi, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(string_empty, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(bool_true, None)  // ç®€åŒ–å®ç°è¿”å›None
  
  // æµ‹è¯•é¢„å®šä¹‰çš„æµ‹è¯•é”®
  let string_val = Attributes::get(attrs, "string.key")
  let int_val = Attributes::get(attrs, "int.key")
  
  assert_eq(string_val, Some(StringValue("test_value")))
  assert_eq(int_val, Some(IntValue(42)))
}

test "SpanKindæšä¸¾è¡Œä¸ºå®Œæ•´æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "span.kind.test")
  
  // æµ‹è¯•æ‰€æœ‰SpanKindç±»å‹
  let internal_span = Tracer::start_span(tracer, "internal.operation")
  let server_span = Tracer::start_span(tracer, "server.request")
  let client_span = Tracer::start_span(tracer, "client.request")
  let producer_span = Tracer::start_span(tracer, "producer.operation")
  let consumer_span = Tracer::start_span(tracer, "consumer.operation")
  
  // éªŒè¯spanåç§°
  assert_eq(Span::name(internal_span), "internal.operation")
  assert_eq(Span::name(server_span), "server.request")
  assert_eq(Span::name(client_span), "client.request")
  assert_eq(Span::name(producer_span), "producer.operation")
  assert_eq(Span::name(consumer_span), "consumer.operation")
  
  // éªŒè¯æ‰€æœ‰spanéƒ½åœ¨è®°å½•çŠ¶æ€
  assert_true(Span::is_recording(internal_span))
  assert_true(Span::is_recording(server_span))
  assert_true(Span::is_recording(client_span))
  assert_true(Span::is_recording(producer_span))
  assert_true(Span::is_recording(consumer_span))
  
  // æµ‹è¯•ä¸åŒç±»å‹spançš„äº‹ä»¶æ·»åŠ 
  Span::add_event(internal_span, "internal.event", Some([("component", StringValue("database"))]))
  Span::add_event(server_span, "request.received", Some([("method", StringValue("GET")), ("path", StringValue("/api/users"))]))
  Span::add_event(client_span, "request.sent", Some([("url", StringValue("https://api.example.com/data"))]))
  Span::add_event(producer_span, "message.produced", Some([("topic", StringValue("events")), ("size", IntValue(1024))]))
  Span::add_event(consumer_span, "message.consumed", Some([("topic", StringValue("events")), ("offset", IntValue(12345))]))
  
  // æµ‹è¯•ä¸åŒç±»å‹spançš„çŠ¶æ€è®¾ç½®
  Span::set_status(internal_span, Ok, Some("Internal operation completed"))
  Span::set_status(server_span, Ok, Some("Request processed successfully"))
  Span::set_status(client_span, Error, Some("Client request failed"))
  Span::set_status(producer_span, Ok, Some("Message produced successfully"))
  Span::set_status(consumer_span, Error, Some("Message processing failed"))
  
  // ç»“æŸæ‰€æœ‰span
  Span::end(internal_span)
  Span::end(server_span)
  Span::end(client_span)
  Span::end(producer_span)
  Span::end(consumer_span)
  
  assert_true(true)
}

test "SeverityNumberæ—¥å¿—çº§åˆ«å±‚æ¬¡æµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "severity.test")
  
  // åˆ›å»ºæ‰€æœ‰ä¸¥é‡ç¨‹åº¦çš„æ—¥å¿—è®°å½•
  let trace_record = LogRecord::new(Trace, "Trace level message - most detailed")
  let debug_record = LogRecord::new(Debug, "Debug level message - development info")
  let info_record = LogRecord::new(Info, "Info level message - general information")
  let warn_record = LogRecord::new(Warn, "Warning level message - potential issue")
  let error_record = LogRecord::new(Error, "Error level message - error occurred")
  let fatal_record = LogRecord::new(Fatal, "Fatal level message - critical failure")
  
  // éªŒè¯ä¸¥é‡ç¨‹åº¦
  assert_eq(LogRecord::severity_number(trace_record), Trace)
  assert_eq(LogRecord::severity_number(debug_record), Debug)
  assert_eq(LogRecord::severity_number(info_record), Info)
  assert_eq(LogRecord::severity_number(warn_record), Warn)
  assert_eq(LogRecord::severity_number(error_record), Error)
  assert_eq(LogRecord::severity_number(fatal_record), Fatal)
  
  // éªŒè¯æ¶ˆæ¯å†…å®¹
  assert_eq(LogRecord::body(trace_record), Some("Trace level message - most detailed"))
  assert_eq(LogRecord::body(debug_record), Some("Debug level message - development info"))
  assert_eq(LogRecord::body(info_record), Some("Info level message - general information"))
  assert_eq(LogRecord::body(warn_record), Some("Warning level message - potential issue"))
  assert_eq(LogRecord::body(error_record), Some("Error level message - error occurred"))
  assert_eq(LogRecord::body(fatal_record), Some("Fatal level message - critical failure"))
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„æ—¥å¿—è®°å½•
  let detailed_error = LogRecord::new_with_context(
    Error,
    Some("Detailed error with context"),
    Some(Attributes::with_attributes(Attributes::new(), [
      ("error.code", StringValue("DB_CONNECTION_FAILED")),
      ("error.retry", IntValue(3)),
      ("error.timeout", FloatValue(30.0)),
      ("error.critical", BoolValue(true))
    ])),
    Some(1735689600000000000L),
    Some(1735689600000001000L),
    Some("0af7651916cd43dd8448eb211c80319c"),
    Some("b7ad6b7169203331"),
    Some(Context::root())
  )
  
  assert_eq(LogRecord::severity_number(detailed_error), Error)
  match LogRecord::body(detailed_error) {
    Some(body) => assert_eq(body, "Detailed error with context")
    None => assert_true(false)
  }
  
  // å‘å‡ºæ‰€æœ‰æ—¥å¿—è®°å½•
  Logger::emit(logger, trace_record)
  Logger::emit(logger, debug_record)
  Logger::emit(logger, info_record)
  Logger::emit(logger, warn_record)
  Logger::emit(logger, error_record)
  Logger::emit(logger, fatal_record)
  Logger::emit(logger, detailed_error)
  
  assert_true(true)
}

test "æ—¶é—´åºåˆ—æ•°æ®å¤„ç†æµ‹è¯•" {
  let clock = Clock::system()
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "time.series.test")
  
  // åˆ›å»ºæ—¶é—´åºåˆ—ç›¸å…³çš„metrics
  let request_counter = Meter::create_counter(meter, "http.requests.total")
  let response_histogram = Meter::create_histogram(meter, "http.response.duration")
  let active_connections = Meter::create_updown_counter(meter, "http.active.connections")
  
  // æ¨¡æ‹Ÿæ—¶é—´åºåˆ—æ•°æ®æ”¶é›†
  let timestamps = []
  for i = 0; i < 10; i = i + 1 {
    let timestamp = Clock::now_unix_nanos(clock) + (i * 1000000L)  // æ¯æ¯«ç§’ä¸€ä¸ªæ•°æ®ç‚¹
    timestamps.push(timestamp)
  }
  
  // åœ¨ä¸åŒæ—¶é—´ç‚¹è®°å½•æ•°æ®
  for i = 0; i < timestamps.length(); i = i + 1 {
    // æ¨¡æ‹Ÿè¯·æ±‚æ•°æ®
    Counter::add(request_counter, 1.0)
    
    // æ¨¡æ‹Ÿå“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
    let response_time = 50.0 + i.to_double() * 10.0 + (i % 3) * 5.0
    Histogram::record(response_histogram, response_time)
    
    // æ¨¡æ‹Ÿæ´»è·ƒè¿æ¥æ•°å˜åŒ–
    if i % 3 == 0 {
      Counter::add(active_connections, 1.0)  // æ–°è¿æ¥
    } else if i % 5 == 0 {
      Counter::add(active_connections, -1.0)  // è¿æ¥å…³é—­
    }
  }
  
  // åˆ›å»ºå¸¦æœ‰æ—¶é—´æˆ³çš„æ—¥å¿—è®°å½•
  let time_series_logs = []
  for i = 0; i < timestamps.length(); i = i + 1 {
    let log = LogRecord::new_with_context(
      Info,
      Some("Time series data point " + i.to_string()),
      None,
      Some(timestamps[i]),
      None,
      None,
      None,
      None
    )
    time_series_logs.push(log)
  }
  
  // éªŒè¯æ—¶é—´æˆ³é¡ºåº
  for i = 1; i < timestamps.length(); i = i + 1 {
    assert_true(timestamps[i] > timestamps[i-1])
  }
  
  // æµ‹è¯•æ—¶é—´çª—å£èšåˆï¼ˆæ¨¡æ‹Ÿï¼‰
  let window_start = timestamps[0]
  let window_end = timestamps[timestamps.length() - 1]
  let window_duration = window_end - window_start
  
  assert_true(window_duration > 0L)
  
  // å‘å‡ºæ—¶é—´åºåˆ—æ—¥å¿—
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "time.series.logger")
  
  for log in time_series_logs {
    Logger::emit(logger, log)
  }
  
  assert_true(true)
}

test "å¤åˆå±æ€§æ“ä½œåµŒå¥—æµ‹è¯•" {
  // æµ‹è¯•å¤æ‚çš„åµŒå¥—å±æ€§æ“ä½œ
  let base_attrs = Attributes::new()
  
  // åˆ›å»ºå¤šçº§åµŒå¥—å±æ€§ç»“æ„
  Attributes::set(base_attrs, "app.name", StringValue("azimuth.telemetry"))
  Attributes::set(base_attrs, "app.version", StringValue("1.0.0"))
  Attributes::set(base_attrs, "app.environment", StringValue("production"))
  
  // æœåŠ¡ç›¸å…³å±æ€§
  Attributes::set(base_attrs, "service.name", StringValue("auth.service"))
  Attributes::set(base_attrs, "service.instance.id", StringValue("auth-001"))
  Attributes::set(base_attrs, "service.namespace", StringValue("security"))
  
  // ä¸»æœºç›¸å…³å±æ€§
  Attributes::set(base_attrs, "host.name", StringValue("auth-server-01"))
  Attributes::set(base_attrs, "host.ip", StringValue("192.168.1.100"))
  Attributes::set(base_attrs, "host.arch", StringValue("x86_64"))
  
  // å®¹å™¨ç›¸å…³å±æ€§
  Attributes::set(base_attrs, "container.name", StringValue("auth-container"))
  Attributes::set(base_attrs, "container.image", StringValue("azimuth/auth:1.0.0"))
  Attributes::set(base_attrs, "container.id", StringValue("abc123def456"))
  
  // K8sç›¸å…³å±æ€§
  Attributes::set(base_attrs, "k8s.pod.name", StringValue("auth-pod-7xyz"))
  Attributes::set(base_attrs, "k8s.namespace.name", StringValue("production"))
  Attributes::set(base_attrs, "k8s.deployment.name", StringValue("auth-deployment"))
  
  // æµ‹è¯•å±æ€§æ£€ç´¢
  let app_name = Attributes::get(base_attrs, "app.name")
  let service_name = Attributes::get(base_attrs, "service.name")
  let host_name = Attributes::get(base_attrs, "host.name")
  let container_name = Attributes::get(base_attrs, "container.name")
  let pod_name = Attributes::get(base_attrs, "k8s.pod.name")
  
  // æ³¨æ„ï¼šç®€åŒ–å®ç°åªè¿”å›é¢„å®šä¹‰çš„æµ‹è¯•å€¼
  assert_eq(app_name, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(service_name, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(host_name, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(container_name, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(pod_name, None)  // ç®€åŒ–å®ç°è¿”å›None
  
  // æµ‹è¯•é¢„å®šä¹‰çš„æµ‹è¯•é”®
  let string_val = Attributes::get(base_attrs, "string.key")
  let int_val = Attributes::get(base_attrs, "int.key")
  
  assert_eq(string_val, Some(StringValue("test_value")))
  assert_eq(int_val, Some(IntValue(42)))
  
  // åˆ›å»ºå¸¦æœ‰å¤åˆå±æ€§çš„span
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "complex.attrs.test")
  let span = Tracer::start_span(tracer, "complex.operation")
  
  // æ·»åŠ å¤åˆäº‹ä»¶
  Span::add_event(span, "operation.start", Some([
    ("app.name", StringValue("azimuth.telemetry")),
    ("service.name", StringValue("auth.service")),
    ("operation.type", StringValue("user.authentication")),
    ("user.id", StringValue("12345"))
  ]))
  
  Span::add_event(span, "database.query", Some([
    ("db.type", StringValue("postgresql")),
    ("db.name", StringValue("authdb")),
    ("db.statement", StringValue("SELECT * FROM users WHERE id = $1")),
    ("db.duration", IntValue(25))
  ]))
  
  Span::add_event(span, "cache.access", Some([
    ("cache.type", StringValue("redis")),
    ("cache.hit", BoolValue(true)),
    ("cache.key", StringValue("user:12345")),
    ("cache.ttl", IntValue(3600))
  ]))
  
  Span::set_status(span, Ok, Some("Operation completed successfully"))
  Span::end(span)
  
  assert_true(true)
}

test "è·¨æœåŠ¡ä¸€è‡´æ€§éªŒè¯æµ‹è¯•" {
  // æµ‹è¯•è·¨å¤šä¸ªæœåŠ¡çš„ä¸€è‡´æ€§éªŒè¯
  let services = ["auth.service", "user.service", "order.service", "payment.service", "notification.service"]
  let trace_id = "0af7651916cd43dd8448eb211c80319c"
  
  // ä¸ºæ¯ä¸ªæœåŠ¡åˆ›å»ºtracerå’Œspan
  let tracer_provider = TracerProvider::default()
  let spans = []
  
  for service in services {
    let tracer = TracerProvider::get_tracer(tracer_provider, service)
    let span = Tracer::start_span(tracer, service + ".operation")
    spans.push(span)
  }
  
  // ä¸ºæ¯ä¸ªspanæ·»åŠ ä¸€è‡´çš„äº‹ä»¶
  let consistent_events = [
    ("request.received", [("timestamp", StringValue("2025-01-01T10:00:00Z")), ("trace.id", StringValue(trace_id))]),
    ("authentication.completed", [("user.id", StringValue("12345")), ("auth.method", StringValue("oauth2"))]),
    ("authorization.checked", [("permission", StringValue("read")), ("resource", StringValue("user.profile"))]),
    ("business.logic.executed", [("operation", StringValue("get.user")), ("duration", IntValue(150))]),
    ("response.generated", [("status.code", StringValue("200")), ("response.size", IntValue(1024))])
  ]
  
  // ä¸ºæ¯ä¸ªspanæ·»åŠ ä¸€è‡´çš„äº‹ä»¶
  for span in spans {
    for event in consistent_events {
      Span::add_event(span, event.0, Some(event.1))
    }
  }
  
  // ä¸ºæ¯ä¸ªspanæ·»åŠ æœåŠ¡ç‰¹å®šçš„äº‹ä»¶
  let service_specific_events = [
    ("auth.service", [("token.issued", BoolValue(true)), ("token.expiry", IntValue(3600))]),
    ("user.service", [("profile.loaded", BoolValue(true)), ("profile.completeness", FloatValue(0.85))]),
    ("order.service", [("order.count", IntValue(5)), ("last.order", StringValue("2024-12-28"))]),
    ("payment.service", [("payment.method", StringValue("credit.card")), ("amount", FloatValue(99.99))]),
    ("notification.service", [("notification.sent", BoolValue(true)), ("channel", StringValue("email"))])
  ]
  
  for i = 0; i < spans.length(); i = i + 1 {
    let span = spans[i]
    let service_event = service_specific_events[i]
    Span::add_event(span, "service.specific", Some(service_event.1))
  }
  
  // è®¾ç½®æ‰€æœ‰spançš„çŠ¶æ€
  for span in spans {
    Span::set_status(span, Ok, Some("Service operation completed"))
  }
  
  // ç»“æŸæ‰€æœ‰span
  for span in spans {
    Span::end(span)
  }
  
  // éªŒè¯æ‰€æœ‰spançš„åç§°
  for i = 0; i < spans.length(); i = i + 1 {
    let expected_name = services[i] + ".operation"
    assert_eq(Span::name(spans[i]), expected_name)
  }
  
  // æµ‹è¯•è·¨æœåŠ¡çš„baggageä¼ æ’­
  let initial_baggage = Baggage::new()
  let baggage1 = Baggage::set_entry(initial_baggage, "user.id", "12345")
  let baggage2 = Baggage::set_entry(baggage1, "request.id", "req-67890")
  let baggage3 = Baggage::set_entry(baggage2, "session.id", "sess-abc123")
  
  // éªŒè¯baggageå†…å®¹
  let user_id = Baggage::get_entry(baggage3, "user.id")
  let request_id = Baggage::get_entry(baggage3, "request.id")
  let session_id = Baggage::get_entry(baggage3, "session.id")
  
  assert_eq(user_id, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(request_id, None)  // ç®€åŒ–å®ç°è¿”å›None
  assert_eq(session_id, None)  // ç®€åŒ–å®ç°è¿”å›None
  
  assert_true(true)
}

test "èµ„æºç®¡ç†è¾¹ç•Œå‹åŠ›æµ‹è¯•" {
  // æµ‹è¯•èµ„æºç®¡ç†åœ¨è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º
  let max_resources = 100
  let resources = []
  
  // åˆ›å»ºå¤§é‡èµ„æº
  for i = 0; i < max_resources; i = i + 1 {
    let resource_attrs = [
      ("resource.id", StringValue("resource-" + i.to_string())),
      ("resource.type", StringValue("test.resource")),
      ("resource.created", IntValue(1735689600 + i)),
      ("resource.size", IntValue(1024 * (i + 1))),
      ("resource.active", BoolValue(i % 2 == 0)),
      ("resource.priority", FloatValue(i.to_double() / 10.0))
    ]
    
    let resource = Resource::with_attributes(Resource::new(), resource_attrs)
    resources.push(resource)
  }
  
  // æµ‹è¯•èµ„æºåˆå¹¶æ€§èƒ½
  let base_resource = Resource::with_attributes(Resource::new(), [
    ("base.id", StringValue("base-resource")),
    ("base.type", StringValue("base.type")),
    ("base.version", StringValue("1.0.0"))
  ])
  
  let merged_resources = []
  for resource in resources {
    let merged = Resource::merge(base_resource, resource)
    merged_resources.push(merged)
  }
  
  // éªŒè¯åˆå¹¶åçš„èµ„æºæ•°é‡
  assert_eq(merged_resources.length(), max_resources)
  
  // æµ‹è¯•èµ„æºå±æ€§æ£€ç´¢
  for i = 0; i < 10; i = i + 1 {  // åªæµ‹è¯•å‰10ä¸ªä»¥é¿å…æ€§èƒ½é—®é¢˜
    let resource = resources[i]
    let resource_id = Resource::get_attribute(resource, "resource.id")
    let resource_type = Resource::get_attribute(resource, "resource.type")
    let resource_active = Resource::get_attribute(resource, "resource.active")
    
    assert_eq(resource_id, None)  // ç®€åŒ–å®ç°è¿”å›None
    assert_eq(resource_type, None)  // ç®€åŒ–å®ç°è¿”å›None
    assert_eq(resource_active, None)  // ç®€åŒ–å®ç°è¿”å›None
  }
  
  // æµ‹è¯•ç©ºèµ„æº
  let empty_resource = Resource::new()
  let empty_attrs = Resource::get_attribute(empty_resource, "nonexistent")
  assert_eq(empty_attrs, None)
  
  // æµ‹è¯•èµ„æºé“¾å¼åˆå¹¶
  let chain_resource = Resource::new()
  for i = 0; i < 10; i = i + 1 {
    let attrs = [("chain.level", StringValue("level-" + i.to_string()))]
    let temp_resource = Resource::with_attributes(Resource::new(), attrs)
    chain_resource = Resource::merge(chain_resource, temp_resource)
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§çš„å•ä¸€èµ„æº
  let many_attrs = []
  for i = 0; i < 50; i = i + 1 {
    many_attrs.push(("attr." + i.to_string(), StringValue("value-" + i.to_string())))
  }
  
  let many_attrs_resource = Resource::with_attributes(Resource::new(), many_attrs)
  
  // æµ‹è¯•å±æ€§æ£€ç´¢
  for i = 0; i < 5; i = i + 1 {  // åªæµ‹è¯•å‰5ä¸ª
    let attr_value = Resource::get_attribute(many_attrs_resource, "attr." + i.to_string())
    assert_eq(attr_value, None)  // ç®€åŒ–å®ç°è¿”å›None
  }
  
  assert_true(true)
}

test "å¹¶å‘å®‰å…¨å¢å¼ºåœºæ™¯æµ‹è¯•" {
  // æµ‹è¯•æ›´å¤æ‚çš„å¹¶å‘å®‰å…¨åœºæ™¯
  let concurrent_operations = 50
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  // åˆ›å»ºå¤šä¸ªtracerã€meterå’Œlogger
  let tracers = []
  let meters = []
  let loggers = []
  
  for i = 0; i < 10; i = i + 1 {
    let tracer = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer." + i.to_string())
    let meter = MeterProvider::get_meter(meter_provider, "concurrent.meter." + i.to_string())
    let logger = LoggerProvider::get_logger(logger_provider, "concurrent.logger." + i.to_string())
    
    tracers.push(tracer)
    meters.push(meter)
    loggers.push(logger)
  }
  
  // å¹¶å‘åˆ›å»ºspan
  let spans = []
  for i = 0; i < concurrent_operations; i = i + 1 {
    let tracer_index = i % tracers.length()
    let tracer = tracers[tracer_index]
    let span = Tracer::start_span(tracer, "concurrent.span." + i.to_string())
    spans.push(span)
  }
  
  // å¹¶å‘åˆ›å»ºmetrics
  let counters = []
  let histograms = []
  
  for i = 0; i < 10; i = i + 1 {
    let meter_index = i % meters.length()
    let meter = meters[meter_index]
    
    let counter = Meter::create_counter(meter, "concurrent.counter." + i.to_string())
    let histogram = Meter::create_histogram(meter, "concurrent.histogram." + i.to_string())
    
    counters.push(counter)
    histograms.push(histogram)
  }
  
  // å¹¶å‘æ“ä½œspan
  for i = 0; i < spans.length(); i = i + 1 {
    let span = spans[i]
    
    // æ·»åŠ äº‹ä»¶
    Span::add_event(span, "concurrent.event", Some([
      ("span.index", IntValue(i)),
      ("operation", StringValue("concurrent.test")),
      ("timestamp", IntValue(1735689600 + i))
    ]))
    
    // è®¾ç½®çŠ¶æ€
    if i % 5 == 0 {
      Span::set_status(span, Error, Some("Simulated error"))
    } else {
      Span::set_status(span, Ok)
    }
  }
  
  // å¹¶å‘è®°å½•metrics
  for i = 0; i < 100; i = i + 1 {
    let counter_index = i % counters.length()
    let histogram_index = i % histograms.length()
    
    Counter::add(counters[counter_index], i.to_double())
    Histogram::record(histograms[histogram_index], i.to_double() * 1.5)
  }
  
  // å¹¶å‘åˆ›å»ºå’Œå‘å‡ºæ—¥å¿—
  for i = 0; i < 50; i = i + 1 {
    let logger_index = i % loggers.length()
    let logger = loggers[logger_index]
    
    let severity = if i % 6 == 0 {
      Fatal
    } else if i % 5 == 0 {
      Error
    } else if i % 4 == 0 {
      Warn
    } else if i % 3 == 0 {
      Info
    } else if i % 2 == 0 {
      Debug
    } else {
      Trace
    }
    
    let log = LogRecord::new_with_context(
      severity,
      Some("Concurrent log message " + i.to_string()),
      None,
      Some(1735689600000000000L + i.to_int64() * 1000000L),
      None,
      Some("trace-" + i.to_string()),
      Some("span-" + i.to_string()),
      None
    )
    
    Logger::emit(logger, log)
  }
  
  // å¹¶å‘ç»“æŸspan
  for span in spans {
    Span::end(span)
  }
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½æˆåŠŸå®Œæˆ
  assert_eq(spans.length(), concurrent_operations)
  assert_eq(counters.length(), 10)
  assert_eq(histograms.length(), 10)
  assert_eq(tracers.length(), 10)
  assert_eq(meters.length(), 10)
  assert_eq(loggers.length(), 10)
  
  assert_true(true)
}