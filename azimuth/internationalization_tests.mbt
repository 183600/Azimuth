// Internationalization and Globalization Test Suite for Azimuth
// This file contains comprehensive tests for internationalization features

// Test 1: Multi-language error messages and logging
pub test "multi-language error messages and logging" {
  let logger_provider = azimuth::LoggerProvider::default()
  let logger = azimuth::LoggerProvider::get_logger(logger_provider, "i18n-test")
  
  // Test error messages in different languages
  let error_messages = [
    ("en", "User authentication failed"),
    ("zh", "ç”¨æˆ·èº«ä»½éªŒè¯å¤±è´¥"),
    ("es", "Error de autenticaciÃ³n de usuario"),
    ("fr", "Ã‰chec de l'authentification de l'utilisateur"),
    ("de", "Benutzer-Authentifizierung fehlgeschlagen"),
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ"),
    ("ko", "ì‚¬ìš©ì ì¸ì¦ ì‹¤íŒ¨"),
    ("ru", "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"),
    ("ar", "ÙØ´Ù„ Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"),
    ("hi", "à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤ªà¥à¤°à¤®à¤¾à¤£à¥€à¤•à¤°à¤£ à¤µà¤¿à¤«à¤²")
  ]
  
  // Create log records in different languages
  let log_records = []
  for (lang, message) in error_messages {
    let log_record = azimuth::LogRecord::new_with_context(
      azimuth::Error,
      Some(message),
      None,
      Some(azimuth::Clock::now_unix_nanos(azimuth::Clock::system())),
      None,
      None,
      None,
      None
    )
    log_records.push((lang, log_record))
  }
  
  // Verify all log records were created with correct messages
  for (expected_lang, expected_message) in error_messages {
    let found = false
    for (actual_lang, record) in log_records {
      if actual_lang == expected_lang {
        assert_eq(azimuth::LogRecord::body(record), Some(expected_message))
        assert_eq(azimuth::LogRecord::severity_number(record), azimuth::Error)
        found = true
        break
      }
    }
    assert_true(found, "Log record for language " + expected_lang + " not found")
  }
}

// Test 2: Unicode and multi-byte character handling in attributes
pub test "unicode and multi-byte character handling in attributes" {
  let attrs = azimuth::Attributes::new()
  
  // Test with various Unicode characters and scripts
  let unicode_test_values = [
    // Chinese characters
    ("chinese.name", azimuth::StringValue("å¼ ä¸‰")),
    ("chinese.address", azimuth::StringValue("åŒ—äº¬å¸‚æœé˜³åŒºå»ºå›½é—¨å¤–å¤§è¡—1å·")),
    
    // Japanese characters
    ("japanese.name", azimuth::StringValue("ç”°ä¸­å¤ªéƒ")),
    ("japanese.address", azimuth::StringValue("æ±äº¬éƒ½åƒä»£ç”°åŒºä¸¸ã®å†…1-2-3")),
    
    // Korean characters
    ("korean.name", azimuth::StringValue("ê¹€ì² ìˆ˜")),
    ("korean.address", azimuth::StringValue("ì„œìš¸íŠ¹ë³„ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123")),
    
    // Arabic characters
    ("arabic.name", azimuth::StringValue("Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯")),
    ("arabic.text", azimuth::StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…")),
    
    // Hebrew characters
    ("hebrew.name", azimuth::StringValue("×“×•×“ ×›×”×Ÿ")),
    ("hebrew.text", azimuth::StringValue("×©×œ×•× ×¢×•×œ×")),
    
    // Cyrillic characters (Russian)
    ("russian.name", azimuth::StringValue("Ğ˜Ğ²Ğ°Ğ½ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²")),
    ("russian.text", azimuth::StringValue("ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€")),
    
    // Hindi characters
    ("hindi.name", azimuth::StringValue("à¤°à¤¾à¤® à¤•à¥à¤®à¤¾à¤°")),
    ("hindi.text", azimuth::StringValue("à¤¨à¤®à¤¸à¥à¤¤à¥‡ à¤¦à¥à¤¨à¤¿à¤¯à¤¾")),
    
    // Thai characters
    ("thai.name", azimuth::StringValue("à¸ªà¸¡à¸Šà¸²à¸¢ à¹ƒà¸ˆà¸”à¸µ")),
    ("thai.text", azimuth::StringValue("à¸ªà¸§à¸±à¸ªà¸”à¸µà¸Šà¸²à¸§à¹‚à¸¥à¸")),
    
    // Emoji and symbols
    ("emoji.text", azimuth::StringValue("ğŸš€ğŸ”¥ğŸ’¯âœ¨ğŸ‰ğŸŒŸ")),
    ("symbols.math", azimuth::StringValue("âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚âˆšâˆâ‰ˆâ‰ â‰¤â‰¥Â±Ã—Ã·")),
    ("symbols.currency", azimuth::StringValue("$â‚¬Â£Â¥â‚¹â‚½â‚©â‚ªâ‚«â‚¡â‚¨â‚¦â‚±â‚²â‚´â‚¸â‚¼â‚½")),
    
    // Mixed scripts
    ("mixed.text", azimuth::StringValue("Hello ä½ å¥½ ì•ˆë…•í•˜ì„¸ìš” Ù…Ø±Ø­Ø¨Ø§ ×©×œ×•× ĞŸÑ€Ğ¸Ğ²ĞµÑ‚")),
    ("complex.mixed", azimuth::StringValue("User: å¼ ä¸‰, ID: 12345, Status: âœ… Active"))
  ]
  
  // Set all Unicode attributes
  for (key, value) in unicode_test_values {
    azimuth::Attributes::set(attrs, key, value)
  }
  
  // Verify all Unicode attributes were stored correctly
  for (key, expected_value) in unicode_test_values {
    let actual_value = azimuth::Attributes::get(attrs, key)
    assert_eq(actual_value, Some(expected_value))
  }
}

// Test 3: Locale-specific formatting in telemetry data
pub test "locale-specific formatting in telemetry data" {
  let attrs = azimuth::Attributes::new()
  
  // Test locale-specific number formatting
  let locale_numbers = [
    ("en_US.decimal", azimuth::StringValue("1,234.56")),
    ("de_DE.decimal", azimuth::StringValue("1.234,56")),
    ("fr_FR.decimal", azimuth::StringValue("1 234,56")),
    ("zh_CN.decimal", azimuth::StringValue("1,234.56")),
    ("ja_JP.decimal", azimuth::StringValue("1,234.56")),
    ("ru_RU.decimal", azimuth::StringValue("1 234,56")),
    ("ar_SA.decimal", azimuth::StringValue("Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦")),
    ("hi_IN.decimal", azimuth::StringValue("1,234.56"))
  ]
  
  // Test locale-specific date/time formatting
  let locale_dates = [
    ("en_US.date", azimuth::StringValue("01/15/2025 03:30:45 PM")),
    ("de_DE.date", azimuth::StringValue("15.01.2025 15:30:45")),
    ("fr_FR.date", azimuth::StringValue("15/01/2025 15:30:45")),
    ("zh_CN.date", azimuth::StringValue("2025/01/15 15:30:45")),
    ("ja_JP.date", azimuth::StringValue("2025/01/15 15:30:45")),
    ("ru_RU.date", azimuth::StringValue("15.01.2025 15:30:45")),
    ("ar_SA.date", azimuth::StringValue("Ù¡Ù¥/Ù Ù¡/Ù¢Ù Ù¢Ù¥ Ù Ù£:Ù£Ù :Ù¤Ù¥ Ù…")),
    ("ko_KR.date", azimuth::StringValue("2025. 01. 15. ì˜¤í›„ 03:30:45"))
  ]
  
  // Test locale-specific currency formatting
  let locale_currencies = [
    ("en_US.currency", azimuth::StringValue("$1,234.56")),
    ("de_DE.currency", azimuth::StringValue("1.234,56 â‚¬")),
    ("fr_FR.currency", azimuth::StringValue("1 234,56 â‚¬")),
    ("zh_CN.currency", azimuth::StringValue("Â¥1,234.56")),
    ("ja_JP.currency", azimuth::StringValue("ï¿¥1,235")),
    ("ru_RU.currency", azimuth::StringValue("1 234,56 â‚½")),
    ("ar_SA.currency", azimuth::StringValue("Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦ Ø±.Ø³")),
    ("hi_IN.currency", azimuth::StringValue("â‚¹1,234.56"))
  ]
  
  // Set all locale-specific attributes
  for (key, value) in locale_numbers {
    azimuth::Attributes::set(attrs, key, value)
  }
  for (key, value) in locale_dates {
    azimuth::Attributes::set(attrs, key, value)
  }
  for (key, value) in locale_currencies {
    azimuth::Attributes::set(attrs, key, value)
  }
  
  // Verify all locale-specific attributes
  let all_locale_values = locale_numbers + locale_dates + locale_currencies
  for (key, expected_value) in all_locale_values {
    let actual_value = azimuth::Attributes::get(attrs, key)
    assert_eq(actual_value, Some(expected_value))
  }
}

// Test 4: Right-to-left (RTL) language support
pub test "right-to-left (RTL) language support" {
  let attrs = azimuth::Attributes::new()
  
  // Test RTL languages
  let rtl_text_samples = [
    // Arabic
    ("arabic.greeting", azimuth::StringValue("Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ…")),
    ("arabic.sentence", azimuth::StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨ÙƒÙ… ÙÙŠ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø§")),
    ("arabic.mixed", azimuth::StringValue("Ø§Ù„Ù†Ø¸Ø§Ù… Azimuth ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø¬ÙŠØ¯")),
    
    // Hebrew
    ("hebrew.greeting", azimuth::StringValue("×©×œ×•× ×¢×•×œ×")),
    ("hebrew.sentence", azimuth::StringValue("×‘×¨×•×›×™× ×”×‘××™× ×œ××¢×¨×›×ª ×”××¢×§×‘ ×©×œ× ×•")),
    ("hebrew.mixed", azimuth::StringValue("×”××¢×¨×›×ª Azimuth ×¢×•×‘×“×ª ×”×™×˜×‘")),
    
    // Persian/Farsi
    ("persian.greeting", azimuth::StringValue("Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§")),
    ("persian.sentence", azimuth::StringValue("Ø¨Ù‡ Ø³ÛŒØ³ØªÙ… Ù†Ø¸Ø§Ø±Øª Ù…Ø§ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯")),
    ("persian.mixed", azimuth::StringValue("Ø³ÛŒØ³ØªÙ… Azimuth Ø¨Ù‡ Ø®ÙˆØ¨ÛŒ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯")),
    
    // Urdu
    ("urdu.greeting", azimuth::StringValue("ÛÛŒÙ„Ùˆ Ø¯Ù†ÛŒØ§")),
    ("urdu.sentence", azimuth::StringValue("ÛÙ…Ø§Ø±Û’ Ù†Ú¯Ø±Ø§Ù†ÛŒ Ù†Ø¸Ø§Ù… Ù…ÛŒÚº Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯")),
    ("urdu.mixed", azimuth::StringValue("Azimuth Ù†Ø¸Ø§Ù… Ø§Ú†Ú¾ÛŒ Ø·Ø±Ø­ Ú©Ø§Ù… Ú©Ø± Ø±ÛØ§ ÛÛ’"))
  ]
  
  // Set RTL text attributes
  for (key, value) in rtl_text_samples {
    azimuth::Attributes::set(attrs, key, value)
  }
  
  // Verify RTL text is preserved correctly
  for (key, expected_value) in rtl_text_samples {
    let actual_value = azimuth::Attributes::get(attrs, key)
    assert_eq(actual_value, Some(expected_value))
  }
  
  // Test RTL/LTR mixed content
  let mixed_directional_text = [
    ("mixed.en_ar", azimuth::StringValue("Hello Ø§Ù„Ø¹Ø§Ù„Ù…")),
    ("mixed.ar_en", azimuth::StringValue("Ù…Ø±Ø­Ø¨Ø§ World")),
    ("mixed.he_en_ja", azimuth::StringValue("×©×œ×•× World ã“ã‚“ã«ã¡ã¯")),
    ("mixed.complex", azimuth::StringValue("System: Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø© - Status: ×¤×¢×™×œ - User: ãƒ¦ãƒ¼ã‚¶ãƒ¼"))
  ]
  
  for (key, value) in mixed_directional_text {
    azimuth::Attributes::set(attrs, key, value)
  }
  
  for (key, expected_value) in mixed_directional_text {
    let actual_value = azimuth::Attributes::get(attrs, key)
    assert_eq(actual_value, Some(expected_value))
  }
}

// Test 5: Timezone and datetime internationalization
pub test "timezone and datetime internationalization" {
  let attrs = azimuth::Attributes::new()
  
  // Test different timezone representations
  let timezone_samples = [
    ("timezone.utc", azimuth::StringValue("2025-01-15T15:30:45Z")),
    ("timezone.est", azimuth::StringValue("2025-01-15T10:30:45-05:00")),
    ("timezone.pst", azimuth::StringValue("2025-01-15T07:30:45-08:00")),
    ("timezone.cet", azimuth::StringValue("2025-01-15T16:30:45+01:00")),
    ("timezone.jst", azimuth::StringValue("2025-01-16T00:30:45+09:00")),
    ("timezone.ist", azimuth::StringValue("2025-01-15T21:00:45+05:30")),
    ("timezone.cst", azimuth::StringValue("2025-01-15T23:30:45+08:00")),
    ("timezone.ms", azimuth::StringValue("2025-01-15T17:30:45+03:00"))
  ]
  
  // Test locale-specific date formats
  let locale_date_formats = [
    ("en_US.short_date", azimuth::StringValue("01/15/25")),
    ("en_US.long_date", azimuth::StringValue("January 15, 2025")),
    ("en_US.full_date", azimuth::StringValue("Wednesday, January 15, 2025")),
    
    ("de_DE.short_date", azimuth::StringValue("15.01.25")),
    ("de_DE.long_date", azimuth::StringValue("15. Januar 2025")),
    ("de_DE.full_date", azimuth::StringValue("Mittwoch, 15. Januar 2025")),
    
    ("fr_FR.short_date", azimuth::StringValue("15/01/2025")),
    ("fr_FR.long_date", azimuth::StringValue("15 janvier 2025")),
    ("fr_FR.full_date", azimuth::StringValue("mercredi 15 janvier 2025")),
    
    ("zh_CN.short_date", azimuth::StringValue("2025/1/15")),
    ("zh_CN.long_date", azimuth::StringValue("2025å¹´1æœˆ15æ—¥")),
    ("zh_CN.full_date", azimuth::StringValue("2025å¹´1æœˆ15æ—¥ æ˜ŸæœŸä¸‰")),
    
    ("ja_JP.short_date", azimuth::StringValue("2025/01/15")),
    ("ja_JP.long_date", azimuth::StringValue("2025å¹´1æœˆ15æ—¥")),
    ("ja_JP.full_date", azimuth::StringValue("2025å¹´1æœˆ15æ—¥(æ°´æ›œæ—¥)")),
    
    ("ru_RU.short_date", azimuth::StringValue("15.01.2025")),
    ("ru_RU.long_date", azimuth::StringValue("15 ÑĞ½Ğ²Ğ°Ñ€Ñ 2025 Ğ³.")),
    ("ru_RU.full_date", azimuth::StringValue("ÑÑ€ĞµĞ´Ğ°, 15 ÑĞ½Ğ²Ğ°Ñ€Ñ 2025 Ğ³."))
  ]
  
  // Test locale-specific time formats
  let locale_time_formats = [
    ("en_US.time_12h", azimuth::StringValue("3:30:45 PM")),
    ("en_US.time_24h", azimuth::StringValue("15:30:45")),
    
    ("de_DE.time_24h", azimuth::StringValue("15:30:45")),
    ("de_DE.time_12h", azimuth::StringValue("3:30:45 PM")),
    
    ("fr_FR.time_24h", azimuth::StringValue("15:30:45")),
    ("ja_JP.time_24h", azimuth::StringValue("15:30:45")),
    ("zh_CN.time_24h", azimuth::StringValue("15:30:45")),
    ("ru_RU.time_24h", azimuth::StringValue("15:30:45")),
    
    ("ko_KR.time_12h", azimuth::StringValue("ì˜¤í›„ 3:30:45")),
    ("ko_KR.time_24h", azimuth::StringValue("15:30:45")),
    
    ("ar_SA.time_12h", azimuth::StringValue("03:30:45 Ù…")),
    ("ar_SA.time_24h", azimuth::StringValue("15:30:45"))
  ]
  
  // Set all timezone and datetime attributes
  for (key, value) in timezone_samples {
    azimuth::Attributes::set(attrs, key, value)
  }
  for (key, value) in locale_date_formats {
    azimuth::Attributes::set(attrs, key, value)
  }
  for (key, value) in locale_time_formats {
    azimuth::Attributes::set(attrs, key, value)
  }
  
  // Verify all datetime attributes
  let all_datetime_values = timezone_samples + locale_date_formats + locale_time_formats
  for (key, expected_value) in all_datetime_values {
    let actual_value = azimuth::Attributes::get(attrs, key)
    assert_eq(actual_value, Some(expected_value))
  }
}

// Test 6: Internationalization in span and trace names
pub test "internationalization in span and trace names" {
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "i18n-tracer")
  
  // Test span names in different languages
  let i18n_span_names = [
    ("en", "user_authentication"),
    ("zh", "ç”¨æˆ·èº«ä»½éªŒè¯"),
    ("es", "autenticaciÃ³n_usuario"),
    ("fr", "authentification_utilisateur"),
    ("de", "benutzer_authentifizierung"),
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼"),
    ("ko", "ì‚¬ìš©ì_ì¸ì¦"),
    ("ru", "Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ_Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"),
    ("ar", "Ù…ØµØ§Ø¯Ù‚Ø©_Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"),
    ("hi", "à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾_à¤ªà¥à¤°à¤®à¤¾à¤£à¥€à¤•à¤°à¤£")
  ]
  
  // Create spans with internationalized names
  let spans = []
  for (lang, name) in i18n_span_names {
    let span = azimuth::Tracer::start_span(tracer, name)
    spans.push((lang, span))
  }
  
  // Verify all spans were created with correct names
  for (expected_lang, expected_name) in i18n_span_names {
    let found = false
    for (actual_lang, span) in spans {
      if actual_lang == expected_lang {
        assert_eq(azimuth::Span::name(span), expected_name)
        found = true
        break
      }
    }
    assert_true(found, "Span for language " + expected_lang + " not found")
  }
  
  // Test span attributes with internationalized content
  for (lang, span) in spans {
    let attrs = azimuth::Attributes::new()
    
    // Add language-specific attributes
    match lang {
      "en" => {
        azimuth::Attributes::set(attrs, "error.message", azimuth::StringValue("Invalid credentials"))
        azimuth::Attributes::set(attrs, "user.country", azimuth::StringValue("United States"))
      }
      "zh" => {
        azimuth::Attributes::set(attrs, "error.message", azimuth::StringValue("å‡­æ®æ— æ•ˆ"))
        azimuth::Attributes::set(attrs, "user.country", azimuth::StringValue("ä¸­å›½"))
      }
      "es" => {
        azimuth::Attributes::set(attrs, "error.message", azimuth::StringValue("Credenciales invÃ¡lidas"))
        azimuth::Attributes::set(attrs, "user.country", azimuth::StringValue("EspaÃ±a"))
      }
      "ja" => {
        azimuth::Attributes::set(attrs, "error.message", azimuth::StringValue("èªè¨¼æƒ…å ±ãŒç„¡åŠ¹ã§ã™"))
        azimuth::Attributes::set(attrs, "user.country", azimuth::StringValue("æ—¥æœ¬"))
      }
      "ar" => {
        azimuth::Attributes::set(attrs, "error.message", azimuth::StringValue("Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯ ØºÙŠØ± ØµØ§Ù„Ø­Ø©"))
        azimuth::Attributes::set(attrs, "user.country", azimuth::StringValue("Ø§Ù„Ù…Ù…Ù„ÙƒØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©"))
      }
      _ => {
        azimuth::Attributes::set(attrs, "error.message", azimuth::StringValue("Authentication failed"))
        azimuth::Attributes::set(attrs, "user.country", azimuth::StringValue("Unknown"))
      }
    }
    
    // Verify attributes were set
    let error_msg = azimuth::Attributes::get(attrs, "error.message")
    let user_country = azimuth::Attributes::get(attrs, "user.country")
    assert_true(error_msg.is_some())
    assert_true(user_country.is_some())
  }
}

// Test 7: Internationalization in metrics and instrument names
pub test "internationalization in metrics and instrument names" {
  let meter_provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(meter_provider, "i18n-meter")
  
  // Test metric names in different languages
  let i18n_metric_names = [
    ("en", "http_requests_total"),
    ("zh", "http_è¯·æ±‚æ€»æ•°"),
    ("es", "solicitudes_http_total"),
    ("fr", "total_requÃªtes_http"),
    ("de", "http_anfragen_gesamt"),
    ("ja", "httpãƒªã‚¯ã‚¨ã‚¹ãƒˆåˆè¨ˆ"),
    ("ko", "http_ìš”ì²­_ì´ê³„"),
    ("ru", "Ğ²ÑĞµĞ³Ğ¾_http_Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²"),
    ("ar", "Ø¥Ø¬Ù…Ø§Ù„ÙŠ_Ø·Ù„Ø¨Ø§Øª_http"),
    ("hi", "_http_à¤…à¤¨à¥à¤°à¥‹à¤§_à¤•à¥à¤²")
  ]
  
  // Create counters with internationalized names
  let counters = []
  for (lang, name) in i18n_metric_names {
    let counter = azimuth::Meter::create_counter(meter, name)
    counters.push((lang, counter))
  }
  
  // Verify all counters were created with correct names
  for (expected_lang, expected_name) in i18n_metric_names {
    let found = false
    for (actual_lang, counter) in counters {
      if actual_lang == expected_lang {
        assert_eq(counter.name, expected_name)
        found = true
        break
      }
    }
    assert_true(found, "Counter for language " + expected_lang + " not found")
  }
  
  // Test metric descriptions in different languages
  let counter = counters[0].1  // Get first counter
  let descriptions = [
    ("en", "Total number of HTTP requests"),
    ("zh", "HTTPè¯·æ±‚çš„æ€»æ•°"),
    ("es", "NÃºmero total de solicitudes HTTP"),
    ("fr", "Nombre total de requÃªtes HTTP"),
    ("de", "Gesamtzahl der HTTP-Anfragen"),
    ("ja", "HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ç·æ•°"),
    ("ko", "HTTP ìš”ì²­ì˜ ì´ ìˆ˜"),
    ("ru", "ĞĞ±Ñ‰ĞµĞµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ HTTP-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²"),
    ("ar", "Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø·Ù„Ø¨Ø§Øª HTTP"),
    ("hi", "HTTP à¤…à¤¨à¥à¤°à¥‹à¤§à¥‹à¤‚ à¤•à¥€ à¤•à¥à¤² à¤¸à¤‚à¤–à¥à¤¯à¤¾")
  ]
  
  // Create attributes with internationalized descriptions
  let attrs = azimuth::Attributes::new()
  for (lang, description) in descriptions {
    let key = "metric.description." + lang
    azimuth::Attributes::set(attrs, key, azimuth::StringValue(description))
  }
  
  // Verify all descriptions were stored
  for (lang, expected_description) in descriptions {
    let key = "metric.description." + lang
    let actual_description = azimuth::Attributes::get(attrs, key)
    assert_eq(actual_description, Some(azimuth::StringValue(expected_description)))
  }
}

// Test 8: Resource attributes with international content
pub test "resource attributes with international content" {
  let resource = azimuth::Resource::new()
  
  // Test resource attributes in different languages
  let i18n_resource_attrs = [
    // Service information in multiple languages
    ("service.name.en", azimuth::StringValue("User Authentication Service")),
    ("service.name.zh", azimuth::StringValue("ç”¨æˆ·èº«ä»½éªŒè¯æœåŠ¡")),
    ("service.name.es", azimuth::StringValue("Servicio de AutenticaciÃ³n de Usuario")),
    ("service.name.fr", azimuth::StringValue("Service d'Authentification Utilisateur")),
    ("service.name.ja", azimuth::StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹")),
    ("service.name.ar", azimuth::StringValue("Ø®Ø¯Ù…Ø© Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")),
    
    // Service descriptions
    ("service.description.en", azimuth::StringValue("Handles user authentication and authorization")),
    ("service.description.zh", azimuth::StringValue("å¤„ç†ç”¨æˆ·èº«ä»½éªŒè¯å’Œæˆæƒ")),
    ("service.description.es", azimuth::StringValue("Maneja la autenticaciÃ³n y autorizaciÃ³n de usuarios")),
    ("service.description.fr", azimuth::StringValue("GÃ¨re l'authentification et l'autorisation des utilisateurs")),
    ("service.description.ja", azimuth::StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èªè¨¼ã¨èªå¯ã‚’å‡¦ç†ã—ã¾ã™")),
    ("service.description.ar", azimuth::StringValue("ÙŠØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù…ØµØ§Ø¯Ù‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„ØªÙÙˆÙŠØ¶")),
    
    // Location information
    ("location.country.en", azimuth::StringValue("United States")),
    ("location.country.zh", azimuth::StringValue("ç¾å›½")),
    ("location.country.es", azimuth::StringValue("Estados Unidos")),
    ("location.country.fr", azimuth::StringValue("Ã‰tats-Unis")),
    ("location.country.ja", azimuth::StringValue("ã‚¢ãƒ¡ãƒªã‚«åˆè¡†å›½")),
    ("location.country.ar", azimuth::StringValue("Ø§Ù„ÙˆÙ„Ø§ÙŠØ§Øª Ø§Ù„Ù…ØªØ­Ø¯Ø© Ø§Ù„Ø£Ù…Ø±ÙŠÙƒÙŠØ©")),
    
    ("location.city.en", azimuth::StringValue("New York")),
    ("location.city.zh", azimuth::StringValue("çº½çº¦")),
    ("location.city.es", azimuth::StringValue("Nueva York")),
    ("location.city.fr", azimuth::StringValue("New York")),
    ("location.city.ja", azimuth::StringValue("ãƒ‹ãƒ¥ãƒ¼ãƒ¨ãƒ¼ã‚¯")),
    ("location.city.ar", azimuth::StringValue("Ù†ÙŠÙˆÙŠÙˆØ±Ùƒ")),
    
    // Team and organization information
    ("team.name.en", azimuth::StringValue("Platform Engineering Team")),
    ("team.name.zh", azimuth::StringValue("å¹³å°å·¥ç¨‹å›¢é˜Ÿ")),
    ("team.name.es", azimuth::StringValue("Equipo de IngenierÃ­a de Plataforma")),
    ("team.name.fr", azimuth::StringValue("Ã‰quipe d'IngÃ©nierie Plateforme")),
    ("team.name.ja", azimuth::StringValue("ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ãƒãƒ¼ãƒ ")),
    ("team.name.ar", azimuth::StringValue("ÙØ±ÙŠÙ‚ Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ù…Ù†ØµØ§Øª")),
    
    ("organization.name.en", azimuth::StringValue("Global Technology Corporation")),
    ("organization.name.zh", azimuth::StringValue("å…¨çƒæŠ€æœ¯å…¬å¸")),
    ("organization.name.es", azimuth::StringValue("CorporaciÃ³n TecnolÃ³gica Global")),
    ("organization.name.fr", azimuth::StringValue("SociÃ©tÃ© Technologique Mondiale")),
    ("organization.name.ja", azimuth::StringValue("ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼æ ªå¼ä¼šç¤¾")),
    ("organization.name.ar", azimuth::StringValue("Ø´Ø±ÙƒØ© Ø§Ù„ØªÙƒÙ†ÙˆÙ„ÙˆØ¬ÙŠØ§ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ©"))
  ]
  
  // Set all internationalized resource attributes
  let resource_with_i18n = azimuth::Resource::with_attributes(resource, i18n_resource_attrs)
  
  // Verify all internationalized attributes were stored correctly
  for (key, expected_value) in i18n_resource_attrs {
    let actual_value = azimuth::Resource::get_attribute(resource_with_i18n, key)
    assert_eq(actual_value, Some(expected_value))
  }
  
  // Test resource merging with internationalized content
  let additional_i18n_attrs = [
    ("service.version", azimuth::StringValue("2.1.0")),
    ("deployment.region.en", azimuth::StringValue("North America")),
    ("deployment.region.zh", azimuth::StringValue("åŒ—ç¾")),
    ("deployment.region.es", azimuth::StringValue("AmÃ©rica del Norte")),
    ("deployment.region.fr", azimuth::StringValue("AmÃ©rique du Nord")),
    ("deployment.region.ja", azimuth::StringValue("åŒ—ç±³")),
    ("deployment.region.ar", azimuth::StringValue("Ø£Ù…Ø±ÙŠÙƒØ§ Ø§Ù„Ø´Ù…Ø§Ù„ÙŠØ©"))
  ]
  
  let additional_resource = azimuth::Resource::with_attributes(resource, additional_i18n_attrs)
  let merged_resource = azimuth::Resource::merge(resource_with_i18n, additional_resource)
  
  // Verify merged resource contains all attributes
  let all_i18n_attrs = i18n_resource_attrs + additional_i18n_attrs
  for (key, expected_value) in all_i18n_attrs {
    let actual_value = azimuth::Resource::get_attribute(merged_resource, key)
    assert_eq(actual_value, Some(expected_value))
  }
}