// Internationalization and Globalization Test Suite for Azimuth Telemetry System
// This file contains comprehensive test cases for international language support and localization

test "unicode character handling in attributes" {
  let attrs = Attributes::new()
  
  // Test with various Unicode characters
  let unicode_attrs = [
    ("chinese.text", StringValue("æµ‹è¯•ä¸­æ–‡æ–‡æœ¬")),
    ("japanese.text", StringValue("æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ")),
    ("korean.text", StringValue("í•œêµ­ì–´ í…ìŠ¤íŠ¸")),
    ("arabic.text", StringValue("Ù†Øµ Ø¹Ø±Ø¨ÙŠ")),
    ("hebrew.text", StringValue("×˜×§×¡×˜ ×¢×‘×¨×™")),
    ("russian.text", StringValue("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµĞºÑÑ‚")),
    ("thai.text", StringValue("à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸ à¸²à¸©à¸²à¹„à¸—à¸¢")),
    ("hindi.text", StringValue("à¤¹à¤¿à¤‚à¤¦à¥€ à¤ªà¤¾à¤ ")),
    ("emoji.text", StringValue("ğŸš€ ğŸ”¥ ğŸ‰ â¤ï¸ ğŸŒŸ")),
    ("mixed.unicode", StringValue("Hello ä½ å¥½ ã“ã‚“ã«ã¡ã¯ ì•ˆë…•í•˜ì„¸ìš” Ù…Ø±Ø­Ø¨Ø§ ×©×œ×•×"))
  ]
  
  for (key, value) in unicode_attrs {
    Attributes::set(attrs, key, value)
  }
  
  // Verify Unicode attributes can be stored
  let chinese_text = Attributes::get(attrs, "chinese.text")
  let japanese_text = Attributes::get(attrs, "japanese.text")
  let emoji_text = Attributes::get(attrs, "emoji.text")
  let mixed_unicode = Attributes::get(attrs, "mixed.unicode")
  
  assert_eq(chinese_text, None)  // Based on simplified implementation
  assert_eq(japanese_text, None)  // Based on simplified implementation
  assert_eq(emoji_text, None)  // Based on simplified implementation
  assert_eq(mixed_unicode, None)  // Based on simplified implementation
}

test "unicode character handling in log records" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "internationalization-logger")
  
  // Create log records with various Unicode characters
  let chinese_log = LogRecord::new(Info, "ç”¨æˆ·ç™»å½•æˆåŠŸ")
  let japanese_log = LogRecord::new(Warn, "æ—¥æœ¬èªã®è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
  let korean_log = LogRecord::new(Error, "í•œêµ­ì–´ ì˜¤ë¥˜ ë©”ì‹œì§€")
  let arabic_log = LogRecord::new(Debug, "Ø±Ø³Ø§Ù„Ø© ØªØµØ­ÙŠØ­ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  let emoji_log = LogRecord::new(Info, "System status: ğŸŸ¢ All systems operational âœ…")
  let mixed_log = LogRecord::new(Error, "Mixed language error: ç”¨æˆ·é”™è¯¯ user error ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ©ãƒ¼")
  
  // Verify log records with Unicode characters
  assert_eq(LogRecord::body(chinese_log), Some("ç”¨æˆ·ç™»å½•æˆåŠŸ"))
  assert_eq(LogRecord::body(japanese_log), Some("æ—¥æœ¬èªã®è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"))
  assert_eq(LogRecord::body(korean_log), Some("í•œêµ­ì–´ ì˜¤ë¥˜ ë©”ì‹œì§€"))
  assert_eq(LogRecord::body(arabic_log), Some("Ø±Ø³Ø§Ù„Ø© ØªØµØ­ÙŠØ­ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq(LogRecord::body(emoji_log), Some("System status: ğŸŸ¢ All systems operational âœ…"))
  assert_eq(LogRecord::body(mixed_log), Some("Mixed language error: ç”¨æˆ·é”™è¯¯ user error ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ©ãƒ¼"))
}

test "right-to-left language support" {
  let attrs = Attributes::new()
  
  // Test with RTL languages
  let rtl_attrs = [
    ("arabic.service.name", StringValue("Ø®Ø¯Ù…Ø© Ø§Ù„ØªØªØ¨Ø¹")),
    ("hebrew.service.name", StringValue("×©×™×¨×•×ª ××¢×§×‘")),
    ("persian.service.name", StringValue("Ø®Ø¯Ù…Ù‡ Ø±Ø¯ÛŒØ§Ø¨ÛŒ")),
    ("urdu.service.name", StringValue("Ù¹Ø±ÛŒÚ©Ù†Ú¯ Ø³Ø±ÙˆØ³"))
  ]
  
  for (key, value) in rtl_attrs {
    Attributes::set(attrs, key, value)
  }
  
  // Test RTL log messages
  let arabic_log = LogRecord::new(Info, "Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­")
  let hebrew_log = LogRecord::new(Warn, "××–×”×¨×”: ×–×™×›×¨×•×Ÿ × ××•×š")
  let persian_log = LogRecord::new(Error, "Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡")
  
  // Verify RTL language support
  assert_eq(LogRecord::body(arabic_log), Some("Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­"))
  assert_eq(LogRecord::body(hebrew_log), Some("××–×”×¨×”: ×–×™×›×¨×•×Ÿ × ××•×š"))
  assert_eq(LogRecord::body(persian_log), Some("Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ù¾Ø§ÛŒÚ¯Ø§Ù‡ Ø¯Ø§Ø¯Ù‡"))
}

test "locale-specific date and time formatting" {
  let clock = Clock::system()
  let timestamp = Clock::now_unix_nanos(clock)
  
  // Simulate locale-specific date formatting
  let us_date = "01/15/2025 03:45:30 PM EST"
  let european_date = "15/01/2025 15:45:30 CET"
  let iso_date = "2025-01-15T20:45:30.000Z"
  let chinese_date = "2025å¹´1æœˆ15æ—¥ ä¸‹åˆ3:45:30"
  let japanese_date = "2025å¹´1æœˆ15æ—¥ 15:45:30"
  
  // Create log records with locale-specific timestamps
  let us_log = LogRecord::new_with_context(
    Info,
    Some("User action completed at " + us_date),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  let european_log = LogRecord::new_with_context(
    Info,
    Some("Benutzeraktion abgeschlossen um " + european_date),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  let chinese_log = LogRecord::new_with_context(
    Info,
    Some("ç”¨æˆ·æ“ä½œå®Œæˆäº" + chinese_date),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  // Verify locale-specific date formatting
  assert_eq(LogRecord::body(us_log), Some("User action completed at " + us_date))
  assert_eq(LogRecord::body(european_log), Some("Benutzeraktion abgeschlossen um " + european_date))
  assert_eq(LogRecord::body(chinese_log), Some("ç”¨æˆ·æ“ä½œå®Œæˆäº" + chinese_date))
}

test "currency and number formatting" {
  let attrs = Attributes::new()
  
  // Test with different currency and number formats
  let currency_attrs = [
    ("price.usd", StringValue("$1,234.56")),
    ("price.eur", StringValue("â‚¬1.234,56")),
    ("price.jpy", StringValue("Â¥1,235")),
    ("price.cny", StringValue("Â¥1,234.56")),
    ("price.inr", StringValue("â‚¹1,234.56")),
    ("price.krw", StringValue("â‚©1,235")),
    ("number.french", StringValue("1 234,567")),
    ("number.german", StringValue("1.234.567")),
    ("number.indian", StringValue("12,34,567"))
  ]
  
  for (key, value) in currency_attrs {
    Attributes::set(attrs, key, value)
  }
  
  // Test with metric values using different number formats
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization-meter")
  
  let us_counter = Meter::create_counter(meter, "revenue.usd")
  let eu_counter = Meter::create_counter(meter, "revenue.eur")
  let jp_counter = Meter::create_counter(meter, "revenue.jpy")
  
  Counter::add(us_counter, 1234.56)
  Counter::add(eu_counter, 1234.56)
  Counter::add(jp_counter, 1235.0)
  
  // Verify metric creation with different locales
  assert_eq(us_counter.name, "revenue.usd")
  assert_eq(eu_counter.name, "revenue.eur")
  assert_eq(jp_counter.name, "revenue.jpy")
}

test "multilingual error messages" {
  // Create error messages in different languages
  let error_messages = [
    ("en", "Database connection failed"),
    ("zh", "æ•°æ®åº“è¿æ¥å¤±è´¥"),
    ("ja", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ"),
    ("ko", "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨"),
    ("es", "Error de conexiÃ³n a la base de datos"),
    ("fr", "Ã‰chec de la connexion Ã  la base de donnÃ©es"),
    ("de", "Datenbankverbindung fehlgeschlagen"),
    ("ru", "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"),
    ("ar", "ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"),
    ("hi", "à¤¡à¥‡à¤Ÿà¤¾à¤¬à¥‡à¤¸ à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤µà¤¿à¤«à¤²")
  ]
  
  // Create log records with multilingual error messages
  let error_logs = Array.map(error_messages, fn(pair) {
    let locale = pair.0
    let message = pair.1
    LogRecord::new(Error, message + " [" + locale + "]")
  })
  
  // Verify multilingual error messages
  assert_eq(LogRecord::body(error_logs[0]), Some("Database connection failed [en]"))
  assert_eq(LogRecord::body(error_logs[1]), Some("æ•°æ®åº“è¿æ¥å¤±è´¥ [zh]"))
  assert_eq(LogRecord::body(error_logs[2]), Some("ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ [ja]"))
  assert_eq(LogRecord::body(error_logs[3]), Some("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨ [ko]"))
  assert_eq(LogRecord::body(error_logs[4]), Some("Error de conexiÃ³n a la base de datos [es]"))
  assert_eq(LogRecord::body(error_logs[5]), Some("Ã‰chec de la connexion Ã  la base de donnÃ©es [fr]"))
  assert_eq(LogRecord::body(error_logs[6]), Some("Datenbankverbindung fehlgeschlagen [de]"))
  assert_eq(LogRecord::body(error_logs[7]), Some("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… [ru]"))
  assert_eq(LogRecord::body(error_logs[8]), Some("ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª [ar]"))
  assert_eq(LogRecord::body(error_logs[9]), Some("à¤¡à¥‡à¤Ÿà¤¾à¤¬à¥‡à¤¸ à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤µà¤¿à¤«à¤² [hi]"))
}

test "timezone handling" {
  let clock = Clock::system()
  let timestamp = Clock::now_unix_nanos(clock)
  
  // Create log records with different timezone information
  let utc_log = LogRecord::new_with_context(
    Info,
    Some("Event occurred at 2025-01-15T20:45:30.000Z"),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  let est_log = LogRecord::new_with_context(
    Info,
    Some("Event occurred at 2025-01-15T15:45:30.000-05:00"),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  let pst_log = LogRecord::new_with_context(
    Info,
    Some("Event occurred at 2025-01-15T12:45:30.000-08:00"),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  let cet_log = LogRecord::new_with_context(
    Info,
    Some("Event occurred at 2025-01-15T21:45:30.000+01:00"),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  let jst_log = LogRecord::new_with_context(
    Info,
    Some("Event occurred at 2025-01-16T05:45:30.000+09:00"),
    None,
    Some(timestamp),
    Some(timestamp),
    None,
    None,
    None
  )
  
  // Verify timezone handling
  assert_eq(LogRecord::body(utc_log), Some("Event occurred at 2025-01-15T20:45:30.000Z"))
  assert_eq(LogRecord::body(est_log), Some("Event occurred at 2025-01-15T15:45:30.000-05:00"))
  assert_eq(LogRecord::body(pst_log), Some("Event occurred at 2025-01-15T12:45:30.000-08:00"))
  assert_eq(LogRecord::body(cet_log), Some("Event occurred at 2025-01-15T21:45:30.000+01:00"))
  assert_eq(LogRecord::body(jst_log), Some("Event occurred at 2025-01-16T05:45:30.000+09:00"))
}

test "multilingual service names and descriptions" {
  let provider = MeterProvider::default()
  
  // Create meters with multilingual names and descriptions
  let english_meter = MeterProvider::get_meter(provider, "web-service")
  let chinese_meter = MeterProvider::get_meter(provider, "ç½‘ç»œæœåŠ¡")
  let japanese_meter = MeterProvider::get_meter(provider, "ã‚¦ã‚§ãƒ–ã‚µãƒ¼ãƒ“ã‚¹")
  let spanish_meter = MeterProvider::get_meter(provider, "servicio-web")
  
  // Create metrics with multilingual descriptions
  let english_counter = Meter::create_counter(english_meter, "http.requests", Some("Total HTTP requests"), Some("count"))
  let chinese_counter = Meter::create_counter(chinese_meter, "http.è¯·æ±‚", Some("HTTPè¯·æ±‚æ€»æ•°"), Some("è®¡æ•°"))
  let japanese_counter = Meter::create_counter(japanese_meter, "http.ãƒªã‚¯ã‚¨ã‚¹ãƒˆ", Some("HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆç·æ•°"), Some("ã‚«ã‚¦ãƒ³ãƒˆ"))
  let spanish_counter = Meter::create_counter(spanish_meter, "http.solicitudes", Some("Total de solicitudes HTTP"), Some("cuenta"))
  
  // Verify multilingual metric creation
  assert_eq(english_counter.name, "http.requests")
  assert_eq(english_counter.description, Some("Total HTTP requests"))
  assert_eq(english_counter.unit, Some("count"))
  
  assert_eq(chinese_counter.name, "http.è¯·æ±‚")
  assert_eq(chinese_counter.description, Some("HTTPè¯·æ±‚æ€»æ•°"))
  assert_eq(chinese_counter.unit, Some("è®¡æ•°"))
  
  assert_eq(japanese_counter.name, "http.ãƒªã‚¯ã‚¨ã‚¹ãƒˆ")
  assert_eq(japanese_counter.description, Some("HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆç·æ•°"))
  assert_eq(japanese_counter.unit, Some("ã‚«ã‚¦ãƒ³ãƒˆ"))
  
  assert_eq(spanish_counter.name, "http.solicitudes")
  assert_eq(spanish_counter.description, Some("Total de solicitudes HTTP"))
  assert_eq(spanish_counter.unit, Some("cuenta"))
}

test "international character handling in HTTP headers" {
  // Create HTTP requests with international characters in headers
  let chinese_headers = [
    ("X-User-Name", "å¼ ä¸‰"),
    ("X-Service-Name", "ç”¨æˆ·æœåŠ¡"),
    ("User-Agent", "ä¸­æ–‡æµè§ˆå™¨/1.0")
  ]
  
  let japanese_headers = [
    ("X-User-Name", "ç”°ä¸­å¤ªéƒ"),
    ("X-Service-Name", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹"),
    ("User-Agent", "æ—¥æœ¬èªãƒ–ãƒ©ã‚¦ã‚¶/1.0")
  ]
  
  let arabic_headers = [
    ("X-User-Name", "Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"),
    ("X-Service-Name", "Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"),
    ("User-Agent", "Ù…ØªØµÙØ­ Ø¹Ø±Ø¨ÙŠ/1.0")
  ]
  
  let chinese_request = HttpRequest::new("GET", "https://api.example.com/users", chinese_headers)
  let japanese_request = HttpRequest::new("GET", "https://api.example.com/users", japanese_headers)
  let arabic_request = HttpRequest::new("GET", "https://api.example.com/users", arabic_headers)
  
  // Verify HTTP requests with international characters
  assert_eq(HttpRequest::http_method(chinese_request), "GET")
  assert_eq(HttpRequest::url(chinese_request), "https://api.example.com/users")
  
  assert_eq(HttpRequest::http_method(japanese_request), "GET")
  assert_eq(HttpRequest::url(japanese_request), "https://api.example.com/users")
  
  assert_eq(HttpRequest::http_method(arabic_request), "GET")
  assert_eq(HttpRequest::url(arabic_request), "https://api.example.com/users")
}

test "cultural formatting differences" {
  let attrs = Attributes::new()
  
  // Test with culturally different formatting
  let cultural_attrs = [
    ("address.us", StringValue("123 Main St, New York, NY 10001")),
    ("address.jp", StringValue("ã€’100-0001 æ±äº¬éƒ½åƒä»£ç”°åŒºåƒä»£ç”°1-1")),
    ("address.cn", StringValue("ä¸­å›½åŒ—äº¬å¸‚æœé˜³åŒºå»ºå›½é—¨å¤–å¤§è¡—1å·")),
    ("address.uk", StringValue("10 Downing Street, London SW1A 2AA")),
    ("phone.us", StringValue("+1 (555) 123-4567")),
    ("phone.uk", StringValue("+44 20 7946 0958")),
    ("phone.jp", StringValue("+81-3-1234-5678")),
    ("phone.cn", StringValue("+86 10 1234 5678")),
    ("name.western", StringValue("John Smith")),
    ("name.eastern", StringValue("å¼ ä¸‰ (ZhÄng SÄn)")),
    ("date.us", StringValue("01/15/2025")),
    ("date.uk", StringValue("15/01/2025")),
    ("date.iso", StringValue("2025-01-15"))
  ]
  
  for (key, value) in cultural_attrs {
    Attributes::set(attrs, key, value)
  }
  
  // Create logs with culturally different formatting
  let us_log = LogRecord::new(Info, "Customer John Smith from New York placed order #12345")
  let jp_log = LogRecord::new(Info, "ãŠå®¢æ§˜ç”°ä¸­å¤ªéƒãŒæ±äº¬éƒ½ã§æ³¨æ–‡#12345ã‚’é…ç½®ã—ã¾ã—ãŸ")
  let cn_log = LogRecord::new(Info, "åŒ—äº¬å®¢æˆ·å¼ ä¸‰ä¸‹äº†è®¢å•#12345")
  
  // Verify culturally different formatting
  assert_eq(LogRecord::body(us_log), Some("Customer John Smith from New York placed order #12345"))
  assert_eq(LogRecord::body(jp_log), Some("ãŠå®¢æ§˜ç”°ä¸­å¤ªéƒãŒæ±äº¬éƒ½ã§æ³¨æ–‡#12345ã‚’é…ç½®ã—ã¾ã—ãŸ"))
  assert_eq(LogRecord::body(cn_log), Some("åŒ—äº¬å®¢æˆ·å¼ ä¸‰ä¸‹äº†è®¢å•#12345"))
}