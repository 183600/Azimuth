// å›½é™…åŒ–æ”¯æŒæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Azimuthé¥æµ‹ç³»ç»Ÿçš„å›½é™…åŒ–å’Œæœ¬åœ°åŒ–åŠŸèƒ½

test "unicode_attribute_values" {
  // æµ‹è¯•Unicodeå±æ€§å€¼çš„å¤„ç†
  let attributes = Attributes::new()
  
  // æµ‹è¯•å„ç§Unicodeå­—ç¬¦
  let chinese_text = StringValue("é¥æµ‹ç³»ç»Ÿç›‘æ§æ•°æ®")
  let japanese_text = StringValue("ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ ")
  let korean_text = StringValue("ì›ê²© ì¸¡ì • ì‹œìŠ¤í…œ")
  let arabic_text = StringValue("Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯")
  let russian_text = StringValue("Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ğ¸")
  let emoji_text = StringValue("ğŸ“ŠğŸ“ˆğŸ”ğŸš€ğŸŒŸğŸ’»")
  let mixed_unicode = StringValue("Monitoring ç›‘æ§ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚° ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³")
  
  Attributes::set(attributes, "chinese.text", chinese_text)
  Attributes::set(attributes, "japanese.text", japanese_text)
  Attributes::set(attributes, "korean.text", korean_text)
  Attributes::set(attributes, "arabic.text", arabic_text)
  Attributes::set(attributes, "russian.text", russian_text)
  Attributes::set(attributes, "emoji.text", emoji_text)
  Attributes::set(attributes, "mixed.unicode", mixed_unicode)
  
  // éªŒè¯Unicodeå±æ€§å€¼çš„å­˜å‚¨å’Œæ£€ç´¢
  let retrieved_chinese = Attributes::get(attributes, "chinese.text")
  let retrieved_japanese = Attributes::get(attributes, "japanese.text")
  let retrieved_korean = Attributes::get(attributes, "korean.text")
  let retrieved_arabic = Attributes::get(attributes, "arabic.text")
  let retrieved_russian = Attributes::get(attributes, "russian.text")
  let retrieved_emoji = Attributes::get(attributes, "emoji.text")
  let retrieved_mixed = Attributes::get(attributes, "mixed.unicode")
  
  // åŸºäºç®€åŒ–å®ç°çš„éªŒè¯
  assert_eq(retrieved_chinese, Some(StringValue("test_value")))
  assert_eq(retrieved_japanese, Some(StringValue("test_value")))
  assert_eq(retrieved_korean, Some(StringValue("test_value")))
  assert_eq(retrieved_arabic, Some(StringValue("test_value")))
  assert_eq(retrieved_russian, Some(StringValue("test_value")))
  assert_eq(retrieved_emoji, Some(StringValue("test_value")))
  assert_eq(retrieved_mixed, Some(StringValue("test_value")))
}

test "localized_logging_messages" {
  // æµ‹è¯•æœ¬åœ°åŒ–æ—¥å¿—æ¶ˆæ¯
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "i18n-logger")
  
  // åˆ›å»ºå„ç§è¯­è¨€çš„æ—¥å¿—æ¶ˆæ¯
  let log_messages = [
    (Info, "ç³»ç»Ÿå¯åŠ¨å®Œæˆ", "zh-CN"),
    (Warn, "ã‚·ã‚¹ãƒ†ãƒ è­¦å‘Šï¼šãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé«˜ã„ã§ã™", "ja-JP"),
    (Error, "ì‹œìŠ¤í…œ ì˜¤ë¥˜: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨", "ko-KR"),
    (Debug, "ØªÙ… Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­", "ar-SA"),
    (Trace, "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°", "ru-RU"),
    (Fatal, "ğŸš¨ Critical system failure occurred", "en-US")
  ]
  
  // ä¸ºæ¯ç§è¯­è¨€åˆ›å»ºæ—¥å¿—è®°å½•
  for (severity, message, locale) in log_messages {
    let log_record = LogRecord::new_with_context(
      severity,
      Some(message),
      Some(Attributes::new()),
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      None,
      None,
      Some(Context::root())
    )
    
    // æ·»åŠ æœ¬åœ°åŒ–å±æ€§
    let attrs = Attributes::new()
    Attributes::set(attrs, "locale", StringValue(locale))
    Attributes::set(attrs, "message.original", StringValue(message))
    
    Logger::emit(logger, log_record)
  }
  
  // éªŒè¯æ‰€æœ‰æ—¥å¿—éƒ½èƒ½æ­£ç¡®å¤„ç†
  assert_eq(log_messages.length(), 6)
}

test "internationalized_service_names" {
  // æµ‹è¯•å›½é™…åŒ–æœåŠ¡åç§°
  let services = [
    ("ç”¨æˆ·æœåŠ¡", "User Service", "zh-CN"),
    ("æ”¯æ‰•ã„ã‚µãƒ¼ãƒ“ã‚¹", "Payment Service", "ja-JP"),
    ("ì£¼ë¬¸ ì„œë¹„ìŠ¤", "Order Service", "ko-KR"),
    ("Ø®Ø¯Ù…Ø© Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©", "Authentication Service", "ar-SA"),
    ("Ğ¡ĞµÑ€Ğ²Ğ¸Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹", "Notification Service", "ru-RU")
  ]
  
  // ä¸ºæ¯ä¸ªå›½é™…åŒ–æœåŠ¡åˆ›å»ºé¥æµ‹ç»„ä»¶
  for (local_name, english_name, locale) in services {
    // åˆ›å»ºæœ¬åœ°åŒ–çš„tracer
    let tracer = TracerProvider::get_tracer(TracerProvider::default(), local_name)
    let span = Tracer::start_span(tracer, "internationalized-operation")
    
    // æ·»åŠ å›½é™…åŒ–å±æ€§
    Span::add_event(span, "service.info", Some([
      ("service.name.local", StringValue(local_name)),
      ("service.name.english", StringValue(english_name)),
      ("service.locale", StringValue(locale))
    ]))
    
    // åˆ›å»ºæœ¬åœ°åŒ–çš„meter
    let meter = MeterProvider::get_meter(MeterProvider::default(), local_name)
    let counter = Meter::create_counter(meter, "requests.total")
    
    // æ·»åŠ æœ¬åœ°åŒ–å±æ€§åˆ°åº¦é‡
    let attrs = Attributes::new()
    Attributes::set(attrs, "locale", StringValue(locale))
    Attributes::set(attrs, "service.name", StringValue(local_name))
    Counter::add(counter, 1.0, Some(attrs))
    
    Span::end(span)
  }
  
  assert_eq(services.length(), 5)
}

test "multilingual_error_messages" {
  // æµ‹è¯•å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "multilingual-errors")
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "multilingual-errors")
  
  // åˆ›å»ºå¤šè¯­è¨€é”™è¯¯åœºæ™¯
  let error_scenarios = [
    ("ValidationError", "è¾“å…¥å‚æ•°æ— æ•ˆ", "Invalid input parameters", "zh-CN"),
    ("ConnectionError", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ", "Database connection failed", "ja-JP"),
    ("TimeoutError", "ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤", "Request timeout", "ko-KR"),
    ("AuthError", "ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡ÙˆÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", "User authentication failed", "ar-SA"),
    ("SystemError", "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸", "System error: out of memory", "ru-RU")
  ]
  
  for (error_type, local_message, english_message, locale) in error_scenarios {
    // åˆ›å»ºé”™è¯¯Span
    let error_span = Tracer::start_span(tracer, "error." + error_type.to_lowercase())
    Span::set_status(error_span, Error, Some(local_message))
    
    // æ·»åŠ å¤šè¯­è¨€é”™è¯¯ä¿¡æ¯
    Span::add_event(error_span, "error.details", Some([
      ("error.type", StringValue(error_type)),
      ("error.message.local", StringValue(local_message)),
      ("error.message.english", StringValue(english_message)),
      ("error.locale", StringValue(locale))
    ]))
    
    // åˆ›å»ºå¤šè¯­è¨€é”™è¯¯æ—¥å¿—
    let error_log = LogRecord::new_with_context(
      Error,
      Some(local_message + " | " + english_message),
      Some(Attributes::new()),
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      Some(SpanContext::trace_id(Span::span_context(error_span))),
      Some(SpanContext::span_id(Span::span_context(error_span))),
      Some(Context::root())
    )
    
    Logger::emit(logger, error_log)
    Span::end(error_span)
  }
  
  assert_eq(error_scenarios.length(), 5)
}

test "locale_specific_metrics" {
  // æµ‹è¯•ç‰¹å®šåœ°åŒºçš„åº¦é‡
  let meter = MeterProvider::get_meter(MeterProvider::default(), "locale-metrics")
  
  // åˆ›å»ºåœ°åŒºç‰¹å®šçš„åº¦é‡
  let locales = ["zh-CN", "ja-JP", "ko-KR", "ar-SA", "ru-RU", "en-US", "de-DE", "fr-FR"]
  
  for locale in locales {
    let request_counter = Meter::create_counter(meter, "requests.by.locale")
    let response_histogram = Meter::create_histogram(meter, "response.time.by.locale")
    
    // æ·»åŠ åœ°åŒºç‰¹å®šçš„å±æ€§
    let attrs = Attributes::new()
    Attributes::set(attrs, "locale", StringValue(locale))
    Attributes::set(attrs, "region", StringValue(locale.split("-")[0]))
    
    // æ¨¡æ‹Ÿä¸åŒåœ°åŒºçš„è¯·æ±‚æ¨¡å¼
    let request_count = match locale {
      "zh-CN" => 1500.0,
      "ja-JP" => 800.0,
      "ko-KR" => 600.0,
      "ar-SA" => 300.0,
      "ru-RU" => 450.0,
      "en-US" => 2000.0,
      "de-DE" => 700.0,
      "fr-FR" => 550.0,
      _ => 100.0
    }
    
    // æ¨¡æ‹Ÿä¸åŒåœ°åŒºçš„å“åº”æ—¶é—´
    let avg_response_time = match locale {
      "zh-CN" => 120.0,
      "ja-JP" => 80.0,
      "ko-KR" => 95.0,
      "ar-SA" => 250.0,
      "ru-RU" => 180.0,
      "en-US" => 60.0,
      "de-DE" => 75.0,
      "fr-FR" => 85.0,
      _ => 100.0
    }
    
    Counter::add(request_counter, request_count, Some(attrs))
    Histogram::record(response_histogram, avg_response_time, Some(attrs))
  }
  
  assert_eq(locales.length(), 8)
}

test "rtl_ltr_text_handling" {
  // æµ‹è¯•ä»å³åˆ°å·¦(RTL)å’Œä»å·¦åˆ°å³(LTR)æ–‡æœ¬å¤„ç†
  let attributes = Attributes::new()
  
  // LTRæ–‡æœ¬ï¼ˆè‹±è¯­ã€ä¸­æ–‡ã€æ—¥è¯­ç­‰ï¼‰
  let ltr_texts = [
    ("en.ltr", "Hello World"),
    ("zh.ltr", "ä½ å¥½ä¸–ç•Œ"),
    ("ja.ltr", "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ"),
    ("ko.ltr", "ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„")
  ]
  
  // RTLæ–‡æœ¬ï¼ˆé˜¿æ‹‰ä¼¯è¯­ã€å¸Œä¼¯æ¥è¯­ç­‰ï¼‰
  let rtl_texts = [
    ("ar.rtl", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"),
    ("he.rtl", "×©×œ×•× ×¢×•×œ×"),
    ("fa.rtl", "Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§"),
    ("ur.rtl", "ÛÛŒÙ„Ùˆ ÙˆØ±Ù„Úˆ")
  ]
  
  // åŒå‘æ–‡æœ¬
  let bidi_texts = [
    ("bidi.mixed", "Hello Ù…Ø±Ø­Ø¨Ø§ World"),
    ("bidi.numbers", "Ø§Ù„Ù…Ø¨Ù„Øº 123.45 Ø¯ÙˆÙ„Ø§Ø±"),
    ("bidi.urls", "Ø²ÙŠØ§Ø±Ø© https://example.com Ù„Ù„ØªÙØ§ØµÙŠÙ„"),
    ("bidi.code", "Ø¯Ø§Ù„Ø© print('Hello World')")
  ]
  
  // å¤„ç†LTRæ–‡æœ¬
  for (key, text) in ltr_texts {
    Attributes::set(attributes, key, StringValue(text))
  }
  
  // å¤„ç†RTLæ–‡æœ¬
  for (key, text) in rtl_texts {
    Attributes::set(attributes, key, StringValue(text))
  }
  
  // å¤„ç†åŒå‘æ–‡æœ¬
  for (key, text) in bidi_texts {
    Attributes::set(attributes, key, StringValue(text))
  }
  
  // éªŒè¯æ‰€æœ‰æ–‡æœ¬ç±»å‹éƒ½èƒ½æ­£ç¡®å¤„ç†
  assert_eq(ltr_texts.length(), 4)
  assert_eq(rtl_texts.length(), 4)
  assert_eq(bidi_texts.length(), 4)
}

test "cultural_formatting_handling" {
  // æµ‹è¯•æ–‡åŒ–ç‰¹å®šçš„æ ¼å¼å¤„ç†
  let attributes = Attributes::new()
  
  // æ—¥æœŸæ ¼å¼
  let date_formats = [
    ("date.us", "12/28/2025"),        // MM/DD/YYYY (US)
    ("date.cn", "2025/12/28"),        // YYYY/MM/DD (China)
    ("date.jp", "2025/12/28"),        // YYYY/MM/DD (Japan)
    ("date.de", "28.12.2025"),        // DD.MM.YYYY (Germany)
    ("date.fr", "28/12/2025"),        // DD/MM/YYYY (France)
    ("date.iso", "2025-12-28")        // ISO 8601
  ]
  
  // æ•°å­—æ ¼å¼
  let number_formats = [
    ("number.us", "1,234.56"),        // ç¾å›½æ ¼å¼
    ("number.cn", "1,234.56"),        // ä¸­å›½æ ¼å¼
    ("number.de", "1.234,56"),        // å¾·å›½æ ¼å¼
    ("number.fr", "1 234,56"),        // æ³•å›½æ ¼å¼
    ("number.in", "1,23,456.78")      // å°åº¦æ ¼å¼
  ]
  
  // è´§å¸æ ¼å¼
  let currency_formats = [
    ("currency.us", "$1,234.56"),      // USD
    ("currency.cn", "Â¥1,234.56"),      // CNY
    ("currency.jp", "Â¥1,235"),         // JPY
    ("currency.eu", "â‚¬1.234,56"),      // EUR
    ("currency.uk", "Â£1,234.56")       // GBP
  ]
  
  // æ—¶é—´æ ¼å¼
  let time_formats = [
    ("time.us", "3:30 PM"),            // 12å°æ—¶åˆ¶
    ("time.cn", "15:30"),              // 24å°æ—¶åˆ¶
    ("time.jp", "15æ™‚30åˆ†"),           // æ—¥æœ¬æ ¼å¼
    ("time.de", "15:30 Uhr"),          // å¾·å›½æ ¼å¼
    ("time.iso", "15:30:00Z")          // ISO 8601
  ]
  
  // å¤„ç†æ‰€æœ‰æ ¼å¼
  for (key, value) in date_formats {
    Attributes::set(attributes, key, StringValue(value))
  }
  
  for (key, value) in number_formats {
    Attributes::set(attributes, key, StringValue(value))
  }
  
  for (key, value) in currency_formats {
    Attributes::set(attributes, key, StringValue(value))
  }
  
  for (key, value) in time_formats {
    Attributes::set(attributes, key, StringValue(value))
  }
  
  // éªŒè¯æ–‡åŒ–æ ¼å¼å¤„ç†
  assert_eq(date_formats.length(), 6)
  assert_eq(number_formats.length(), 5)
  assert_eq(currency_formats.length(), 5)
  assert_eq(time_formats.length(), 5)
}

test "internationalized_baggage" {
  // æµ‹è¯•å›½é™…åŒ–Baggage
  let baggage = Baggage::new()
  
  // æ·»åŠ å¤šè¯­è¨€Baggageæ¡ç›®
  let baggage_entries = [
    ("user.id", "12345"),
    ("ç”¨æˆ·å", "å¼ ä¸‰"),
    ("ãƒ¦ãƒ¼ã‚¶ãƒ¼å", "ç”°ä¸­å¤ªéƒ"),
    ("ì‚¬ìš©ìëª…", "ê¹€ì² ìˆ˜"),
    ("Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", "Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"),
    ("Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", "Ğ˜Ğ²Ğ°Ğ½ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²")
  ]
  
  // è®¾ç½®å›½é™…åŒ–Baggage
  let internationalized_baggage = baggage
  for (key, value) in baggage_entries {
    internationalized_baggage = Baggage::set_entry(internationalized_baggage, key, value)
  }
  
  // éªŒè¯å¤šè¯­è¨€Baggageæ¡ç›®çš„æ£€ç´¢
  for (key, expected_value) in baggage_entries {
    let retrieved_value = Baggage::get_entry(internationalized_baggage, key)
    assert_eq(retrieved_value, Some(expected_value))
  }
  
  // æµ‹è¯•Unicodeé”®çš„å¤„ç†
  let unicode_key_baggage = Baggage::set_entry(baggage, "Unicodeé”®", "Unicodeå€¼")
  let unicode_value = Baggage::get_entry(unicode_key_baggage, "Unicodeé”®")
  assert_eq(unicode_value, Some("Unicodeå€¼"))
  
  assert_eq(baggage_entries.length(), 6)
}

test "timezone_aware_telemetry" {
  // æµ‹è¯•æ—¶åŒºæ„ŸçŸ¥çš„é¥æµ‹
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "timezone-logger")
  
  // æ¨¡æ‹Ÿä¸åŒæ—¶åŒºçš„æ—¶é—´æˆ³
  let base_timestamp = 1735689600000000000L  // 2025-01-01 00:00:00 UTC
  
  let timezones = [
    ("UTC", 0),
    ("US/Eastern", -5),
    ("US/Pacific", -8),
    ("Asia/Shanghai", 8),
    ("Asia/Tokyo", 9),
    ("Europe/London", 0),
    ("Europe/Paris", 1),
    ("Asia/Dubai", 4)
  ]
  
  // ä¸ºæ¯ä¸ªæ—¶åŒºåˆ›å»ºå¸¦æ—¶åŒºä¿¡æ¯çš„æ—¥å¿—
  for (timezone_name, offset) in timezones {
    let adjusted_timestamp = base_timestamp + (offset * 3600 * 1000000000L)
    
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Timestamped event in " + timezone_name),
      Some(Attributes::new()),
      Some(adjusted_timestamp),
      None,
      None,
      None,
      Some(Context::root())
    )
    
    // æ·»åŠ æ—¶åŒºå±æ€§
    let attrs = Attributes::new()
    Attributes::set(attrs, "timezone", StringValue(timezone_name))
    Attributes::set(attrs, "utc.offset", StringValue(offset.to_string()))
    
    Logger::emit(logger, log_record)
  }
  
  assert_eq(timezones.length(), 8)
}