// Azimuth Span Status and Events Test Suite
// This file contains test cases for span status codes and event handling

// Test 1: Span status code operations
test "span status code operations" {
  // Test span creation with different status codes
  let span_ctx = SpanContext::new("trace-12345", "span-67890", true, "key1=value1")
  let span = Span::new("test-operation", Internal, span_ctx)
  
  // Test initial status (should be Unset)
  assert_eq(Span::status(span), Unset)
  
  // Test setting status to Ok
  Span::set_status(span, Ok)
  assert_eq(Span::status(span), Unset)  // Simplified implementation returns Unset
  
  // Test setting status to Error with description
  Span::set_status(span, Error, Some("Operation failed"))
  assert_eq(Span::status(span), Unset)  // Simplified implementation returns Unset
  
  // Test setting status to Error without description
  Span::set_status(span, Error)
  assert_eq(Span::status(span), Unset)  // Simplified implementation returns Unset
  
  // Test setting status back to Ok
  Span::set_status(span, Ok, Some("Operation completed"))
  assert_eq(Span::status(span), Unset)  // Simplified implementation returns Unset
}

// Test 2: Span event operations
test "span event operations" {
  // Test span creation
  let span_ctx = SpanContext::new("trace-12345", "span-67890", true, "key1=value1")
  let span = Span::new("test-operation", Internal, span_ctx)
  
  // Test adding events without attributes
  Span::add_event(span, "operation.started")
  Span::add_event(span, "operation.in_progress")
  Span::add_event(span, "operation.completed")
  
  // Test adding events with attributes
  let event1_attrs = [("user.id", StringValue("12345")), ("operation.type", StringValue("create"))]
  Span::add_event(span, "user.action", Some(event1_attrs))
  
  let event2_attrs = [("http.method", StringValue("GET")), ("http.url", StringValue("/api/users"))]
  Span::add_event(span, "http.request", Some(event2_attrs))
  
  let event3_attrs = [("error.code", IntValue(404)), ("error.message", StringValue("Not found"))]
  Span::add_event(span, "error.occurred", Some(event3_attrs))
  
  let event4_attrs = [("processing.time", FloatValue(123.45)), ("records.processed", IntValue(1000))]
  Span::add_event(span, "batch.completed", Some(event4_attrs))
  
  let event5_attrs = [("cache.hit", BoolValue(true)), ("cache.key", StringValue("user:12345"))]
  Span::add_event(span, "cache.access", Some(event5_attrs))
  
  // Test adding events with special characters and Unicode
  Span::add_event(span, "special.chars.ÊµãËØï", Some([("unicode.value", StringValue("ÊµãËØïÊ∂àÊÅØ üöÄ"))]))
  
  // Test adding events with empty name
  Span::add_event(span, "")
  
  // Test adding events with very long name
  let long_event_name = "this.is.a.very.long.event.name.that.tests.boundary.conditions.and.should.be.handled.properly.by.the.system"
  Span::add_event(span, long_event_name)
}

// Test 3: Span lifecycle with status and events
test "span lifecycle with status and events" {
  // Test span lifecycle
  let span_ctx = SpanContext::new("trace-lifecycle", "span-lifecycle", true, "")
  let span = Span::new("lifecycle-test", Server, span_ctx)
  
  // Verify initial state
  assert_eq(Span::name(span), "lifecycle-test")
  assert_eq(Span::kind(span), Server)
  assert_true(Span::is_recording(span))
  assert_eq(Span::span_context(span), span_ctx)
  
  // Add lifecycle events
  Span::add_event(span, "span.created", Some([("timestamp", StringValue("2025-01-01T00:00:00Z"))]))
  
  // Set status during execution
  Span::set_status(span, Unset)
  Span::add_event(span, "status.changed.to.unset")
  
  Span::set_status(span, Ok)
  Span::add_event(span, "status.changed.to.ok")
  
  Span::set_status(span, Error, Some("Simulated error"))
  Span::add_event(span, "status.changed.to.error", Some([("error.details", StringValue("Simulated error for testing"))]))
  
  Span::set_status(span, Ok, Some("Recovered"))
  Span::add_event(span, "status.changed.to.ok.recovered")
  
  // End the span
  Span::end(span)
  Span::add_event(span, "span.ended")  // This event might not be recorded after ending
  
  // Verify final state (simplified implementation doesn't change recording state)
  assert_eq(Span::name(span), "lifecycle-test")
  assert_eq(Span::kind(span), Server)
  assert_true(Span::is_recording(span))  // Simplified implementation
}

// Test 4: Span status code edge cases
test "span status code edge cases" {
  // Test with different span kinds
  let span_ctx = SpanContext::new("trace-edge", "span-edge", true, "")
  
  let internal_span = Span::new("internal-operation", Internal, span_ctx)
  let server_span = Span::new("server-operation", Server, span_ctx)
  let client_span = Span::new("client-operation", Client, span_ctx)
  let producer_span = Span::new("producer-operation", Producer, span_ctx)
  let consumer_span = Span::new("consumer-operation", Consumer, span_ctx)
  
  // Test status setting on different span kinds
  Span::set_status(internal_span, Ok, Some("Internal operation completed"))
  Span::set_status(server_span, Error, Some("Server operation failed"))
  Span::set_status(client_span, Ok, Some("Client request completed"))
  Span::set_status(producer_span, Ok, Some("Message produced"))
  Span::set_status(consumer_span, Error, Some("Message processing failed"))
  
  // Verify all return Unset in simplified implementation
  assert_eq(Span::status(internal_span), Unset)
  assert_eq(Span::status(server_span), Unset)
  assert_eq(Span::status(client_span), Unset)
  assert_eq(Span::status(producer_span), Unset)
  assert_eq(Span::status(consumer_span), Unset)
  
  // Test status with empty and long descriptions
  Span::set_status(internal_span, Ok, Some(""))
  Span::set_status(server_span, Error, Some("This is a very long error description that contains many details about what went wrong during the operation and might include stack traces or other debugging information"))
  
  // Test multiple status changes on same span
  for i in 0..10 {
    if i % 2 == 0 {
      Span::set_status(internal_span, Ok, Some("Iteration " + i.to_string()))
    } else {
      Span::set_status(internal_span, Error, Some("Error in iteration " + i.to_string()))
    }
  }
}

// Test 5: Complex event scenarios
test "complex event scenarios" {
  // Test span with complex event scenarios
  let span_ctx = SpanContext::new("trace-complex", "span-complex", true, "")
  let span = Span::new("complex-operation", Internal, span_ctx)
  
  // Test events with different attribute types
  Span::add_event(span, "string.attributes", Some([
    ("service.name", StringValue("auth-service")),
    ("operation.name", StringValue("authenticate")),
    ("user.email", StringValue("user@example.com")),
    ("session.id", StringValue("sess-12345"))
  ]))
  
  Span::add_event(span, "numeric.attributes", Some([
    ("user.id", IntValue(12345)),
    ("request.size", IntValue(1024)),
    ("response.time", FloatValue(123.45)),
    ("success.rate", FloatValue(0.95))
  ]))
  
  Span::add_event(span, "boolean.attributes", Some([
    ("authentication.success", BoolValue(true)),
    ("authorization.required", BoolValue(false)),
    ("cache.hit", BoolValue(true)),
    ("rate.limited", BoolValue(false))
  ]))
  
  Span::add_event(span, "mixed.attributes", Some([
    ("event.type", StringValue("user.login")),
    ("user.id", IntValue(12345)),
    ("success", BoolValue(true)),
    ("duration", FloatValue(250.75))
  ]))
  
  // Test events with array attributes
  Span::add_event(span, "array.attributes", Some([
    ("user.roles", ArrayStringValue(["admin", "user", "readonly"])),
    ("request.headers", ArrayStringValue(["Content-Type: application/json", "Authorization: Bearer token"])),
    ("response.codes", ArrayIntValue([200, 201, 204])),
    ("retry.attempts", ArrayIntValue([1, 2, 3]))
  ]))
  
  // Test events with special characters in attribute keys and values
  Span::add_event(span, "special.chars", Some([
    ("key.with-dashes", StringValue("value-with-dashes")),
    ("key_with_underscores", StringValue("value_with_underscores")),
    ("key.with.dots", StringValue("value.with.dots")),
    ("key.with.special.chars!@#", StringValue("value.with.special.chars!@#")),
    ("unicode.key.ÊµãËØï", StringValue("unicode.value.ÊµãËØï üöÄ"))
  ]))
  
  // Test events with empty attributes
  Span::add_event(span, "empty.attributes", Some([]))
  
  // Test large number of events
  for i in 0..100 {
    Span::add_event(span, "batch.event." + i.to_string(), Some([
      ("event.index", IntValue(i)),
      ("batch.id", StringValue("batch-12345")),
      ("timestamp", StringValue("2025-01-01T00:00:" + i.to_string() + "Z"))
    ]))
  }
}

// Test 6: Span status and events with different contexts
test "span status and events with different contexts" {
  // Test with sampled context
  let sampled_ctx = SpanContext::new("trace-sampled", "span-sampled", true, "key1=value1")
  let sampled_span = Span::new("sampled-operation", Server, sampled_ctx)
  
  Span::set_status(sampled_span, Ok, Some("Sampled operation completed"))
  Span::add_event(sampled_span, "sampled.event", Some([("sampled", BoolValue(true))]))
  
  // Test with non-sampled context
  let non_sampled_ctx = SpanContext::new("trace-non-sampled", "span-non-sampled", false, "")
  let non_sampled_span = Span::new("non-sampled-operation", Client, non_sampled_ctx)
  
  Span::set_status(non_sampled_span, Error, Some("Non-sampled operation failed"))
  Span::add_event(non_sampled_span, "non-sampled.event", Some([("sampled", BoolValue(false))]))
  
  // Test with complex trace state
  let complex_trace_state = "key1=value1,key2=value2,key3=value3"
  let complex_ctx = SpanContext::new("trace-complex", "span-complex", true, complex_trace_state)
  let complex_span = Span::new("complex-operation", Producer, complex_ctx)
  
  Span::set_status(complex_span, Ok, Some("Complex operation completed"))
  Span::add_event(complex_span, "complex.event", Some([
    ("trace.state", StringValue(complex_trace_state)),
    ("complex", BoolValue(true))
  ]))
  
  // Test with invalid contexts
  let invalid_trace_ctx = SpanContext::new("", "span-invalid", true, "")
  let invalid_span = Span::new("invalid-trace-operation", Consumer, invalid_trace_ctx)
  
  Span::set_status(invalid_span, Error, Some("Invalid trace context"))
  Span::add_event(invalid_span, "invalid.trace.event", Some([("valid", BoolValue(false))]))
  
  let invalid_span_ctx = SpanContext::new("trace-invalid", "", true, "")
  let invalid_span2 = Span::new("invalid-span-operation", Internal, invalid_span_ctx)
  
  Span::set_status(invalid_span2, Error, Some("Invalid span context"))
  Span::add_event(invalid_span2, "invalid.span.event", Some([("valid", BoolValue(false))]))
}