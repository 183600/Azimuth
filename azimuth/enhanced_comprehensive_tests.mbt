// å¢å¼ºç»¼åˆæµ‹è¯•ç”¨ä¾‹ - ä¸º Azimuth é¡¹ç›®æ·»åŠ çš„é«˜è´¨é‡æµ‹è¯•
// åŒ…å«10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹

test "precision_arithmetic_operations" {
  // ç²¾åº¦ç®—æœ¯è¿ç®—æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„ç²¾åº¦ä¿æŒ
  let large_num1 = 1000000
  let large_num2 = 999999
  let sum_result = add(large_num1, large_num2)
  let diff_result = subtract(large_num1, large_num2)
  let product_result = multiply(large_num1, 1)
  
  assert_eq(1999999, sum_result)
  assert_eq(1, diff_result)
  assert_eq(1000000, product_result)
  
  // æµ‹è¯•é™¤æ³•çš„ç²¾åº¦è¾¹ç•Œ
  assert_eq(500000, divide_with_ceil(1000000, 2))
  assert_eq(333334, divide_with_ceil(1000000, 3))
  assert_eq(250001, divide_with_ceil(1000000, 4))
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’Œè¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, empty!", greet(""))
  assert_eq_string("Hello, space !", greet(" "))
  assert_eq_string("Hello, multiple   spaces!", greet("multiple   spaces"))
  assert_eq_string("Hello, tab	char!", greet("tab	char"))
  assert_eq_string("Hello, newline
!", greet("newline
"))
  assert_eq_string("Hello, quote\"!", greet("quote\""))
  assert_eq_string("Hello, apostrophe'!", greet("apostrophe'"))
  assert_eq_string("Hello, back\\slash!", greet("back\\slash"))
  assert_eq_string("Hello, emojiğŸ˜Š!", greet("emojiğŸ˜Š"))
  assert_eq_string("Hello, mathÏ€!", greet("mathÏ€"))
}

test "business_inventory_management" {
  // ä¸šåŠ¡åº“å­˜ç®¡ç†æµ‹è¯•
  // æ¨¡æ‹Ÿä»“åº“ç®¡ç†ç³»ç»Ÿçš„å¤æ‚è®¡ç®—
  
  // äº§å“Aï¼šåº“å­˜245ä»¶ï¼Œæ¯ç®±è£…12ä»¶
  let product_a_stock = 245
  let product_a_capacity = 12
  let boxes_a = divide_with_ceil(product_a_stock, product_a_capacity)
  
  // äº§å“Bï¼šåº“å­˜487ä»¶ï¼Œæ¯ç®±è£…18ä»¶
  let product_b_stock = 487
  let product_b_capacity = 18
  let boxes_b = divide_with_ceil(product_b_stock, product_b_capacity)
  
  // äº§å“Cï¼šåº“å­˜123ä»¶ï¼Œæ¯ç®±è£…8ä»¶
  let product_c_stock = 123
  let product_c_capacity = 8
  let boxes_c = divide_with_ceil(product_c_stock, product_c_capacity)
  
  // è®¡ç®—æ€»ç®±æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  let total_capacity = add(
    multiply(boxes_a, product_a_capacity),
    add(multiply(boxes_b, product_b_capacity), multiply(boxes_c, product_c_capacity))
  )
  
  assert_eq(21, boxes_a)  // ceil(245/12)
  assert_eq(28, boxes_b)  // ceil(487/18)
  assert_eq(16, boxes_c)  // ceil(123/8)
  assert_eq(65, total_boxes)
  assert_eq(744, total_capacity)
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—
  
  // ç­‰å·®æ•°åˆ—ï¼š1, 4, 7, 10, 13 (å…¬å·®ä¸º3)
  let arithmetic_diff = 3
  let arithmetic_term1 = 1
  let arithmetic_term2 = add(arithmetic_term1, arithmetic_diff)
  let arithmetic_term3 = add(arithmetic_term2, arithmetic_diff)
  let arithmetic_term4 = add(arithmetic_term3, arithmetic_diff)
  let arithmetic_term5 = add(arithmetic_term4, arithmetic_diff)
  
  let arithmetic_sum = add(add(add(add(arithmetic_term1, arithmetic_term2), arithmetic_term3), arithmetic_term4), arithmetic_term5)
  
  // ç­‰æ¯”æ•°åˆ—ï¼š2, 6, 18, 54 (å…¬æ¯”ä¸º3)
  let geometric_ratio = 3
  let geometric_term1 = 2
  let geometric_term2 = multiply(geometric_term1, geometric_ratio)
  let geometric_term3 = multiply(geometric_term2, geometric_ratio)
  let geometric_term4 = multiply(geometric_term3, geometric_ratio)
  
  let geometric_sum = add(add(add(geometric_term1, geometric_term2), geometric_term3), geometric_term4)
  
  assert_eq(35, arithmetic_sum)  // 1+4+7+10+13 = 35
  assert_eq(80, geometric_sum)   // 2+6+18+54 = 80
}

test "resource_optimization_complex" {
  // å¤æ‚èµ„æºä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šå¤šé¡¹ç›®èµ„æºåˆ†é…ä¼˜åŒ–
  
  let total_budget = 50000
  let project_a_priority = 3
  let project_b_priority = 2
  let project_c_priority = 1
  let total_priority = add(add(project_a_priority, project_b_priority), project_c_priority)
  
  // æŒ‰ä¼˜å…ˆçº§æ¯”ä¾‹åˆ†é…èµ„æº
  let base_unit = divide_with_ceil(total_budget, total_priority)
  let project_a_budget = multiply(project_a_priority, base_unit)
  let project_b_budget = multiply(project_b_priority, base_unit)
  let project_c_budget = multiply(project_c_priority, base_unit)
  
  // éªŒè¯åˆ†é…ç»“æœ
  assert_eq(4, base_unit)  // ceil(50000/6)
  assert_eq(12, project_a_budget)
  assert_eq(8, project_b_budget)
  assert_eq(4, project_c_budget)
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = add(add(project_a_budget, project_b_budget), project_c_budget)
  assert_eq(24, total_allocated)
  assert_true(total_allocated <= total_budget)
}

test "error_recovery_scenarios" {
  // é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // æµ‹è¯•å„ç§é”™è¯¯æƒ…å†µä¸‹çš„ç³»ç»Ÿæ¢å¤èƒ½åŠ›
  
  // è¿ç»­é™¤é›¶é”™è¯¯å¤„ç†
  let result1 = divide_with_ceil(10, 0)
  let result2 = divide_with_ceil(0, 0)
  let result3 = divide_with_ceil(-10, 0)
  
  assert_eq(0, result1)
  assert_eq(0, result2)
  assert_eq(0, result3)
  
  // é”™è¯¯åçš„æ­£å¸¸æ“ä½œéªŒè¯
  let normal_result1 = add(result1, 5)  // 0 + 5 = 5
  let normal_result2 = multiply(result2, 10)  // 0 * 10 = 0
  let normal_result3 = divide_with_ceil(20, 4)  // ceil(20/4) = 5
  
  assert_eq(5, normal_result1)
  assert_eq(0, normal_result2)
  assert_eq(5, normal_result3)
}

test "performance_benchmark_operations" {
  // æ€§èƒ½åŸºå‡†æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ€§èƒ½æµ‹è¯•åœºæ™¯
  
  let base_value = 1000
  let iterations = 100
  
  // è¿ç»­åŠ æ³•æ“ä½œ
  let add_result = add(base_value, iterations)
  
  // è¿ç»­ä¹˜æ³•æ“ä½œ
  let multiply_result = multiply(divide_with_ceil(base_value, 10), 15)
  
  // æ··åˆæ“ä½œ
  let mixed_result = divide_with_ceil(
    multiply(add(base_value, 50), 2),
    subtract(iterations, 50)
  )
  
  assert_eq(1100, add_result)
  assert_eq(1500, multiply_result)
  assert_eq(42, mixed_result)  // ceil((1000+50)*2/50) = ceil(2100/50) = 42
}

test "data_validation_comprehensive" {
  // ç»¼åˆæ•°æ®éªŒè¯æµ‹è¯•
  // æµ‹è¯•å„ç§æ•°æ®éªŒè¯åœºæ™¯
  
  // è¾¹ç•Œå€¼éªŒè¯
  let boundary_tests = [
    ("zero", 0),
    ("positive_small", 1),
    ("positive_medium", 100),
    ("positive_large", 1000000),
    ("negative_small", -1),
    ("negative_medium", -100),
    ("negative_large", -1000000)
  ]
  
  // éªŒè¯æ¯ä¸ªè¾¹ç•Œå€¼çš„è¿ç®—ç»“æœ
  assert_eq(0, add(0, 0))
  assert_eq(1, add(0, 1))
  assert_eq(100, add(0, 100))
  assert_eq(1000000, add(0, 1000000))
  assert_eq(-1, add(0, -1))
  assert_eq(-100, add(0, -100))
  assert_eq(-1000000, add(0, -1000000))
  
  // éªŒè¯ä¹˜æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, multiply(0, 1000000))
  assert_eq(1000000, multiply(1, 1000000))
  assert_eq(-1000000, multiply(-1, 1000000))
  assert_eq(1000000000000, multiply(1000000, 1000000))
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•çš„å¤æ‚åº¦ç‰¹å¾
  
  let input_sizes = [10, 100, 1000]
  
  // O(1) å¸¸æ•°æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let constant_time_10 = 5
  let constant_time_100 = 5
  let constant_time_1000 = 5
  
  // O(n) çº¿æ€§æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let linear_time_10 = multiply(10, 2)
  let linear_time_100 = multiply(100, 2)
  let linear_time_1000 = multiply(1000, 2)
  
  // O(log n) å¯¹æ•°æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let log_time_10 = divide_with_ceil(10, 3)
  let log_time_100 = divide_with_ceil(100, 3)
  let log_time_1000 = divide_with_ceil(1000, 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time_10)
  assert_eq(5, constant_time_100)
  assert_eq(5, constant_time_1000)
  
  assert_eq(20, linear_time_10)
  assert_eq(200, linear_time_100)
  assert_eq(2000, linear_time_1000)
  
  assert_eq(4, log_time_10)
  assert_eq(34, log_time_100)
  assert_eq(334, log_time_1000)
}

test "real_world_financial_calculations" {
  // çœŸå®ä¸–ç•Œé‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè´·æ¬¾è®¡ç®—å’ŒæŠ•èµ„å›æŠ¥åˆ†æ
  
  // è´·æ¬¾è®¡ç®—
  let loan_amount = 200000
  let interest_rate = 6  // 6% å¹´åˆ©ç‡
  let loan_years = 30
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—ï¼ˆä¸è€ƒè™‘å¤åˆ©ï¼‰
  let total_months = multiply(loan_years, 12)
  let total_interest = divide_with_ceil(multiply(loan_amount, multiply(interest_rate, loan_years)), 100)
  let total_payment = add(loan_amount, total_interest)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  
  // æŠ•èµ„å›æŠ¥è®¡ç®—
  let investment_amount = 50000
  let annual_return = 8  // 8% å¹´å›æŠ¥ç‡
  let investment_years = 10
  
  let total_return = divide_with_ceil(multiply(investment_amount, multiply(annual_return, investment_years)), 100)
  let final_value = add(investment_amount, total_return)
  
  // éªŒè¯è®¡ç®—ç»“æœ
  assert_eq(360, total_months)
  assert_eq(360000, total_interest)  // 200000 * 6% * 30
  assert_eq(560000, total_payment)
  assert_eq(1556, monthly_payment)  // ceil(560000/360)
  
  assert_eq(40000, total_return)  // 50000 * 8% * 10
  assert_eq(90000, final_value)
}