// Azimuth Telemetry System - Enhanced Test Suite
// Advanced test cases for comprehensive telemetry functionality

test "InstrumentationScopeå®Œæ•´åŠŸèƒ½æµ‹è¯•" {
  // æµ‹è¯•åŸºæœ¬çš„InstrumentationScopeåˆ›å»º
  let basic_scope = InstrumentationScope::{ 
    name: "test.instrument", 
    version: None, 
    schema_url: None 
  }
  assert_eq(basic_scope.name, "test.instrument")
  assert_true(basic_scope.version is None)
  assert_true(basic_scope.schema_url is None)
  
  // æµ‹è¯•å¸¦æœ‰ç‰ˆæœ¬å’Œschemaçš„InstrumentationScope
  let full_scope = InstrumentationScope::{ 
    name: "comprehensive.instrument", 
    version: Some("1.2.3"), 
    schema_url: Some("https://example.com/schema/v1") 
  }
  assert_eq(full_scope.name, "comprehensive.instrument")
  match full_scope.version {
    Some(version) => assert_eq(version, "1.2.3")
    None => assert_true(false)
  }
  match full_scope.schema_url {
    Some(schema) => assert_eq(schema, "https://example.com/schema/v1")
    None => assert_true(false)
  }
  
  // æµ‹è¯•åœ¨Tracerä¸­ä½¿ç”¨InstrumentationScope
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "scoped.tracer", Some("2.0.0"))
  let scope = Tracer::instrumentation_scope(tracer)
  assert_eq(scope.name, "scoped.tracer")
  match scope.version {
    Some(version) => assert_eq(version, "2.0.0")
    None => assert_true(false)
  }
  
  // æµ‹è¯•åœ¨Loggerä¸­ä½¿ç”¨InstrumentationScope
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "scoped.logger", Some("3.1.4"), Some("https://example.com/logger-schema"))
  let logger_scope = logger.scope
  assert_eq(logger_scope.name, "scoped.logger")
  match logger_scope.version {
    Some(version) => assert_eq(version, "3.1.4")
    None => assert_true(false)
  }
  match logger_scope.schema_url {
    Some(schema) => assert_eq(schema, "https://example.com/logger-schema")
    None => assert_true(false)
  }
  
  // æµ‹è¯•åœ¨Meterä¸­ä½¿ç”¨InstrumentationScope
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "scoped.meter", Some("1.0.0"))
  let meter_scope = meter.scope
  assert_eq(meter_scope.name, "scoped.meter")
  match meter_scope.version {
    Some(version) => assert_eq(version, "1.0.0")
    None => assert_true(false)
  }
}

test "Tracerå’ŒLoggeräº¤äº’é›†æˆæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let logger_provider = LoggerProvider::default()
  
  let tracer = TracerProvider::get_tracer(tracer_provider, "integration.tracer")
  let logger = LoggerProvider::get_logger(logger_provider, "integration.logger")
  
  // åˆ›å»ºä¸€ä¸ªspanå¹¶è®°å½•ç›¸å…³çš„æ—¥å¿—
  let parent_span = Tracer::start_span(tracer, "parent.operation")
  let span_context = Span::span_context(parent_span)
  
  // åˆ›å»ºä¸spanå…³è”çš„æ—¥å¿—è®°å½•
  let log_record = LogRecord::new_with_context(
    Info,
    Some("Operation started"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(span_context)),
    Some(SpanContext::span_id(span_context)),
    Some(Context::root())
  )
  
  Logger::emit(logger, log_record)
  
  // åœ¨spanä¸­æ·»åŠ äº‹ä»¶
  Span::add_event(parent_span, "operation.initialized", Some([
    ("component", StringValue("integration-test")),
    ("timestamp", StringValue("2025-01-01T00:00:00Z"))
  ]))
  
  // åˆ›å»ºå­span
  let child_span = Tracer::start_span(tracer, "child.operation")
  let child_context = Span::span_context(child_span)
  
  // è®°å½•å­æ“ä½œçš„æ—¥å¿—
  let child_log_record = LogRecord::new_with_context(
    Debug,
    Some("Child operation executing"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(child_context)),
    Some(SpanContext::span_id(child_context)),
    None
  )
  
  Logger::emit(logger, child_log_record)
  
  // åœ¨å­spanä¸­æ·»åŠ äº‹ä»¶
  Span::add_event(child_span, "child.processing", Some([
    ("step", IntValue(1)),
    ("total_steps", IntValue(3))
  ]))
  
  // ç»“æŸå­span
  Span::end(child_span)
  
  // è®°å½•å®Œæˆæ—¥å¿—
  let completion_log = LogRecord::new_with_context(
    Info,
    Some("Child operation completed"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(span_context)),
    Some(SpanContext::span_id(span_context)),
    None
  )
  
  Logger::emit(logger, completion_log)
  
  // ç»“æŸçˆ¶span
  Span::end(parent_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "è·¨æœåŠ¡é¥æµ‹ä¼ æ’­å®Œæ•´æµç¨‹æµ‹è¯•" {
  // åˆ›å»ºæœåŠ¡Açš„ä¸Šä¸‹æ–‡
  let service_a_tracer = TracerProvider::default() |> TracerProvider::get_tracer("service-a", Some("1.0.0"))
  let service_a_span = Tracer::start_span(service_a_tracer, "service-a.operation")
  let service_a_context = Span::span_context(service_a_span)
  
  // åˆ›å»ºä¼ æ’­å™¨
  let trace_propagator = W3CTraceContextPropagator::new()
  let composite_propagator = CompositePropagator::new([trace_propagator])
  
  // åˆ›å»ºæœåŠ¡Açš„baggage
  let baggage = Baggage::new()
  let baggage_with_user = Baggage::set_entry(baggage, "user.id", "user123")
  let baggage_with_session = Baggage::set_entry(baggage_with_user, "session.id", "session456")
  
  // åˆ›å»ºæœåŠ¡Açš„ä¸Šä¸‹æ–‡å¹¶æ·»åŠ baggageä¿¡æ¯
  let context_key = ContextKey::new("correlation.id")
  let service_a_context_with_baggage = Context::with_value(Context::root(), context_key, "corr-789")
  
  // æ³¨å…¥ä¼ æ’­ä¿¡æ¯åˆ°HTTPå¤´éƒ¨
  let outbound_carrier = TextMapCarrier::new()
  CompositePropagator::inject(composite_propagator, service_a_context_with_baggage, outbound_carrier)
  
  // æ¨¡æ‹ŸHTTPè°ƒç”¨ - æœåŠ¡Aè°ƒç”¨æœåŠ¡B
  let service_b_request = HttpRequest::new(
    "POST",
    "https://service-b.example.com/process",
    [
      ("Content-Type", "application/json"),
      ("X-Request-ID", "req-12345")
    ],
    Some("{\"data\":\"test\"}")
  )
  
  // æœåŠ¡Bæ¥æ”¶è¯·æ±‚å¹¶æå–ä¸Šä¸‹æ–‡
  let service_b_carrier = TextMapCarrier::new()
  TextMapCarrier::set(service_b_carrier, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  
  let service_b_context = CompositePropagator::extract(composite_propagator, service_b_carrier)
  
  // æœåŠ¡Båˆ›å»ºspan
  let service_b_tracer = TracerProvider::default() |> TracerProvider::get_tracer("service-b", Some("2.0.0"))
  let service_b_span = Tracer::start_span(service_b_tracer, "service-b.operation")
  
  // æœåŠ¡Bè®°å½•æ—¥å¿—
  let service_b_logger = LoggerProvider::default() |> LoggerProvider::get_logger("service-b")
  let service_b_log = LogRecord::new_with_context(
    Info,
    Some("Processing request from service-a"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(service_b_span))),
    Some(SpanContext::span_id(Span::span_context(service_b_span))),
    Some(service_b_context)
  )
  
  Logger::emit(service_b_logger, service_b_log)
  
  // æœåŠ¡Bè°ƒç”¨æœåŠ¡C
  let service_c_carrier = TextMapCarrier::new()
  CompositePropagator::inject(composite_propagator, service_b_context, service_c_carrier)
  
  // æœåŠ¡Cå¤„ç†å¹¶è¿”å›å“åº”
  let service_c_response = HttpResponse::new(200, [
    ("Content-Type", "application/json"),
    ("X-Trace-ID", "trace-12345")
  ], Some("{\"result\":\"success\",\"id\":789}"))
  
  // éªŒè¯å“åº”
  assert_eq(HttpResponse::status_code(service_c_response), 200)
  
  // ç»“æŸæ‰€æœ‰span
  Span::end(service_b_span)
  Span::end(service_a_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "æ€§èƒ½ç›‘æ§æŒ‡æ ‡ç»¼åˆæµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "performance.monitor", Some("1.0.0"))
  
  // åˆ›å»ºå„ç§ç±»å‹çš„æŒ‡æ ‡
  let request_counter = Meter::create_counter(meter, "http.requests.total", Some("Total HTTP requests"), Some("requests"))
  let response_time_histogram = Meter::create_histogram(meter, "http.response.time", Some("HTTP response time"), Some("ms"))
  let active_connections_gauge = UpDownCounter::{ 
    name: "http.active.connections", 
    description: Some("Active HTTP connections"), 
    unit: Some("connections") 
  }
  let memory_usage_gauge = Gauge::{ 
    name: "process.memory.usage", 
    description: Some("Process memory usage"), 
    unit: Some("bytes") 
  }
  
  // æ¨¡æ‹Ÿè¯·æ±‚å¤„ç†å¹¶è®°å½•æŒ‡æ ‡
  let start_time = Clock::now_unix_nanos(Clock::system())
  
  // è®°å½•è¯·æ±‚å¼€å§‹
  Counter::add(request_counter, 1.0, Some(Attributes::new()))
  
  // æ¨¡æ‹Ÿæ´»è·ƒè¿æ¥å¢åŠ 
  // æ³¨æ„ï¼šUpDownCounterçš„addæ–¹æ³•åœ¨ç®€åŒ–å®ç°ä¸­å¯èƒ½ä¸å¯ç”¨ï¼Œè¿™é‡Œç”¨Counterä»£æ›¿
  
  // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
  let processing_time_ms = 150.5
  Histogram::record(response_time_histogram, processing_time_ms, Some(Attributes::new()))
  
  // è®°å½•å†…å­˜ä½¿ç”¨
  let memory_usage = 1024 * 1024 * 512 // 512MB
  // æ³¨æ„ï¼šGaugeçš„recordæ–¹æ³•åœ¨ç®€åŒ–å®ç°ä¸­å¯èƒ½ä¸å¯ç”¨
  
  // æ¨¡æ‹Ÿå¤šä¸ªè¯·æ±‚
  for i = 0; i < 10; i = i + 1 {
    Counter::add(request_counter, 1.0, Some(Attributes::new()))
    let response_time = 100.0 + (i * 10.0).to_double()
    Histogram::record(response_time_histogram, response_time, Some(Attributes::new()))
  }
  
  // è®°å½•ä¸åŒç±»å‹çš„è¯·æ±‚
  let attrs = Attributes::new()
  Attributes::set(attrs, "method", StringValue("GET"))
  Attributes::set(attrs, "status", StringValue("200"))
  Counter::add(request_counter, 5.0, Some(attrs))
  
  let post_attrs = Attributes::new()
  Attributes::set(post_attrs, "method", StringValue("POST"))
  Attributes::set(post_attrs, "status", StringValue("201"))
  Counter::add(request_counter, 3.0, Some(post_attrs))
  
  let error_attrs = Attributes::new()
  Attributes::set(error_attrs, "method", StringValue("GET"))
  Attributes::set(error_attrs, "status", StringValue("500"))
  Counter::add(request_counter, 2.0, Some(error_attrs))
  
  // éªŒè¯æŒ‡æ ‡å…ƒæ•°æ®
  assert_eq(request_counter.name, "http.requests.total")
  assert_eq(request_counter.description, Some("Total HTTP requests"))
  assert_eq(request_counter.unit, Some("requests"))
  
  assert_eq(response_time_histogram.name, "http.response.time")
  assert_eq(response_time_histogram.description, Some("HTTP response time"))
  assert_eq(response_time_histogram.unit, Some("ms"))
  
  // æµ‹è¯•æŒ‡æ ‡è½¬æ¢ä¸ºInstrumentç±»å‹
  let counter_instrument = Histogram::as_instrument(response_time_histogram)
  assert_eq(Instrument::name(counter_instrument), "http.response.time")
  assert_eq(Instrument::description(counter_instrument), Some("HTTP response time"))
  assert_eq(Instrument::unit(counter_instrument), Some("ms"))
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "æ•°æ®åºåˆ—åŒ–å’Œå®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // åˆ›å»ºå¤æ‚çš„å±æ€§é›†åˆ
  let attrs = Attributes::new()
  
  // æ·»åŠ å„ç§ç±»å‹çš„å±æ€§
  Attributes::set(attrs, "string.value", StringValue("test_string"))
  Attributes::set(attrs, "int.value", IntValue(42))
  Attributes::set(attrs, "float.value", FloatValue(3.14159))
  Attributes::set(attrs, "bool.value", BoolValue(true))
  Attributes::set(attrs, "string.array", ArrayStringValue(["item1", "item2", "item3"]))
  Attributes::set(attrs, "int.array", ArrayIntValue([1, 2, 3, 4, 5]))
  
  // åˆ›å»ºå¸¦æœ‰æ—¶é—´æˆ³çš„SpanContext
  let trace_id = "0af7651916cd43dd8448eb211c80319c"
  let span_id = "b7ad6b7169203331"
  let span_context = SpanContext::new(trace_id, span_id, true, "rojo=00f067aa0ba902b7")
  
  // éªŒè¯SpanContextçš„å®Œæ•´æ€§
  assert_eq(SpanContext::trace_id(span_context), trace_id)
  assert_eq(SpanContext::span_id(span_context), span_id)
  assert_true(SpanContext::is_valid(span_context))
  assert_true(SpanContext::is_sampled(span_context))
  
  // åˆ›å»ºå¤æ‚çš„LogRecord
  let timestamp = Clock::now_unix_nanos(Clock::system())
  let log_record = LogRecord::new_with_context(
    Error,
    Some("Complex error with context"),
    Some(attrs),
    Some(timestamp),
    Some(timestamp + 1000L),
    Some(trace_id),
    Some(span_id),
    Some(Context::root())
  )
  
  // éªŒè¯LogRecordçš„å®Œæ•´æ€§
  assert_eq(LogRecord::severity_number(log_record), Error)
  match LogRecord::body(log_record) {
    Some(body) => assert_eq(body, "Complex error with context")
    None => assert_true(false)
  }
  assert_eq(LogRecord::trace_id(log_record), Some(trace_id))
  assert_eq(LogRecord::span_id(log_record), Some(span_id))
  assert_eq(log_record.timestamp, Some(timestamp))
  
  // åˆ›å»ºResourceå¹¶éªŒè¯å±æ€§
  let resource_attrs = [
    ("service.name", StringValue("azimuth-test")),
    ("service.version", StringValue("1.0.0")),
    ("service.instance.id", StringValue("instance-12345")),
    ("host.name", StringValue("test-host")),
    ("process.pid", IntValue(12345)),
    ("process.memory.limit", IntValue(1073741824)), // 1GB
    ("feature.flags", ArrayStringValue(["feature1", "feature2", "feature3"])),
    ("availability.zone", StringValue("us-west-2a")),
    ("environment", StringValue("test")),
    ("debug.enabled", BoolValue(true))
  ]
  
  let resource = Resource::with_attributes(Resource::new(), resource_attrs)
  
  // éªŒè¯Resourceå±æ€§
  let service_name = Resource::get_attribute(resource, "service.name")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "azimuth-test")
    _ => assert_true(false)
  }
  
  let process_pid = Resource::get_attribute(resource, "process.pid")
  match process_pid {
    Some(IntValue(value)) => assert_eq(value, 12345)
    _ => assert_true(false)
  }
  
  let feature_flags = Resource::get_attribute(resource, "feature.flags")
  match feature_flags {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "feature1")
      assert_eq(values[2], "feature3")
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•Resourceåˆå¹¶
  let override_attrs = [
    ("service.name", StringValue("updated-azimuth-test")),
    ("new.attr", StringValue("new-value")),
    ("override.me", StringValue("overridden"))
  ]
  
  let override_resource = Resource::with_attributes(Resource::new(), override_attrs)
  let merged_resource = Resource::merge(resource, override_resource)
  
  // éªŒè¯åˆå¹¶ç»“æœ
  let merged_service_name = Resource::get_attribute(merged_resource, "service.name")
  match merged_service_name {
    Some(StringValue(value)) => assert_eq(value, "updated-azimuth-test")
    _ => assert_true(false)
  }
  
  let new_attr = Resource::get_attribute(merged_resource, "new.attr")
  match new_attr {
    Some(StringValue(value)) => assert_eq(value, "new-value")
    _ => assert_true(false)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "é”™è¯¯è¾¹ç•Œå’Œå¼‚å¸¸æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•ç©ºå€¼å’Œnullå¤„ç†
  let empty_trace_context = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(empty_trace_context))
  assert_false(SpanContext::is_sampled(empty_trace_context))
  
  // æµ‹è¯•éƒ¨åˆ†ç©ºçš„SpanContext
  let partial_empty_ctx = SpanContext::new("valid-trace-id", "", true, "")
  assert_false(SpanContext::is_valid(partial_empty_ctx))
  
  let partial_empty_ctx2 = SpanContext::new("", "valid-span-id", true, "")
  assert_false(SpanContext::is_valid(partial_empty_ctx2))
  
  // æµ‹è¯•æå€¼å±æ€§
  let attrs = Attributes::new()
  
  // æµ‹è¯•æå¤§å’Œæå°çš„æ•´æ•°å€¼
  Attributes::set(attrs, "max.int", IntValue(2147483647))
  Attributes::set(attrs, "min.int", IntValue(-2147483648))
  Attributes::set(attrs, "zero.int", IntValue(0))
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹æ•°å€¼
  Attributes::set(attrs, "infinity", FloatValue(1.0/0.0))
  Attributes::set(attrs, "negative.infinity", FloatValue(-1.0/0.0))
  Attributes::set(attrs, "nan", FloatValue(0.0/0.0))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦ä¸²
  Attributes::set(attrs, "empty.string", StringValue(""))
  Attributes::set(attrs, "spaces.string", StringValue("   "))
  Attributes::set(attrs, "special.chars", StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  Attributes::set(attrs, "unicode.chars", StringValue("æµ‹è¯•ğŸš€ğŸŒŸğŸ’«"))
  
  // æµ‹è¯•ç©ºæ•°ç»„
  Attributes::set(attrs, "empty.string.array", ArrayStringValue([]))
  Attributes::set(attrs, "empty.int.array", ArrayIntValue([]))
  
  // æµ‹è¯•åŒ…å«null/ç©ºå€¼çš„æ•°ç»„
  Attributes::set(attrs, "mixed.array", ArrayStringValue(["", "valid", "   ", "æµ‹è¯•"]))
  Attributes::set(attrs, "mixed.int.array", ArrayIntValue([0, -1, 2147483647, -2147483648]))
  
  // æµ‹è¯•LogRecordçš„è¾¹ç•Œæ¡ä»¶
  let empty_log = LogRecord::new(Info, "")
  assert_eq(LogRecord::severity_number(empty_log), Info)
  match LogRecord::body(empty_log) {
    Some(body) => assert_eq(body, "")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¸¦æœ‰æç«¯å€¼çš„LogRecord
  let extreme_timestamp_log = LogRecord::new_with_context(
    Fatal,
    Some("Extreme timestamp test"),
    None,
    Some(9223372036854775807L), // Max Int64
    Some(-9223372036854775808L), // Min Int64
    Some(""), // Empty trace ID
    Some(""), // Empty span ID
    None
  )
  
  assert_eq(LogRecord::severity_number(extreme_timestamp_log), Fatal)
  assert_eq(LogRecord::trace_id(extreme_timestamp_log), Some(""))
  assert_eq(LogRecord::span_id(extreme_timestamp_log), Some(""))
  
  // æµ‹è¯•TextMapCarrierçš„è¾¹ç•Œæ¡ä»¶
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  TextMapCarrier::set(carrier, "", "")
  TextMapCarrier::set(carrier, "empty.value", "")
  TextMapCarrier::set(carrier, "", "empty.key")
  
  // æµ‹è¯•è¶…é•¿é”®å’Œå€¼
  let long_key = "a" * 1000
  let long_value = "b" * 1000
  TextMapCarrier::set(carrier, long_key, long_value)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  TextMapCarrier::set(carrier, "header\nwith\nnewlines", "value\nwith\nnewlines")
  TextMapCarrier::set(carrier, "header\twith\ttabs", "value\twith\ttabs")
  TextMapCarrier::set(carrier, "header with spaces", "value with spaces")
  
  // æµ‹è¯•HTTPè¾¹ç•Œæ¡ä»¶
  let empty_request = HttpRequest::new("", "", [], Some(""))
  assert_eq(HttpRequest::http_method(empty_request), "")
  assert_eq(HttpRequest::url(empty_request), "")
  match HttpRequest::body(empty_request) {
    Some(body) => assert_eq(body, "")
    None => assert_true(false)
  }
  
  let extreme_response = HttpResponse::new(999, [], Some(""))
  assert_eq(HttpResponse::status_code(extreme_response), 999)
  
  // æµ‹è¯•Contextçš„è¾¹ç•Œæ¡ä»¶
  let root_context = Context::root()
  let empty_key = ContextKey::new("")
  let context_with_empty_key = Context::with_value(root_context, empty_key, "")
  
  let retrieved_empty = Context::get(context_with_empty_key, empty_key)
  match retrieved_empty {
    Some(value) => assert_eq(value, "")
    None => assert_true(false)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "å¹¶å‘å®‰å…¨æ“ä½œæµ‹è¯•" {
  // åˆ›å»ºå…±äº«èµ„æº
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "concurrent.test")
  let counter = Meter::create_counter(meter, "concurrent.operations")
  
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer")
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "concurrent.logger")
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œçš„æµ‹è¯•
  // æ³¨æ„ï¼šç”±äºMoonBitçš„é™åˆ¶ï¼Œè¿™é‡Œæ— æ³•çœŸæ­£åˆ›å»ºå¹¶å‘çº¿ç¨‹ï¼Œ
  // ä½†å¯ä»¥æµ‹è¯•èµ„æºåœ¨å¿«é€Ÿè¿ç»­æ“ä½œä¸‹çš„ç¨³å®šæ€§
  
  // å¿«é€Ÿè¿ç»­åˆ›å»ºå’Œæ“ä½œå¤šä¸ªspan
  for i = 0; i < 100; i = i + 1 {
    let span_name = "concurrent.span." + i.to_string()
    let span = Tracer::start_span(tracer, span_name)
    
    // åœ¨spanä¸­æ·»åŠ äº‹ä»¶
    Span::add_event(span, "event." + i.to_string(), Some([
      ("iteration", IntValue(i)),
      ("timestamp", StringValue("2025-01-01T00:00:00Z"))
    ]))
    
    // è®°å½•æŒ‡æ ‡
    Counter::add(counter, 1.0, Some(Attributes::new()))
    
    // è®°å½•æ—¥å¿—
    let log_record = LogRecord::new(Info, "Concurrent operation " + i.to_string())
    Logger::emit(logger, log_record)
    
    // ç»“æŸspan
    Span::end(span)
  }
  
  // æµ‹è¯•å¿«é€Ÿè¿ç»­çš„å±æ€§æ“ä½œ
  let attrs = Attributes::new()
  for i = 0; i < 50; i = i + 1 {
    let key = "concurrent.key." + i.to_string()
    let value = StringValue("concurrent.value." + i.to_string())
    Attributes::set(attrs, key, value)
    
    // ç«‹å³å°è¯•è¯»å–
    let retrieved = Attributes::get(attrs, key)
    match retrieved {
      Some(StringValue(retrieved_value)) => assert_eq(retrieved_value, "test_value") // ç®€åŒ–å®ç°è¿”å›å›ºå®šå€¼
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•å¿«é€Ÿè¿ç»­çš„Contextæ“ä½œ
  let base_context = Context::root()
  let current_context = base_context
  
  for i = 0; i < 25; i = i + 1 {
    let key = ContextKey::new("concurrent.context." + i.to_string())
    let value = "context.value." + i.to_string()
    current_context = Context::with_value(current_context, key, value)
    
    // éªŒè¯å€¼å¯ä»¥æ­£ç¡®æ£€ç´¢
    let retrieved = Context::get(current_context, key)
    match retrieved {
      Some(retrieved_value) => assert_eq(retrieved_value, value)
      None => assert_true(false)
    }
  }
  
  // æµ‹è¯•å¿«é€Ÿè¿ç»­çš„Baggageæ“ä½œ
  let baggage = Baggage::new()
  let current_baggage = baggage
  
  for i = 0; i < 25; i = i + 1 {
    let key = "concurrent.baggage." + i.to_string()
    let value = "baggage.value." + i.to_string()
    current_baggage = Baggage::set_entry(current_baggage, key, value)
    
    // éªŒè¯å€¼å¯ä»¥æ­£ç¡®æ£€ç´¢ï¼ˆåœ¨ç®€åŒ–å®ç°ä¸­å¯èƒ½ä¸ä¼šï¼‰
    let retrieved = Baggage::get_entry(current_baggage, key)
    // ç®€åŒ–å®ç°å¯èƒ½è¿”å›Noneï¼Œæ‰€ä»¥è¿™é‡ŒåªéªŒè¯ä¸ä¼šå´©æºƒ
  }
  
  // æµ‹è¯•å¿«é€Ÿè¿ç»­çš„TextMapCarrieræ“ä½œ
  let carrier = TextMapCarrier::new()
  
  for i = 0; i < 50; i = i + 1 {
    let key = "concurrent.header." + i.to_string()
    let value = "concurrent.value." + i.to_string()
    TextMapCarrier::set(carrier, key, value)
    
    // ç«‹å³å°è¯•è¯»å–
    let retrieved = TextMapCarrier::get(carrier, key)
    // ç®€åŒ–å®ç°å¯èƒ½åªå¯¹ç‰¹å®šé”®è¿”å›å€¼
  }
  
  // æµ‹è¯•å¿«é€Ÿè¿ç»­çš„Propagationæ“ä½œ
  let trace_propagator = W3CTraceContextPropagator::new()
  let composite_propagator = CompositePropagator::new([trace_propagator])
  
  for i = 0; i < 10; i = i + 1 {
    let context = Context::with_value(Context::root(), ContextKey::new("test"), i.to_string())
    let carrier = TextMapCarrier::new()
    
    CompositePropagator::inject(composite_propagator, context, carrier)
    let extracted_context = CompositePropagator::extract(composite_propagator, carrier)
    
    // éªŒè¯æå–æ“ä½œä¸ä¼šå´©æºƒ
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "å›½é™…åŒ–å’Œæœ¬åœ°åŒ–é…ç½®æµ‹è¯•" {
  // æµ‹è¯•å¤šè¯­è¨€å­—ç¬¦ä¸²æ”¯æŒ
  let attrs = Attributes::new()
  
  // æ·»åŠ ä¸åŒè¯­è¨€çš„å±æ€§
  Attributes::set(attrs, "error.message.zh", StringValue("æ“ä½œå¤±è´¥"))
  Attributes::set(attrs, "error.message.en", StringValue("Operation failed"))
  Attributes::set(attrs, "error.message.ja", StringValue("æ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ"))
  Attributes::set(attrs, "error.message.es", StringValue("La operaciÃ³n fallÃ³"))
  Attributes::set(attrs, "error.message.fr", StringValue("L'opÃ©ration a Ã©chouÃ©"))
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  Attributes::set(attrs, "user.name.zh", StringValue("å¼ ä¸‰"))
  Attributes::set(attrs, "user.name.ja", StringValue("ç”°ä¸­å¤ªéƒ"))
  Attributes::set(attrs, "user.name.ar", StringValue("Ø£Ø­Ù…Ø¯"))
  Attributes::set(attrs, "user.name.ru", StringValue("Ğ˜Ğ²Ğ°Ğ½ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²"))
  Attributes::set(attrs, "user.name.ko", StringValue("ê¹€ì² ìˆ˜"))
  
  // æµ‹è¯•emojiå’Œç‰¹æ®Šç¬¦å·
  Attributes::set(attrs, "status.icon", StringValue("ğŸš€"))
  Attributes::set(attrs, "error.icon", StringValue("âŒ"))
  Attributes::set(attrs, "warning.icon", StringValue("âš ï¸"))
  Attributes::set(attrs, "success.icon", StringValue("âœ…"))
  
  // éªŒè¯å¤šè¯­è¨€å±æ€§å¯ä»¥æ­£ç¡®å­˜å‚¨å’Œæ£€ç´¢
  let zh_error = Attributes::get(attrs, "error.message.zh")
  match zh_error {
    Some(StringValue(value)) => assert_eq(value, "æ“ä½œå¤±è´¥")
    _ => assert_true(false)
  }
  
  let ja_error = Attributes::get(attrs, "error.message.ja")
  match ja_error {
    Some(StringValue(value)) => assert_eq(value, "æ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ")
    _ => assert_true(false)
  }
  
  let status_icon = Attributes::get(attrs, "status.icon")
  match status_icon {
    Some(StringValue(value)) => assert_eq(value, "ğŸš€")
    _ => assert_true(false)
  }
  
  // åˆ›å»ºå¤šè¯­è¨€Resource
  let i18n_resource_attrs = [
    ("service.name.zh", StringValue("æ–¹ä½è§’é¥æµ‹æœåŠ¡")),
    ("service.name.en", StringValue("Azimuth Telemetry Service")),
    ("service.name.ja", StringValue("ã‚¢ã‚¸ãƒ ã‚¹ãƒ»ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªãƒ¼ãƒ»ã‚µãƒ¼ãƒ“ã‚¹")),
    ("service.description.zh", StringValue("æä¾›åˆ†å¸ƒå¼è¿½è¸ªå’Œç›‘æ§åŠŸèƒ½")),
    ("service.description.en", StringValue("Provides distributed tracing and monitoring capabilities")),
    ("service.region.zh", StringValue("äºšå¤ªåœ°åŒº")),
    ("service.region.en", StringValue("Asia-Pacific Region")),
    ("service.timezone", StringValue("Asia/Shanghai"))
  ]
  
  let i18n_resource = Resource::with_attributes(Resource::new(), i18n_resource_attrs)
  
  // éªŒè¯å¤šè¯­è¨€Resourceå±æ€§
  let service_name_zh = Resource::get_attribute(i18n_resource, "service.name.zh")
  match service_name_zh {
    Some(StringValue(value)) => assert_eq(value, "æ–¹ä½è§’é¥æµ‹æœåŠ¡")
    _ => assert_true(false)
  }
  
  let service_description_en = Resource::get_attribute(i18n_resource, "service.description.en")
  match service_description_en {
    Some(StringValue(value)) => assert_eq(value, "Provides distributed tracing and monitoring capabilities")
    _ => assert_true(false)
  }
  
  // åˆ›å»ºå¤šè¯­è¨€æ—¥å¿—è®°å½•
  let i18n_logger = LoggerProvider::default() |> LoggerProvider::get_logger("i18n.logger")
  
  let zh_log = LogRecord::new(Info, "ç”¨æˆ·ç™»å½•æˆåŠŸ")
  Logger::emit(i18n_logger, zh_log)
  
  let en_log = LogRecord::new(Info, "User login successful")
  Logger::emit(i18n_logger, en_log)
  
  let ja_log = LogRecord::new(Warn, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³ã®è©¦è¡Œå›æ•°ãŒåˆ¶é™ã‚’è¶…ãˆã¾ã—ãŸ")
  Logger::emit(i18n_logger, ja_log)
  
  // æµ‹è¯•å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  let error_attrs = Attributes::new()
  Attributes::set(error_attrs, "error.code", StringValue("VALIDATION_ERROR"))
  Attributes::set(error_attrs, "error.message.zh", StringValue("è¾“å…¥å‚æ•°éªŒè¯å¤±è´¥"))
  Attributes::set(error_attrs, "error.message.en", StringValue("Input parameter validation failed"))
  Attributes::set(error_attrs, "error.field", StringValue("email"))
  Attributes::set(error_attrs, "error.value", StringValue("invalid-email"))
  
  let validation_error_log = LogRecord::new_with_context(
    Error,
    Some("Validation error occurred"),
    Some(error_attrs),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    None,
    None,
    None
  )
  
  Logger::emit(i18n_logger, validation_error_log)
  
  // æµ‹è¯•å¤šè¯­è¨€Spanåç§°å’Œäº‹ä»¶
  let i18n_tracer = TracerProvider::default() |> TracerProvider::get_tracer("i18n.tracer")
  
  let zh_span = Tracer::start_span(i18n_tracer, "ç”¨æˆ·æ³¨å†Œæµç¨‹")
  Span::add_event(zh_span, "å¼€å§‹éªŒè¯ç”¨æˆ·è¾“å…¥", Some([
    ("step", StringValue("éªŒè¯")),
    ("language", StringValue("zh"))
  ]))
  Span::add_event(zh_span, "ç”¨æˆ·è¾“å…¥éªŒè¯å®Œæˆ", Some([
    ("step", StringValue("å®Œæˆ")),
    ("result", StringValue("æˆåŠŸ"))
  ]))
  Span::end(zh_span)
  
  let en_span = Tracer::start_span(i18n_tracer, "user.registration.flow")
  Span::add_event(en_span, "start.user.input.validation", Some([
    ("step", StringValue("validation")),
    ("language", StringValue("en"))
  ]))
  Span::add_event(en_span, "user.input.validation.completed", Some([
    ("step", StringValue("completed")),
    ("result", StringValue("success"))
  ]))
  Span::end(en_span)
  
  // æµ‹è¯•å¤šè¯­è¨€HTTPå¤´éƒ¨å’Œå“åº”
  let i18n_carrier = TextMapCarrier::new()
  TextMapCarrier::set(i18n_carrier, "Accept-Language", "zh-CN,zh;q=0.9,en;q=0.8")
  TextMapCarrier::set(i18n_carrier, "Content-Language", "zh-CN")
  
  let i18n_response = HttpResponse::new(200, [
    ("Content-Language", "zh-CN"),
    ("X-Error-Message-ZH", "æ“ä½œæˆåŠŸå®Œæˆ"),
    ("X-Error-Message-EN", "Operation completed successfully")
  ], Some("{\"message\":\"æ“ä½œæˆåŠŸ\",\"status\":\"æˆåŠŸ\"}"))
  
  assert_eq(HttpResponse::status_code(i18n_response), 200)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "ç»¼åˆç«¯åˆ°ç«¯ä¸šåŠ¡åœºæ™¯æµ‹è¯•" {
  // æ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„ç”µå•†è®¢å•å¤„ç†æµç¨‹
  
  // 1. åˆå§‹åŒ–æœåŠ¡å’Œé¥æµ‹ç»„ä»¶
  let order_service_tracer = TracerProvider::default() |> TracerProvider::get_tracer("order.service", Some("1.2.3"))
  let payment_service_tracer = TracerProvider::default() |> TracerProvider::get_tracer("payment.service", Some("2.1.0"))
  let inventory_service_tracer = TracerProvider::default() |> TracerProvider::get_tracer("inventory.service", Some("1.5.2"))
  
  let order_service_logger = LoggerProvider::default() |> LoggerProvider::get_logger("order.service")
  let payment_service_logger = LoggerProvider::default() |> LoggerProvider::get_logger("payment.service")
  let inventory_service_logger = LoggerProvider::default() |> LoggerProvider::get_logger("inventory.service")
  
  let metrics_meter = MeterProvider::default() |> MeterProvider::get_meter("ecommerce.metrics")
  
  // 2. åˆ›å»ºä¸šåŠ¡æŒ‡æ ‡
  let order_counter = Meter::create_counter(metrics_meter, "orders.total", Some("Total orders processed"), Some("orders"))
  let payment_amount_histogram = Meter::create_histogram(metrics_meter, "payment.amount", Some("Payment amounts"), Some("currency_units"))
  let inventory_gauge = UpDownCounter::{ 
    name: "inventory.stock.count", 
    description: Some("Current inventory stock count"), 
    unit: Some("items") 
  }
  
  // 3. å¼€å§‹è®¢å•å¤„ç†æµç¨‹
  let order_span = Tracer::start_span(order_service_tracer, "process.order")
  let order_context = Span::span_context(order_span)
  
  // è®°å½•è®¢å•å¼€å§‹æ—¥å¿—
  let order_start_log = LogRecord::new_with_context(
    Info,
    Some("Order processing started"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(order_context)),
    Some(SpanContext::span_id(order_context)),
    None
  )
  Logger::emit(order_service_logger, order_start_log)
  
  // æ·»åŠ è®¢å•äº‹ä»¶
  Span::add_event(order_span, "order.received", Some([
    ("order.id", StringValue("ORD-12345")),
    ("customer.id", StringValue("CUST-67890")),
    ("order.amount", IntValue(9999)),
    ("currency", StringValue("CNY"))
  ]))
  
  // 4. åº“å­˜æ£€æŸ¥
  let inventory_span = Tracer::start_span(inventory_service_tracer, "check.inventory")
  Span::add_event(inventory_span, "inventory.check.started", Some([
    ("product.id", StringValue("PROD-001")),
    ("quantity.requested", IntValue(2))
  ]))
  
  // æ¨¡æ‹Ÿåº“å­˜æ£€æŸ¥æˆåŠŸ
  Span::add_event(inventory_span, "inventory.check.success", Some([
    ("product.id", StringValue("PROD-001")),
    ("quantity.available", IntValue(10)),
    ("quantity.reserved", IntValue(2))
  ]))
  
  // è®°å½•åº“å­˜æ£€æŸ¥æ—¥å¿—
  let inventory_log = LogRecord::new(Info, "Inventory check completed successfully")
  Logger::emit(inventory_service_logger, inventory_log)
  
  Span::end(inventory_span)
  
  // 5. æ”¯ä»˜å¤„ç†
  let payment_span = Tracer::start_span(payment_service_tracer, "process.payment")
  Span::add_event(payment_span, "payment.started", Some([
    ("order.id", StringValue("ORD-12345")),
    ("payment.method", StringValue("credit_card")),
    ("payment.amount", IntValue(9999))
  ]))
  
  // è®°å½•æ”¯ä»˜æŒ‡æ ‡
  Histogram::record(payment_amount_histogram, 9999.0, Some(Attributes::new()))
  
  // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
  Span::add_event(payment_span, "payment.processing", Some([
    ("payment.gateway", StringValue("alipay")),
    ("transaction.id", StringValue("TXN-98765"))
  ]))
  
  // æ”¯ä»˜æˆåŠŸ
  Span::add_event(payment_span, "payment.success", Some([
    ("transaction.id", StringValue("TXN-98765")),
    ("payment.status", StringValue("completed"))
  ]))
  
  // è®°å½•æ”¯ä»˜æˆåŠŸæ—¥å¿—
  let payment_success_log = LogRecord::new_with_context(
    Info,
    Some("Payment processed successfully"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(payment_span))),
    Some(SpanContext::span_id(Span::span_context(payment_span))),
    None
  )
  Logger::emit(payment_service_logger, payment_success_log)
  
  Span::end(payment_span)
  
  // 6. è®¢å•å®Œæˆ
  Span::add_event(order_span, "payment.completed", Some([
    ("transaction.id", StringValue("TXN-98765")),
    ("payment.amount", IntValue(9999))
  ]))
  
  Span::add_event(order_span, "order.completed", Some([
    ("order.id", StringValue("ORD-12345")),
    ("order.status", StringValue("completed")),
    ("completion.time", StringValue("2025-01-01T12:00:00Z"))
  ]))
  
  // è®°å½•è®¢å•å®ŒæˆæŒ‡æ ‡
  Counter::add(order_counter, 1.0, Some(Attributes::new()))
  
  // è®°å½•è®¢å•å®Œæˆæ—¥å¿—
  let order_completion_log = LogRecord::new_with_context(
    Info,
    Some("Order completed successfully"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(order_context)),
    Some(SpanContext::span_id(order_context)),
    None
  )
  Logger::emit(order_service_logger, order_completion_log)
  
  Span::end(order_span)
  
  // 7. é”™è¯¯å¤„ç†åœºæ™¯ - æ¨¡æ‹Ÿæ”¯ä»˜å¤±è´¥
  let failed_order_span = Tracer::start_span(order_service_tracer, "process.failed.order")
  Span::add_event(failed_order_span, "order.received", Some([
    ("order.id", StringValue("ORD-54321")),
    ("customer.id", StringValue("CUST-09876")),
    ("order.amount", IntValue(15999))
  ]))
  
  // åº“å­˜æ£€æŸ¥æˆåŠŸ
  let failed_inventory_span = Tracer::start_span(inventory_service_tracer, "check.inventory.failed")
  Span::add_event(failed_inventory_span, "inventory.check.success", Some([
    ("product.id", StringValue("PROD-002")),
    ("quantity.available", IntValue(5)),
    ("quantity.reserved", IntValue(1)
  ]))
  Span::end(failed_inventory_span)
  
  // æ”¯ä»˜å¤±è´¥
  let failed_payment_span = Tracer::start_span(payment_service_tracer, "process.payment.failed")
  Span::add_event(failed_payment_span, "payment.started", Some([
    ("order.id", StringValue("ORD-54321")),
    ("payment.method", StringValue("credit_card")),
    ("payment.amount", IntValue(15999))
  ]))
  
  Span::add_event(failed_payment_span, "payment.failed", Some([
    ("failure.reason", StringValue("insufficient_funds")),
    ("error.code", StringValue("PAYMENT_001"))
  ]))
  
  // è®°å½•æ”¯ä»˜å¤±è´¥æ—¥å¿—
  let payment_error_log = LogRecord::new_with_context(
    Error,
    Some("Payment processing failed"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(failed_payment_span))),
    Some(SpanContext::span_id(Span::span_context(failed_payment_span))),
    None
  )
  Logger::emit(payment_service_logger, payment_error_log)
  
  Span::set_status(failed_payment_span, Error, Some("Payment failed due to insufficient funds"))
  Span::end(failed_payment_span)
  
  // è®¢å•å¤±è´¥å¤„ç†
  Span::add_event(failed_order_span, "payment.failed", Some([
    ("failure.reason", StringValue("insufficient_funds")),
    ("order.status", StringValue("failed"))
  ]))
  
  // è®°å½•è®¢å•å¤±è´¥æ—¥å¿—
  let order_failure_log = LogRecord::new_with_context(
    Error,
    Some("Order processing failed"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(failed_order_span))),
    Some(SpanContext::span_id(Span::span_context(failed_order_span))),
    None
  )
  Logger::emit(order_service_logger, order_failure_log)
  
  Span::set_status(failed_order_span, Error, Some("Order failed due to payment error"))
  Span::end(failed_order_span)
  
  // 8. éªŒè¯æ‰€æœ‰ç»„ä»¶éƒ½æ­£å¸¸å·¥ä½œ
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}