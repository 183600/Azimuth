// Azimuth Premium Quality Test Suite
// é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼Œä¸“æ³¨äºé«˜çº§åŠŸèƒ½ã€æ€§èƒ½ä¼˜åŒ–å’Œè¾¹ç•Œæƒ…å†µ

// æµ‹è¯•1: é¥æµ‹æ•°æ®å‹ç¼©å’Œä¼˜åŒ–
test "é¥æµ‹æ•°æ®å‹ç¼©å’Œå­˜å‚¨ä¼˜åŒ–æµ‹è¯•" {
  // åˆ›å»ºå¤§é‡é¥æµ‹æ•°æ®
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "compression.test")
  
  // åˆ›å»ºåŒ…å«å¤§é‡å±æ€§çš„Span
  let span = Tracer::start_span(tracer, "compression.test.span")
  
  // æ·»åŠ å¤§é‡å±æ€§ä»¥æµ‹è¯•å‹ç¼©æ•ˆæœ
  for i in 0..100 {
    let key = "attribute." + i.to_string()
    let value = "value.with.much.longer.content.to.test.compression.efficiency." + i.to_string()
    Span::set_attribute(span, key, StringValue(value))
  }
  
  // æ·»åŠ äº‹ä»¶
  for i in 0..50 {
    let event_name = "event." + i.to_string()
    Span::add_event(span, event_name, Some([
      ("event.index", IntValue(i)),
      ("event.timestamp", IntValue(1000000 + i)),
      ("event.type", StringValue("compression.test"))
    ]))
  }
  
  // éªŒè¯Spanå±æ€§æ•°é‡
  let attributes = Span::attributes(span)
  assert_eq(Array::length(attributes), 100)
  
  // æµ‹è¯•åºåˆ—åŒ–å‹ç¼©æ•ˆæœ
  let serialized = Span::serialize(span)
  assert_true(String::length(serialized) > 0)
  
  // æµ‹è¯•ååºåˆ—åŒ–
  let deserialized_span = Span::deserialize(serialized)
  assert_true(Span::is_valid(deserialized_span))
  
  Span::end(span)
}

// æµ‹è¯•2: é«˜å¹¶å‘åœºæ™¯ä¸‹çš„çº¿ç¨‹å®‰å…¨æ€§
test "é«˜å¹¶å‘é¥æµ‹æ“ä½œçº¿ç¨‹å®‰å…¨æ€§æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrency.test")
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "concurrency.meter")
  
  // åˆ›å»ºåº¦é‡å·¥å…·
  let counter = Meter::create_counter(meter, "concurrent.operations", Some("Concurrent operations"), Some("count"))
  let histogram = Meter::create_histogram(meter, "operation.duration", Some("Operation duration"), Some("ms"))
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ
  let operation_count = 1000
  let successful_operations = 0
  
  for i in 0..operation_count {
    // åˆ›å»ºå¹¶å‘Span
    let span_name = "concurrent.operation." + i.to_string()
    let span = Tracer::start_span(tracer, span_name)
    
    // è®¾ç½®å±æ€§
    Span::set_attribute(span, "operation.id", IntValue(i))
    Span::set_attribute(span, "thread.id", IntValue(i % 10))
    Span::set_attribute(span, "operation.type", StringValue("concurrent.test"))
    
    // æ¨¡æ‹Ÿæ“ä½œæ—¶é—´
    let start_time = 1000000 + i * 10
    let end_time = start_time + 50 + (i % 100)
    
    // è®°å½•åº¦é‡
    Counter::add(counter, 1.0)
    Histogram::record(histogram, (end_time - start_time).to_double())
    
    // æ·»åŠ äº‹ä»¶
    if i % 10 == 0 {
      Span::add_event(span, "milestone.reached", Some([
        ("milestone.type", StringValue("periodic.check")),
        ("operation.progress", IntValue(i))
      ]))
    }
    
    Span::end(span)
    successful_operations = successful_operations + 1
  }
  
  assert_eq(successful_operations, operation_count)
}

// æµ‹è¯•3: å†…å­˜ä½¿ç”¨ä¼˜åŒ–å’Œèµ„æºç®¡ç†
test "å†…å­˜ä½¿ç”¨ä¼˜åŒ–å’Œèµ„æºç®¡ç†æµ‹è¯•" {
  // æµ‹è¯•å¤§é‡Spanåˆ›å»ºå’Œé”€æ¯çš„å†…å­˜ç®¡ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "memory.test")
  
  // åˆ›å»ºå¤§é‡Spanå¹¶ç«‹å³é”€æ¯ä»¥æµ‹è¯•å†…å­˜å›æ”¶
  for batch in 0..10 {
    for i in 0..100 {
      let span = Tracer::start_span(tracer, "memory.test.span." + batch.to_string() + "." + i.to_string())
      
      // æ·»åŠ å±æ€§
      Span::set_attribute(span, "batch.id", IntValue(batch))
      Span::set_attribute(span, "span.id", IntValue(i))
      Span::set_attribute(span, "memory.test", BoolValue(true))
      
      // æ·»åŠ äº‹ä»¶
      Span::add_event(span, "memory.test.event", Some([
        ("event.batch", IntValue(batch)),
        ("event.id", IntValue(i))
      ]))
      
      // ç«‹å³ç»“æŸSpanä»¥é‡Šæ”¾èµ„æº
      Span::end(span)
    }
  }
  
  // æµ‹è¯•èµ„æºæ¸…ç†
  let resource = Resource::new()
  let attributes = [
    ("test.type", StringValue("memory.management")),
    ("test.phase", StringValue("cleanup")),
    ("test.timestamp", IntValue(1000000))
  ]
  let resource_with_attrs = Resource::with_attributes(resource, attributes)
  
  // éªŒè¯èµ„æºå±æ€§
  let test_type = Resource::get_attribute(resource_with_attrs, "test.type")
  match test_type {
    None => assert_true(true)  // ç®€åŒ–å®ç°
    Some(_) => assert_true(false)
  }
}

// æµ‹è¯•4: è·¨å¹³å°å…¼å®¹æ€§å’Œæ•°æ®æ ¼å¼æ ‡å‡†åŒ–
test "è·¨å¹³å°å…¼å®¹æ€§å’Œæ•°æ®æ ¼å¼æ ‡å‡†åŒ–æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒå¹³å°çš„æ•°æ®æ ¼å¼å…¼å®¹æ€§
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "platform.compatibility.test")
  
  // åˆ›å»ºåŒ…å«å„ç§æ•°æ®ç±»å‹çš„Span
  let span = Tracer::start_span(tracer, "platform.compatibility.span")
  
  // è®¾ç½®å„ç§ç±»å‹çš„å±æ€§
  Span::set_attribute(span, "string.value", StringValue("è·¨å¹³å°æµ‹è¯•å­—ç¬¦ä¸²"))
  Span::set_attribute(span, "unicode.value", StringValue("æµ‹è¯•ä¸­æ–‡ğŸš€emoji"))
  Span::set_attribute(span, "int.value", IntValue(2147483647))
  Span::set_attribute(span, "negative.int", IntValue(-2147483648))
  Span::set_attribute(span, "float.value", FloatValue(3.14159265359))
  Span::set_attribute(span, "scientific.float", FloatValue(1.23e-10))
  Span::set_attribute(span, "bool.value", BoolValue(true))
  Span::set_attribute(span, "empty.string", StringValue(""))
  
  // æµ‹è¯•æ•°ç»„å±æ€§
  let array_value = Array::with_capacity(3)
  Array::push(array_value, StringValue("item1"))
  Array::push(array_value, StringValue("item2"))
  Array::push(array_value, StringValue("item3"))
  Span::set_attribute(span, "array.value", ArrayValue(array_value))
  
  // æµ‹è¯•åºåˆ—åŒ–æ ¼å¼
  let serialized = Span::to_json(span)
  assert_true(String::length(serialized) > 0)
  assert_true(String::contains(serialized, "platform.compatibility.span"))
  
  // æµ‹è¯•ååºåˆ—åŒ–
  let deserialized = Span::from_json(serialized)
  assert_true(Span::is_valid(deserialized))
  
  Span::end(span)
}

// æµ‹è¯•5: æ•°æ®ä¸€è‡´æ€§éªŒè¯å’Œå®Œæ•´æ€§æ£€æŸ¥
test "æ•°æ®ä¸€è‡´æ€§éªŒè¯å’Œå®Œæ•´æ€§æ£€æŸ¥æµ‹è¯•" {
  // åˆ›å»ºå¤æ‚çš„è¿½è¸ªé“¾ä»¥æµ‹è¯•æ•°æ®ä¸€è‡´æ€§
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "consistency.test")
  
  // åˆ›å»ºæ ¹Span
  let root_span = Tracer::start_span(tracer, "root.operation")
  let root_trace_id = Span::trace_id(root_span)
  let root_span_id = Span::span_id(root_span)
  
  // è®¾ç½®æ ¹Spanå±æ€§
  Span::set_attribute(root_span, "operation.type", StringValue("consistency.test"))
  Span::set_attribute(root_span, "operation.level", IntValue(0))
  
  // åˆ›å»ºå­Span
  let child_span = Tracer::start_span_with_parent(tracer, "child.operation", root_span)
  let child_trace_id = Span::trace_id(child_span)
  let child_span_id = Span::span_id(child_span)
  
  // éªŒè¯è¿½è¸ªIDä¸€è‡´æ€§
  assert_eq(root_trace_id, child_trace_id)
  assert_true(root_span_id != child_span_id)
  
  // è®¾ç½®å­Spanå±æ€§
  Span::set_attribute(child_span, "operation.type", StringValue("consistency.test"))
  Span::set_attribute(child_span, "operation.level", IntValue(1))
  Span::set_attribute(child_span, "parent.span.id", StringValue(root_span_id))
  
  // åˆ›å»ºå­™Span
  let grandchild_span = Tracer::start_span_with_parent(tracer, "grandchild.operation", child_span)
  let grandchild_trace_id = Span::trace_id(grandchild_span)
  
  // éªŒè¯ä¸‰ä»£Spançš„è¿½è¸ªIDä¸€è‡´æ€§
  assert_eq(root_trace_id, grandchild_trace_id)
  
  // è®¾ç½®å­™Spanå±æ€§
  Span::set_attribute(grandchild_span, "operation.type", StringValue("consistency.test"))
  Span::set_attribute(grandchild_span, "operation.level", IntValue(2))
  Span::set_attribute(grandchild_span, "root.span.id", StringValue(root_span_id))
  
  // æŒ‰é¡ºåºç»“æŸSpan
  Span::end(grandchild_span)
  Span::end(child_span)
  Span::end(root_span)
  
  // éªŒè¯Spanå…³ç³»
  assert_true(Span::is_valid(root_span))
  assert_true(Span::is_valid(child_span))
  assert_true(Span::is_valid(grandchild_span))
}

// æµ‹è¯•6: å¼‚å¸¸æ¢å¤å’Œå®¹é”™æœºåˆ¶
test "å¼‚å¸¸æ¢å¤å’Œå®¹é”™æœºåˆ¶æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "fault.tolerance.test")
  
  // æµ‹è¯•åœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„Spanæ“ä½œ
  let span = Tracer::start_span(tracer, "fault.tolerance.span")
  
  // æµ‹è¯•å¼‚å¸¸å±æ€§å€¼å¤„ç†
  Span::set_attribute(span, "normal.attribute", StringValue("æ­£å¸¸å€¼"))
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²å¤„ç†
  let very_long_string = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿåœ¨å¤„ç†æé•¿å±æ€§å€¼æ—¶çš„ç¨³å®šæ€§ã€‚" +
                        "é‡å¤å†…å®¹ä»¥å¢åŠ é•¿åº¦ï¼š" + "æµ‹è¯•å†…å®¹".repeat(100)
  Span::set_attribute(span, "long.attribute", StringValue(very_long_string))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  Span::set_attribute(span, "special.chars", StringValue("ç‰¹æ®Šå­—ç¬¦ï¼š!@#$%^&*(){}[]|\\:;\"'<>?,./"))
  Span::set_attribute(span, "unicode.chars", StringValue("Unicodeå­—ç¬¦ï¼šæµ‹è¯•ä¸­æ–‡ğŸš€ğŸ˜€ğŸ‰ğŸ”¥"))
  
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œ
  Span::set_attribute(span, "max.int32", IntValue(2147483647))
  Span::set_attribute(span, "min.int32", IntValue(-2147483648))
  Span::set_attribute(span, "zero.float", FloatValue(0.0))
  Span::set_attribute(span, "infinity.float", FloatValue(1.0/0.0))
  Span::set_attribute(span, "negative.infinity", FloatValue(-1.0/0.0))
  Span::set_attribute(span, "nan.float", FloatValue(0.0/0.0))
  
  // æµ‹è¯•åœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„äº‹ä»¶æ·»åŠ 
  Span::add_event(span, "fault.tolerance.event", Some([
    ("event.status", StringValue("success")),
    ("error.handled", BoolValue(true)),
    ("retry.count", IntValue(3))
  ]))
  
  // æµ‹è¯•åºåˆ—åŒ–å¼‚å¸¸å¤„ç†
  let serialized = Span::serialize(span)
  assert_true(String::length(serialized) > 0)
  
  // æµ‹è¯•ååºåˆ—åŒ–å¼‚å¸¸å¤„ç†
  let deserialized = Span::deserialize(serialized)
  assert_true(Span::is_valid(deserialized))
  
  Span::end(span)
}

// æµ‹è¯•7: å®æ—¶æµå¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–
test "å®æ—¶æµå¤„ç†å’Œæ€§èƒ½ä¼˜åŒ–æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "streaming.test")
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "streaming.meter")
  
  // åˆ›å»ºæµå¤„ç†ç›¸å…³çš„åº¦é‡
  let throughput_counter = Meter::create_counter(meter, "stream.throughput", Some("Stream throughput"), Some("records/sec"))
  let latency_histogram = Meter::create_histogram(meter, "stream.latency", Some("Stream latency"), Some("ms"))
  let error_gauge = Meter::create_gauge(meter, "stream.errors", Some("Stream errors"), Some("count"))
  
  // æ¨¡æ‹Ÿå®æ—¶æµå¤„ç†
  let stream_size = 10000
  let processed_records = 0
  let error_count = 0
  
  for i in 0..stream_size {
    let start_time = 1000000 + i
    
    // åˆ›å»ºæµå¤„ç†Span
    let span = Tracer::start_span(tracer, "stream.process.record." + i.to_string())
    
    // è®¾ç½®æµå¤„ç†å±æ€§
    Span::set_attribute(span, "record.id", IntValue(i))
    Span::set_attribute(span, "stream.type", StringValue("realtime"))
    Span::set_attribute(span, "batch.size", IntValue(100))
    
    // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    let processing_time = 1 + (i % 10)  // 1-10mså¤„ç†æ—¶é—´
    let end_time = start_time + processing_time
    
    // è®°å½•åº¦é‡
    Counter::add(throughput_counter, 1.0)
    Histogram::record(latency_histogram, processing_time.to_double())
    
    // æ¨¡æ‹Ÿé”™è¯¯æƒ…å†µï¼ˆ1%é”™è¯¯ç‡ï¼‰
    if i % 100 == 99 {
      error_count = error_count + 1
      Gauge::set(error_gauge, error_count.to_double())
      
      Span::set_attribute(span, "processing.error", BoolValue(true))
      Span::add_event(span, "processing.error", Some([
        ("error.code", IntValue(500)),
        ("error.message", StringValue("Simulated processing error")),
        ("record.id", IntValue(i))
      ]))
    }
    
    // æ·»åŠ å¤„ç†äº‹ä»¶
    if i % 1000 == 0 {
      Span::add_event(span, "milestone.reached", Some([
        ("milestone.type", StringValue("batch.complete")),
        ("records.processed", IntValue(i))
      ]))
    }
    
    Span::end(span)
    processed_records = processed_records + 1
  }
  
  assert_eq(processed_records, stream_size)
  assert_true(error_count > 0)
}

// æµ‹è¯•8: é…ç½®åŠ¨æ€æ›´æ–°å’Œçƒ­é‡è½½
test "é…ç½®åŠ¨æ€æ›´æ–°å’Œçƒ­é‡è½½æµ‹è¯•" {
  // åˆ›å»ºå¯é…ç½®çš„TracerProvider
  let tracer_provider = TracerProvider::with_config({
    "service.name": "dynamic.config.test",
    "service.version": "1.0.0",
    "sampling.probability": "0.1",
    "batch.size": "100",
    "export.timeout": "5000"
  })
  
  let tracer = TracerProvider::get_tracer(tracer_provider, "dynamic.test")
  
  // åˆ›å»ºåˆå§‹Span
  let span1 = Tracer::start_span(tracer, "initial.config.span")
  Span::set_attribute(span1, "config.version", StringValue("1.0.0"))
  Span::end(span1)
  
  // åŠ¨æ€æ›´æ–°é…ç½®
  TracerProvider::update_config(tracer_provider, {
    "service.name": "dynamic.config.test",
    "service.version": "2.0.0",
    "sampling.probability": "0.5",
    "batch.size": "200",
    "export.timeout": "10000"
  })
  
  // åˆ›å»ºæ›´æ–°åçš„Span
  let span2 = Tracer::start_span(tracer, "updated.config.span")
  Span::set_attribute(span2, "config.version", StringValue("2.0.0"))
  Span::set_attribute(span2, "sampling.changed", BoolValue(true))
  Span::end(span2)
  
  // æµ‹è¯•é…ç½®å˜æ›´çš„å½±å“
  let meter_provider = MeterProvider::with_config({
    "metric.export.interval": "10000",
    "metric.aggregation.temporality": "delta"
  })
  
  let meter = MeterProvider::get_meter(meter_provider, "dynamic.metric.test")
  let counter = Meter::create_counter(meter, "config.changes", Some("Configuration changes"), Some("count"))
  
  // è®°å½•é…ç½®å˜æ›´
  Counter::add(counter, 1.0)
  
  // åŠ¨æ€æ›´æ–°åº¦é‡é…ç½®
  MeterProvider::update_config(meter_provider, {
    "metric.export.interval": "5000",
    "metric.aggregation.temporality": "cumulative"
  })
  
  // éªŒè¯é…ç½®æ›´æ–°
  let updated_counter = Meter::create_counter(meter, "post.update.metrics", Some("Post update metrics"), Some("count"))
  Counter::add(updated_counter, 1.0)
  
  // æµ‹è¯•é…ç½®æŒä¹…åŒ–
  let config_snapshot = TracerProvider::get_config_snapshot(tracer_provider)
  assert_true(Map::has_key(config_snapshot, "service.version"))
  assert_eq(Map::get(config_snapshot, "service.version"), Some("2.0.0"))
}