// Azimuth Premium Quality Test Suite
// é«˜è´¨é‡é¥æµ‹ç³»ç»Ÿæµ‹è¯•ç”¨ä¾‹ - æ¶µç›–æ ¸å¿ƒåŠŸèƒ½ã€è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†

// æµ‹è¯•1: é¥æµ‹ä¸Šä¸‹æ–‡ä¼ æ’­çš„å®Œæ•´æ€§
test "telemetry_context_propagation_integrity" {
  // åˆ›å»ºçˆ¶çº§ä¸Šä¸‹æ–‡
  let parent_ctx = azimuth::SpanContext::new("trace-001", "span-parent", true, "env=production,service=api")
  
  // åˆ›å»ºå­çº§spanå¹¶éªŒè¯ä¸Šä¸‹æ–‡ä¼ æ’­
  let child_span = azimuth::Span::new("child-operation", azimuth::Internal, parent_ctx)
  let child_ctx = azimuth::Span::get_context(child_span)
  
  // éªŒè¯trace IDçš„ä¸€è‡´æ€§
  assert_eq(azimuth::SpanContext::get_trace_id(child_ctx), "trace-001")
  assert_not_eq(azimuth::SpanContext::get_span_id(child_ctx), "span-parent")
  
  // éªŒè¯baggageé¡¹çš„æ­£ç¡®ä¼ æ’­
  let propagated_baggage = azimuth::SpanContext::get_baggage(child_ctx)
  assert_true(propagated_baggage.contains("env=production"))
  assert_true(propagated_baggage.contains("service=api"))
  
  // æµ‹è¯•æ·±å±‚åµŒå¥—çš„ä¸Šä¸‹æ–‡ä¼ æ’­
  let grandchild_span = azimuth::Span::new("grandchild-operation", azimuth::Client, child_ctx)
  let grandchild_ctx = azimuth::Span::get_context(grandchild_span)
  
  // éªŒè¯ä¸‰ä»£ä¹‹é—´çš„trace IDä¸€è‡´æ€§
  assert_eq(azimuth::SpanContext::get_trace_id(grandchild_ctx), "trace-001")
  assert_not_eq(azimuth::SpanContext::get_span_id(grandchild_ctx), "span-parent")
  assert_not_eq(azimuth::SpanContext::get_span_id(grandchild_ctx), azimuth::SpanContext::get_span_id(child_ctx))
}

// æµ‹è¯•2: æ€§èƒ½æŒ‡æ ‡èšåˆçš„å‡†ç¡®æ€§
test "metrics_aggregation_accuracy" {
  // åˆ›å»ºæµ‹è¯•ç”¨çš„æŒ‡æ ‡æ”¶é›†å™¨
  let metrics_collector = azimuth::Metrics::new_collector("test-service")
  
  // è®°å½•ä¸åŒç±»å‹çš„æŒ‡æ ‡
  azimuth::Metrics::record_counter(metrics_collector, "requests_total", 10, ["method:GET", "status:200"])
  azimuth::Metrics::record_counter(metrics_collector, "requests_total", 5, ["method:POST", "status:201"])
  azimuth::Metrics::record_counter(metrics_collector, "requests_total", 2, ["method:GET", "status:404"])
  
  azimuth::Metrics::record_histogram(metrics_collector, "response_time_ms", 150.0, ["endpoint:/api/data"])
  azimuth::Metrics::record_histogram(metrics_collector, "response_time_ms", 200.0, ["endpoint:/api/data"])
  azimuth::Metrics::record_histogram(metrics_collector, "response_time_ms", 100.0, ["endpoint:/api/data"])
  
  azimuth::Metrics::record_gauge(metrics_collector, "active_connections", 25)
  azimuth::Metrics::record_gauge(metrics_collector, "active_connections", 30)
  azimuth::Metrics::record_gauge(metrics_collector, "active_connections", 20)
  
  // éªŒè¯è®¡æ•°å™¨èšåˆ
  let get_counter = azimuth::Metrics::get_counter(metrics_collector, "requests_total", ["method:GET"])
  assert_eq(get_counter, 12)  // 10 + 2
  
  let post_counter = azimuth::Metrics::get_counter(metrics_collector, "requests_total", ["method:POST"])
  assert_eq(post_counter, 5)
  
  // éªŒè¯ç›´æ–¹å›¾ç»Ÿè®¡
  let histogram_stats = azimuth::Metrics::get_histogram_stats(metrics_collector, "response_time_ms", ["endpoint:/api/data"])
  assert_eq(histogram_stats.count, 3)
  assert_eq(histogram_stats.sum, 450.0)
  assert_eq(histogram_stats.min, 100.0)
  assert_eq(histogram_stats.max, 200.0)
  
  // éªŒè¯ä»ªè¡¨ç›˜æœ€æ–°å€¼
  let current_gauge = azimuth::Metrics::get_gauge(metrics_collector, "active_connections")
  assert_eq(current_gauge, 20)  // åº”è¯¥æ˜¯æœ€åè®¾ç½®çš„å€¼
}

// æµ‹è¯•3: åˆ†å¸ƒå¼è¿½è¸ªçš„ä¸€è‡´æ€§éªŒè¯
test "distributed_tracing_consistency" {
  // æ¨¡æ‹Ÿåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„å¤šä¸ªæœåŠ¡
  let service_a_trace = azimuth::Trace::start("service-a-operation")
  let service_a_context = azimuth::Trace::get_context(service_a_trace)
  
  // æœåŠ¡Aè°ƒç”¨æœåŠ¡B
  let service_b_headers = azimuth::Propagator::inject(service_a_context)
  let service_b_context = azimuth::Propagator::extract(service_b_headers)
  let service_b_trace = azimuth::Trace::continue("service-b-operation", service_b_context)
  
  // æœåŠ¡Bè°ƒç”¨æœåŠ¡C
  let service_c_headers = azimuth::Propagator::inject(azimuth::Trace::get_context(service_b_trace))
  let service_c_context = azimuth::Propagator::extract(service_c_headers)
  let service_c_trace = azimuth::Trace::continue("service-c-operation", service_c_context)
  
  // éªŒè¯æ‰€æœ‰æœåŠ¡çš„trace IDä¸€è‡´
  let trace_id_a = azimuth::SpanContext::get_trace_id(azimuth::Trace::get_context(service_a_trace))
  let trace_id_b = azimuth::SpanContext::get_trace_id(azimuth::Trace::get_context(service_b_trace))
  let trace_id_c = azimuth::SpanContext::get_trace_id(azimuth::Trace::get_context(service_c_trace))
  
  assert_eq(trace_id_a, trace_id_b)
  assert_eq(trace_id_b, trace_id_c)
  
  // éªŒè¯çˆ¶å­å…³ç³»
  let span_a = azimuth::Trace::get_root_span(service_a_trace)
  let span_b = azimuth::Trace::get_root_span(service_b_trace)
  let span_c = azimuth::Trace::get_root_span(service_c_trace)
  
  let parent_b = azimuth::Span::get_parent_span_id(span_b)
  let parent_c = azimuth::Span::get_parent_span_id(span_c)
  
  assert_eq(parent_b, azimuth::Span::get_span_id(span_a))
  assert_eq(parent_c, azimuth::Span::get_span_id(span_b))
  
  // å®Œæˆè¿½è¸ªå¹¶éªŒè¯å®Œæ•´æ€§
  azimuth::Trace::finish(service_a_trace)
  azimuth::Trace::finish(service_b_trace)
  azimuth::Trace::finish(service_c_trace)
  
  // éªŒè¯æ‰€æœ‰spanéƒ½è¢«æ­£ç¡®è®°å½•
  let completed_spans = azimuth::Trace::get_completed_spans()
  assert_eq(completed_spans.length(), 3)
}

// æµ‹è¯•4: é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶
test "error_handling_and_recovery" {
  // æµ‹è¯•spanåˆ›å»ºæ—¶çš„é”™è¯¯å¤„ç†
  let invalid_span_result = azimuth::Span::new("", azimuth::Internal, azimuth::SpanContext::empty())
  match invalid_span_result {
    Ok(_) => assert_false(true, "Expected error for empty span name")
    Err(error) => assert_true(error.contains("span name cannot be empty"))
  }
  
  // æµ‹è¯•å±æ€§è®¾ç½®çš„é”™è¯¯å¤„ç†
  let valid_span = azimuth::Span::new("valid-operation", azimuth::Internal, azimuth::SpanContext::empty()) |> unwrap
  let null_key_result = azimuth::Span::set_attribute(valid_span, "", StringValue("value"))
  match null_key_result {
    Ok(_) => assert_false(true, "Expected error for empty attribute key")
    Err(error) => assert_true(error.contains("attribute key cannot be empty"))
  }
  
  // æµ‹è¯•è¿‡é•¿çš„å±æ€§å€¼å¤„ç†
  let long_value = "x" * 10000  // åˆ›å»ºä¸€ä¸ªå¾ˆé•¿çš„å­—ç¬¦ä¸²
  let long_value_result = azimuth::Span::set_attribute(valid_span, "long.key", StringValue(long_value))
  match long_value_result {
    Ok(_) => assert_false(true, "Expected error for attribute value too long")
    Err(error) => assert_true(error.contains("attribute value exceeds maximum length"))
  }
  
  // æµ‹è¯•æ¢å¤æœºåˆ¶ - ç¡®ä¿é”™è¯¯åspanä»ç„¶å¯ç”¨
  let recovery_result = azimuth::Span::set_attribute(valid_span, "recovery.test", StringValue("success"))
  match recovery_result {
    Ok(_) => assert_true(true, "Span should recover from previous errors")
    Err(_) => assert_false(true, "Span should be functional after error handling")
  }
}

// æµ‹è¯•5: å¹¶å‘å®‰å…¨æ€§éªŒè¯
test "concurrent_safety_verification" {
  // åˆ›å»ºå…±äº«çš„é¥æµ‹èµ„æº
  let shared_collector = azimuth::Metrics::new_collector("concurrent-test")
  let shared_tracer = azimuth::Tracer::new("concurrent-service")
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ
  let concurrent_operations = []
  
  // å¹¶å‘è®°å½•æŒ‡æ ‡
  for i in range(0, 100) {
    let operation = {
      let metric_name = "concurrent_counter_" + i.to_string()
      azimuth::Metrics::record_counter(shared_collector, metric_name, 1, ["thread:" + i.to_string()])
    }
    concurrent_operations.push(operation)
  }
  
  // å¹¶å‘åˆ›å»ºspan
  for i in range(0, 50) {
    let operation = {
      let span_name = "concurrent_span_" + i.to_string()
      let span = azimuth::Tracer::start_span(shared_tracer, span_name) |> unwrap
      azimuth::Span::set_attribute(span, "concurrent.id", IntValue(i)) |> ignore
      azimuth::Tracer::finish_span(shared_tracer, span)
    }
    concurrent_operations.push(operation)
  }
  
  // æ‰§è¡Œæ‰€æœ‰å¹¶å‘æ“ä½œï¼ˆåœ¨å®é™…å®ç°ä¸­è¿™é‡Œä¼šä½¿ç”¨çœŸæ­£çš„å¹¶å‘æœºåˆ¶ï¼‰
  for operation in concurrent_operations {
    operation()
  }
  
  // éªŒè¯æ•°æ®å®Œæ•´æ€§
  let total_metrics = azimuth::Metrics::get_all_metrics(shared_collector)
  assert_eq(total_metrics.length(), 100)  // ç¡®ä¿æ‰€æœ‰æŒ‡æ ‡éƒ½è¢«è®°å½•
  
  let total_spans = azimuth::Tracer::get_completed_spans(shared_tracer)
  assert_eq(total_spans.length(), 50)  // ç¡®ä¿æ‰€æœ‰spanéƒ½è¢«å®Œæˆ
  
  // éªŒè¯æ²¡æœ‰æ•°æ®æŸå
  for metric in total_metrics {
    let metric_value = azimuth::Metrics::get_metric_value(shared_collector, metric.name)
    assert_eq(metric_value, 1)  // æ¯ä¸ªæŒ‡æ ‡åº”è¯¥åªè¢«è®°å½•ä¸€æ¬¡
  }
}

// æµ‹è¯•6: å†…å­˜ç®¡ç†å’Œèµ„æºæ¸…ç†
test "memory_management_and_cleanup" {
  // åˆ›å»ºå¤§é‡ä¸´æ—¶èµ„æº
  let temp_resources = []
  
  for i in range(0, 1000) {
    let temp_span = azimuth::Span::new("temp-span-" + i.to_string(), azimuth::Internal, azimuth::SpanContext::empty()) |> unwrap
    let temp_metrics = azimuth::Metrics::new_collector("temp-collector-" + i.to_string())
    
    // æ·»åŠ ä¸€äº›å±æ€§å’ŒæŒ‡æ ‡
    azimuth::Span::set_attribute(temp_span, "temp.id", IntValue(i)) |> ignore
    azimuth::Metrics::record_counter(temp_metrics, "temp.counter", i, [])
    
    temp_resources.push((temp_span, temp_metrics))
  }
  
  // éªŒè¯èµ„æºåˆ›å»ºæˆåŠŸ
  assert_eq(temp_resources.length(), 1000)
  
  // æ¸…ç†æ‰€æœ‰èµ„æº
  for (span, collector) in temp_resources {
    azimuth::Span::finish(span)
    azimuth::Metrics::cleanup(collector)
  }
  
  // éªŒè¯èµ„æºè¢«æ­£ç¡®æ¸…ç†
  let active_spans = azimuth::Span::get_active_count()
  assert_eq(active_spans, 0)  // æ‰€æœ‰spanåº”è¯¥è¢«æ¸…ç†
  
  let active_collectors = azimuth::Metrics::get_active_collector_count()
  assert_eq(active_collectors, 0)  // æ‰€æœ‰æ”¶é›†å™¨åº”è¯¥è¢«æ¸…ç†
  
  // éªŒè¯å†…å­˜æ²¡æœ‰æ³„æ¼ï¼ˆåœ¨å®é™…å®ç°ä¸­è¿™é‡Œä¼šæ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µï¼‰
  let memory_usage = azimuth::System::get_memory_usage()
  assert_true(memory_usage < 100 * 1024 * 1024)  // åº”è¯¥å°äº100MB
}

// æµ‹è¯•7: é…ç½®åŠ¨æ€æ›´æ–°æµ‹è¯•
test "dynamic_configuration_updates" {
  // åˆ›å»ºåˆå§‹é…ç½®
  let initial_config = azimuth::Config::new()
  azimuth::Config::set_sampling_rate(initial_config, 0.1)  // 10%é‡‡æ ·ç‡
  azimuth::Config::set_max_attributes(initial_config, 100)
  azimuth::Config::set_max_events(initial_config, 50)
  
  // åˆ›å»ºä½¿ç”¨åˆå§‹é…ç½®çš„tracer
  let tracer = azimuth::Tracer::with_config(initial_config)
  
  // éªŒè¯åˆå§‹é…ç½®ç”Ÿæ•ˆ
  assert_eq(azimuth::Tracer::get_sampling_rate(tracer), 0.1)
  assert_eq(azimuth::Tracer::get_max_attributes(tracer), 100)
  assert_eq(azimuth::Tracer::get_max_events(tracer), 50)
  
  // åŠ¨æ€æ›´æ–°é…ç½®
  azimuth::Config::set_sampling_rate(initial_config, 0.5)  // æ›´æ–°åˆ°50%é‡‡æ ·ç‡
  azimuth::Config::set_max_attributes(initial_config, 200)
  azimuth::Config::set_max_events(initial_config, 100)
  
  // é€šçŸ¥traceré…ç½®å·²æ›´æ–°
  azimuth::Tracer::update_config(tracer, initial_config)
  
  // éªŒè¯é…ç½®æ›´æ–°ç”Ÿæ•ˆ
  assert_eq(azimuth::Tracer::get_sampling_rate(tracer), 0.5)
  assert_eq(azimuth::Tracer::get_max_attributes(tracer), 200)
  assert_eq(azimuth::Tracer::get_max_events(tracer), 100)
  
  // æµ‹è¯•é…ç½®éªŒè¯
  let invalid_config_result = azimuth::Config::set_sampling_rate(initial_config, 1.5)  // æ— æ•ˆé‡‡æ ·ç‡
  match invalid_config_result {
    Ok(_) => assert_false(true, "Expected error for invalid sampling rate")
    Err(error) => assert_true(error.contains("sampling rate must be between 0 and 1"))
  }
  
  // æµ‹è¯•é…ç½®æŒä¹…åŒ–
  let config_data = azimuth::Config::serialize(initial_config)
  let restored_config = azimuth::Config::deserialize(config_data) |> unwrap
  
  assert_eq(azimuth::Config::get_sampling_rate(restored_config), 0.5)
  assert_eq(azimuth::Config::get_max_attributes(restored_config), 200)
  assert_eq(azimuth::Config::get_max_events(restored_config), 100)
}

// æµ‹è¯•8: åºåˆ—åŒ–å’Œååºåˆ—åŒ–å®Œæ•´æ€§
test "serialization_deserialization_integrity" {
  // åˆ›å»ºå¤æ‚çš„é¥æµ‹æ•°æ®
  let original_span = azimuth::Span::new("serialization-test", azimuth::Server, azimuth::SpanContext::new("trace-123", "span-456", true, "env=test")) |> unwrap
  
  // æ·»åŠ å„ç§ç±»å‹çš„å±æ€§
  azimuth::Span::set_attribute(original_span, "string.attr", StringValue("test value")) |> ignore
  azimuth::Span::set_attribute(original_span, "int.attr", IntValue(42)) |> ignore
  azimuth::Span::set_attribute(original_span, "float.attr", FloatValue(3.14159)) |> ignore
  azimuth::Span::set_attribute(original_span, "bool.attr", BoolValue(true)) |> ignore
  azimuth::Span::set_attribute(original_span, "array.attr", ArrayStringValue(["item1", "item2", "item3"])) |> ignore
  
  // æ·»åŠ äº‹ä»¶
  azimuth::Span::add_event(original_span, "test-event", [
    ("event.key1", StringValue("event.value1")),
    ("event.key2", IntValue(123))
  ])
  
  // è®¾ç½®çŠ¶æ€
  azimuth::Span::set_status(original_span, azimuth::Status::Ok)
  
  // åºåˆ—åŒ–span
  let serialized_data = azimuth::Span::serialize(original_span)
  assert_true(serialized_data.length() > 0)
  
  // ååºåˆ—åŒ–span
  let deserialized_span = azimuth::Span::deserialize(serialized_data) |> unwrap
  
  // éªŒè¯ååºåˆ—åŒ–çš„å®Œæ•´æ€§
  assert_eq(azimuth::Span::get_name(deserialized_span), azimuth::Span::get_name(original_span))
  assert_eq(azimuth::Span::get_kind(deserialized_span), azimuth::Span::get_kind(original_span))
  
  let original_ctx = azimuth::Span::get_context(original_span)
  let deserialized_ctx = azimuth::Span::get_context(deserialized_span)
  
  assert_eq(azimuth::SpanContext::get_trace_id(deserialized_ctx), azimuth::SpanContext::get_trace_id(original_ctx))
  assert_eq(azimuth::SpanContext::get_span_id(deserialized_ctx), azimuth::SpanContext::get_span_id(original_ctx))
  
  // éªŒè¯å±æ€§å®Œæ•´æ€§
  let original_attrs = azimuth::Span::get_attributes(original_span)
  let deserialized_attrs = azimuth::Span::get_attributes(deserialized_span)
  
  assert_eq(original_attrs.length(), deserialized_attrs.length())
  
  for (key, value) in original_attrs {
    let deserialized_value = azimuth::Attributes::get(deserialized_attrs, key) |> unwrap
    match (value, deserialized_value) {
      (StringValue(orig), StringValue(deser)) => assert_eq(orig, deser)
      (IntValue(orig), IntValue(deser)) => assert_eq(orig, deser)
      (FloatValue(orig), FloatValue(deser)) => assert_eq(orig, deser)
      (BoolValue(orig), BoolValue(deser)) => assert_eq(orig, deser)
      (ArrayStringValue(orig), ArrayStringValue(deser)) => {
        assert_eq(orig.length(), deser.length())
        for i in range(0, orig.length()) {
          assert_eq(orig[i], deser[i])
        }
      }
      _ => assert_false(true, "Attribute type mismatch")
    }
  }
  
  // éªŒè¯äº‹ä»¶å®Œæ•´æ€§
  let original_events = azimuth::Span::get_events(original_span)
  let deserialized_events = azimuth::Span::get_events(deserialized_span)
  
  assert_eq(original_events.length(), deserialized_events.length())
  assert_eq(azimuth::Event::get_name(original_events[0]), azimuth::Event::get_name(deserialized_events[0]))
  
  // éªŒè¯çŠ¶æ€å®Œæ•´æ€§
  assert_eq(azimuth::Span::get_status(original_span), azimuth::Span::get_status(deserialized_span))
}

// æµ‹è¯•9: å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æ–‡æœ¬å¤„ç†
test "internationalization_localization_handling" {
  // æµ‹è¯•å¤šè¯­è¨€å±æ€§å€¼
  let multilingual_span = azimuth::Span::new("å›½é™…åŒ–æµ‹è¯•", azimuth::Internal, azimuth::SpanContext::empty()) |> unwrap
  
  // æ·»åŠ å„ç§è¯­è¨€çš„å±æ€§
  azimuth::Span::set_attribute(multilingual_span, "chinese.name", StringValue("å¼ ä¸‰")) |> ignore
  azimuth::Span::set_attribute(multilingual_span, "japanese.name", StringValue("ç”°ä¸­å¤ªéƒ")) |> ignore
  azimuth::Span::set_attribute(multilingual_span, "korean.name", StringValue("ê¹€ì² ìˆ˜")) |> ignore
  azimuth::Span::set_attribute(multilingual_span, "arabic.name", StringValue("Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯")) |> ignore
  azimuth::Span::set_attribute(multilingual_span, "russian.name", StringValue("Ğ˜Ğ²Ğ°Ğ½ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²")) |> ignore
  azimuth::Span::set_attribute(multilingual_span, "emoji.test", StringValue("ğŸš€ğŸŒŸğŸ’»ğŸ”§")) |> ignore
  
  // æµ‹è¯•æ··åˆè¯­è¨€çš„æ–‡æœ¬
  let mixed_text = "Hello ä¸–ç•Œ! ã“ã‚“ã«ã¡ã¯ ì•ˆë…•í•˜ì„¸ìš”! Ù…Ø±Ø­Ø¨Ø§ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚!"
  azimuth::Span::set_attribute(multilingual_span, "mixed.text", StringValue(mixed_text)) |> ignore
  
  // æµ‹è¯•ä»å³åˆ°å·¦çš„æ–‡æœ¬
  let rtl_text = "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"
  azimuth::Span::set_attribute(multilingual_span, "rtl.text", StringValue(rtl_text)) |> ignore
  
  // éªŒè¯æ–‡æœ¬å¤„ç†æ­£ç¡®æ€§
  let attrs = azimuth::Span::get_attributes(multilingual_span)
  
  let chinese_name = azimuth::Attributes::get(attrs, "chinese.name") |> unwrap
  match chinese_name {
    StringValue(name) => assert_eq(name, "å¼ ä¸‰")
    _ => assert_false(true, "Expected StringValue")
  }
  
  let emoji_test = azimuth::Attributes::get(attrs, "emoji.test") |> unwrap
  match emoji_test {
    StringValue(emojis) => assert_true(emojis.contains("ğŸš€"))
    _ => assert_false(true, "Expected StringValue")
  }
  
  let mixed_text_attr = azimuth::Attributes::get(attrs, "mixed.text") |> unwrap
  match mixed_text_attr {
    StringValue(text) => {
      assert_true(text.contains("Hello"))
      assert_true(text.contains("ä¸–ç•Œ"))
      assert_true(text.contains("ã“ã‚“ã«ã¡ã¯"))
      assert_true(text.contains("ì•ˆë…•í•˜ì„¸ìš”"))
    }
    _ => assert_false(true, "Expected StringValue")
  }
  
  // æµ‹è¯•æ–‡æœ¬é•¿åº¦å’Œå­—èŠ‚é•¿åº¦å¤„ç†
  let chinese_attr = azimuth::Attributes::get(attrs, "chinese.name") |> unwrap
  match chinese_attr {
    StringValue(text) => {
      assert_eq(text.length(), 2)  // å­—ç¬¦é•¿åº¦
      assert_eq(text.byte_length(), 6)  // UTF-8å­—èŠ‚é•¿åº¦
    }
    _ => assert_false(true, "Expected StringValue")
  }
  
  // æµ‹è¯•æœ¬åœ°åŒ–é”™è¯¯æ¶ˆæ¯
  let localized_error = azimuth::Error::new_with_localized_message("validation.error", "zh-CN", "éªŒè¯å¤±è´¥")
  assert_eq(azimuth::Error::get_message(localized_error, "zh-CN"), "éªŒè¯å¤±è´¥")
  assert_eq(azimuth::Error::get_message(localized_error, "en-US"), "Validation error")
  assert_eq(azimuth::Error::get_message(localized_error, "ja-JP"), "æ¤œè¨¼ã‚¨ãƒ©ãƒ¼")
}

// æµ‹è¯•10: èµ„æºç”Ÿå‘½å‘¨æœŸå’Œä¾èµ–ç®¡ç†
test "resource_lifecycle_and_dependency_management" {
  // åˆ›å»ºèµ„æºä¾èµ–å›¾
  let root_resource = azimuth::Resource::new("root-service", "v1.0.0")
  let child_resource1 = azimuth::Resource::with_parent("child-service-1", "v1.1.0", root_resource)
  let child_resource2 = azimuth::Resource::with_parent("child-service-2", "v1.2.0", root_resource)
  let grandchild_resource = azimuth::Resource::with_parent("grandchild-service", "v1.0.1", child_resource1)
  
  // éªŒè¯èµ„æºå±‚æ¬¡ç»“æ„
  assert_eq(azimuth::Resource::get_parent(root_resource), None)
  assert_eq(azimuth::Resource::get_parent(child_resource1), Some(root_resource))
  assert_eq(azimuth::Resource::get_parent(child_resource2), Some(root_resource))
  assert_eq(azimuth::Resource::get_parent(grandchild_resource), Some(child_resource1))
  
  // éªŒè¯èµ„æºä¾èµ–å…³ç³»
  let root_dependencies = azimuth::Resource::get_dependencies(root_resource)
  assert_eq(root_dependencies.length(), 2)  // ä¸¤ä¸ªå­èµ„æº
  assert_true(root_dependencies.contains(child_resource1))
  assert_true(root_dependencies.contains(child_resource2))
  
  let child1_dependencies = azimuth::Resource::get_dependencies(child_resource1)
  assert_eq(child1_dependencies.length(), 1)  // ä¸€ä¸ªå­™èµ„æº
  assert_true(child1_dependencies.contains(grandchild_resource))
  
  // æµ‹è¯•èµ„æºçŠ¶æ€ç®¡ç†
  assert_eq(azimuth::Resource::get_state(root_resource), azimuth::ResourceState::Initialized)
  assert_eq(azimuth::Resource::get_state(child_resource1), azimuth::ResourceState::Initialized)
  
  // å¯åŠ¨æ ¹èµ„æºï¼ˆåº”è¯¥çº§è”å¯åŠ¨æ‰€æœ‰å­èµ„æºï¼‰
  azimuth::Resource::start(root_resource)
  assert_eq(azimuth::Resource::get_state(root_resource), azimuth::ResourceState::Running)
  assert_eq(azimuth::Resource::get_state(child_resource1), azimuth::ResourceState::Running)
  assert_eq(azimuth::Resource::get_state(child_resource2), azimuth::ResourceState::Running)
  assert_eq(azimuth::Resource::get_state(grandchild_resource), azimuth::ResourceState::Running)
  
  // æµ‹è¯•èµ„æºå¥åº·æ£€æŸ¥
  let root_health = azimuth::Resource::check_health(root_resource)
  assert_eq(root_health.status, azimuth::HealthStatus::Healthy)
  
  // æ¨¡æ‹Ÿå­èµ„æºæ•…éšœ
  azimuth::Resource::simulate_failure(child_resource2, "Connection timeout")
  let child2_health = azimuth::Resource::check_health(child_resource2)
  assert_eq(child2_health.status, azimuth::HealthStatus::Unhealthy)
  assert_eq(child2_health.error, "Connection timeout")
  
  // éªŒè¯æ•…éšœä¼ æ’­
  let root_health_after_failure = azimuth::Resource::check_health(root_resource)
  assert_eq(root_health_after_failure.status, azimuth::HealthStatus::Degraded)
  
  // æµ‹è¯•èµ„æºä¼˜é›…å…³é—­
  let shutdown_result = azimuth::Resource::shutdown_gracefully(root_resource, 5000)  // 5ç§’è¶…æ—¶
  match shutdown_result {
    Ok(_) => {
      assert_eq(azimuth::Resource::get_state(root_resource), azimuth::ResourceState::Stopped)
      assert_eq(azimuth::Resource::get_state(child_resource1), azimuth::ResourceState::Stopped)
      assert_eq(azimuth::Resource::get_state(child_resource2), azimuth::ResourceState::Stopped)
      assert_eq(azimuth::Resource::get_state(grandchild_resource), azimuth::ResourceState::Stopped)
    }
    Err(error) => assert_false(true, "Graceful shutdown should succeed: " + error)
  }
  
  // éªŒè¯èµ„æºæ¸…ç†
  let active_resources = azimuth::Resource::get_active_resources()
  assert_eq(active_resources.length(), 0)  // æ‰€æœ‰èµ„æºåº”è¯¥è¢«æ¸…ç†
}