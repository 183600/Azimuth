// Enhanced Azimuth æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•ï¼Œä¸“æ³¨äºæ ¸å¿ƒåŠŸèƒ½çš„æ·±åº¦æµ‹è¯•

test "string_unicode_comprehensive" {
  // ç»¼åˆUnicodeå­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, ğŸ‘‹ğŸ½!", greet("ğŸ‘‹ğŸ½"))
  assert_eq_string("Hello, ğŸš€ğŸŒ™!", greet("ğŸš€ğŸŒ™"))
  assert_eq_string("Hello, Î±Î²Î³!", greet("Î±Î²Î³"))
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
}

test "mathematical_associativity_laws" {
  // æ•°å­¦ç»“åˆå¾‹æµ‹è¯•
  // åŠ æ³•ç»“åˆå¾‹ï¼š(a + b) + c = a + (b + c)
  let a = 100
  let b = 200
  let c = 300
  
  let left_assoc = add(add(a, b), c)
  let right_assoc = add(a, add(b, c))
  assert_eq(left_assoc, right_assoc)
  
  // ä¹˜æ³•ç»“åˆå¾‹ï¼š(a Ã— b) Ã— c = a Ã— (b Ã— c)
  let left_mul = multiply(multiply(a, b), c)
  let right_mul = multiply(a, multiply(b, c))
  assert_eq(left_mul, right_mul)
}

test "boundary_comprehensive_stress" {
  // ç»¼åˆè¾¹ç•Œå€¼å‹åŠ›æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼çš„å„ç§ç»„åˆ
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, add(0, max_val))
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(max_val, multiply(1, max_val))
  assert_eq(0, multiply(max_val, 0))
  
  // æœ€å°å€¼çš„å„ç§ç»„åˆ
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, add(0, min_val))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(1, min_val))
  assert_eq(0, multiply(min_val, 0))
}

test "negative_number_specialized" {
  // è´Ÿæ•°ä¸“é¡¹æµ‹è¯•
  // è´Ÿæ•°åŠ æ³•æµ‹è¯•
  assert_eq(-10, add(-3, -7))
  assert_eq(-5, add(-8, 3))
  assert_eq(5, add(-3, 8))
  assert_eq(0, add(-5, 5))
  
  // è´Ÿæ•°ä¹˜æ³•æµ‹è¯•
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(-3, 5))
  assert_eq(-15, multiply(3, -5))
  assert_eq(0, multiply(-5, 0))
  
  // è´Ÿæ•°é™¤æ³•æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-7, 3))
  assert_eq(-3, divide_with_ceil(-8, 3))
  assert_eq(2, divide_with_ceil(-7, -3))
  assert_eq(3, divide_with_ceil(-8, -3))
}

test "zero_value_edge_cases" {
  // é›¶å€¼è¾¹ç•Œæƒ…å†µæµ‹è¯•
  // é›¶å€¼åŠ æ³•
  assert_eq(5, add(5, 0))
  assert_eq(5, add(0, 5))
  assert_eq(-5, add(-5, 0))
  assert_eq(-5, add(0, -5))
  assert_eq(0, add(0, 0))
  
  // é›¶å€¼ä¹˜æ³•
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(0, 0))
  
  // é›¶å€¼é™¤æ³•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "complex_expression_evaluation" {
  // å¤æ‚è¡¨è¾¾å¼è®¡ç®—æµ‹è¯•
  // åµŒå¥—ç®—æœ¯è¡¨è¾¾å¼
  let expr1 = add(multiply(10, 5), multiply(3, 2))
  assert_eq(56, expr1)  // 10*5 + 3*2 = 50 + 6 = 56
  
  let expr2 = multiply(add(7, 3), add(4, 2))
  assert_eq(60, expr2)  // (7+3)*(4+2) = 10*6 = 60
  
  let expr3 = divide_with_ceil(add(multiply(4, 5), 3), 2)
  assert_eq(12, expr3)  // ceil((4*5 + 3)/2) = ceil(23/2) = 12
  
  // å¤šå±‚åµŒå¥—
  let expr4 = add(multiply(divide_with_ceil(15, 4), 3), 5)
  assert_eq(17, expr4)  // ceil(15/4)*3 + 5 = 4*3 + 5 = 17
}

test "real_world_application_scenarios" {
  // å®é™…åº”ç”¨åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·ï¼ˆå«ç¨ï¼‰
  let item1 = 299
  let item2 = 399
  let item3 = 199
  let subtotal = add(add(item1, item2), item3)
  let tax = divide_with_ceil(subtotal, 10)  // 10%ç¨
  let total = add(subtotal, tax)
  assert_eq(986, total)  // 897 + ceil(897/10) = 897 + 90 = 987
  
  // åœºæ™¯2ï¼šè®¡ç®—å¹³å‡åˆ†ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let score1 = 87
  let score2 = 93
  let score3 = 91
  let score4 = 89
  let total_score = add(add(add(score1, score2), score3), score4)
  let average = divide_with_ceil(total_score, 4)
  assert_eq(91, average)  // ceil(360/4) = ceil(90) = 90
  
  // åœºæ™¯3ï¼šæ‰¹é‡è®¡ç®—æŠ˜æ‰£ä»·æ ¼
  let original_price = 1599
  let discount_rate = 3  // 1/3 = 33%æŠ˜æ‰£
  let discounted_price = divide_with_ceil(multiply(original_price, 2), 3)
  assert_eq(1066, discounted_price)  // ceil(1599*2/3) = ceil(3198/3) = 1066
}

test "overflow_protection_comprehensive" {
  // æº¢å‡ºä¿æŠ¤ç»¼åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // åŠ æ³•æº¢å‡ºæµ‹è¯•
  let overflow_add1 = add(max_val, 1)
  let overflow_add2 = add(max_val, max_val)
  let overflow_add3 = add(min_val, -1)
  let overflow_add4 = add(min_val, min_val)
  
  assert_true(overflow_add1 == max_val || overflow_add1 == min_val)
  assert_true(overflow_add2 == max_val || overflow_add2 == min_val)
  assert_true(overflow_add3 == max_val || overflow_add3 == min_val)
  assert_true(overflow_add4 == max_val || overflow_add4 == min_val)
  
  // ä¹˜æ³•æº¢å‡ºæµ‹è¯•
  let overflow_mul1 = multiply(max_val, 2)
  let overflow_mul2 = multiply(46341, 46341)  // sqrt(max_val) + 1
  let overflow_mul3 = multiply(min_val, -1)  // ç‰¹æ®Šæƒ…å†µ
  let overflow_mul4 = multiply(min_val, 2)
  
  assert_true(overflow_mul1 == max_val || overflow_mul1 == min_val)
  assert_true(overflow_mul2 == max_val || overflow_mul2 == min_val)
  assert_eq(min_val, overflow_mul3)  // æœ€å°å€¼ä¹˜ä»¥-1çš„ç‰¹æ®Šæƒ…å†µ
  assert_true(overflow_mul4 == max_val || overflow_mul4 == min_val)
}

test "performance_critical_operations" {
  // æ€§èƒ½å…³é”®æ“ä½œæµ‹è¯•
  // å¤§é‡è¿ç»­æ“ä½œ
  let base = 1000
  let result1 = add(add(add(base, 500), 250), 125)
  assert_eq(1875, result1)
  
  let result2 = multiply(multiply(multiply(base, 2), 3), 4)
  assert_eq(24000, result2)
  
  // æ··åˆæ“ä½œæ€§èƒ½æµ‹è¯•
  let result3 = add(multiply(divide_with_ceil(1000, 3), 2), 5)
  assert_eq(675, result3)  // ceil(1000/3)*2 + 5 = 334*2 + 5 = 673
  
  // å¾ªç¯å¼æ“ä½œæ¨¡æ‹Ÿ
  let accumulator = 0
  let acc1 = add(accumulator, 100)
  let acc2 = add(acc1, 200)
  let acc3 = add(acc2, 300)
  let acc4 = add(acc3, 400)
  assert_eq(1000, acc4)
}

test "function_chaining_composition" {
  // å‡½æ•°é“¾å¼è°ƒç”¨å’Œç»„åˆæµ‹è¯•
  // ç®€å•é“¾å¼è°ƒç”¨
  let chain1 = add(multiply(5, 3), 2)
  assert_eq(17, chain1)  // 5*3 + 2 = 17
  
  let chain2 = multiply(add(10, 5), 2)
  assert_eq(30, chain2)  // (10+5)*2 = 30
  
  let chain3 = divide_with_ceil(multiply(4, 7), 3)
  assert_eq(10, chain3)  // ceil(4*7/3) = ceil(28/3) = 10
  
  // å¤æ‚é“¾å¼è°ƒç”¨
  let complex_chain = add(
    multiply(divide_with_ceil(25, 4), 3),
    multiply(add(5, 3), 2)
  )
  assert_eq(33, complex_chain)  // ceil(25/4)*3 + (5+3)*2 = 7*3 + 8*2 = 21 + 16 = 37
  
  // å‡½æ•°ç»„åˆæµ‹è¯•
  let compose1 = multiply(add(multiply(2, 3), 4), 5)
  assert_eq(50, compose1)  // (2*3 + 4)*5 = (6 + 4)*5 = 10*5 = 50
  
  let compose2 = divide_with_ceil(add(multiply(6, 7), multiply(8, 9)), 10)
  assert_eq(12, compose2)  // ceil((6*7 + 8*9)/10) = ceil((42 + 72)/10) = ceil(114/10) = 12
}