// Azimuth æ–°å¢æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// åŒ…å«10ä¸ªé«˜è´¨é‡çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

test "add_function_edge_cases" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, add(0, 0))
  assert_eq(1, add(1, 0))
  assert_eq(-1, add(-1, 0))
  assert_eq(1000000, add(500000, 500000))
  assert_eq(-1000000, add(-500000, -500000))
}

test "multiply_function_various_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„å„ç§æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "subtract_function_comprehensive" {
  // å…¨é¢æµ‹è¯•å‡æ³•å‡½æ•°
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
  assert_eq(0, subtract(10, 10))
  assert_eq(15, subtract(10, -5))
  assert_eq(-15, subtract(-10, 5))
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000, divide_with_ceil(1999, 2))
  assert_eq(666667, divide_with_ceil(2000000, 3))
  assert_eq(0, divide_with_ceil(0, 100))
}

test "greet_function_international_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸŒ™!", greet("ğŸŒ™"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, empty!", greet("empty"))
}

test "mathematical_commutative_laws" {
  // éªŒè¯æ•°å­¦äº¤æ¢å¾‹
  let a = 42
  let b = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
}

test "resource_allocation_scenario" {
  // èµ„æºåˆ†é…åœºæ™¯æµ‹è¯•
  let total_items = 157
  let containers = 12
  let items_per_container = divide_with_ceil(total_items, containers)
  
  assert_eq(14, items_per_container)  // ceil(157/12) = 14
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(items_per_container, containers)
  assert_eq(168, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_items)
  assert_eq(11, remaining_space)
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let initial_value = 20
  
  // è®¡ç®—æµç¨‹ï¼š((initial / 3) * 2) + 5
  let step1 = divide_with_ceil(initial_value, 3)
  let step2 = multiply(step1, 2)
  let result = add(step2, 5)
  
  assert_eq(19, result)  // ceil(20/3) * 2 + 5 = 7 * 2 + 5 = 19
}

test "error_handling_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(-1, divide_with_ceil(-1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
}

test "real_world_business_calculation" {
  // çœŸå®ä¸–ç•Œä¸šåŠ¡è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®æˆæœ¬å’Œèµ„æºéœ€æ±‚
  let team_members = 8
  let daily_rate = 150
  let project_days = 15
  let budget_per_sprint = 5000
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = multiply(team_members, multiply(daily_rate, project_days))
  assert_eq(18000, total_cost)  // 8 * 150 * 15 = 18000
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ¬¡æ•°
  let sprints_needed = divide_with_ceil(total_cost, budget_per_sprint)
  assert_eq(4, sprints_needed)  // ceil(18000/5000) = 4
  
  // è®¡ç®—æœ€ç»ˆå†²åˆºçš„é¢„ç®—
  let final_sprint_budget = subtract(
    multiply(sprints_needed, budget_per_sprint),
    multiply(sprints_needed - 1, budget_per_sprint)
  )
  assert_eq(5000, final_sprint_budget)
}