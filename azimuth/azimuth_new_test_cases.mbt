// Azimuth æ–°å¢žæµ‹è¯•ç”¨ä¾‹
// åŒ…å«8ä¸ªé«˜è´¨é‡çš„ MoonBit æµ‹è¯•ç”¨ä¾‹

test "mathematical_fibonacci_sequence" {
  // æ–æ³¢é‚£å¥‘æ•°åˆ—æµ‹è¯•
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  let fib6 = add(fib4, fib5)  // 8
  let fib7 = add(fib5, fib6)  // 13
  
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
  assert_eq(13, fib7)
}

test "warehouse_packaging_optimization" {
  // ä»“åº“åŒ…è£…ä¼˜åŒ–æµ‹è¯•
  let product_a = 47
  let product_b = 89
  let product_c = 156
  
  let box_capacity = 24
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°
  let boxes_a = divide_with_ceil(product_a, box_capacity)
  let boxes_b = divide_with_ceil(product_b, box_capacity)
  let boxes_c = divide_with_ceil(product_c, box_capacity)
  
  assert_eq(2, boxes_a)  // ceil(47/24) = 2
  assert_eq(4, boxes_b)  // ceil(89/24) = 4
  assert_eq(7, boxes_c)  // ceil(156/24) = 7
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(13, total_boxes)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(total_boxes, box_capacity)
  assert_eq(312, total_capacity)
}

test "financial_compound_interest" {
  // é‡‘èžå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let rate_percent = 5
  
  // è®¡ç®—ä¸€å¹´åŽçš„å¤åˆ©
  let year1_end = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  assert_eq(10500, year1_end)
  
  // è®¡ç®—ä¸¤å¹´åŽçš„å¤åˆ©
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, rate_percent), 100))
  assert_eq(11025, year2_end)
  
  // è®¡ç®—ä¸‰å¹´åŽçš„å¤åˆ©
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, rate_percent), 100))
  assert_eq(11576, year3_end)
}

test "unicode_greeting_comprehensive" {
  // Unicode é—®å€™ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ÐœÐ¾ÑÐºÐ²Ð°!", greet("ÐœÐ¾ÑÐºÐ²Ð°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ðŸš€!", greet("ðŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ðŸ³ï¸â€ðŸŒˆ!", greet("ðŸ³ï¸â€ðŸŒˆ"))
}

test "algorithm_performance_comparison" {
  // ç®—æ³•æ€§èƒ½æ¯”è¾ƒæµ‹è¯•
  let input_size = 1000
  
  // O(1) å¸¸æ•°æ—¶é—´
  let constant_time = 5
  
  // O(n) çº¿æ€§æ—¶é—´
  let linear_time = multiply(input_size, 2)
  
  // O(log n) å¯¹æ•°æ—¶é—´ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let log_time = divide_with_ceil(input_size, 10)
  
  assert_eq(5, constant_time)
  assert_eq(2000, linear_time)
  assert_eq(100, log_time)
  
  // éªŒè¯å¤æ‚åº¦å…³ç³»
  assert_true(linear_time > constant_time)
  assert_true(log_time < linear_time)
}

test "resource_allocation_problem" {
  // èµ„æºåˆ†é…é—®é¢˜æµ‹è¯•
  let total_resources = 1000
  let departments = 7
  
  // åŸºç¡€åˆ†é…
  let base_allocation = divide_with_ceil(total_resources, departments)
  assert_eq(143, base_allocation)  // ceil(1000/7) = 143
  
  // è®¡ç®—æ€»åˆ†é…
  let total_allocated = multiply(base_allocation, departments)
  assert_eq(1001, total_allocated)
  
  // è®¡ç®—æº¢å‡º
  let overflow = subtract(total_allocated, total_resources)
  assert_eq(1, overflow)
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  
  // æžå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  
  // å¤§æ•°æµ‹è¯•
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(2000000, add(1000000, 1000000))
}

test "business_workflow_integration" {
  // ä¸šåŠ¡å·¥ä½œæµé›†æˆæµ‹è¯•
  let orders = 87
  let capacity_per_box = 8
  let boxes_per_pallet = 12
  let processing_time_per_box = 15  // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„ç®±å­æ•°
  let boxes_needed = divide_with_ceil(orders, capacity_per_box)
  assert_eq(11, boxes_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—éœ€è¦çš„æ‰˜ç›˜æ•°
  let pallets_needed = divide_with_ceil(boxes_needed, boxes_per_pallet)
  assert_eq(1, pallets_needed)  // ceil(11/12) = 1
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_processing_time = multiply(boxes_needed, processing_time_per_box)
  assert_eq(165, total_processing_time)  // 11 * 15 = 165åˆ†é’Ÿ
  
  // è®¡ç®—å®Œæˆæ—¶é—´ï¼ˆå°æ—¶ï¼‰
  let completion_hours = divide_with_ceil(total_processing_time, 60)
  assert_eq(3, completion_hours)  // ceil(165/60) = 3å°æ—¶
}