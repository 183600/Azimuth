// Azimuth New Comprehensive Test Suite
// This file contains new comprehensive test cases for the Azimuth telemetry system

// Test 1: Error handling and boundary conditions
test "error handling and boundary conditions" {
  // Test with null and empty values in attributes
  let attrs = azimuth::Attributes::new()
  
  // Test setting and getting various boundary values
  azimuth::Attributes::set(attrs, "empty.string", azimuth::StringValue(""))
  azimuth::Attributes::set(attrs, "max.int", azimuth::IntValue(9223372036854775807))
  azimuth::Attributes::set(attrs, "min.int", azimuth::IntValue(-9223372036854775808))
  azimuth::Attributes::set(attrs, "infinity.float", azimuth::FloatValue(1.0/0.0))
  azimuth::Attributes::set(attrs, "neg.infinity.float", azimuth::FloatValue(-1.0/0.0))
  azimuth::Attributes::set(attrs, "nan.float", azimuth::FloatValue(0.0/0.0))
  
  // Test context with extreme values
  let ctx = azimuth::Context::root()
  let empty_key = azimuth::ContextKey::new("")
  let very_long_key = azimuth::ContextKey::new("this.is.a.very.long.key.name.that.exceeds.typical.limits.and.tests.boundary.conditions")
  let special_char_key = azimuth::ContextKey::new("key.with.special.chars!@#$%^&*()")
  
  let ctx_with_empty = azimuth::Context::with_value(ctx, empty_key, "")
  let ctx_with_long = azimuth::Context::with_value(ctx_with_empty, very_long_key, "very.long.value.that.exceeds.typical.limits")
  let ctx_with_special = azimuth::Context::with_value(ctx_with_long, special_char_key, "special.value!@#$%^&*()")
  
  // Verify retrieval works
  assert_eq(azimuth::Context::get(ctx_with_empty, empty_key), Some(""))
  assert_eq(azimuth::Context::get(ctx_with_long, very_long_key), Some("very.long.value.that.exceeds.typical.limits"))
  assert_eq(azimuth::Context::get(ctx_with_special, special_char_key), Some("special.value!@#$%^&*()")
  
  // Test span context with boundary values
  let max_trace_id = "ffffffffffffffffffffffffffffffff"
  let max_span_id = "ffffffffffffffff"
  let boundary_span_ctx = azimuth::SpanContext::new(max_trace_id, max_span_id, true, "")
  
  assert_eq(azimuth::SpanContext::trace_id(boundary_span_ctx), max_trace_id)
  assert_eq(azimuth::SpanContext::span_id(boundary_span_ctx), max_span_id)
  assert_true(azimuth::SpanContext::is_valid(boundary_span_ctx))
  assert_true(azimuth::SpanContext::is_sampled(boundary_span_ctx))
}

// Test 2: Performance and stress testing
test "performance and stress testing" {
  // Test creating many spans
  let provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(provider, "stress-test-tracer")
  
  // Create multiple spans rapidly
  for i = 0; i < 100; i = i + 1 {
    let span_name = "stress-test-span-" + i.to_string()
    let span = azimuth::Tracer::start_span(tracer, span_name)
    assert_eq(azimuth::Span::name(span), span_name)
    
    // Add events to span
    azimuth::Span::add_event(span, "event-" + i.to_string())
    azimuth::Span::end(span)
  }
  
  // Test creating many metrics
  let meter_provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(meter_provider, "stress-test-meter")
  
  // Create multiple metrics
  for i = 0; i < 50; i = i + 1 {
    let counter = azimuth::Meter::create_counter(meter, "stress-counter-" + i.to_string())
    azimuth::Counter::add(counter, i.to_double())
    
    let histogram = azimuth::Meter::create_histogram(meter, "stress-histogram-" + i.to_string())
    azimuth::Histogram::record(histogram, i.to_double() * 1.5)
    
    let updown = azimuth::Meter::create_updown_counter(meter, "stress-updown-" + i.to_string())
    azimuth::UpDownCounter::add(updown, i.to_double() - 25.0)
    
    let gauge = azimuth::Meter::create_gauge(meter, "stress-gauge-" + i.to_string())
    // Gauge doesn't have a set method in the simplified implementation
  }
  
  // Test creating many log records
  let logger_provider = azimuth::LoggerProvider::default()
  let logger = azimuth::LoggerProvider::get_logger(logger_provider, "stress-test-logger")
  
  for i = 0; i < 100; i = i + 1 {
    let severity = match i % 6 {
      0 => azimuth::Trace
      1 => azimuth::Debug
      2 => azimuth::Info
      3 => azimuth::Warn
      4 => azimuth::Error
      _ => azimuth::Fatal
    }
    
    let log = azimuth::LogRecord::new(severity, "Stress test log message " + i.to_string())
    azimuth::Logger::emit(logger, log)
  }
  
  assert_true(true)
}

// Test 3: Concurrent safety testing
test "concurrent safety testing" {
  // Test concurrent context operations
  let base_ctx = azimuth::Context::root()
  
  // Create multiple context keys
  let keys = [
    azimuth::ContextKey::new("concurrent.key1"),
    azimuth::ContextKey::new("concurrent.key2"),
    azimuth::ContextKey::new("concurrent.key3"),
    azimuth::ContextKey::new("concurrent.key4"),
    azimuth::ContextKey::new("concurrent.key5")
  ]
  
  // Create context with multiple values
  let ctx1 = azimuth::Context::with_value(base_ctx, keys[0], "value1")
  let ctx2 = azimuth::Context::with_value(ctx1, keys[1], "value2")
  let ctx3 = azimuth::Context::with_value(ctx2, keys[2], "value3")
  let ctx4 = azimuth::Context::with_value(ctx3, keys[3], "value4")
  let ctx5 = azimuth::Context::with_value(ctx4, keys[4], "value5")
  
  // Verify all values are accessible
  assert_eq(azimuth::Context::get(ctx5, keys[0]), Some("value1"))
  assert_eq(azimuth::Context::get(ctx5, keys[1]), Some("value2"))
  assert_eq(azimuth::Context::get(ctx5, keys[2]), Some("value3"))
  assert_eq(azimuth::Context::get(ctx5, keys[3]), Some("value4"))
  assert_eq(azimuth::Context::get(ctx5, keys[4]), Some("value5"))
  
  // Test concurrent baggage operations
  let base_baggage = azimuth::Baggage::new()
  let baggage1 = azimuth::Baggage::set_entry(base_baggage, "baggage.key1", "baggage.value1")
  let baggage2 = azimuth::Baggage::set_entry(baggage1, "baggage.key2", "baggage.value2")
  let baggage3 = azimuth::Baggage::set_entry(baggage2, "baggage.key3", "baggage.value3")
  
  // Verify baggage entries
  assert_eq(azimuth::Baggage::get_entry(baggage3, "baggage.key1"), Some("baggage.value1"))
  assert_eq(azimuth::Baggage::get_entry(baggage3, "baggage.key2"), Some("baggage.value2"))
  assert_eq(azimuth::Baggage::get_entry(baggage3, "baggage.key3"), Some("baggage.value3"))
  
  // Test concurrent resource operations
  let base_resource = azimuth::Resource::new()
  let resource1 = azimuth::Resource::with_attributes(base_resource, [
    ("concurrent.attr1", azimuth::StringValue("value1")),
    ("concurrent.attr2", azimuth::IntValue(42))
  ])
  let resource2 = azimuth::Resource::with_attributes(resource1, [
    ("concurrent.attr3", azimuth::BoolValue(true)),
    ("concurrent.attr4", azimuth::FloatValue(3.14))
  ])
  
  // Verify resource attributes
  assert_eq(azimuth::Resource::get_attribute(resource2, "concurrent.attr1"), Some(azimuth::StringValue("value1")))
  assert_eq(azimuth::Resource::get_attribute(resource2, "concurrent.attr2"), Some(azimuth::IntValue(42)))
  assert_eq(azimuth::Resource::get_attribute(resource2, "concurrent.attr3"), Some(azimuth::BoolValue(true)))
  assert_eq(azimuth::Resource::get_attribute(resource2, "concurrent.attr4"), Some(azimuth::FloatValue(3.14)))
}

// Test 4: Cross-service propagation testing
test "cross-service propagation testing" {
  // Test trace context propagation
  let trace_propagator = azimuth::W3CTraceContextPropagator::new()
  let baggage_propagator = azimuth::W3CBaggagePropagator::new()
  
  let propagators = [trace_propagator, baggage_propagator]
  let composite_propagator = azimuth::CompositePropagator::new(propagators)
  
  // Create source context with trace and baggage
  let source_ctx = azimuth::Context::root()
  let trace_key = azimuth::ContextKey::new("trace")
  let baggage_key = azimuth::ContextKey::new("baggage")
  let source_with_trace = azimuth::Context::with_value(source_ctx, trace_key, "trace-value")
  let source_with_baggage = azimuth::Context::with_value(source_with_trace, baggage_key, "baggage-value")
  
  // Inject context into carrier
  let carrier = azimuth::TextMapCarrier::new()
  azimuth::CompositePropagator::inject(composite_propagator, source_with_baggage, carrier)
  
  // Extract context from carrier
  let extracted_ctx = azimuth::CompositePropagator::extract(composite_propagator, carrier)
  
  // Verify extraction
  let extracted_key = azimuth::ContextKey::new("extracted")
  let extracted_value = azimuth::Context::get(extracted_ctx, extracted_key)
  assert_eq(extracted_value, Some("true"))
  
  // Test with multiple carriers
  let carrier1 = azimuth::TextMapCarrier::new()
  let carrier2 = azimuth::TextMapCarrier::new()
  let carrier3 = azimuth::TextMapCarrier::new()
  
  azimuth::CompositePropagator::inject(composite_propagator, source_with_baggage, carrier1)
  azimuth::CompositePropagator::inject(composite_propagator, source_with_baggage, carrier2)
  azimuth::CompositePropagator::inject(composite_propagator, source_with_baggage, carrier3)
  
  let extracted1 = azimuth::CompositePropagator::extract(composite_propagator, carrier1)
  let extracted2 = azimuth::CompositePropagator::extract(composite_propagator, carrier2)
  let extracted3 = azimuth::CompositePropagator::extract(composite_propagator, carrier3)
  
  assert_eq(azimuth::Context::get(extracted1, extracted_key), Some("true"))
  assert_eq(azimuth::Context::get(extracted2, extracted_key), Some("true"))
  assert_eq(azimuth::Context::get(extracted3, extracted_key), Some("true"))
}

// Test 5: Time series operations testing
test "time series operations testing" {
  // Test timestamp operations
  let clock = azimuth::Clock::system()
  let timestamp1 = azimuth::Clock::now_unix_nanos(clock)
  
  // Create log records with different timestamps
  let log1 = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Time series log 1"),
    None,
    Some(timestamp1),
    None,
    None,
    None,
    None
  )
  
  // Wait a moment (simulated)
  let timestamp2 = timestamp1 + 1000000L  // Add 1ms
  let log2 = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Time series log 2"),
    None,
    Some(timestamp2),
    None,
    None,
    None,
    None
  )
  
  // Verify timestamps are different
  assert_true(timestamp2 > timestamp1)
  
  // Test metrics with time series data
  let provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(provider, "time-series-meter")
  let histogram = azimuth::Meter::create_histogram(meter, "response.time")
  
  // Record multiple values over time
  for i = 0; i < 10; i = i + 1 {
    let value = i.to_double() * 10.0
    azimuth::Histogram::record(histogram, value)
  }
  
  // Test gauge with time series data
  let gauge = azimuth::Meter::create_gauge(meter, "cpu.usage")
  
  // Simulate gauge readings over time
  for i = 0; i < 5; i = i + 1 {
    let usage = 50.0 + i.to_double() * 10.0
    // Gauge doesn't have a set method in simplified implementation
  }
  
  assert_true(true)
}

// Test 6: Internationalization and localization testing
test "internationalization and localization testing" {
  // Test with various Unicode characters
  let attrs = azimuth::Attributes::new()
  
  // Test Chinese characters
  azimuth::Attributes::set(attrs, "chinese.test", azimuth::StringValue("æµ‹è¯•ä¸­æ–‡"))
  
  // Test Emoji
  azimuth::Attributes::set(attrs, "emoji.test", azimuth::StringValue("ðŸ˜€ðŸŽ‰ðŸ”¥"))
  
  // Test Arabic
  azimuth::Attributes::set(attrs, "arabic.test", azimuth::StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  
  // Test Russian
  azimuth::Attributes::set(attrs, "russian.test", azimuth::StringValue("Ð¢ÐµÑÑ‚ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼"))
  
  // Test Japanese
  azimuth::Attributes::set(attrs, "japanese.test", azimuth::StringValue("æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆ"))
  
  // Test mixed languages
  azimuth::Attributes::set(attrs, "mixed.test", azimuth::StringValue("Hello ä¸–ç•Œ ðŸŒ Ñ‚ÐµÑÑ‚"))
  
  // Test log records with international content
  let chinese_log = azimuth::LogRecord::new(azimuth::Info, "ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯")
  let emoji_log = azimuth::LogRecord::new(azimuth::Info, "Emoji log message ðŸ˜€ðŸŽ‰")
  let mixed_log = azimuth::LogRecord::new(azimuth::Info, "Mixed: Hello ä¸–ç•Œ ðŸŒ")
  
  assert_eq(azimuth::LogRecord::body(chinese_log), Some("ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯"))
  assert_eq(azimuth::LogRecord::body(emoji_log), Some("Emoji log message ðŸ˜€ðŸŽ‰"))
  assert_eq(azimuth::LogRecord::body(mixed_log), Some("Mixed: Hello ä¸–ç•Œ ðŸŒ"))
  
  // Test context with international keys and values
  let ctx = azimuth::Context::root()
  let chinese_key = azimuth::ContextKey::new("ä¸­æ–‡é”®")
  let ctx_with_chinese = azimuth::Context::with_value(ctx, chinese_key, "ä¸­æ–‡å€¼")
  
  assert_eq(azimuth::Context::get(ctx_with_chinese, chinese_key), Some("ä¸­æ–‡å€¼"))
  
  // Test baggage with international content
  let baggage = azimuth::Baggage::new()
  let baggage_with_intl = azimuth::Baggage::set_entry(baggage, "ç”¨æˆ·.id", "12345")
  
  assert_eq(azimuth::Baggage::get_entry(baggage_with_intl, "ç”¨æˆ·.id"), Some("12345"))
}

// Test 7: Data serialization and integrity testing
test "data serialization and integrity testing" {
  // Test with complex attribute values
  let attrs = azimuth::Attributes::new()
  
  // Test with various data types
  azimuth::Attributes::set(attrs, "string.value", azimuth::StringValue("test string"))
  azimuth::Attributes::set(attrs, "int.value", azimuth::IntValue(42))
  azimuth::Attributes::set(attrs, "float.value", azimuth::FloatValue(3.14159))
  azimuth::Attributes::set(attrs, "bool.value", azimuth::BoolValue(true))
  
  // Test with array values
  azimuth::Attributes::set(attrs, "string.array", azimuth::ArrayStringValue(["a", "b", "c"]))
  azimuth::Attributes::set(attrs, "int.array", azimuth::ArrayIntValue([1, 2, 3, 4, 5]))
  
  // Test with empty arrays
  azimuth::Attributes::set(attrs, "empty.string.array", azimuth::ArrayStringValue([]))
  azimuth::Attributes::set(attrs, "empty.int.array", azimuth::ArrayIntValue([]))
  
  // Test resource with complex attributes
  let resource = azimuth::Resource::with_attributes(azimuth::Resource::new(), [
    ("service.name", azimuth::StringValue("test-service")),
    ("service.version", azimuth::StringValue("1.0.0")),
    ("process.id", azimuth::IntValue(12345)),
    ("process.cpu.percent", azimuth::FloatValue(75.5)),
    ("service.healthy", azimuth::BoolValue(true)),
    ("service.tags", azimuth::ArrayStringValue(["tag1", "tag2", "tag3"]))
  ])
  
  // Verify resource attributes
  assert_eq(azimuth::Resource::get_attribute(resource, "service.name"), Some(azimuth::StringValue("test-service")))
  assert_eq(azimuth::Resource::get_attribute(resource, "service.version"), Some(azimuth::StringValue("1.0.0")))
  assert_eq(azimuth::Resource::get_attribute(resource, "process.id"), Some(azimuth::IntValue(12345)))
  assert_eq(azimuth::Resource::get_attribute(resource, "process.cpu.percent"), Some(azimuth::FloatValue(75.5)))
  assert_eq(azimuth::Resource::get_attribute(resource, "service.healthy"), Some(azimuth::BoolValue(true)))
  assert_eq(azimuth::Resource::get_attribute(resource, "service.tags"), Some(azimuth::ArrayStringValue(["tag1", "tag2", "tag3"])))
  
  // Test span context serialization
  let span_ctx = azimuth::SpanContext::new("trace-12345", "span-67890", true, "key1=value1,key2=value2")
  
  assert_eq(azimuth::SpanContext::trace_id(span_ctx), "trace-12345")
  assert_eq(azimuth::SpanContext::span_id(span_ctx), "span-67890")
  assert_true(azimuth::SpanContext::is_sampled(span_ctx))
  assert_eq(azimuth::SpanContext::trace_state(span_ctx), "key1=value1,key2=value2")
}

// Test 8: Platform compatibility testing
test "platform compatibility testing" {
  // Test clock operations
  let clock = azimuth::Clock::system()
  let timestamp = azimuth::Clock::now_unix_nanos(clock)
  
  // Verify timestamp is reasonable (should be > 0)
  assert_true(timestamp > 0L)
  
  // Test random operations
  let random = azimuth::Random::system()
  let random_bytes = azimuth::Random::next_bytes(random, 16)
  let random_u64 = azimuth::Random::next_u64(random)
  
  // Verify random generation
  assert_eq(random_bytes.length(), 0)  // Simplified implementation returns empty array
  assert_eq(random_u64, 12345UL)  // Simplified implementation returns fixed value
  
  // Test HTTP operations with various URLs
  let https_request = azimuth::HttpRequest::new("GET", "https://api.example.com", [])
  let http_request = azimuth::HttpRequest::new("GET", "http://api.example.com", [])
  let localhost_request = azimuth::HttpRequest::new("GET", "http://localhost:8080", [])
  let ip_request = azimuth::HttpRequest::new("GET", "http://192.168.1.1:3000", [])
  
  assert_eq(azimuth::HttpRequest::url(https_request), "https://api.example.com")
  assert_eq(azimuth::HttpRequest::url(http_request), "http://api.example.com")
  assert_eq(azimuth::HttpRequest::url(localhost_request), "http://localhost:8080")
  assert_eq(azimuth::HttpRequest::url(ip_request), "http://192.168.1.1:3000")
  
  // Test HTTP responses with various status codes
  let success_response = azimuth::HttpResponse::new(200, [], Some("Success"))
  let redirect_response = azimuth::HttpResponse::new(301, [], Some("Redirect"))
  let client_error_response = azimuth::HttpResponse::new(404, [], Some("Not Found"))
  let server_error_response = azimuth::HttpResponse::new(500, [], Some("Internal Server Error"))
  
  assert_eq(azimuth::HttpResponse::status_code(success_response), 200)
  assert_eq(azimuth::HttpResponse::status_code(redirect_response), 301)
  assert_eq(azimuth::HttpResponse::status_code(client_error_response), 404)
  assert_eq(azimuth::HttpResponse::status_code(server_error_response), 500)
}

// Test 9: Security and privacy testing
test "security and privacy testing" {
  // Test with sensitive data in attributes
  let attrs = azimuth::Attributes::new()
  
  // Test with various sensitive data types
  azimuth::Attributes::set(attrs, "user.id", azimuth::StringValue("user-12345"))
  azimuth::Attributes::set(attrs, "email", azimuth::StringValue("user@example.com"))
  azimuth::Attributes::set(attrs, "api.key", azimuth::StringValue("sk-1234567890abcdef"))
  azimuth::Attributes::set(attrs, "session.token", azimuth::StringValue("sess-abcdef123456"))
  azimuth::Attributes::set(attrs, "credit.card", azimuth::StringValue("4111-1111-1111-1111"))
  azimuth::Attributes::set(attrs, "ssn", azimuth::StringValue("123-45-6789"))
  
  // Test log records with sensitive data
  let sensitive_log = azimuth::LogRecord::new(azimuth::Error, "User login failed for user@example.com")
  let token_log = azimuth::LogRecord::new(azimuth::Warn, "API key validation failed")
  
  assert_eq(azimuth::LogRecord::body(sensitive_log), Some("User login failed for user@example.com"))
  assert_eq(azimuth::LogRecord::body(token_log), Some("API key validation failed"))
  
  // Test context with sensitive data
  let ctx = azimuth::Context::root()
  let sensitive_key = azimuth::ContextKey::new("user.session")
  let ctx_with_sensitive = azimuth::Context::with_value(ctx, sensitive_key, "sess-abcdef123456")
  
  assert_eq(azimuth::Context::get(ctx_with_sensitive, sensitive_key), Some("sess-abcdef123456"))
  
  // Test baggage with sensitive data
  let baggage = azimuth::Baggage::new()
  let baggage_with_sensitive = azimuth::Baggage::set_entry(baggage, "auth.token", "bearer-123456")
  
  assert_eq(azimuth::Baggage::get_entry(baggage_with_sensitive, "auth.token"), Some("bearer-123456"))
  
  // Test HTTP with sensitive headers
  let sensitive_headers = [
    ("Authorization", "Bearer token123"),
    ("X-API-Key", "secret-key-123"),
    ("Cookie", "session=abc123; user=def456")
  ]
  
  let sensitive_request = azimuth::HttpRequest::new("POST", "https://api.example.com/secure", sensitive_headers, Some("sensitive data"))
  
  assert_eq(azimuth::HttpRequest::http_method(sensitive_request), "POST")
  assert_eq(azimuth::HttpRequest::url(sensitive_request), "https://api.example.com/secure")
  assert_eq(azimuth::HttpRequest::body(sensitive_request), Some("sensitive data"))
}

// Test 10: Real-time data processing testing
test "real-time data processing testing" {
  // Test high-frequency log generation
  let logger_provider = azimuth::LoggerProvider::default()
  let logger = azimuth::LoggerProvider::get_logger(logger_provider, "realtime-logger")
  
  // Generate logs in rapid succession
  for i = 0; i < 50; i = i + 1 {
    let log = azimuth::LogRecord::new_with_context(
      azimuth::Info,
      Some("Real-time log message " + i.to_string()),
      None,
      Some(1735689600000000000L + i.to_int64() * 1000000L),
      None,
      Some("realtime-trace-" + (i / 10).to_string()),
      Some("realtime-span-" + i.to_string()),
      None
    )
    
    azimuth::Logger::emit(logger, log)
  }
  
  // Test high-frequency metric generation
  let meter_provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(meter_provider, "realtime-meter")
  
  let counter = azimuth::Meter::create_counter(meter, "realtime.events")
  let histogram = azimuth::Meter::create_histogram(meter, "realtime.latency")
  
  // Generate metrics in rapid succession
  for i = 0; i < 50; i = i + 1 {
    azimuth::Counter::add(counter, 1.0)
    azimuth::Histogram::record(histogram, i.to_double() * 0.1)
  }
  
  // Test real-time span creation
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "realtime-tracer")
  
  // Create spans in rapid succession
  for i = 0; i < 20; i = i + 1 {
    let span = azimuth::Tracer::start_span(tracer, "realtime-operation-" + i.to_string())
    
    // Add events to span
    azimuth::Span::add_event(span, "start-event-" + i.to_string())
    azimuth::Span::add_event(span, "processing-event-" + i.to_string())
    azimuth::Span::add_event(span, "end-event-" + i.to_string())
    
    azimuth::Span::end(span)
  }
  
  // Test real-time context propagation
  let base_ctx = azimuth::Context::root()
  let correlation_key = azimuth::ContextKey::new("correlation.id")
  
  for i = 0; i < 10; i = i + 1 {
    let correlation_id = "corr-" + i.to_string()
    let ctx_with_corr = azimuth::Context::with_value(base_ctx, correlation_key, correlation_id)
    
    // Verify correlation ID is set
    assert_eq(azimuth::Context::get(ctx_with_corr, correlation_key), Some(correlation_id))
  }
  
  assert_true(true)
}