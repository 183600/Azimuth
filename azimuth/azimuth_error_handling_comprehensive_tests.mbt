// Azimuth Error Handling Comprehensive Tests
// å…¨é¢çš„é”™è¯¯å¤„ç†æµ‹è¯•

test "spané”™è¯¯çŠ¶æ€è½¬æ¢æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.test")
  
  let span = Tracer::start_span(tracer, "error.test.span")
  
  // åˆå§‹çŠ¶æ€åº”ä¸ºUnset
  match Span::status(span) {
    Unset => assert_true(true)
    _ => assert_true(false)
  }
  
  // è®¾ç½®ä¸ºErrorçŠ¶æ€
  Span::set_status(span, Error, Some("Test error occurred"))
  match Span::status(span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°è¿”å›Unset
    _ => assert_true(false)
  }
  
  // æ·»åŠ é”™è¯¯äº‹ä»¶
  Span::add_event(span, "error.details", Some([
    ("error.code", StringValue("ERR_001")),
    ("error.message", StringValue("Test error message")),
    ("error.stack", StringValue("at error.test.span:1"))
  ]))
  
  // å°è¯•æ¢å¤ï¼šè®¾ç½®ä¸ºOkçŠ¶æ€
  Span::set_status(span, Ok, Some("Error recovered"))
  match Span::status(span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°è¿”å›Unset
    _ => assert_true(false)
  }
  
  // æ·»åŠ æ¢å¤äº‹ä»¶
  Span::add_event(span, "error.recovered", Some([
    ("recovery.time", StringValue("100ms")),
    ("recovery.strategy", StringValue("retry"))
  ]))
  
  Span::end(span)
}

test "metricsæ“ä½œå¼‚å¸¸å¤„ç†æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "error.metrics.test")
  
  // æµ‹è¯•counterçš„å¼‚å¸¸å¤„ç†
  let counter = Meter::create_counter(meter, "error.counter")
  
  // å°è¯•æ·»åŠ è´Ÿå€¼ï¼ˆåº”è¯¥è¢«å¤„ç†æˆ–å¿½ç•¥ï¼‰
  Counter::add(counter, -1.0)
  
  // å°è¯•æ·»åŠ æå¤§å€¼
  Counter::add(counter, 999999999.0)
  
  // å°è¯•æ·»åŠ NaNï¼ˆå¦‚æœæ”¯æŒï¼‰
  Counter::add(counter, 0.0 / 0.0)
  
  // æµ‹è¯•histogramçš„å¼‚å¸¸å¤„ç†
  let histogram = Meter::create_histogram(meter, "error.histogram")
  
  // è®°å½•è´Ÿå€¼
  Histogram::record(histogram, -100.0)
  
  // è®°å½•æå¤§å€¼
  Histogram::record(histogram, 999999999.0)
  
  // æµ‹è¯•UpDownCounterçš„å¼‚å¸¸å¤„ç†
  let updown_counter = Meter::create_updown_counter(meter, "error.updown")
  
  // æµ‹è¯•å¢å‡æ“ä½œ
  UpDownCounter::add(updown_counter, 10.0)
  UpDownCounter::add(updown_counter, -5.0)
  
  // æµ‹è¯•æç«¯å€¼
  UpDownCounter::add(updown_counter, 999999999.0)
  UpDownCounter::add(updown_counter, -999999999.0)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "contextä¼ æ’­é”™è¯¯å¤„ç†æµ‹è¯•" {
  let ctx = Context::root()
  let key = ContextKey::new("test.key")
  
  // æµ‹è¯•æ­£å¸¸æƒ…å†µ
  let normal_ctx = Context::with_value(ctx, key, "normal.value")
  let normal_value = Context::get(normal_ctx, key)
  assert_eq(normal_value, Some("normal.value"))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  let empty_ctx = Context::with_value(ctx, key, "")
  let empty_value = Context::get(empty_ctx, key)
  assert_eq(empty_value, Some(""))
  
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²å€¼
  let long_value = "This is a very long string that exceeds normal limits and tests error handling for long values in context propagation"
  let long_ctx = Context::with_value(ctx, key, long_value)
  let retrieved_long = Context::get(long_ctx, key)
  assert_eq(retrieved_long, Some(long_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å€¼
  let special_value = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_ctx = Context::with_value(ctx, key, special_value)
  let retrieved_special = Context::get(special_ctx, key)
  assert_eq(retrieved_special, Some(special_value))
  
  // æµ‹è¯•Unicodeå­—ç¬¦å€¼
  let unicode_value = "æµ‹è¯•ğŸš€ğŸ“ŠÎ±Î²Î³Î´ÎµÎ¶Î·Î¸"
  let unicode_ctx = Context::with_value(ctx, key, unicode_value)
  let retrieved_unicode = Context::get(unicode_ctx, key)
  assert_eq(retrieved_unicode, Some(unicode_value))
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„é”®
  let missing_key = ContextKey::new("missing.key")
  let missing_value = Context::get(ctx, missing_key)
  assert_eq(missing_value, None)
}

test "baggageæ“ä½œé”™è¯¯å¤„ç†æµ‹è¯•" {
  let baggage = Baggage::new()
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼
  let empty_key_baggage = Baggage::set_entry(baggage, "", "empty.key")
  let empty_value_baggage = Baggage::set_entry(baggage, "empty.value", "")
  
  // æµ‹è¯•éå¸¸é•¿çš„é”®å’Œå€¼
  let long_key = "this.is.a.very.long.key.name.that.exceeds.normal.limits.and.tests.error.handling"
  let long_value = "this.is.a.very.long.value.that.exceeds.normal.limits.and.tests.error.handling.in.baggage.operations"
  
  let long_key_baggage = Baggage::set_entry(baggage, long_key, "normal.value")
  let long_value_baggage = Baggage::set_entry(baggage, "normal.key", long_value)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_value = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  
  let special_baggage = Baggage::set_entry(baggage, special_key, special_value)
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = "æµ‹è¯•é”®ğŸš€"
  let unicode_value = "æµ‹è¯•å€¼ğŸ“Š"
  
  let unicode_baggage = Baggage::set_entry(baggage, unicode_key, unicode_value)
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„æ¡ç›®
  let missing_entry = Baggage::get_entry(baggage, "nonexistent.key")
  assert_eq(missing_entry, None)
  
  // æµ‹è¯•ç§»é™¤ä¸å­˜åœ¨çš„æ¡ç›®
  let remove_missing = Baggage::remove_entry(baggage, "nonexistent.key")
  
  // æµ‹è¯•ç§»é™¤å­˜åœ¨çš„æ¡ç›®
  let test_baggage = Baggage::set_entry(baggage, "test.key", "test.value")
  let after_remove = Baggage::remove_entry(test_baggage, "test.key")
  let removed_value = Baggage::get_entry(after_remove, "test.key")
  assert_eq(removed_value, None)
}

test "logè®°å½•å¼‚å¸¸å¤„ç†æµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "error.log.test")
  
  // æµ‹è¯•ç©ºæ¶ˆæ¯
  let empty_log = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_log), Some(""))
  
  // æµ‹è¯•éå¸¸é•¿çš„æ¶ˆæ¯
  let long_message = "This is a very long log message that exceeds normal limits and tests error handling for long messages in log records. " +
                    "It includes multiple sentences and should test the boundary conditions of the logging system. " +
                    "The purpose is to ensure that the system can handle unusually long log messages without crashing or losing data."
  
  let long_log = LogRecord::new(Error, long_message)
  assert_eq(LogRecord::body(long_log), Some(long_message))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ¶ˆæ¯
  let special_message = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_log = LogRecord::new(Warn, special_message)
  assert_eq(LogRecord::body(special_log), Some(special_message))
  
  // æµ‹è¯•Unicodeæ¶ˆæ¯
  let unicode_message = "æµ‹è¯•æ—¥å¿—æ¶ˆæ¯ğŸš€ğŸ“ŠåŒ…å«ç‰¹æ®Šå­—ç¬¦Î±Î²Î³Î´ÎµÎ¶Î·Î¸"
  let unicode_log = LogRecord::new(Debug, unicode_message)
  assert_eq(LogRecord::body(unicode_log), Some(unicode_message))
  
  // æµ‹è¯•å¸¦æœ‰å¼‚å¸¸å±æ€§çš„æ—¥å¿—
  let error_attrs = Attributes::with_attributes(Attributes::new(), [
    ("error.type", StringValue("null.pointer")),
    ("error.message", StringValue("Attempted to access null object")),
    ("error.stack", StringValue("at error.location:1\nat error.location:2\nat error.location:3"))
  ])
  
  let error_log = LogRecord::new_with_context(
    Fatal,
    Some("Critical error occurred"),
    Some(error_attrs),
    Some(1735689600000000000L),
    Some(1735689600000001000L),
    Some("trace.id.12345"),
    Some("span.id.67890"),
    Some(Context::root())
  )
  
  Logger::emit(logger, empty_log)
  Logger::emit(logger, long_log)
  Logger::emit(logger, special_log)
  Logger::emit(logger, unicode_log)
  Logger::emit(logger, error_log)
  
  assert_true(true)
}

test "resourceæ“ä½œé”™è¯¯å¤„ç†æµ‹è¯•" {
  let resource = Resource::new()
  
  // æµ‹è¯•ç©ºå±æ€§é”®å’Œå€¼
  let empty_attrs = [
    ("", StringValue("empty.key")),
    ("empty.value", StringValue(""))
  ]
  
  let resource_with_empty = Resource::with_attributes(resource, empty_attrs)
  
  // æµ‹è¯•éå¸¸é•¿çš„å±æ€§é”®å’Œå€¼
  let long_key = "this.is.a.very.long.attribute.key.name.that.exceeds.normal.limits"
  let long_value = "this.is.a.very.long.attribute.value.that.exceeds.normal.limits.and.tests.error.handling"
  
  let long_attrs = [
    (long_key, StringValue(long_value))
  ]
  
  let resource_with_long = Resource::with_attributes(resource, long_attrs)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§é”®å’Œå€¼
  let special_attrs = [
    ("!@#$%^&*()", StringValue("!@#$%^&*()")),
    ("[]{}|;':\",./<>?", StringValue("[]{}|;':\",./<>?"))
  ]
  
  let resource_with_special = Resource::with_attributes(resource, special_attrs)
  
  // æµ‹è¯•Unicodeå±æ€§é”®å’Œå€¼
  let unicode_attrs = [
    ("æµ‹è¯•é”®", StringValue("æµ‹è¯•å€¼")),
    ("emojiğŸš€", StringValue("emojiğŸ“Š"))
  ]
  
  let resource_with_unicode = Resource::with_attributes(resource, unicode_attrs)
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å±æ€§
  let missing_attr = Resource::get_attribute(resource, "nonexistent.attr")
  assert_eq(missing_attr, None)
  
  // æµ‹è¯•èµ„æºåˆå¹¶
  let base_resource = Resource::with_attributes(resource, [
    ("base.attr", StringValue("base.value")),
    ("common.attr", StringValue("base.common"))
  ])
  
  let override_resource = Resource::with_attributes(resource, [
    ("override.attr", StringValue("override.value")),
    ("common.attr", StringValue("override.common"))
  ])
  
  let merged = Resource::merge(base_resource, override_resource)
  
  // éªŒè¯åˆå¹¶ç»“æœ
  let base_attr = Resource::get_attribute(merged, "base.attr")
  let override_attr = Resource::get_attribute(merged, "override.attr")
  let common_attr = Resource::get_attribute(merged, "common.attr")
  
  // ç®€åŒ–å®ç°å¯èƒ½è¿”å›Noneï¼Œä½†ä¸åº”è¯¥å´©æºƒ
  assert_true(true)
}

test "HTTPå®¢æˆ·ç«¯é”™è¯¯å¤„ç†æµ‹è¯•" {
  let client = HttpClient::new()
  
  // æµ‹è¯•å„ç§é”™è¯¯çŠ¶æ€ç 
  let error_codes = [400, 401, 403, 404, 500, 502, 503]
  
  for code in error_codes {
    let error_response = HttpResponse::new(
      code,
      [("Content-Type", "application/json")],
      Some("{\"error\":\"Error " + code.to_string() + "\",\"message\":\"Request failed\"}")
    )
    
    assert_eq(HttpResponse::status_code(error_response), code)
    
    match HttpResponse::body(error_response) {
      Some(body) => assert_true(body.contains("Error " + code.to_string()))
      None => assert_true(false)
    }
  }
  
  // æµ‹è¯•ç©ºå“åº”ä½“
  let empty_response = HttpResponse::new(200, [], None)
  assert_eq(HttpResponse::body(empty_response), None)
  
  // æµ‹è¯•éå¸¸å¤§çš„å“åº”ä½“
  let large_body = "{\"data\":\"" + "x".repeat(10000) + "\"}"
  let large_response = HttpResponse::new(200, [("Content-Length", "10007")], Some(large_body))
  
  match HttpResponse::body(large_response) {
    Some(body) => assert_eq(body.length(), 10007)
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¸¦æœ‰ç‰¹æ®Šå­—ç¬¦çš„å“åº”å¤´
  let special_headers = [
    ("X-Special-Header", "!@#$%^&*()_+-=[]{}|;':\",./<>?"),
    ("X-Unicode-Header", "æµ‹è¯•å¤´ğŸš€ğŸ“Š")
  ]
  
  let special_response = HttpResponse::new(200, special_headers, Some("{\"status\":\"ok\"}"))
  assert_eq(HttpResponse::status_code(special_response), 200)
  
  // æµ‹è¯•æ— æ•ˆçš„è¯·æ±‚
  let invalid_request = HttpRequest::new("", "", [], Some(""))
  assert_eq(HttpRequest::http_method(invalid_request), "")
  assert_eq(HttpRequest::url(invalid_request), "")
  assert_eq(HttpRequest::body(invalid_request), Some(""))
}

test "span contexté”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºtrace_idå’Œspan_id
  let empty_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(empty_ctx))
  
  // æµ‹è¯•åªæœ‰trace_idæ²¡æœ‰span_id
  let trace_only_ctx = SpanContext::new("trace.id.12345", "", true, "")
  assert_false(SpanContext::is_valid(trace_only_ctx))
  
  // æµ‹è¯•åªæœ‰span_idæ²¡æœ‰trace_id
  let span_only_ctx = SpanContext::new("", "span.id.67890", true, "")
  assert_false(SpanContext::is_valid(span_only_ctx))
  
  // æµ‹è¯•éå¸¸é•¿çš„trace_idå’Œspan_id
  let long_trace_id = "a".repeat(100)
  let long_span_id = "b".repeat(100)
  let long_ctx = SpanContext::new(long_trace_id, long_span_id, true, "")
  assert_true(SpanContext::is_valid(long_ctx))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦trace_idå’Œspan_id
  let special_trace_id = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_span_id = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_ctx = SpanContext::new(special_trace_id, special_span_id, true, "")
  assert_true(SpanContext::is_valid(special_ctx))
  
  // æµ‹è¯•Unicode trace_idå’Œspan_id
  let unicode_trace_id = "æµ‹è¯•traceğŸš€"
  let unicode_span_id = "æµ‹è¯•spanğŸ“Š"
  let unicode_ctx = SpanContext::new(unicode_trace_id, unicode_span_id, true, "")
  assert_true(SpanContext::is_valid(unicode_ctx))
  
  // æµ‹è¯•trace_state
  let normal_ctx = SpanContext::new("trace.id", "span.id", true, "key1=value1,key2=value2")
  assert_eq(SpanContext::is_sampled(normal_ctx), true)
  
  let empty_state_ctx = SpanContext::new("trace.id", "span.id", false, "")
  assert_eq(SpanContext::is_sampled(empty_state_ctx), false)
  
  // æµ‹è¯•å¤æ‚trace_state
  let complex_state = "key1=value1;key2=value2,key3=value3;key4=value4"
  let complex_ctx = SpanContext::new("trace.id", "span.id", true, complex_state)
  assert_eq(SpanContext::is_sampled(complex_ctx), true)
}

test "ä¼ æ’­å™¨é”™è¯¯å¤„ç†æµ‹è¯•" {
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let carrier = TextMapCarrier::new()
  let ctx = Context::root()
  
  // æµ‹è¯•å‘ç©ºcarrieræ³¨å…¥
  CompositePropagator::inject(propagator, ctx, carrier)
  
  // æµ‹è¯•ä»ç©ºcarrieræå–
  let empty_carrier = TextMapCarrier::new()
  let extracted_from_empty = CompositePropagator::extract(propagator, empty_carrier)
  assert_true(extracted_from_empty is Context)
  
  // æµ‹è¯•å¸¦æœ‰ç‰¹æ®Šå­—ç¬¦çš„carrier
  TextMapCarrier::set(carrier, "traceparent", "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  TextMapCarrier::set(carrier, "baggage", "æµ‹è¯•ğŸš€ğŸ“Š")
  
  let special_extracted = CompositePropagator::extract(propagator, carrier)
  assert_true(special_extracted is Context)
  
  // æµ‹è¯•å¸¦æœ‰éå¸¸é•¿å€¼çš„carrier
  let long_value = "a".repeat(1000)
  TextMapCarrier::set(carrier, "long.header", long_value)
  
  let long_extracted = CompositePropagator::extract(propagator, carrier)
  assert_true(long_extracted is Context)
  
  // æµ‹è¯•å¸¦æœ‰Unicodeé”®çš„carrier
  TextMapCarrier::set(carrier, "æµ‹è¯•é”®", "æµ‹è¯•å€¼")
  
  let unicode_extracted = CompositePropagator::extract(propagator, carrier)
  assert_true(unicode_extracted is Context)
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å¤´éƒ¨
  let missing_header = TextMapCarrier::get(carrier, "nonexistent.header")
  assert_eq(missing_header, None)
}