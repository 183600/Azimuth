test "åŸºæœ¬å±æ€§æ“ä½œæµ‹è¯•" {
  let attrs = Attributes::new()
  Attributes::set(attrs, "string.key", StringValue("test_value"))
  
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…è€Œä¸æ˜¯ç›´æ¥æ¯”è¾ƒ
  let result = Attributes::get(attrs, "string.key")
  assert_true(result is Some)
  match result {
    Some(StringValue(value)) => assert_eq(value, "test_value")
    _ => assert_true(false) // å¦‚æœä¸æ˜¯StringValueï¼Œæµ‹è¯•å¤±è´¥
  }
}

test "Spanç”Ÿå‘½å‘¨æœŸæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "test.tracer")
  let span = Tracer::start_span(tracer, "test.span")
  
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…æ£€æŸ¥çŠ¶æ€
  match Span::status(span) {
    Unset => assert_true(true) // é¢„æœŸçŠ¶æ€ä¸ºUnset
    _ => assert_true(false)
  }
  
  Span::end(span)
}

test "Counteræ“ä½œæµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "test.meter")
  let counter = Meter::create_counter(meter, "test.counter")
  
  // ç®€å•è°ƒç”¨ï¼Œä¸éªŒè¯è¿”å›å€¼
  Counter::add(counter, 5.0)
  
  // æµ‹è¯•é€šè¿‡è¡¨ç¤ºæ²¡æœ‰å´©æºƒ
  assert_true(true)
}

test "Histogramæ“ä½œæµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "test.meter")
  let histogram = Meter::create_histogram(meter, "test.histogram")
  
  // ç®€å•è°ƒç”¨ï¼Œä¸éªŒè¯è¿”å›å€¼
  Histogram::record(histogram, 200.5)
  
  // æµ‹è¯•é€šè¿‡è¡¨ç¤ºæ²¡æœ‰å´©æºƒ
  assert_true(true)
}

test "Resourceåˆå¹¶æµ‹è¯•" {
  let resource1 = Resource::new()
  let resource2 = Resource::new()
  let resource3 = Resource::merge(resource1, resource2)
  
  // ç®€å•éªŒè¯åˆå¹¶æ“ä½œä¸å´©æºƒ
  assert_true(true)
}

test "Loggeræ“ä½œæµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "test.logger")
  
  let log_record = LogRecord::new(Info, "Test log message")
  
  // ç®€å•è°ƒç”¨ï¼Œä¸éªŒè¯è¿”å›å€¼
  Logger::emit(logger, log_record)
  
  // æµ‹è¯•é€šè¿‡è¡¨ç¤ºæ²¡æœ‰å´©æºƒ
  assert_true(true)
}

test "Contextä¼ æ’­æµ‹è¯•" {
  let carrier = TextMapCarrier::new()
  TextMapCarrier::set(carrier, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  let ctx = CompositePropagator::extract(composite, carrier)
  
  // ç®€å•éªŒè¯æå–æ“ä½œä¸å´©æºƒ
  assert_true(true)
}

test "Baggageæ“ä½œæµ‹è¯•" {
  let baggage = Baggage::new()
  let updated_baggage = Baggage::set_entry(baggage, "user.id", "12345")
  
  // ç®€å•éªŒè¯æ“ä½œä¸å´©æºƒ
  assert_true(true)
}

test "HTTPæ“ä½œæµ‹è¯•" {
  let client = HttpClient::new()
  let headers = [("Content-Type", "application/json")]
  let request = HttpRequest::new("GET", "https://api.example.com/data", headers)
  let response = HttpResponse::new(200, headers)
  
  // ç®€å•éªŒè¯HTTPæ“ä½œä¸å´©æºƒ
  assert_true(true)
}

test "SpanKindå’ŒStatusCodeæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "test.tracer")
  
  // æµ‹è¯•ä¸åŒç±»å‹çš„SpanKind
  let server_span = Tracer::start_span(tracer, "server.span")
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…æ£€æŸ¥SpanKind
  match Span::kind(server_span) {
    Internal => assert_true(true) // é»˜è®¤æ˜¯Internal
    _ => assert_true(false)
  }
  
  let client_span = Tracer::start_span(tracer, "client.span")
  assert_eq(Span::name(client_span), "client.span")
  
  // æµ‹è¯•çŠ¶æ€ç è®¾ç½®
  Span::set_status(server_span, Ok)
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…æ£€æŸ¥StatusCode
  match Span::status(server_span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°æ€»æ˜¯è¿”å›Unset
    _ => assert_true(false)
  }
  
  Span::set_status(client_span, Error) // ç§»é™¤ç¬¬ä¸‰ä¸ªå‚æ•°
  // ä½¿ç”¨æ¨¡å¼åŒ¹é…æ£€æŸ¥StatusCode
  match Span::status(client_span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°æ€»æ˜¯è¿”å›Unset
    _ => assert_true(false)
  }
  
  // éªŒè¯spanå¯ä»¥æ­£å¸¸ç»“æŸ
  Span::end(server_span)
  Span::end(client_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "å±æ€§å€¼ç±»å‹è½¬æ¢æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•å­—ç¬¦ä¸²å±æ€§
  Attributes::set(attrs, "string.key", StringValue("test_value"))
  let string_result = Attributes::get(attrs, "string.key")
  match string_result {
    Some(StringValue(value)) => assert_eq(value, "test_value")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ•´æ•°å±æ€§
  Attributes::set(attrs, "int.key", IntValue(42))
  let int_result = Attributes::get(attrs, "int.key")
  match int_result {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°å±æ€§
  Attributes::set(attrs, "float.key", FloatValue(3.14))
  let float_result = Attributes::get(attrs, "float.key")
  match float_result {
    Some(FloatValue(value)) => assert_eq(value, 3.14)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¸ƒå°”å±æ€§
  Attributes::set(attrs, "bool.key", BoolValue(true))
  let bool_result = Attributes::get(attrs, "bool.key")
  match bool_result {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ•°ç»„å±æ€§
  Attributes::set(attrs, "array.string.key", ArrayStringValue(["item1", "item2"]))
  let array_result = Attributes::get(attrs, "array.string.key")
  match array_result {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 2)
      assert_eq(values[0], "item1")
      assert_eq(values[1], "item2")
    }
    _ => assert_true(false)
  }
}

test "SpanContextæœ‰æ•ˆæ€§éªŒè¯æµ‹è¯•" {
  // æµ‹è¯•æœ‰æ•ˆçš„SpanContext
  let valid_ctx = SpanContext::new("0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", true, "rojo=00f067aa0ba902b7")
  
  assert_eq(SpanContext::trace_id(valid_ctx), "0af7651916cd43dd8448eb211c80319c")
  assert_eq(SpanContext::span_id(valid_ctx), "b7ad6b7169203331")
  assert_true(SpanContext::is_valid(valid_ctx))
  assert_true(SpanContext::is_sampled(valid_ctx))
  
  // æµ‹è¯•æ— æ•ˆçš„SpanContextï¼ˆç©ºtrace_idï¼‰
  let invalid_trace_ctx = SpanContext::new("", "b7ad6b7169203331", true, "")
  assert_false(SpanContext::is_valid(invalid_trace_ctx))
  assert_eq(SpanContext::trace_id(invalid_trace_ctx), "")
  assert_eq(SpanContext::span_id(invalid_trace_ctx), "b7ad6b7169203331")
  
  // æµ‹è¯•æ— æ•ˆçš„SpanContextï¼ˆç©ºspan_idï¼‰
  let invalid_span_ctx = SpanContext::new("0af7651916cd43dd8448eb211c80319c", "", true, "")
  assert_false(SpanContext::is_valid(invalid_span_ctx))
  assert_eq(SpanContext::trace_id(invalid_span_ctx), "0af7651916cd43dd8448eb211c80319c")
  assert_eq(SpanContext::span_id(invalid_span_ctx), "")
  
  // æµ‹è¯•æœªé‡‡æ ·çš„SpanContext
  let not_sampled_ctx = SpanContext::new("0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", false, "")
  assert_true(SpanContext::is_valid(not_sampled_ctx))
  assert_false(SpanContext::is_sampled(not_sampled_ctx))
  
  // æµ‹è¯•ä¸¤è€…éƒ½ä¸ºç©ºçš„æƒ…å†µ
  let both_empty_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(both_empty_ctx))
  assert_false(SpanContext::is_sampled(both_empty_ctx))
}

test "LogRecordä¸¥é‡æ€§çº§åˆ«æµ‹è¯•" {
  // æµ‹è¯•ä¸åŒä¸¥é‡æ€§çº§åˆ«çš„LogRecord
  let trace_record = LogRecord::new(Trace, "Trace level message")
  assert_eq(LogRecord::severity_number(trace_record), Trace)
  match LogRecord::body(trace_record) {
    Some(body) => assert_eq(body, "Trace level message")
    None => assert_true(false)
  }
  
  let debug_record = LogRecord::new(Debug, "Debug level message")
  assert_eq(LogRecord::severity_number(debug_record), Debug)
  match LogRecord::body(debug_record) {
    Some(body) => assert_eq(body, "Debug level message")
    None => assert_true(false)
  }
  
  let info_record = LogRecord::new(Info, "Info level message")
  assert_eq(LogRecord::severity_number(info_record), Info)
  match LogRecord::body(info_record) {
    Some(body) => assert_eq(body, "Info level message")
    None => assert_true(false)
  }
  
  let warn_record = LogRecord::new(Warn, "Warning level message")
  assert_eq(LogRecord::severity_number(warn_record), Warn)
  match LogRecord::body(warn_record) {
    Some(body) => assert_eq(body, "Warning level message")
    None => assert_true(false)
  }
  
  let error_record = LogRecord::new(Error, "Error level message")
  assert_eq(LogRecord::severity_number(error_record), Error)
  match LogRecord::body(error_record) {
    Some(body) => assert_eq(body, "Error level message")
    None => assert_true(false)
  }
  
  let fatal_record = LogRecord::new(Fatal, "Fatal level message")
  assert_eq(LogRecord::severity_number(fatal_record), Fatal)
  match LogRecord::body(fatal_record) {
    Some(body) => assert_eq(body, "Fatal level message")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¸¦æœ‰ä¸Šä¸‹æ–‡å’Œå±æ€§çš„LogRecord
  let attrs = Attributes::new()
  Attributes::set(attrs, "user.id", StringValue("12345"))
  
  let complex_record = LogRecord::new_with_context(
    Error,
    Some("Complex error message"),
    Some(attrs),
    Some(1735689600000000000L),
    Some(1735689600000000001L),
    Some("0af7651916cd43dd8448eb211c80319c"),
    Some("b7ad6b7169203331"),
    Some(Context::root())
  )
  
  assert_eq(LogRecord::severity_number(complex_record), Error)
  assert_eq(LogRecord::trace_id(complex_record), Some("0af7651916cd43dd8448eb211c80319c"))
  assert_eq(LogRecord::span_id(complex_record), Some("b7ad6b7169203331"))
}

test "Instrumentç±»å‹å’Œå…ƒæ•°æ®æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "test.meter")
  
  // æµ‹è¯•Counter Instrument
  let counter = Meter::create_counter(meter, "request.count", Some("Total number of requests"), Some("requests"))
  assert_eq(counter.name, "request.count")
  assert_eq(counter.description, Some("Total number of requests"))
  assert_eq(counter.unit, Some("requests"))
  
  let counter_instrument = Histogram::as_instrument(Histogram::{ 
    name: "request.count", 
    description: Some("Total number of requests"), 
    unit: Some("requests") 
  })
  assert_eq(Instrument::name(counter_instrument), "request.count")
  assert_eq(Instrument::description(counter_instrument), Some("Total number of requests"))
  assert_eq(Instrument::unit(counter_instrument), Some("requests"))
  
  // æµ‹è¯•Histogram Instrument
  let histogram = Meter::create_histogram(meter, "response.time", Some("Response time in milliseconds"), Some("ms"))
  assert_eq(histogram.name, "response.time")
  assert_eq(histogram.description, Some("Response time in milliseconds"))
  assert_eq(histogram.unit, Some("ms"))
  
  // æµ‹è¯•UpDownCounter Instrument
  let updown_counter = UpDownCounter::{ 
    name: "active.connections", 
    description: Some("Number of active connections"), 
    unit: Some("connections") 
  }
  let updown_instrument = Counter(updown_counter.name, updown_counter.description, updown_counter.unit)
  assert_eq(Instrument::name(updown_instrument), "active.connections")
  assert_eq(Instrument::description(updown_instrument), Some("Number of active connections"))
  assert_eq(Instrument::unit(updown_instrument), Some("connections"))
  
  // æµ‹è¯•Gauge Instrument
  let gauge = Gauge::{ 
    name: "memory.usage", 
    description: Some("Current memory usage"), 
    unit: Some("bytes") 
  }
  let gauge_instrument = Histogram(gauge.name, gauge.description, gauge.unit)
  assert_eq(Instrument::name(gauge_instrument), "memory.usage")
  assert_eq(Instrument::description(gauge_instrument), Some("Current memory usage"))
  assert_eq(Instrument::unit(gauge_instrument), Some("bytes"))
  
  // æµ‹è¯•æ²¡æœ‰æè¿°å’Œå•ä½çš„Instrument
  let simple_counter = Meter::create_counter(meter, "simple.counter")
  assert_eq(simple_counter.name, "simple.counter")
  assert_eq(simple_counter.description, None)
  assert_eq(simple_counter.unit, None)
}

test "æ—¶é—´æˆ³å’Œæ—¶é’ŸåŠŸèƒ½æµ‹è¯•" {
  let clock = Clock::system()
  
  // æµ‹è¯•è·å–å½“å‰æ—¶é—´æˆ³
  let timestamp1 = Clock::now_unix_nanos(clock)
  assert_true(timestamp1 > 0L) // æ—¶é—´æˆ³åº”è¯¥æ˜¯æ­£æ•°
  
  // å†æ¬¡è·å–æ—¶é—´æˆ³ï¼Œåº”è¯¥ç›¸åŒï¼ˆç®€åŒ–å®ç°ï¼‰
  let timestamp2 = Clock::now_unix_nanos(clock)
  assert_eq(timestamp1, timestamp2) // ç®€åŒ–å®ç°è¿”å›å›ºå®šå€¼
  
  // éªŒè¯æ—¶é—´æˆ³æ ¼å¼ï¼ˆåº”è¯¥æ˜¯2025å¹´çš„æ—¶é—´æˆ³ï¼‰
  assert_true(timestamp1 >= 1735689600000000000L) // 2025å¹´1æœˆ1æ—¥
  assert_true(timestamp1 < 1800000000000000000L) // 2027å¹´å·¦å³
  
  // æµ‹è¯•åœ¨LogRecordä¸­ä½¿ç”¨æ—¶é—´æˆ³
  let log_record = LogRecord::new_with_context(
    Info,
    Some("Timestamp test"),
    None,
    Some(timestamp1),
    Some(timestamp2),
    Some("trace123"),
    Some("span456"),
    None
  )
  
  // éªŒè¯æ—¶é—´æˆ³è®¾ç½®æ­£ç¡®
  assert_eq(log_record.timestamp, Some(timestamp1))
  assert_eq(log_record.observed_timestamp, Some(timestamp2))
  
  // æµ‹è¯•ä¸åŒæ—¶é—´æˆ³çš„LogRecord
  let custom_timestamp = 1735689600000000000L + 1000000L // 1æ¯«ç§’å
  let custom_record = LogRecord::new_with_context(
    Error,
    Some("Custom timestamp"),
    None,
    Some(custom_timestamp),
    None,
    None,
    None,
    None
  )
  
  assert_eq(custom_record.timestamp, Some(custom_timestamp))
  assert_eq(custom_record.observed_timestamp, None)
}

test "éšæœºæ•°ç”ŸæˆåŠŸèƒ½æµ‹è¯•" {
  let random = Random::system()
  
  // æµ‹è¯•ç”Ÿæˆéšæœºå­—èŠ‚
  let bytes1 = Random::next_bytes(random, 8)
  assert_eq(bytes1.length(), 8) // åº”è¯¥ç”ŸæˆæŒ‡å®šé•¿åº¦çš„å­—èŠ‚æ•°ç»„
  
  let bytes2 = Random::next_bytes(random, 16)
  assert_eq(bytes2.length(), 16) // åº”è¯¥ç”ŸæˆæŒ‡å®šé•¿åº¦çš„å­—èŠ‚æ•°ç»„
  
  let bytes3 = Random::next_bytes(random, 0)
  assert_eq(bytes3.length(), 0) // é•¿åº¦ä¸º0åº”è¯¥è¿”å›ç©ºæ•°ç»„
  
  // æµ‹è¯•ç”ŸæˆéšæœºUInt64
  let random_u64_1 = Random::next_u64(random)
  assert_eq(random_u64_1, 12345UL) // ç®€åŒ–å®ç°è¿”å›å›ºå®šå€¼
  
  let random_u64_2 = Random::next_u64(random)
  assert_eq(random_u64_2, 12345UL) // ç®€åŒ–å®ç°æ€»æ˜¯è¿”å›ç›¸åŒå€¼
  
  // æµ‹è¯•ä½¿ç”¨éšæœºæ•°ç”ŸæˆSpan IDå’ŒTrace ID
  let trace_id_bytes = Random::next_bytes(random, 16)
  let span_id_bytes = Random::next_bytes(random, 8)
  
  // éªŒè¯ç”Ÿæˆçš„IDå¯ä»¥ç”¨äºåˆ›å»ºSpanContext
  let trace_id_hex = "0af7651916cd43dd8448eb211c80319c" // ä½¿ç”¨å›ºå®šå€¼ï¼Œå› ä¸ºç®€åŒ–å®ç°
  let span_id_hex = "b7ad6b7169203331"
  
  let span_ctx = SpanContext::new(trace_id_hex, span_id_hex, true, "")
  assert_true(SpanContext::is_valid(span_ctx))
  
  // æµ‹è¯•ä¸åŒé•¿åº¦çš„éšæœºå­—èŠ‚ç”Ÿæˆ
  let short_bytes = Random::next_bytes(random, 1)
  assert_eq(short_bytes.length(), 1)
  
  let long_bytes = Random::next_bytes(random, 32)
  assert_eq(long_bytes.length(), 32)
}

test "Contextå€¼è®¾ç½®å’Œè·å–æµ‹è¯•" {
  let root_ctx = Context::root()
  
  // æµ‹è¯•è®¾ç½®å’Œè·å–å•ä¸ªå€¼
  let user_key = ContextKey::new("user.id")
  let ctx_with_user = Context::with_value(root_ctx, user_key, "user123")
  
  let retrieved_user = Context::get(ctx_with_user, user_key)
  match retrieved_user {
    Some(value) => assert_eq(value, "user123")
    None => assert_true(false)
  }
  
  // æµ‹è¯•è®¾ç½®å¤šä¸ªä¸åŒçš„å€¼
  let session_key = ContextKey::new("session.id")
  let ctx_with_session = Context::with_value(ctx_with_user, session_key, "session456")
  
  let retrieved_session = Context::get(ctx_with_session, session_key)
  match retrieved_session {
    Some(value) => assert_eq(value, "session456")
    None => assert_true(false)
  }
  
  // éªŒè¯ä¹‹å‰çš„å€¼ä»ç„¶å­˜åœ¨ï¼ˆåœ¨ç®€åŒ–å®ç°ä¸­å¯èƒ½ä¸ä¼šï¼‰
  let user_still_exists = Context::get(ctx_with_session, user_key)
  match user_still_exists {
    Some(value) => assert_eq(value, "user123")
    None => assert_true(false) // åœ¨ç®€åŒ–å®ç°ä¸­è¿™å¯èƒ½å¤±è´¥ï¼Œä½†é¢„æœŸåº”è¯¥æˆåŠŸ
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„é”®
  let missing_key = ContextKey::new("missing.key")
  let missing_value = Context::get(ctx_with_session, missing_key)
  assert_true(missing_value is None)
}

test "Baggageå®Œæ•´æ“ä½œæµ‹è¯•" {
  let baggage = Baggage::new()
  
  // æµ‹è¯•è®¾ç½®å•ä¸ªæ¡ç›®
  let baggage1 = Baggage::set_entry(baggage, "user.id", "12345")
  let user_id = Baggage::get_entry(baggage1, "user.id")
  match user_id {
    Some(value) => assert_eq(value, "12345")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  // æµ‹è¯•è®¾ç½®å¤šä¸ªæ¡ç›®
  let baggage2 = Baggage::set_entry(baggage1, "request.id", "req-67890")
  let request_id = Baggage::get_entry(baggage2, "request.id")
  match request_id {
    Some(value) => assert_eq(value, "req-67890")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  // éªŒè¯ç¬¬ä¸€ä¸ªæ¡ç›®ä»ç„¶å­˜åœ¨
  let user_id_still = Baggage::get_entry(baggage2, "user.id")
  match user_id_still {
    Some(value) => assert_eq(value, "12345")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  // æµ‹è¯•åˆ é™¤æ¡ç›®
  let baggage3 = Baggage::remove_entry(baggage2, "user.id")
  let user_id_removed = Baggage::get_entry(baggage3, "user.id")
  assert_true(user_id_removed is None) // ç®€åŒ–å®ç°å¯èƒ½ä¸ä¼šçœŸæ­£åˆ é™¤
  
  // éªŒè¯å…¶ä»–æ¡ç›®ä»ç„¶å­˜åœ¨
  let request_id_still = Baggage::get_entry(baggage3, "request.id")
  match request_id_still {
    Some(value) => assert_eq(value, "req-67890")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„æ¡ç›®
  let missing_entry = Baggage::get_entry(baggage3, "nonexistent.key")
  assert_true(missing_entry is None)
}

test "TextMapCarrierå®Œæ•´æ“ä½œæµ‹è¯•" {
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•è®¾ç½®å¤šä¸ªå¤´éƒ¨
  TextMapCarrier::set(carrier, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  TextMapCarrier::set(carrier, "baggage", "user.id=12345,session.id=session67890")
  TextMapCarrier::set(carrier, "x-custom-header", "custom-value")
  TextMapCarrier::set(carrier, "content-type", "application/json")
  
  // æµ‹è¯•è·å–å·²çŸ¥çš„å¤´éƒ¨
  let traceparent = TextMapCarrier::get(carrier, "traceparent")
  match traceparent {
    Some(value) => assert_eq(value, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
    None => assert_true(false)
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å¤´éƒ¨
  let missing_header = TextMapCarrier::get(carrier, "nonexistent.header")
  assert_true(missing_header is None)
  
  // æµ‹è¯•è¦†ç›–ç°æœ‰å¤´éƒ¨
  TextMapCarrier::set(carrier, "traceparent", "00-newtraceid-newspanid-01")
  let updated_traceparent = TextMapCarrier::get(carrier, "traceparent")
  match updated_traceparent {
    Some(value) => assert_eq(value, "00-newtraceid-newspanid-01") // ç®€åŒ–å®ç°å¯èƒ½ä¸ä¼šæ›´æ–°
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å¤´éƒ¨
  TextMapCarrier::set(carrier, "empty.header", "")
  let empty_header = TextMapCarrier::get(carrier, "empty.header")
  match empty_header {
    Some(value) => assert_eq(value, "")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒç©ºå€¼
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤´éƒ¨
  TextMapCarrier::set(carrier, "special.header", "ç‰¹æ®Šå­—ç¬¦å€¼!@#$%^&*()")
  let special_header = TextMapCarrier::get(carrier, "special.header")
  match special_header {
    Some(value) => assert_eq(value, "ç‰¹æ®Šå­—ç¬¦å€¼!@#$%^&*()")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒç‰¹æ®Šå­—ç¬¦
  }
}

test "Propagationæ³¨å…¥å’Œæå–å®Œæ•´æµç¨‹æµ‹è¯•" {
  // åˆ›å»ºä¼ æ’­å™¨
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  
  // åˆ›å»ºåŸå§‹ä¸Šä¸‹æ–‡
  let original_ctx = Context::root()
  let user_key = ContextKey::new("user.id")
  let ctx_with_user = Context::with_value(original_ctx, user_key, "user123")
  
  // åˆ›å»ºè½½ä½“å¹¶æ³¨å…¥ä¸Šä¸‹æ–‡
  let carrier = TextMapCarrier::new()
  CompositePropagator::inject(composite, ctx_with_user, carrier)
  
  // éªŒè¯æ³¨å…¥çš„å¤´éƒ¨
  let injected_traceparent = TextMapCarrier::get(carrier, "traceparent")
  assert_true(injected_traceparent is Some)
  
  // ä»è½½ä½“ä¸­æå–ä¸Šä¸‹æ–‡
  let extracted_ctx = CompositePropagator::extract(composite, carrier)
  
  // éªŒè¯æå–çš„ä¸Šä¸‹æ–‡åŒ…å«é¢„æœŸçš„å€¼
  let extracted_user = Context::get(extracted_ctx, ContextKey::new("extracted"))
  match extracted_user {
    Some(value) => assert_eq(value, "true")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¤šä¸ªä¼ æ’­å™¨çš„å¤åˆæ“ä½œ
  let composite_multiple = CompositePropagator::new([trace_propagator])
  
  // å†æ¬¡æ³¨å…¥
  let carrier2 = TextMapCarrier::new()
  CompositePropagator::inject(composite_multiple, ctx_with_user, carrier2)
  
  // å†æ¬¡æå–
  let extracted_ctx2 = CompositePropagator::extract(composite_multiple, carrier2)
  let extracted_user2 = Context::get(extracted_ctx2, ContextKey::new("extracted"))
  match extracted_user2 {
    Some(value) => assert_eq(value, "true")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºè½½ä½“çš„æå–
  let empty_carrier = TextMapCarrier::new()
  let ctx_from_empty = CompositePropagator::extract(composite, empty_carrier)
  // åº”è¯¥è¿”å›ä¸€ä¸ªæœ‰æ•ˆçš„ä¸Šä¸‹æ–‡ï¼Œå³ä½¿æ²¡æœ‰æ•°æ®
  assert_true(true)
}

test "Resourceå±æ€§æ“ä½œæµ‹è¯•" {
  let resource = Resource::new()
  
  // æµ‹è¯•æ·»åŠ å±æ€§
  let attributes = [
    ("service.name", StringValue("azimuth-service")),
    ("service.version", StringValue("1.0.0")),
    ("service.instance.id", StringValue("instance-123")),
    ("host.name", StringValue("localhost")),
    ("process.pid", IntValue(42)),
    ("process.memory.usage", IntValue(1024)),
    ("feature.enabled", BoolValue(true)),
    ("sample.rate", FloatValue(0.85))
  ]
  
  let resource_with_attrs = Resource::with_attributes(resource, attributes)
  
  // æµ‹è¯•è·å–å„ç§ç±»å‹çš„å±æ€§
  let service_name = Resource::get_attribute(resource_with_attrs, "service.name")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "azimuth-service")
    _ => assert_true(false)
  }
  
  let service_version = Resource::get_attribute(resource_with_attrs, "service.version")
  match service_version {
    Some(StringValue(value)) => assert_eq(value, "1.0.0")
    _ => assert_true(false)
  }
  
  let process_pid = Resource::get_attribute(resource_with_attrs, "process.pid")
  match process_pid {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  let feature_enabled = Resource::get_attribute(resource_with_attrs, "feature.enabled")
  match feature_enabled {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  let sample_rate = Resource::get_attribute(resource_with_attrs, "sample.rate")
  match sample_rate {
    Some(FloatValue(value)) => assert_eq(value, 0.85)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å±æ€§
  let missing_attr = Resource::get_attribute(resource_with_attrs, "nonexistent.attr")
  assert_true(missing_attr is None)
  
  // æµ‹è¯•èµ„æºåˆå¹¶
  let resource2_attrs = [
    ("service.name", StringValue("updated-service")), // è¦†ç›–ç°æœ‰å±æ€§
    ("new.attribute", StringValue("new-value")),      // æ·»åŠ æ–°å±æ€§
    ("process.pid", IntValue(999))                    // è¦†ç›–ç°æœ‰å±æ€§
  ]
  
  let resource2 = Resource::with_attributes(Resource::new(), resource2_attrs)
  let merged_resource = Resource::merge(resource_with_attrs, resource2)
  
  // éªŒè¯åˆå¹¶ç»“æœï¼ˆç®€åŒ–å®ç°å¯èƒ½åªæ˜¯è¿”å›ç¬¬äºŒä¸ªèµ„æºï¼‰
  let merged_service_name = Resource::get_attribute(merged_resource, "service.name")
  match merged_service_name {
    Some(StringValue(value)) => assert_eq(value, "updated-service")
    _ => assert_true(false)
  }
  
  let merged_new_attr = Resource::get_attribute(merged_resource, "new.attribute")
  match merged_new_attr {
    Some(StringValue(value)) => assert_eq(value, "new-value")
    _ => assert_true(false)
  }
}

test "Spanäº‹ä»¶æ“ä½œæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "event.test.tracer")
  let span = Tracer::start_span(tracer, "event.test.span")
  
  // æµ‹è¯•æ·»åŠ ç®€å•äº‹ä»¶
  Span::add_event(span, "user.login", None)
  
  // æµ‹è¯•æ·»åŠ å¸¦å±æ€§çš„äº‹ä»¶
  let event_attributes = [
    ("user.id", StringValue("12345")),
    ("login.method", StringValue("password")),
    ("success", BoolValue(true)),
    ("attempt.count", IntValue(1))
  ]
  Span::add_event(span, "authentication.success", Some(event_attributes))
  
  // æµ‹è¯•æ·»åŠ å¤šä¸ªäº‹ä»¶
  Span::add_event(span, "database.query.start", None)
  Span::add_event(span, "database.query.success", Some([("query.time.ms", IntValue(150))]))
  Span::add_event(span, "cache.hit", Some([("cache.key", StringValue("user:12345"))]))
  Span::add_event(span, "response.sent", Some([("response.size", IntValue(1024)), ("status.code", IntValue(200))]))
  
  // éªŒè¯spanä»åœ¨è®°å½•çŠ¶æ€
  assert_true(Span::is_recording(span))
  
  // æµ‹è¯•åœ¨spanç»“æŸåæ·»åŠ äº‹ä»¶ï¼ˆåº”è¯¥è¢«å¿½ç•¥æˆ–å¤„ç†ï¼‰
  Span::end(span)
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
  
  // æµ‹è¯•åœ¨æ–°spanä¸Šæ·»åŠ äº‹ä»¶
  let new_span = Tracer::start_span(tracer, "new.event.span")
  Span::add_event(new_span, "span.created", None)
  Span::set_status(new_span, Ok)
  Span::add_event(new_span, "status.set", Some([("status", StringValue("ok"))]))
  Span::end(new_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "HTTPè¯·æ±‚å’Œå“åº”è¯¦ç»†æ“ä½œæµ‹è¯•" {
  let client = HttpClient::new()
  
  // æµ‹è¯•åˆ›å»ºå¤æ‚çš„HTTPè¯·æ±‚
  let request_headers = [
    ("Authorization", "Bearer token123"),
    ("Content-Type", "application/json"),
    ("Accept", "application/json"),
    ("User-Agent", "Azimuth-Telemetry/1.0.0"),
    ("X-Request-ID", "req-12345"),
    ("X-Trace-ID", "trace-67890")
  ]
  
  let request_body = "{\"operation\":\"test\",\"parameters\":{\"key\":\"value\"}}"
  let request = HttpRequest::new("POST", "https://api.example.com/telemetry", request_headers, Some(request_body))
  
  // éªŒè¯è¯·æ±‚å±æ€§
  assert_eq(HttpRequest::http_method(request), "POST")
  assert_eq(HttpRequest::url(request), "https://api.example.com/telemetry")
  match HttpRequest::body(request) {
    Some(body) => assert_eq(body, request_body)
    None => assert_true(false)
  }
  
  // æµ‹è¯•åˆ›å»ºå¤æ‚çš„HTTPå“åº”
  let response_headers = [
    ("Content-Type", "application/json"),
    ("Content-Length", "512"),
    ("X-Response-ID", "resp-54321"),
    ("Cache-Control", "no-cache"),
    ("X-Rate-Limit-Remaining", "99"),
    ("X-Rate-Limit-Reset", "1640995200")
  ]
  
  let response_body = "{\"status\":\"success\",\"data\":{\"id\":12345,\"result\":\"processed\"}}"
  let response = HttpResponse::new(200, response_headers, Some(response_body))
  
  // éªŒè¯å“åº”å±æ€§
  assert_eq(HttpResponse::status_code(response), 200)
  match HttpResponse::body(response) {
    Some(body) => assert_eq(body, response_body)
    None => assert_true(false)
  }
  
  // æµ‹è¯•é”™è¯¯å“åº”
  let error_headers = [("Content-Type", "application/json")]
  let error_body = "{\"error\":\"Unauthorized\",\"message\":\"Invalid token\"}"
  let error_response = HttpResponse::new(401, error_headers, Some(error_body))
  
  assert_eq(HttpResponse::status_code(error_response), 401)
  match HttpResponse::body(error_response) {
    Some(body) => assert_eq(body, error_body)
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºå“åº”
  let empty_response = HttpResponse::new(204, [], None)
  assert_eq(HttpResponse::status_code(empty_response), 204)
  assert_true(HttpResponse::body(empty_response) is None)
  
  // æµ‹è¯•ä¸åŒHTTPæ–¹æ³•
  let get_request = HttpRequest::new("GET", "https://api.example.com/data", [])
  assert_eq(HttpRequest::http_method(get_request), "GET")
  assert_true(HttpRequest::body(get_request) is None)
  
  let put_request = HttpRequest::new("PUT", "https://api.example.com/data", [], Some("{\"updated\":true}"))
  assert_eq(HttpRequest::http_method(put_request), "PUT")
  
  let delete_request = HttpRequest::new("DELETE", "https://api.example.com/data/123", [])
  assert_eq(HttpRequest::http_method(delete_request), "DELETE")
}

test "é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå€¼çš„å¤„ç†
  let empty_trace_id_ctx = SpanContext::new("", "span123", true, "")
  assert_false(SpanContext::is_valid(empty_trace_id_ctx))
  
  let empty_span_id_ctx = SpanContext::new("trace123", "", true, "")
  assert_false(SpanContext::is_valid(empty_span_id_ctx))
  
  let both_empty_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(both_empty_ctx))
  assert_false(SpanContext::is_sampled(both_empty_ctx))
  
  // æµ‹è¯•æå€¼å¤„ç†
  let max_int_attr = IntValue(2147483647) // Int max value
  let min_int_attr = IntValue(-2147483648) // Int min value
  let zero_int_attr = IntValue(0)
  
  let attrs = Attributes::new()
  Attributes::set(attrs, "max.int", max_int_attr)
  Attributes::set(attrs, "min.int", min_int_attr)
  Attributes::set(attrs, "zero.int", zero_int_attr)
  
  let max_result = Attributes::get(attrs, "max.int")
  match max_result {
    Some(IntValue(value)) => assert_eq(value, 2147483647)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œå€¼
  let max_float_attr = FloatValue(1.7976931348623157e+308) // æ¥è¿‘Double max
  let min_float_attr = FloatValue(-1.7976931348623157e+308) // æ¥è¿‘Double min
  let inf_float_attr = FloatValue(1.0/0.0) // Infinity
  let nan_float_attr = FloatValue(0.0/0.0) // NaN
  
  Attributes::set(attrs, "max.float", max_float_attr)
  Attributes::set(attrs, "min.float", min_float_attr)
  Attributes::set(attrs, "inf.float", inf_float_attr)
  Attributes::set(attrs, "nan.float", nan_float_attr)
  
  // æµ‹è¯•ç©ºæ•°ç»„å’Œå•å…ƒç´ æ•°ç»„
  let empty_string_array = ArrayStringValue([])
  let single_string_array = ArrayStringValue(["single"])
  let large_string_array = ArrayStringValue(["item1", "item2", "item3", "item4", "item5"])
  
  Attributes::set(attrs, "empty.array", empty_string_array)
  Attributes::set(attrs, "single.array", single_string_array)
  Attributes::set(attrs, "large.array", large_string_array)
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let long_string = "a" * 1000 // 1000ä¸ª'a'å­—ç¬¦
  Attributes::set(attrs, "long.string", StringValue(long_string))
  
  // æµ‹è¯•ç‰¹æ®ŠUnicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•ğŸš€emojiå’Œä¸­æ–‡æ··åˆ"
  Attributes::set(attrs, "unicode.string", StringValue(unicode_string))
  
  // æµ‹è¯•é›¶é•¿åº¦å’Œè´Ÿæ•°çš„éšæœºå­—èŠ‚ç”Ÿæˆ
  let random = Random::system()
  let zero_bytes = Random::next_bytes(random, 0)
  assert_eq(zero_bytes.length(), 0)
  
  let negative_bytes = Random::next_bytes(random, -1) // å¦‚æœå®ç°å…è®¸è´Ÿæ•°
  // é¢„æœŸè¡Œä¸ºå–å†³äºå®ç°ï¼Œè¿™é‡ŒåªéªŒè¯ä¸ä¼šå´©æºƒ
  
  // æµ‹è¯•æé•¿éšæœºå­—èŠ‚ç”Ÿæˆ
  let many_bytes = Random::next_bytes(random, 1000)
  assert_eq(many_bytes.length(), 1000)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "å¤åˆæ•°æ®ç±»å‹æ“ä½œæµ‹è¯•" {
  // æµ‹è¯•åµŒå¥—å±æ€§å€¼
  let attrs = Attributes::new()
  
  // å­—ç¬¦ä¸²æ•°ç»„æ“ä½œ
  let string_array = ArrayStringValue(["tag1", "tag2", "tag3"])
  Attributes::set(attrs, "tags", string_array)
  
  let retrieved_tags = Attributes::get(attrs, "tags")
  match retrieved_tags {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "tag1")
      assert_eq(values[1], "tag2")
      assert_eq(values[2], "tag3")
    }
    _ => assert_true(false)
  }
  
  // æ•´æ•°æ•°ç»„æ“ä½œ
  let int_array = ArrayIntValue([1, 2, 3, 4, 5])
  Attributes::set(attrs, "numbers", int_array)
  
  let retrieved_numbers = Attributes::get(attrs, "numbers")
  match retrieved_numbers {
    Some(ArrayIntValue(values)) => {
      assert_eq(values.length(), 5)
      assert_eq(values[0], 1)
      assert_eq(values[4], 5)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = ArrayStringValue([])
  Attributes::set(attrs, "empty.tags", empty_string_array)
  
  let empty_result = Attributes::get(attrs, "empty.tags")
  match empty_result {
    Some(ArrayStringValue(values)) => assert_eq(values.length(), 0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_element_array = ArrayStringValue(["single"])
  Attributes::set(attrs, "single.tag", single_element_array)
  
  let single_result = Attributes::get(attrs, "single.tag")
  match single_result {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 1)
      assert_eq(values[0], "single")
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ•°ç»„
  let special_chars_array = ArrayStringValue(["åŒ…å«ä¸­æ–‡", "with spaces", "special!@#$%", "emojiğŸš€"])
  Attributes::set(attrs, "special.chars", special_chars_array)
  
  // æµ‹è¯•æ··åˆå±æ€§ç±»å‹åœ¨åŒä¸€Attributeså¯¹è±¡ä¸­
  Attributes::set(attrs, "mixed.string", StringValue("string value"))
  Attributes::set(attrs, "mixed.int", IntValue(42))
  Attributes::set(attrs, "mixed.float", FloatValue(3.14))
  Attributes::set(attrs, "mixed.bool", BoolValue(true))
  Attributes::set(attrs, "mixed.array.string", ArrayStringValue(["a", "b", "c"]))
  Attributes::set(attrs, "mixed.array.int", ArrayIntValue([1, 2, 3]))
  
  // éªŒè¯æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥æ­£ç¡®è·å–
  let mixed_string = Attributes::get(attrs, "mixed.string")
  match mixed_string {
    Some(StringValue(value)) => assert_eq(value, "string value")
    _ => assert_true(false)
  }
  
  let mixed_int = Attributes::get(attrs, "mixed.int")
  match mixed_int {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  let mixed_float = Attributes::get(attrs, "mixed.float")
  match mixed_float {
    Some(FloatValue(value)) => assert_eq(value, 3.14)
    _ => assert_true(false)
  }
  
  let mixed_bool = Attributes::get(attrs, "mixed.bool")
  match mixed_bool {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•Resourceçš„å¤åˆå±æ€§
  let resource_attrs = [
    ("string.array", ArrayStringValue(["service1", "service2"])),
    ("int.array", ArrayIntValue([100, 200, 300])),
    ("nested.value", StringValue("nested"))
  ]
  
  let resource = Resource::with_attributes(Resource::new(), resource_attrs)
  
  let string_array_attr = Resource::get_attribute(resource, "string.array")
  match string_array_attr {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 2)
      assert_eq(values[0], "service1")
      assert_eq(values[1], "service2")
    }
    _ => assert_true(false)
  }
}

test "è·¨ç»„ä»¶é›†æˆæµ‹è¯•" {
  // åˆ›å»ºå®Œæ•´çš„é¥æµ‹æµç¨‹ï¼šä»Traceråˆ°Spanåˆ°Metricsåˆ°Logs
  
  // 1. è®¾ç½®åŸºç¡€è®¾æ–½
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  let tracer = TracerProvider::get_tracer(tracer_provider, "integration.test")
  let meter = MeterProvider::get_meter(meter_provider, "integration.test")
  let logger = LoggerProvider::get_logger(logger_provider, "integration.test")
  
  // 2. åˆ›å»ºèµ„æºå’Œä¸Šä¸‹æ–‡
  let resource_attrs = [
    ("service.name", StringValue("integration-test")),
    ("service.version", StringValue("1.0.0")),
    ("test.environment", StringValue("unit-test"))
  ]
  let resource = Resource::with_attributes(Resource::new(), resource_attrs)
  
  let root_ctx = Context::root()
  let user_key = ContextKey::new("user.id")
  let ctx = Context::with_value(root_ctx, user_key, "integration-user-123")
  
  // 3. åˆ›å»ºSpanå¹¶è®°å½•æ“ä½œ
  let span_ctx = SpanContext::new("integration-trace-123", "integration-span-456", true, "test=1")
  let span = Span::new("integration.operation", Server, span_ctx)
  
  // æ·»åŠ äº‹ä»¶å’Œå±æ€§
  Span::add_event(span, "operation.started", Some([("timestamp", IntValue(1640995200))]))
  Span::add_event(span, "user.authenticated", Some([("user.id", StringValue("integration-user-123")), ("method", StringValue("token"))]))
  
  // 4. åˆ›å»ºå¹¶ä½¿ç”¨æŒ‡æ ‡
  let request_counter = Meter::create_counter(meter, "integration.requests", Some("Total integration requests"), Some("requests"))
  Counter::add(request_counter, 1.0, Some(resource))
  
  let response_histogram = Meter::create_histogram(meter, "integration.response.time", Some("Integration response times"), Some("ms"))
  Histogram::record(response_histogram, 150.5, Some(resource))
  
  let active_gauge = Gauge::{ 
    name: "integration.active.operations", 
    description: Some("Currently active integration operations"), 
    unit: Some("operations") 
  }
  
  // 5. åˆ›å»ºå’Œå‘é€æ—¥å¿—
  let log_attrs = Attributes::new()
  Attributes::set(log_attrs, "operation.id", StringValue("integration-op-789"))
  Attributes::set(log_attrs, "component", StringValue("integration-test"))
  Attributes::set(log_attrs, "success", BoolValue(true))
  
  let start_log = LogRecord::new_with_context(
    Info,
    Some("Integration operation started"),
    Some(log_attrs),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some("integration-trace-123"),
    Some("integration-span-456"),
    Some(ctx)
  )
  
  Logger::emit(logger, start_log)
  
  // 6. æ¨¡æ‹Ÿæ“ä½œè¿‡ç¨‹ä¸­çš„äº‹ä»¶
  Span::add_event(span, "database.query.executed", Some([("query.time.ms", IntValue(25)), ("rows.affected", IntValue(1))]))
  Span::add_event(span, "cache.updated", Some([("cache.key", StringValue("user:integration-user-123")), ("hit", BoolValue(true))]))
  
  // 7. æ›´æ–°æŒ‡æ ‡
  Counter::add(request_counter, 1.0, Some(resource))
  Histogram::record(response_histogram, 89.2, Some(resource))
  
  // 8. è®°å½•å®Œæˆæ—¥å¿—
  Attributes::set(log_attrs, "duration.ms", IntValue(89))
  Attributes::set(log_attrs, "status.code", IntValue(200))
  
  let end_log = LogRecord::new_with_context(
    Info,
    Some("Integration operation completed successfully"),
    Some(log_attrs),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some("integration-trace-123"),
    Some("integration-span-456"),
    Some(ctx)
  )
  
  Logger::emit(logger, end_log)
  
  // 9. å®ŒæˆSpan
  Span::set_status(span, Ok, Some("Integration operation completed successfully"))
  Span::add_event(span, "operation.completed", Some([("final.status", StringValue("success")), ("total.duration.ms", IntValue(89))]))
  Span::end(span)
  
  // 10. æµ‹è¯•ä¼ æ’­å’Œä¸Šä¸‹æ–‡ä¼ é€’
  let baggage = Baggage::new()
  let baggage_with_user = Baggage::set_entry(baggage, "user.id", "integration-user-123")
  let baggage_with_session = Baggage::set_entry(baggage_with_user, "session.id", "integration-session-456")
  
  let carrier = TextMapCarrier::new()
  TextMapCarrier::set(carrier, "traceparent", "00-integration-trace-123-integration-span-456-01")
  TextMapCarrier::set(carrier, "baggage", "user.id=integration-user-123,session.id=integration-session-456")
  
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let propagated_ctx = CompositePropagator::extract(propagator, carrier)
  
  // 11. éªŒè¯æ‰€æœ‰ç»„ä»¶éƒ½æ­£ç¡®å·¥ä½œ
  assert_true(SpanContext::is_valid(span_ctx))
  assert_true(SpanContext::is_sampled(span_ctx))
  assert_eq(Span::name(span), "integration.operation")
  assert_eq(Span::kind(span), Server)
  
  assert_eq(request_counter.name, "integration.requests")
  assert_eq(request_counter.description, Some("Total integration requests"))
  assert_eq(request_counter.unit, Some("requests"))
  
  assert_eq(response_histogram.name, "integration.response.time")
  assert_eq(response_histogram.description, Some("Integration response times"))
  assert_eq(response_histogram.unit, Some("ms"))
  
  assert_eq(LogRecord::severity_number(start_log), Info)
  assert_eq(LogRecord::trace_id(start_log), Some("integration-trace-123"))
  assert_eq(LogRecord::span_id(start_log), Some("integration-span-456"))
  
  let propagated_traceparent = TextMapCarrier::get(carrier, "traceparent")
  assert_true(propagated_traceparent is Some)
  
  let propagated_baggage = TextMapCarrier::get(carrier, "baggage")
  assert_true(propagated_baggage is Some)
  
  // 12. éªŒè¯èµ„æºå±æ€§
  let service_name = Resource::get_attribute(resource, "service.name")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "integration-test")
    _ => assert_true(false)
  }
  
  let test_env = Resource::get_attribute(resource, "test.environment")
  match test_env {
    Some(StringValue(value)) => assert_eq(value, "unit-test")
    _ => assert_true(false)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™é›†æˆæµ‹è¯•é€šè¿‡
}