// Azimuth ç»¼åˆå•å…ƒæµ‹è¯•
// åŒ…å«10ä¸ªé«˜è´¨é‡çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹

test "add_function_performance_validation" {
  // åŠ æ³•å‡½æ•°æ€§èƒ½éªŒè¯æµ‹è¯•
  // æµ‹è¯•è¿žç»­åŠ æ³•è¿ç®—çš„æ­£ç¡®æ€§
  let result = add(add(add(1, 2), add(3, 4)), add(5, 6))
  assert_eq(21, result)  // (1+2)+(3+4)+(5+6) = 3+7+11 = 21
  
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let large_result = add(500000, 500000)
  assert_eq(1000000, large_result)
}

test "multiply_function_zero_handling" {
  // ä¹˜æ³•å‡½æ•°é›¶å¤„ç†æµ‹è¯•
  // éªŒè¯é›¶å…ƒç´ çš„å„ç§æƒ…å†µ
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 123))
  assert_eq(0, multiply(123, 0))
  assert_eq(0, multiply(-123, 0))
  assert_eq(0, multiply(0, -123))
}

test "greet_function_empty_and_special_inputs" {
  // é—®å€™å‡½æ•°ç©ºå€¼å’Œç‰¹æ®Šè¾“å…¥æµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,  !", greet(" "))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \n!", greet("\n"))
  assert_eq_string("Hello, \t!", greet("\t"))
}

test "divide_with_ceil_negative_scenarios" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿæ•°åœºæ™¯æµ‹è¯•
  // æµ‹è¯•è¢«é™¤æ•°ä¸ºè´Ÿçš„æƒ…å†µ
  assert_eq(-2, divide_with_ceil(-5, 3))
  assert_eq(-1, divide_with_ceil(-2, 3))
  assert_eq(-3, divide_with_ceil(-8, 3))
  
  // æµ‹è¯•é™¤æ•°ä¸ºè´Ÿçš„æƒ…å†µ
  assert_eq(-2, divide_with_ceil(5, -3))
  assert_eq(-1, divide_with_ceil(2, -3))
  assert_eq(-3, divide_with_ceil(8, -3))
}

test "complex_calculation_workflow" {
  // å¤æ‚è®¡ç®—å·¥ä½œæµæµ‹è¯•
  // æ¨¡æ‹Ÿå®žé™…ä¸šåŠ¡åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_size = 12
  let tasks_per_member = 8
  let total_tasks = multiply(team_size, tasks_per_member)
  
  let daily_capacity = 15
  let days_needed = divide_with_ceil(total_tasks, daily_capacity)
  
  assert_eq(96, total_tasks)  // 12 * 8 = 96
  assert_eq(7, days_needed)   // ceil(96/15) = 7
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(105, total_capacity)
}

test "mathematical_identity_verification" {
  // æ•°å­¦æ’ç­‰å¼éªŒè¯æµ‹è¯•
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(-x, multiply(x, -1))
  assert_eq(-x, multiply(-1, x))
}

test "resource_allocation_boundary_test" {
  // èµ„æºåˆ†é…è¾¹ç•Œæµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—ä¼šè®®å®¤éœ€æ±‚
  let attendees = 95
  let room_capacity = 20
  let rooms_needed = divide_with_ceil(attendees, room_capacity)
  
  assert_eq(5, rooms_needed)  // ceil(95/20) = 5
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(rooms_needed, room_capacity)
  assert_eq(100, total_capacity)
  
  // éªŒè¯å‰©ä½™å®¹é‡
  let remaining_capacity = subtract(total_capacity, attendees)
  assert_eq(5, remaining_capacity)
}

test "string_processing_unicode_support" {
  // å­—ç¬¦ä¸²å¤„ç†Unicodeæ”¯æŒæµ‹è¯•
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, EspaÃ±ol!", greet("EspaÃ±ol"))
  assert_eq_string("Hello, FranÃ§ais!", greet("FranÃ§ais"))
  assert_eq_string("Hello, Ð ÑƒÑÑÐºÐ¸Ð¹!", greet("Ð ÑƒÑÑÐºÐ¸Ð¹"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ðŸŽ‰!", greet("ðŸŽ‰"))
  assert_eq_string("Hello, ðŸ’»!", greet("ðŸ’»"))
}

test "error_handling_comprehensive" {
  // ç»¼åˆé”™è¯¯å¤„ç†æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(1000000, 0))
  assert_eq(0, divide_with_ceil(-1000000, 0))
}

test "algorithm_efficiency_validation" {
  // ç®—æ³•æ•ˆçŽ‡éªŒè¯æµ‹è¯•
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•å¤æ‚åº¦çš„åœºæ™¯
  let input_size = 1000
  
  // O(1) ç®—æ³•æ¨¡æ‹Ÿ
  let constant_time = multiply(1, input_size)
  assert_eq(1000, constant_time)
  
  // O(n) ç®—æ³•æ¨¡æ‹Ÿ
  let linear_time = multiply(input_size, 2)
  assert_eq(2000, linear_time)
  
  // O(log n) ç®—æ³•æ¨¡æ‹Ÿï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  let logarithmic_time = divide_with_ceil(input_size, 100)
  assert_eq(10, logarithmic_time)
  
  // éªŒè¯æ•ˆçŽ‡å·®å¼‚
  let efficiency_ratio = divide_with_ceil(linear_time, logarithmic_time)
  assert_eq(200, efficiency_ratio)
}

// è¾…åŠ©å‡½æ•°
fn subtract(a : Int, b : Int) -> Int {
  a - b
}