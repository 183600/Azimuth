// è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºä¸åŒå¹³å°å’Œç¯å¢ƒä¸‹çš„å…¼å®¹æ€§éªŒè¯

test "è·¨å¹³å°æ—¶é’Ÿå’Œéšæœºæ•°ç”Ÿæˆå…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•æ—¶é’Ÿç³»ç»Ÿå…¼å®¹æ€§
  let system_clock = Clock::system()
  let timestamp1 = Clock::now_unix_nanos(system_clock)
  let timestamp2 = Clock::now_unix_nanos(system_clock)
  
  // éªŒè¯æ—¶é’ŸåŸºæœ¬åŠŸèƒ½ï¼ˆè·¨å¹³å°ä¸€è‡´æ€§ï¼‰
  assert_true(timestamp1 > 0L)
  assert_true(timestamp2 >= timestamp1)  // æ—¶é—´åº”è¯¥é€’è¿›
  assert_true(timestamp2 - timestamp1 < 1000000000L)  // å·®å¼‚åº”è¯¥åˆç†ï¼ˆå°äº1ç§’ï¼‰
  
  // æµ‹è¯•å¤šæ¬¡æ—¶é’Ÿè°ƒç”¨çš„ç¨³å®šæ€§
  let timestamps = Array::new()
  for i = 0; i < 10; i = i + 1 {
    let ts = Clock::now_unix_nanos(system_clock)
    timestamps.push(ts)
  }
  
  // éªŒè¯æ—¶é—´æˆ³é€’å¢æ€§
  for i = 1; i < timestamps.length(); i = i + 1 {
    assert_true(timestamps[i] >= timestamps[i - 1])
  }
  
  // æµ‹è¯•éšæœºæ•°ç”Ÿæˆå™¨è·¨å¹³å°å…¼å®¹æ€§
  let system_random = Random::system()
  
  // æµ‹è¯•éšæœºå­—èŠ‚ç”Ÿæˆ
  let random_bytes_8 = Random::next_bytes(system_random, 8)
  let random_bytes_16 = Random::next_bytes(system_random, 16)
  let random_bytes_32 = Random::next_bytes(system_random, 32)
  
  // éªŒè¯å­—èŠ‚é•¿åº¦ï¼ˆè·¨å¹³å°ä¸€è‡´æ€§ï¼‰
  assert_eq(random_bytes_8.length(), 8)
  assert_eq(random_bytes_16.length(), 16)
  assert_eq(random_bytes_32.length(), 32)
  
  // æµ‹è¯•éšæœºæ•°ç”Ÿæˆçš„ä¸€è‡´æ€§
  let random_values = Array::new()
  for i = 0; i < 20; i = i + 1 {
    let random_u64 = Random::next_u64(system_random)
    random_values.push(random_u64)
  }
  
  // éªŒè¯éšæœºæ•°åŸºæœ¬å±æ€§
  for random_val in random_values {
    assert_true(random_val >= 0UL)
  }
  
  // æµ‹è¯•éšæœºæ•°åˆ†å¸ƒï¼ˆç®€å•éªŒè¯ï¼‰
  let sum = 0UL
  for val in random_values {
    sum = sum + val
  }
  let average = sum / random_values.length().to_uint64()
  
  // å¹³å‡å€¼åº”è¯¥åœ¨åˆç†èŒƒå›´å†…
  assert_true(average >= 0UL)
}

test "è·¨å¹³å°å­—ç¬¦ä¸²å’Œç¼–ç å…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•åŸºæœ¬å­—ç¬¦ä¸²æ“ä½œè·¨å¹³å°ä¸€è‡´æ€§
  let basic_strings = [
    "",
    "hello",
    "Hello World",
    "1234567890",
    "abcdefghijklmnopqrstuvwxyz",
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "hello world"
  ]
  
  for str in basic_strings {
    assert_eq(str.length(), str.length())  // é•¿åº¦è®¡ç®—ä¸€è‡´æ€§
    assert_true(str.length() >= 0)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²è·¨å¹³å°å¤„ç†
  let special_char_strings = [
    "!@#$%^&*()_+-=[]{}|;':\",./<>?",
    " \t\n\r",
    "[]{}()<>",
    "''\"\"",
    "&&||!!"
  ]
  
  for special_str in special_char_strings {
    assert_eq(special_str.length(), special_str.length())
    assert_true(special_str.length() > 0)
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²è·¨å¹³å°å…¼å®¹æ€§
  let unicode_strings = [
    "æµ‹è¯•ä¸­æ–‡",
    "Ğ¢ĞµÑÑ‚ Ñ€ÑƒÑÑĞºĞ¸Ğ¹",
    "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",
    "ğŸš€ğŸ”¥ğŸ’©",
    "Test æµ‹è¯• Ğ¢ĞµÑÑ‚ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ğŸš€",
    "æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ",
    "í•œêµ­ì–´í…ŒìŠ¤íŠ¸",
    "EspaÃ±ol prueba",
    "FranÃ§ais essai",
    "Deutsch Test"
  ]
  
  for unicode_str in unicode_strings {
    assert_eq(unicode_str.length(), unicode_str.length())
    assert_true(unicode_str.length() > 0)
  }
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ‹¼æ¥è·¨å¹³å°ä¸€è‡´æ€§
  let str1 = "Hello"
  let str2 = " World"
  let str3 = "!"
  let concatenated = str1 + str2 + str3
  
  assert_eq(concatenated, "Hello World!")
  assert_eq(concatenated.length(), 12)
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²å¤„ç†è·¨å¹³å°å…¼å®¹æ€§
  let very_long_string = "a" * 1000 + "b" * 1000 + "c" * 1000
  assert_eq(very_long_string.length(), 3000)
  
  // æµ‹è¯•æ··åˆå­—ç¬¦ç±»å‹å­—ç¬¦ä¸²
  let mixed_string = "Hello" + "æµ‹è¯•" + "ğŸš€" + "123" + "Ğ¢ĞµÑÑ‚"
  assert_eq(mixed_string.length(), mixed_string.length())
  assert_true(mixed_string.length() > 0)
}

test "è·¨å¹³å°æ•°å€¼ç±»å‹å…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•æ•´æ•°ç±»å‹è·¨å¹³å°ä¸€è‡´æ€§
  let int_values = [
    0, 1, -1, 42, -42,
    2147483647,  // Int max
    -2147483648, // Int min
    1000000, -1000000
  ]
  
  for int_val in int_values {
    let double_val = int_val.to_double()
    let string_val = int_val.to_string()
    
    assert_true(double_val >= -2147483648.0)
    assert_true(double_val <= 2147483647.0)
    assert_true(string_val.length() > 0)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°ç±»å‹è·¨å¹³å°ä¸€è‡´æ€§
  let float_values = [
    0.0, 1.0, -1.0, 3.14159, -3.14159,
    1.7976931348623157e+308,  // Double max
    -1.7976931348623157e+308, // Double min
    1.23e-10, -1.23e-10
  ]
  
  for float_val in float_values {
    let int_val = float_val as Int
    let string_val = float_val.to_string()
    
    assert_true(string_val.length() > 0)
    assert_true(int_val >= -2147483648)
    assert_true(int_val <= 2147483647)
  }
  
  // æµ‹è¯•æ•°å€¼è¿ç®—è·¨å¹³å°ä¸€è‡´æ€§
  for i = 0; i < 100; i = i + 1 {
    let a = i
    let b = i * 2
    let sum = a + b
    let product = a * b
    let difference = b - a
    
    assert_eq(sum, i * 3)
    assert_eq(product, i * i * 2)
    assert_eq(difference, i)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¿ç®—è·¨å¹³å°ä¸€è‡´æ€§
  for i = 0; i < 50; i = i + 1 {
    let a = i.to_double()
    let b = i.to_double() * 1.5
    let sum = a + b
    let product = a * b
    
    assert_true(sum >= 0.0)
    assert_true(product >= 0.0)
  }
}

test "è·¨å¹³å°æ•°ç»„æ“ä½œå…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•æ•´æ•°æ•°ç»„è·¨å¹³å°ä¸€è‡´æ€§
  let int_arrays = [
    [],
    [1],
    [1, 2, 3],
    [0, -1, 42, -42, 2147483647, -2147483648]
  ]
  
  for int_array in int_arrays {
    assert_eq(int_array.length(), int_array.length())
    assert_true(int_array.length() >= 0)
    
    // æµ‹è¯•æ•°ç»„è®¿é—®
    if int_array.length() > 0 {
      assert_eq(int_array[0], int_array[0])
      assert_eq(int_array[int_array.length() - 1], int_array[int_array.length() - 1])
    }
  }
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ•°ç»„è·¨å¹³å°ä¸€è‡´æ€§
  let string_arrays = [
    [],
    ["hello"],
    ["hello", "world", "æµ‹è¯•", "ğŸš€"],
    ["", " ", "\t", "\n", "special!@#$%"]
  ]
  
  for string_array in string_arrays {
    assert_eq(string_array.length(), string_array.length())
    assert_true(string_array.length() >= 0)
    
    // æµ‹è¯•æ•°ç»„è®¿é—®
    if string_array.length() > 0 {
      assert_eq(string_array[0], string_array[0])
      assert_eq(string_array[string_array.length() - 1], string_array[string_array.length() - 1])
    }
  }
  
  // æµ‹è¯•æ•°ç»„åˆ›å»ºå’Œæ“ä½œè·¨å¹³å°ä¸€è‡´æ€§
  let large_int_array = Array::new()
  for i = 0; i < 1000; i = i + 1 {
    large_int_array.push(i)
  }
  
  assert_eq(large_int_array.length(), 1000)
  assert_eq(large_int_array[0], 0)
  assert_eq(large_int_array[999], 999)
  assert_eq(large_int_array[500], 500)
  
  // æµ‹è¯•æ•°ç»„éå†è·¨å¹³å°ä¸€è‡´æ€§
  let sum = 0
  for val in large_int_array {
    sum = sum + val
  }
  assert_eq(sum, 1000 * 999 / 2)  // 0 + 1 + 2 + ... + 999
  
  // æµ‹è¯•æ··åˆç±»å‹æ•°ç»„
  let mixed_array = ["hello", 42, 3.14, true, "æµ‹è¯•", "ğŸš€"]
  assert_eq(mixed_array.length(), 6)
}

test "è·¨å¹³å°Optionç±»å‹å¤„ç†å…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•Option[Int]è·¨å¹³å°ä¸€è‡´æ€§
  let some_int_values = [Some(0), Some(1), Some(-1), Some(42), Some(-42)]
  let none_int = None
  
  for some_val in some_int_values {
    assert_true(some_val is Some)
    assert_false(some_val is None)
    assert_false(some_val == None)
  }
  
  assert_true(none_int is None)
  assert_false(none_int is Some)
  assert_true(none_int == None)
  
  // æµ‹è¯•Option[String]è·¨å¹³å°ä¸€è‡´æ€§
  let some_string_values = [Some(""), Some("hello"), Some("æµ‹è¯•"), Some("ğŸš€")]
  let none_string = None
  
  for some_str in some_string_values {
    assert_true(some_str is Some)
    assert_false(some_str is None)
    assert_false(some_str == None)
  }
  
  assert_true(none_string is None)
  assert_false(none_string is Some)
  assert_true(none_string == None)
  
  // æµ‹è¯•OptionåŒ¹é…è·¨å¹³å°ä¸€è‡´æ€§
  for some_val in some_int_values {
    match some_val {
      Some(value) => assert_true(value >= -42 && value <= 42)
      _ => assert_true(false)  // ä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œ
    }
  }
  
  match none_int {
    Some(_) => assert_true(false)  // ä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œ
    None => assert_true(true)      // åº”è¯¥åˆ°è¾¾è¿™é‡Œ
  }
}

test "è·¨å¹³å°é¥æµ‹æ•°æ®ç»“æ„å…¼å®¹æ€§æµ‹è¯•" {
  // æµ‹è¯•SpanKindæšä¸¾è·¨å¹³å°ä¸€è‡´æ€§
  let span_kinds = [Internal, Server, Client, Producer, Consumer]
  
  for kind in span_kinds {
    let kind_as_int = kind as Int
    assert_true(kind_as_int >= 0)
    assert_true(kind_as_int <= 4)
  }
  
  // æµ‹è¯•StatusCodeæšä¸¾è·¨å¹³å°ä¸€è‡´æ€§
  let status_codes = [Unset, Ok, Error]
  
  for code in status_codes {
    let code_as_int = code as Int
    assert_true(code_as_int >= 0)
    assert_true(code_as_int <= 2)
  }
  
  // æµ‹è¯•SeverityNumberæšä¸¾è·¨å¹³å°ä¸€è‡´æ€§
  let severity_numbers = [Trace, Debug, Info, Warn, Error, Fatal]
  
  for severity in severity_numbers {
    let severity_as_int = severity as Int
    assert_true(severity_as_int >= 0)
    assert_true(severity_as_int <= 5)
  }
  
  // æµ‹è¯•AttributeValueæšä¸¾è·¨å¹³å°ä¸€è‡´æ€§
  let attribute_values = [
    StringValue("test"),
    IntValue(42),
    FloatValue(3.14),
    BoolValue(true),
    ArrayStringValue(["a", "b", "c"]),
    ArrayIntValue([1, 2, 3])
  ]
  
  for attr_val in attribute_values {
    // éªŒè¯å±æ€§å€¼å¯ä»¥æ­£ç¡®åˆ›å»ºå’Œæ¯”è¾ƒ
    assert_true(attr_val == attr_val)
  }
  
  // æµ‹è¯•SpanContextè·¨å¹³å°ä¸€è‡´æ€§
  let span_contexts = [
    SpanContext::new("trace1", "span1", true, ""),
    SpanContext::new("trace2", "span2", false, "key=value"),
    SpanContext::new("", "", false, ""),  // æ— æ•ˆä¸Šä¸‹æ–‡
    SpanContext::new("a" * 32, "b" * 16, true, "complex=state,with=multiple")
  ]
  
  for ctx in span_contexts {
    let trace_id = SpanContext::trace_id(ctx)
    let span_id = SpanContext::span_id(ctx)
    let is_valid = SpanContext::is_valid(ctx)
    let is_sampled = SpanContext::is_sampled(ctx)
    
    assert_eq(trace_id.length(), trace_id.length())
    assert_eq(span_id.length(), span_id.length())
    assert_true(is_valid == (trace_id != "" && span_id != ""))
  }
}