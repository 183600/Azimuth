// é”™è¯¯è¾¹ç•Œæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• Azimuth é¥æµ‹ç³»ç»Ÿä¸­çš„é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶

test "span_context_invalid_values" {
  // æµ‹è¯•ç©ºçš„trace_id
  let empty_trace_ctx = SpanContext::new("", "1234567890abcdef", true, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  
  // æµ‹è¯•ç©ºçš„span_id
  let empty_span_ctx = SpanContext::new("1234567890abcdef1234567890abcdef", "", true, "")
  assert_false(SpanContext::is_valid(empty_span_ctx))
  
  // æµ‹è¯•ä¸¤è€…éƒ½ä¸ºç©º
  let both_empty_ctx = SpanContext::new("", "", true, "")
  assert_false(SpanContext::is_valid(both_empty_ctx))
  
  // æµ‹è¯•æ— æ•ˆé•¿åº¦çš„trace_id
  let short_trace_ctx = SpanContext::new("short", "1234567890abcdef", true, "")
  assert_false(SpanContext::is_valid(short_trace_ctx))
  
  // æµ‹è¯•æ— æ•ˆé•¿åº¦çš„span_id
  let short_span_ctx = SpanContext::new("1234567890abcdef1234567890abcdef", "short", true, "")
  assert_false(SpanContext::is_valid(short_span_ctx))
}

test "attributes_null_and_empty_values" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  Attributes::set(attrs, "empty.string", StringValue(""))
  let empty_result = Attributes::get(attrs, "empty.string")
  
  match empty_result {
    Some(StringValue(value)) => assert_eq(value, "")
    _ => assert_true(false, "Expected empty string value")
  }
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„é”®
  let non_existent = Attributes::get(attrs, "non.existent.key")
  assert_eq(non_existent, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®
  Attributes::set(attrs, "special.key!@#$%", StringValue("special_value"))
  let special_result = Attributes::get(attrs, "special.key!@#$%")
  
  match special_result {
    Some(StringValue(value)) => assert_eq(value, "special_value")
    _ => assert_true(false, "Expected special character key value")
  }
}

test "context_operations_edge_cases" {
  let ctx = Context::root()
  
  // æµ‹è¯•ç©ºé”®
  let empty_key = ContextKey::new("")
  let ctx_with_empty_key = Context::with_value(ctx, empty_key, "empty_key_value")
  let empty_key_result = Context::get(ctx_with_empty_key, empty_key)
  assert_eq(empty_key_result, Some("empty_key_value"))
  
  // æµ‹è¯•ç©ºå€¼
  let normal_key = ContextKey::new("normal.key")
  let ctx_with_empty_value = Context::with_value(ctx, normal_key, "")
  let empty_value_result = Context::get(ctx_with_empty_value, normal_key)
  assert_eq(empty_value_result, Some(""))
  
  // æµ‹è¯•é•¿é”®å’Œå€¼
  let long_key = ContextKey::new("this.is.a.very.long.key.that.might.be.used.in.some.scenarios")
  let long_value = "this.is.a.very.long.value.that.contains.a.lot.of.information"
  let ctx_with_long = Context::with_value(ctx, long_key, long_value)
  let long_result = Context::get(ctx_with_long, long_key)
  assert_eq(long_result, Some(long_value))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_key = ContextKey::new("key.with.special.chars!@#$%^&*()")
  let special_value = "value.with.special.chars!@#$%^&*()"
  let ctx_with_special = Context::with_value(ctx, special_key, special_value)
  let special_result = Context::get(ctx_with_special, special_key)
  assert_eq(special_result, Some(special_value))
}

test "log_record_boundary_conditions" {
  // æµ‹è¯•ç©ºæ¶ˆæ¯
  let empty_message = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_message), Some(""))
  
  // æµ‹è¯•éå¸¸é•¿çš„æ¶ˆæ¯
  let long_message = "This is a very long log message that contains a lot of detail. ".repeat(100)
  let long_record = LogRecord::new(Error, long_message)
  assert_eq(LogRecord::body(long_record), Some(long_message))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ¶ˆæ¯
  let special_chars = "Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?\\"
  let special_record = LogRecord::new(Warn, special_chars)
  assert_eq(LogRecord::body(special_record), Some(special_chars))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_message = "Unicode test: ä¸­æ–‡æµ‹è¯• ğŸš€ emoji test Ã±Ã¡Ã©Ã­Ã³Ãº"
  let unicode_record = LogRecord::new(Info, unicode_message)
  assert_eq(LogRecord::body(unicode_record), Some(unicode_message))
  
  // æµ‹è¯•æ¢è¡Œç¬¦å’Œå…¶ä»–æ§åˆ¶å­—ç¬¦
  let control_chars = "Line 1\nLine 2\tTabbed\rCarriage return"
  let control_record = LogRecord::new(Debug, control_chars)
  assert_eq(LogRecord::body(control_record), Some(control_chars))
}

test "meter_instrument_boundary_conditions" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "boundary.test")
  
  // æµ‹è¯•ç©ºåç§°
  let empty_name_counter = Meter::create_counter(meter, "")
  assert_eq(empty_name_counter.name, "")
  
  // æµ‹è¯•éå¸¸é•¿çš„åç§°
  let long_name = "this.is.a.very.long.instrument.name.that.exceeds.normal.expectations".repeat(10)
  let long_name_counter = Meter::create_counter(meter, long_name)
  assert_eq(long_name_counter.name, long_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°
  let special_name = "test.counter!@#$%^&*()"
  let special_counter = Meter::create_counter(meter, special_name)
  assert_eq(special_counter.name, special_name)
  
  // æµ‹è¯•æé™å€¼
  let counter = Meter::create_counter(meter, "boundary.counter")
  Counter::add(counter, 0.0)
  Counter::add(counter, -1.0)
  Counter::add(counter, 999999999.0)
  Counter::add(counter, -999999999.0)
  Counter::add(counter, 0.0000001)
  Counter::add(counter, -0.0000001)
  
  // æµ‹è¯•ç›´æ–¹å›¾æé™å€¼
  let histogram = Meter::create_histogram(meter, "boundary.histogram")
  Histogram::record(histogram, 0.0)
  Histogram::record(histogram, -1.0)
  Histogram::record(histogram, 999999999.0)
  Histogram::record(histogram, 0.0000001)
  
  assert_true(true)
}

test "text_map_carrier_boundary_conditions" {
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼
  TextMapCarrier::set(carrier, "", "")
  let empty_key_result = TextMapCarrier::get(carrier, "")
  assert_eq(empty_key_result, None)
  
  // æµ‹è¯•é•¿é”®å’Œå€¼
  let long_key = "this.is.a.very.long.header.name.that.might.be.used".repeat(10)
  let long_value = "this.is.a.very.long.header.value.that.contains.a.lot.of.data".repeat(10)
  TextMapCarrier::set(carrier, long_key, long_value)
  let long_key_result = TextMapCarrier::get(carrier, long_key)
  assert_eq(long_key_result, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = "X-Special-Header!@#$%^&*()"
  let special_value = "Special value with !@#$%^&*() characters"
  TextMapCarrier::set(carrier, special_key, special_value)
  let special_result = TextMapCarrier::get(carrier, special_key)
  assert_eq(special_result, None)
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = "X-Unicode-Header-ä¸­æ–‡"
  let unicode_value = "Unicode value with ä¸­æ–‡ and ğŸš€ emoji"
  TextMapCarrier::set(carrier, unicode_key, unicode_value)
  let unicode_result = TextMapCarrier::get(carrier, unicode_key)
  assert_eq(unicode_result, None)
}

test "baggage_operations_boundary_conditions" {
  let baggage = Baggage::new()
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼
  let baggage1 = Baggage::set_entry(baggage, "", "")
  let empty_key_result = Baggage::get_entry(baggage1, "")
  assert_eq(empty_key_result, None)
  
  // æµ‹è¯•é•¿é”®å’Œå€¼
  let long_key = "this.is.a.very.long.baggage.key.that.exceeds.expectations".repeat(10)
  let long_value = "this.is.a.very.long.baggage.value.with.lots.of.data".repeat(10)
  let baggage2 = Baggage::set_entry(baggage1, long_key, long_value)
  let long_key_result = Baggage::get_entry(baggage2, long_key)
  assert_eq(long_key_result, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key = "special.key!@#$%^&*()"
  let special_value = "special.value!@#$%^&*()"
  let baggage3 = Baggage::set_entry(baggage2, special_key, special_value)
  let special_result = Baggage::get_entry(baggage3, special_key)
  assert_eq(special_result, None)
  
  // æµ‹è¯•Unicodeé”®å’Œå€¼
  let unicode_key = "unicode.key.ä¸­æ–‡"
  let unicode_value = "unicode.value.ä¸­æ–‡.ğŸš€"
  let baggage4 = Baggage::set_entry(baggage3, unicode_key, unicode_value)
  let unicode_result = Baggage::get_entry(baggage4, unicode_key)
  assert_eq(unicode_result, None)
}

test "resource_operations_boundary_conditions" {
  let resource = Resource::new()
  
  // æµ‹è¯•ç©ºå±æ€§åå’Œå€¼
  let empty_attrs = [("", StringValue(""))]
  let resource_with_empty = Resource::with_attributes(resource, empty_attrs)
  let empty_result = Resource::get_attribute(resource_with_empty, "")
  assert_eq(empty_result, None)
  
  // æµ‹è¯•é•¿å±æ€§åå’Œå€¼
  let long_name = "this.is.a.very.long.attribute.name.that.exceeds.expectations".repeat(10)
  let long_value = "this.is.a.very.long.attribute.value.with.lots.of.data".repeat(10)
  let long_attrs = [(long_name, StringValue(long_value))]
  let resource_with_long = Resource::with_attributes(resource, long_attrs)
  let long_result = Resource::get_attribute(resource_with_long, long_name)
  assert_eq(long_result, None)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§åå’Œå€¼
  let special_name = "special.attribute!@#$%^&*()"
  let special_value = "special.attribute.value!@#$%^&*()"
  let special_attrs = [(special_name, StringValue(special_value))]
  let resource_with_special = Resource::with_attributes(resource, special_attrs)
  let special_result = Resource::get_attribute(resource_with_special, special_name)
  assert_eq(special_result, None)
  
  // æµ‹è¯•Unicodeå±æ€§åå’Œå€¼
  let unicode_name = "unicode.attribute.ä¸­æ–‡"
  let unicode_value = "unicode.attribute.value.ä¸­æ–‡.ğŸš€"
  let unicode_attrs = [(unicode_name, StringValue(unicode_value))]
  let resource_with_unicode = Resource::with_attributes(resource, unicode_attrs)
  let unicode_result = Resource::get_attribute(resource_with_unicode, unicode_name)
  assert_eq(unicode_result, None)
}

test "propagation_boundary_conditions" {
  let ctx = Context::root()
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºè½½ä½“ä¸Šçš„ä¼ æ’­
  let empty_carrier = TextMapCarrier::new()
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CTraceContextPropagator::new()
  
  let propagators = [trace_propagator, baggage_propagator]
  let composite = CompositePropagator::new(propagators)
  
  let extracted_from_empty = CompositePropagator::extract(composite, empty_carrier)
  let empty_result = Context::get(extracted_from_empty, ContextKey::new("extracted"))
  assert_eq(empty_result, Some("true"))
  
  // æµ‹è¯•æ— æ•ˆæ ¼å¼çš„å¤´éƒ¨
  TextMapCarrier::set(carrier, "traceparent", "invalid-format")
  TextMapCarrier::set(carrier, "baggage", "invalid-baggage-format")
  
  let extracted_from_invalid = CompositePropagator::extract(composite, carrier)
  let invalid_result = Context::get(extracted_from_invalid, ContextKey::new("extracted"))
  assert_eq(invalid_result, Some("true"))
  
  // æµ‹è¯•ç©ºå¤´éƒ¨å€¼
  let empty_value_carrier = TextMapCarrier::new()
  TextMapCarrier::set(empty_value_carrier, "traceparent", "")
  TextMapCarrier::set(empty_value_carrier, "baggage", "")
  
  let extracted_from_empty_values = CompositePropagator::extract(composite, empty_value_carrier)
  let empty_values_result = Context::get(extracted_from_empty_values, ContextKey::new("extracted"))
  assert_eq(empty_values_result, Some("true"))
}

test "span_operations_boundary_conditions" {
  let provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(provider, "boundary.test")
  
  // æµ‹è¯•ç©ºåç§°çš„span
  let empty_span = Tracer::start_span(tracer, "")
  assert_eq(Span::name(empty_span), "")
  
  // æµ‹è¯•é•¿åç§°çš„span
  let long_name = "this.is.a.very.long.span.name.that.exceeds.expectations".repeat(10)
  let long_span = Tracer::start_span(tracer, long_name)
  assert_eq(Span::name(long_span), long_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°çš„span
  let special_name = "span.name!@#$%^&*()"
  let special_span = Tracer::start_span(tracer, special_name)
  assert_eq(Span::name(special_span), special_name)
  
  // æµ‹è¯•Unicodeåç§°çš„span
  let unicode_name = "span.name.ä¸­æ–‡.ğŸš€"
  let unicode_span = Tracer::start_span(tracer, unicode_name)
  assert_eq(Span::name(unicode_span), unicode_name)
  
  // æµ‹è¯•spançŠ¶æ€æ“ä½œ
  Span::set_status(empty_span, Error)
  Span::set_status(long_span, Ok)
  Span::set_status(special_span, Unset)
  
  Span::add_event(empty_span, "empty span event")
  Span::add_event(long_span, "long span event")
  Span::add_event(special_span, "special span event")
  Span::add_event(unicode_span, "unicode span event")
  
  Span::end(empty_span)
  Span::end(long_span)
  Span::end(special_span)
  Span::end(unicode_span)
  
  assert_true(true)
}