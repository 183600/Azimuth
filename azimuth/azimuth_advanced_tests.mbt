// Azimuth é¡¹ç›®é«˜çº§æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ï¼ŒåŒ…å«é«˜çº§æ•°å­¦è¿ç®—å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•

test "mathematical_associative_law" {
  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  let a = 12
  let b = 15
  let c = 23
  
  let left_side = azimuth::add(azimuth::add(a, b), c)  // (12 + 15) + 23 = 50
  let right_side = azimuth::add(a, azimuth::add(b, c))  // 12 + (15 + 23) = 50
  
  assert_eq(left_side, right_side)
  
  // æµ‹è¯•ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  let x = 3
  let y = 4
  let z = 5
  
  let mult_left = azimuth::multiply(azimuth::multiply(x, y), z)  // (3 * 4) * 5 = 60
  let mult_right = azimuth::multiply(x, azimuth::multiply(y, z))  // 3 * (4 * 5) = 60
  
  assert_eq(mult_left, mult_right)
}

test "string_unicode_handling" {
  // æµ‹è¯• Unicode å­—ç¬¦ä¸²å¤„ç†
  let unicode_inputs = ["æµ‹è¯•", "ğŸš€", "CafÃ©", "ĞœĞ¾ÑĞºĞ²Ğ°", "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"]
  
  for input in unicode_inputs {
    let result = azimuth::greet(input)
    let expected = "Hello, " + input + "!"
    assert_eq(result, expected)
  }
}

test "large_number_arithmetic" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num1 = 1000000
  let large_num2 = 2000000
  
  // å¤§æ•°åŠ æ³•
  let sum_result = azimuth::add(large_num1, large_num2)
  assert_eq(sum_result, 3000000)
  
  // å¤§æ•°ä¹˜æ³•ï¼ˆä½¿ç”¨è¾ƒå°çš„æ•°é¿å…æº¢å‡ºï¼‰
  let mult_result = azimuth::multiply(10000, 5000)
  assert_eq(mult_result, 50000000)
  
  // å¤§æ•°ä¸é›¶çš„è¿ç®—
  assert_eq(azimuth::add(large_num1, 0), large_num1)
  assert_eq(azimuth::multiply(large_num1, 0), 0)
}

test "prime_number_calculation" {
  // æµ‹è¯•ç´ æ•°ç›¸å…³è®¡ç®—
  // ä½¿ç”¨åŠ æ³•éªŒè¯ç´ æ•°æ€§è´¨
  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
  
  // éªŒè¯ç´ æ•°åºåˆ—çš„è¿ç»­å·®å€¼
  for i in 1..length(primes) {
    let diff = azimuth::add(primes[i], -primes[i-1])
    // ç´ æ•°å·®å€¼åº”è¯¥å¤§äº0ï¼ˆé™¤äº†2å’Œ3ä¹‹é—´å·®1ï¼‰
    assert_eq(diff > 0, true)
  }
  
  // éªŒè¯ç‰¹å®šç´ æ•°æ€§è´¨
  assert_eq(azimuth::add(primes[0], primes[1]), 5)  // 2 + 3 = 5 (ä¹Ÿæ˜¯ç´ æ•°)
  assert_eq(azimuth::multiply(primes[1], primes[2]), 15)  // 3 * 5 = 15
}

test "recursive_calculation_simulation" {
  // æµ‹è¯•é€’å½’è®¡ç®—æ¨¡æ‹Ÿï¼ˆä½¿ç”¨è¿­ä»£æ–¹å¼ï¼‰
  // è®¡ç®—é˜¶ä¹˜: 5! = 5 * 4 * 3 * 2 * 1 = 120
  let n = 5
  let factorial = 1
  
  // æ¨¡æ‹Ÿé€’å½’è®¡ç®—
  factorial = azimuth::multiply(factorial, 5)  // 1 * 5 = 5
  factorial = azimuth::multiply(factorial, 4)  // 5 * 4 = 20
  factorial = azimuth::multiply(factorial, 3)  // 20 * 3 = 60
  factorial = azimuth::multiply(factorial, 2)  // 60 * 2 = 120
  factorial = azimuth::multiply(factorial, 1)  // 120 * 1 = 120
  
  assert_eq(factorial, 120)
}

test "string_length_boundary_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œæƒ…å†µ
  let empty_string = ""
  let single_char = "a"
  let long_string = "this_is_a_very_long_string_for_testing_purposes"
  
  let result1 = azimuth::greet(empty_string)
  assert_eq(result1, "Hello, !")
  
  let result2 = azimuth::greet(single_char)
  assert_eq(result2, "Hello, a!")
  
  let result3 = azimuth::greet(long_string)
  assert_eq(result3, "Hello, this_is_a_very_long_string_for_testing_purposes!")
}

test "power_operation_simulation" {
  // æµ‹è¯•å¹‚è¿ç®—æ¨¡æ‹Ÿï¼ˆä½¿ç”¨é‡å¤ä¹˜æ³•ï¼‰
  // è®¡ç®— 2^4 = 2 * 2 * 2 * 2 = 16
  let base = 2
  let exponent = 4
  let result = 1
  
  result = azimuth::multiply(result, base)  // 1 * 2 = 2
  result = azimuth::multiply(result, base)  // 2 * 2 = 4
  result = azimuth::multiply(result, base)  // 4 * 2 = 8
  result = azimuth::multiply(result, base)  // 8 * 2 = 16
  
  assert_eq(result, 16)
  
  // è®¡ç®— 3^3 = 3 * 3 * 3 = 27
  let base2 = 3
  let result2 = 1
  
  result2 = azimuth::multiply(result2, base2)  // 1 * 3 = 3
  result2 = azimuth::multiply(result2, base2)  // 3 * 3 = 9
  result2 = azimuth::multiply(result2, base2)  // 9 * 3 = 27
  
  assert_eq(result2, 27)
}

test "negative_number_boundary_tests" {
  // æµ‹è¯•è´Ÿæ•°è¾¹ç•Œæƒ…å†µ
  let max_negative = -2147483648  // 32ä½æœ‰ç¬¦å·æ•´æ•°æœ€å°å€¼
  let min_negative = -1
  
  // è´Ÿæ•°åŠ æ³•æµ‹è¯•
  let result1 = azimuth::add(max_negative, 1)
  let result2 = azimuth::add(min_negative, -1)
  
  // è´Ÿæ•°ä¹˜æ³•æµ‹è¯•
  let result3 = azimuth::multiply(max_negative, 1)
  let result4 = azimuth::multiply(min_negative, -1)
  
  // éªŒè¯è´Ÿæ•°è¿ç®—æ€§è´¨
  assert_eq(azimuth::add(-10, 20), 10)  // è´Ÿæ•°åŠ æ­£æ•°
  assert_eq(azimuth::multiply(-5, -5), 25)  // è´Ÿæ•°ä¹˜è´Ÿæ•°å¾—æ­£æ•°
  assert_eq(azimuth::multiply(-5, 3), -15)  // è´Ÿæ•°ä¹˜æ­£æ•°å¾—è´Ÿæ•°
}

test "string_special_character_processing" {
  // æµ‹è¯•å­—ç¬¦ä¸²ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let special_chars = [
    "line\nbreak",
    "tab\tcharacter", 
    "quote\"test",
    "apostrophe'test",
    "back\\slash",
    "emojiğŸ˜€test",
    "space test",
    "bracket(test)",
    "curly{test}",
    "square[test]"
  ]
  
  for char_string in special_chars {
    let result = azimuth::greet(char_string)
    let expected = "Hello, " + char_string + "!"
    assert_eq(result, expected)
  }
}

test "complex_mathematical_expressions" {
  // æµ‹è¯•å¤æ‚æ•°å­¦è¡¨è¾¾å¼
  // è¡¨è¾¾å¼1: (a + b) * (c - d) + e
  let a = 8
  let b = 12
  let c = 20
  let d = 5
  let e = 15
  
  let step1 = azimuth::add(a, b)           // 8 + 12 = 20
  let step2 = azimuth::add(c, -d)          // 20 - 5 = 15
  let step3 = azimuth::multiply(step1, step2)  // 20 * 15 = 300
  let result1 = azimuth::add(step3, e)     // 300 + 15 = 315
  
  assert_eq(result1, 315)
  
  // è¡¨è¾¾å¼2: a * b + c * d - e * f
  let f = 2
  
  let expr1 = azimuth::multiply(a, b)      // 8 * 12 = 96
  let expr2 = azimuth::multiply(c, d)      // 20 * 5 = 100
  let expr3 = azimuth::multiply(e, f)      // 15 * 2 = 30
  let result2 = azimuth::add(azimuth::add(expr1, expr2), -expr3)  // 96 + 100 - 30 = 166
  
  assert_eq(result2, 166)
}