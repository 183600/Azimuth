// é¢å¤–çš„é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æä¾›é¢å¤–çš„æµ‹è¯•è¦†ç›–ï¼Œä¸“æ³¨äºè¾¹ç•Œæ¡ä»¶å’Œå®é™…åº”ç”¨åœºæ™¯

// å¯¼å…¥è¢«æµ‹è¯•çš„æ¨¡å—
use azimuth

test "extreme_boundary_conditions" {
  // æµ‹è¯•æç«¯è¾¹ç•Œæ¡ä»¶
  // æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„åŠ æ³•æµ‹è¯•
  assert_eq(2147483646, azimuth.add(2147483645, 1))
  assert_eq(-2147483647, azimuth.add(-2147483646, -1))
  
  // å¤§æ•°ä¹˜æ³•æµ‹è¯•
  assert_eq(46340, azimuth.multiply(215, 215))  // 215^2 = 46225ï¼Œåœ¨å®‰å…¨èŒƒå›´å†…
  assert_eq(-46340, azimuth.multiply(215, -215))
}

test "financial_calculation_scenarios" {
  // é‡‘èè®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—è´·æ¬¾åˆ†æœŸ
  let loan_amount = 50000
  let monthly_payment = 2200
  let months_needed = azimuth.divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(23, months_needed)  // ceil(50000/2200) = 23
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = azimuth.multiply(months_needed, monthly_payment)
  assert_eq(50600, total_payment)
  
  // è®¡ç®—æœ€åä¸€æœŸçš„å®é™…æ”¯ä»˜é‡‘é¢
  let previous_payments = azimuth.multiply(months_needed - 1, monthly_payment)
  let final_payment = total_payment - previous_payments
  assert_eq(600, final_payment)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šäº‘æœåŠ¡å™¨èµ„æºåˆ†é…
  let total_cpu_cores = 127
  let instances = 8
  let cores_per_instance = azimuth.divide_with_ceil(total_cpu_cores, instances)
  assert_eq(16, cores_per_instance)  // ceil(127/8) = 16
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»æ ¸å¿ƒæ•°
  let total_allocated = azimuth.multiply(cores_per_instance, instances)
  assert_eq(128, total_allocated)
  
  // è®¡ç®—èµ„æºæµªè´¹
  let resource_waste = total_allocated - total_cpu_cores
  assert_eq(1, resource_waste)
}

test "complex_nested_calculations" {
  // å¤æ‚åµŒå¥—è®¡ç®—æµ‹è¯•
  // æ¨¡æ‹Ÿå¤šå±‚ä¸šåŠ¡é€»è¾‘è®¡ç®—
  let base_value = 100
  let growth_rate = 15
  let periods = 3
  
  // å¤åˆ©è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let period1 = azimuth.add(base_value, azimuth.divide_with_ceil(azimuth.multiply(base_value, growth_rate), 100))
  let period2 = azimuth.add(period1, azimuth.divide_with_ceil(azimuth.multiply(period1, growth_rate), 100))
  let period3 = azimuth.add(period2, azimuth.divide_with_ceil(azimuth.multiply(period2, growth_rate), 100))
  
  assert_eq(115, period1)  // 100 + 15%
  assert_eq(133, period2)  // 115 + 15% = 132.25 -> 133
  assert_eq(154, period3)  // 133 + 15% = 152.95 -> 153 -> 154 (å‘ä¸Šå–æ•´)
}

test "internationalization_comprehensive" {
  // å›½é™…åŒ–ç»¼åˆæµ‹è¯•
  // æµ‹è¯•å„ç§è¯­è¨€å’Œç‰¹æ®Šå­—ç¬¦çš„é—®å€™
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", azimuth.greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", azimuth.greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, à¤¹à¤¿à¤¨à¥à¤¦à¥€!", azimuth.greet("à¤¹à¤¿à¤¨à¥à¤¦à¥€"))
  assert_eq_string("Hello, í•œêµ­ì–´!", azimuth.greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, ÎµÎ»Î»Î·Î½Î¹ÎºÎ¬!", azimuth.greet("ÎµÎ»Î»Î·Î½Î¹ÎºÎ¬"))
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", azimuth.greet("ğŸŒğŸŒğŸŒ"))
}

test "error_boundary_and_resilience" {
  // é”™è¯¯è¾¹ç•Œå’Œæ¢å¤èƒ½åŠ›æµ‹è¯•
  // æµ‹è¯•å„ç§é™¤é›¶æƒ…å†µçš„å¤„ç†
  assert_eq(0, azimuth.divide_with_ceil(0, 0))
  assert_eq(0, azimuth.divide_with_ceil(100, 0))
  assert_eq(0, azimuth.divide_with_ceil(-100, 0))
  assert_eq(0, azimuth.divide_with_ceil(2147483647, 0))
  assert_eq(0, azimuth.divide_with_ceil(-2147483648, 0))
  
  // æµ‹è¯•æå°é™¤æ•°
  assert_eq(100000, azimuth.divide_with_ceil(99999, 1))
  assert_eq(-99999, azimuth.divide_with_ceil(-99999, 1))
  
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶çš„å¸ƒå°”éªŒè¯
  let zero_division_result = azimuth.divide_with_ceil(50, 0)
  assert_eq(0, zero_division_result)  // éªŒè¯é™¤é›¶è¿”å›0
  
  let positive_result = azimuth.divide_with_ceil(10, 3)
  assert_eq(0, positive_result - 4)  // éªŒè¯ç»“æœä¸º4 (ä½¿ç”¨å‡æ³•æ¥éªŒè¯ç›¸ç­‰)
}

test "batch_processing_efficiency" {
  // æ‰¹å¤„ç†æ•ˆç‡æµ‹è¯•
  // åœºæ™¯ï¼šæ‰¹é‡æ•°æ®å¤„ç†
  let total_records = 1047
  let batch_size = 50
  let batches_needed = azimuth.divide_with_ceil(total_records, batch_size)
  assert_eq(21, batches_needed)  // ceil(1047/50) = 21
  
  // è®¡ç®—å®Œæ•´æ‰¹æ¬¡å’Œæœ€åä¸€æ‰¹çš„å¤§å°
  let full_batches = batches_needed - 1
  let records_in_full_batches = azimuth.multiply(full_batches, batch_size)
  let final_batch_size = total_records - records_in_full_batches
  
  assert_eq(20, full_batches)
  assert_eq(1000, records_in_full_batches)
  assert_eq(47, final_batch_size)
}

test "mathematical_sequence_operations" {
  // æ•°å­¦åºåˆ—æ“ä½œæµ‹è¯•
  // æµ‹è¯•ç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—çš„ç®€å•è®¡ç®—
  let first_term = 3
  let common_difference = 4
  let terms_count = 5
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„ç¬¬né¡¹ï¼ša_n = a_1 + (n-1)d
  let nth_term = azimuth.add(first_term, azimuth.multiply(terms_count - 1, common_difference))
  assert_eq(19, nth_term)  // 3 + (5-1)*4 = 3 + 16 = 19
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œï¼šS_n = n/2 * (a_1 + a_n)
  let sum = azimuth.divide_with_ceil(azimuth.multiply(terms_count, azimuth.add(first_term, nth_term)), 2)
  assert_eq(55, sum)  // 5/2 * (3 + 19) = 2.5 * 22 = 55
}

test "real_world_inventory_management" {
  // çœŸå®ä¸–ç•Œåº“å­˜ç®¡ç†æµ‹è¯•
  // åœºæ™¯ï¼šå¤šäº§å“åº“å­˜ä¼˜åŒ–
  let product_a = 89
  let product_b = 156
  let product_c = 234
  let box_capacity = 50
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_a = azimuth.divide_with_ceil(product_a, box_capacity)
  let boxes_b = azimuth.divide_with_ceil(product_b, box_capacity)
  let boxes_c = azimuth.divide_with_ceil(product_c, box_capacity)
  
  assert_eq(2, boxes_a)   // ceil(89/50) = 2
  assert_eq(4, boxes_b)   // ceil(156/50) = 4
  assert_eq(5, boxes_c)   // ceil(234/50) = 5
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œæ€»å®¹é‡
  let total_boxes = azimuth.add(azimuth.add(boxes_a, boxes_b), boxes_c)
  let total_capacity = azimuth.multiply(total_boxes, box_capacity)
  let total_products = azimuth.add(azimuth.add(product_a, product_b), product_c)
  
  assert_eq(11, total_boxes)
  assert_eq(550, total_capacity)
  assert_eq(479, total_products)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let remaining_space = total_capacity - total_products
  assert_eq(71, remaining_space)
}

test "performance_benchmark_operations" {
  // æ€§èƒ½åŸºå‡†æ“ä½œæµ‹è¯•
  // æµ‹è¯•å¤§é‡è¿ç®—çš„ç»„åˆæ€§èƒ½
  let base_number = 1000
  let iterations = 100
  
  // è¿ç»­åŠ æ³•æ“ä½œ
  let addition_result = azimuth.add(base_number, iterations)
  assert_eq(1100, addition_result)
  
  // è¿ç»­ä¹˜æ³•æ“ä½œ
  let multiplication_result = azimuth.multiply(base_number, iterations)
  assert_eq(100000, multiplication_result)
  
  // æ··åˆè¿ç®—ï¼š((base + iterations) * 10) / (base / 100)
  let mixed_step1 = azimuth.add(base_number, iterations)
  let mixed_step2 = azimuth.multiply(mixed_step1, 10)
  let mixed_step3 = azimuth.divide_with_ceil(base_number, 100)
  let final_result = azimuth.divide_with_ceil(mixed_step2, mixed_step3)
  
  assert_eq(1100, mixed_step1)      // 1000 + 100
  assert_eq(11000, mixed_step2)     // 1100 * 10
  assert_eq(10, mixed_step3)        // ceil(1000/100)
  assert_eq(1100, final_result)     // ceil(11000/10)
}