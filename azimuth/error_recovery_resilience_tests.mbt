// å¼‚å¸¸å¤„ç†å’Œæ¢å¤æœºåˆ¶æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„æ¢å¤èƒ½åŠ›å’Œå®¹é”™æœºåˆ¶

test "Spanæ“ä½œå¼‚å¸¸å¤„ç†å’ŒçŠ¶æ€æ¢å¤æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "exception.tracer")
  
  // æµ‹è¯•æ— æ•ˆSpanåç§°å¤„ç†
  let empty_name_span = Tracer::start_span(tracer, "")
  assert_true(Span::name(empty_name_span) == "")
  assert_true(Span::is_recording(empty_name_span))
  Span::end(empty_name_span)
  
  // æµ‹è¯•æé•¿Spanåç§°å¤„ç†
  let very_long_name = "very-long-span-name-" + "x" * 1000
  let long_name_span = Tracer::start_span(tracer, very_long_name)
  assert_true(Span::name(long_name_span) == very_long_name)
  Span::end(long_name_span)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Spanåç§°å¤„ç†
  let special_chars_span = Tracer::start_span(tracer, "span.with.special.chars!@#$%^&*()")
  assert_true(Span::name(special_chars_span).contains("!@#$%^&*()"))
  Span::end(special_chars_span)
  
  // æµ‹è¯•Unicode Spanåç§°å¤„ç†
  let unicode_span = Tracer::start_span(tracer, "æµ‹è¯•Spanåç§°ğŸš€Ğ¢ĞµÑÑ‚Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  assert_true(Span::name(unicode_span).contains("æµ‹è¯•"))
  assert_true(Span::name(unicode_span).contains("ğŸš€"))
  Span::end(unicode_span)
  
  // æµ‹è¯•SpançŠ¶æ€è®¾ç½®æ¢å¤
  let recovery_span = Tracer::start_span(tracer, "recovery.test.span")
  
  // è®¾ç½®é”™è¯¯çŠ¶æ€
  Span::set_status(recovery_span, Error, Some("Simulated error for testing"))
  Span::add_event(recovery_span, "error.event", Some([
    ("error.code", StringValue("E001")),
    ("error.message", StringValue("Test error message"))
  ]))
  
  // éªŒè¯é”™è¯¯çŠ¶æ€è®¾ç½®å®Œæˆ
  assert_true(Span::is_recording(recovery_span))
  
  // æ¢å¤åˆ°æ­£å¸¸çŠ¶æ€
  Span::set_status(recovery_span, Ok, Some("System recovered successfully"))
  Span::add_event(recovery_span, "recovery.event", Some([
    ("recovery.action", StringValue("automatic_recovery")),
    ("recovery.timestamp", IntValue(1735689600))
  ]))
  
  // ç»“æŸSpan
  Span::end(recovery_span)
  assert_false(Span::is_recording(recovery_span))
}

test "æŒ‡æ ‡æ“ä½œå¼‚å¸¸å¤„ç†å’Œæ•°æ®å®Œæ•´æ€§æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "exception.meter")
  
  // æµ‹è¯•æ— æ•ˆæŒ‡æ ‡åç§°å¤„ç†
  let empty_counter = Meter::create_counter(meter, "")
  assert_eq(empty_counter.name, "")
  Counter::add(empty_counter, 1.0)
  
  let special_char_histogram = Meter::create_histogram(meter, "histogram.with.special.chars!@#")
  assert_eq(special_char_histogram.name, "histogram.with.special.chars!@#")
  Histogram::record(special_char_histogram, 42.5)
  
  // æµ‹è¯•æé™å€¼å¤„ç†
  let counter = Meter::create_counter(meter, "boundary.test.counter")
  let histogram = Meter::create_histogram(meter, "boundary.test.histogram")
  let updown_counter = Meter::create_updown_counter(meter, "boundary.test.updown")
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(counter, 1.7976931348623157e+308)  // Double max
  Histogram::record(histogram, 1.7976931348623157e+308)
  UpDownCounter::add(updown_counter, 1.7976931348623157e+308)
  
  // æµ‹è¯•æå°å€¼
  Counter::add(counter, -1.7976931348623157e+308)  // Double min
  Histogram::record(histogram, -1.7976931348623157e+308)
  UpDownCounter::add(updown_counter, -1.7976931348623157e+308)
  
  // æµ‹è¯•ç‰¹æ®Šæ•°å€¼
  Counter::add(counter, 0.0)
  Histogram::record(histogram, 0.0)
  UpDownCounter::add(updown_counter, 0.0)
  
  // æµ‹è¯•æ— ç©·å¤§å’ŒNaNï¼ˆå¦‚æœæ”¯æŒï¼‰
  Counter::add(counter, 1.0 / 0.0)  // Infinity
  Histogram::record(histogram, -1.0 / 0.0)  // -Infinity
  UpDownCounter::add(updown_counter, 0.0 / 0.0)  // NaN
  
  // éªŒè¯ä»ªå™¨ä»ç„¶å¯ç”¨
  assert_eq(counter.name, "boundary.test.counter")
  assert_eq(histogram.name, "boundary.test.histogram")
  assert_eq(updown_counter.name, "boundary.test.updown")
}

test "ä¸Šä¸‹æ–‡ä¼ æ’­å¼‚å¸¸æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•æ— æ•ˆä¸Šä¸‹æ–‡å¤„ç†
  let invalid_trace_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(invalid_trace_ctx))
  assert_false(SpanContext::is_sampled(invalid_trace_ctx))
  
  // æµ‹è¯•éƒ¨åˆ†æ— æ•ˆä¸Šä¸‹æ–‡
  let partial_invalid_ctx1 = SpanContext::new("valid-trace-id", "", true, "")
  assert_false(SpanContext::is_valid(partial_invalid_ctx1))
  
  let partial_invalid_ctx2 = SpanContext::new("", "valid-span-id", true, "")
  assert_false(SpanContext::is_valid(partial_invalid_ctx2))
  
  // æµ‹è¯•æé•¿ä¸Šä¸‹æ–‡å¤„ç†
  let very_long_trace_id = "a" * 1000
  let very_long_span_id = "b" * 500
  let very_long_trace_state = "key=value," + "x" * 2000
  let long_ctx = SpanContext::new(very_long_trace_id, very_long_span_id, true, very_long_trace_state)
  
  assert_true(SpanContext::is_valid(long_ctx))
  assert_eq(SpanContext::trace_id(long_ctx), very_long_trace_id)
  assert_eq(SpanContext::span_id(long_ctx), very_long_span_id)
  
  // æµ‹è¯•ä¼ æ’­å™¨å¼‚å¸¸å¤„ç†
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡ä¼ æ’­
  let empty_ctx = Context::root()
  CompositePropagator::inject(propagator, empty_ctx, carrier)
  let extracted_empty = CompositePropagator::extract(propagator, carrier)
  assert_true(extracted_empty.data is Some)
  
  // æµ‹è¯•ç©ºè½½ä½“å¤„ç†
  let empty_carrier = TextMapCarrier::new()
  let ctx_from_empty = CompositePropagator::extract(propagator, empty_carrier)
  assert_true(ctx_from_empty.data is Some)
  
  // æµ‹è¯•æŸåçš„è½½ä½“æ•°æ®
  let corrupted_carrier = TextMapCarrier::new()
  TextMapCarrier::set(corrupted_carrier, "traceparent", "invalid-trace-data")
  TextMapCarrier::set(corrupted_carrier, "corrupted-header", "corrupted-value")
  
  let ctx_from_corrupted = CompositePropagator::extract(propagator, corrupted_carrier)
  assert_true(ctx_from_corrupted.data is Some)
  
  // æµ‹è¯•Baggageå¼‚å¸¸å¤„ç†
  let baggage = Baggage::new()
  
  // æµ‹è¯•ç©ºé”®å€¼å¤„ç†
  let empty_key_baggage = Baggage::set_entry(baggage, "", "empty-key-value")
  let empty_value_baggage = Baggage::set_entry(empty_key_baggage, "empty-value-key", "")
  
  let empty_key_result = Baggage::get_entry(empty_value_baggage, "")
  let empty_value_result = Baggage::get_entry(empty_value_baggage, "empty-value-key")
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦Baggage
  let special_chars_baggage = Baggage::set_entry(empty_value_baggage, "special.key!@#$%", "special.value!@#$%")
  let special_result = Baggage::get_entry(special_chars_baggage, "special.key!@#$%")
  assert_true(special_result is Some)
}

test "æ—¥å¿—è®°å½•å¼‚å¸¸å¤„ç†å’Œæ¢å¤æµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "exception.logger")
  
  // æµ‹è¯•ç©ºæ—¥å¿—æ¶ˆæ¯å¤„ç†
  let empty_message_record = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_message_record), Some(""))
  Logger::emit(logger, empty_message_record)
  
  // æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯å¤„ç†
  let very_long_message = "Very long log message " + "x" * 5000
  let long_message_record = LogRecord::new(Error, very_long_message)
  assert_eq(LogRecord::body(long_message_record), Some(very_long_message))
  Logger::emit(logger, long_message_record)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ—¥å¿—æ¶ˆæ¯
  let special_chars_message = "Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_chars_record = LogRecord::new(Warn, special_chars_message)
  assert_eq(LogRecord::body(special_chars_record), Some(special_chars_message))
  Logger::emit(logger, special_chars_record)
  
  // æµ‹è¯•Unicodeæ—¥å¿—æ¶ˆæ¯
  let unicode_message = "Unicode test: æµ‹è¯•ğŸš€Ğ¢ĞµÑÑ‚Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© emoji ğŸ’©ğŸ”¥"
  let unicode_record = LogRecord::new(Error, unicode_message)
  assert_eq(LogRecord::body(unicode_record), Some(unicode_message))
  Logger::emit(logger, unicode_record)
  
  // æµ‹è¯•æ— æ•ˆä¸Šä¸‹æ–‡æ—¥å¿—è®°å½•
  let invalid_context_record = LogRecord::new_with_context(
    Fatal,
    Some("Log with invalid context"),
    None,
    Some(-1L),  // æ— æ•ˆæ—¶é—´æˆ³
    Some(-1L),  // æ— æ•ˆè§‚å¯Ÿæ—¶é—´æˆ³
    Some(""),   // æ— æ•ˆtrace ID
    Some(""),   // æ— æ•ˆspan ID
    Some(Context::root())
  )
  
  assert_eq(LogRecord::severity_number(invalid_context_record), Fatal)
  assert_eq(LogRecord::trace_id(invalid_context_record), Some(""))
  assert_eq(LogRecord::span_id(invalid_context_record), Some(""))
  Logger::emit(logger, invalid_context_record)
  
  // æµ‹è¯•æé™æ—¶é—´æˆ³å¤„ç†
  let max_timestamp_record = LogRecord::new_with_context(
    Info,
    Some("Max timestamp test"),
    None,
    Some(9223372036854775807L),  // Int64 max
    None,
    None,
    None,
    None
  )
  
  let min_timestamp_record = LogRecord::new_with_context(
    Info,
    Some("Min timestamp test"),
    None,
    Some(-9223372036854775808L),  // Int64 min
    None,
    None,
    None,
    None
  )
  
  Logger::emit(logger, max_timestamp_record)
  Logger::emit(logger, min_timestamp_record)
  
  // æµ‹è¯•æ¢å¤æœºåˆ¶
  let recovery_record = LogRecord::new_with_context(
    Info,
    Some("System recovered from exception"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    Some(Clock::now_unix_nanos(Clock::system()) + 1000L),
    Some("recovery-trace-id"),
    Some("recovery-span-id"),
    Some(Context::with_value(Context::root(), ContextKey::new("recovery.status"), "success"))
  )
  
  Logger::emit(logger, recovery_record)
  assert_eq(LogRecord::body(recovery_record), Some("System recovered from exception"))
}

test "èµ„æºç®¡ç†å¼‚å¸¸å¤„ç†å’Œæ¢å¤æµ‹è¯•" {
  // æµ‹è¯•ç©ºèµ„æºå¤„ç†
  let empty_resource = Resource::new()
  assert_eq(empty_resource.attributes.length(), 0)
  
  let empty_attr = Resource::get_attribute(empty_resource, "non.existent.key")
  assert_eq(empty_attr, None)
  
  // æµ‹è¯•æ— æ•ˆå±æ€§å¤„ç†
  let invalid_attrs = [
    ("", StringValue("empty-key-value")),
    ("invalid.key", StringValue("")),
    ("special.chars.key!@#$%", StringValue("special.value!@#$%")),
    ("unicode.key.æµ‹è¯•", StringValue("unicode.value.æµ‹è¯•ğŸš€"))
  ]
  
  let invalid_resource = Resource::with_attributes(Resource::new(), invalid_attrs)
  
  // éªŒè¯æ— æ•ˆå±æ€§è®¾ç½®
  let empty_key_attr = Resource::get_attribute(invalid_resource, "")
  assert_true(empty_key_attr is Some)
  
  let empty_value_attr = Resource::get_attribute(invalid_resource, "invalid.key")
  assert_true(empty_value_attr is Some)
  
  let special_chars_attr = Resource::get_attribute(invalid_resource, "special.chars.key!@#$%")
  assert_true(special_chars_attr is Some)
  
  // æµ‹è¯•èµ„æºåˆå¹¶å¼‚å¸¸å¤„ç†
  let base_resource = Resource::with_attributes(Resource::new(), [
    ("base.attr", StringValue("base-value"))
  ])
  
  let empty_override_resource = Resource::new()
  let merged_with_empty = Resource::merge(base_resource, empty_override_resource)
  
  let invalid_override_resource = Resource::with_attributes(Resource::new(), [
    ("", StringValue("invalid-merge-key"))
  ])
  let merged_with_invalid = Resource::merge(base_resource, invalid_override_resource)
  
  // éªŒè¯åˆå¹¶ç»“æœ
  let base_attr_after_merge = Resource::get_attribute(merged_with_empty, "base.attr")
  assert_true(base_attr_after_merge is Some)
  
  let invalid_attr_after_merge = Resource::get_attribute(merged_with_invalid, "")
  assert_true(invalid_attr_after_merge is Some)
  
  // æµ‹è¯•å¤æ‚å±æ€§ç±»å‹å¼‚å¸¸å¤„ç†
  let complex_attrs = [
    ("empty.string.array", ArrayStringValue([])),
    ("empty.int.array", ArrayIntValue([])),
    ("single.string.array", ArrayStringValue(["single-item"])),
    ("single.int.array", ArrayIntValue([42]))
  ]
  
  let complex_resource = Resource::with_attributes(Resource::new(), complex_attrs)
  
  // éªŒè¯å¤æ‚å±æ€§
  let empty_string_array = Resource::get_attribute(complex_resource, "empty.string.array")
  assert_true(empty_string_array is Some)
  
  let single_int_array = Resource::get_attribute(complex_resource, "single.int.array")
  assert_true(single_int_array is Some)
}

test "HTTPå®¢æˆ·ç«¯å¼‚å¸¸å¤„ç†å’Œç½‘ç»œæ¢å¤æµ‹è¯•" {
  let http_client = HttpClient::new()
  
  // æµ‹è¯•æ— æ•ˆURLå¤„ç†
  let invalid_urls = [
    "",
    "not-a-url",
    "ftp://invalid-protocol.com",
    "http://",
    "https://",
    "http://[invalid-ipv6"
  ]
  
  for invalid_url in invalid_urls {
    let request = HttpRequest::new("GET", invalid_url, [])
    assert_eq(HttpRequest::url(request), invalid_url)
    assert_eq(HttpRequest::http_method(request), "GET")
  }
  
  // æµ‹è¯•æ— æ•ˆHTTPæ–¹æ³•
  let invalid_methods = ["", "INVALID", "CONNECT", "TRACE", "PATCH"]
  
  for invalid_method in invalid_methods {
    let request = HttpRequest::new(invalid_method, "https://example.com", [])
    assert_eq(HttpRequest::http_method(request), invalid_method)
  }
  
  // æµ‹è¯•æé•¿URLå’Œå¤´éƒ¨å¤„ç†
  let very_long_url = "https://example.com/" + "path" * 100
  let very_long_headers = [
    ("Very-Long-Header-Name-" + "x" * 50, "Very-Long-Header-Value-" + "y" * 50),
    ("Special-Chars-Header!@#$%", "Special-Value!@#$%^&*()"),
    ("Unicode-Header-æµ‹è¯•", "Unicode-Value-æµ‹è¯•ğŸš€")
  ]
  
  let long_request = HttpRequest::new("POST", very_long_url, very_long_headers)
  assert_eq(HttpRequest::url(long_request), very_long_url)
  assert_eq(HttpRequest::http_method(long_request), "POST")
  
  // æµ‹è¯•æé•¿å“åº”ä½“å¤„ç†
  let very_long_body = "Very long response body " + "z" * 10000
  let long_response = HttpResponse::new(200, [], Some(very_long_body))
  assert_eq(HttpResponse::status_code(long_response), 200)
  assert_eq(HttpResponse::body(long_response), Some(very_long_body))
  
  // æµ‹è¯•æ— æ•ˆçŠ¶æ€ç å¤„ç†
  let invalid_status_codes = [-1, 0, 1000, 9999]
  
  for invalid_code in invalid_status_codes {
    let response = HttpResponse::new(invalid_code, [])
    assert_eq(HttpResponse::status_code(response), invalid_code)
  }
  
  // æµ‹è¯•ç½‘ç»œæ¢å¤åœºæ™¯
  let recovery_headers = [
    ("Retry-After", "30"),
    ("X-Retry-Count", "3"),
    ("X-Error-Recovery", "automatic")
  ]
  
  let recovery_request = HttpRequest::new(
    "GET",
    "https://recovery.example.com/api",
    [("Authorization", "Bearer recovery-token")]
  )
  
  let recovery_response = HttpResponse::new(503, recovery_headers, Some("Service temporarily unavailable"))
  
  // æ¨¡æ‹Ÿé‡è¯•é€»è¾‘éªŒè¯
  assert_eq(HttpResponse::status_code(recovery_response), 503)
  assert_true(HttpResponse::body(recovery_response) is Some)
  
  // æµ‹è¯•æˆåŠŸæ¢å¤å“åº”
  let success_response = HttpResponse::new(200, [
    ("X-Recovery-Success", "true"),
    ("X-Attempts", "3")
  ], Some("{\"status\": \"success\", \"recovered\": true}"))
  
  assert_eq(HttpResponse::status_code(success_response), 200)
  assert_true(HttpResponse::body(success_response) is Some)
}