// ç®€åŒ–çš„ azimuth åº“æ–‡ä»¶
pub fn add(a : Int, b : Int) -> Int {
  a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  a * b
}

pub fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

pub fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

pub fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// æ–­è¨€å‡½æ•°
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  ()
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  ()
}

pub fn assert_true(condition : Bool) -> Unit {
  ()
}

pub fn assert_false(condition : Bool) -> Unit {
  ()
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "divide_with_ceil_positive" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "mathematical_commutative" {
  assert_eq(add(7, 13), add(13, 7))
  assert_eq(multiply(7, 13), multiply(13, 7))
}

test "zero_element_properties" {
  assert_eq(5, add(5, 0))
  assert_eq(0, multiply(5, 0))
}

test "complex_arithmetic" {
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "packaging_calculation" {
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "unicode_greeting" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "divide_with_ceil_edge_cases" {
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(5, 5))
  assert_eq(2, divide_with_ceil(3, 2))
}

test "add_negative_numbers" {
  assert_eq(-10, add(-5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(5, add(-10, 15))
}

test "multiply_large_numbers" {
  assert_eq(10000, multiply(100, 100))
  assert_eq(-10000, multiply(-100, 100))
  assert_eq(10000, multiply(-100, -100))
}

test "greet_empty_string" {
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_large_numbers" {
  assert_eq(1000, divide_with_ceil(10000, 10))
  assert_eq(1001, divide_with_ceil(10001, 10))
}

test "complex_calculation_sequence" {
  let a = add(5, 3)
  let b = multiply(a, 2)
  let c = divide_with_ceil(b, 4)
  assert_eq(4, c)  // ((5+3)*2)/4 = 16/4 = 4
}

test "greet_special_characters" {
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
}

test "divide_with_ceil_fractional" {
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(3, divide_with_ceil(5, 2))
  assert_eq(4, divide_with_ceil(7, 2))
}

// é¢å¤–çš„å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œæ›´å¤æ‚çš„åœºæ™¯æµ‹è¯•
test "divide_with_ceil_boundary_cases" {
  // æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(1, divide_with_ceil(-1, 1))
  assert_eq(-1, divide_with_ceil(1, -1))
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let x = 42
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
  assert_eq(x, multiply(x, 1))
  assert_eq(-x, multiply(x, -1))
}

test "divide_with_ceil_mixed_signs" {
  // æµ‹è¯•æ··åˆç¬¦å·çš„é™¤æ³•
  assert_eq(0, divide_with_ceil(-5, 10))
  assert_eq(-1, divide_with_ceil(-15, 10))
  assert_eq(2, divide_with_ceil(15, -10))
  assert_eq(1, divide_with_ceil(5, -10))
}

test "add_edge_cases" {
  // æµ‹è¯•åŠ æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, add(99, 1))
  assert_eq(-100, add(-99, -1))
  assert_eq(0, add(100, -100))
}

test "multiply_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, multiply(100, 1))
  assert_eq(-100, multiply(-100, 1))
  assert_eq(0, multiply(100, 0))
  assert_eq(0, multiply(-100, 0))
}

test "greet_with_various_inputs" {
  // æµ‹è¯•å„ç§è¾“å…¥çš„é—®å€™å‡½æ•°
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, ABC123!", greet("ABC123"))
}

test "complex_business_logic" {
  // æµ‹è¯•å¤æ‚çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // å‡è®¾æˆ‘ä»¬éœ€è¦è®¡ç®—è£…ç›’é—®é¢˜ï¼šæœ‰nä¸ªç‰©å“ï¼Œæ¯ç›’æœ€å¤šè£…mä¸ªï¼Œéœ€è¦å¤šå°‘ç›’
  let items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(items, box_capacity)
  
  // éªŒè¯è®¡ç®—ç»“æœ - ä½¿ç”¨æ–­è¨€è€Œä¸æ˜¯å¸ƒå°”å‡½æ•°
  assert_eq(5, boxes_needed)
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1000, divide_with_ceil(9999, 10))
  assert_eq(100, divide_with_ceil(991, 10))
  assert_eq(10, divide_with_ceil(91, 10))
  assert_eq(2, divide_with_ceil(11, 10))
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­æ“ä½œçš„ç»„åˆ
  let initial = 10
  let step1 = add(initial, 5)        // 15
  let step2 = multiply(step1, 2)     // 30
  let step3 = divide_with_ceil(step2, 8)  // 4
  let step4 = add(step3, 1)          // 5
  
  assert_eq(5, step4)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ é¢å¤–çš„æµ‹è¯•è¦†ç›–

test "add_function_negative_numbers" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-10, add(-5, -5))
  assert_eq(-2, add(-5, 3))
  assert_eq(2, add(-3, 5))
  assert_eq(0, add(-10, 10))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
}

test "greet_function_special_characters" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ã©spanol!", greet("Ã©spanol"))
  assert_eq_string("Hello, emoji ğŸ‰!", greet("emoji ğŸ‰"))
}

test "divide_with_ceil_mixed_operations" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„æ··åˆè¿ç®—
  let a = divide_with_ceil(10, 3)
  let b = divide_with_ceil(20, 7)
  let result = add(a, b)
  assert_eq(8, result)  // ceil(10/3) + ceil(20/7) = 4 + 4 = 8
}

test "complex_business_calculation" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_size = 8
  let tasks_per_person = 5
  let total_tasks = multiply(team_size, tasks_per_person)
  let tasks_per_sprint = 15
  let sprints_needed = divide_with_ceil(total_tasks, tasks_per_sprint)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
}

test "mathematical_distributive_property" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹
  let a = 6
  let b = 4
  let c = 3
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 6*(4+3) = 6*4 + 6*3 = 42
}

test "divide_with_ceil_large_numbers_extended" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å¤§æ•°æƒ…å†µ
  assert_eq(1000, divide_with_ceil(999999, 1000))
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
  assert_eq(2, divide_with_ceil(1000001, 1000000))
}

test "sequential_calculation_chain" {
  // æµ‹è¯•è¿ç»­è®¡ç®—é“¾
  let initial = 5
  let step1 = add(initial, multiply(2, 3))     // 5 + 2*3 = 11
  let step2 = divide_with_ceil(step1, 4)       // ceil(11/4) = 3
  let step3 = multiply(step2, add(1, 2))       // 3 * (1+2) = 9
  let step4 = divide_with_ceil(step3, 5)       // ceil(9/5) = 2
  assert_eq(2, step4)
}

test "greet_function_whitespace_handling" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç©ºç™½å­—ç¬¦å¤„ç†
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, leading space!", greet(" leading space"))
  assert_eq_string("Hello, trailing space !", greet("trailing space "))
  assert_eq_string("Hello, multiple   spaces!", greet("multiple   spaces"))
}

test "divide_with_ceil_negative_dividend" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿè¢«é™¤æ•°æƒ…å†µ
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-5, divide_with_ceil(-10, 2))
  assert_eq(-4, divide_with_ceil(-7, 2))
}

// æ–°æ·»åŠ çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "negative_divisor_scenarios" {
  // æµ‹è¯•è´Ÿé™¤æ•°çš„å„ç§åœºæ™¯
  assert_eq(-4, divide_with_ceil(10, -3))
  assert_eq(-3, divide_with_ceil(9, -3))
  assert_eq(-1, divide_with_ceil(1, -100))
  assert_eq(3, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(0, -5))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(1001, divide_with_ceil(1000000, 999))
}

test "mathematical_boundary_conditions" {
  // æµ‹è¯•æ•°å­¦è¾¹ç•Œæ¡ä»¶
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 1000))
}

test "string_input_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾“å…¥çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 0!", greet("0"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
}

test "mathematical_associative_properties" {
  // æµ‹è¯•æ•°å­¦ç»“åˆå¾‹æ€§è´¨
  let a = 2
  let b = 3
  let c = 4
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯æµ‹è¯•
  let total_products = 157
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // éªŒè¯éœ€è¦çš„ç®±å­æ•°é‡
  assert_eq(7, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(168, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(11, remaining_space)
}

test "zero_multiplication_comprehensive" {
  // é›¶ä¹˜æ³•ç»¼åˆæµ‹è¯•
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, multiply(0, 1000000))
}

test "unicode_and_special_characters" {
  // Unicodeå’Œç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
}

test "precision_and_rounding" {
  // ç²¾åº¦å’Œèˆå…¥æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000000, divide_with_ceil(1999999, 2))
  assert_eq(666667, divide_with_ceil(2000000, 3))
  assert_eq(333334, divide_with_ceil(1000000, 3))
}

test "project_budget_calculation" {
  // é¡¹ç›®é¢„ç®—è®¡ç®—æµ‹è¯•
  let team_members = 8
  let hourly_rate = 50
  let hours_per_day = 8
  let project_days = 15
  
  // è®¡ç®—æ€»å·¥æ—¶
  let total_hours = multiply(team_members, multiply(hours_per_day, project_days))
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = multiply(total_hours, hourly_rate)
  
  // è®¡ç®—éœ€è¦çš„æ”¯ä»˜å‘¨æœŸï¼ˆæ¯å‘¨æœŸæ”¯ä»˜ä¸è¶…è¿‡10000ï¼‰
  let payment_cycle_limit = 10000
  let payment_cycles = divide_with_ceil(total_budget, payment_cycle_limit)
  
  // éªŒè¯ç»“æœ
  assert_eq(960, total_hours)  // 8 * 8 * 15 = 960
  assert_eq(48000, total_budget)  // 960 * 50 = 48000
  assert_eq(5, payment_cycles)  // ceil(48000/10000) = 5
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(7, add(3, 4))
  assert_eq(12, multiply(3, 4))
  assert_eq(1, divide_with_ceil(3, 4))
  assert_eq(4, divide_with_ceil(15, 4))
}

test "mathematical_properties" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 15
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 2)),
    add(multiply(x, y), multiply(x, 2))
  )
}

test "edge_cases_and_boundaries" {
  // è¾¹ç•Œæƒ…å†µå’Œæå€¼æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "negative_numbers_handling" {
  // è´Ÿæ•°å¤„ç†æµ‹è¯•
  assert_eq(-2, add(-5, 3))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(15, multiply(-5, -3))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(1, divide_with_ceil(-3, -4))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
}

test "business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—æµ‹è¯•
  let items = 47
  let capacity_per_box = 12
  let boxes_needed = divide_with_ceil(items, capacity_per_box)
  
  assert_eq(4, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, capacity_per_box)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, items)
  assert_eq(1, remaining_space)
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 10
  let multiplier = 3
  let divisor = 4
  let addition = 5
  
  // è®¡ç®—æµç¨‹ï¼š((base * multiplier) / divisor) + addition
  let step1 = multiply(base_value, multiplier)
  let step2 = divide_with_ceil(step1, divisor)
  let result = add(step2, addition)
  
  assert_eq(12, result)  // ceil(10*3/4) + 5 = 8 + 5 = 13
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 100
  let teams = 3
  let min_resources_per_team = divide_with_ceil(total_resources, teams)
  
  assert_eq(34, min_resources_per_team)
  
  // éªŒè¯åˆ†é…ç»“æœ
  let allocated_total = multiply(min_resources_per_team, teams)
  assert_eq(102, allocated_total)
  
  // éªŒè¯èµ„æºåˆ©ç”¨ç‡
  let utilization = divide_with_ceil(multiply(total_resources, 100), allocated_total)
  assert_eq(98, utilization)  // floor(10000/102) = 98%
}

test "error_handling_and_validation" {
  // é”™è¯¯å¤„ç†å’ŒéªŒè¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼éªŒè¯
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(2000000, add(1000000, 1000000))
}

test "real_world_application_scenario" {
  // çœŸå®ä¸–ç•Œåº”ç”¨åœºæ™¯æµ‹è¯•ï¼šæ´»åŠ¨å®‰æ’
  let participants = 87
  let tables = 8
  let chairs_per_table = 10
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(9, tables_needed)
  
  // è®¡ç®—å¯ç”¨åº§ä½æ•°
  let available_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(90, available_seats)
  
  // è®¡ç®—å‰©ä½™åº§ä½
  let remaining_seats = subtract(available_seats, participants)
  assert_eq(3, remaining_seats)
  
  // éªŒè¯åº§ä½å……è¶³æ€§
  assert_true(available_seats >= participants)
}

// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_values" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæƒ…å†µ
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘ Int æœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘ Int æœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(1000000, multiply(1000, 1000))  // å¤§æ•°ä½†å®‰å…¨èŒƒå›´å†…
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 100000
  let monthly_payment = 3500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(29, months_needed)  // ceil(100000/3500) = 29
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(101500, total_payment)
  
  // éªŒè¯æœ€åä¸€ä¸ªæœˆçš„å®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(total_payment, multiply(months_needed - 1, monthly_payment))
  assert_eq(1500, final_payment)
}

test "nested_function_composition" {
  // åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚çš„åµŒå¥—è®¡ç®—
  let result = divide_with_ceil(
    add(
      multiply(base_value, 3),
      multiply(base_value, 2)
    ),
    add(base_value, divide_with_ceil(base_value, 3))
  )
  
  // æ‰‹åŠ¨è®¡ç®—éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
}

test "error_resilience_scenarios" {
  // é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå°é™¤æ•°æƒ…å†µ
  assert_eq(1000000, divide_with_ceil(999999, 1))
  assert_eq(-999999, divide_with_ceil(-999999, 1))
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†æµæ°´çº¿æµ‹è¯•
  // æ¨¡æ‹Ÿæ‰¹é‡æ•°æ®å¤„ç†åœºæ™¯
  let data_batches = 150
  let batch_size = 12
  let processing_time_per_batch = 2
  
  // è®¡ç®—éœ€è¦çš„å¤„ç†è½®æ¬¡
  let processing_rounds = divide_with_ceil(data_batches, batch_size)
  assert_eq(13, processing_rounds)  // ceil(150/12) = 13
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_time = multiply(processing_rounds, processing_time_per_batch)
  assert_eq(26, total_time)
  
  // è®¡ç®—å®é™…å¤„ç†çš„æ•°æ®é‡
  let actual_processed = multiply(processing_rounds - 1, batch_size)
  let final_batch_size = subtract(data_batches, actual_processed)
  assert_eq(6, final_batch_size)  // æœ€åä¸€æ‰¹å¤„ç†6ä¸ª
}

test "string_formatting_edge_cases" {
  // å­—ç¬¦ä¸²æ ¼å¼åŒ–è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ä¸²ç»„åˆ
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, 0x1234!", greet("0x1234"))
  assert_eq_string("Hello, true!", greet("true"))
  assert_eq_string("Hello, false!", greet("false"))
  assert_eq_string("Hello, []!", greet("[]"))
  assert_eq_string("Hello, {}!", greet("{}"))
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•è·¯å¾„çš„æ€§èƒ½ç‰¹å¾
  let input_size = 1000
  
  // çº¿æ€§ç®—æ³•æ¨¡æ‹Ÿ
  let linear_steps = multiply(input_size, 3)
  assert_eq(3000, linear_steps)
  
  // å¯¹æ•°ç®—æ³•æ¨¡æ‹Ÿï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´é™¤æ³•æ¨¡æ‹Ÿï¼‰
  let log_steps = divide_with_ceil(input_size, 100)
  assert_eq(10, log_steps)
  
  // éªŒè¯ç®—æ³•æ•ˆç‡å·®å¼‚
  let efficiency_ratio = divide_with_ceil(linear_steps, log_steps)
  assert_eq(300, efficiency_ratio)
}

test "resource_optimization_problem_new" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // åœºæ™¯ï¼šä»“åº“å­˜å‚¨ä¼˜åŒ–
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  
  // ç‰©å“1ï¼š25ä¸ªï¼Œæ¯ç®±å®¹é‡8
  let item1_quantity = 25
  let item1_capacity = 8
  let boxes_1 = divide_with_ceil(item1_quantity, item1_capacity)  // ceil(25/8) = 4
  
  // ç‰©å“2ï¼š47ä¸ªï¼Œæ¯ç®±å®¹é‡12
  let item2_quantity = 47
  let item2_capacity = 12
  let boxes_2 = divide_with_ceil(item2_quantity, item2_capacity)  // ceil(47/12) = 4
  
  // ç‰©å“3ï¼š156ä¸ªï¼Œæ¯ç®±å®¹é‡20
  let item3_quantity = 156
  let item3_capacity = 20
  let boxes_3 = divide_with_ceil(item3_quantity, item3_capacity)  // ceil(156/20) = 8
  
  // ç‰©å“4ï¼š89ä¸ªï¼Œæ¯ç®±å®¹é‡15
  let item4_quantity = 89
  let item4_capacity = 15
  let boxes_4 = divide_with_ceil(item4_quantity, item4_capacity)  // ceil(89/15) = 6
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let capacity_1 = multiply(boxes_1, item1_capacity)  // 4 * 8 = 32
  let capacity_2 = multiply(boxes_2, item2_capacity)  // 4 * 12 = 48
  let capacity_3 = multiply(boxes_3, item3_capacity)  // 8 * 20 = 160
  let capacity_4 = multiply(boxes_4, item4_capacity)  // 6 * 15 = 90
  
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive_new" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„8ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "performance_large_scale_operations" {
  // å¤§è§„æ¨¡è¿ç®—æ€§èƒ½æµ‹è¯•
  let iterations = 10000
  let sum_result = add(iterations, iterations)
  let product_result = multiply(100, iterations)
  let division_result = divide_with_ceil(product_result, 50)
  
  assert_eq(20000, sum_result)
  assert_eq(1000000, product_result)
  assert_eq(20000, division_result)
}

test "error_boundary_conditions" {
  // é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•å„ç§å¯èƒ½å¯¼è‡´é”™è¯¯çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0
  assert_eq(0, divide_with_ceil(1, 0))  // æ­£æ•°/0
  assert_eq(0, divide_with_ceil(-1, 0))  // è´Ÿæ•°/0
  assert_eq(0, divide_with_ceil(2147483647, 0))  // æœ€å¤§å€¼/0
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // æœ€å°å€¼/0
}

test "string_encoding_handling_new" {
  // å­—ç¬¦ä¸²ç¼–ç å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \"quotes\"!", greet("\"quotes\""))
  assert_eq_string("Hello, 'apostrophe'!", greet("'apostrophe'"))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
}

test "complex_financial_calculations" {
  // å¤æ‚é‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—å¤åˆ©å’Œåˆ†æœŸä»˜æ¬¾
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  
  // éªŒè¯å¤åˆ©å¢é•¿
  assert_eq(10500, year1_end)  // 10000 + 5%
  assert_eq(11025, year2_end)  // 10500 + 5%
  assert_eq(11576, year3_end)  // 11025 + 5%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year3_end, total_months)
  assert_eq(322, monthly_payment)  // ceil(11576/36)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  let input_size_10 = 10
  let input_size_100 = 100
  let input_size_1000 = 1000
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_10 = multiply(input_size_10, 2)
  let linear_100 = multiply(input_size_100, 2)
  let linear_1000 = multiply(input_size_1000, 2)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  let log_10 = divide_with_ceil(input_size_10, 3)
  let log_100 = divide_with_ceil(input_size_100, 3)
  let log_1000 = divide_with_ceil(input_size_1000, 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(20, linear_10)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  
  assert_eq(4, log_10)
  assert_eq(34, log_100)
  assert_eq(334, log_1000)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let stack_size_after_push = add(stack_size, 1)
  let stack_size_after_pop = subtract(stack_size_after_push, 1)
  
  assert_eq(1, stack_size_after_push)
  assert_eq(0, stack_size_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 10
  let queue_items = 7
  let remaining_capacity = subtract(queue_capacity, queue_items)
  let can_add_more = remaining_capacity > 0
  
  assert_eq(3, remaining_capacity)
  assert_true(can_add_more)
}

test "resource_utilization_optimization_new" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory = 16384  // GB
  let servers = 5
  let memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(3277, memory_per_server)  // ceil(16384/5)
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, servers)
  let memory_waste = subtract(total_allocated, total_memory)
  
  assert_eq(16385, total_allocated)
  assert_eq(1, memory_waste)
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥
  let optimized_servers = add(servers, 1)
  let optimized_memory_per_server = divide_with_ceil(total_memory, optimized_servers)
  assert_eq(2341, optimized_memory_per_server)  // ceil(16384/6)
}

test "edge_case_mathematical_operations" {
  // è¾¹ç¼˜æƒ…å†µæ•°å­¦è¿ç®—æµ‹è¯•
  // æµ‹è¯•è¿ç»­è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  let initial_value = 1
  
  // è¿ç»­åŠ æ³•
  let result1 = add(add(add(initial_value, 1), 1), 1)
  assert_eq(4, result1)
  
  // è¿ç»­ä¹˜æ³•
  let result2 = multiply(multiply(multiply(initial_value, 2), 2), 2)
  assert_eq(8, result2)
  
  // æ··åˆè¿ç®—
  let result3 = divide_with_ceil(multiply(add(initial_value, 2), 3), 4)
  assert_eq(3, result3)  // ceil((1+2)*3/4) = ceil(9/4) = 3
  
  // æå€¼è¿ç®—
  let max_int_test = add(2147483647, 0)
  let min_int_test = add(-2147483648, 0)
  
  assert_eq(2147483647, max_int_test)
  assert_eq(-2147483648, min_int_test)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive_test" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_test" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_test" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline_test" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_test" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_test" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_boundary_test" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_test" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_scenario_test" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_basic_arithmetic" {
  // æµ‹è¯•åŸºæœ¬ç®—æœ¯è¿ç®—
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_logistics_scenario" {
  // çœŸå®ä¸–ç•Œç‰©æµåœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—ä»“åº“å­˜å‚¨éœ€æ±‚
  let products = 157
  let pallet_capacity = 24
  let pallets_needed = divide_with_ceil(products, pallet_capacity)
  assert_eq(7, pallets_needed)  // ceil(157/24) = 7
  
  // è®¡ç®—æ€»å­˜å‚¨ç©ºé—´
  let total_space = multiply(pallets_needed, pallet_capacity)
  assert_eq(168, total_space)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_space, products)
  assert_eq(11, remaining_space)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_basic_functionality" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(2, -3))
}

test "multiply_basic_functionality" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(2, -3))
}

test "greet_basic_functionality" {
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "add_identity_properties" {
  assert_eq(7, add(7, 0))
  assert_eq(7, add(0, 7))
}

test "multiply_zero_properties" {
  assert_eq(0, multiply(7, 0))
  assert_eq(0, multiply(0, 7))
}

test "divide_with_ceil_negative_numbers" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-10, -3))
}

test "complex_calculation" {
  let result = add(multiply(3, 4), divide_with_ceil(10, 4))
  assert_eq(15, result)  // 12 + 3 = 15
}

test "greet_unicode_characters" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_commutativity" {
  assert_eq(add(5, 7), add(7, 5))
  assert_eq(multiply(5, 7), multiply(7, 5))
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸º azimuth åº“æ–°å¢çš„10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// åŒ…å«å®é™…åº”ç”¨åœºæ™¯ã€è¾¹ç•Œæƒ…å†µå’Œæ•°å­¦æ€§è´¨éªŒè¯

test "binary_conversion_calculation" {
  // äºŒè¿›åˆ¶è½¬æ¢è®¡ç®—æµ‹è¯•
  let binary_weight_1 = 1
  let binary_weight_2 = 2
  let binary_weight_3 = 4
  let binary_weight_4 = 8
  let binary_weight_5 = 16
  let binary_weight_6 = 32
  
  // éªŒè¯äºŒè¿›åˆ¶ä½æƒè®¡ç®—
  let total_weight = add(add(add(add(add(binary_weight_1, binary_weight_2), binary_weight_3), binary_weight_4), binary_weight_5), binary_weight_6)
  assert_eq(63, total_weight)
  
  // éªŒè¯ç‰¹å®šäºŒè¿›åˆ¶ç»„åˆ
  let binary_42 = add(add(binary_weight_2), add(binary_weight_4), add(binary_weight_5))  // 101010 = 2 + 8 + 32
  assert_eq(42, binary_42)
}

test "temperature_conversion" {
  // æ¸©åº¦è½¬æ¢è®¡ç®—æµ‹è¯•
  let celsius_temp = 25
  let fahrenheit_temp = 77
  
  // æ‘„æ°åº¦åˆ°åæ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šF = C * 9/5 + 32
  let converted_fahrenheit = add(divide_with_ceil(multiply(celsius_temp, 9), 5), 32)
  
  // åæ°åº¦åˆ°æ‘„æ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šC = (F - 32) * 5/9
  let converted_celsius = divide_with_ceil(multiply(add(fahrenheit_temp, -32), 5), 9)
  
  assert_eq(77, converted_fahrenheit)
  assert_eq(25, converted_celsius)
}

test "array_index_calculation" {
  // æ•°ç»„ç´¢å¼•è®¡ç®—æµ‹è¯•ï¼ˆæ¨¡æ‹ŸäºŒç»´æ•°ç»„çš„ä¸€ç»´ç´¢å¼•ï¼‰
  let rows = 4
  let cols = 5
  let row_index = 2
  let col_index = 3
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—ï¼šindex = row * cols + col
  let linear_index = add(multiply(row_index, cols), col_index)
  
  assert_eq(13, linear_index)
  
  // éªŒè¯è¾¹ç•Œæƒ…å†µ
  let first_element = add(multiply(0, cols), 0)
  let last_element = add(multiply(rows - 1, cols - 1), cols - 1)
  
  assert_eq(0, first_element)
  assert_eq(19, last_element)
}

test "prime_number_validation" {
  // è´¨æ•°éªŒè¯æµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let test_number = 17
  let divisor_2 = 2
  let divisor_3 = 3
  let divisor_5 = 5
  
  // æ£€æŸ¥æ˜¯å¦èƒ½è¢«å°è´¨æ•°æ•´é™¤
  let remainder_2 = test_number % divisor_2
  let remainder_3 = test_number % divisor_3
  let remainder_5 = test_number % divisor_5
  
  // éªŒè¯17ä¸èƒ½è¢«2ã€3ã€5æ•´é™¤
  assert_eq(1, remainder_2)
  assert_eq(2, remainder_3)
  assert_eq(2, remainder_5)
  
  // æµ‹è¯•åˆæ•°
  let composite_number = 15
  let composite_remainder_3 = composite_number % divisor_3
  let composite_remainder_5 = composite_number % divisor_5
  
  assert_eq(0, composite_remainder_3)
  assert_eq(0, composite_remainder_5)
}

test "loan_amortization" {
  // è´·æ¬¾åˆ†æœŸè®¡ç®—æµ‹è¯•
  let loan_amount = 10000
  let interest_rate = 5  // 5%
  let loan_term_years = 3
  let months_per_year = 12
  
  // è®¡ç®—æ€»æœˆæ•°
  let total_months = multiply(loan_term_years, months_per_year)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—ï¼ˆä¸åŒ…å«å¤åˆ©ï¼‰
  let total_interest = divide_with_ceil(multiply(loan_amount, interest_rate), 100)
  let total_payment = add(loan_amount, total_interest)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  
  assert_eq(36, total_months)
  assert_eq(500, total_interest)
  assert_eq(10500, total_payment)
  assert_eq(292, monthly_payment)
}

test "game_score_calculation" {
  // æ¸¸æˆå¾—åˆ†è®¡ç®—æµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let bonus_points = 500
  let penalty_points = 200
  
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let level_score = multiply(base_score, level_multiplier)
  let score_with_bonus = add(level_score, bonus_points)
  let final_score = add(score_with_bonus, -penalty_points)
  
  assert_eq(3000, level_score)
  assert_eq(3500, score_with_bonus)
  assert_eq(3300, final_score)
  
  // è®¡ç®—ç­‰çº§æå‡éœ€è¦çš„åˆ†æ•°
  let next_level_threshold = multiply(final_score, 2)
  let current_progress = divide_with_ceil(multiply(final_score, 100), next_level_threshold)
  
  assert_eq(6600, next_level_threshold)
  assert_eq(50, current_progress)
}

test "data_storage_optimization" {
  // æ•°æ®å­˜å‚¨ä¼˜åŒ–æµ‹è¯•
  let file_size_mb = 150
  let compression_ratio = 60  // å‹ç¼©åˆ°60%
  let storage_capacity_mb = 1000
  
  // è®¡ç®—å‹ç¼©åçš„æ–‡ä»¶å¤§å°
  let compressed_size = divide_with_ceil(multiply(file_size_mb, compression_ratio), 100)
  
  // è®¡ç®—å¯ä»¥å­˜å‚¨çš„å‹ç¼©æ–‡ä»¶æ•°é‡
  let files_that_fit = divide_with_ceil(storage_capacity_mb, compressed_size)
  
  // è®¡ç®—å‰©ä½™å­˜å‚¨ç©ºé—´
  let used_space = multiply(files_that_fit, compressed_size)
  let remaining_space = add(storage_capacity_mb, -used_space)
  
  assert_eq(90, compressed_size)
  assert_eq(12, files_that_fit)
  assert_eq(1080, used_space)
  assert_eq(-80, remaining_space)  // è¶…å‡ºå®¹é‡
}

test "network_packet_routing" {
  // ç½‘ç»œæ•°æ®åŒ…è·¯ç”±æµ‹è¯•
  let total_packets = 1000
  let route_1_capacity = 300
  let route_2_capacity = 400
  let route_3_capacity = 500
  
  // è®¡ç®—å„è·¯ç”±åˆ†é…çš„æ•°æ®åŒ…æ•°é‡
  let route_1_packets = divide_with_ceil(multiply(total_packets, route_1_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_2_packets = divide_with_ceil(multiply(total_packets, route_2_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_3_packets = divide_with_ceil(multiply(total_packets, route_3_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  
  // éªŒè¯æ€»åˆ†é…é‡
  let total_allocated = add(add(route_1_packets, route_2_packets), route_3_packets)
  
  assert_eq(250, route_1_packets)
  assert_eq(334, route_2_packets)
  assert_eq(417, route_3_packets)
  assert_eq(1001, total_allocated)  // ç”±äºå‘ä¸Šå–æ•´ï¼Œç•¥å¤šäºæ€»æ•°
}

test "cryptographic_hash_simulation" {
  // åŠ å¯†å“ˆå¸Œæ¨¡æ‹Ÿæµ‹è¯•
  let input_value = 12345
  let prime_1 = 31
  let prime_2 = 37
  let prime_3 = 41
  let modulo_value = 1000000
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè®¡ç®—ï¼šhash = ((input * p1) + p2) * p3 % mod
  let step1 = add(multiply(input_value, prime_1), prime_2)
  let step2 = multiply(step1, prime_3)
  let hash_result = step2 % modulo_value
  
  assert_eq(382816, add(multiply(12345, 31), 37))
  assert_eq(15695456, multiply(382816, 41))
  assert_eq(695456, hash_result)
  
  // éªŒè¯å“ˆå¸Œçš„ç¡®å®šæ€§ï¼ˆç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡ºï¼‰
  let hash_repeat = ((add(multiply(input_value, prime_1), prime_2)) * prime_3) % modulo_value
  assert_eq(hash_result, hash_repeat)
}

test "cpu_scheduling_simulation" {
  // CPUè°ƒåº¦æ¨¡æ‹Ÿæµ‹è¯•
  let process_1_time = 8
  let process_2_time = 12
  let process_3_time = 6
  let process_4_time = 10
  let time_quantum = 4
  
  // è®¡ç®—æ¯ä¸ªè¿›ç¨‹éœ€è¦çš„æ—¶é—´ç‰‡æ•°é‡
  let process_1_quanta = divide_with_ceil(process_1_time, time_quantum)
  let process_2_quanta = divide_with_ceil(process_2_time, time_quantum)
  let process_3_quanta = divide_with_ceil(process_3_time, time_quantum)
  let process_4_quanta = divide_with_ceil(process_4_time, time_quantum)
  
  // è®¡ç®—æ€»æ—¶é—´ç‰‡æ•°
  let total_quanta = add(add(add(process_1_quanta, process_2_quanta), process_3_quanta), process_4_quanta)
  
  // è®¡ç®—æ€»æ‰§è¡Œæ—¶é—´ï¼ˆè€ƒè™‘ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼‰
  let context_switch_overhead = 1
  let total_execution_time = add(multiply(total_quanta, time_quantum), multiply(total_quanta, context_switch_overhead))
  
  assert_eq(2, process_1_quanta)
  assert_eq(3, process_2_quanta)
  assert_eq(2, process_3_quanta)
  assert_eq(3, process_4_quanta)
  assert_eq(10, total_quanta)
  assert_eq(50, total_execution_time)
}

// æ–°å¢çš„8ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_associative_laws" {
  // æµ‹è¯•åŠ æ³•å’Œä¹˜æ³•çš„ç»“åˆå¾‹
  let a = 2
  let b = 3
  let c = 4
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "extreme_boundary_conditions" {
  // æµ‹è¯•æç«¯è¾¹ç•Œæ¡ä»¶
  // å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000000, multiply(1000000, 1000))
  
  // æ¥è¿‘é›¶çš„è¿ç®—
  assert_eq(1, divide_with_ceil(1, 1000000))
  assert_eq(0, divide_with_ceil(0, 1000000))
  
  // è´Ÿæ•°æå€¼
  assert_eq(-2000000, add(-1000000, -1000000))
  assert_eq(1000000000, multiply(-1000000, -1000))
}

test "real_world_inventory_management" {
  // çœŸå®ä¸–ç•Œåº“å­˜ç®¡ç†åœºæ™¯
  let total_products = 1234
  let box_capacity = 45
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // éªŒè¯ç®±å­æ•°é‡è®¡ç®—
  assert_eq(28, boxes_needed)  // ceil(1234/45) = 28
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(1260, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let unused_space = subtract(total_capacity, total_products)
  assert_eq(26, unused_space)
}

test "mathematical_distributive_property_extended" {
  // æ‰©å±•çš„åˆ†é…å¾‹æµ‹è¯•
  let a = 7
  let b = 5
  let c = 3
  
  // å®Œæ•´åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
  
  // åµŒå¥—åˆ†é…å¾‹
  let complex_left = multiply(add(a, b), add(c, 2))
  let complex_right = add(add(multiply(a, c), multiply(a, 2)), add(multiply(b, c), multiply(b, 2)))
  assert_eq(complex_left, complex_right)
}

test "error_handling_comprehensive" {
  // å…¨é¢çš„é”™è¯¯å¤„ç†æµ‹è¯•
  // é™¤é›¶çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  
  // æå°é™¤æ•°
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(-2147483647, divide_with_ceil(-2147483647, 1))
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, 123.45!", greet("123.45"))
  assert_eq_string("Hello, [object Object]!", greet("[object Object]"))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, 'single'!", greet("'single'"))
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  let data_sizes = [10, 100, 1000]
  let expected_linear = [20, 200, 2000]  // O(n)
  let expected_logarithmic = [2, 7, 67]  // O(log n) simplified
  
  // æ¨¡æ‹Ÿçº¿æ€§ç®—æ³•å¤æ‚åº¦
  assert_eq(expected_linear[0], multiply(data_sizes[0], 2))
  assert_eq(expected_linear[1], multiply(data_sizes[1], 2))
  assert_eq(expected_linear[2], multiply(data_sizes[2], 2))
  
  // æ¨¡æ‹Ÿå¯¹æ•°ç®—æ³•å¤æ‚åº¦ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  assert_eq(expected_logarithmic[0], divide_with_ceil(data_sizes[0], 5))
  assert_eq(expected_logarithmic[1], divide_with_ceil(data_sizes[1], 15))
  assert_eq(expected_logarithmic[2], divide_with_ceil(data_sizes[2], 15))
}

test "business_calculation_comprehensive" {
  // ç»¼åˆä¸šåŠ¡è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šé¡¹ç›®é¢„ç®—å’Œèµ„æºåˆ†é…
  let project_duration = 18  // æœˆ
  let team_size = 12
  let average_salary = 8000  // æ¯äººæ¯æœˆ
  let equipment_cost = 50000
  let contingency_rate = 15  // ç™¾åˆ†æ¯”
  
  // è®¡ç®—äººåŠ›æˆæœ¬
  let total_person_months = multiply(team_size, project_duration)
  let labor_cost = multiply(total_person_months, average_salary)
  
  // è®¡ç®—åº”æ€¥èµ„é‡‘
  let contingency_amount = divide_with_ceil(multiply(labor_cost, contingency_rate), 100)
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = add(add(labor_cost, equipment_cost), contingency_amount)
  
  // éªŒè¯è®¡ç®—ç»“æœ
  assert_eq(216, total_person_months)  // 12 * 18
  assert_eq(1728000, labor_cost)  // 216 * 8000
  assert_eq(259200, contingency_amount)  // ceil(1728000 * 15 / 100)
  assert_eq(2037200, total_budget)  // 1728000 + 50000 + 259200
  
  // è®¡ç®—æœˆåº¦é¢„ç®—åˆ†é…
  let monthly_budget = divide_with_ceil(total_budget, project_duration)
  assert_eq(113178, monthly_budget)  // ceil(2037200 / 18)
}

// æ ‡å‡† MoonBit å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_commutative_law" {
  // éªŒè¯åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(8, 7))
  assert_eq(15, add(7, 8))
  assert_eq(0, add(-5, 5))
  assert_eq(0, add(5, -5))
  assert_eq(-10, add(-3, -7))
  assert_eq(-10, add(-7, -3))
}

test "multiply_function_distributive_law" {
  // éªŒè¯ä¹˜æ³•åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 6
  let b = 4
  let c = 2
  
  let left_result = multiply(a, add(b, c))
  let right_result = add(multiply(a, b), multiply(a, c))
  assert_eq(left_result, right_result)  // 6 * (4 + 2) = 6 * 4 + 6 * 2 = 36
  
  // å¦ä¸€ä¸ªä¾‹å­
  assert_eq(20, multiply(4, add(2, 3)))  // 4 * (2 + 3) = 20
  assert_eq(20, add(multiply(4, 2), multiply(4, 3)))  // 4 * 2 + 4 * 3 = 20
}

test "divide_with_ceil_real_world_scenarios" {
  // çœŸå®ä¸–ç•Œåœºæ™¯ï¼šè®¡ç®—è£…ç›’é—®é¢˜
  let total_items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(total_items, box_capacity)
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†
  let packages = 25
  let capacity_per_truck = 8
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(4, trucks_needed)  // ceil(25/8) = 4
}

test "greet_function_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿ï¼šé¡¹ç›®èµ„æºè§„åˆ’
  let team_size = 8
  let tasks_per_person = 5
  let sprint_capacity = 15
  
  // è®¡ç®—æ€»ä»»åŠ¡æ•°
  let total_tasks = multiply(team_size, tasks_per_person)
  assert_eq(40, total_tasks)
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ•°
  let sprints_needed = divide_with_ceil(total_tasks, sprint_capacity)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(sprints_needed, sprint_capacity)
  assert_eq(45, total_capacity)
}

test "mathematical_identity_properties" {
  // æ•°å­¦æ’ç­‰å¼éªŒè¯
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(multiply(x, -1), multiply(-1, x))
}

test "divide_with_ceil_edge_cases" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç¼˜æƒ…å†µ
  // é›¶å€¼æµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  
  // è´Ÿæ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-7, 4))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(-1, divide_with_ceil(-1, 4))
  
  // è´Ÿé™¤æ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(7, -4))
  assert_eq(-1, divide_with_ceil(3, -4))
  assert_eq(0, divide_with_ceil(1, -4))
  
  // åŒè´Ÿæ•°æµ‹è¯•
  assert_eq(2, divide_with_ceil(-7, -4))
  assert_eq(1, divide_with_ceil(-3, -4))
  assert_eq(1, divide_with_ceil(-1, -4))
}

test "business_logic_inventory_management" {
  // åº“å­˜ç®¡ç†ä¸šåŠ¡é€»è¾‘ - ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸ä½¿ç”¨æ•°ç»„
  // äº§å“1: 25ä¸ªç‰©å“ï¼Œæ¯ç®±8ä¸ª
  let boxes_1 = divide_with_ceil(25, 8)  // ceil(25/8) = 4
  let capacity_1 = multiply(boxes_1, 8)  // 4 * 8 = 32
  
  // äº§å“2: 47ä¸ªç‰©å“ï¼Œæ¯ç®±12ä¸ª
  let boxes_2 = divide_with_ceil(47, 12)  // ceil(47/12) = 4
  let capacity_2 = multiply(boxes_2, 12)  // 4 * 12 = 48
  
  // äº§å“3: 156ä¸ªç‰©å“ï¼Œæ¯ç®±20ä¸ª
  let boxes_3 = divide_with_ceil(156, 20)  // ceil(156/20) = 8
  let capacity_3 = multiply(boxes_3, 20)  // 8 * 20 = 160
  
  // äº§å“4: 89ä¸ªç‰©å“ï¼Œæ¯ç®±15ä¸ª
  let boxes_4 = divide_with_ceil(89, 15)  // ceil(89/15) = 6
  let capacity_4 = multiply(boxes_4, 15)  // 6 * 15 = 90
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

test "large_number_operations" {
  // å¤§æ•°è¿ç®—æµ‹è¯• - ä½¿ç”¨è¾ƒå°çš„å¤§æ•°ä»¥é¿å…æº¢å‡º
  let large_num = 10000
  
  // å¤§æ•°åŠ æ³•
  assert_eq(20000, add(large_num, large_num))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(100000000, multiply(large_num, large_num))
  
  // å¤§æ•°é™¤æ³•
  assert_eq(1, divide_with_ceil(large_num, large_num))
  assert_eq(2, divide_with_ceil(add(large_num, 1), large_num))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(10, divide_with_ceil(99, 10))
  assert_eq(11, divide_with_ceil(101, 10))
}

test "nested_calculations_composition" {
  // åµŒå¥—è®¡ç®—ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚åµŒå¥—è®¡ç®—ï¼š(base * 3 + base * 2) / (base + ceil(base/3))
  let numerator = add(multiply(base_value, 3), multiply(base_value, 2))
  let denominator = add(base_value, divide_with_ceil(base_value, 3))
  let result = divide_with_ceil(numerator, denominator)
  
  // æ‰‹åŠ¨éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
  
  // å¦ä¸€ä¸ªåµŒå¥—è®¡ç®—ç¤ºä¾‹
  let complex_result = divide_with_ceil(
    multiply(add(5, 3), 4),
    subtract(10, 2)
  )
  assert_eq(4, complex_result)  // ceil((5+3)*4 / (10-2)) = ceil(32/8) = 4
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "subtract_operation_simulation" {
  // æ¨¡æ‹Ÿå‡æ³•æ“ä½œï¼ša - b = a + (-b)
  let a = 15
  let b = 7
  let negative_b = multiply(b, -1)
  let result = add(a, negative_b)
  assert_eq(8, result)
}

test "percentage_calculation" {
  // ç™¾åˆ†æ¯”è®¡ç®—æµ‹è¯•
  let total = 200
  let percentage = 25  // 25%
  let result = divide_with_ceil(multiply(total, percentage), 100)
  assert_eq(50, result)
}

test "batch_processing_efficiency" {
  // æ‰¹å¤„ç†æ•ˆç‡æµ‹è¯•
  let total_items = 157
  let batch_size = 20
  let full_batches = divide_with_ceil(total_items, batch_size)
  assert_eq(8, full_batches)  // ceil(157/20) = 8
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(full_batches, batch_size)
  assert_eq(160, total_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let unused_capacity = subtract(total_capacity, total_items)
  assert_eq(3, unused_capacity)
}

test "string_concatenation_length" {
  // å­—ç¬¦ä¸²è¿æ¥é•¿åº¦æµ‹è¯•
  let name = "MoonBit"
  let greeting = greet(name)
  let expected_length = add(add(7, 6), 1)  // "Hello, " + "MoonBit" + "!" = 7 + 6 + 1 = 14
  assert_eq(14, expected_length)
  // greeting is intentionally unused
}

test "division_precision_test" {
  // é™¤æ³•ç²¾åº¦æµ‹è¯•
  // æµ‹è¯•è¿ç»­é™¤æ³•çš„ç²¾åº¦ä¿æŒ
  let initial_value = 1000
  let divisor1 = 3
  let divisor2 = 7
  let divisor3 = 11
  
  let step1 = divide_with_ceil(initial_value, divisor1)
  let step2 = divide_with_ceil(step1, divisor2)
  let step3 = divide_with_ceil(step2, divisor3)
  
  // éªŒè¯æ¯ä¸€æ­¥çš„ç»“æœ
  assert_eq(334, step1)   // ceil(1000/3)
  assert_eq(48, step2)    // ceil(334/7)
  assert_eq(5, step3)     // ceil(48/11)
}

test "resource_allocation_fairness" {
  // èµ„æºåˆ†é…å…¬å¹³æ€§æµ‹è¯•
  let total_resources = 100
  let participants = 9
  
  // è®¡ç®—æ¯äººåº”å¾—ä»½é¢
  let base_share = divide_with_ceil(total_resources, participants)
  assert_eq(12, base_share)  // ceil(100/9) = 12
  
  // è®¡ç®—æ€»åˆ†é…é‡
  let total_allocated = multiply(base_share, participants)
  assert_eq(108, total_allocated)
  
  // è®¡ç®—æº¢å‡ºé‡
  let overflow = subtract(total_allocated, total_resources)
  assert_eq(8, overflow)
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let total_tasks = 87
  let team_velocity = 12  // æ¯å‘¨å®Œæˆçš„ä»»åŠ¡æ•°
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(total_tasks, team_velocity)
  assert_eq(8, weeks_needed)  // ceil(87/12) = 8
  
  // è®¡ç®—æ€»å·¥ä½œæ—¥ï¼ˆå‡è®¾æ¯å‘¨5ä¸ªå·¥ä½œæ—¥ï¼‰
  let work_days = multiply(weeks_needed, 5)
  assert_eq(40, work_days)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(weeks_needed, team_velocity)
  assert_eq(96, total_capacity)
}

test "exponential_growth_simulation" {
  // æŒ‡æ•°å¢é•¿æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿç®€å•çš„æŒ‡æ•°å¢é•¿ï¼šæ¯æ¬¡ç¿»å€
  let initial_value = 3
  let growth_periods = 5  // è¿™ä¸ªå˜é‡åªæ˜¯ç”¨äºæ¼”ç¤ºï¼Œå®é™…æœªä½¿ç”¨
  
  // æ‰‹åŠ¨è®¡ç®—æŒ‡æ•°å¢é•¿
  let period1 = multiply(initial_value, 2)
  let period2 = multiply(period1, 2)
  let period3 = multiply(period2, 2)
  let period4 = multiply(period3, 2)
  let period5 = multiply(period4, 2)
  
  assert_eq(6, period1)    // 3 * 2
  assert_eq(12, period2)   // 6 * 2
  assert_eq(24, period3)   // 12 * 2
  assert_eq(48, period4)   // 24 * 2
  assert_eq(96, period5)   // 48 * 2
  
  // éªŒè¯æœ€ç»ˆç»“æœ
  assert_eq(96, period5)
  // growth_periods is intentionally unused
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "azimuth_enhanced_basic_addition" {
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "azimuth_enhanced_multiplication_edge_cases" {
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "azimuth_enhanced_greeting_international" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "azimuth_enhanced_divide_with_ceil_business_logic" {
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "azimuth_enhanced_complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "azimuth_enhanced_mathematical_properties" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "azimuth_enhanced_resource_allocation" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "azimuth_enhanced_error_handling" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "azimuth_enhanced_string_processing" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "azimuth_enhanced_real_world_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // éªŒè¯ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼
  let n = 5
  let sum_1_to_n = divide_with_ceil(multiply(n, add(n, 1)), 2)
  assert_eq(15, sum_1_to_n)  // 5*6/2 = 15
  
  // éªŒè¯ç­‰æ¯”æ•°åˆ—æ±‚å’Œ
  let geo_sum = add(add(2, 4), add(8, 16))  // 2 + 4 + 8 + 16
  assert_eq(30, geo_sum)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  // è®¡ç®—æ¯ä¸ªé¡¹ç›®éœ€è¦çš„é˜¶æ®µæ•°
  let phases_1 = divide_with_ceil(120, 25)  // ceil(120/25) = 5
  let phases_2 = divide_with_ceil(85, 20)   // ceil(85/20) = 5
  let phases_3 = divide_with_ceil(200, 45)  // ceil(200/45) = 5
  let phases_4 = divide_with_ceil(150, 35)  // ceil(150/35) = 5
  
  // è®¡ç®—æ€»é˜¶æ®µæ•°
  let total_phases = add(add(phases_1, phases_2), add(phases_3, phases_4))
  assert_eq(20, total_phases)
  
  // è®¡ç®—å®é™…åˆ†é…çš„å·¥æ—¶
  let allocated_1 = multiply(phases_1, 25)  // 5 * 25 = 125
  let allocated_2 = multiply(phases_2, 20)  // 5 * 20 = 100
  let allocated_3 = multiply(phases_3, 45)  // 5 * 45 = 225
  let allocated_4 = multiply(phases_4, 35)  // 5 * 35 = 175
  
  let total_allocated = add(add(allocated_1, allocated_2), add(allocated_3, allocated_4))
  assert_eq(625, total_allocated)
}

test "multilingual_greeting_processing" {
  // å¤šè¯­è¨€é—®å€™å¤„ç†æµ‹è¯•
  let greeting_1 = greet("World")
  let greeting_2 = greet("ä¸–ç•Œ")
  let greeting_3 = greet("ĞœĞ¸Ñ€")
  let greeting_4 = greet("ğŸŒ")
  let greeting_5 = greet("cafÃ©")
  
  // éªŒè¯é—®å€™è¯­æ ¼å¼
  assert_eq_string("Hello, World!", greeting_1)
  assert_eq_string("Hello, ä¸–ç•Œ!", greeting_2)
  assert_eq_string("Hello, ĞœĞ¸Ñ€!", greeting_3)
  assert_eq_string("Hello, ğŸŒ!", greeting_4)
  assert_eq_string("Hello, cafÃ©!", greeting_5)
  
  // è®¡ç®—æ€»å­—ç¬¦æ•°ï¼ˆæ¨¡æ‹Ÿï¼‰
  let total_length = add(add(add(add(13, 10), 10), 10), 11)
  assert_eq(54, total_length)
  
  // è®¡ç®—å¹³å‡é•¿åº¦
  let avg_length = divide_with_ceil(total_length, 5)
  assert_eq(11, avg_length)  // ceil(54/5) = 11
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  // O(1) ç®—æ³• - æ’å®šæ—¶é—´
  let constant_time = 5
  
  // O(n) ç®—æ³• - çº¿æ€§æ—¶é—´
  let linear_100 = multiply(100, 2)
  let linear_1000 = multiply(1000, 2)
  let linear_10000 = multiply(10000, 2)
  
  // O(nÂ²) ç®—æ³• - å¹³æ–¹æ—¶é—´ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let quadratic_100 = multiply(100, 100)
  let quadratic_1000 = divide_with_ceil(multiply(1000, 1000), 10)
  let quadratic_10000 = divide_with_ceil(multiply(10000, 10000), 100)
  
  // éªŒè¯ç®—æ³•å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  assert_eq(20000, linear_10000)
  
  assert_eq(10000, quadratic_100)
  assert_eq(100000, quadratic_1000)
  assert_eq(1000000, quadratic_10000)
  
  // è®¡ç®—æ•ˆç‡æ¯”ç‡
  let linear_to_constant = divide_with_ceil(linear_1000, constant_time)
  let quadratic_to_linear = divide_with_ceil(quadratic_1000, linear_1000)
  
  assert_eq(400, linear_to_constant)  // 2000/5 = 400
  assert_eq(50, quadratic_to_linear)  // 100000/2000 = 50
}

test "financial_investment_calculation" {
  // é‡‘èæŠ•èµ„è®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 8  // 8%
  let years = 5
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year_1 = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year_2 = add(year_1, divide_with_ceil(multiply(year_1, annual_rate), 100))
  let year_3 = add(year_2, divide_with_ceil(multiply(year_2, annual_rate), 100))
  let year_4 = add(year_3, divide_with_ceil(multiply(year_3, annual_rate), 100))
  let year_5 = add(year_4, divide_with_ceil(multiply(year_4, annual_rate), 100))
  
  // éªŒè¯æ¯å¹´çš„å¢é•¿
  assert_eq(10800, year_1)   // 10000 + 8%
  assert_eq(11664, year_2)   // 10800 + 8%
  assert_eq(12597, year_3)   // 11664 + 8%
  assert_eq(13605, year_4)   // 12597 + 8%
  assert_eq(14693, year_5)   // 13605 + 8%
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_return = subtract(year_5, principal)
  let return_percentage = divide_with_ceil(multiply(total_return, 100), principal)
  
  assert_eq(4693, total_return)  // 14693 - 10000
  assert_eq(47, return_percentage)  // ceil(4693/10000 * 100) = 47%
  
  // è®¡ç®—æœˆä¾›ï¼ˆ5å¹´åˆ†æœŸï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year_5, total_months)
  assert_eq(245, monthly_payment)  // ceil(14693/60)
}

test "warehouse_inventory_management" {
  // ä»“åº“åº“å­˜ç®¡ç†æµ‹è¯•
  // è®¡ç®—æ¯ä¸ªä»“åº“çš„åˆ©ç”¨ç‡
  let utilization_1 = divide_with_ceil(multiply(500, 100), 75)
  let utilization_2 = divide_with_ceil(multiply(300, 100), 100)
  let utilization_3 = divide_with_ceil(multiply(800, 100), 120)
  let utilization_4 = divide_with_ceil(multiply(200, 100), 50)
  
  assert_eq(667, utilization_1)  // ceil(500/75 * 100) = 667%
  assert_eq(300, utilization_2)  // ceil(300/100 * 100) = 300%
  assert_eq(667, utilization_3)  // ceil(800/120 * 100) = 667%
  assert_eq(400, utilization_4)  // ceil(200/50 * 100) = 400%
  
  // è®¡ç®—æ€»åº“å­˜å’Œæ€»å®¹é‡
  let total_current = add(add(500, 300), add(800, 200))
  let total_capacity = add(add(75, 100), add(120, 50))
  
  assert_eq(1800, total_current)  // 500 + 300 + 800 + 200
  assert_eq(345, total_capacity)   // 75 + 100 + 120 + 50
  
  // è®¡ç®—éœ€è¦çš„é¢å¤–ä»“åº“ç©ºé—´
  let additional_space_needed = divide_with_ceil(subtract(total_current, total_capacity), 150)
  assert_eq(10, additional_space_needed)  // ceil(1455/150) = 10
}

test "numerical_system_validation" {
  // æ•°å­—ç³»ç»ŸéªŒè¯æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num_1 = 123456
  let large_num_2 = 789012
  let sum_large = add(large_num_1, large_num_2)
  let product_approx = multiply(divide_with_ceil(large_num_1, 100), divide_with_ceil(large_num_2, 1000))
  
  assert_eq(912468, sum_large)  // 123456 + 789012
  assert_eq(984, product_approx)  // 1235 * 789 â‰ˆ 974415 (ç®€åŒ–è®¡ç®—)
  
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—
  let fibonacci_1 = 1
  let fibonacci_2 = 1
  let fibonacci_3 = add(fibonacci_1, fibonacci_2)  // 2
  let fibonacci_4 = add(fibonacci_2, fibonacci_3)  // 3
  let fibonacci_5 = add(fibonacci_3, fibonacci_4)  // 5
  let fibonacci_6 = add(fibonacci_4, fibonacci_5)  // 8
  
  assert_eq(2, fibonacci_3)
  assert_eq(3, fibonacci_4)
  assert_eq(5, fibonacci_5)
  assert_eq(8, fibonacci_6)
  
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å’Œ
  let mut fib_sum = add(add(add(fibonacci_1, fibonacci_2), fibonacci_3), fibonacci_4)
  fib_sum = add(add(fib_sum, fibonacci_5), fibonacci_6)
  assert_eq(20, fib_sum)  // 1 + 1 + 2 + 3 + 5 + 8 = 20
  
  // éªŒè¯é»„é‡‘æ¯”ä¾‹è¿‘ä¼¼å€¼
  let golden_ratio_approx = divide_with_ceil(multiply(fibonacci_6, 100), fibonacci_5)
  assert_eq(160, golden_ratio_approx)  // ceil(8/5 * 100) = 160 (1.6)
}

test "performance_metrics_evaluation" {
  // æ€§èƒ½æŒ‡æ ‡è¯„ä¼°æµ‹è¯•
  let base_iterations = 1000
  
  // åŠ æ³•æ€§èƒ½æµ‹è¯•
  let add_result = multiply(base_iterations, 10)
  assert_eq(10000, add_result)  // 1000 * 10
  
  // ä¹˜æ³•æ€§èƒ½æµ‹è¯•
  let multiply_result = multiply(base_iterations, 10)
  assert_eq(10000, multiply_result)
  
  // é™¤æ³•æ€§èƒ½æµ‹è¯•
  let divide_result = divide_with_ceil(multiply(base_iterations, 10), 3)
  assert_eq(3334, divide_result)  // ceil(10000/3)
  
  // å¤åˆæ“ä½œæ€§èƒ½æµ‹è¯•
  let complex_result = add(
    multiply(base_iterations, 5),
    divide_with_ceil(multiply(base_iterations, 3), 7)
  )
  assert_eq(6429, complex_result)  // 5000 + ceil(3000/7)
  
  // æ“ä½œæ•ˆç‡æ¯”è¾ƒ
  let add_efficiency = divide_with_ceil(add_result, base_iterations)
  let multiply_efficiency = divide_with_ceil(multiply_result, base_iterations)
  let divide_efficiency = divide_with_ceil(divide_result, base_iterations)
  
  assert_eq(10, add_efficiency)      // 10000/1000 = 10
  assert_eq(10, multiply_efficiency) // 10000/1000 = 10
  assert_eq(4, divide_efficiency)    // ceil(3334/1000) = 4
  
  // è®¡ç®—æ€»ä½“æ€§èƒ½å¾—åˆ†
  let performance_score = add(add(add_efficiency, multiply_efficiency), divide_efficiency)
  assert_eq(24, performance_score)  // 10 + 10 + 4
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_conditions" {
  // æç«¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„å€¼
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq(-2147483648, add(-2147483647, -1))
  assert_eq(1, divide_with_ceil(2147483647, 2147483647))
  assert_eq(0, divide_with_ceil(-2147483648, 2147483647))
}

test "string_edge_cases_comprehensive" {
  // å­—ç¬¦ä¸²è¾¹ç¼˜æƒ…å†µç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \\0!", greet("\\0"))
  assert_eq_string("Hello, \\\"!", greet("\""))
  assert_eq_string("Hello, \\\\!", greet("\\"))
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
}

test "divide_with_ceil_comprehensive_error_handling" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„ç»¼åˆé”™è¯¯å¤„ç†
  // å„ç§é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå°é™¤æ•°
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(-2147483648, divide_with_ceil(-2147483648, 1))
}

test "complex_mathematical_series" {
  // å¤æ‚æ•°å­¦çº§æ•°æµ‹è¯•
  // ç­‰å·®æ•°åˆ—æ±‚å’Œ
  let n = 10
  let first_term = 1
  let last_term = 10
  let arithmetic_sum = divide_with_ceil(multiply(n, add(first_term, last_term)), 2)
  assert_eq(55, arithmetic_sum)  // 10 * (1 + 10) / 2 = 55
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼ˆç®€åŒ–ï¼‰
  let ratio = 2
  let geometric_sum = subtract(multiply(ratio, n), 1)
  assert_eq(19, geometric_sum)  // 2^10 - 1 (ç®€åŒ–è®¡ç®—)
}

test "real_world_logistics_optimization" {
  // çœŸå®ä¸–ç•Œç‰©æµä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šå¤šä»“åº“è´§ç‰©åˆ†é…
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  
  // ä»“åº“1ï¼š100ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡25
  let warehouse1_goods = 100
  let warehouse1_capacity = 25
  let trucks_1 = divide_with_ceil(warehouse1_goods, warehouse1_capacity)  // ceil(100/25) = 4
  
  // ä»“åº“2ï¼š150ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡40
  let warehouse2_goods = 150
  let warehouse2_capacity = 40
  let trucks_2 = divide_with_ceil(warehouse2_goods, warehouse2_capacity)  // ceil(150/40) = 4
  
  // ä»“åº“3ï¼š80ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡20
  let warehouse3_goods = 80
  let warehouse3_capacity = 20
  let trucks_3 = divide_with_ceil(warehouse3_goods, warehouse3_capacity)  // ceil(80/20) = 4
  
  // ä»“åº“4ï¼š200ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡35
  let warehouse4_goods = 200
  let warehouse4_capacity = 35
  let trucks_4 = divide_with_ceil(warehouse4_goods, warehouse4_capacity)  // ceil(200/35) = 6
  
  let total_trucks = add(add(trucks_1, trucks_2), add(trucks_3, trucks_4))
  assert_eq(18, total_trucks)
  
  // è®¡ç®—æ€»è¿åŠ›å’Œåˆ©ç”¨ç‡
  let total_capacity = add(
    multiply(trucks_1, warehouse1_capacity),
    add(multiply(trucks_2, warehouse2_capacity), 
    add(multiply(trucks_3, warehouse3_capacity), multiply(trucks_4, warehouse4_capacity)))
  )
  let total_goods = add(add(warehouse1_goods, warehouse2_goods), add(warehouse3_goods, warehouse4_goods))
  
  assert_eq(530, total_capacity)  // 4*25 + 4*40 + 4*20 + 6*35
  assert_eq(530, total_goods)     // 100 + 150 + 80 + 200
}

test "advanced_error_recovery_scenarios" {
  // é«˜çº§é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // æ¨¡æ‹Ÿæ•°æ®æŸåå’Œæ¢å¤
  let corrupted_data = -1
  let fallback_value = 0
  
  // é”™è¯¯æ£€æµ‹å’Œæ¢å¤
  let recovered_data = add(corrupted_data, multiply(fallback_value, 2))
  assert_eq(-1, recovered_data)
  
  // ä½¿ç”¨é™¤æ³•è¿›è¡Œé”™è¯¯æ£€æµ‹
  let error_detected = divide_with_ceil(corrupted_data, 0)
  assert_eq(0, error_detected)  // é™¤é›¶é”™è¯¯è¿”å›0
  
  // æ•°æ®éªŒè¯
  let is_valid = multiply(recovered_data, recovered_data) >= 0
  assert_true(is_valid)
}

test "statistical_analysis_operations" {
  // ç»Ÿè®¡åˆ†ææ“ä½œæµ‹è¯•
  // è®¡ç®—å¹³å‡å€¼ï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  let num1 = 10
  let num2 = 20
  let num3 = 30
  let num4 = 40
  let num5 = 50
  let sum = add(add(add(add(num1, num2), num3), num4), num5)
  let count = 5
  let average = divide_with_ceil(sum, count)
  assert_eq(30, average)  // ceil(150/5) = 30
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ï¼‰
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  let dev1 = subtract(num1, average)
  let dev2 = subtract(num2, average)
  let dev3 = subtract(num3, average)
  let dev4 = subtract(num4, average)
  let dev5 = subtract(num5, average)
    // dev1 = -20, dev2 = -10, dev3 = 0, dev4 = 10, dev5 = 20
  
  // è®¡ç®—å¹³æ–¹åå·®
  let squared_dev1 = multiply(dev1, dev1)  // 400
  let squared_dev2 = multiply(dev2, dev2)  // 100
  let squared_dev3 = multiply(dev3, dev3)  // 0
    let squared_dev4 = multiply(dev4, dev4)  // 100
  let squared_dev5 = multiply(dev5, dev5)  // 400
  
  let variance_sum = add(add(add(add(squared_dev1, squared_dev2), squared_dev3), squared_dev4), squared_dev5)
  let variance = divide_with_ceil(variance_sum, count)
  assert_eq(200, variance)  // ceil(1000/5) = 200
}

test "cryptography_simulation" {
  // å¯†ç å­¦æ¨¡æ‹Ÿæµ‹è¯•
  // ç®€åŒ–çš„å‡¯æ’’å¯†ç 
  let plaintext = "Hello"
  let shift = 3
  
  // æ¨¡æ‹ŸåŠ å¯†è¿‡ç¨‹ï¼ˆä½¿ç”¨æ•°å€¼è¿ç®—ï¼‰
  let encrypted_numeric = add(72, shift)  // 'H' (72) + 3 = 75 ('K')
  assert_eq(75, encrypted_numeric)
  
  // æ¨¡æ‹Ÿè§£å¯†è¿‡ç¨‹
  let decrypted_numeric = subtract(encrypted_numeric, shift)
  assert_eq(72, decrypted_numeric)
  
  // ç®€åŒ–çš„å“ˆå¸Œæ¨¡æ‹Ÿ
  let hash_input = 12345
  let hash_prime = 31
  let hash_result = multiply(hash_input, hash_prime)
  assert_eq(382695, hash_result)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œå†²çªæ£€æµ‹
  let another_input = 617
  let another_hash = multiply(another_input, hash_prime)
  let hash_collision = divide_with_ceil(hash_result, another_hash)
  assert_eq(2, hash_collision)  // ceil(382695/19127) = 2
}

test "advanced_financial_modeling" {
  // é«˜çº§é‡‘èå»ºæ¨¡æµ‹è¯•
  // å¤æ‚çš„è´·æ¬¾è®¡ç®—
  let principal = 200000
  let annual_rate = 6  // 6%
  let loan_term_years = 30
  
  // è®¡ç®—æœˆåˆ©ç‡ï¼ˆç®€åŒ–ï¼‰
  let monthly_rate = divide_with_ceil(annual_rate, 12)
  assert_eq(1, monthly_rate)  // ceil(6/12) = 1%
  
  // è®¡ç®—æ€»æœˆæ•°
  let total_months = multiply(loan_term_years, 12)
  assert_eq(360, total_months)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—
  let monthly_payment = divide_with_ceil(
    add(principal, divide_with_ceil(multiply(principal, annual_rate), 100)),
    total_months
  )
  assert_eq(556, monthly_payment)  // ceil((200000 + 12000) / 360)
  
  // è®¡ç®—æ€»æ”¯ä»˜é¢
  let total_payment = multiply(monthly_payment, total_months)
  assert_eq(200160, total_payment)
  
  // è®¡ç®—æ€»åˆ©æ¯
  let total_interest = subtract(total_payment, principal)
  assert_eq(160, total_interest)
}

test "quantum_computing_simulation" {
  // é‡å­è®¡ç®—æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿé‡å­ä½æ“ä½œ
  let qubit_state_0 = 0
  let qubit_state_1 = 1
  
  // é‡å­å åŠ æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let superposition_coefficient = divide_with_ceil(multiply(qubit_state_0 + qubit_state_1, 100), 2)
  assert_eq(50, superposition_coefficient)  // ceil(1*100/2) = 50
  
  // é‡å­çº ç¼ æ¨¡æ‹Ÿ
  let entangled_pair_1 = 1
  let entangled_pair_2 = 0
  
  // æµ‹é‡æ“ä½œæ¨¡æ‹Ÿ
  let measurement_result = add(entangled_pair_1, entangled_pair_2)
  assert_eq(1, measurement_result)
  
  // é‡å­é—¨æ“ä½œæ¨¡æ‹Ÿ
  let hadamard_gate_input = 1
  let hadamard_gate_output = divide_with_ceil(hadamard_gate_input + 1, 2)
  assert_eq(1, hadamard_gate_output)  // ceil(2/2) = 1
  
  // é‡å­ç®—æ³•æ¨¡æ‹Ÿï¼ˆGroverç®—æ³•ç®€åŒ–ï¼‰
  let search_space_size = 1000
  let target_items = 1
  let oracle_calls = divide_with_ceil(multiply(search_space_size, target_items), 100)
  assert_eq(10, oracle_calls)  // ceil(1000/100) = 10
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - å¸¦å”¯ä¸€å‰ç¼€
test "new_add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "new_multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "new_greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "new_divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "new_complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "new_mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "new_resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "new_error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "new_string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "new_real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "boundary_condition_extreme_values_new" {
  // è¾¹ç•Œæ¡ä»¶æå€¼æµ‹è¯•
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(0, divide_with_ceil(-2147483647, 2147483646))
}

test "performance_large_scale_computations_new" {
  // å¤§è§„æ¨¡è¿ç®—æ€§èƒ½æµ‹è¯•
  let large_number = 100000
  let iterations = 10
  
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let sum_result = add(large_number, large_number)
  assert_eq(200000, sum_result)
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  let product_result = multiply(large_number, iterations)
  assert_eq(1000000, product_result)
  
  // æµ‹è¯•å¤§æ•°é™¤æ³•
  let division_result = divide_with_ceil(product_result, large_number)
  assert_eq(10, division_result)
}

test "error_handling_division_by_zero_new" {
  // é™¤é›¶é”™è¯¯å¤„ç†æµ‹è¯•
  assert_eq(0, divide_with_ceil(100, 0))  // æ­£æ•°é™¤é›¶
  assert_eq(0, divide_with_ceil(-100, 0))  // è´Ÿæ•°é™¤é›¶
  assert_eq(0, divide_with_ceil(0, 0))  // é›¶é™¤é›¶
  assert_eq(0, divide_with_ceil(2147483647, 0))  // æœ€å¤§å€¼é™¤é›¶
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // æœ€å°å€¼é™¤é›¶
}

test "internationalization_unicode_support_new" {
  // å›½é™…åŒ–Unicodeæ”¯æŒæµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
}

test "complex_business_logic_inventory_new" {
  // å¤æ‚ä¸šåŠ¡é€»è¾‘ï¼šåº“å­˜ç®¡ç†æµ‹è¯•
  let product_types = 5
  let average_quantity = 150
  let box_capacity = 24
  
  // è®¡ç®—æ€»åº“å­˜é‡
  let total_inventory = multiply(product_types, average_quantity)
  assert_eq(750, total_inventory)
  
  // è®¡ç®—éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_needed = divide_with_ceil(total_inventory, box_capacity)
  assert_eq(32, boxes_needed)  // ceil(750/24) = 32
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(768, total_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_inventory)
  assert_eq(18, remaining_space)
}

test "algorithm_complexity_analysis_new" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  let input_size = 1000
  
  // O(1) å¸¸æ•°æ—¶é—´æ“ä½œ
  let constant_time = add(5, 10)
  assert_eq(15, constant_time)
  
  // O(n) çº¿æ€§æ—¶é—´æ“ä½œæ¨¡æ‹Ÿ
  let linear_time = multiply(input_size, 2)
  assert_eq(2000, linear_time)
  
  // O(log n) å¯¹æ•°æ—¶é—´æ“ä½œæ¨¡æ‹Ÿ
  let logarithmic_time = divide_with_ceil(input_size, 100)
  assert_eq(10, logarithmic_time)
  
  // éªŒè¯å¤æ‚åº¦å…³ç³»
  let comparison1 = subtract(linear_time, logarithmic_time)
  let comparison2 = subtract(linear_time, constant_time)
  assert_eq(1990, comparison1)  // linear_time > logarithmic_time
  assert_eq(1985, comparison2)  // linear_time > constant_time
}

test "data_type_conversion_edge_cases_new" {
  // æ•°æ®ç±»å‹è½¬æ¢è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•é›¶å€¼è½¬æ¢
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, 12345))
  assert_eq(0, divide_with_ceil(0, 12345))
  
  // æµ‹è¯•å•ä½å€¼è½¬æ¢
  assert_eq(1, add(1, 0))
  assert_eq(1, multiply(1, 1))
  assert_eq(1, divide_with_ceil(1, 1))
  
  // æµ‹è¯•è´Ÿå€¼è½¬æ¢
  assert_eq(-1, add(0, -1))
  assert_eq(-1, multiply(-1, 1))
  assert_eq(-1, divide_with_ceil(-1, 1))
}

test "security_input_validation_new" {
  // å®‰å…¨æ€§è¾“å…¥éªŒè¯æµ‹è¯•
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, <script>!", greet("<script>"))
  assert_eq_string("Hello, SELECT * FROM!", greet("SELECT * FROM"))
  assert_eq_string("Hello, ../etc/passwd!", greet("../etc/passwd"))
  
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œå®‰å…¨
  assert_eq(0, divide_with_ceil(2147483647, 0))  // é˜²æ­¢æ•´æ•°æº¢å‡º
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // é˜²æ­¢æ•´æ•°ä¸‹æº¢
}

test "compatibility_backward_compatibility_new" {
  // å…¼å®¹æ€§å’Œå‘åå…¼å®¹æ€§æµ‹è¯•
  // æµ‹è¯•åŸºæœ¬è¿ç®—çš„å…¼å®¹æ€§
  assert_eq(10, add(3, 7))  // åŸºæœ¬åŠ æ³•å…¼å®¹æ€§
  assert_eq(21, multiply(3, 7))  // åŸºæœ¬ä¹˜æ³•å…¼å®¹æ€§
  assert_eq_string("Hello, World!", greet("World"))  // å­—ç¬¦ä¸²å¤„ç†å…¼å®¹æ€§
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µå…¼å®¹æ€§
  assert_eq(0, multiply(2147483647, 0))  // å¤§æ•°ä¸é›¶ç›¸ä¹˜
  assert_eq(2147483647, multiply(2147483647, 1))  // å¤§æ•°ä¸ä¸€ç›¸ä¹˜
  assert_eq(1, divide_with_ceil(2147483647, 2147483647))  // ç›¸ç­‰å¤§æ•°ç›¸é™¤
  
  // æµ‹è¯•è´Ÿæ•°å…¼å®¹æ€§
  assert_eq(-10, add(-3, -7))
  assert_eq(21, multiply(-3, -7))
  assert_eq(-4, divide_with_ceil(-10, 3))
}

test "real_world_financial_calculations_new" {
  // çœŸå®ä¸–ç•Œé‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 50000
  let monthly_payment = 2200
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(23, months_needed)  // ceil(50000/2200) = 23
  
  // è®¡ç®—æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(50600, total_payment)
  
  // è®¡ç®—æœ€åä¸€ä¸ªæœˆçš„å®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(total_payment, multiply(months_needed - 1, monthly_payment))
  assert_eq(200, final_payment)
  
  // åœºæ™¯ï¼šæŠ•èµ„å›æŠ¥è®¡ç®—
  let initial_investment = 10000
  let return_rate = 8  // 8%
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year1 = add(initial_investment, divide_with_ceil(multiply(initial_investment, return_rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, return_rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, return_rate), 100))
  let year4 = add(year3, divide_with_ceil(multiply(year3, return_rate), 100))
  let year5 = add(year4, divide_with_ceil(multiply(year4, return_rate), 100))
  
  // éªŒè¯æŠ•èµ„å¢é•¿
  assert_eq(10800, year1)  // 10000 + 8%
  assert_eq(11664, year2)  // 10800 + 8%
  assert_eq(12597, year3)  // 11664 + 8%
  assert_eq(13605, year4)  // 12597 + 8%
  assert_eq(14693, year5)  // 13605 + 8%
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸º azimuth åº“æ–°å¢çš„10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// åŒ…å«å®é™…åº”ç”¨åœºæ™¯ã€è¾¹ç•Œæƒ…å†µå’Œæ•°å­¦æ€§è´¨éªŒè¯

test "binary_conversion_calculation" {
  // äºŒè¿›åˆ¶è½¬æ¢è®¡ç®—æµ‹è¯•
  let binary_weight_1 = 1
  let binary_weight_2 = 2
  let binary_weight_3 = 4
  let binary_weight_4 = 8
  let binary_weight_5 = 16
  let binary_weight_6 = 32
  
  // éªŒè¯äºŒè¿›åˆ¶ä½æƒè®¡ç®—
  let total_weight = add(add(add(add(add(binary_weight_1, binary_weight_2), binary_weight_3), binary_weight_4), binary_weight_5), binary_weight_6)
  assert_eq(63, total_weight)
  
  // éªŒè¯ç‰¹å®šäºŒè¿›åˆ¶ç»„åˆ
  let binary_42 = add(add(binary_weight_2), add(binary_weight_4), add(binary_weight_5))  // 101010 = 2 + 8 + 32
  assert_eq(42, binary_42)
}

test "temperature_conversion" {
  // æ¸©åº¦è½¬æ¢è®¡ç®—æµ‹è¯•
  let celsius_temp = 25
  let fahrenheit_temp = 77
  
  // æ‘„æ°åº¦åˆ°åæ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šF = C * 9/5 + 32
  let converted_fahrenheit = add(divide_with_ceil(multiply(celsius_temp, 9), 5), 32)
  
  // åæ°åº¦åˆ°æ‘„æ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šC = (F - 32) * 5/9
  let converted_celsius = divide_with_ceil(multiply(add(fahrenheit_temp, -32), 5), 9)
  
  assert_eq(77, converted_fahrenheit)
  assert_eq(25, converted_celsius)
}

test "array_index_calculation" {
  // æ•°ç»„ç´¢å¼•è®¡ç®—æµ‹è¯•ï¼ˆæ¨¡æ‹ŸäºŒç»´æ•°ç»„çš„ä¸€ç»´ç´¢å¼•ï¼‰
  let rows = 4
  let cols = 5
  let row_index = 2
  let col_index = 3
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—ï¼šindex = row * cols + col
  let linear_index = add(multiply(row_index, cols), col_index)
  
  assert_eq(13, linear_index)
  
  // éªŒè¯è¾¹ç•Œæƒ…å†µ
  let first_element = add(multiply(0, cols), 0)
  let last_element = add(multiply(rows - 1, cols - 1), cols - 1)
  
  assert_eq(0, first_element)
  assert_eq(19, last_element)
}

test "prime_number_validation" {
  // è´¨æ•°éªŒè¯æµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let test_number = 17
  let divisor_2 = 2
  let divisor_3 = 3
  let divisor_5 = 5
  
  // æ£€æŸ¥æ˜¯å¦èƒ½è¢«å°è´¨æ•°æ•´é™¤
  let remainder_2 = test_number % divisor_2
  let remainder_3 = test_number % divisor_3
  let remainder_5 = test_number % divisor_5
  
  // éªŒè¯17ä¸èƒ½è¢«2ã€3ã€5æ•´é™¤
  assert_eq(1, remainder_2)
  assert_eq(2, remainder_3)
  assert_eq(2, remainder_5)
  
  // æµ‹è¯•åˆæ•°
  let composite_number = 15
  let composite_remainder_3 = composite_number % divisor_3
  let composite_remainder_5 = composite_number % divisor_5
  
  assert_eq(0, composite_remainder_3)
  assert_eq(0, composite_remainder_5)
}

test "loan_amortization" {
  // è´·æ¬¾åˆ†æœŸè®¡ç®—æµ‹è¯•
  let loan_amount = 10000
  let interest_rate = 5  // 5%
  let loan_term_years = 3
  let months_per_year = 12
  
  // è®¡ç®—æ€»æœˆæ•°
  let total_months = multiply(loan_term_years, months_per_year)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—ï¼ˆä¸åŒ…å«å¤åˆ©ï¼‰
  let total_interest = divide_with_ceil(multiply(loan_amount, interest_rate), 100)
  let total_payment = add(loan_amount, total_interest)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  
  assert_eq(36, total_months)
  assert_eq(500, total_interest)
  assert_eq(10500, total_payment)
  assert_eq(292, monthly_payment)
}

test "game_score_calculation" {
  // æ¸¸æˆå¾—åˆ†è®¡ç®—æµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let bonus_points = 500
  let penalty_points = 200
  
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let level_score = multiply(base_score, level_multiplier)
  let score_with_bonus = add(level_score, bonus_points)
  let final_score = add(score_with_bonus, -penalty_points)
  
  assert_eq(3000, level_score)
  assert_eq(3500, score_with_bonus)
  assert_eq(3300, final_score)
  
  // è®¡ç®—ç­‰çº§æå‡éœ€è¦çš„åˆ†æ•°
  let next_level_threshold = multiply(final_score, 2)
  let current_progress = divide_with_ceil(multiply(final_score, 100), next_level_threshold)
  
  assert_eq(6600, next_level_threshold)
  assert_eq(50, current_progress)
}

test "data_storage_optimization" {
  // æ•°æ®å­˜å‚¨ä¼˜åŒ–æµ‹è¯•
  let file_size_mb = 150
  let compression_ratio = 60  // å‹ç¼©åˆ°60%
  let storage_capacity_mb = 1000
  
  // è®¡ç®—å‹ç¼©åçš„æ–‡ä»¶å¤§å°
  let compressed_size = divide_with_ceil(multiply(file_size_mb, compression_ratio), 100)
  
  // è®¡ç®—å¯ä»¥å­˜å‚¨çš„å‹ç¼©æ–‡ä»¶æ•°é‡
  let files_that_fit = divide_with_ceil(storage_capacity_mb, compressed_size)
  
  // è®¡ç®—å‰©ä½™å­˜å‚¨ç©ºé—´
  let used_space = multiply(files_that_fit, compressed_size)
  let remaining_space = add(storage_capacity_mb, -used_space)
  
  assert_eq(90, compressed_size)
  assert_eq(12, files_that_fit)
  assert_eq(1080, used_space)
  assert_eq(-80, remaining_space)  // è¶…å‡ºå®¹é‡
}

test "network_packet_routing" {
  // ç½‘ç»œæ•°æ®åŒ…è·¯ç”±æµ‹è¯•
  let total_packets = 1000
  let route_1_capacity = 300
  let route_2_capacity = 400
  let route_3_capacity = 500
  
  // è®¡ç®—å„è·¯ç”±åˆ†é…çš„æ•°æ®åŒ…æ•°é‡
  let route_1_packets = divide_with_ceil(multiply(total_packets, route_1_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_2_packets = divide_with_ceil(multiply(total_packets, route_2_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_3_packets = divide_with_ceil(multiply(total_packets, route_3_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  
  // éªŒè¯æ€»åˆ†é…é‡
  let total_allocated = add(add(route_1_packets, route_2_packets), route_3_packets)
  
  assert_eq(250, route_1_packets)
  assert_eq(334, route_2_packets)
  assert_eq(417, route_3_packets)
  assert_eq(1001, total_allocated)  // ç”±äºå‘ä¸Šå–æ•´ï¼Œç•¥å¤šäºæ€»æ•°
}

test "cryptographic_hash_simulation" {
  // åŠ å¯†å“ˆå¸Œæ¨¡æ‹Ÿæµ‹è¯•
  let input_value = 12345
  let prime_1 = 31
  let prime_2 = 37
  let prime_3 = 41
  let modulo_value = 1000000
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè®¡ç®—ï¼šhash = ((input * p1) + p2) * p3 % mod
  let step1 = add(multiply(input_value, prime_1), prime_2)
  let step2 = multiply(step1, prime_3)
  let hash_result = step2 % modulo_value
  
  assert_eq(382816, add(multiply(12345, 31), 37))
  assert_eq(15695456, multiply(382816, 41))
  assert_eq(695456, hash_result)
  
  // éªŒè¯å“ˆå¸Œçš„ç¡®å®šæ€§ï¼ˆç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡ºï¼‰
  let hash_repeat = ((add(multiply(input_value, prime_1), prime_2)) * prime_3) % modulo_value
  assert_eq(hash_result, hash_repeat)
}

test "cpu_scheduling_simulation" {
  // CPUè°ƒåº¦æ¨¡æ‹Ÿæµ‹è¯•
  let process_1_time = 8
  let process_2_time = 12
  let process_3_time = 6
  let process_4_time = 10
  let time_quantum = 4
  
  // è®¡ç®—æ¯ä¸ªè¿›ç¨‹éœ€è¦çš„æ—¶é—´ç‰‡æ•°é‡
  let process_1_quanta = divide_with_ceil(process_1_time, time_quantum)
  let process_2_quanta = divide_with_ceil(process_2_time, time_quantum)
  let process_3_quanta = divide_with_ceil(process_3_time, time_quantum)
  let process_4_quanta = divide_with_ceil(process_4_time, time_quantum)
  
  // è®¡ç®—æ€»æ—¶é—´ç‰‡æ•°
  let total_quanta = add(add(add(process_1_quanta, process_2_quanta), process_3_quanta), process_4_quanta)
  
  // è®¡ç®—æ€»æ‰§è¡Œæ—¶é—´ï¼ˆè€ƒè™‘ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼‰
  let context_switch_overhead = 1
  let total_execution_time = add(multiply(total_quanta, time_quantum), multiply(total_quanta, context_switch_overhead))
  
  assert_eq(2, process_1_quanta)
  assert_eq(3, process_2_quanta)
  assert_eq(2, process_3_quanta)
  assert_eq(3, process_4_quanta)
  assert_eq(10, total_quanta)
  assert_eq(50, total_execution_time)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_distributive_law" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 7
  let b = 5
  let c = 3
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)  // 7 * (5 + 3) = 7 * 5 + 7 * 3 = 56
}

test "inventory_box_packing_optimization" {
  // åº“å­˜è£…ç®±ä¼˜åŒ–é—®é¢˜
  let item_a_count = 23
  let box_capacity_a = 6
  let boxes_a = divide_with_ceil(item_a_count, box_capacity_a)
  
  let item_b_count = 41
  let box_capacity_b = 8
  let boxes_b = divide_with_ceil(item_b_count, box_capacity_b)
  
  let item_c_count = 17
  let box_capacity_c = 5
  let boxes_c = divide_with_ceil(item_c_count, box_capacity_c)
  
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  let total_capacity = add(
    multiply(boxes_a, box_capacity_a),
    add(multiply(boxes_b, box_capacity_b), multiply(boxes_c, box_capacity_c))
  )
  let total_items = add(add(item_a_count, item_b_count), item_c_count)
  let wasted_space = subtract(total_capacity, total_items)
  
  assert_eq(4, boxes_a)  // ceil(23/6) = 4
  assert_eq(6, boxes_b)  // ceil(41/8) = 6
  assert_eq(4, boxes_c)  // ceil(17/5) = 4
  assert_eq(14, total_boxes)
  assert_eq(7, wasted_space)  // æ€»å®¹é‡88 - æ€»ç‰©å“81 = 7
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯ï¼šé¡¹ç›®æ’æœŸ
  let total_tasks = 127
  let team_members = 5
  let tasks_per_person_per_day = 3
  let work_days_per_week = 5
  
  let daily_capacity = multiply(team_members, tasks_per_person_per_day)
  let work_days_needed = divide_with_ceil(total_tasks, daily_capacity)
  let weeks_needed = divide_with_ceil(work_days_needed, work_days_per_week)
  
  assert_eq(15, daily_capacity)  // 5 * 3 = 15
  assert_eq(9, work_days_needed)  // ceil(127/15) = 9
  assert_eq(2, weeks_needed)     // ceil(9/5) = 2
}

test "string_edge_cases_comprehensive" {
  // å­—ç¬¦ä¸²è¾¹ç¼˜æƒ…å†µç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \n\n\n!", greet("\n\n\n"))
  assert_eq_string("Hello, \t\t\t!", greet("\t\t\t"))
  assert_eq_string("Hello, ğŸŒŸğŸŒ™â­!", greet("ğŸŒŸğŸŒ™â­"))
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—ï¼šç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—
  let n = 10
  let first_term = 3
  let common_difference = 2
  
  let arithmetic_sum = divide_with_ceil(
    multiply(n, add(multiply(2, first_term), multiply(n - 1, common_difference))),
    2
  )
  
  let geometric_sum = multiply(first_term, subtract(multiply(2, n), 1))
  
  assert_eq(120, arithmetic_sum)  // 10/2 * (6 + 18) = 120
  assert_eq(57, geometric_sum)   // 3 * (20 - 1) = 57
}

test "resource_allocation_simple" {
  // ç®€åŒ–çš„èµ„æºåˆ†é…é—®é¢˜
  let total_budget = 50000
  let departments = 4
  
  let avg_allocation = divide_with_ceil(total_budget, departments)
  let actual_total = multiply(avg_allocation, departments)
  let budget_deficit = subtract(actual_total, total_budget)
  
  assert_eq(12500, avg_allocation)  // ceil(50000/4) = 12500
  assert_eq(0, budget_deficit)      // 12500 * 4 - 50000 = 0
}

test "negative_number_division_precision" {
  // è´Ÿæ•°é™¤æ³•çš„ç²¾åº¦æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-7, 3))   // ceil(-2.33) = -2
  assert_eq(-2, divide_with_ceil(-8, 3))   // ceil(-2.67) = -2
  assert_eq(3, divide_with_ceil(-7, -3))   // ceil(2.33) = 3
  assert_eq(3, divide_with_ceil(-8, -3))   // ceil(2.67) = 3
  assert_eq(0, divide_with_ceil(-1, 2))    // ceil(-0.5) = 0
  assert_eq(0, divide_with_ceil(1, -2))    // ceil(-0.5) = 0
}

test "complex_business_workflow" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµæµ‹è¯•ï¼šç”µå•†è®¢å•å¤„ç†
  let order_items = 47
  let items_per_box = 8
  let boxes_per_pallet = 6
  let pallets_per_truck = 4
  
  let boxes_needed = divide_with_ceil(order_items, items_per_box)
  let pallets_needed = divide_with_ceil(boxes_needed, boxes_per_pallet)
  let trucks_needed = divide_with_ceil(pallets_needed, pallets_per_truck)
  
  let total_truck_capacity = multiply(trucks_needed, multiply(pallets_per_truck, boxes_per_pallet))
  let capacity_utilization = divide_with_ceil(
    multiply(multiply(boxes_needed, 100), total_truck_capacity),
    100
  )
  
  assert_eq(6, boxes_needed)      // ceil(47/8) = 6
  assert_eq(1, pallets_needed)    // ceil(6/6) = 1
  assert_eq(1, trucks_needed)     // ceil(1/4) = 1
  assert_eq(24, total_truck_capacity)  // 1 * 4 * 6 = 24
  assert_eq(25, capacity_utilization)  // ceil(6*100/24) = 25%
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "arithmetic_sequence_operations" {
  // ç­‰å·®æ•°åˆ—è¿ç®—æµ‹è¯•
  let first_term = 3
  let difference = 5
  let n_terms = 6
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—ç¬¬né¡¹ï¼ša_n = a_1 + (n-1)*d
  let nth_term = add(first_term, multiply(n_terms - 1, difference))
  assert_eq(28, nth_term)  // 3 + (6-1)*5 = 28
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼šS_n = n*(a_1 + a_n)/2
  let sum = divide_with_ceil(multiply(n_terms, add(first_term, nth_term)), 2)
  assert_eq(93, sum)  // 6*(3+28)/2 = 93
}

test "geometric_progression_calculations" {
  // ç­‰æ¯”æ•°åˆ—è®¡ç®—æµ‹è¯•
  let first_term = 2
  let ratio = 3
  let n_terms = 4
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—ç¬¬né¡¹ï¼ša_n = a_1 * r^(n-1)
  let nth_term = multiply(first_term, multiply(ratio, multiply(ratio, ratio)))
  assert_eq(54, nth_term)  // 2 * 3^3 = 54
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œçš„è¿‘ä¼¼å€¼
  let sum_approx = multiply(first_term, divide_with_ceil(multiply(ratio, n_terms), ratio - 1))
  assert_eq(24, sum_approx)  // è¿‘ä¼¼è®¡ç®—
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
}

test "resource_scheduling_optimization" {
  // èµ„æºè°ƒåº¦ä¼˜åŒ–æµ‹è¯•
  let total_tasks = 127
  let workers = 8
  let hours_per_day = 8
  let working_days = 5
  
  // è®¡ç®—æ¯ä¸ªå·¥äººçš„ä»»åŠ¡é‡
  let tasks_per_worker = divide_with_ceil(total_tasks, workers)
  assert_eq(16, tasks_per_worker)  // ceil(127/8) = 16
  
  // è®¡ç®—æ€»å·¥ä½œæ—¶é•¿
  let total_hours = multiply(tasks_per_worker, workers)
  assert_eq(128, total_hours)
  
  // è®¡ç®—éœ€è¦çš„å¤©æ•°
  let days_needed = divide_with_ceil(total_hours, hours_per_day)
  assert_eq(16, days_needed)  // ceil(128/8) = 16
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(days_needed, working_days)
  assert_eq(4, weeks_needed)  // ceil(16/5) = 4
}

test "mathematical_series_analysis" {
  // æ•°å­¦çº§æ•°åˆ†ææµ‹è¯•
  // æ¨¡æ‹Ÿè°ƒå’Œçº§æ•°çš„éƒ¨åˆ†å’Œè®¡ç®—
  
  // è®¡ç®— H_n = 1 + 1/2 + 1/3 + ... + 1/n çš„è¿‘ä¼¼å€¼
  // ä½¿ç”¨æ•´æ•°è¿ç®—æ¨¡æ‹Ÿ
  let term1 = divide_with_ceil(1000, 1)
  let term2 = divide_with_ceil(1000, 2)
  let term3 = divide_with_ceil(1000, 3)
  let term4 = divide_with_ceil(1000, 4)
  let term5 = divide_with_ceil(1000, 5)
  
  let partial_sum = add(add(add(add(term1, term2), add(term3, term4)), term5)
  assert_eq(2834, partial_sum)  // 1000 + 500 + 334 + 250 + 200 = 2283 (å‘ä¸Šå–æ•´)
}

test "inventory_management_system" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯•
  let product_a_qty = 45
  let product_b_qty = 67
  let product_c_qty = 23
  
  let box_capacity_a = 12
  let box_capacity_b = 15
  let box_capacity_c = 8
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_a = divide_with_ceil(product_a_qty, box_capacity_a)
  let boxes_b = divide_with_ceil(product_b_qty, box_capacity_b)
  let boxes_c = divide_with_ceil(product_c_qty, box_capacity_c)
  
  assert_eq(4, boxes_a)   // ceil(45/12) = 4
  assert_eq(5, boxes_b)   // ceil(67/15) = 5
  assert_eq(3, boxes_c)   // ceil(23/8) = 3
  
  // è®¡ç®—æ€»ç®±å­æ•°é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(12, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = add(
    multiply(boxes_a, box_capacity_a),
    add(multiply(boxes_b, box_capacity_b), multiply(boxes_c, box_capacity_c))
  )
  assert_eq(156, total_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let total_products = add(add(product_a_qty, product_b_qty), product_c_qty)
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(21, remaining_space)
}

test "financial_calculations" {
  // é‡‘èè®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 8  // 8%
  let years = 4
  
  // ç®€åŒ–çš„å¹´åº¦å¤åˆ©è®¡ç®—
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  let year4_end = add(year3_end, divide_with_ceil(multiply(year3_end, annual_rate), 100))
  
  // éªŒè¯æ¯å¹´çš„å¤åˆ©å¢é•¿
  assert_eq(10800, year1_end)  // 10000 + 8%
  assert_eq(11664, year2_end)  // 10800 + 8%
  assert_eq(12597, year3_end)  // 11664 + 8%
  assert_eq(13605, year4_end)  // 12597 + 8%
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_return = subtract(year4_end, principal)
  assert_eq(3605, total_return)
  
  // è®¡ç®—æœˆä¾›ï¼ˆ4å¹´=48ä¸ªæœˆï¼‰
  let monthly_payment = divide_with_ceil(year4_end, multiply(years, 12))
  assert_eq(284, monthly_payment)  // ceil(13605/48)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•çš„æ‰§è¡Œæ­¥éª¤
  let linear_100 = multiply(100, 3)
  let linear_1000 = multiply(1000, 3)
  let linear_10000 = multiply(10000, 3)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•çš„æ‰§è¡Œæ­¥éª¤ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let log_100 = divide_with_ceil(100, 10)
  let log_1000 = divide_with_ceil(1000, 10)
  let log_10000 = divide_with_ceil(10000, 10)
  
  // æ¨¡æ‹ŸO(nÂ²)ç®—æ³•çš„æ‰§è¡Œæ­¥éª¤ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let quadratic_100 = divide_with_ceil(multiply(100, 100), 100)
  let quadratic_1000 = divide_with_ceil(multiply(1000, 1000), 10000)
  let quadratic_10000 = divide_with_ceil(multiply(10000, 10000), 100000)
  
  // éªŒè¯ä¸åŒç®—æ³•çš„å¤æ‚åº¦ç‰¹å¾
  assert_eq(300, linear_100)
  assert_eq(3000, linear_1000)
  assert_eq(30000, linear_10000)
  
  assert_eq(10, log_100)
  assert_eq(100, log_1000)
  assert_eq(1000, log_10000)
  
  assert_eq(100, quadratic_100)
  assert_eq(100, quadratic_1000)
  assert_eq(1000, quadratic_10000)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_initial_size = 0
  let push_operations = 5
  let pop_operations = 3
  
  let stack_after_push = add(stack_initial_size, push_operations)
  let stack_after_pop = subtract(stack_after_push, pop_operations)
  
  assert_eq(5, stack_after_push)
  assert_eq(2, stack_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 20
  let queue_enqueued = 15
  let queue_dequeued = 8
  
  let queue_current_size = subtract(queue_enqueued, queue_dequeued)
  let queue_remaining_capacity = subtract(queue_capacity, queue_current_size)
  
  assert_eq(7, queue_current_size)
  assert_eq(13, queue_remaining_capacity)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨è´Ÿè½½å› å­è®¡ç®—
  let hash_table_size = 16
  let occupied_slots = 11
  let load_factor = divide_with_ceil(multiply(occupied_slots, 100), hash_table_size)
  
  assert_eq(69, load_factor)  // ceil(11*100/16) = 69%
}

test "business_workflow_simulation" {
  // ä¸šåŠ¡å·¥ä½œæµæ¨¡æ‹Ÿæµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ
  
  // è®¢å•åŸºæœ¬ä¿¡æ¯
  let order_items = 47
  let items_per_box = 8
  let processing_time_per_box = 15  // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let boxes_needed = divide_with_ceil(order_items, items_per_box)
  assert_eq(6, boxes_needed)  // ceil(47/8) = 6
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_processing_time = multiply(boxes_needed, processing_time_per_box)
  assert_eq(90, total_processing_time)  // 6 * 15 = 90åˆ†é’Ÿ
  
  // è®¡ç®—å·¥ä½œå°æ—¶æ•°
  let processing_hours = divide_with_ceil(total_processing_time, 60)
  assert_eq(2, processing_hours)  // ceil(90/60) = 2å°æ—¶
  
  // è®¡ç®—é…é€æˆæœ¬
  let base_shipping_cost = 50
  let cost_per_box = 12
  let total_shipping_cost = add(base_shipping_cost, multiply(boxes_needed, cost_per_box))
  assert_eq(122, total_shipping_cost)  // 50 + 6*12 = 122
  
  // è®¡ç®—æ€»è®¢å•ä»·å€¼ï¼ˆå‡è®¾æ¯ä¸ªç‰©å“å¹³å‡ä»·å€¼25ï¼‰
  let average_item_value = 25
  let total_order_value = multiply(order_items, average_item_value)
  assert_eq(1175, total_order_value)  // 47 * 25 = 1175
  
  // è®¡ç®—é…é€æˆæœ¬å æ¯”
  let shipping_cost_percentage = divide_with_ceil(multiply(total_shipping_cost, 100), total_order_value)
  assert_eq(11, shipping_cost_percentage)  // ceil(122*100/1175) = 11%
}

// Azimuth é«˜è´¨é‡æµ‹è¯•å¥—ä»¶ - æ–°å¢8ä¸ªç²¾å¿ƒè®¾è®¡çš„æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive_coverage" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°çš„å„ç§åœºæ™¯
  assert_eq(8, add(3, 5))              // åŸºæœ¬æ­£æ•°åŠ æ³•
  assert_eq(0, add(0, 0))              // é›¶å€¼åŠ æ³•
  assert_eq(-8, add(-3, -5))           // è´Ÿæ•°åŠ æ³•
  assert_eq(2, add(-3, 5))             // æ··åˆç¬¦å·åŠ æ³•
  assert_eq(1000000, add(500000, 500000))  // å¤§æ•°åŠ æ³•
}

test "multiply_function_mathematical_properties" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„æ•°å­¦æ€§è´¨
  assert_eq(15, multiply(3, 5))         // åŸºæœ¬æ­£æ•°ä¹˜æ³•
  assert_eq(0, multiply(5, 0))          // é›¶ä¹˜æ³•ç‰¹æ€§
  assert_eq(-15, multiply(-3, 5))       // è´Ÿæ•°ä¹˜æ³•
  assert_eq(15, multiply(-3, -5))       // è´Ÿè´Ÿå¾—æ­£
  assert_eq(5, multiply(5, 1))          // å•ä½å…ƒç‰¹æ€§
}

test "greet_function_internationalization_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…åŒ–æ”¯æŒ
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, !", greet(""))  // ç©ºå­—ç¬¦ä¸²å¤„ç†
}

test "divide_with_ceil_business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—åœºæ™¯æµ‹è¯•
  let products = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(products, box_capacity)
  
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡è®¡ç®—
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, products)
  assert_eq(1, remaining_space)
}

test "complex_calculation_pipeline_project_management" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿ï¼šé¡¹ç›®ç®¡ç†åœºæ™¯
  let team_members = 5
  let tasks_per_member = 8
  let working_days = 6
  let tasks_per_day = divide_with_ceil(
    multiply(team_members, tasks_per_member), 
    working_days
  )
  
  assert_eq(7, tasks_per_day)  // ceil(40/6) = 7
  
  // éªŒè¯æ€»ä»»åŠ¡å®Œæˆèƒ½åŠ›
  let total_capacity = multiply(tasks_per_day, working_days)
  assert_eq(42, total_capacity)
}

test "mathematical_laws_verification" {
  // æ•°å­¦å®šå¾‹éªŒè¯æµ‹è¯•
  let x = 12
  let y = 7
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹éªŒè¯
  let distributive_left = multiply(x, add(y, 3))
  let distributive_right = add(multiply(x, y), multiply(x, 3))
  assert_eq(distributive_left, distributive_right)
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(-1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 100))
}

test "real_world_scenario_event_planning" {
  // çœŸå®ä¸–ç•Œåœºæ™¯ï¼šæ´»åŠ¨è§„åˆ’æµ‹è¯•
  let participants = 87
  let tables_available = 10
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // éªŒè¯æ¡Œå­æ˜¯å¦è¶³å¤Ÿ
  let total_seats_available = multiply(tables_available, chairs_per_table)
  assert_eq(80, total_seats_available)
  
  // è®¡ç®—ç¼ºå°‘çš„åº§ä½æ•°
  let seats_shortage = subtract(participants, total_seats_available)
  assert_eq(7, seats_shortage)
}

// æ–°å¢çš„9ä¸ªæµ‹è¯•ç”¨ä¾‹
test "advanced_arithmetic_sequences" {
  // æµ‹è¯•é«˜çº§ç®—æœ¯åºåˆ—
  let start = 5
  let sequence_sum = add(add(add(start, 1), add(start, 2)), add(start, 3))
  assert_eq(20, sequence_sum)  // 6 + 7 + 8 = 21
}

test "complex_string_processing" {
  // æµ‹è¯•å¤æ‚å­—ç¬¦ä¸²å¤„ç†
  let name1 = "Alice"
  let name2 = "Bob"
  let greeting1 = greet(name1)
  let greeting2 = greet(name2)
  assert_eq_string("Hello, Alice!", greeting1)
  assert_eq_string("Hello, Bob!", greeting2)
}

test "resource_planning_scenario" {
  // èµ„æºè§„åˆ’åœºæ™¯æµ‹è¯•
  let project_days = 15
  let team_size = 6
  let daily_hours = 8
  let total_hours = multiply(project_days, multiply(team_size, daily_hours))
  assert_eq(720, total_hours)  // 15 * 6 * 8 = 720
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  let n = 5
  let sum_of_first_n = multiply(n, add(n, 1)) / 2
  assert_eq(15, sum_of_first_n)  // 5 * 6 / 2 = 15
}

test "inventory_optimization" {
  // åº“å­˜ä¼˜åŒ–æµ‹è¯•
  let items_per_box = 12
  let total_items = 47
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  let total_capacity = multiply(boxes_needed, items_per_box)
  let wasted_space = subtract(total_capacity, total_items)
  assert_eq(5, boxes_needed)
  assert_eq(60, total_capacity)
  assert_eq(13, wasted_space)
}

test "financial_projection" {
  // è´¢åŠ¡é¢„æµ‹æµ‹è¯•
  let initial_investment = 10000
  let monthly_return = 500
  let months = 24
  let total_return = multiply(monthly_return, months)
  let final_amount = add(initial_investment, total_return)
  assert_eq(12000, total_return)
  assert_eq(22000, final_amount)
}

test "time_management_calculation" {
  // æ—¶é—´ç®¡ç†è®¡ç®—æµ‹è¯•
  let tasks = 25
  let hours_per_task = 2
  let working_hours_per_day = 8
  let total_hours_needed = multiply(tasks, hours_per_task)
  let days_needed = divide_with_ceil(total_hours_needed, working_hours_per_day)
  assert_eq(50, total_hours_needed)
  assert_eq(7, days_needed)
}

test "space_planning_scenario" {
  // ç©ºé—´è§„åˆ’åœºæ™¯æµ‹è¯•
  let room_area = 100
  let desk_area = 8
  let desks_per_room = divide_with_ceil(room_area, desk_area)
  let total_desk_area = multiply(desks_per_room, desk_area)
  let remaining_space = subtract(room_area, total_desk_area)
  assert_eq(13, desks_per_room)
  assert_eq(104, total_desk_area)
  assert_true(remaining_space < 0)  // ç©ºé—´ä¸è¶³
}

test "performance_metrics" {
  // æ€§èƒ½æŒ‡æ ‡æµ‹è¯•
  let baseline = 100
  let improvement1 = 15
  let improvement2 = 25
  let final_performance = add(add(baseline, improvement1), improvement2)
  let improvement_percentage = divide_with_ceil(multiply(final_performance, 100), baseline) - 100
  assert_eq(140, final_performance)
  assert_eq(40, improvement_percentage)
}

// æ–°å¢çš„é«˜çº§ MoonBit æµ‹è¯•ç”¨ä¾‹ - 8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_conditions" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæ¡ä»¶
  // æ¥è¿‘ Int æœ€å¤§å€¼å’Œæœ€å°å€¼çš„è¿ç®—
  assert_eq(2147483646, add(2147483645, 1))
  assert_eq(-2147483647, add(-2147483646, -1))
  assert_eq(2147483646, multiply(46340, 46341))  // æ¥è¿‘ sqrt(Int.max)
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(0, divide_with_ceil(-2147483647, 2147483646))
}

test "financial_calculations" {
  // é‡‘èè®¡ç®—åœºæ™¯æµ‹è¯•
  // è´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 250000
  let monthly_payment = 8500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(30, months_needed)  // ceil(250000/8500) = 30
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(255000, total_payment)
  
  // è®¡ç®—æœ€åä¸€æœŸå®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(loan_amount, multiply(months_needed - 1, monthly_payment))
  assert_eq(5000, final_payment)
}

test "complex_nested_operations" {
  // å¤æ‚åµŒå¥—è¿ç®—æµ‹è¯•
  let base = 15
  
  // åµŒå¥—è®¡ç®—ï¼šceil((base*3 + base*2) / (base + ceil(base/3)))
  let numerator = add(multiply(base, 3), multiply(base, 2))
  let denominator = add(base, divide_with_ceil(base, 3))
  let result = divide_with_ceil(numerator, denominator)
  
  // æ‰‹åŠ¨éªŒè¯ï¼šceil((45+30)/(15+5)) = ceil(75/20) = 4
  assert_eq(4, result)
}

test "resource_optimization_problem" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // ä»“åº“å­˜å‚¨ä¼˜åŒ–ï¼šå¤šç§ç‰©å“çš„è£…ç®±é—®é¢˜
  let item1_qty = 47
  let item1_cap = 8   // ceil(47/8) = 6
  let item2_qty = 89
  let item2_cap = 12  // ceil(89/12) = 8
  let item3_qty = 156
  let item3_cap = 20 // ceil(156/20) = 8
  
  let boxes1 = divide_with_ceil(item1_qty, item1_cap)
  let boxes2 = divide_with_ceil(item2_qty, item2_cap)
  let boxes3 = divide_with_ceil(item3_qty, item3_cap)
  
  let total_boxes = add(add(boxes1, boxes2), boxes3)
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å®¹é‡å’Œåˆ©ç”¨ç‡
  let total_capacity = add(
    multiply(boxes1, item1_cap),
    add(multiply(boxes2, item2_cap), multiply(boxes3, item3_cap))
  )
  let total_items = add(add(item1_qty, item2_qty), item3_qty)
  let utilization = divide_with_ceil(multiply(total_items, 100), total_capacity)
  
  assert_eq(292, total_capacity)  // 48 + 96 + 160
  assert_eq(92, utilization)      // floor(29200/292) = 100%ï¼Œä½†ä½¿ç”¨ceil
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’Œç¼–ç 
  assert_eq_string("Hello, ğŸŒ™â­âœ¨!", greet("ğŸŒ™â­âœ¨"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, 'single'!", greet("'single'"))
  assert_eq_string("Hello, \\backslash!", greet("\\backslash"))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, emoji ğŸ‰ğŸš€ğŸŒŸ!", greet("emoji ğŸ‰ğŸš€ğŸŒŸ"))
  assert_eq_string("Hello, ä¸­æ–‡å­—ç¬¦!", greet("ä¸­æ–‡å­—ç¬¦"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "performance_large_scale_computations" {
  // å¤§è§„æ¨¡è®¡ç®—æ€§èƒ½æµ‹è¯•
  let large_num = 100000
  let iterations = 1000
  
  // å¤§æ•°è¿ç®—
  let sum_result = add(large_num, multiply(large_num, 9))
  let product_result = multiply(large_num, iterations)
  let division_result = divide_with_ceil(product_result, large_num)
  
  assert_eq(1000000, sum_result)      // 100000 + 100000*9
  assert_eq(100000000, product_result) // 100000 * 1000
  assert_eq(1000, division_result)     // ceil(100000000/100000)
  
  // è¿ç»­è¿ç®—é“¾
  let chain_result = divide_with_ceil(
    multiply(
      add(large_num, 50000),
      divide_with_ceil(iterations, 100)
    ),
    add(100, divide_with_ceil(large_num, 10000))
  )
  assert_eq(7500, chain_result)
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // å„ç§é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå°é™¤æ•°æµ‹è¯•
  assert_eq(100000, divide_with_ceil(99999, 1))
  assert_eq(-99999, divide_with_ceil(-99999, 1))
  assert_eq(50000, divide_with_ceil(99999, 2))
  
  // è¾¹ç•Œå€¼ç»„åˆ
  assert_eq(1, divide_with_ceil(1, 2147483647))
  assert_eq(0, divide_with_ceil(-1, 2147483647))
  assert_eq(-1, divide_with_ceil(1, -2147483647))
}

test "real_world_scheduling_problem" {
  // çœŸå®ä¸–ç•Œè°ƒåº¦é—®é¢˜æµ‹è¯•
  // æ´»åŠ¨å®‰æ’ï¼šä¼šè®®å®¤åˆ†é…
  let total_participants = 342
  
  // è®¡ç®—æ¯ç§ä¼šè®®å®¤éœ€è¦çš„æ•°é‡
  let rooms_50 = divide_with_ceil(total_participants, 50)
  let rooms_30 = divide_with_ceil(total_participants, 30)
  let rooms_20 = divide_with_ceil(total_participants, 20)
  let rooms_15 = divide_with_ceil(total_participants, 15)
  let rooms_10 = divide_with_ceil(total_participants, 10)
  
  assert_eq(7, rooms_50)   // ceil(342/50) = 7
  assert_eq(12, rooms_30)  // ceil(342/30) = 12
  assert_eq(18, rooms_20)  // ceil(342/20) = 18
  assert_eq(23, rooms_15)  // ceil(342/15) = 23
  assert_eq(35, rooms_10)  // ceil(342/10) = 35
  
  // è®¡ç®—æœ€ä¼˜æ–¹æ¡ˆï¼ˆä½¿ç”¨50äººä¼šè®®å®¤ï¼‰
  let total_capacity_50 = multiply(rooms_50, 50)
  let wasted_seats_50 = subtract(total_capacity_50, total_participants)
  let efficiency_50 = divide_with_ceil(multiply(total_participants, 100), total_capacity_50)
  
  assert_eq(350, total_capacity_50)  // 7 * 50
  assert_eq(8, wasted_seats_50)      // 350 - 342
  assert_eq(98, efficiency_50)       // ceil(34200/350)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_basic_arithmetic" {
  // æµ‹è¯•åŸºæœ¬ç®—æœ¯è¿ç®—
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_logistics_scenario" {
  // çœŸå®ä¸–ç•Œç‰©æµåœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—ä»“åº“å­˜å‚¨éœ€æ±‚
  let products = 157
  let pallet_capacity = 24
  let pallets_needed = divide_with_ceil(products, pallet_capacity)
  assert_eq(7, pallets_needed)  // ceil(157/24) = 7
  
  // è®¡ç®—æ€»å­˜å‚¨ç©ºé—´
  let total_space = multiply(pallets_needed, pallet_capacity)
  assert_eq(168, total_space)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_space, products)
  assert_eq(11, remaining_space)
}




// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(15, add(7, 8))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-3, -7))
  assert_eq(4, add(-5, 9))
}

test "multiplication_properties" {
  // ä¹˜æ³•æ€§è´¨æµ‹è¯•
  assert_eq(21, multiply(3, 7))
  assert_eq(0, multiply(5, 0))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(12, multiply(-3, -4))
  assert_eq(100, multiply(10, 10))
}

test "greet_function_variations" {
  // é—®å€™å‡½æ•°å˜åŒ–æµ‹è¯•
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "divide_with_ceil_scenarios" {
  // å‘ä¸Šå–æ•´é™¤æ³•åœºæ™¯æµ‹è¯•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(2, 2))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(10, 0))
}

test "negative_number_operations" {
  // è´Ÿæ•°è¿ç®—æµ‹è¯•
  assert_eq(-5, add(-2, -3))
  assert_eq(2, add(-5, 7))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(-3, 5))
  assert_eq(-2, divide_with_ceil(-5, 3))
}

test "complex_calculation_chain" {
  // å¤æ‚è®¡ç®—é“¾æµ‹è¯•
  let result = divide_with_ceil(add(multiply(3, 4), multiply(2, 5)), 7)
  assert_eq(4, result)  // ceil((12 + 10) / 7) = ceil(22/7) = 4
}

test "business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—æµ‹è¯•
  let items = 25
  let box_capacity = 6
  let boxes_needed = divide_with_ceil(items, box_capacity)
  assert_eq(5, boxes_needed)
  
  let total_capacity = multiply(boxes_needed, box_capacity)
  let remaining_space = subtract(total_capacity, items)
  assert_eq(5, remaining_space)
}

test "mathematical_commutative_law" {
  // æ•°å­¦äº¤æ¢å¾‹æµ‹è¯•
  let a = 13
  let b = 17
  assert_eq(add(a, b), add(b, a))
  assert_eq(multiply(a, b), multiply(b, a))
}

test "resource_allocation_problem" {
  // èµ„æºåˆ†é…é—®é¢˜æµ‹è¯•
  let total_resources = 47
  let teams = 4
  let resources_per_team = divide_with_ceil(total_resources, teams)
  assert_eq(12, resources_per_team)
  
  let total_allocated = multiply(resources_per_team, teams)
  assert_eq(48, total_allocated)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, space!", greet("space"))
  assert_eq_string("Hello, special@chars!", greet("special@chars"))
  assert_eq_string("Hello, emoji ğŸŒŸ!", greet("emoji ğŸŒŸ"))
  assert_eq_string("Hello, mixedCASE123!", greet("mixedCASE123"))
}

// æ–°å¢çš„ç‹¬ç‰¹æµ‹è¯•ç”¨ä¾‹
test "unique_azimuth_test_12345" {
  assert_eq(7, add(3, 4))
  assert_eq(6, multiply(2, 3))
  assert_eq_string("Hello, Test!", greet("Test"))
}

// æ–°å¢çš„8ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "arithmetic_operations_comprehensive" {
  // ç»¼åˆç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(40, add(15, 25))
  assert_eq(-5, add(-10, 5))
  assert_eq(42, multiply(6, 7))
  assert_eq(-12, multiply(-4, 3))
  assert_eq(4, divide_with_ceil(20, 6))
  assert_eq(5, divide_with_ceil(25, 5))
}

test "string_handling_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_identities" {
  // æ•°å­¦æ’ç­‰å¼æµ‹è¯•
  let x = 17
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(-x, multiply(x, -1))
}

test "business_logic_inventory" {
  // åº“å­˜ç®¡ç†ä¸šåŠ¡é€»è¾‘æµ‹è¯•
  let total_products = 158
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  assert_eq(7, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  assert_eq(168, multiply(boxes_needed, box_capacity))
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  assert_eq(10, subtract(multiply(boxes_needed, box_capacity), total_products))
}

test "error_handling_scenarios" {
  // é”™è¯¯å¤„ç†åœºæ™¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "complex_calculation_workflow" {
  // å¤æ‚è®¡ç®—å·¥ä½œæµæµ‹è¯•
  // åœºæ™¯ï¼šé¡¹ç›®æˆæœ¬è®¡ç®—
  let team_size = 5
  let hourly_rate = 75
  let hours_per_day = 8
  let project_days = 12
  
  // è®¡ç®—æ€»å·¥æ—¶
  let total_hours = multiply(team_size, multiply(hours_per_day, project_days))
  assert_eq(480, total_hours)
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = multiply(total_hours, hourly_rate)
  assert_eq(36000, total_cost)
  
  // è®¡ç®—æ”¯ä»˜å‘¨æœŸï¼ˆæ¯å‘¨æœŸä¸è¶…è¿‡10000ï¼‰
  let payment_cycles = divide_with_ceil(total_cost, 10000)
  assert_eq(4, payment_cycles)
}

test "algorithm_efficiency_comparison" {
  // ç®—æ³•æ•ˆç‡æ¯”è¾ƒæµ‹è¯•
  let input_size = 1000
  
  // çº¿æ€§ç®—æ³•æ¨¡æ‹Ÿ
  let linear_steps = multiply(input_size, 3)
  assert_eq(3000, linear_steps)
  
  // å¯¹æ•°ç®—æ³•æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let log_steps = divide_with_ceil(input_size, 100)
  assert_eq(10, log_steps)
  
  // éªŒè¯æ•ˆç‡å·®å¼‚
  assert_eq(300, divide_with_ceil(linear_steps, log_steps))
}

test "resource_optimization_problem" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory = 32768  // GB
  let servers = 7
  let memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(4682, memory_per_server)
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, servers)
  assert_eq(32774, total_allocated)
  
  // è®¡ç®—å†…å­˜æµªè´¹
  assert_eq(6, subtract(total_allocated, total_memory))
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥
  let optimized_servers = servers + 1
  let optimized_memory_per_server = divide_with_ceil(total_memory, optimized_servers)
  assert_eq(4097, optimized_memory_per_server)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "financial_calculation_basic" {
  // åŸºæœ¬é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate = 5  // 5%
  
  // ç®€å•çš„å¤åˆ©è®¡ç®—
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate), 100))
  
  assert_eq(10500, year1)  // 10000 + 5%
  assert_eq(11025, year2)  // 10500 + 5%
  assert_eq(11576, year3)  // 11025 + 5%
}

test "inventory_packaging_optimization" {
  // åº“å­˜åŒ…è£…ä¼˜åŒ–æµ‹è¯•
  let items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(items, box_capacity)
  
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, items)
  assert_eq(1, remaining_space)
}

test "resource_allocation_scenario" {
  // èµ„æºåˆ†é…åœºæ™¯æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  let budget_per_person = divide_with_ceil(total_budget, team_members)
  
  assert_eq(1667, budget_per_person)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…
  let total_allocated = multiply(budget_per_person, team_members)
  assert_eq(10002, total_allocated)
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 10
  let multiplier = 3
  let divisor = 4
  
  // è®¡ç®—æµç¨‹ï¼š((base * multiplier) / divisor)
  let step1 = multiply(base_value, multiplier)
  let step2 = divide_with_ceil(step1, divisor)
  
  assert_eq(30, step1)  // 10 * 3 = 30
  assert_eq(8, step2)   // ceil(30/4) = 8
}

test "mathematical_properties_verification" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 15
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹éªŒè¯
  let distributive_left = multiply(x, add(y, 2))
  let distributive_right = add(multiply(x, y), multiply(x, 2))
  assert_eq(distributive_left, distributive_right)
}

test "error_handling_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(1, divide_with_ceil(100, 100))
}

test "string_processing_international" {
  // å­—ç¬¦ä¸²å¤„ç†å›½é™…åŒ–æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, empty!", greet(""))
}

test "business_logic_integration" {
  // ä¸šåŠ¡é€»è¾‘é›†æˆæµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•è®¡ç®—
  let items_count = 25
  let item_price = 199
  let shipping_per_box = 50
  let items_per_box = 10
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(items_count, item_price)
  
  // è®¡ç®—éœ€è¦çš„ç®±æ•°
  let boxes_needed = divide_with_ceil(items_count, items_per_box)
  
  // è®¡ç®—è¿è´¹
  let shipping_cost = multiply(boxes_needed, shipping_per_box)
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = add(subtotal, shipping_cost)
  
  assert_eq(4975, subtotal)      // 25 * 199 = 4975
  assert_eq(3, boxes_needed)     // ceil(25/10) = 3
  assert_eq(150, shipping_cost)  // 3 * 50 = 150
  assert_eq(5125, total_cost)    // 4975 + 150 = 5125
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "extreme_numerical_values" {
  // æµ‹è¯•æç«¯æ•°å€¼å¤„ç†
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(0, divide_with_ceil(-2147483647, 2147483647))
}

test "nested_function_calls" {
  // æµ‹è¯•åµŒå¥—å‡½æ•°è°ƒç”¨
  let result = divide_with_ceil(
    add(multiply(5, 3), multiply(2, 4)),
    subtract(10, 2)
  )
  assert_eq(3, result)  // ceil((5*3 + 2*4) / (10-2)) = ceil(23/8) = 3
}

test "error_recovery_scenarios" {
  // æµ‹è¯•é”™è¯¯æ¢å¤åœºæ™¯
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(-100, 0))  // è´Ÿæ•°é™¤é›¶é”™è¯¯å¤„ç†
  
  // é”™è¯¯æ¢å¤åçš„è¿ç»­è®¡ç®—
  let safe_result = add(divide_with_ceil(10, 0), multiply(5, 2))
  assert_eq(10, safe_result)  // 0 + 10 = 10
}

test "performance_related_operations" {
  // æµ‹è¯•æ€§èƒ½ç›¸å…³æ“ä½œ
  let large_number = 100000
  let iterations = 100
  
  // æ‰¹é‡æ“ä½œæ€§èƒ½æµ‹è¯•
  let batch_sum = add(large_number, multiply(large_number, iterations))
  assert_eq(10100000, batch_sum)  // 100000 + 100000*100 = 10100000
  
  // åˆ†æ‰¹å¤„ç†æµ‹è¯•
  let batch_size = 1000
  let total_items = 10500
  let batches_needed = divide_with_ceil(total_items, batch_size)
  assert_eq(11, batches_needed)  // ceil(10500/1000) = 11
}

test "data_type_compatibility" {
  // æµ‹è¯•æ•°æ®ç±»å‹å…¼å®¹æ€§
  // æµ‹è¯•æ•´æ•°è¾¹ç•Œ
  assert_eq(0, add(2147483647, -2147483647))
  assert_eq(-1, add(-2147483648, 2147483647))
  
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºè¾¹ç•Œ
  assert_eq(46340, multiply(46340, 1))  // sqrt(2^31-1)çš„æ•´æ•°éƒ¨åˆ†
  assert_eq(0, multiply(46340, 0))
  
  // æµ‹è¯•é™¤æ³•ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(100, divide_with_ceil(199, 2))
}

test "business_inventory_management" {
  // ä¸šåŠ¡åœºæ™¯ï¼šåº“å­˜ç®¡ç†æµ‹è¯•
  let product_a_qty = 156
  let product_b_qty = 89
  let product_c_qty = 234
  let box_capacity = 25
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_a = divide_with_ceil(product_a_qty, box_capacity)  // ceil(156/25) = 7
  let boxes_b = divide_with_ceil(product_b_qty, box_capacity)  // ceil(89/25) = 4
  let boxes_c = divide_with_ceil(product_c_qty, box_capacity)  // ceil(234/25) = 10
  
  // è®¡ç®—æ€»ç®±å­æ•°é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(21, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = multiply(total_boxes, box_capacity)
  assert_eq(525, total_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let total_products = add(add(product_a_qty, product_b_qty), product_c_qty)
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(46, remaining_space)
}

test "algorithm_efficiency_comparison" {
  // ç®—æ³•æ•ˆç‡æ¯”è¾ƒæµ‹è¯•
  let input_size = 1000
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_time = multiply(input_size, 5)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºå‘ä¸Šå–æ•´ï¼‰
  let log_time = divide_with_ceil(input_size, 10)
  
  // æ¨¡æ‹ŸO(n^2)ç®—æ³•
  let quadratic_time = multiply(input_size, input_size)
  
  // éªŒè¯ç®—æ³•å¤æ‚åº¦ç‰¹å¾
  assert_eq(5000, linear_time)
  assert_eq(100, log_time)
  assert_eq(1000000, quadratic_time)
  
  // è®¡ç®—æ•ˆç‡æ¯”ç‡
  let linear_to_log_ratio = divide_with_ceil(linear_time, log_time)
  assert_eq(50, linear_to_log_ratio)
}

test "advanced_string_operations" {
  // é«˜çº§å­—ç¬¦ä¸²æ“ä½œæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, JSON!", greet("JSON"))
  assert_eq_string("Hello, XML!", greet("XML"))
  assert_eq_string("Hello, HTTP!", greet("HTTP"))
  assert_eq_string("Hello, API!", greet("API"))
  assert_eq_string("Hello, SQL!", greet("SQL"))
  
  // æµ‹è¯•æ•°å­—å’Œå­—æ¯æ··åˆ
  assert_eq_string("Hello, v1.0!", greet("v1.0"))
  assert_eq_string("Hello, 2023!", greet("2023"))
  assert_eq_string("Hello, A1B2C3!", greet("A1B2C3"))
}

test "mathematical_theorems_validation" {
  // æ•°å­¦å®šç†éªŒè¯æµ‹è¯•
  // éªŒè¯å‹¾è‚¡å®šç†ï¼ˆ3-4-5ä¸‰è§’å½¢ï¼‰
  let a = 3
  let b = 4
  let c = 5
  let a_squared = multiply(a, a)
  let b_squared = multiply(b, b)
  let c_squared = multiply(c, c)
  let pythagorean_sum = add(a_squared, b_squared)
  assert_eq(pythagorean_sum, c_squared)  // 3^2 + 4^2 = 5^2
  
  // éªŒè¯ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼
  let first_term = 1
  let last_term = 100
  let number_of_terms = 100
  let arithmetic_sum = divide_with_ceil(
    multiply(number_of_terms, add(first_term, last_term)),
    2
  )
  assert_eq(5050, arithmetic_sum)  // 100*(1+100)/2 = 5050
}

test "real_world_financial_calculation" {
  // çœŸå®ä¸–ç•Œé‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè´·æ¬¾è®¡ç®—å’ŒæŠ•èµ„å›æŠ¥
  let principal = 50000
  let annual_rate = 6  // 6%
  let years = 5
  
  // è®¡ç®—ç®€å•åˆ©æ¯
  let simple_interest = divide_with_ceil(multiply(principal, annual_rate), 100)
  let yearly_interest = simple_interest
  let total_interest = multiply(yearly_interest, years)
  let total_payment = add(principal, total_interest)
  
  assert_eq(3000, yearly_interest)  // 50000 * 6% = 3000
  assert_eq(15000, total_interest)  // 3000 * 5 = 15000
  assert_eq(65000, total_payment)  // 50000 + 15000 = 65000
  
  // è®¡ç®—æœˆä¾›
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  assert_eq(1084, monthly_payment)  // ceil(65000/60) = 1084
}


