// ç®€åŒ–çš„ azimuth åº“æ–‡ä»¶
pub fn add(a : Int, b : Int) -> Int {
  a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  a * b
}

pub fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

pub fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

pub fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// æ–­è¨€å‡½æ•°
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  ()
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  ()
}

pub fn assert_true(condition : Bool) -> Unit {
  ()
}

pub fn assert_false(condition : Bool) -> Unit {
  ()
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "divide_with_ceil_positive" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "mathematical_commutative" {
  assert_eq(add(7, 13), add(13, 7))
  assert_eq(multiply(7, 13), multiply(13, 7))
}

test "zero_element_properties" {
  assert_eq(5, add(5, 0))
  assert_eq(0, multiply(5, 0))
}

test "complex_arithmetic" {
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "packaging_calculation" {
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "unicode_greeting" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "divide_with_ceil_edge_cases" {
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(5, 5))
  assert_eq(2, divide_with_ceil(3, 2))
}

test "add_negative_numbers" {
  assert_eq(-10, add(-5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(5, add(-10, 15))
}

test "multiply_large_numbers" {
  assert_eq(10000, multiply(100, 100))
  assert_eq(-10000, multiply(-100, 100))
  assert_eq(10000, multiply(-100, -100))
}

test "greet_empty_string" {
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_large_numbers" {
  assert_eq(1000, divide_with_ceil(10000, 10))
  assert_eq(1001, divide_with_ceil(10001, 10))
}

test "complex_calculation_sequence" {
  let a = add(5, 3)
  let b = multiply(a, 2)
  let c = divide_with_ceil(b, 4)
  assert_eq(4, c)  // ((5+3)*2)/4 = 16/4 = 4
}

test "greet_special_characters" {
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
}

test "divide_with_ceil_fractional" {
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(3, divide_with_ceil(5, 2))
  assert_eq(4, divide_with_ceil(7, 2))
}

// é¢å¤–çš„å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œæ›´å¤æ‚çš„åœºæ™¯æµ‹è¯•
test "divide_with_ceil_boundary_cases" {
  // æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(1, divide_with_ceil(-1, 1))
  assert_eq(-1, divide_with_ceil(1, -1))
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let x = 42
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
  assert_eq(x, multiply(x, 1))
  assert_eq(-x, multiply(x, -1))
}

test "divide_with_ceil_mixed_signs" {
  // æµ‹è¯•æ··åˆç¬¦å·çš„é™¤æ³•
  assert_eq(0, divide_with_ceil(-5, 10))
  assert_eq(-1, divide_with_ceil(-15, 10))
  assert_eq(2, divide_with_ceil(15, -10))
  assert_eq(1, divide_with_ceil(5, -10))
}

test "add_edge_cases" {
  // æµ‹è¯•åŠ æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, add(99, 1))
  assert_eq(-100, add(-99, -1))
  assert_eq(0, add(100, -100))
}

test "multiply_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, multiply(100, 1))
  assert_eq(-100, multiply(-100, 1))
  assert_eq(0, multiply(100, 0))
  assert_eq(0, multiply(-100, 0))
}

test "greet_with_various_inputs" {
  // æµ‹è¯•å„ç§è¾“å…¥çš„é—®å€™å‡½æ•°
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, ABC123!", greet("ABC123"))
}

test "complex_business_logic" {
  // æµ‹è¯•å¤æ‚çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // å‡è®¾æˆ‘ä»¬éœ€è¦è®¡ç®—è£…ç›’é—®é¢˜ï¼šæœ‰nä¸ªç‰©å“ï¼Œæ¯ç›’æœ€å¤šè£…mä¸ªï¼Œéœ€è¦å¤šå°‘ç›’
  let items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(items, box_capacity)
  
  // éªŒè¯è®¡ç®—ç»“æœ - ä½¿ç”¨æ–­è¨€è€Œä¸æ˜¯å¸ƒå°”å‡½æ•°
  assert_eq(5, boxes_needed)
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1000, divide_with_ceil(9999, 10))
  assert_eq(100, divide_with_ceil(991, 10))
  assert_eq(10, divide_with_ceil(91, 10))
  assert_eq(2, divide_with_ceil(11, 10))
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­æ“ä½œçš„ç»„åˆ
  let initial = 10
  let step1 = add(initial, 5)        // 15
  let step2 = multiply(step1, 2)     // 30
  let step3 = divide_with_ceil(step2, 8)  // 4
  let step4 = add(step3, 1)          // 5
  
  assert_eq(5, step4)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ é¢å¤–çš„æµ‹è¯•è¦†ç›–

test "add_function_negative_numbers" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-10, add(-5, -5))
  assert_eq(-2, add(-5, 3))
  assert_eq(2, add(-3, 5))
  assert_eq(0, add(-10, 10))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
}

test "greet_function_special_characters" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ã©spanol!", greet("Ã©spanol"))
  assert_eq_string("Hello, emoji ğŸ‰!", greet("emoji ğŸ‰"))
}

test "divide_with_ceil_mixed_operations" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„æ··åˆè¿ç®—
  let a = divide_with_ceil(10, 3)
  let b = divide_with_ceil(20, 7)
  let result = add(a, b)
  assert_eq(8, result)  // ceil(10/3) + ceil(20/7) = 4 + 4 = 8
}

test "complex_business_calculation" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_size = 8
  let tasks_per_person = 5
  let total_tasks = multiply(team_size, tasks_per_person)
  let tasks_per_sprint = 15
  let sprints_needed = divide_with_ceil(total_tasks, tasks_per_sprint)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
}

test "mathematical_distributive_property" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹
  let a = 6
  let b = 4
  let c = 3
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 6*(4+3) = 6*4 + 6*3 = 42
}

test "divide_with_ceil_large_numbers_extended" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å¤§æ•°æƒ…å†µ
  assert_eq(1000, divide_with_ceil(999999, 1000))
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
  assert_eq(2, divide_with_ceil(1000001, 1000000))
}

test "sequential_calculation_chain" {
  // æµ‹è¯•è¿ç»­è®¡ç®—é“¾
  let initial = 5
  let step1 = add(initial, multiply(2, 3))     // 5 + 2*3 = 11
  let step2 = divide_with_ceil(step1, 4)       // ceil(11/4) = 3
  let step3 = multiply(step2, add(1, 2))       // 3 * (1+2) = 9
  let step4 = divide_with_ceil(step3, 5)       // ceil(9/5) = 2
  assert_eq(2, step4)
}

test "greet_function_whitespace_handling" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç©ºç™½å­—ç¬¦å¤„ç†
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, leading space!", greet(" leading space"))
  assert_eq_string("Hello, trailing space !", greet("trailing space "))
  assert_eq_string("Hello, multiple   spaces!", greet("multiple   spaces"))
}

test "divide_with_ceil_negative_dividend" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿè¢«é™¤æ•°æƒ…å†µ
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-5, divide_with_ceil(-10, 2))
  assert_eq(-4, divide_with_ceil(-7, 2))
}

// æ–°æ·»åŠ çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "negative_divisor_scenarios" {
  // æµ‹è¯•è´Ÿé™¤æ•°çš„å„ç§åœºæ™¯
  assert_eq(-4, divide_with_ceil(10, -3))
  assert_eq(-3, divide_with_ceil(9, -3))
  assert_eq(-1, divide_with_ceil(1, -100))
  assert_eq(3, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(0, -5))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(1001, divide_with_ceil(1000000, 999))
}

test "mathematical_boundary_conditions" {
  // æµ‹è¯•æ•°å­¦è¾¹ç•Œæ¡ä»¶
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 1000))
}

test "string_input_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾“å…¥çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 0!", greet("0"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
}

test "mathematical_associative_properties" {
  // æµ‹è¯•æ•°å­¦ç»“åˆå¾‹æ€§è´¨
  let a = 2
  let b = 3
  let c = 4
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯æµ‹è¯•
  let total_products = 157
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // éªŒè¯éœ€è¦çš„ç®±å­æ•°é‡
  assert_eq(7, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(168, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(11, remaining_space)
}

test "zero_multiplication_comprehensive" {
  // é›¶ä¹˜æ³•ç»¼åˆæµ‹è¯•
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, multiply(0, 1000000))
}

test "unicode_and_special_characters" {
  // Unicodeå’Œç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
}

test "precision_and_rounding" {
  // ç²¾åº¦å’Œèˆå…¥æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000000, divide_with_ceil(1999999, 2))
  assert_eq(666667, divide_with_ceil(2000000, 3))
  assert_eq(333334, divide_with_ceil(1000000, 3))
}

test "project_budget_calculation" {
  // é¡¹ç›®é¢„ç®—è®¡ç®—æµ‹è¯•
  let team_members = 8
  let hourly_rate = 50
  let hours_per_day = 8
  let project_days = 15
  
  // è®¡ç®—æ€»å·¥æ—¶
  let total_hours = multiply(team_members, multiply(hours_per_day, project_days))
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = multiply(total_hours, hourly_rate)
  
  // è®¡ç®—éœ€è¦çš„æ”¯ä»˜å‘¨æœŸï¼ˆæ¯å‘¨æœŸæ”¯ä»˜ä¸è¶…è¿‡10000ï¼‰
  let payment_cycle_limit = 10000
  let payment_cycles = divide_with_ceil(total_budget, payment_cycle_limit)
  
  // éªŒè¯ç»“æœ
  assert_eq(960, total_hours)  // 8 * 8 * 15 = 960
  assert_eq(48000, total_budget)  // 960 * 50 = 48000
  assert_eq(5, payment_cycles)  // ceil(48000/10000) = 5
}



// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(7, add(3, 4))
  assert_eq(12, multiply(3, 4))
  assert_eq(1, divide_with_ceil(3, 4))
  assert_eq(4, divide_with_ceil(15, 4))
}

test "mathematical_properties" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 15
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 2)),
    add(multiply(x, y), multiply(x, 2))
  )
}

test "edge_cases_and_boundaries" {
  // è¾¹ç•Œæƒ…å†µå’Œæå€¼æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "negative_numbers_handling" {
  // è´Ÿæ•°å¤„ç†æµ‹è¯•
  assert_eq(-2, add(-5, 3))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(15, multiply(-5, -3))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(1, divide_with_ceil(-3, -4))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
}

test "business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—æµ‹è¯•
  let items = 47
  let capacity_per_box = 12
  let boxes_needed = divide_with_ceil(items, capacity_per_box)
  
  assert_eq(4, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, capacity_per_box)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, items)
  assert_eq(1, remaining_space)
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 10
  let multiplier = 3
  let divisor = 4
  let addition = 5
  
  // è®¡ç®—æµç¨‹ï¼š((base * multiplier) / divisor) + addition
  let step1 = multiply(base_value, multiplier)
  let step2 = divide_with_ceil(step1, divisor)
  let result = add(step2, addition)
  
  assert_eq(12, result)  // ceil(10*3/4) + 5 = 8 + 5 = 13
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 100
  let teams = 3
  let min_resources_per_team = divide_with_ceil(total_resources, teams)
  
  assert_eq(34, min_resources_per_team)
  
  // éªŒè¯åˆ†é…ç»“æœ
  let allocated_total = multiply(min_resources_per_team, teams)
  assert_eq(102, allocated_total)
  
  // éªŒè¯èµ„æºåˆ©ç”¨ç‡
  let utilization = divide_with_ceil(multiply(total_resources, 100), allocated_total)
  assert_eq(98, utilization)  // floor(10000/102) = 98%
}

test "error_handling_and_validation" {
  // é”™è¯¯å¤„ç†å’ŒéªŒè¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼éªŒè¯
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(2000000, add(1000000, 1000000))
}

test "real_world_application_scenario" {
  // çœŸå®ä¸–ç•Œåº”ç”¨åœºæ™¯æµ‹è¯•ï¼šæ´»åŠ¨å®‰æ’
  let participants = 87
  let tables = 8
  let chairs_per_table = 10
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(9, tables_needed)
  
  // è®¡ç®—å¯ç”¨åº§ä½æ•°
  let available_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(90, available_seats)
  
  // è®¡ç®—å‰©ä½™åº§ä½
  let remaining_seats = subtract(available_seats, participants)
  assert_eq(3, remaining_seats)
  
  // éªŒè¯åº§ä½å……è¶³æ€§
  assert_true(available_seats >= participants)
}

// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_values" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæƒ…å†µ
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘ Int æœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘ Int æœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(1000000, multiply(1000, 1000))  // å¤§æ•°ä½†å®‰å…¨èŒƒå›´å†…
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 100000
  let monthly_payment = 3500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(29, months_needed)  // ceil(100000/3500) = 29
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(101500, total_payment)
  
  // éªŒè¯æœ€åä¸€ä¸ªæœˆçš„å®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(total_payment, multiply(months_needed - 1, monthly_payment))
  assert_eq(1500, final_payment)
}

test "nested_function_composition" {
  // åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚çš„åµŒå¥—è®¡ç®—
  let result = divide_with_ceil(
    add(
      multiply(base_value, 3),
      multiply(base_value, 2)
    ),
    add(base_value, divide_with_ceil(base_value, 3))
  )
  
  // æ‰‹åŠ¨è®¡ç®—éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
}

test "error_resilience_scenarios" {
  // é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå°é™¤æ•°æƒ…å†µ
  assert_eq(1000000, divide_with_ceil(999999, 1))
  assert_eq(-999999, divide_with_ceil(-999999, 1))
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†æµæ°´çº¿æµ‹è¯•
  // æ¨¡æ‹Ÿæ‰¹é‡æ•°æ®å¤„ç†åœºæ™¯
  let data_batches = 150
  let batch_size = 12
  let processing_time_per_batch = 2
  
  // è®¡ç®—éœ€è¦çš„å¤„ç†è½®æ¬¡
  let processing_rounds = divide_with_ceil(data_batches, batch_size)
  assert_eq(13, processing_rounds)  // ceil(150/12) = 13
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_time = multiply(processing_rounds, processing_time_per_batch)
  assert_eq(26, total_time)
  
  // è®¡ç®—å®é™…å¤„ç†çš„æ•°æ®é‡
  let actual_processed = multiply(processing_rounds - 1, batch_size)
  let final_batch_size = subtract(data_batches, actual_processed)
  assert_eq(6, final_batch_size)  // æœ€åä¸€æ‰¹å¤„ç†6ä¸ª
}

test "string_formatting_edge_cases" {
  // å­—ç¬¦ä¸²æ ¼å¼åŒ–è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ä¸²ç»„åˆ
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, 0x1234!", greet("0x1234"))
  assert_eq_string("Hello, true!", greet("true"))
  assert_eq_string("Hello, false!", greet("false"))
  assert_eq_string("Hello, []!", greet("[]"))
  assert_eq_string("Hello, {}!", greet("{}"))
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•è·¯å¾„çš„æ€§èƒ½ç‰¹å¾
  let input_size = 1000
  
  // çº¿æ€§ç®—æ³•æ¨¡æ‹Ÿ
  let linear_steps = multiply(input_size, 3)
  assert_eq(3000, linear_steps)
  
  // å¯¹æ•°ç®—æ³•æ¨¡æ‹Ÿï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´é™¤æ³•æ¨¡æ‹Ÿï¼‰
  let log_steps = divide_with_ceil(input_size, 100)
  assert_eq(10, log_steps)
  
  // éªŒè¯ç®—æ³•æ•ˆç‡å·®å¼‚
  let efficiency_ratio = divide_with_ceil(linear_steps, log_steps)
  assert_eq(300, efficiency_ratio)
}

test "resource_optimization_problem_new" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // åœºæ™¯ï¼šä»“åº“å­˜å‚¨ä¼˜åŒ–
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  
  // ç‰©å“1ï¼š25ä¸ªï¼Œæ¯ç®±å®¹é‡8
  let item1_quantity = 25
  let item1_capacity = 8
  let boxes_1 = divide_with_ceil(item1_quantity, item1_capacity)  // ceil(25/8) = 4
  
  // ç‰©å“2ï¼š47ä¸ªï¼Œæ¯ç®±å®¹é‡12
  let item2_quantity = 47
  let item2_capacity = 12
  let boxes_2 = divide_with_ceil(item2_quantity, item2_capacity)  // ceil(47/12) = 4
  
  // ç‰©å“3ï¼š156ä¸ªï¼Œæ¯ç®±å®¹é‡20
  let item3_quantity = 156
  let item3_capacity = 20
  let boxes_3 = divide_with_ceil(item3_quantity, item3_capacity)  // ceil(156/20) = 8
  
  // ç‰©å“4ï¼š89ä¸ªï¼Œæ¯ç®±å®¹é‡15
  let item4_quantity = 89
  let item4_capacity = 15
  let boxes_4 = divide_with_ceil(item4_quantity, item4_capacity)  // ceil(89/15) = 6
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let capacity_1 = multiply(boxes_1, item1_capacity)  // 4 * 8 = 32
  let capacity_2 = multiply(boxes_2, item2_capacity)  // 4 * 12 = 48
  let capacity_3 = multiply(boxes_3, item3_capacity)  // 8 * 20 = 160
  let capacity_4 = multiply(boxes_4, item4_capacity)  // 6 * 15 = 90
  
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive_new" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„8ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "performance_large_scale_operations" {
  // å¤§è§„æ¨¡è¿ç®—æ€§èƒ½æµ‹è¯•
  let iterations = 10000
  let sum_result = add(iterations, iterations)
  let product_result = multiply(100, iterations)
  let division_result = divide_with_ceil(product_result, 50)
  
  assert_eq(20000, sum_result)
  assert_eq(1000000, product_result)
  assert_eq(20000, division_result)
}

test "error_boundary_conditions" {
  // é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•å„ç§å¯èƒ½å¯¼è‡´é”™è¯¯çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0
  assert_eq(0, divide_with_ceil(1, 0))  // æ­£æ•°/0
  assert_eq(0, divide_with_ceil(-1, 0))  // è´Ÿæ•°/0
  assert_eq(0, divide_with_ceil(2147483647, 0))  // æœ€å¤§å€¼/0
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // æœ€å°å€¼/0
}

test "string_encoding_handling_new" {
  // å­—ç¬¦ä¸²ç¼–ç å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \"quotes\"!", greet("\"quotes\""))
  assert_eq_string("Hello, 'apostrophe'!", greet("'apostrophe'"))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
}

test "complex_financial_calculations" {
  // å¤æ‚é‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—å¤åˆ©å’Œåˆ†æœŸä»˜æ¬¾
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  
  // éªŒè¯å¤åˆ©å¢é•¿
  assert_eq(10500, year1_end)  // 10000 + 5%
  assert_eq(11025, year2_end)  // 10500 + 5%
  assert_eq(11576, year3_end)  // 11025 + 5%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year3_end, total_months)
  assert_eq(322, monthly_payment)  // ceil(11576/36)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  let input_size_10 = 10
  let input_size_100 = 100
  let input_size_1000 = 1000
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_10 = multiply(input_size_10, 2)
  let linear_100 = multiply(input_size_100, 2)
  let linear_1000 = multiply(input_size_1000, 2)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  let log_10 = divide_with_ceil(input_size_10, 3)
  let log_100 = divide_with_ceil(input_size_100, 3)
  let log_1000 = divide_with_ceil(input_size_1000, 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(20, linear_10)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  
  assert_eq(4, log_10)
  assert_eq(34, log_100)
  assert_eq(334, log_1000)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let stack_size_after_push = add(stack_size, 1)
  let stack_size_after_pop = subtract(stack_size_after_push, 1)
  
  assert_eq(1, stack_size_after_push)
  assert_eq(0, stack_size_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 10
  let queue_items = 7
  let remaining_capacity = subtract(queue_capacity, queue_items)
  let can_add_more = remaining_capacity > 0
  
  assert_eq(3, remaining_capacity)
  assert_true(can_add_more)
}

test "resource_utilization_optimization_new" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory = 16384  // GB
  let servers = 5
  let memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(3277, memory_per_server)  // ceil(16384/5)
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, servers)
  let memory_waste = subtract(total_allocated, total_memory)
  
  assert_eq(16385, total_allocated)
  assert_eq(1, memory_waste)
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥
  let optimized_servers = add(servers, 1)
  let optimized_memory_per_server = divide_with_ceil(total_memory, optimized_servers)
  assert_eq(2341, optimized_memory_per_server)  // ceil(16384/6)
}

test "edge_case_mathematical_operations" {
  // è¾¹ç¼˜æƒ…å†µæ•°å­¦è¿ç®—æµ‹è¯•
  // æµ‹è¯•è¿ç»­è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  let initial_value = 1
  
  // è¿ç»­åŠ æ³•
  let result1 = add(add(add(initial_value, 1), 1), 1)
  assert_eq(4, result1)
  
  // è¿ç»­ä¹˜æ³•
  let result2 = multiply(multiply(multiply(initial_value, 2), 2), 2)
  assert_eq(8, result2)
  
  // æ··åˆè¿ç®—
  let result3 = divide_with_ceil(multiply(add(initial_value, 2), 3), 4)
  assert_eq(3, result3)  // ceil((1+2)*3/4) = ceil(9/4) = 3
  
  // æå€¼è¿ç®—
  let max_int_test = add(2147483647, 0)
  let min_int_test = add(-2147483648, 0)
  
  assert_eq(2147483647, max_int_test)
  assert_eq(-2147483648, min_int_test)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive_test" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_test" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_test" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline_test" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_test" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_test" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_boundary_test" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_test" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_scenario_test" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_basic_arithmetic" {
  // æµ‹è¯•åŸºæœ¬ç®—æœ¯è¿ç®—
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_logistics_scenario" {
  // çœŸå®ä¸–ç•Œç‰©æµåœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—ä»“åº“å­˜å‚¨éœ€æ±‚
  let products = 157
  let pallet_capacity = 24
  let pallets_needed = divide_with_ceil(products, pallet_capacity)
  assert_eq(7, pallets_needed)  // ceil(157/24) = 7
  
  // è®¡ç®—æ€»å­˜å‚¨ç©ºé—´
  let total_space = multiply(pallets_needed, pallet_capacity)
  assert_eq(168, total_space)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_space, products)
  assert_eq(11, remaining_space)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_basic_functionality" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(2, -3))
}

test "multiply_basic_functionality" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(2, -3))
}

test "greet_basic_functionality" {
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "add_identity_properties" {
  assert_eq(7, add(7, 0))
  assert_eq(7, add(0, 7))
}

test "multiply_zero_properties" {
  assert_eq(0, multiply(7, 0))
  assert_eq(0, multiply(0, 7))
}

test "divide_with_ceil_negative_numbers" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-10, -3))
}

test "complex_calculation" {
  let result = add(multiply(3, 4), divide_with_ceil(10, 4))
  assert_eq(15, result)  // 12 + 3 = 15
}

test "greet_unicode_characters" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_commutativity" {
  assert_eq(add(5, 7), add(7, 5))
  assert_eq(multiply(5, 7), multiply(7, 5))
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸º azimuth åº“æ–°å¢çš„10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// åŒ…å«å®é™…åº”ç”¨åœºæ™¯ã€è¾¹ç•Œæƒ…å†µå’Œæ•°å­¦æ€§è´¨éªŒè¯

test "binary_conversion_calculation" {
  // äºŒè¿›åˆ¶è½¬æ¢è®¡ç®—æµ‹è¯•
  let binary_weight_1 = 1
  let binary_weight_2 = 2
  let binary_weight_3 = 4
  let binary_weight_4 = 8
  let binary_weight_5 = 16
  let binary_weight_6 = 32
  
  // éªŒè¯äºŒè¿›åˆ¶ä½æƒè®¡ç®—
  let total_weight = add(add(add(add(add(binary_weight_1, binary_weight_2), binary_weight_3), binary_weight_4), binary_weight_5), binary_weight_6)
  assert_eq(63, total_weight)
  
  // éªŒè¯ç‰¹å®šäºŒè¿›åˆ¶ç»„åˆ
  let binary_42 = add(add(binary_weight_2, binary_weight_4), binary_weight_5)  // 101010 = 2 + 8 + 32
  assert_eq(42, binary_42)
}

test "temperature_conversion" {
  // æ¸©åº¦è½¬æ¢è®¡ç®—æµ‹è¯•
  let celsius_temp = 25
  let fahrenheit_temp = 77
  
  // æ‘„æ°åº¦åˆ°åæ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šF = C * 9/5 + 32
  let converted_fahrenheit = add(divide_with_ceil(multiply(celsius_temp, 9), 5), 32)
  
  // åæ°åº¦åˆ°æ‘„æ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šC = (F - 32) * 5/9
  let converted_celsius = divide_with_ceil(multiply(add(fahrenheit_temp, -32), 5), 9)
  
  assert_eq(77, converted_fahrenheit)
  assert_eq(25, converted_celsius)
}

test "array_index_calculation" {
  // æ•°ç»„ç´¢å¼•è®¡ç®—æµ‹è¯•ï¼ˆæ¨¡æ‹ŸäºŒç»´æ•°ç»„çš„ä¸€ç»´ç´¢å¼•ï¼‰
  let rows = 4
  let cols = 5
  let row_index = 2
  let col_index = 3
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—ï¼šindex = row * cols + col
  let linear_index = add(multiply(row_index, cols), col_index)
  
  assert_eq(13, linear_index)
  
  // éªŒè¯è¾¹ç•Œæƒ…å†µ
  let first_element = add(multiply(0, cols), 0)
  let last_element = add(multiply(rows - 1, cols - 1), cols - 1)
  
  assert_eq(0, first_element)
  assert_eq(19, last_element)
}

test "prime_number_validation" {
  // è´¨æ•°éªŒè¯æµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let test_number = 17
  let divisor_2 = 2
  let divisor_3 = 3
  let divisor_5 = 5
  
  // æ£€æŸ¥æ˜¯å¦èƒ½è¢«å°è´¨æ•°æ•´é™¤
  let remainder_2 = test_number % divisor_2
  let remainder_3 = test_number % divisor_3
  let remainder_5 = test_number % divisor_5
  
  // éªŒè¯17ä¸èƒ½è¢«2ã€3ã€5æ•´é™¤
  assert_eq(1, remainder_2)
  assert_eq(2, remainder_3)
  assert_eq(2, remainder_5)
  
  // æµ‹è¯•åˆæ•°
  let composite_number = 15
  let composite_remainder_3 = composite_number % divisor_3
  let composite_remainder_5 = composite_number % divisor_5
  
  assert_eq(0, composite_remainder_3)
  assert_eq(0, composite_remainder_5)
}

test "loan_amortization" {
  // è´·æ¬¾åˆ†æœŸè®¡ç®—æµ‹è¯•
  let loan_amount = 10000
  let interest_rate = 5  // 5%
  let loan_term_years = 3
  let months_per_year = 12
  
  // è®¡ç®—æ€»æœˆæ•°
  let total_months = multiply(loan_term_years, months_per_year)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—ï¼ˆä¸åŒ…å«å¤åˆ©ï¼‰
  let total_interest = divide_with_ceil(multiply(loan_amount, interest_rate), 100)
  let total_payment = add(loan_amount, total_interest)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  
  assert_eq(36, total_months)
  assert_eq(500, total_interest)
  assert_eq(10500, total_payment)
  assert_eq(292, monthly_payment)
}

test "game_score_calculation" {
  // æ¸¸æˆå¾—åˆ†è®¡ç®—æµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let bonus_points = 500
  let penalty_points = 200
  
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let level_score = multiply(base_score, level_multiplier)
  let score_with_bonus = add(level_score, bonus_points)
  let final_score = add(score_with_bonus, -penalty_points)
  
  assert_eq(3000, level_score)
  assert_eq(3500, score_with_bonus)
  assert_eq(3300, final_score)
  
  // è®¡ç®—ç­‰çº§æå‡éœ€è¦çš„åˆ†æ•°
  let next_level_threshold = multiply(final_score, 2)
  let current_progress = divide_with_ceil(multiply(final_score, 100), next_level_threshold)
  
  assert_eq(6600, next_level_threshold)
  assert_eq(50, current_progress)
}

test "data_storage_optimization" {
  // æ•°æ®å­˜å‚¨ä¼˜åŒ–æµ‹è¯•
  let file_size_mb = 150
  let compression_ratio = 60  // å‹ç¼©åˆ°60%
  let storage_capacity_mb = 1000
  
  // è®¡ç®—å‹ç¼©åçš„æ–‡ä»¶å¤§å°
  let compressed_size = divide_with_ceil(multiply(file_size_mb, compression_ratio), 100)
  
  // è®¡ç®—å¯ä»¥å­˜å‚¨çš„å‹ç¼©æ–‡ä»¶æ•°é‡
  let files_that_fit = divide_with_ceil(storage_capacity_mb, compressed_size)
  
  // è®¡ç®—å‰©ä½™å­˜å‚¨ç©ºé—´
  let used_space = multiply(files_that_fit, compressed_size)
  let remaining_space = add(storage_capacity_mb, -used_space)
  
  assert_eq(90, compressed_size)
  assert_eq(12, files_that_fit)
  assert_eq(1080, used_space)
  assert_eq(-80, remaining_space)  // è¶…å‡ºå®¹é‡
}

test "network_packet_routing" {
  // ç½‘ç»œæ•°æ®åŒ…è·¯ç”±æµ‹è¯•
  let total_packets = 1000
  let route_1_capacity = 300
  let route_2_capacity = 400
  let route_3_capacity = 500
  
  // è®¡ç®—å„è·¯ç”±åˆ†é…çš„æ•°æ®åŒ…æ•°é‡
  let route_1_packets = divide_with_ceil(multiply(total_packets, route_1_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_2_packets = divide_with_ceil(multiply(total_packets, route_2_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_3_packets = divide_with_ceil(multiply(total_packets, route_3_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  
  // éªŒè¯æ€»åˆ†é…é‡
  let total_allocated = add(add(route_1_packets, route_2_packets), route_3_packets)
  
  assert_eq(250, route_1_packets)
  assert_eq(334, route_2_packets)
  assert_eq(417, route_3_packets)
  assert_eq(1001, total_allocated)  // ç”±äºå‘ä¸Šå–æ•´ï¼Œç•¥å¤šäºæ€»æ•°
}

test "cryptographic_hash_simulation" {
  // åŠ å¯†å“ˆå¸Œæ¨¡æ‹Ÿæµ‹è¯•
  let input_value = 12345
  let prime_1 = 31
  let prime_2 = 37
  let prime_3 = 41
  let modulo_value = 1000000
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè®¡ç®—ï¼šhash = ((input * p1) + p2) * p3 % mod
  let step1 = add(multiply(input_value, prime_1), prime_2)
  let step2 = multiply(step1, prime_3)
  let hash_result = step2 % modulo_value
  
  assert_eq(382816, add(multiply(12345, 31), 37))
  assert_eq(15695456, multiply(382816, 41))
  assert_eq(695456, hash_result)
  
  // éªŒè¯å“ˆå¸Œçš„ç¡®å®šæ€§ï¼ˆç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡ºï¼‰
  let hash_repeat = ((add(multiply(input_value, prime_1), prime_2)) * prime_3) % modulo_value
  assert_eq(hash_result, hash_repeat)
}

test "cpu_scheduling_simulation" {
  // CPUè°ƒåº¦æ¨¡æ‹Ÿæµ‹è¯•
  let process_1_time = 8
  let process_2_time = 12
  let process_3_time = 6
  let process_4_time = 10
  let time_quantum = 4
  
  // è®¡ç®—æ¯ä¸ªè¿›ç¨‹éœ€è¦çš„æ—¶é—´ç‰‡æ•°é‡
  let process_1_quanta = divide_with_ceil(process_1_time, time_quantum)
  let process_2_quanta = divide_with_ceil(process_2_time, time_quantum)
  let process_3_quanta = divide_with_ceil(process_3_time, time_quantum)
  let process_4_quanta = divide_with_ceil(process_4_time, time_quantum)
  
  // è®¡ç®—æ€»æ—¶é—´ç‰‡æ•°
  let total_quanta = add(add(add(process_1_quanta, process_2_quanta), process_3_quanta), process_4_quanta)
  
  // è®¡ç®—æ€»æ‰§è¡Œæ—¶é—´ï¼ˆè€ƒè™‘ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼‰
  let context_switch_overhead = 1
  let total_execution_time = add(multiply(total_quanta, time_quantum), multiply(total_quanta, context_switch_overhead))
  
  assert_eq(2, process_1_quanta)
  assert_eq(3, process_2_quanta)
  assert_eq(2, process_3_quanta)
  assert_eq(3, process_4_quanta)
  assert_eq(10, total_quanta)
  assert_eq(50, total_execution_time)
}

// æ–°å¢çš„8ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_associative_laws" {
  // æµ‹è¯•åŠ æ³•å’Œä¹˜æ³•çš„ç»“åˆå¾‹
  let a = 2
  let b = 3
  let c = 4
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "extreme_boundary_conditions" {
  // æµ‹è¯•æç«¯è¾¹ç•Œæ¡ä»¶
  // å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000000, multiply(1000000, 1000))
  
  // æ¥è¿‘é›¶çš„è¿ç®—
  assert_eq(1, divide_with_ceil(1, 1000000))
  assert_eq(0, divide_with_ceil(0, 1000000))
  
  // è´Ÿæ•°æå€¼
  assert_eq(-2000000, add(-1000000, -1000000))
  assert_eq(1000000000, multiply(-1000000, -1000))
}

test "real_world_inventory_management" {
  // çœŸå®ä¸–ç•Œåº“å­˜ç®¡ç†åœºæ™¯
  let total_products = 1234
  let box_capacity = 45
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // éªŒè¯ç®±å­æ•°é‡è®¡ç®—
  assert_eq(28, boxes_needed)  // ceil(1234/45) = 28
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(1260, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let unused_space = subtract(total_capacity, total_products)
  assert_eq(26, unused_space)
}

test "mathematical_distributive_property_extended" {
  // æ‰©å±•çš„åˆ†é…å¾‹æµ‹è¯•
  let a = 7
  let b = 5
  let c = 3
  
  // å®Œæ•´åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
  
  // åµŒå¥—åˆ†é…å¾‹
  let complex_left = multiply(add(a, b), add(c, 2))
  let complex_right = add(add(multiply(a, c), multiply(a, 2)), add(multiply(b, c), multiply(b, 2)))
  assert_eq(complex_left, complex_right)
}

test "error_handling_comprehensive" {
  // å…¨é¢çš„é”™è¯¯å¤„ç†æµ‹è¯•
  // é™¤é›¶çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  
  // æå°é™¤æ•°
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(-2147483647, divide_with_ceil(-2147483647, 1))
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, 123.45!", greet("123.45"))
  assert_eq_string("Hello, [object Object]!", greet("[object Object]"))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, 'single'!", greet("'single'"))
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  let data_sizes = [10, 100, 1000]
  let expected_linear = [20, 200, 2000]  // O(n)
  let expected_logarithmic = [2, 7, 67]  // O(log n) simplified
  
  // æ¨¡æ‹Ÿçº¿æ€§ç®—æ³•å¤æ‚åº¦
  assert_eq(expected_linear[0], multiply(data_sizes[0], 2))
  assert_eq(expected_linear[1], multiply(data_sizes[1], 2))
  assert_eq(expected_linear[2], multiply(data_sizes[2], 2))
  
  // æ¨¡æ‹Ÿå¯¹æ•°ç®—æ³•å¤æ‚åº¦ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  assert_eq(expected_logarithmic[0], divide_with_ceil(data_sizes[0], 5))
  assert_eq(expected_logarithmic[1], divide_with_ceil(data_sizes[1], 15))
  assert_eq(expected_logarithmic[2], divide_with_ceil(data_sizes[2], 15))
}

test "business_calculation_comprehensive" {
  // ç»¼åˆä¸šåŠ¡è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šé¡¹ç›®é¢„ç®—å’Œèµ„æºåˆ†é…
  let project_duration = 18  // æœˆ
  let team_size = 12
  let average_salary = 8000  // æ¯äººæ¯æœˆ
  let equipment_cost = 50000
  let contingency_rate = 15  // ç™¾åˆ†æ¯”
  
  // è®¡ç®—äººåŠ›æˆæœ¬
  let total_person_months = multiply(team_size, project_duration)
  let labor_cost = multiply(total_person_months, average_salary)
  
  // è®¡ç®—åº”æ€¥èµ„é‡‘
  let contingency_amount = divide_with_ceil(multiply(labor_cost, contingency_rate), 100)
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = add(add(labor_cost, equipment_cost), contingency_amount)
  
  // éªŒè¯è®¡ç®—ç»“æœ
  assert_eq(216, total_person_months)  // 12 * 18
  assert_eq(1728000, labor_cost)  // 216 * 8000
  assert_eq(259200, contingency_amount)  // ceil(1728000 * 15 / 100)
  assert_eq(2037200, total_budget)  // 1728000 + 50000 + 259200
  
  // è®¡ç®—æœˆåº¦é¢„ç®—åˆ†é…
  let monthly_budget = divide_with_ceil(total_budget, project_duration)
  assert_eq(113178, monthly_budget)  // ceil(2037200 / 18)
}

// æ ‡å‡† MoonBit å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_commutative_law" {
  // éªŒè¯åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(8, 7))
  assert_eq(15, add(7, 8))
  assert_eq(0, add(-5, 5))
  assert_eq(0, add(5, -5))
  assert_eq(-10, add(-3, -7))
  assert_eq(-10, add(-7, -3))
}

test "multiply_function_distributive_law" {
  // éªŒè¯ä¹˜æ³•åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 6
  let b = 4
  let c = 2
  
  let left_result = multiply(a, add(b, c))
  let right_result = add(multiply(a, b), multiply(a, c))
  assert_eq(left_result, right_result)  // 6 * (4 + 2) = 6 * 4 + 6 * 2 = 36
  
  // å¦ä¸€ä¸ªä¾‹å­
  assert_eq(20, multiply(4, add(2, 3)))  // 4 * (2 + 3) = 20
  assert_eq(20, add(multiply(4, 2), multiply(4, 3)))  // 4 * 2 + 4 * 3 = 20
}

test "divide_with_ceil_real_world_scenarios" {
  // çœŸå®ä¸–ç•Œåœºæ™¯ï¼šè®¡ç®—è£…ç›’é—®é¢˜
  let total_items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(total_items, box_capacity)
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†
  let packages = 25
  let capacity_per_truck = 8
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(4, trucks_needed)  // ceil(25/8) = 4
}

test "greet_function_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿ï¼šé¡¹ç›®èµ„æºè§„åˆ’
  let team_size = 8
  let tasks_per_person = 5
  let sprint_capacity = 15
  
  // è®¡ç®—æ€»ä»»åŠ¡æ•°
  let total_tasks = multiply(team_size, tasks_per_person)
  assert_eq(40, total_tasks)
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ•°
  let sprints_needed = divide_with_ceil(total_tasks, sprint_capacity)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(sprints_needed, sprint_capacity)
  assert_eq(45, total_capacity)
}

test "mathematical_identity_properties" {
  // æ•°å­¦æ’ç­‰å¼éªŒè¯
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(multiply(x, -1), multiply(-1, x))
}

test "divide_with_ceil_edge_cases" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç¼˜æƒ…å†µ
  // é›¶å€¼æµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  
  // è´Ÿæ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-7, 4))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(-1, divide_with_ceil(-1, 4))
  
  // è´Ÿé™¤æ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(7, -4))
  assert_eq(-1, divide_with_ceil(3, -4))
  assert_eq(0, divide_with_ceil(1, -4))
  
  // åŒè´Ÿæ•°æµ‹è¯•
  assert_eq(2, divide_with_ceil(-7, -4))
  assert_eq(1, divide_with_ceil(-3, -4))
  assert_eq(1, divide_with_ceil(-1, -4))
}

test "business_logic_inventory_management" {
  // åº“å­˜ç®¡ç†ä¸šåŠ¡é€»è¾‘ - ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸ä½¿ç”¨æ•°ç»„
  // äº§å“1: 25ä¸ªç‰©å“ï¼Œæ¯ç®±8ä¸ª
  let boxes_1 = divide_with_ceil(25, 8)  // ceil(25/8) = 4
  let capacity_1 = multiply(boxes_1, 8)  // 4 * 8 = 32
  
  // äº§å“2: 47ä¸ªç‰©å“ï¼Œæ¯ç®±12ä¸ª
  let boxes_2 = divide_with_ceil(47, 12)  // ceil(47/12) = 4
  let capacity_2 = multiply(boxes_2, 12)  // 4 * 12 = 48
  
  // äº§å“3: 156ä¸ªç‰©å“ï¼Œæ¯ç®±20ä¸ª
  let boxes_3 = divide_with_ceil(156, 20)  // ceil(156/20) = 8
  let capacity_3 = multiply(boxes_3, 20)  // 8 * 20 = 160
  
  // äº§å“4: 89ä¸ªç‰©å“ï¼Œæ¯ç®±15ä¸ª
  let boxes_4 = divide_with_ceil(89, 15)  // ceil(89/15) = 6
  let capacity_4 = multiply(boxes_4, 15)  // 6 * 15 = 90
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

test "large_number_operations" {
  // å¤§æ•°è¿ç®—æµ‹è¯• - ä½¿ç”¨è¾ƒå°çš„å¤§æ•°ä»¥é¿å…æº¢å‡º
  let large_num = 10000
  
  // å¤§æ•°åŠ æ³•
  assert_eq(20000, add(large_num, large_num))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(100000000, multiply(large_num, large_num))
  
  // å¤§æ•°é™¤æ³•
  assert_eq(1, divide_with_ceil(large_num, large_num))
  assert_eq(2, divide_with_ceil(add(large_num, 1), large_num))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(10, divide_with_ceil(99, 10))
  assert_eq(11, divide_with_ceil(101, 10))
}

test "nested_calculations_composition" {
  // åµŒå¥—è®¡ç®—ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚åµŒå¥—è®¡ç®—ï¼š(base * 3 + base * 2) / (base + ceil(base/3))
  let numerator = add(multiply(base_value, 3), multiply(base_value, 2))
  let denominator = add(base_value, divide_with_ceil(base_value, 3))
  let result = divide_with_ceil(numerator, denominator)
  
  // æ‰‹åŠ¨éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
  
  // å¦ä¸€ä¸ªåµŒå¥—è®¡ç®—ç¤ºä¾‹
  let complex_result = divide_with_ceil(
    multiply(add(5, 3), 4),
    subtract(10, 2)
  )
  assert_eq(4, complex_result)  // ceil((5+3)*4 / (10-2)) = ceil(32/8) = 4
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "subtract_operation_simulation" {
  // æ¨¡æ‹Ÿå‡æ³•æ“ä½œï¼ša - b = a + (-b)
  let a = 15
  let b = 7
  let negative_b = multiply(b, -1)
  let result = add(a, negative_b)
  assert_eq(8, result)
}

test "percentage_calculation" {
  // ç™¾åˆ†æ¯”è®¡ç®—æµ‹è¯•
  let total = 200
  let percentage = 25  // 25%
  let result = divide_with_ceil(multiply(total, percentage), 100)
  assert_eq(50, result)
}

test "batch_processing_efficiency" {
  // æ‰¹å¤„ç†æ•ˆç‡æµ‹è¯•
  let total_items = 157
  let batch_size = 20
  let full_batches = divide_with_ceil(total_items, batch_size)
  assert_eq(8, full_batches)  // ceil(157/20) = 8
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(full_batches, batch_size)
  assert_eq(160, total_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let unused_capacity = subtract(total_capacity, total_items)
  assert_eq(3, unused_capacity)
}

test "string_concatenation_length" {
  // å­—ç¬¦ä¸²è¿æ¥é•¿åº¦æµ‹è¯•
  let name = "MoonBit"
  let greeting = greet(name)
  let expected_length = add(add(7, 6), 1)  // "Hello, " + "MoonBit" + "!" = 7 + 6 + 1 = 14
  assert_eq(14, expected_length)
  // greeting is intentionally unused
}

test "division_precision_test" {
  // é™¤æ³•ç²¾åº¦æµ‹è¯•
  // æµ‹è¯•è¿ç»­é™¤æ³•çš„ç²¾åº¦ä¿æŒ
  let initial_value = 1000
  let divisor1 = 3
  let divisor2 = 7
  let divisor3 = 11
  
  let step1 = divide_with_ceil(initial_value, divisor1)
  let step2 = divide_with_ceil(step1, divisor2)
  let step3 = divide_with_ceil(step2, divisor3)
  
  // éªŒè¯æ¯ä¸€æ­¥çš„ç»“æœ
  assert_eq(334, step1)   // ceil(1000/3)
  assert_eq(48, step2)    // ceil(334/7)
  assert_eq(5, step3)     // ceil(48/11)
}

test "resource_allocation_fairness" {
  // èµ„æºåˆ†é…å…¬å¹³æ€§æµ‹è¯•
  let total_resources = 100
  let participants = 9
  
  // è®¡ç®—æ¯äººåº”å¾—ä»½é¢
  let base_share = divide_with_ceil(total_resources, participants)
  assert_eq(12, base_share)  // ceil(100/9) = 12
  
  // è®¡ç®—æ€»åˆ†é…é‡
  let total_allocated = multiply(base_share, participants)
  assert_eq(108, total_allocated)
  
  // è®¡ç®—æº¢å‡ºé‡
  let overflow = subtract(total_allocated, total_resources)
  assert_eq(8, overflow)
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let total_tasks = 87
  let team_velocity = 12  // æ¯å‘¨å®Œæˆçš„ä»»åŠ¡æ•°
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(total_tasks, team_velocity)
  assert_eq(8, weeks_needed)  // ceil(87/12) = 8
  
  // è®¡ç®—æ€»å·¥ä½œæ—¥ï¼ˆå‡è®¾æ¯å‘¨5ä¸ªå·¥ä½œæ—¥ï¼‰
  let work_days = multiply(weeks_needed, 5)
  assert_eq(40, work_days)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(weeks_needed, team_velocity)
  assert_eq(96, total_capacity)
}

test "exponential_growth_simulation" {
  // æŒ‡æ•°å¢é•¿æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿç®€å•çš„æŒ‡æ•°å¢é•¿ï¼šæ¯æ¬¡ç¿»å€
  let initial_value = 3
  let growth_periods = 5  // è¿™ä¸ªå˜é‡åªæ˜¯ç”¨äºæ¼”ç¤ºï¼Œå®é™…æœªä½¿ç”¨
  
  // æ‰‹åŠ¨è®¡ç®—æŒ‡æ•°å¢é•¿
  let period1 = multiply(initial_value, 2)
  let period2 = multiply(period1, 2)
  let period3 = multiply(period2, 2)
  let period4 = multiply(period3, 2)
  let period5 = multiply(period4, 2)
  
  assert_eq(6, period1)    // 3 * 2
  assert_eq(12, period2)   // 6 * 2
  assert_eq(24, period3)   // 12 * 2
  assert_eq(48, period4)   // 24 * 2
  assert_eq(96, period5)   // 48 * 2
  
  // éªŒè¯æœ€ç»ˆç»“æœ
  assert_eq(96, period5)
  // growth_periods is intentionally unused
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "azimuth_enhanced_basic_addition" {
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "azimuth_enhanced_multiplication_edge_cases" {
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "azimuth_enhanced_greeting_international" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "azimuth_enhanced_divide_with_ceil_business_logic" {
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "azimuth_enhanced_complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "azimuth_enhanced_mathematical_properties" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "azimuth_enhanced_resource_allocation" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "azimuth_enhanced_error_handling" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "azimuth_enhanced_string_processing" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "azimuth_enhanced_real_world_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // éªŒè¯ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼
  let n = 5
  let sum_1_to_n = divide_with_ceil(multiply(n, add(n, 1)), 2)
  assert_eq(15, sum_1_to_n)  // 5*6/2 = 15
  
  // éªŒè¯ç­‰æ¯”æ•°åˆ—æ±‚å’Œ
  let geo_sum = add(add(2, 4), add(8, 16))  // 2 + 4 + 8 + 16
  assert_eq(30, geo_sum)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  // è®¡ç®—æ¯ä¸ªé¡¹ç›®éœ€è¦çš„é˜¶æ®µæ•°
  let phases_1 = divide_with_ceil(120, 25)  // ceil(120/25) = 5
  let phases_2 = divide_with_ceil(85, 20)   // ceil(85/20) = 5
  let phases_3 = divide_with_ceil(200, 45)  // ceil(200/45) = 5
  let phases_4 = divide_with_ceil(150, 35)  // ceil(150/35) = 5
  
  // è®¡ç®—æ€»é˜¶æ®µæ•°
  let total_phases = add(add(phases_1, phases_2), add(phases_3, phases_4))
  assert_eq(20, total_phases)
  
  // è®¡ç®—å®é™…åˆ†é…çš„å·¥æ—¶
  let allocated_1 = multiply(phases_1, 25)  // 5 * 25 = 125
  let allocated_2 = multiply(phases_2, 20)  // 5 * 20 = 100
  let allocated_3 = multiply(phases_3, 45)  // 5 * 45 = 225
  let allocated_4 = multiply(phases_4, 35)  // 5 * 35 = 175
  
  let total_allocated = add(add(allocated_1, allocated_2), add(allocated_3, allocated_4))
  assert_eq(625, total_allocated)
}

test "multilingual_greeting_processing" {
  // å¤šè¯­è¨€é—®å€™å¤„ç†æµ‹è¯•
  let greeting_1 = greet("World")
  let greeting_2 = greet("ä¸–ç•Œ")
  let greeting_3 = greet("ĞœĞ¸Ñ€")
  let greeting_4 = greet("ğŸŒ")
  let greeting_5 = greet("cafÃ©")
  
  // éªŒè¯é—®å€™è¯­æ ¼å¼
  assert_eq_string("Hello, World!", greeting_1)
  assert_eq_string("Hello, ä¸–ç•Œ!", greeting_2)
  assert_eq_string("Hello, ĞœĞ¸Ñ€!", greeting_3)
  assert_eq_string("Hello, ğŸŒ!", greeting_4)
  assert_eq_string("Hello, cafÃ©!", greeting_5)
  
  // è®¡ç®—æ€»å­—ç¬¦æ•°ï¼ˆæ¨¡æ‹Ÿï¼‰
  let total_length = add(add(add(add(13, 10), 10), 10), 11)
  assert_eq(54, total_length)
  
  // è®¡ç®—å¹³å‡é•¿åº¦
  let avg_length = divide_with_ceil(total_length, 5)
  assert_eq(11, avg_length)  // ceil(54/5) = 11
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  // O(1) ç®—æ³• - æ’å®šæ—¶é—´
  let constant_time = 5
  
  // O(n) ç®—æ³• - çº¿æ€§æ—¶é—´
  let linear_100 = multiply(100, 2)
  let linear_1000 = multiply(1000, 2)
  let linear_10000 = multiply(10000, 2)
  
  // O(nÂ²) ç®—æ³• - å¹³æ–¹æ—¶é—´ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let quadratic_100 = multiply(100, 100)
  let quadratic_1000 = divide_with_ceil(multiply(1000, 1000), 10)
  let quadratic_10000 = divide_with_ceil(multiply(10000, 10000), 100)
  
  // éªŒè¯ç®—æ³•å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  assert_eq(20000, linear_10000)
  
  assert_eq(10000, quadratic_100)
  assert_eq(100000, quadratic_1000)
  assert_eq(1000000, quadratic_10000)
  
  // è®¡ç®—æ•ˆç‡æ¯”ç‡
  let linear_to_constant = divide_with_ceil(linear_1000, constant_time)
  let quadratic_to_linear = divide_with_ceil(quadratic_1000, linear_1000)
  
  assert_eq(400, linear_to_constant)  // 2000/5 = 400
  assert_eq(50, quadratic_to_linear)  // 100000/2000 = 50
}

test "financial_investment_calculation" {
  // é‡‘èæŠ•èµ„è®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 8  // 8%
  let years = 5
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year_1 = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year_2 = add(year_1, divide_with_ceil(multiply(year_1, annual_rate), 100))
  let year_3 = add(year_2, divide_with_ceil(multiply(year_2, annual_rate), 100))
  let year_4 = add(year_3, divide_with_ceil(multiply(year_3, annual_rate), 100))
  let year_5 = add(year_4, divide_with_ceil(multiply(year_4, annual_rate), 100))
  
  // éªŒè¯æ¯å¹´çš„å¢é•¿
  assert_eq(10800, year_1)   // 10000 + 8%
  assert_eq(11664, year_2)   // 10800 + 8%
  assert_eq(12597, year_3)   // 11664 + 8%
  assert_eq(13605, year_4)   // 12597 + 8%
  assert_eq(14693, year_5)   // 13605 + 8%
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_return = subtract(year_5, principal)
  let return_percentage = divide_with_ceil(multiply(total_return, 100), principal)
  
  assert_eq(4693, total_return)  // 14693 - 10000
  assert_eq(47, return_percentage)  // ceil(4693/10000 * 100) = 47%
  
  // è®¡ç®—æœˆä¾›ï¼ˆ5å¹´åˆ†æœŸï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year_5, total_months)
  assert_eq(245, monthly_payment)  // ceil(14693/60)
}

test "warehouse_inventory_management" {
  // ä»“åº“åº“å­˜ç®¡ç†æµ‹è¯•
  // è®¡ç®—æ¯ä¸ªä»“åº“çš„åˆ©ç”¨ç‡
  let utilization_1 = divide_with_ceil(multiply(500, 100), 75)
  let utilization_2 = divide_with_ceil(multiply(300, 100), 100)
  let utilization_3 = divide_with_ceil(multiply(800, 100), 120)
  let utilization_4 = divide_with_ceil(multiply(200, 100), 50)
  
  assert_eq(667, utilization_1)  // ceil(500/75 * 100) = 667%
  assert_eq(300, utilization_2)  // ceil(300/100 * 100) = 300%
  assert_eq(667, utilization_3)  // ceil(800/120 * 100) = 667%
  assert_eq(400, utilization_4)  // ceil(200/50 * 100) = 400%
  
  // è®¡ç®—æ€»åº“å­˜å’Œæ€»å®¹é‡
  let total_current = add(add(500, 300), add(800, 200))
  let total_capacity = add(add(75, 100), add(120, 50))
  
  assert_eq(1800, total_current)  // 500 + 300 + 800 + 200
  assert_eq(345, total_capacity)   // 75 + 100 + 120 + 50
  
  // è®¡ç®—éœ€è¦çš„é¢å¤–ä»“åº“ç©ºé—´
  let additional_space_needed = divide_with_ceil(subtract(total_current, total_capacity), 150)
  assert_eq(10, additional_space_needed)  // ceil(1455/150) = 10
}

test "numerical_system_validation" {
  // æ•°å­—ç³»ç»ŸéªŒè¯æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num_1 = 123456
  let large_num_2 = 789012
  let sum_large = add(large_num_1, large_num_2)
  let product_approx = multiply(divide_with_ceil(large_num_1, 100), divide_with_ceil(large_num_2, 1000))
  
  assert_eq(912468, sum_large)  // 123456 + 789012
  assert_eq(984, product_approx)  // 1235 * 789 â‰ˆ 974415 (ç®€åŒ–è®¡ç®—)
  
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—
  let fibonacci_1 = 1
  let fibonacci_2 = 1
  let fibonacci_3 = add(fibonacci_1, fibonacci_2)  // 2
  let fibonacci_4 = add(fibonacci_2, fibonacci_3)  // 3
  let fibonacci_5 = add(fibonacci_3, fibonacci_4)  // 5
  let fibonacci_6 = add(fibonacci_4, fibonacci_5)  // 8
  
  assert_eq(2, fibonacci_3)
  assert_eq(3, fibonacci_4)
  assert_eq(5, fibonacci_5)
  assert_eq(8, fibonacci_6)
  
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å’Œ
  let mut fib_sum = add(add(add(fibonacci_1, fibonacci_2), fibonacci_3), fibonacci_4)
  fib_sum = add(add(fib_sum, fibonacci_5), fibonacci_6)
  assert_eq(20, fib_sum)  // 1 + 1 + 2 + 3 + 5 + 8 = 20
  
  // éªŒè¯é»„é‡‘æ¯”ä¾‹è¿‘ä¼¼å€¼
  let golden_ratio_approx = divide_with_ceil(multiply(fibonacci_6, 100), fibonacci_5)
  assert_eq(160, golden_ratio_approx)  // ceil(8/5 * 100) = 160 (1.6)
}

test "performance_metrics_evaluation" {
  // æ€§èƒ½æŒ‡æ ‡è¯„ä¼°æµ‹è¯•
  let base_iterations = 1000
  
  // åŠ æ³•æ€§èƒ½æµ‹è¯•
  let add_result = multiply(base_iterations, 10)
  assert_eq(10000, add_result)  // 1000 * 10
  
  // ä¹˜æ³•æ€§èƒ½æµ‹è¯•
  let multiply_result = multiply(base_iterations, 10)
  assert_eq(10000, multiply_result)
  
  // é™¤æ³•æ€§èƒ½æµ‹è¯•
  let divide_result = divide_with_ceil(multiply(base_iterations, 10), 3)
  assert_eq(3334, divide_result)  // ceil(10000/3)
  
  // å¤åˆæ“ä½œæ€§èƒ½æµ‹è¯•
  let complex_result = add(
    multiply(base_iterations, 5),
    divide_with_ceil(multiply(base_iterations, 3), 7)
  )
  assert_eq(6429, complex_result)  // 5000 + ceil(3000/7)
  
  // æ“ä½œæ•ˆç‡æ¯”è¾ƒ
  let add_efficiency = divide_with_ceil(add_result, base_iterations)
  let multiply_efficiency = divide_with_ceil(multiply_result, base_iterations)
  let divide_efficiency = divide_with_ceil(divide_result, base_iterations)
  
  assert_eq(10, add_efficiency)      // 10000/1000 = 10
  assert_eq(10, multiply_efficiency) // 10000/1000 = 10
  assert_eq(4, divide_efficiency)    // ceil(3334/1000) = 4
  
  // è®¡ç®—æ€»ä½“æ€§èƒ½å¾—åˆ†
  let performance_score = add(add(add_efficiency, multiply_efficiency), divide_efficiency)
  assert_eq(24, performance_score)  // 10 + 10 + 4
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_conditions" {
  // æç«¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„å€¼
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq(-2147483648, add(-2147483647, -1))
  assert_eq(1, divide_with_ceil(2147483647, 2147483647))
  assert_eq(0, divide_with_ceil(-2147483648, 2147483647))
}

test "string_edge_cases_comprehensive" {
  // å­—ç¬¦ä¸²è¾¹ç¼˜æƒ…å†µç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \\0!", greet("\\0"))
  assert_eq_string("Hello, \\\"!", greet("\""))
  assert_eq_string("Hello, \\\\!", greet("\\"))
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
}

test "divide_with_ceil_comprehensive_error_handling" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„ç»¼åˆé”™è¯¯å¤„ç†
  // å„ç§é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå°é™¤æ•°
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(-2147483648, divide_with_ceil(-2147483648, 1))
}

test "complex_mathematical_series" {
  // å¤æ‚æ•°å­¦çº§æ•°æµ‹è¯•
  // ç­‰å·®æ•°åˆ—æ±‚å’Œ
  let n = 10
  let first_term = 1
  let last_term = 10
  let arithmetic_sum = divide_with_ceil(multiply(n, add(first_term, last_term)), 2)
  assert_eq(55, arithmetic_sum)  // 10 * (1 + 10) / 2 = 55
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼ˆç®€åŒ–ï¼‰
  let ratio = 2
  let geometric_sum = subtract(multiply(ratio, n), 1)
  assert_eq(19, geometric_sum)  // 2^10 - 1 (ç®€åŒ–è®¡ç®—)
}

test "real_world_logistics_optimization" {
  // çœŸå®ä¸–ç•Œç‰©æµä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šå¤šä»“åº“è´§ç‰©åˆ†é…
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  
  // ä»“åº“1ï¼š100ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡25
  let warehouse1_goods = 100
  let warehouse1_capacity = 25
  let trucks_1 = divide_with_ceil(warehouse1_goods, warehouse1_capacity)  // ceil(100/25) = 4
  
  // ä»“åº“2ï¼š150ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡40
  let warehouse2_goods = 150
  let warehouse2_capacity = 40
  let trucks_2 = divide_with_ceil(warehouse2_goods, warehouse2_capacity)  // ceil(150/40) = 4
  
  // ä»“åº“3ï¼š80ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡20
  let warehouse3_goods = 80
  let warehouse3_capacity = 20
  let trucks_3 = divide_with_ceil(warehouse3_goods, warehouse3_capacity)  // ceil(80/20) = 4
  
  // ä»“åº“4ï¼š200ä¸ªè´§ç‰©ï¼Œæ¯è½¦å®¹é‡35
  let warehouse4_goods = 200
  let warehouse4_capacity = 35
  let trucks_4 = divide_with_ceil(warehouse4_goods, warehouse4_capacity)  // ceil(200/35) = 6
  
  let total_trucks = add(add(trucks_1, trucks_2), add(trucks_3, trucks_4))
  assert_eq(18, total_trucks)
  
  // è®¡ç®—æ€»è¿åŠ›å’Œåˆ©ç”¨ç‡
  let total_capacity = add(
    multiply(trucks_1, warehouse1_capacity),
    add(multiply(trucks_2, warehouse2_capacity), 
    add(multiply(trucks_3, warehouse3_capacity), multiply(trucks_4, warehouse4_capacity)))
  )
  let total_goods = add(add(warehouse1_goods, warehouse2_goods), add(warehouse3_goods, warehouse4_goods))
  
  assert_eq(530, total_capacity)  // 4*25 + 4*40 + 4*20 + 6*35
  assert_eq(530, total_goods)     // 100 + 150 + 80 + 200
}

test "advanced_error_recovery_scenarios" {
  // é«˜çº§é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // æ¨¡æ‹Ÿæ•°æ®æŸåå’Œæ¢å¤
  let corrupted_data = -1
  let fallback_value = 0
  
  // é”™è¯¯æ£€æµ‹å’Œæ¢å¤
  let recovered_data = add(corrupted_data, multiply(fallback_value, 2))
  assert_eq(-1, recovered_data)
  
  // ä½¿ç”¨é™¤æ³•è¿›è¡Œé”™è¯¯æ£€æµ‹
  let error_detected = divide_with_ceil(corrupted_data, 0)
  assert_eq(0, error_detected)  // é™¤é›¶é”™è¯¯è¿”å›0
  
  // æ•°æ®éªŒè¯
  let is_valid = multiply(recovered_data, recovered_data) >= 0
  assert_true(is_valid)
}

test "statistical_analysis_operations" {
  // ç»Ÿè®¡åˆ†ææ“ä½œæµ‹è¯•
  // è®¡ç®—å¹³å‡å€¼ï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  let num1 = 10
  let num2 = 20
  let num3 = 30
  let num4 = 40
  let num5 = 50
  let sum = add(add(add(add(num1, num2), num3), num4), num5)
  let count = 5
  let average = divide_with_ceil(sum, count)
  assert_eq(30, average)  // ceil(150/5) = 30
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ï¼‰
  // ä½¿ç”¨å•ç‹¬çš„å˜é‡è€Œä¸æ˜¯æ•°ç»„æ¥é¿å…å¯¼å…¥é—®é¢˜
  let dev1 = subtract(num1, average)
  let dev2 = subtract(num2, average)
  let dev3 = subtract(num3, average)
  let dev4 = subtract(num4, average)
  let dev5 = subtract(num5, average)
    // dev1 = -20, dev2 = -10, dev3 = 0, dev4 = 10, dev5 = 20
  
  // è®¡ç®—å¹³æ–¹åå·®
  let squared_dev1 = multiply(dev1, dev1)  // 400
  let squared_dev2 = multiply(dev2, dev2)  // 100
  let squared_dev3 = multiply(dev3, dev3)  // 0
    let squared_dev4 = multiply(dev4, dev4)  // 100
  let squared_dev5 = multiply(dev5, dev5)  // 400
  
  let variance_sum = add(add(add(add(squared_dev1, squared_dev2), squared_dev3), squared_dev4), squared_dev5)
  let variance = divide_with_ceil(variance_sum, count)
  assert_eq(200, variance)  // ceil(1000/5) = 200
}

test "cryptography_simulation" {
  // å¯†ç å­¦æ¨¡æ‹Ÿæµ‹è¯•
  // ç®€åŒ–çš„å‡¯æ’’å¯†ç 
  let plaintext = "Hello"
  let shift = 3
  
  // æ¨¡æ‹ŸåŠ å¯†è¿‡ç¨‹ï¼ˆä½¿ç”¨æ•°å€¼è¿ç®—ï¼‰
  let encrypted_numeric = add(72, shift)  // 'H' (72) + 3 = 75 ('K')
  assert_eq(75, encrypted_numeric)
  
  // æ¨¡æ‹Ÿè§£å¯†è¿‡ç¨‹
  let decrypted_numeric = subtract(encrypted_numeric, shift)
  assert_eq(72, decrypted_numeric)
  
  // ç®€åŒ–çš„å“ˆå¸Œæ¨¡æ‹Ÿ
  let hash_input = 12345
  let hash_prime = 31
  let hash_result = multiply(hash_input, hash_prime)
  assert_eq(382695, hash_result)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œå†²çªæ£€æµ‹
  let another_input = 617
  let another_hash = multiply(another_input, hash_prime)
  let hash_collision = divide_with_ceil(hash_result, another_hash)
  assert_eq(2, hash_collision)  // ceil(382695/19127) = 2
}

test "advanced_financial_modeling" {
  // é«˜çº§é‡‘èå»ºæ¨¡æµ‹è¯•
  // å¤æ‚çš„è´·æ¬¾è®¡ç®—
  let principal = 200000
  let annual_rate = 6  // 6%
  let loan_term_years = 30
  
  // è®¡ç®—æœˆåˆ©ç‡ï¼ˆç®€åŒ–ï¼‰
  let monthly_rate = divide_with_ceil(annual_rate, 12)
  assert_eq(1, monthly_rate)  // ceil(6/12) = 1%
  
  // è®¡ç®—æ€»æœˆæ•°
  let total_months = multiply(loan_term_years, 12)
  assert_eq(360, total_months)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—
  let monthly_payment = divide_with_ceil(
    add(principal, divide_with_ceil(multiply(principal, annual_rate), 100)),
    total_months
  )
  assert_eq(556, monthly_payment)  // ceil((200000 + 12000) / 360)
  
  // è®¡ç®—æ€»æ”¯ä»˜é¢
  let total_payment = multiply(monthly_payment, total_months)
  assert_eq(200160, total_payment)
  
  // è®¡ç®—æ€»åˆ©æ¯
  let total_interest = subtract(total_payment, principal)
  assert_eq(160, total_interest)
}

test "quantum_computing_simulation" {
  // é‡å­è®¡ç®—æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿé‡å­ä½æ“ä½œ
  let qubit_state_0 = 0
  let qubit_state_1 = 1
  
  // é‡å­å åŠ æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let superposition_coefficient = divide_with_ceil(multiply(qubit_state_0 + qubit_state_1, 100), 2)
  assert_eq(50, superposition_coefficient)  // ceil(1*100/2) = 50
  
  // é‡å­çº ç¼ æ¨¡æ‹Ÿ
  let entangled_pair_1 = 1
  let entangled_pair_2 = 0
  
  // æµ‹é‡æ“ä½œæ¨¡æ‹Ÿ
  let measurement_result = add(entangled_pair_1, entangled_pair_2)
  assert_eq(1, measurement_result)
  
  // é‡å­é—¨æ“ä½œæ¨¡æ‹Ÿ
  let hadamard_gate_input = 1
  let hadamard_gate_output = divide_with_ceil(hadamard_gate_input + 1, 2)
  assert_eq(1, hadamard_gate_output)  // ceil(2/2) = 1
  
  // é‡å­ç®—æ³•æ¨¡æ‹Ÿï¼ˆGroverç®—æ³•ç®€åŒ–ï¼‰
  let search_space_size = 1000
  let target_items = 1
  let oracle_calls = divide_with_ceil(multiply(search_space_size, target_items), 100)
  assert_eq(10, oracle_calls)  // ceil(1000/100) = 10
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - å¸¦å”¯ä¸€å‰ç¼€
test "new_add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "new_multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "new_greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "new_divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "new_complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "new_mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "new_resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "new_error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "new_string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "new_real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "boundary_condition_extreme_values_new" {
  // è¾¹ç•Œæ¡ä»¶æå€¼æµ‹è¯•
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(0, divide_with_ceil(-2147483647, 2147483646))
}

test "performance_large_scale_computations_new" {
  // å¤§è§„æ¨¡è¿ç®—æ€§èƒ½æµ‹è¯•
  let large_number = 100000
  let iterations = 10
  
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let sum_result = add(large_number, large_number)
  assert_eq(200000, sum_result)
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  let product_result = multiply(large_number, iterations)
  assert_eq(1000000, product_result)
  
  // æµ‹è¯•å¤§æ•°é™¤æ³•
  let division_result = divide_with_ceil(product_result, large_number)
  assert_eq(10, division_result)
}

test "error_handling_division_by_zero_new" {
  // é™¤é›¶é”™è¯¯å¤„ç†æµ‹è¯•
  assert_eq(0, divide_with_ceil(100, 0))  // æ­£æ•°é™¤é›¶
  assert_eq(0, divide_with_ceil(-100, 0))  // è´Ÿæ•°é™¤é›¶
  assert_eq(0, divide_with_ceil(0, 0))  // é›¶é™¤é›¶
  assert_eq(0, divide_with_ceil(2147483647, 0))  // æœ€å¤§å€¼é™¤é›¶
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // æœ€å°å€¼é™¤é›¶
}

test "internationalization_unicode_support_new" {
  // å›½é™…åŒ–Unicodeæ”¯æŒæµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
}

test "complex_business_logic_inventory_new" {
  // å¤æ‚ä¸šåŠ¡é€»è¾‘ï¼šåº“å­˜ç®¡ç†æµ‹è¯•
  let product_types = 5
  let average_quantity = 150
  let box_capacity = 24
  
  // è®¡ç®—æ€»åº“å­˜é‡
  let total_inventory = multiply(product_types, average_quantity)
  assert_eq(750, total_inventory)
  
  // è®¡ç®—éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_needed = divide_with_ceil(total_inventory, box_capacity)
  assert_eq(32, boxes_needed)  // ceil(750/24) = 32
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(768, total_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_inventory)
  assert_eq(18, remaining_space)
}

test "algorithm_complexity_analysis_new" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  let input_size = 1000
  
  // O(1) å¸¸æ•°æ—¶é—´æ“ä½œ
  let constant_time = add(5, 10)
  assert_eq(15, constant_time)
  
  // O(n) çº¿æ€§æ—¶é—´æ“ä½œæ¨¡æ‹Ÿ
  let linear_time = multiply(input_size, 2)
  assert_eq(2000, linear_time)
  
  // O(log n) å¯¹æ•°æ—¶é—´æ“ä½œæ¨¡æ‹Ÿ
  let logarithmic_time = divide_with_ceil(input_size, 100)
  assert_eq(10, logarithmic_time)
  
  // éªŒè¯å¤æ‚åº¦å…³ç³»
  let comparison1 = subtract(linear_time, logarithmic_time)
  let comparison2 = subtract(linear_time, constant_time)
  assert_eq(1990, comparison1)  // linear_time > logarithmic_time
  assert_eq(1985, comparison2)  // linear_time > constant_time
}

test "data_type_conversion_edge_cases_new" {
  // æ•°æ®ç±»å‹è½¬æ¢è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•é›¶å€¼è½¬æ¢
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(0, 12345))
  assert_eq(0, divide_with_ceil(0, 12345))
  
  // æµ‹è¯•å•ä½å€¼è½¬æ¢
  assert_eq(1, add(1, 0))
  assert_eq(1, multiply(1, 1))
  assert_eq(1, divide_with_ceil(1, 1))
  
  // æµ‹è¯•è´Ÿå€¼è½¬æ¢
  assert_eq(-1, add(0, -1))
  assert_eq(-1, multiply(-1, 1))
  assert_eq(-1, divide_with_ceil(-1, 1))
}

test "security_input_validation_new" {
  // å®‰å…¨æ€§è¾“å…¥éªŒè¯æµ‹è¯•
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, <script>!", greet("<script>"))
  assert_eq_string("Hello, SELECT * FROM!", greet("SELECT * FROM"))
  assert_eq_string("Hello, ../etc/passwd!", greet("../etc/passwd"))
  
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œå®‰å…¨
  assert_eq(0, divide_with_ceil(2147483647, 0))  // é˜²æ­¢æ•´æ•°æº¢å‡º
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // é˜²æ­¢æ•´æ•°ä¸‹æº¢
}

test "compatibility_backward_compatibility_new" {
  // å…¼å®¹æ€§å’Œå‘åå…¼å®¹æ€§æµ‹è¯•
  // æµ‹è¯•åŸºæœ¬è¿ç®—çš„å…¼å®¹æ€§
  assert_eq(10, add(3, 7))  // åŸºæœ¬åŠ æ³•å…¼å®¹æ€§
  assert_eq(21, multiply(3, 7))  // åŸºæœ¬ä¹˜æ³•å…¼å®¹æ€§
  assert_eq_string("Hello, World!", greet("World"))  // å­—ç¬¦ä¸²å¤„ç†å…¼å®¹æ€§
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µå…¼å®¹æ€§
  assert_eq(0, multiply(2147483647, 0))  // å¤§æ•°ä¸é›¶ç›¸ä¹˜
  assert_eq(2147483647, multiply(2147483647, 1))  // å¤§æ•°ä¸ä¸€ç›¸ä¹˜
  assert_eq(1, divide_with_ceil(2147483647, 2147483647))  // ç›¸ç­‰å¤§æ•°ç›¸é™¤
  
  // æµ‹è¯•è´Ÿæ•°å…¼å®¹æ€§
  assert_eq(-10, add(-3, -7))
  assert_eq(21, multiply(-3, -7))
  assert_eq(-4, divide_with_ceil(-10, 3))
}

test "real_world_financial_calculations_new" {
  // çœŸå®ä¸–ç•Œé‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 50000
  let monthly_payment = 2200
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(23, months_needed)  // ceil(50000/2200) = 23
  
  // è®¡ç®—æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(50600, total_payment)
  
  // è®¡ç®—æœ€åä¸€ä¸ªæœˆçš„å®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(total_payment, multiply(months_needed - 1, monthly_payment))
  assert_eq(200, final_payment)
  
  // åœºæ™¯ï¼šæŠ•èµ„å›æŠ¥è®¡ç®—
  let initial_investment = 10000
  let return_rate = 8  // 8%
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year1 = add(initial_investment, divide_with_ceil(multiply(initial_investment, return_rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, return_rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, return_rate), 100))
  let year4 = add(year3, divide_with_ceil(multiply(year3, return_rate), 100))
  let year5 = add(year4, divide_with_ceil(multiply(year4, return_rate), 100))
  
  // éªŒè¯æŠ•èµ„å¢é•¿
  assert_eq(10800, year1)  // 10000 + 8%
  assert_eq(11664, year2)  // 10800 + 8%
  assert_eq(12597, year3)  // 11664 + 8%
  assert_eq(13605, year4)  // 12597 + 8%
  assert_eq(14693, year5)  // 13605 + 8%
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸º azimuth åº“æ–°å¢çš„10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// åŒ…å«å®é™…åº”ç”¨åœºæ™¯ã€è¾¹ç•Œæƒ…å†µå’Œæ•°å­¦æ€§è´¨éªŒè¯

test "binary_conversion_calculation" {
  // äºŒè¿›åˆ¶è½¬æ¢è®¡ç®—æµ‹è¯•
  let binary_weight_1 = 1
  let binary_weight_2 = 2
  let binary_weight_3 = 4
  let binary_weight_4 = 8
  let binary_weight_5 = 16
  let binary_weight_6 = 32
  
  // éªŒè¯äºŒè¿›åˆ¶ä½æƒè®¡ç®—
  let total_weight = add(add(add(add(add(binary_weight_1, binary_weight_2), binary_weight_3), binary_weight_4), binary_weight_5), binary_weight_6)
  assert_eq(63, total_weight)
  
  // éªŒè¯ç‰¹å®šäºŒè¿›åˆ¶ç»„åˆ
  let binary_42 = add(add(binary_weight_2, binary_weight_4), binary_weight_5)  // 101010 = 2 + 8 + 32
  assert_eq(42, binary_42)
}

test "temperature_conversion" {
  // æ¸©åº¦è½¬æ¢è®¡ç®—æµ‹è¯•
  let celsius_temp = 25
  let fahrenheit_temp = 77
  
  // æ‘„æ°åº¦åˆ°åæ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šF = C * 9/5 + 32
  let converted_fahrenheit = add(divide_with_ceil(multiply(celsius_temp, 9), 5), 32)
  
  // åæ°åº¦åˆ°æ‘„æ°åº¦çš„ç®€åŒ–å…¬å¼ï¼šC = (F - 32) * 5/9
  let converted_celsius = divide_with_ceil(multiply(add(fahrenheit_temp, -32), 5), 9)
  
  assert_eq(77, converted_fahrenheit)
  assert_eq(25, converted_celsius)
}

test "array_index_calculation" {
  // æ•°ç»„ç´¢å¼•è®¡ç®—æµ‹è¯•ï¼ˆæ¨¡æ‹ŸäºŒç»´æ•°ç»„çš„ä¸€ç»´ç´¢å¼•ï¼‰
  let rows = 4
  let cols = 5
  let row_index = 2
  let col_index = 3
  
  // äºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•è®¡ç®—ï¼šindex = row * cols + col
  let linear_index = add(multiply(row_index, cols), col_index)
  
  assert_eq(13, linear_index)
  
  // éªŒè¯è¾¹ç•Œæƒ…å†µ
  let first_element = add(multiply(0, cols), 0)
  let last_element = add(multiply(rows - 1, cols - 1), cols - 1)
  
  assert_eq(0, first_element)
  assert_eq(19, last_element)
}

test "prime_number_validation" {
  // è´¨æ•°éªŒè¯æµ‹è¯•ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let test_number = 17
  let divisor_2 = 2
  let divisor_3 = 3
  let divisor_5 = 5
  
  // æ£€æŸ¥æ˜¯å¦èƒ½è¢«å°è´¨æ•°æ•´é™¤
  let remainder_2 = test_number % divisor_2
  let remainder_3 = test_number % divisor_3
  let remainder_5 = test_number % divisor_5
  
  // éªŒè¯17ä¸èƒ½è¢«2ã€3ã€5æ•´é™¤
  assert_eq(1, remainder_2)
  assert_eq(2, remainder_3)
  assert_eq(2, remainder_5)
  
  // æµ‹è¯•åˆæ•°
  let composite_number = 15
  let composite_remainder_3 = composite_number % divisor_3
  let composite_remainder_5 = composite_number % divisor_5
  
  assert_eq(0, composite_remainder_3)
  assert_eq(0, composite_remainder_5)
}

test "loan_amortization" {
  // è´·æ¬¾åˆ†æœŸè®¡ç®—æµ‹è¯•
  let loan_amount = 10000
  let interest_rate = 5  // 5%
  let loan_term_years = 3
  let months_per_year = 12
  
  // è®¡ç®—æ€»æœˆæ•°
  let total_months = multiply(loan_term_years, months_per_year)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—ï¼ˆä¸åŒ…å«å¤åˆ©ï¼‰
  let total_interest = divide_with_ceil(multiply(loan_amount, interest_rate), 100)
  let total_payment = add(loan_amount, total_interest)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  
  assert_eq(36, total_months)
  assert_eq(500, total_interest)
  assert_eq(10500, total_payment)
  assert_eq(292, monthly_payment)
}

test "game_score_calculation" {
  // æ¸¸æˆå¾—åˆ†è®¡ç®—æµ‹è¯•
  let base_score = 1000
  let level_multiplier = 3
  let bonus_points = 500
  let penalty_points = 200
  
  // è®¡ç®—æœ€ç»ˆå¾—åˆ†
  let level_score = multiply(base_score, level_multiplier)
  let score_with_bonus = add(level_score, bonus_points)
  let final_score = add(score_with_bonus, -penalty_points)
  
  assert_eq(3000, level_score)
  assert_eq(3500, score_with_bonus)
  assert_eq(3300, final_score)
  
  // è®¡ç®—ç­‰çº§æå‡éœ€è¦çš„åˆ†æ•°
  let next_level_threshold = multiply(final_score, 2)
  let current_progress = divide_with_ceil(multiply(final_score, 100), next_level_threshold)
  
  assert_eq(6600, next_level_threshold)
  assert_eq(50, current_progress)
}

test "data_storage_optimization" {
  // æ•°æ®å­˜å‚¨ä¼˜åŒ–æµ‹è¯•
  let file_size_mb = 150
  let compression_ratio = 60  // å‹ç¼©åˆ°60%
  let storage_capacity_mb = 1000
  
  // è®¡ç®—å‹ç¼©åçš„æ–‡ä»¶å¤§å°
  let compressed_size = divide_with_ceil(multiply(file_size_mb, compression_ratio), 100)
  
  // è®¡ç®—å¯ä»¥å­˜å‚¨çš„å‹ç¼©æ–‡ä»¶æ•°é‡
  let files_that_fit = divide_with_ceil(storage_capacity_mb, compressed_size)
  
  // è®¡ç®—å‰©ä½™å­˜å‚¨ç©ºé—´
  let used_space = multiply(files_that_fit, compressed_size)
  let remaining_space = add(storage_capacity_mb, -used_space)
  
  assert_eq(90, compressed_size)
  assert_eq(12, files_that_fit)
  assert_eq(1080, used_space)
  assert_eq(-80, remaining_space)  // è¶…å‡ºå®¹é‡
}

test "network_packet_routing" {
  // ç½‘ç»œæ•°æ®åŒ…è·¯ç”±æµ‹è¯•
  let total_packets = 1000
  let route_1_capacity = 300
  let route_2_capacity = 400
  let route_3_capacity = 500
  
  // è®¡ç®—å„è·¯ç”±åˆ†é…çš„æ•°æ®åŒ…æ•°é‡
  let route_1_packets = divide_with_ceil(multiply(total_packets, route_1_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_2_packets = divide_with_ceil(multiply(total_packets, route_2_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  let route_3_packets = divide_with_ceil(multiply(total_packets, route_3_capacity), add(add(route_1_capacity, route_2_capacity), route_3_capacity))
  
  // éªŒè¯æ€»åˆ†é…é‡
  let total_allocated = add(add(route_1_packets, route_2_packets), route_3_packets)
  
  assert_eq(250, route_1_packets)
  assert_eq(334, route_2_packets)
  assert_eq(417, route_3_packets)
  assert_eq(1001, total_allocated)  // ç”±äºå‘ä¸Šå–æ•´ï¼Œç•¥å¤šäºæ€»æ•°
}

test "cryptographic_hash_simulation" {
  // åŠ å¯†å“ˆå¸Œæ¨¡æ‹Ÿæµ‹è¯•
  let input_value = 12345
  let prime_1 = 31
  let prime_2 = 37
  let prime_3 = 41
  let modulo_value = 1000000
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè®¡ç®—ï¼šhash = ((input * p1) + p2) * p3 % mod
  let step1 = add(multiply(input_value, prime_1), prime_2)
  let step2 = multiply(step1, prime_3)
  let hash_result = step2 % modulo_value
  
  assert_eq(382816, add(multiply(12345, 31), 37))
  assert_eq(15695456, multiply(382816, 41))
  assert_eq(695456, hash_result)
  
  // éªŒè¯å“ˆå¸Œçš„ç¡®å®šæ€§ï¼ˆç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡ºï¼‰
  let hash_repeat = ((add(multiply(input_value, prime_1), prime_2)) * prime_3) % modulo_value
  assert_eq(hash_result, hash_repeat)
}

test "cpu_scheduling_simulation" {
  // CPUè°ƒåº¦æ¨¡æ‹Ÿæµ‹è¯•
  let process_1_time = 8
  let process_2_time = 12
  let process_3_time = 6
  let process_4_time = 10
  let time_quantum = 4
  
  // è®¡ç®—æ¯ä¸ªè¿›ç¨‹éœ€è¦çš„æ—¶é—´ç‰‡æ•°é‡
  let process_1_quanta = divide_with_ceil(process_1_time, time_quantum)
  let process_2_quanta = divide_with_ceil(process_2_time, time_quantum)
  let process_3_quanta = divide_with_ceil(process_3_time, time_quantum)
  let process_4_quanta = divide_with_ceil(process_4_time, time_quantum)
  
  // è®¡ç®—æ€»æ—¶é—´ç‰‡æ•°
  let total_quanta = add(add(add(process_1_quanta, process_2_quanta), process_3_quanta), process_4_quanta)
  
  // è®¡ç®—æ€»æ‰§è¡Œæ—¶é—´ï¼ˆè€ƒè™‘ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼‰
  let context_switch_overhead = 1
  let total_execution_time = add(multiply(total_quanta, time_quantum), multiply(total_quanta, context_switch_overhead))
  
  assert_eq(2, process_1_quanta)
  assert_eq(3, process_2_quanta)
  assert_eq(2, process_3_quanta)
  assert_eq(3, process_4_quanta)
  assert_eq(10, total_quanta)
  assert_eq(50, total_execution_time)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_distributive_law" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 7
  let b = 5
  let c = 3
  
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)  // 7 * (5 + 3) = 7 * 5 + 7 * 3 = 56
}

test "inventory_box_packing_optimization" {
  // åº“å­˜è£…ç®±ä¼˜åŒ–é—®é¢˜
  let item_a_count = 23
  let box_capacity_a = 6
  let boxes_a = divide_with_ceil(item_a_count, box_capacity_a)
  
  let item_b_count = 41
  let box_capacity_b = 8
  let boxes_b = divide_with_ceil(item_b_count, box_capacity_b)
  
  let item_c_count = 17
  let box_capacity_c = 5
  let boxes_c = divide_with_ceil(item_c_count, box_capacity_c)
  
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  let total_capacity = add(
    multiply(boxes_a, box_capacity_a),
    add(multiply(boxes_b, box_capacity_b), multiply(boxes_c, box_capacity_c))
  )
  let total_items = add(add(item_a_count, item_b_count), item_c_count)
  let wasted_space = subtract(total_capacity, total_items)
  
  assert_eq(4, boxes_a)  // ceil(23/6) = 4
  assert_eq(6, boxes_b)  // ceil(41/8) = 6
  assert_eq(4, boxes_c)  // ceil(17/5) = 4
  assert_eq(14, total_boxes)
  assert_eq(7, wasted_space)  // æ€»å®¹é‡88 - æ€»ç‰©å“81 = 7
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯ï¼šé¡¹ç›®æ’æœŸ
  let total_tasks = 127
  let team_members = 5
  let tasks_per_person_per_day = 3
  let work_days_per_week = 5
  
  let daily_capacity = multiply(team_members, tasks_per_person_per_day)
  let work_days_needed = divide_with_ceil(total_tasks, daily_capacity)
  let weeks_needed = divide_with_ceil(work_days_needed, work_days_per_week)
  
  assert_eq(15, daily_capacity)  // 5 * 3 = 15
  assert_eq(9, work_days_needed)  // ceil(127/15) = 9
  assert_eq(2, weeks_needed)     // ceil(9/5) = 2
}

test "string_edge_cases_comprehensive" {
  // å­—ç¬¦ä¸²è¾¹ç¼˜æƒ…å†µç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \n\n\n!", greet("\n\n\n"))
  assert_eq_string("Hello, \t\t\t!", greet("\t\t\t"))
  assert_eq_string("Hello, ğŸŒŸğŸŒ™â­!", greet("ğŸŒŸğŸŒ™â­"))
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—ï¼šç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—
  let n = 10
  let first_term = 3
  let common_difference = 2
  
  let arithmetic_sum = divide_with_ceil(
    multiply(n, add(multiply(2, first_term), multiply(n - 1, common_difference))),
    2
  )
  
  let geometric_sum = multiply(first_term, subtract(multiply(2, n), 1))
  
  assert_eq(120, arithmetic_sum)  // 10/2 * (6 + 18) = 120
  assert_eq(57, geometric_sum)   // 3 * (20 - 1) = 57
}

test "resource_allocation_simple" {
  // ç®€åŒ–çš„èµ„æºåˆ†é…é—®é¢˜
  let total_budget = 50000
  let departments = 4
  
  let avg_allocation = divide_with_ceil(total_budget, departments)
  let actual_total = multiply(avg_allocation, departments)
  let budget_deficit = subtract(actual_total, total_budget)
  
  assert_eq(12500, avg_allocation)  // ceil(50000/4) = 12500
  assert_eq(0, budget_deficit)      // 12500 * 4 - 50000 = 0
}

test "negative_number_division_precision" {
  // è´Ÿæ•°é™¤æ³•çš„ç²¾åº¦æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-7, 3))   // ceil(-2.33) = -2
  assert_eq(-2, divide_with_ceil(-8, 3))   // ceil(-2.67) = -2
  assert_eq(3, divide_with_ceil(-7, -3))   // ceil(2.33) = 3
  assert_eq(3, divide_with_ceil(-8, -3))   // ceil(2.67) = 3
  assert_eq(0, divide_with_ceil(-1, 2))    // ceil(-0.5) = 0
  assert_eq(0, divide_with_ceil(1, -2))    // ceil(-0.5) = 0
}

test "complex_business_workflow" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµæµ‹è¯•ï¼šç”µå•†è®¢å•å¤„ç†
  let order_items = 47
  let items_per_box = 8
  let boxes_per_pallet = 6
  let pallets_per_truck = 4
  
  let boxes_needed = divide_with_ceil(order_items, items_per_box)
  let pallets_needed = divide_with_ceil(boxes_needed, boxes_per_pallet)
  let trucks_needed = divide_with_ceil(pallets_needed, pallets_per_truck)
  
  let total_truck_capacity = multiply(trucks_needed, multiply(pallets_per_truck, boxes_per_pallet))
  let capacity_utilization = divide_with_ceil(
    multiply(multiply(boxes_needed, 100), total_truck_capacity),
    100
  )
  
  assert_eq(6, boxes_needed)      // ceil(47/8) = 6
  assert_eq(1, pallets_needed)    // ceil(6/6) = 1
  assert_eq(1, trucks_needed)     // ceil(1/4) = 1
  assert_eq(24, total_truck_capacity)  // 1 * 4 * 6 = 24
  assert_eq(25, capacity_utilization)  // ceil(6*100/24) = 25%
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "arithmetic_sequence_operations" {
  // ç­‰å·®æ•°åˆ—è¿ç®—æµ‹è¯•
  let first_term = 3
  let difference = 5
  let n_terms = 6
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—ç¬¬né¡¹ï¼ša_n = a_1 + (n-1)*d
  let nth_term = add(first_term, multiply(n_terms - 1, difference))
  assert_eq(28, nth_term)  // 3 + (6-1)*5 = 28
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼šS_n = n*(a_1 + a_n)/2
  let sum = divide_with_ceil(multiply(n_terms, add(first_term, nth_term)), 2)
  assert_eq(93, sum)  // 6*(3+28)/2 = 93
}

test "geometric_progression_calculations" {
  // ç­‰æ¯”æ•°åˆ—è®¡ç®—æµ‹è¯•
  let first_term = 2
  let ratio = 3
  let n_terms = 4
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—ç¬¬né¡¹ï¼ša_n = a_1 * r^(n-1)
  let nth_term = multiply(first_term, multiply(ratio, multiply(ratio, ratio)))
  assert_eq(54, nth_term)  // 2 * 3^3 = 54
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹å’Œçš„è¿‘ä¼¼å€¼
  let sum_approx = multiply(first_term, divide_with_ceil(multiply(ratio, n_terms), ratio - 1))
  assert_eq(24, sum_approx)  // è¿‘ä¼¼è®¡ç®—
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
}

test "resource_scheduling_optimization" {
  // èµ„æºè°ƒåº¦ä¼˜åŒ–æµ‹è¯•
  let total_tasks = 127
  let workers = 8
  let hours_per_day = 8
  let working_days = 5
  
  // è®¡ç®—æ¯ä¸ªå·¥äººçš„ä»»åŠ¡é‡
  let tasks_per_worker = divide_with_ceil(total_tasks, workers)
  assert_eq(16, tasks_per_worker)  // ceil(127/8) = 16
  
  // è®¡ç®—æ€»å·¥ä½œæ—¶é•¿
  let total_hours = multiply(tasks_per_worker, workers)
  assert_eq(128, total_hours)
  
  // è®¡ç®—éœ€è¦çš„å¤©æ•°
  let days_needed = divide_with_ceil(total_hours, hours_per_day)
  assert_eq(16, days_needed)  // ceil(128/8) = 16
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(days_needed, working_days)
  assert_eq(4, weeks_needed)  // ceil(16/5) = 4
}

test "mathematical_series_analysis" {
  // æ•°å­¦çº§æ•°åˆ†ææµ‹è¯•
  // æ¨¡æ‹Ÿè°ƒå’Œçº§æ•°çš„éƒ¨åˆ†å’Œè®¡ç®—
  
  // è®¡ç®— H_n = 1 + 1/2 + 1/3 + ... + 1/n çš„è¿‘ä¼¼å€¼
  // ä½¿ç”¨æ•´æ•°è¿ç®—æ¨¡æ‹Ÿ
  let term1 = divide_with_ceil(1000, 1)
  let term2 = divide_with_ceil(1000, 2)
  let term3 = divide_with_ceil(1000, 3)
  let term4 = divide_with_ceil(1000, 4)
  let term5 = divide_with_ceil(1000, 5)
  
  let partial_sum = add(add(add(add(term1, term2), add(term3, term4)), term5))
  assert_eq(2834, partial_sum)  // 1000 + 500 + 334 + 250 + 200 = 2283 (å‘ä¸Šå–æ•´)
}

test "inventory_management_system" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯•
  let product_a_qty = 45
  let product_b_qty = 67
  let product_c_qty = 23
  
  let box_capacity_a = 12
  let box_capacity_b = 15
  let box_capacity_c = 8
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_a = divide_with_ceil(product_a_qty, box_capacity_a)
  let boxes_b = divide_with_ceil(product_b_qty, box_capacity_b)
  let boxes_c = divide_with_ceil(product_c_qty, box_capacity_c)
  
  assert_eq(4, boxes_a)   // ceil(45/12) = 4
  assert_eq(5, boxes_b)   // ceil(67/15) = 5
  assert_eq(3, boxes_c)   // ceil(23/8) = 3
  
  // è®¡ç®—æ€»ç®±å­æ•°é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(12, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = add(
    multiply(boxes_a, box_capacity_a),
    add(multiply(boxes_b, box_capacity_b), multiply(boxes_c, box_capacity_c))
  )
  assert_eq(156, total_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let total_products = add(add(product_a_qty, product_b_qty), product_c_qty)
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(21, remaining_space)
}

test "financial_calculations" {
  // é‡‘èè®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 8  // 8%
  let years = 4
  
  // ç®€åŒ–çš„å¹´åº¦å¤åˆ©è®¡ç®—
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  let year4_end = add(year3_end, divide_with_ceil(multiply(year3_end, annual_rate), 100))
  
  // éªŒè¯æ¯å¹´çš„å¤åˆ©å¢é•¿
  assert_eq(10800, year1_end)  // 10000 + 8%
  assert_eq(11664, year2_end)  // 10800 + 8%
  assert_eq(12597, year3_end)  // 11664 + 8%
  assert_eq(13605, year4_end)  // 12597 + 8%
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_return = subtract(year4_end, principal)
  assert_eq(3605, total_return)
  
  // è®¡ç®—æœˆä¾›ï¼ˆ4å¹´=48ä¸ªæœˆï¼‰
  let monthly_payment = divide_with_ceil(year4_end, multiply(years, 12))
  assert_eq(284, monthly_payment)  // ceil(13605/48)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•çš„æ‰§è¡Œæ­¥éª¤
  let linear_100 = multiply(100, 3)
  let linear_1000 = multiply(1000, 3)
  let linear_10000 = multiply(10000, 3)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•çš„æ‰§è¡Œæ­¥éª¤ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let log_100 = divide_with_ceil(100, 10)
  let log_1000 = divide_with_ceil(1000, 10)
  let log_10000 = divide_with_ceil(10000, 10)
  
  // æ¨¡æ‹ŸO(nÂ²)ç®—æ³•çš„æ‰§è¡Œæ­¥éª¤ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let quadratic_100 = divide_with_ceil(multiply(100, 100), 100)
  let quadratic_1000 = divide_with_ceil(multiply(1000, 1000), 10000)
  let quadratic_10000 = divide_with_ceil(multiply(10000, 10000), 100000)
  
  // éªŒè¯ä¸åŒç®—æ³•çš„å¤æ‚åº¦ç‰¹å¾
  assert_eq(300, linear_100)
  assert_eq(3000, linear_1000)
  assert_eq(30000, linear_10000)
  
  assert_eq(10, log_100)
  assert_eq(100, log_1000)
  assert_eq(1000, log_10000)
  
  assert_eq(100, quadratic_100)
  assert_eq(100, quadratic_1000)
  assert_eq(1000, quadratic_10000)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_initial_size = 0
  let push_operations = 5
  let pop_operations = 3
  
  let stack_after_push = add(stack_initial_size, push_operations)
  let stack_after_pop = subtract(stack_after_push, pop_operations)
  
  assert_eq(5, stack_after_push)
  assert_eq(2, stack_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 20
  let queue_enqueued = 15
  let queue_dequeued = 8
  
  let queue_current_size = subtract(queue_enqueued, queue_dequeued)
  let queue_remaining_capacity = subtract(queue_capacity, queue_current_size)
  
  assert_eq(7, queue_current_size)
  assert_eq(13, queue_remaining_capacity)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨è´Ÿè½½å› å­è®¡ç®—
  let hash_table_size = 16
  let occupied_slots = 11
  let load_factor = divide_with_ceil(multiply(occupied_slots, 100), hash_table_size)
  
  assert_eq(69, load_factor)  // ceil(11*100/16) = 69%
}

test "business_workflow_simulation" {
  // ä¸šåŠ¡å·¥ä½œæµæ¨¡æ‹Ÿæµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ
  
  // è®¢å•åŸºæœ¬ä¿¡æ¯
  let order_items = 47
  let items_per_box = 8
  let processing_time_per_box = 15  // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let boxes_needed = divide_with_ceil(order_items, items_per_box)
  assert_eq(6, boxes_needed)  // ceil(47/8) = 6
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_processing_time = multiply(boxes_needed, processing_time_per_box)
  assert_eq(90, total_processing_time)  // 6 * 15 = 90åˆ†é’Ÿ
  
  // è®¡ç®—å·¥ä½œå°æ—¶æ•°
  let processing_hours = divide_with_ceil(total_processing_time, 60)
  assert_eq(2, processing_hours)  // ceil(90/60) = 2å°æ—¶
  
  // è®¡ç®—é…é€æˆæœ¬
  let base_shipping_cost = 50
  let cost_per_box = 12
  let total_shipping_cost = add(base_shipping_cost, multiply(boxes_needed, cost_per_box))
  assert_eq(122, total_shipping_cost)  // 50 + 6*12 = 122
  
  // è®¡ç®—æ€»è®¢å•ä»·å€¼ï¼ˆå‡è®¾æ¯ä¸ªç‰©å“å¹³å‡ä»·å€¼25ï¼‰
  let average_item_value = 25
  let total_order_value = multiply(order_items, average_item_value)
  assert_eq(1175, total_order_value)  // 47 * 25 = 1175
  
  // è®¡ç®—é…é€æˆæœ¬å æ¯”
  let shipping_cost_percentage = divide_with_ceil(multiply(total_shipping_cost, 100), total_order_value)
  assert_eq(11, shipping_cost_percentage)  // ceil(122*100/1175) = 11%
}

// Azimuth é«˜è´¨é‡æµ‹è¯•å¥—ä»¶ - æ–°å¢8ä¸ªç²¾å¿ƒè®¾è®¡çš„æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive_coverage" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°çš„å„ç§åœºæ™¯
  assert_eq(8, add(3, 5))              // åŸºæœ¬æ­£æ•°åŠ æ³•
  assert_eq(0, add(0, 0))              // é›¶å€¼åŠ æ³•
  assert_eq(-8, add(-3, -5))           // è´Ÿæ•°åŠ æ³•
  assert_eq(2, add(-3, 5))             // æ··åˆç¬¦å·åŠ æ³•
  assert_eq(1000000, add(500000, 500000))  // å¤§æ•°åŠ æ³•
}

test "multiply_function_mathematical_properties" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„æ•°å­¦æ€§è´¨
  assert_eq(15, multiply(3, 5))         // åŸºæœ¬æ­£æ•°ä¹˜æ³•
  assert_eq(0, multiply(5, 0))          // é›¶ä¹˜æ³•ç‰¹æ€§
  assert_eq(-15, multiply(-3, 5))       // è´Ÿæ•°ä¹˜æ³•
  assert_eq(15, multiply(-3, -5))       // è´Ÿè´Ÿå¾—æ­£
  assert_eq(5, multiply(5, 1))          // å•ä½å…ƒç‰¹æ€§
}

test "greet_function_internationalization_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…åŒ–æ”¯æŒ
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, !", greet(""))  // ç©ºå­—ç¬¦ä¸²å¤„ç†
}

test "divide_with_ceil_business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—åœºæ™¯æµ‹è¯•
  let products = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(products, box_capacity)
  
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡è®¡ç®—
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, products)
  assert_eq(1, remaining_space)
}

test "complex_calculation_pipeline_project_management" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿ï¼šé¡¹ç›®ç®¡ç†åœºæ™¯
  let team_members = 5
  let tasks_per_member = 8
  let working_days = 6
  let tasks_per_day = divide_with_ceil(
    multiply(team_members, tasks_per_member), 
    working_days
  )
  
  assert_eq(7, tasks_per_day)  // ceil(40/6) = 7
  
  // éªŒè¯æ€»ä»»åŠ¡å®Œæˆèƒ½åŠ›
  let total_capacity = multiply(tasks_per_day, working_days)
  assert_eq(42, total_capacity)
}

test "mathematical_laws_verification" {
  // æ•°å­¦å®šå¾‹éªŒè¯æµ‹è¯•
  let x = 12
  let y = 7
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹éªŒè¯
  let distributive_left = multiply(x, add(y, 3))
  let distributive_right = add(multiply(x, y), multiply(x, 3))
  assert_eq(distributive_left, distributive_right)
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(-1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 100))
}

test "real_world_scenario_event_planning" {
  // çœŸå®ä¸–ç•Œåœºæ™¯ï¼šæ´»åŠ¨è§„åˆ’æµ‹è¯•
  let participants = 87
  let tables_available = 10
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // éªŒè¯æ¡Œå­æ˜¯å¦è¶³å¤Ÿ
  let total_seats_available = multiply(tables_available, chairs_per_table)
  assert_eq(80, total_seats_available)
  
  // è®¡ç®—ç¼ºå°‘çš„åº§ä½æ•°
  let seats_shortage = subtract(participants, total_seats_available)
  assert_eq(7, seats_shortage)
}

// æ–°å¢çš„9ä¸ªæµ‹è¯•ç”¨ä¾‹
test "advanced_arithmetic_sequences" {
  // æµ‹è¯•é«˜çº§ç®—æœ¯åºåˆ—
  let start = 5
  let sequence_sum = add(add(add(start, 1), add(start, 2)), add(start, 3))
  assert_eq(20, sequence_sum)  // 6 + 7 + 8 = 21
}

test "complex_string_processing" {
  // æµ‹è¯•å¤æ‚å­—ç¬¦ä¸²å¤„ç†
  let name1 = "Alice"
  let name2 = "Bob"
  let greeting1 = greet(name1)
  let greeting2 = greet(name2)
  assert_eq_string("Hello, Alice!", greeting1)
  assert_eq_string("Hello, Bob!", greeting2)
}

test "resource_planning_scenario" {
  // èµ„æºè§„åˆ’åœºæ™¯æµ‹è¯•
  let project_days = 15
  let team_size = 6
  let daily_hours = 8
  let total_hours = multiply(project_days, multiply(team_size, daily_hours))
  assert_eq(720, total_hours)  // 15 * 6 * 8 = 720
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  let n = 5
  let sum_of_first_n = multiply(n, add(n, 1)) / 2
  assert_eq(15, sum_of_first_n)  // 5 * 6 / 2 = 15
}

test "inventory_optimization" {
  // åº“å­˜ä¼˜åŒ–æµ‹è¯•
  let items_per_box = 12
  let total_items = 47
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  let total_capacity = multiply(boxes_needed, items_per_box)
  let wasted_space = subtract(total_capacity, total_items)
  assert_eq(5, boxes_needed)
  assert_eq(60, total_capacity)
  assert_eq(13, wasted_space)
}

test "financial_projection" {
  // è´¢åŠ¡é¢„æµ‹æµ‹è¯•
  let initial_investment = 10000
  let monthly_return = 500
  let months = 24
  let total_return = multiply(monthly_return, months)
  let final_amount = add(initial_investment, total_return)
  assert_eq(12000, total_return)
  assert_eq(22000, final_amount)
}

test "time_management_calculation" {
  // æ—¶é—´ç®¡ç†è®¡ç®—æµ‹è¯•
  let tasks = 25
  let hours_per_task = 2
  let working_hours_per_day = 8
  let total_hours_needed = multiply(tasks, hours_per_task)
  let days_needed = divide_with_ceil(total_hours_needed, working_hours_per_day)
  assert_eq(50, total_hours_needed)
  assert_eq(7, days_needed)
}

test "space_planning_scenario" {
  // ç©ºé—´è§„åˆ’åœºæ™¯æµ‹è¯•
  let room_area = 100
  let desk_area = 8
  let desks_per_room = divide_with_ceil(room_area, desk_area)
  let total_desk_area = multiply(desks_per_room, desk_area)
  let remaining_space = subtract(room_area, total_desk_area)
  assert_eq(13, desks_per_room)
  assert_eq(104, total_desk_area)
  assert_true(remaining_space < 0)  // ç©ºé—´ä¸è¶³
}

test "performance_metrics" {
  // æ€§èƒ½æŒ‡æ ‡æµ‹è¯•
  let baseline = 100
  let improvement1 = 15
  let improvement2 = 25
  let final_performance = add(add(baseline, improvement1), improvement2)
  let improvement_percentage = divide_with_ceil(multiply(final_performance, 100), baseline) - 100
  assert_eq(140, final_performance)
  assert_eq(40, improvement_percentage)
}

// æ–°å¢çš„é«˜çº§ MoonBit æµ‹è¯•ç”¨ä¾‹ - 8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_conditions" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæ¡ä»¶
  // æ¥è¿‘ Int æœ€å¤§å€¼å’Œæœ€å°å€¼çš„è¿ç®—
  assert_eq(2147483646, add(2147483645, 1))
  assert_eq(-2147483647, add(-2147483646, -1))
  assert_eq(2147483646, multiply(46340, 46341))  // æ¥è¿‘ sqrt(Int.max)
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(0, divide_with_ceil(-2147483647, 2147483646))
}

test "financial_calculations" {
  // é‡‘èè®¡ç®—åœºæ™¯æµ‹è¯•
  // è´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 250000
  let monthly_payment = 8500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(30, months_needed)  // ceil(250000/8500) = 30
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(255000, total_payment)
  
  // è®¡ç®—æœ€åä¸€æœŸå®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(loan_amount, multiply(months_needed - 1, monthly_payment))
  assert_eq(5000, final_payment)
}

test "complex_nested_operations" {
  // å¤æ‚åµŒå¥—è¿ç®—æµ‹è¯•
  let base = 15
  
  // åµŒå¥—è®¡ç®—ï¼šceil((base*3 + base*2) / (base + ceil(base/3)))
  let numerator = add(multiply(base, 3), multiply(base, 2))
  let denominator = add(base, divide_with_ceil(base, 3))
  let result = divide_with_ceil(numerator, denominator)
  
  // æ‰‹åŠ¨éªŒè¯ï¼šceil((45+30)/(15+5)) = ceil(75/20) = 4
  assert_eq(4, result)
}

test "resource_optimization_problem" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // ä»“åº“å­˜å‚¨ä¼˜åŒ–ï¼šå¤šç§ç‰©å“çš„è£…ç®±é—®é¢˜
  let item1_qty = 47
  let item1_cap = 8   // ceil(47/8) = 6
  let item2_qty = 89
  let item2_cap = 12  // ceil(89/12) = 8
  let item3_qty = 156
  let item3_cap = 20 // ceil(156/20) = 8
  
  let boxes1 = divide_with_ceil(item1_qty, item1_cap)
  let boxes2 = divide_with_ceil(item2_qty, item2_cap)
  let boxes3 = divide_with_ceil(item3_qty, item3_cap)
  
  let total_boxes = add(add(boxes1, boxes2), boxes3)
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å®¹é‡å’Œåˆ©ç”¨ç‡
  let total_capacity = add(
    multiply(boxes1, item1_cap),
    add(multiply(boxes2, item2_cap), multiply(boxes3, item3_cap))
  )
  let total_items = add(add(item1_qty, item2_qty), item3_qty)
  let utilization = divide_with_ceil(multiply(total_items, 100), total_capacity)
  
  assert_eq(292, total_capacity)  // 48 + 96 + 160
  assert_eq(92, utilization)      // floor(29200/292) = 100%ï¼Œä½†ä½¿ç”¨ceil
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’Œç¼–ç 
  assert_eq_string("Hello, ğŸŒ™â­âœ¨!", greet("ğŸŒ™â­âœ¨"))
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, 'single'!", greet("'single'"))
  assert_eq_string("Hello, \\backslash!", greet("\\backslash"))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, emoji ğŸ‰ğŸš€ğŸŒŸ!", greet("emoji ğŸ‰ğŸš€ğŸŒŸ"))
  assert_eq_string("Hello, ä¸­æ–‡å­—ç¬¦!", greet("ä¸­æ–‡å­—ç¬¦"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
}

test "performance_large_scale_computations" {
  // å¤§è§„æ¨¡è®¡ç®—æ€§èƒ½æµ‹è¯•
  let large_num = 100000
  let iterations = 1000
  
  // å¤§æ•°è¿ç®—
  let sum_result = add(large_num, multiply(large_num, 9))
  let product_result = multiply(large_num, iterations)
  let division_result = divide_with_ceil(product_result, large_num)
  
  assert_eq(1000000, sum_result)      // 100000 + 100000*9
  assert_eq(100000000, product_result) // 100000 * 1000
  assert_eq(1000, division_result)     // ceil(100000000/100000)
  
  // è¿ç»­è¿ç®—é“¾
  let chain_result = divide_with_ceil(
    multiply(
      add(large_num, 50000),
      divide_with_ceil(iterations, 100)
    ),
    add(100, divide_with_ceil(large_num, 10000))
  )
  assert_eq(7500, chain_result)
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // å„ç§é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå°é™¤æ•°æµ‹è¯•
  assert_eq(100000, divide_with_ceil(99999, 1))
  assert_eq(-99999, divide_with_ceil(-99999, 1))
  assert_eq(50000, divide_with_ceil(99999, 2))
  
  // è¾¹ç•Œå€¼ç»„åˆ
  assert_eq(1, divide_with_ceil(1, 2147483647))
  assert_eq(0, divide_with_ceil(-1, 2147483647))
  assert_eq(-1, divide_with_ceil(1, -2147483647))
}

test "real_world_scheduling_problem" {
  // çœŸå®ä¸–ç•Œè°ƒåº¦é—®é¢˜æµ‹è¯•
  // æ´»åŠ¨å®‰æ’ï¼šä¼šè®®å®¤åˆ†é…
  let total_participants = 342
  
  // è®¡ç®—æ¯ç§ä¼šè®®å®¤éœ€è¦çš„æ•°é‡
  let rooms_50 = divide_with_ceil(total_participants, 50)
  let rooms_30 = divide_with_ceil(total_participants, 30)
  let rooms_20 = divide_with_ceil(total_participants, 20)
  let rooms_15 = divide_with_ceil(total_participants, 15)
  let rooms_10 = divide_with_ceil(total_participants, 10)
  
  assert_eq(7, rooms_50)   // ceil(342/50) = 7
  assert_eq(12, rooms_30)  // ceil(342/30) = 12
  assert_eq(18, rooms_20)  // ceil(342/20) = 18
  assert_eq(23, rooms_15)  // ceil(342/15) = 23
  assert_eq(35, rooms_10)  // ceil(342/10) = 35
  
  // è®¡ç®—æœ€ä¼˜æ–¹æ¡ˆï¼ˆä½¿ç”¨50äººä¼šè®®å®¤ï¼‰
  let total_capacity_50 = multiply(rooms_50, 50)
  let wasted_seats_50 = subtract(total_capacity_50, total_participants)
  let efficiency_50 = divide_with_ceil(multiply(total_participants, 100), total_capacity_50)
  
  assert_eq(350, total_capacity_50)  // 7 * 50
  assert_eq(8, wasted_seats_50)      // 350 - 342
  assert_eq(98, efficiency_50)       // ceil(34200/350)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_basic_arithmetic" {
  // æµ‹è¯•åŸºæœ¬ç®—æœ¯è¿ç®—
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_support" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_logistics_scenario" {
  // çœŸå®ä¸–ç•Œç‰©æµåœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—ä»“åº“å­˜å‚¨éœ€æ±‚
  let products = 157
  let pallet_capacity = 24
  let pallets_needed = divide_with_ceil(products, pallet_capacity)
  assert_eq(7, pallets_needed)  // ceil(157/24) = 7
  
  // è®¡ç®—æ€»å­˜å‚¨ç©ºé—´
  let total_space = multiply(pallets_needed, pallet_capacity)
  assert_eq(168, total_space)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_space, products)
  assert_eq(11, remaining_space)
}




// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(15, add(7, 8))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-3, -7))
  assert_eq(4, add(-5, 9))
}

test "multiplication_properties" {
  // ä¹˜æ³•æ€§è´¨æµ‹è¯•
  assert_eq(21, multiply(3, 7))
  assert_eq(0, multiply(5, 0))
  assert_eq(-12, multiply(-3, 4))
  assert_eq(12, multiply(-3, -4))
  assert_eq(100, multiply(10, 10))
}

test "greet_function_variations" {
  // é—®å€™å‡½æ•°å˜åŒ–æµ‹è¯•
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "divide_with_ceil_scenarios" {
  // å‘ä¸Šå–æ•´é™¤æ³•åœºæ™¯æµ‹è¯•
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(2, 2))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(10, 0))
}

test "negative_number_operations" {
  // è´Ÿæ•°è¿ç®—æµ‹è¯•
  assert_eq(-5, add(-2, -3))
  assert_eq(2, add(-5, 7))
  assert_eq(15, multiply(-3, -5))
  assert_eq(-15, multiply(-3, 5))
  assert_eq(-2, divide_with_ceil(-5, 3))
}

test "complex_calculation_chain" {
  // å¤æ‚è®¡ç®—é“¾æµ‹è¯•
  let result = divide_with_ceil(add(multiply(3, 4), multiply(2, 5)), 7)
  assert_eq(4, result)  // ceil((12 + 10) / 7) = ceil(22/7) = 4
}

test "business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—æµ‹è¯•
  let items = 25
  let box_capacity = 6
  let boxes_needed = divide_with_ceil(items, box_capacity)
  assert_eq(5, boxes_needed)
  
  let total_capacity = multiply(boxes_needed, box_capacity)
  let remaining_space = subtract(total_capacity, items)
  assert_eq(5, remaining_space)
}

test "mathematical_commutative_law" {
  // æ•°å­¦äº¤æ¢å¾‹æµ‹è¯•
  let a = 13
  let b = 17
  assert_eq(add(a, b), add(b, a))
  assert_eq(multiply(a, b), multiply(b, a))
}

test "resource_allocation_problem" {
  // èµ„æºåˆ†é…é—®é¢˜æµ‹è¯•
  let total_resources = 47
  let teams = 4
  let resources_per_team = divide_with_ceil(total_resources, teams)
  assert_eq(12, resources_per_team)
  
  let total_allocated = multiply(resources_per_team, teams)
  assert_eq(48, total_allocated)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, space!", greet("space"))
  assert_eq_string("Hello, special@chars!", greet("special@chars"))
  assert_eq_string("Hello, emoji ğŸŒŸ!", greet("emoji ğŸŒŸ"))
  assert_eq_string("Hello, mixedCASE123!", greet("mixedCASE123"))
}

// æ–°å¢çš„ç‹¬ç‰¹æµ‹è¯•ç”¨ä¾‹
test "unique_azimuth_test_12345" {
  assert_eq(7, add(3, 4))
  assert_eq(6, multiply(2, 3))
  assert_eq_string("Hello, Test!", greet("Test"))
}

// æ–°å¢çš„8ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "arithmetic_operations_comprehensive" {
  // ç»¼åˆç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(40, add(15, 25))
  assert_eq(-5, add(-10, 5))
  assert_eq(42, multiply(6, 7))
  assert_eq(-12, multiply(-4, 3))
  assert_eq(4, divide_with_ceil(20, 6))
  assert_eq(5, divide_with_ceil(25, 5))
}

test "string_handling_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_identities" {
  // æ•°å­¦æ’ç­‰å¼æµ‹è¯•
  let x = 17
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(-x, multiply(x, -1))
}

test "business_logic_inventory" {
  // åº“å­˜ç®¡ç†ä¸šåŠ¡é€»è¾‘æµ‹è¯•
  let total_products = 158
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  assert_eq(7, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  assert_eq(168, multiply(boxes_needed, box_capacity))
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  assert_eq(10, subtract(multiply(boxes_needed, box_capacity), total_products))
}

test "error_handling_scenarios" {
  // é”™è¯¯å¤„ç†åœºæ™¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "complex_calculation_workflow" {
  // å¤æ‚è®¡ç®—å·¥ä½œæµæµ‹è¯•
  // åœºæ™¯ï¼šé¡¹ç›®æˆæœ¬è®¡ç®—
  let team_size = 5
  let hourly_rate = 75
  let hours_per_day = 8
  let project_days = 12
  
  // è®¡ç®—æ€»å·¥æ—¶
  let total_hours = multiply(team_size, multiply(hours_per_day, project_days))
  assert_eq(480, total_hours)
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = multiply(total_hours, hourly_rate)
  assert_eq(36000, total_cost)
  
  // è®¡ç®—æ”¯ä»˜å‘¨æœŸï¼ˆæ¯å‘¨æœŸä¸è¶…è¿‡10000ï¼‰
  let payment_cycles = divide_with_ceil(total_cost, 10000)
  assert_eq(4, payment_cycles)
}

test "algorithm_efficiency_comparison" {
  // ç®—æ³•æ•ˆç‡æ¯”è¾ƒæµ‹è¯•
  let input_size = 1000
  
  // çº¿æ€§ç®—æ³•æ¨¡æ‹Ÿ
  let linear_steps = multiply(input_size, 3)
  assert_eq(3000, linear_steps)
  
  // å¯¹æ•°ç®—æ³•æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let log_steps = divide_with_ceil(input_size, 100)
  assert_eq(10, log_steps)
  
  // éªŒè¯æ•ˆç‡å·®å¼‚
  assert_eq(300, divide_with_ceil(linear_steps, log_steps))
}

test "resource_optimization_problem" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory = 32768  // GB
  let servers = 7
  let memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(4682, memory_per_server)
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, servers)
  assert_eq(32774, total_allocated)
  
  // è®¡ç®—å†…å­˜æµªè´¹
  assert_eq(6, subtract(total_allocated, total_memory))
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥
  let optimized_servers = servers + 1
  let optimized_memory_per_server = divide_with_ceil(total_memory, optimized_servers)
  assert_eq(4097, optimized_memory_per_server)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "financial_calculation_basic" {
  // åŸºæœ¬é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate = 5  // 5%
  
  // ç®€å•çš„å¤åˆ©è®¡ç®—
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate), 100))
  
  assert_eq(10500, year1)  // 10000 + 5%
  assert_eq(11025, year2)  // 10500 + 5%
  assert_eq(11576, year3)  // 11025 + 5%
}

test "inventory_packaging_optimization" {
  // åº“å­˜åŒ…è£…ä¼˜åŒ–æµ‹è¯•
  let items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(items, box_capacity)
  
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, items)
  assert_eq(1, remaining_space)
}

test "resource_allocation_scenario" {
  // èµ„æºåˆ†é…åœºæ™¯æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  let budget_per_person = divide_with_ceil(total_budget, team_members)
  
  assert_eq(1667, budget_per_person)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…
  let total_allocated = multiply(budget_per_person, team_members)
  assert_eq(10002, total_allocated)
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 10
  let multiplier = 3
  let divisor = 4
  
  // è®¡ç®—æµç¨‹ï¼š((base * multiplier) / divisor)
  let step1 = multiply(base_value, multiplier)
  let step2 = divide_with_ceil(step1, divisor)
  
  assert_eq(30, step1)  // 10 * 3 = 30
  assert_eq(8, step2)   // ceil(30/4) = 8
}

test "mathematical_properties_verification" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 15
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹éªŒè¯
  let distributive_left = multiply(x, add(y, 2))
  let distributive_right = add(multiply(x, y), multiply(x, 2))
  assert_eq(distributive_left, distributive_right)
}

test "error_handling_boundary_conditions" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(1, divide_with_ceil(100, 100))
}

test "string_processing_international" {
  // å­—ç¬¦ä¸²å¤„ç†å›½é™…åŒ–æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, empty!", greet(""))
}

test "business_logic_integration" {
  // ä¸šåŠ¡é€»è¾‘é›†æˆæµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•è®¡ç®—
  let items_count = 25
  let item_price = 199
  let shipping_per_box = 50
  let items_per_box = 10
  
  // è®¡ç®—å•†å“æ€»ä»·
  let subtotal = multiply(items_count, item_price)
  
  // è®¡ç®—éœ€è¦çš„ç®±æ•°
  let boxes_needed = divide_with_ceil(items_count, items_per_box)
  
  // è®¡ç®—è¿è´¹
  let shipping_cost = multiply(boxes_needed, shipping_per_box)
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = add(subtotal, shipping_cost)
  
  assert_eq(4975, subtotal)      // 25 * 199 = 4975
  assert_eq(3, boxes_needed)     // ceil(25/10) = 3
  assert_eq(150, shipping_cost)  // 3 * 50 = 150
  assert_eq(5125, total_cost)    // 4975 + 150 = 5125
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "extreme_numerical_values" {
  // æµ‹è¯•æç«¯æ•°å€¼å¤„ç†
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(0, divide_with_ceil(-2147483647, 2147483647))
}

test "nested_function_calls" {
  // æµ‹è¯•åµŒå¥—å‡½æ•°è°ƒç”¨
  let result = divide_with_ceil(
    add(multiply(5, 3), multiply(2, 4)),
    subtract(10, 2)
  )
  assert_eq(3, result)  // ceil((5*3 + 2*4) / (10-2)) = ceil(23/8) = 3
}

test "error_recovery_scenarios" {
  // æµ‹è¯•é”™è¯¯æ¢å¤åœºæ™¯
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(-100, 0))  // è´Ÿæ•°é™¤é›¶é”™è¯¯å¤„ç†
  
  // é”™è¯¯æ¢å¤åçš„è¿ç»­è®¡ç®—
  let safe_result = add(divide_with_ceil(10, 0), multiply(5, 2))
  assert_eq(10, safe_result)  // 0 + 10 = 10
}

test "performance_related_operations" {
  // æµ‹è¯•æ€§èƒ½ç›¸å…³æ“ä½œ
  let large_number = 100000
  let iterations = 100
  
  // æ‰¹é‡æ“ä½œæ€§èƒ½æµ‹è¯•
  let batch_sum = add(large_number, multiply(large_number, iterations))
  assert_eq(10100000, batch_sum)  // 100000 + 100000*100 = 10100000
  
  // åˆ†æ‰¹å¤„ç†æµ‹è¯•
  let batch_size = 1000
  let total_items = 10500
  let batches_needed = divide_with_ceil(total_items, batch_size)
  assert_eq(11, batches_needed)  // ceil(10500/1000) = 11
}

test "data_type_compatibility" {
  // æµ‹è¯•æ•°æ®ç±»å‹å…¼å®¹æ€§
  // æµ‹è¯•æ•´æ•°è¾¹ç•Œ
  assert_eq(0, add(2147483647, -2147483647))
  assert_eq(-1, add(-2147483648, 2147483647))
  
  // æµ‹è¯•ä¹˜æ³•æº¢å‡ºè¾¹ç•Œ
  assert_eq(46340, multiply(46340, 1))  // sqrt(2^31-1)çš„æ•´æ•°éƒ¨åˆ†
  assert_eq(0, multiply(46340, 0))
  
  // æµ‹è¯•é™¤æ³•ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(100, divide_with_ceil(199, 2))
}

test "business_inventory_management" {
  // ä¸šåŠ¡åœºæ™¯ï¼šåº“å­˜ç®¡ç†æµ‹è¯•
  let product_a_qty = 156
  let product_b_qty = 89
  let product_c_qty = 234
  let box_capacity = 25
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_a = divide_with_ceil(product_a_qty, box_capacity)  // ceil(156/25) = 7
  let boxes_b = divide_with_ceil(product_b_qty, box_capacity)  // ceil(89/25) = 4
  let boxes_c = divide_with_ceil(product_c_qty, box_capacity)  // ceil(234/25) = 10
  
  // è®¡ç®—æ€»ç®±å­æ•°é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(21, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = multiply(total_boxes, box_capacity)
  assert_eq(525, total_capacity)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let total_products = add(add(product_a_qty, product_b_qty), product_c_qty)
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(46, remaining_space)
}

test "algorithm_efficiency_comparison" {
  // ç®—æ³•æ•ˆç‡æ¯”è¾ƒæµ‹è¯•
  let input_size = 1000
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_time = multiply(input_size, 5)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºå‘ä¸Šå–æ•´ï¼‰
  let log_time = divide_with_ceil(input_size, 10)
  
  // æ¨¡æ‹ŸO(n^2)ç®—æ³•
  let quadratic_time = multiply(input_size, input_size)
  
  // éªŒè¯ç®—æ³•å¤æ‚åº¦ç‰¹å¾
  assert_eq(5000, linear_time)
  assert_eq(100, log_time)
  assert_eq(1000000, quadratic_time)
  
  // è®¡ç®—æ•ˆç‡æ¯”ç‡
  let linear_to_log_ratio = divide_with_ceil(linear_time, log_time)
  assert_eq(50, linear_to_log_ratio)
}

test "advanced_string_operations" {
  // é«˜çº§å­—ç¬¦ä¸²æ“ä½œæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, JSON!", greet("JSON"))
  assert_eq_string("Hello, XML!", greet("XML"))
  assert_eq_string("Hello, HTTP!", greet("HTTP"))
  assert_eq_string("Hello, API!", greet("API"))
  assert_eq_string("Hello, SQL!", greet("SQL"))
  
  // æµ‹è¯•æ•°å­—å’Œå­—æ¯æ··åˆ
  assert_eq_string("Hello, v1.0!", greet("v1.0"))
  assert_eq_string("Hello, 2023!", greet("2023"))
  assert_eq_string("Hello, A1B2C3!", greet("A1B2C3"))
}

test "mathematical_theorems_validation" {
  // æ•°å­¦å®šç†éªŒè¯æµ‹è¯•
  // éªŒè¯å‹¾è‚¡å®šç†ï¼ˆ3-4-5ä¸‰è§’å½¢ï¼‰
  let a = 3
  let b = 4
  let c = 5
  let a_squared = multiply(a, a)
  let b_squared = multiply(b, b)
  let c_squared = multiply(c, c)
  let pythagorean_sum = add(a_squared, b_squared)
  assert_eq(pythagorean_sum, c_squared)  // 3^2 + 4^2 = 5^2
  
  // éªŒè¯ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼
  let first_term = 1
  let last_term = 100
  let number_of_terms = 100
  let arithmetic_sum = divide_with_ceil(
    multiply(number_of_terms, add(first_term, last_term)),
    2
  )
  assert_eq(5050, arithmetic_sum)  // 100*(1+100)/2 = 5050
}

test "real_world_financial_calculation" {
  // çœŸå®ä¸–ç•Œé‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè´·æ¬¾è®¡ç®—å’ŒæŠ•èµ„å›æŠ¥
  let principal = 50000
  let annual_rate = 6  // 6%
  let years = 5
  
  // è®¡ç®—ç®€å•åˆ©æ¯
  let simple_interest = divide_with_ceil(multiply(principal, annual_rate), 100)
  let yearly_interest = simple_interest
  let total_interest = multiply(yearly_interest, years)
  let total_payment = add(principal, total_interest)
  
  assert_eq(3000, yearly_interest)  // 50000 * 6% = 3000
  assert_eq(15000, total_interest)  // 3000 * 5 = 15000
  assert_eq(65000, total_payment)  // 50000 + 15000 = 65000
  
  // è®¡ç®—æœˆä¾›
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  assert_eq(1084, monthly_payment)  // ceil(65000/60) = 1084
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "inventory_management_system" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯•ï¼šè®¡ç®—è¡¥è´§éœ€æ±‚
  let current_stock = 156
  let daily_demand = 23
  let lead_time_days = 7
  let safety_stock = 50
  
  // è®¡ç®—è¡¥è´§æœŸé—´çš„æ€»éœ€æ±‚
  let total_demand = multiply(daily_demand, lead_time_days)
  assert_eq(161, total_demand)  // 23 * 7 = 161
  
  // è®¡ç®—è¡¥è´§ç‚¹
  let reorder_point = add(total_demand, safety_stock)
  assert_eq(211, reorder_point)  // 161 + 50 = 211
  
  // è®¡ç®—éœ€è¦è¡¥è´§çš„æ•°é‡
  let reorder_quantity = divide_with_ceil(reorder_point, 100) * 100
  assert_eq(300, reorder_quantity)  // ceil(211/100) * 100 = 300
}

test "project_resource_allocation" {
  // é¡¹ç›®èµ„æºåˆ†é…æµ‹è¯•
  let total_hours = 480
  let team_members = 8
  let work_days = 15
  
  // è®¡ç®—æ¯äººæ¯å¤©çš„å·¥ä½œå°æ—¶æ•°
  let hours_per_person_per_day = divide_with_ceil(total_hours, multiply(team_members, work_days))
  assert_eq(4, hours_per_person_per_day)  // ceil(480/(8*15)) = 4
  
  // éªŒè¯æ€»å·¥æ—¶è®¡ç®—
  let calculated_total = multiply(hours_per_person_per_day, multiply(team_members, work_days))
  assert_eq(480, calculated_total)
  
  // è®¡ç®—å®é™…å¯ç”¨å·¥æ—¶
  let available_hours = multiply(team_members, multiply(hours_per_person_per_day, work_days))
  assert_eq(480, available_hours)
}

test "financial_loan_calculation" {
  // é‡‘èè´·æ¬¾è®¡ç®—æµ‹è¯•
  let loan_amount = 250000
  let interest_rate = 6  // 6%
  let loan_years = 30
  
  // è®¡ç®—æ€»åˆ©æ¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_interest = divide_with_ceil(multiply(loan_amount, multiply(interest_rate, loan_years)), 100)
  assert_eq(450000, total_interest)  // ceil(250000 * 6 * 30 / 100) = 450000
  
  // è®¡ç®—æ€»è¿˜æ¬¾é¢
  let total_payment = add(loan_amount, total_interest)
  assert_eq(700000, total_payment)
  
  // è®¡ç®—æœˆä¾›
  let total_months = multiply(loan_years, 12)
  let monthly_payment = divide_with_ceil(total_payment, total_months)
  assert_eq(1945, monthly_payment)  // ceil(700000/360) = 1945
}

test "event_planning_capacity" {
  // æ´»åŠ¨è§„åˆ’å®¹é‡æµ‹è¯•
  let expected_guests = 247
  let tables_per_room = 12
  let chairs_per_table = 8
  let rooms_available = 3
  
  // è®¡ç®—æ¯ä¸ªæˆ¿é—´çš„å®¹é‡
  let capacity_per_room = multiply(tables_per_room, chairs_per_table)
  assert_eq(96, capacity_per_room)  // 12 * 8 = 96
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(capacity_per_room, rooms_available)
  assert_eq(288, total_capacity)  // 96 * 3 = 288
  
  // è®¡ç®—éœ€è¦çš„æˆ¿é—´æ•°
  let rooms_needed = divide_with_ceil(expected_guests, capacity_per_room)
  assert_eq(3, rooms_needed)  // ceil(247/96) = 3
  
  // éªŒè¯å®¹é‡å……è¶³
  assert_true(total_capacity >= expected_guests)
}

test "manufacturing_production_batch" {
  // åˆ¶é€ ä¸šç”Ÿäº§æ‰¹æ¬¡æµ‹è¯•
  let daily_target = 1250
  let machine_capacity_per_hour = 85
  let working_hours = 8
  let defect_rate = 3  // 3%
  
  // è®¡ç®—ç†è®ºæ—¥äº§é‡
  let theoretical_daily = multiply(machine_capacity_per_hour, working_hours)
  assert_eq(680, theoretical_daily)  // 85 * 8 = 680
  
  // è®¡ç®—è€ƒè™‘ç¼ºé™·ç‡çš„å®é™…äº§é‡
  let actual_production = subtract(theoretical_daily, divide_with_ceil(multiply(theoretical_daily, defect_rate), 100))
  assert_eq(660, actual_production)  // 680 - ceil(680*3/100) = 660
  
  // è®¡ç®—éœ€è¦çš„æœºå™¨æ•°é‡
  let machines_needed = divide_with_ceil(daily_target, actual_production)
  assert_eq(2, machines_needed)  // ceil(1250/660) = 2
  
  // è®¡ç®—å®é™…æ€»äº§é‡
  let total_production = multiply(actual_production, machines_needed)
  assert_eq(1320, total_production)  // 660 * 2 = 1320
}

test "cloud_resource_scaling" {
  // äº‘èµ„æºæ‰©å±•æµ‹è¯•
  let current_users = 5000
  let expected_growth = 150  // 150%
  let server_capacity = 1000
  let buffer_percentage = 20  // 20%
  
  // è®¡ç®—é¢„æœŸç”¨æˆ·æ•°
  let expected_users = add(current_users, divide_with_ceil(multiply(current_users, expected_growth), 100))
  assert_eq(12500, expected_users)  // 5000 + ceil(5000*150/100) = 12500
  
  // è®¡ç®—åŸºç¡€æœåŠ¡å™¨éœ€æ±‚
  let base_servers = divide_with_ceil(expected_users, server_capacity)
  assert_eq(13, base_servers)  // ceil(12500/1000) = 13
  
  // è®¡ç®—ç¼“å†²æœåŠ¡å™¨
  let buffer_servers = divide_with_ceil(multiply(base_servers, buffer_percentage), 100)
  assert_eq(3, buffer_servers)  // ceil(13*20/100) = 3
  
  // è®¡ç®—æ€»æœåŠ¡å™¨æ•°
  let total_servers = add(base_servers, buffer_servers)
  assert_eq(16, total_servers)  // 13 + 3 = 16
}

test "educational_class_scheduling" {
  // æ•™è‚²è¯¾ç¨‹å®‰æ’æµ‹è¯•
  let total_students = 285
  let max_class_size = 30
  let teachers_available = 12
  let subjects_per_student = 6
  
  // è®¡ç®—éœ€è¦çš„ç­çº§æ•°
  let classes_needed = divide_with_ceil(total_students, max_class_size)
  assert_eq(10, classes_needed)  // ceil(285/30) = 10
  
  // è®¡ç®—æ¯ä¸ªæ•™å¸ˆçš„ç­çº§è´Ÿæ‹…
  let classes_per_teacher = divide_with_ceil(classes_needed, teachers_available)
  assert_eq(1, classes_per_teacher)  // ceil(10/12) = 1
  
  // è®¡ç®—æ€»è¯¾æ—¶éœ€æ±‚
  let total_class_periods = multiply(classes_needed, subjects_per_student)
  assert_eq(60, total_class_periods)  // 10 * 6 = 60
  
  // è®¡ç®—æ¯ä¸ªæ•™å¸ˆçš„è¯¾æ—¶è´Ÿæ‹…
  let periods_per_teacher = divide_with_ceil(total_class_periods, teachers_available)
  assert_eq(5, periods_per_teacher)  // ceil(60/12) = 5
}

test "logistics_delivery_optimization" {
  // ç‰©æµé…é€ä¼˜åŒ–æµ‹è¯•
  let total_packages = 1847
  let truck_capacity = 120
  let delivery_routes = 8
  let average_delivery_time = 45  // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„å¡è½¦æ•°
  let trucks_needed = divide_with_ceil(total_packages, truck_capacity)
  assert_eq(16, trucks_needed)  // ceil(1847/120) = 16
  
  // è®¡ç®—æ¯æ¡è·¯çº¿çš„åŒ…è£¹æ•°
  let packages_per_route = divide_with_ceil(total_packages, delivery_routes)
  assert_eq(231, packages_per_route)  // ceil(1847/8) = 231
  
  // è®¡ç®—æ€»é…é€æ—¶é—´ï¼ˆå°æ—¶ï¼‰
  let total_delivery_time = multiply(delivery_routes, divide_with_ceil(average_delivery_time, 60))
  assert_eq(8, total_delivery_time)  // 8 * ceil(45/60) = 8
  
  // è®¡ç®—æ¯è¾†å¡è½¦çš„è·¯çº¿æ•°
  let routes_per_truck = divide_with_ceil(delivery_routes, trucks_needed)
  assert_eq(1, routes_per_truck)  // ceil(8/16) = 1
}

test "healthcare_patient_flow" {
  // åŒ»ç–—ä¿å¥æ‚£è€…æµç¨‹æµ‹è¯•
  let daily_patients = 145
  let doctors_available = 8
  let consultation_time = 20  // åˆ†é’Ÿ
  let working_hours = 8
  
  // è®¡ç®—æ¯ä¸ªåŒ»ç”Ÿçš„æ‚£è€…æ•°
  let patients_per_doctor = divide_with_ceil(daily_patients, doctors_available)
  assert_eq(19, patients_per_doctor)  // ceil(145/8) = 19
  
  // è®¡ç®—æ¯ä¸ªåŒ»ç”Ÿçš„å·¥ä½œæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
  let doctor_time_minutes = multiply(patients_per_doctor, consultation_time)
  assert_eq(380, doctor_time_minutes)  // 19 * 20 = 380
  
  // è®¡ç®—æ¯ä¸ªåŒ»ç”Ÿçš„å·¥ä½œæ—¶é—´ï¼ˆå°æ—¶ï¼‰
  let doctor_time_hours = divide_with_ceil(doctor_time_minutes, 60)
  assert_eq(7, doctor_time_hours)  // ceil(380/60) = 7
  
  // éªŒè¯å·¥ä½œæ—¶é—´ä¸è¶…è¿‡å¯ç”¨æ—¶é—´
  assert_true(doctor_time_hours <= working_hours)
  
  // è®¡ç®—æ€»è¯Šç–—æ—¶é—´
  let total_consultation_time = multiply(daily_patients, consultation_time)
  assert_eq(2900, total_consultation_time)  // 145 * 20 = 2900
}

test "agricultural_harvest_planning" {
  // å†œä¸šæ”¶è·è§„åˆ’æµ‹è¯•
  let field_area = 450  // å…¬é¡·
  let yield_per_hectare = 2800  // å…¬æ–¤
  let storage_capacity = 800000  // å…¬æ–¤
  let harvest_days = 15
  
  // è®¡ç®—é¢„æœŸæ€»äº§é‡
  let expected_yield = multiply(field_area, yield_per_hectare)
  assert_eq(1260000, expected_yield)  // 450 * 2800 = 1260000
  
  // è®¡ç®—éœ€è¦çš„å­˜å‚¨è®¾æ–½æ•°
  let storage_facilities = divide_with_ceil(expected_yield, storage_capacity)
  assert_eq(2, storage_facilities)  // ceil(1260000/800000) = 2
  
  // è®¡ç®—æ¯æ—¥æ”¶è·é‡
  let daily_harvest = divide_with_ceil(expected_yield, harvest_days)
  assert_eq(84000, daily_harvest)  // ceil(1260000/15) = 84000
  
  // è®¡ç®—æ¯æ—¥éœ€è¦çš„è¿è¾“èƒ½åŠ›
  let daily_transport_capacity = divide_with_ceil(daily_harvest, storage_capacity)
  assert_eq(1, daily_transport_capacity)  // ceil(84000/800000) = 1
  
  // éªŒè¯æ€»å­˜å‚¨å®¹é‡å……è¶³
  let total_storage_capacity = multiply(storage_facilities, storage_capacity)
  assert_eq(1600000, total_storage_capacity)  // 2 * 800000 = 1600000
  assert_true(total_storage_capacity >= expected_yield)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "recursive_calculation_simulation" {
  // é€’å½’è®¡ç®—æ¨¡æ‹Ÿæµ‹è¯• - ä½¿ç”¨ç°æœ‰å‡½æ•°æ¨¡æ‹Ÿé€’å½’è®¡ç®—è¿‡ç¨‹
  // æ¨¡æ‹Ÿè®¡ç®—é˜¶ä¹˜çš„é€’å½’è¿‡ç¨‹ï¼š5! = 5 * 4 * 3 * 2 * 1
  let n = 5
  
  // ä½¿ç”¨è¿­ä»£æ–¹å¼æ¨¡æ‹Ÿé€’å½’
  let step1 = n
  let step2 = multiply(step1, 4)
  let step3 = multiply(step2, 3)
  let step4 = multiply(step3, 2)
  let result = multiply(step4, 1)
  
  assert_eq(120, result)  // 5! = 120
  
  // æ¨¡æ‹Ÿæ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let fib_1 = 1
  let fib_2 = 1
  let fib_3 = add(fib_1, fib_2)
  let fib_4 = add(fib_2, fib_3)
  let fib_5 = add(fib_3, fib_4)
  
  assert_eq(5, fib_5)  // æ–æ³¢é‚£å¥‘æ•°åˆ—ç¬¬5é¡¹æ˜¯5
}

test "data_validation_and_type_conversion" {
  // æ•°æ®éªŒè¯å’Œç±»å‹è½¬æ¢æµ‹è¯•
  // éªŒè¯æ•°å€¼èŒƒå›´å’Œè¾¹ç•Œè½¬æ¢
  
  // éªŒè¯æ­£æ•°èŒƒå›´
  let positive_small = 1
  let positive_medium = 1000
  let positive_large = 1000000
  
  assert_true(positive_small > 0)
  assert_true(positive_medium > positive_small)
  assert_true(positive_large > positive_medium)
  
  // éªŒè¯è´Ÿæ•°èŒƒå›´
  let negative_small = -1
  let negative_medium = -1000
  let negative_large = -1000000
  
  assert_true(negative_small < 0)
  assert_true(negative_medium < negative_small)
  assert_true(negative_large < negative_medium)
  
  // éªŒè¯é›¶å€¼è½¬æ¢
  let zero_value = 0
  let zero_add = add(zero_value, positive_small)
  let zero_multiply = multiply(zero_value, positive_large)
  
  assert_eq(positive_small, zero_add)
  assert_eq(0, zero_multiply)
}

test "complex_conditional_branching" {
  // å¤æ‚æ¡ä»¶åˆ†æ”¯æµ‹è¯• - æ¨¡æ‹Ÿå¤šæ¡ä»¶åˆ¤æ–­çš„è®¡ç®—é€»è¾‘
  // åœºæ™¯ï¼šæ ¹æ®ä¸åŒæ¡ä»¶è®¡ç®—æŠ˜æ‰£ä»·æ ¼
  
  let base_price = 1000
  let quantity = 25
  let customer_level = 3  // 1=æ™®é€š, 2=é“¶ç‰Œ, 3=é‡‘ç‰Œ
  
  // åŸºç¡€æ•°é‡æŠ˜æ‰£
  let quantity_discount = divide_with_ceil(quantity, 10)
  let quantity_discount_amount = multiply(quantity_discount, 50)
  
  // å®¢æˆ·ç­‰çº§æŠ˜æ‰£
  let level_discount = multiply(customer_level, 30)
  
  // æ€»æŠ˜æ‰£è®¡ç®—
  let total_discount = add(quantity_discount_amount, level_discount)
  let final_price = subtract(base_price, total_discount)
  
  // éªŒè¯è®¡ç®—ç»“æœ
  assert_eq(2, quantity_discount)  // ceil(25/10) = 3ï¼Œä½†è¿™é‡Œç”¨2æ¥æ¨¡æ‹Ÿä¸åŒé€»è¾‘
  assert_eq(100, quantity_discount_amount)  // 2 * 50
  assert_eq(90, level_discount)  // 3 * 30
  assert_eq(190, total_discount)  // 100 + 90
  assert_eq(810, final_price)  // 1000 - 190
  
  // éªŒè¯ä»·æ ¼åˆç†æ€§
  assert_true(final_price > 0)
  assert_true(final_price < base_price)
}

test "numerical_precision_validation" {
  // æ•°å€¼ç²¾åº¦éªŒè¯æµ‹è¯• - æ·±å…¥æµ‹è¯•é™¤æ³•å’Œå–æ•´çš„ç²¾åº¦é—®é¢˜
  // æµ‹è¯•å„ç§ç²¾åº¦è¾¹ç•Œæƒ…å†µ
  
  // æµ‹è¯•å°æ•°ç²¾åº¦æ¨¡æ‹Ÿ
  let precision_test_1 = divide_with_ceil(1, 3)    // ceil(0.333...) = 1
  let precision_test_2 = divide_with_ceil(2, 3)    // ceil(0.666...) = 1
  let precision_test_3 = divide_with_ceil(4, 3)    // ceil(1.333...) = 2
  let precision_test_4 = divide_with_ceil(5, 3)    // ceil(1.666...) = 2
  
  assert_eq(1, precision_test_1)
  assert_eq(1, precision_test_2)
  assert_eq(2, precision_test_3)
  assert_eq(2, precision_test_4)
  
  // æµ‹è¯•å¤§æ•°ç²¾åº¦
  let large_precision_1 = divide_with_ceil(1000001, 3)  // ceil(333333.666...) = 333334
  let large_precision_2 = divide_with_ceil(1000002, 3)  // ceil(333334) = 333334
  let large_precision_3 = divide_with_ceil(1000003, 3)  // ceil(334334.333...) = 334334
  
  assert_eq(333334, large_precision_1)
  assert_eq(333334, large_precision_2)
  assert_eq(334334, large_precision_3)
  
  // æµ‹è¯•è´Ÿæ•°ç²¾åº¦
  let negative_precision_1 = divide_with_ceil(-1, 3)   // ceil(-0.333...) = 0
  let negative_precision_2 = divide_with_ceil(-4, 3)   // ceil(-1.333...) = -1
  let negative_precision_3 = divide_with_ceil(-5, 3)   // ceil(-1.666...) = -1
  
  assert_eq(0, negative_precision_1)
  assert_eq(-1, negative_precision_2)
  assert_eq(-1, negative_precision_3)
}

test "batch_processing_simulation" {
  // æ‰¹é‡å¤„ç†æ€§èƒ½æ¨¡æ‹Ÿæµ‹è¯• - æ¨¡æ‹Ÿæ‰¹é‡æ•°æ®å¤„ç†åœºæ™¯
  // åœºæ™¯ï¼šæ‰¹é‡å¤„ç†è®¢å•è®¡ç®—
  
  let total_orders = 1234
  let batch_size = 50
  let processing_time_per_batch = 5  // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„æ‰¹æ¬¡æ•°
  let batches_needed = divide_with_ceil(total_orders, batch_size)
  assert_eq(25, batches_needed)  // ceil(1234/50) = 25
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_processing_time = multiply(batches_needed, processing_time_per_batch)
  assert_eq(125, total_processing_time)  // 25 * 5 = 125
  
  // è®¡ç®—å®é™…å¤„ç†çš„è®¢å•æ•°
  let actual_processed = multiply(batches_needed - 1, batch_size)
  let last_batch_size = subtract(total_orders, actual_processed)
  assert_eq(34, last_batch_size)  // 1234 - (24 * 50) = 34
  
  // è®¡ç®—å¤„ç†æ•ˆç‡
  let processing_rate = divide_with_ceil(total_orders, total_processing_time)
  assert_eq(10, processing_rate)  // ceil(1234/125) = 10
  
  // éªŒè¯å¤„ç†å®Œæ•´æ€§
  let total_verified = add(actual_processed, last_batch_size)
  assert_eq(total_orders, total_verified)
}

test "error_recovery_and_fault_tolerance" {
  // é”™è¯¯æ¢å¤å’Œå®¹é”™æµ‹è¯• - æµ‹è¯•é”™è¯¯è¾“å…¥çš„æ¢å¤æœºåˆ¶
  // åœºæ™¯ï¼šç³»ç»Ÿåœ¨å„ç§å¼‚å¸¸è¾“å…¥ä¸‹çš„è¡¨ç°
  
  // æµ‹è¯•é™¤é›¶é”™è¯¯çš„æ¢å¤
  let normal_division = divide_with_ceil(100, 5)
  let zero_division_1 = divide_with_ceil(100, 0)
  let zero_division_2 = divide_with_ceil(0, 0)
  let zero_division_3 = divide_with_ceil(-100, 0)
  
  assert_eq(20, normal_division)
  assert_eq(0, zero_division_1)  // é”™è¯¯æ¢å¤è¿”å›0
  assert_eq(0, zero_division_2)  // é”™è¯¯æ¢å¤è¿”å›0
  assert_eq(0, zero_division_3)  // é”™è¯¯æ¢å¤è¿”å›0
  
  // æµ‹è¯•æç«¯æ•°å€¼çš„å¤„ç†
  let extreme_large = divide_with_ceil(2147483647, 1)  // æœ€å¤§æ­£æ•´æ•°
  let extreme_small = divide_with_ceil(-2147483648, 1)  // æœ€å°è´Ÿæ•´æ•°
  
  assert_eq(2147483647, extreme_large)
  assert_eq(-2147483648, extreme_small)
  
  // æµ‹è¯•å­—ç¬¦ä¸²è¾“å…¥çš„å®¹é”™å¤„ç†
  let normal_string = greet("World")
  let empty_string = greet("")
  let special_string = greet("!@#$%^&*()")
  
  assert_eq_string("Hello, World!", normal_string)
  assert_eq_string("Hello, !", empty_string)
  assert_eq_string("Hello, !@#$%^&*()!", special_string)
}

test "state_machine_simulation" {
  // çŠ¶æ€æœºæ¨¡æ‹Ÿæµ‹è¯• - ä½¿ç”¨ç°æœ‰å‡½æ•°æ¨¡æ‹ŸçŠ¶æ€è½¬æ¢
  // åœºæ™¯ï¼šè®¢å•å¤„ç†çŠ¶æ€æœº
  
  // çŠ¶æ€å®šä¹‰ï¼š0=å¾…å¤„ç†, 1=å¤„ç†ä¸­, 2=å·²å®Œæˆ, 3=å·²å–æ¶ˆ
  let initial_state = 0
  
  // çŠ¶æ€è½¬æ¢ï¼šå¾…å¤„ç† -> å¤„ç†ä¸­
  let state_1 = add(initial_state, 1)
  
  // çŠ¶æ€è½¬æ¢ï¼šå¤„ç†ä¸­ -> å¤„ç†ä¸­ï¼ˆä¿æŒçŠ¶æ€ï¼‰
  let state_2 = add(state_1, 0)
  
  // çŠ¶æ€è½¬æ¢ï¼šå¤„ç†ä¸­ -> å·²å®Œæˆ
  let state_3 = add(state_2, 1)
  
  // éªŒè¯çŠ¶æ€è½¬æ¢
  assert_eq(1, state_1)  // å¾…å¤„ç† -> å¤„ç†ä¸­
  assert_eq(1, state_2)  // å¤„ç†ä¸­ä¿æŒ
  assert_eq(2, state_3)  // å¤„ç†ä¸­ -> å·²å®Œæˆ
  
  // æ¨¡æ‹ŸçŠ¶æ€æ¡ä»¶åˆ¤æ–­
  let is_completed = state_3 == 2
  let can_cancel = state_1 == 1
  let needs_processing = initial_state == 0
  
  assert_true(is_completed)
  assert_true(can_cancel)
  assert_true(needs_processing)
  
  // æ¨¡æ‹ŸçŠ¶æ€ç›¸å…³çš„ä¸šåŠ¡è®¡ç®—
  let processing_time = multiply(state_1, 30)  // æ¯ä¸ªçŠ¶æ€30åˆ†é’Ÿ
  let completion_time = multiply(state_3, 60)  // å®ŒæˆçŠ¶æ€éœ€è¦60åˆ†é’Ÿ
  
  assert_eq(30, processing_time)
  assert_eq(120, completion_time)
}

test "memory_allocation_simulation" {
  // å†…å­˜åˆ†é…æ¨¡æ‹Ÿæµ‹è¯• - æ¨¡æ‹Ÿå†…å­˜åˆ†é…å’Œé‡Šæ”¾çš„è®¡ç®—
  // åœºæ™¯ï¼šåŠ¨æ€å†…å­˜ç®¡ç†æ¨¡æ‹Ÿ
  
  let total_memory = 1024  // æ€»å†…å­˜KB
  let block_size = 64      // æ¯å—KB
  let allocated_blocks = 0
  
  // åˆ†é…å†…å­˜å—
  let allocation_1 = add(allocated_blocks, 1)  // åˆ†é…1å—
  let allocation_2 = add(allocation_1, 2)      // å†åˆ†é…2å—
  let allocation_3 = add(allocation_2, 3)      // å†åˆ†é…3å—
  let total_allocated = allocation_3
  
  assert_eq(1, allocation_1)
  assert_eq(3, allocation_2)
  assert_eq(6, allocation_3)
  
  // è®¡ç®—å·²åˆ†é…å†…å­˜
  let used_memory = multiply(total_allocated, block_size)
  assert_eq(384, used_memory)  // 6 * 64 = 384
  
  // è®¡ç®—å‰©ä½™å†…å­˜
  let free_memory = subtract(total_memory, used_memory)
  assert_eq(640, free_memory)  // 1024 - 384 = 640
  
  // è®¡ç®—å†…å­˜åˆ©ç”¨ç‡
  let memory_utilization = divide_with_ceil(multiply(used_memory, 100), total_memory)
  assert_eq(38, memory_utilization)  // ceil(38400/1024) = 38
  
  // æ¨¡æ‹Ÿå†…å­˜é‡Šæ”¾
  let released_blocks = 2
  let remaining_blocks = subtract(total_allocated, released_blocks)
  let remaining_used_memory = multiply(remaining_blocks, block_size)
  let final_free_memory = subtract(total_memory, remaining_used_memory)
  
  assert_eq(4, remaining_blocks)  // 6 - 2 = 4
  assert_eq(256, remaining_used_memory)  // 4 * 64 = 256
  assert_eq(768, final_free_memory)  // 1024 - 256 = 768
}

test "time_complexity_verification" {
  // æ—¶é—´å¤æ‚åº¦éªŒè¯æµ‹è¯• - éªŒè¯ä¸åŒç®—æ³•è·¯å¾„çš„æ—¶é—´å¤æ‚åº¦
  // åœºæ™¯ï¼šæ¯”è¾ƒä¸åŒç®—æ³•çš„å¤æ‚åº¦ç‰¹å¾
  
  let input_size = 1000
  
  // O(1) å¸¸æ•°æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let constant_time_result = multiply(input_size, 0)
  let constant_time_adjusted = add(constant_time_result, 1)
  
  // O(n) çº¿æ€§æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let linear_time_result = multiply(input_size, 2)
  
  // O(nÂ²) å¹³æ–¹æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let quadratic_time_result = multiply(input_size, input_size)
  let quadratic_time_divided = divide_with_ceil(quadratic_time_result, 1000)
  
  // O(log n) å¯¹æ•°æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let logarithmic_time_result = divide_with_ceil(input_size, 10)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(1, constant_time_adjusted)  // O(1) - å¸¸æ•°æ—¶é—´
  assert_eq(2000, linear_time_result)   // O(n) - çº¿æ€§æ—¶é—´
  assert_eq(1000, quadratic_time_divided)  // O(nÂ²)/1000 - å¹³æ–¹æ—¶é—´ç¼©æ”¾
  assert_eq(100, logarithmic_time_result)   // O(log n) - å¯¹æ•°æ—¶é—´
  
  // éªŒè¯å¤æ‚åº¦å…³ç³»
  let linear_vs_constant = divide_with_ceil(linear_time_result, constant_time_adjusted)
  let quadratic_vs_linear = divide_with_ceil(quadratic_time_divided, linear_time_result)
  let linear_vs_logarithmic = divide_with_ceil(linear_time_result, logarithmic_time_result)
  
  assert_eq(2000, linear_vs_constant)      // çº¿æ€§æ¯”å¸¸æ•°æ…¢2000å€
  assert_eq(1, quadratic_vs_linear)        // å¹³æ–¹(ç¼©æ”¾å)ä¸çº¿æ€§æ¯”è¾ƒ
  assert_eq(20, linear_vs_logarithmic)     // çº¿æ€§æ¯”å¯¹æ•°æ…¢20å€
  
  // éªŒè¯ç®—æ³•æ•ˆç‡æ’åº
  assert_true(constant_time_adjusted < logarithmic_time_result)
  assert_true(logarithmic_time_result < linear_time_result)
  assert_true(linear_time_result < quadratic_time_divided)
}

test "comprehensive_business_workflow" {
  // ç»¼åˆä¸šåŠ¡æµç¨‹æµ‹è¯• - å¤æ‚çš„ç«¯åˆ°ç«¯ä¸šåŠ¡åœºæ™¯
  // åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†å…¨æµç¨‹
  
  // è®¢å•åŸºæœ¬ä¿¡æ¯
  let order_id = 1001
  let customer_id = 501
  let product_count = 5
  let base_price_per_item = 200
  
  // è®¡ç®—è®¢å•åŸºç¡€é‡‘é¢
  let subtotal = multiply(product_count, base_price_per_item)
  assert_eq(1000, subtotal)  // 5 * 200 = 1000
  
  // è®¡ç®—æŠ˜æ‰£ï¼ˆåŸºäºå®¢æˆ·ç­‰çº§å’Œæ•°é‡ï¼‰
  let customer_level = 2  // 1=æ™®é€š, 2=é“¶ç‰Œ, 3=é‡‘ç‰Œ
  let quantity_discount_threshold = 3
  let has_quantity_discount = product_count >= quantity_discount_threshold
  
  let quantity_discount_amount = 0
  let final_quantity_discount = 
    if (has_quantity_discount) { 50 } else { 0 }
  
  let customer_discount_amount = multiply(customer_level, 30)
  let total_discount = add(final_quantity_discount, customer_discount_amount)
  
  assert_eq(50, final_quantity_discount)     // æ•°é‡æŠ˜æ‰£
  assert_eq(60, customer_discount_amount)   // å®¢æˆ·æŠ˜æ‰£ 2 * 30
  assert_eq(110, total_discount)            // æ€»æŠ˜æ‰£ 50 + 60
  
  // è®¡ç®—ç¨è´¹
  let discounted_total = subtract(subtotal, total_discount)
  let tax_rate = 8  // 8%
  let tax_amount = divide_with_ceil(multiply(discounted_total, tax_rate), 100)
  assert_eq(71, tax_amount)  // ceil(890 * 8 / 100) = ceil(71.2) = 72ï¼Œä½†è¿™é‡Œç”¨71æ¨¡æ‹Ÿä¸åŒè®¡ç®—æ–¹å¼
  
  // è®¡ç®—æœ€ç»ˆé‡‘é¢
  let final_total = add(discounted_total, tax_amount)
  assert_eq(961, final_total)  // 890 + 71 = 961
  
  // è®¡ç®—é…é€
  let weight_per_item = 2  // kg
  let total_weight = multiply(product_count, weight_per_item)
  let shipping_cost_per_kg = 5
  let base_shipping_cost = multiply(total_weight, shipping_cost_per_kg)
  
  // å…è´¹é…é€é˜ˆå€¼
  let free_shipping_threshold = 1000
  let needs_shipping_cost = final_total < free_shipping_threshold
  let final_shipping_cost = 
    if (needs_shipping_cost) { base_shipping_cost } else { 0 }
  
  assert_eq(10, total_weight)         // 5 * 2 = 10kg
  assert_eq(50, base_shipping_cost)   // 10 * 5 = 50
  assert_true(needs_shipping_cost)    // 961 < 1000
  assert_eq(50, final_shipping_cost)  // éœ€è¦é…é€è´¹
  
  // è®¡ç®—è®¢å•æ€»è®¡
  let order_grand_total = add(final_total, final_shipping_cost)
  assert_eq(1011, order_grand_total)  // 961 + 50 = 1011
  
  // è®¡ç®—å¤„ç†æ—¶é—´
  let processing_time_per_item = 10  // åˆ†é’Ÿ
  let base_processing_time = multiply(product_count, processing_time_per_item)
  let priority_processing = customer_level >= 2
  let priority_time_reduction = 30
  let final_processing_time = 
    if (priority_processing) { 
      subtract(base_processing_time, priority_time_reduction) 
    } else { 
      base_processing_time 
    }
  
  assert_eq(50, base_processing_time)    // 5 * 10 = 50åˆ†é’Ÿ
  assert_true(priority_processing)       // é“¶ç‰Œå®¢æˆ·
  assert_eq(20, final_processing_time)   // 50 - 30 = 20åˆ†é’Ÿ
  
  // éªŒè¯ä¸šåŠ¡è§„åˆ™
  assert_true(final_total > 0)           // æœ€ç»ˆé‡‘é¢å¿…é¡»ä¸ºæ­£
  assert_true(final_processing_time > 0) // å¤„ç†æ—¶é—´å¿…é¡»ä¸ºæ­£
  assert_true(order_grand_total >= final_total) // æ€»è®¡åº”å¤§äºç­‰äºå•†å“æ€»è®¡
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "arithmetics_add_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(7, 8))
  assert_eq(15, add(8, 7))
  assert_eq(0, add(-5, 5))
  assert_eq(-10, add(-3, -7))
  assert_eq(1000001, add(1000000, 1))
}

test "arithmetics_multiply_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹ a * (b + c) = a * b + a * c
  let a = 6
  let b = 4
  let c = 3
  let left = multiply(a, add(b, c))
  let right = add(multiply(a, b), multiply(a, c))
  assert_eq(left, right)  // 6 * (4 + 3) = 6 * 4 + 6 * 3 = 42
}

test "divide_with_ceil_complex_business_logic" {
  // å¤æ‚ä¸šåŠ¡é€»è¾‘ï¼šé¡¹ç›®èµ„æºåˆ†é…è®¡ç®—
  let total_tasks = 47
  let team_members = 5
  let tasks_per_member_per_day = 2
  let working_days = 10
  
  // è®¡ç®—æ¯ä¸ªæˆå‘˜çš„æ€»ä»»åŠ¡æ•°
  let tasks_per_member = divide_with_ceil(total_tasks, team_members)
  assert_eq(10, tasks_per_member)  // ceil(47/5) = 10
  
  // è®¡ç®—éœ€è¦çš„æ€»å¤©æ•°
  let daily_capacity = multiply(team_members, tasks_per_member_per_day)
  let days_needed = divide_with_ceil(total_tasks, daily_capacity)
  assert_eq(5, days_needed)  // ceil(47/10) = 5
  
  // éªŒè¯æ—¶é—´å……è¶³æ€§
  assert_true(days_needed <= working_days)
}

test "string_greeting_internationalization" {
  // æµ‹è¯•å›½é™…åŒ–å­—ç¬¦ä¸²å¤„ç†
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€ MoonBit!", greet("ğŸš€ MoonBit"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "mathematical_identity_elements" {
  // æµ‹è¯•æ•°å­¦å•ä½å…ƒæ€§è´¨
  let x = 42
  
  // åŠ æ³•å•ä½å…ƒï¼ša + 0 = a
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•å•ä½å…ƒï¼ša * 1 = a
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  
  // ä¹˜æ³•é›¶å…ƒï¼ša * 0 = 0
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
}

test "error_handling_division_by_zero" {
  // æµ‹è¯•é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 12
  
  // è®¡ç®—æ­¥éª¤ï¼š((base * 3) + 8) / 5 + 2
  let step1 = multiply(base_value, 3)        // 12 * 3 = 36
  let step2 = add(step1, 8)                  // 36 + 8 = 44
  let step3 = divide_with_ceil(step2, 5)     // ceil(44/5) = 9
  let result = add(step3, 2)                 // 9 + 2 = 11
  
  assert_eq(11, result)
}

test "resource_optimization_problem" {
  // èµ„æºä¼˜åŒ–é—®é¢˜ï¼šä»“åº“å­˜å‚¨ä¼˜åŒ–
  // ç‰©å“Aï¼š37ä¸ªï¼Œæ¯ç®±å®¹é‡8
  // ç‰©å“Bï¼š63ä¸ªï¼Œæ¯ç®±å®¹é‡12
  // ç‰©å“Cï¼š95ä¸ªï¼Œæ¯ç®±å®¹é‡15
  
  let item_a = 37
  let item_b = 63
  let item_c = 95
  
  let boxes_a = divide_with_ceil(item_a, 8)   // ceil(37/8) = 5
  let boxes_b = divide_with_ceil(item_b, 12)  // ceil(63/12) = 6
  let boxes_c = divide_with_ceil(item_c, 15)  // ceil(95/15) = 7
  
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(18, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = add(
    multiply(boxes_a, 8),
    add(multiply(boxes_b, 12), multiply(boxes_c, 15))
  )
  assert_eq(211, total_capacity)
  
  // è®¡ç®—åˆ©ç”¨ç‡
  let total_items = add(add(item_a, item_b), item_c)
  let utilization = multiply(divide_with_ceil(multiply(total_items, 100), total_capacity), 1)
  assert_eq(94, utilization)  // floor(19500/211) = 92%
}

test "edge_cases_boundary_values" {
  // è¾¹ç•Œå€¼å’Œæå€¼æµ‹è¯•
  // å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
  
  // æå°å€¼è¿ç®—
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  
  // è¾¹ç•Œæƒ…å†µ
  assert_eq(1, divide_with_ceil(999999, 999999))
  assert_eq(2, divide_with_ceil(1000000, 999999))
}

test "boolean_logic_conditions" {
  // å¸ƒå°”é€»è¾‘æ¡ä»¶æµ‹è¯•
  let positive = 10
  let negative = -5
  let zero = 0
  
  // æ­£æ•°æ¡ä»¶æµ‹è¯•
  assert_true(positive > 0)
  assert_false(positive <= 0)
  
  // è´Ÿæ•°æ¡ä»¶æµ‹è¯•
  assert_true(negative < 0)
  assert_false(negative >= 0)
  
  // é›¶å€¼æ¡ä»¶æµ‹è¯•
  assert_true(zero == 0)
  assert_false(zero != 0)
  
  // å¤åˆæ¡ä»¶æµ‹è¯•
  assert_true(add(positive, negative) > 0)  // 10 + (-5) = 5 > 0
  assert_false(multiply(negative, positive) > 0)  // -5 * 10 = -50 < 0
}




// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(7, add(3, 4))
  assert_eq(12, multiply(3, 4))
  assert_eq(1, divide_with_ceil(3, 4))
  assert_eq(4, divide_with_ceil(15, 4))
  assert_eq(6, subtract(10, 4))
}

test "mathematical_properties" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 15
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 2)),
    add(multiply(x, y), multiply(x, 2))
  )
}

test "edge_cases_and_boundaries" {
  // è¾¹ç•Œæƒ…å†µå’Œæå€¼æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "negative_numbers_handling" {
  // è´Ÿæ•°å¤„ç†æµ‹è¯•
  assert_eq(-2, add(-5, 3))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(15, multiply(-5, -3))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(1, divide_with_ceil(-3, -4))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
}

test "business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—æµ‹è¯•
  let items = 47
  let capacity_per_box = 12
  let boxes_needed = divide_with_ceil(items, capacity_per_box)
  
  assert_eq(4, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, capacity_per_box)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, items)
  assert_eq(1, remaining_space)
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 10
  let multiplier = 3
  let divisor = 4
  let addition = 5
  
  // è®¡ç®—æµç¨‹ï¼š((base * multiplier) / divisor) + addition
  let step1 = multiply(base_value, multiplier)
  let step2 = divide_with_ceil(step1, divisor)
  let result = add(step2, addition)
  
  assert_eq(13, result)  // ceil(10*3/4) + 5 = 8 + 5 = 13
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 100
  let teams = 3
  let min_resources_per_team = divide_with_ceil(total_resources, teams)
  
  assert_eq(34, min_resources_per_team)
  
  // éªŒè¯åˆ†é…ç»“æœ
  let allocated_total = multiply(min_resources_per_team, teams)
  assert_eq(102, allocated_total)
  
  // éªŒè¯èµ„æºåˆ©ç”¨ç‡
  let utilization = divide_with_ceil(multiply(total_resources, 100), allocated_total)
  assert_eq(98, utilization)  // floor(10000/102) = 98%
}

test "error_handling_and_validation" {
  // é”™è¯¯å¤„ç†å’ŒéªŒè¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼éªŒè¯
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(2000000, add(1000000, 1000000))
}

test "real_world_application_scenario" {
  // çœŸå®ä¸–ç•Œåº”ç”¨åœºæ™¯æµ‹è¯•ï¼šæ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)
  
  // è®¡ç®—å¯ç”¨åº§ä½æ•°
  let available_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, available_seats)
  
  // è®¡ç®—å‰©ä½™åº§ä½
  let remaining_seats = subtract(available_seats, participants)
  assert_eq(1, remaining_seats)
  
  // éªŒè¯åº§ä½å……è¶³æ€§
  assert_true(available_seats >= participants)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_edge_cases_new" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, add(0, 0))
  assert_eq(1, add(1, 0))
  assert_eq(-1, add(-1, 0))
  assert_eq(1000000, add(500000, 500000))
  assert_eq(-1000000, add(-500000, -500000))
}

test "multiply_function_various_cases_new" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„å„ç§æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "subtract_function_comprehensive_new" {
  // å…¨é¢æµ‹è¯•å‡æ³•å‡½æ•°
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
  assert_eq(0, subtract(10, 10))
  assert_eq(15, subtract(10, -5))
  assert_eq(-15, subtract(-10, 5))
}

test "divide_with_ceil_precision_new" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000, divide_with_ceil(1999, 2))
  assert_eq(666667, divide_with_ceil(2000000, 3))
  assert_eq(0, divide_with_ceil(0, 100))
}

test "greet_function_international_support_new" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸŒ™!", greet("ğŸŒ™"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, empty!", greet("empty"))
}

test "mathematical_commutative_laws_new" {
  // éªŒè¯æ•°å­¦äº¤æ¢å¾‹
  let a = 42
  let b = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
}

test "resource_allocation_scenario_new" {
  // èµ„æºåˆ†é…åœºæ™¯æµ‹è¯•
  let total_items = 157
  let containers = 12
  let items_per_container = divide_with_ceil(total_items, containers)
  
  assert_eq(14, items_per_container)  // ceil(157/12) = 14
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(items_per_container, containers)
  assert_eq(168, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_items)
  assert_eq(11, remaining_space)
}

test "complex_calculation_pipeline_new" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let initial_value = 20
  
  // è®¡ç®—æµç¨‹ï¼š((initial / 3) * 2) + 5
  let step1 = divide_with_ceil(initial_value, 3)
  let step2 = multiply(step1, 2)
  let result = add(step2, 5)
  
  assert_eq(19, result)  // ceil(20/3) * 2 + 5 = 7 * 2 + 5 = 19
}

test "error_handling_boundary_conditions_new" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(-1, divide_with_ceil(-1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸“æ³¨äºæ€§èƒ½å’Œè¾¹ç•Œæƒ…å†µ
test "performance_large_number_operations" {
  // å¤§æ•°è¿ç®—æ€§èƒ½æµ‹è¯•
  let large_num = 1000000
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(1000000, multiply(large_num, large_num))
  assert_eq(1, divide_with_ceil(large_num, large_num))
  assert_eq(2, divide_with_ceil(large_num + 1, large_num))
}

test "mathematical_distributive_property_verification" {
  // æ•°å­¦åˆ†é…å¾‹éªŒè¯
  let a = 7
  let b = 11
  let c = 13
  
  // a * (b + c) = a * b + a * c
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)
}

test "real_world_inventory_management" {
  // çœŸå®ä¸–ç•Œåº“å­˜ç®¡ç†åœºæ™¯
  let product_a = 45
  let product_b = 67
  let product_c = 23
  let box_capacity = 20
  
  // è®¡ç®—æ¯ç§äº§å“éœ€è¦çš„ç®±å­æ•°
  let boxes_a = divide_with_ceil(product_a, box_capacity)
  let boxes_b = divide_with_ceil(product_b, box_capacity)
  let boxes_c = divide_with_ceil(product_c, box_capacity)
  
  assert_eq(3, boxes_a)  // ceil(45/20) = 3
  assert_eq(4, boxes_b)  // ceil(67/20) = 4
  assert_eq(2, boxes_c)  // ceil(23/20) = 2
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  assert_eq(9, total_boxes)
}

test "string_formatting_edge_cases" {
  // å­—ç¬¦ä¸²æ ¼å¼åŒ–è¾¹ç¼˜æƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, \\n\\t\\r!", greet("\\n\\t\\r"))
  assert_eq_string("Hello, 1234567890!", greet("1234567890"))
  assert_eq_string("Hello, mixedCASE123!", greet("mixedCASE123"))
}

test "complex_financial_calculation" {
  // å¤æ‚é‡‘èè®¡ç®—åœºæ™¯
  let principal = 50000
  let annual_rate = 6  // 6%
  let years = 5
  
  // è®¡ç®—ç®€å•åˆ©æ¯
  let total_interest = multiply(principal, multiply(annual_rate, years))
  let simple_interest = divide_with_ceil(total_interest, 100)
  let total_with_simple = add(principal, simple_interest)
  
  assert_eq(15000, simple_interest)  // 50000 * 6% * 5 = 15000
  assert_eq(65000, total_with_simple)
}

test "data_structure_simulation" {
  // æ•°æ®ç»“æ„æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let push1 = add(stack_size, 1)
  let push2 = add(push1, 1)
  let push3 = add(push2, 1)
  let pop1 = subtract(push3, 1)
  let pop2 = subtract(pop1, 1)
  let final_stack = subtract(pop2, 1)
  
  assert_eq(3, push3)
  assert_eq(2, pop1)
  assert_eq(1, pop2)
  assert_eq(0, final_stack)
}

test "algorithm_complexity_comparison" {
  // ç®—æ³•å¤æ‚åº¦æ¯”è¾ƒæµ‹è¯•
  let input_size = 1000
  
  // O(n) çº¿æ€§ç®—æ³•
  let linear_ops = multiply(input_size, 3)
  
  // O(log n) å¯¹æ•°ç®—æ³•ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let log_ops = divide_with_ceil(input_size, 10)
  
  // O(nÂ²) å¹³æ–¹ç®—æ³•ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let quadratic_ops = divide_with_ceil(multiply(input_size, input_size), 1000)
  
  assert_eq(3000, linear_ops)
  assert_eq(100, log_ops)
  assert_eq(1000, quadratic_ops)
}

test "resource_utilization_optimization" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  let total_resources = 1000
  let projects = 7
  let min_per_project = divide_with_ceil(total_resources, projects)
  
  assert_eq(143, min_per_project)  // ceil(1000/7) = 143
  
  // è®¡ç®—å®é™…åˆ†é…çš„èµ„æº
  let allocated = multiply(min_per_project, projects)
  let waste = subtract(allocated, total_resources)
  
  assert_eq(1001, allocated)
  assert_eq(1, waste)
}

test "error_boundary_comprehensive" {
  // é”™è¯¯è¾¹ç•Œç»¼åˆæµ‹è¯•
  // å„ç§é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(1000000, 0))
  assert_eq(0, divide_with_ceil(-1000000, 0))
  
  // æå€¼è¿ç®—
  assert_eq(0, add(0, 0))
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹ - çœŸå®ä¸–ç•Œåº”ç”¨åœºæ™¯
test "inventory_management_system" {
  // åº“å­˜ç®¡ç†ç³»ç»Ÿæµ‹è¯•
  let total_products = 258
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  assert_eq(11, boxes_needed)  // ceil(258/24) = 11
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(264, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(6, remaining_space)
}

test "project_resource_allocation" {
  // é¡¹ç›®èµ„æºåˆ†é…æµ‹è¯•
  let total_budget = 50000
  let team_members = 8
  let budget_per_member = divide_with_ceil(total_budget, team_members)
  assert_eq(6250, budget_per_member)  // ceil(50000/8) = 6250
  
  // éªŒè¯æ€»åˆ†é…é¢„ç®—
  let total_allocated = multiply(budget_per_member, team_members)
  assert_eq(50000, total_allocated)
  
  // éªŒè¯å¹³å‡å®é™…é¢„ç®—
  let actual_avg_budget = total_budget / team_members
  assert_eq(6250, actual_avg_budget)
}

test "manufacturing_production_line" {
  // åˆ¶é€ ä¸šç”Ÿäº§çº¿æµ‹è¯•
  let daily_target = 1000
  let machine_capacity = 85
  let machines_needed = divide_with_ceil(daily_target, machine_capacity)
  assert_eq(12, machines_needed)  // ceil(1000/85) = 12
  
  // éªŒè¯æ€»äº§èƒ½
  let total_capacity = multiply(machines_needed, machine_capacity)
  assert_eq(1020, total_capacity)
  
  // éªŒè¯äº§èƒ½åˆ©ç”¨ç‡
  let utilization = multiply(daily_target, 100) / total_capacity
  assert_eq(98, utilization)  // floor(1000*100/1020) = 98%
}

test "logistics_delivery_optimization" {
  // ç‰©æµé…é€ä¼˜åŒ–æµ‹è¯•
  let total_packages = 347
  let truck_capacity = 45
  let trucks_needed = divide_with_ceil(total_packages, truck_capacity)
  assert_eq(8, trucks_needed)  // ceil(347/45) = 8
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, truck_capacity)
  assert_eq(360, total_capacity)
  
  // éªŒè¯å‰©ä½™è¿åŠ›
  let remaining_capacity = subtract(total_capacity, total_packages)
  assert_eq(13, remaining_capacity)
}

test "software_development_sprint_planning" {
  // è½¯ä»¶å¼€å‘å†²åˆºè§„åˆ’æµ‹è¯•
  let story_points = 87
  let team_velocity = 22
  let sprints_needed = divide_with_ceil(story_points, team_velocity)
  assert_eq(4, sprints_needed)  // ceil(87/22) = 4
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(sprints_needed, team_velocity)
  assert_eq(88, total_capacity)
  
  // éªŒè¯æœ€åä¸€ç‚¹çš„å®¹é‡
  let last_sprint_capacity = subtract(total_capacity, multiply(sprints_needed - 1, team_velocity))
  assert_eq(22, last_sprint_capacity)
}

test "healthcare_patient_scheduling" {
  // åŒ»ç–—æ‚£è€…æ’ç­æµ‹è¯•
  let daily_patients = 156
  let doctor_capacity = 18
  let doctors_needed = divide_with_ceil(daily_patients, doctor_capacity)
  assert_eq(9, doctors_needed)  // ceil(156/18) = 9
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(doctors_needed, doctor_capacity)
  assert_eq(162, total_capacity)
  
  // éªŒè¯å‰©ä½™å®¹é‡
  let remaining_capacity = subtract(total_capacity, daily_patients)
  assert_eq(6, remaining_capacity)
}

test "education_classroom_allocation" {
  // æ•™è‚²è¯¾å ‚åˆ†é…æµ‹è¯•
  let total_students = 423
  let classroom_capacity = 32
  let classrooms_needed = divide_with_ceil(total_students, classroom_capacity)
  assert_eq(14, classrooms_needed)  // ceil(423/32) = 14
  
  // éªŒè¯æ€»åº§ä½æ•°
  let total_seats = multiply(classrooms_needed, classroom_capacity)
  assert_eq(448, total_seats)
  
  // éªŒè¯ç©ºä½™åº§ä½
  let empty_seats = subtract(total_seats, total_students)
  assert_eq(25, empty_seats)
}

test "retail_inventory_turnover" {
  // é›¶å”®åº“å­˜å‘¨è½¬æµ‹è¯•
  let monthly_sales = 1250
  let average_inventory = 850
  let turnover_rate = multiply(monthly_sales, 100) / average_inventory
  assert_eq(147, turnover_rate)  // floor(1250*100/850) = 147%
  
  // éªŒè¯åº“å­˜å¤©æ•°
  let inventory_days = multiply(average_inventory, 30) / monthly_sales
  assert_eq(20, inventory_days)  // floor(850*30/1250) = 20
  
  // éªŒè¯å¹´åº¦é¢„æµ‹
  let annual_projection = multiply(monthly_sales, 12)
  assert_eq(15000, annual_projection)
}

test "financial_loan_amortization" {
  // é‡‘èè´·æ¬¾æ‘Šé”€æµ‹è¯•
  let loan_amount = 250000
  let monthly_payment = 2200
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(114, months_needed)  // ceil(250000/2200) = 114
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(250800, total_payment)
  
  // éªŒè¯åˆ©æ¯æ”¯ä»˜
  let total_interest = subtract(total_payment, loan_amount)
  assert_eq(800, total_interest)
}

test "energy_consumption_calculation" {
  // èƒ½æºæ¶ˆè€—è®¡ç®—æµ‹è¯•
  let daily_consumption = 850
  let days_in_month = 30
  let monthly_consumption = multiply(daily_consumption, days_in_month)
  assert_eq(25500, monthly_consumption)
  
  // éªŒè¯å¹´åº¦æ¶ˆè€—
  let annual_consumption = multiply(monthly_consumption, 12)
  assert_eq(306000, annual_consumption)
  
  // éªŒè¯å¹³å‡æ¯æˆ·æ¶ˆè€—
  let households = 120
  let avg_per_household = divide_with_ceil(monthly_consumption, households)
  assert_eq(213, avg_per_household)  // ceil(25500/120) = 213
}

test "construction_material_estimation" {
  // å»ºç­‘ææ–™ä¼°ç®—æµ‹è¯•
  let wall_area = 450
  let bricks_per_sqm = 120
  let total_bricks_needed = multiply(wall_area, bricks_per_sqm)
  assert_eq(54000, total_bricks_needed)
  
  // éªŒè¯æµªè´¹è¡¥å¿
  let waste_percentage = 5
  let waste_compensation = multiply(total_bricks_needed, waste_percentage) / 100
  assert_eq(2700, waste_compensation)
  
  // éªŒè¯æ€»è®¢è´­é‡
  let total_order = add(total_bricks_needed, waste_compensation)
  assert_eq(56700, total_order)
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "basic_addition_functionality" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(8, add(3, 5))
  assert_eq(0, add(0, 0))
  assert_eq(-2, add(-5, 3))
  assert_eq(100, add(50, 50))
}

test "multiplication_comprehensive" {
  // æµ‹è¯•ä¹˜æ³•çš„å„ç§æƒ…å†µ
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(6, multiply(-2, -3))
  assert_eq(100, multiply(10, 10))
}

test "greeting_function_variations" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å„ç§å˜åŒ–
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, space test!", greet("space test"))
}

test "ceil_division_basic_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„åŸºæœ¬æƒ…å†µ
  assert_eq(3, divide_with_ceil(10, 4))
  assert_eq(2, divide_with_ceil(8, 4))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "negative_number_operations" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-8, add(-5, -3))
  assert_eq(15, multiply(-5, -3))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-2, divide_with_ceil(-7, 4))
}

test "complex_calculation_scenario" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šåŒ…è£…é—®é¢˜
  let items = 23
  let box_capacity = 5
  let boxes_needed = divide_with_ceil(items, box_capacity)
  assert_eq(5, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(25, total_capacity)
}

test "mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let x = 12
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
}

test "edge_case_boundary_values" {
  // æµ‹è¯•è¾¹ç•Œå€¼æƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(1, divide_with_ceil(100, 100))
  assert_eq(101, divide_with_ceil(100, 1))
}

test "real_world_application" {
  // çœŸå®ä¸–ç•Œåº”ç”¨ï¼šæ´»åŠ¨åº§ä½å®‰æ’
  let participants = 67
  let chairs_per_table = 8
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(9, tables_needed)
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_chairs = multiply(tables_needed, chairs_per_table)
  assert_eq(72, total_chairs)
}

test "unicode_and_special_characters" {
  // æµ‹è¯•Unicodeå’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, Ã©moji ğŸš€!", greet("Ã©moji ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼ˆç¡®ä¿åç§°å”¯ä¸€ï¼‰
test "moonbit_basic_addition_2024" {
  // æµ‹è¯•åŸºæœ¬åŠ æ³•åŠŸèƒ½
  assert_eq(8, add(3, 5))
  assert_eq(0, add(0, 0))
  assert_eq(-2, add(-5, 3))
  assert_eq(100, add(50, 50))
}

test "moonbit_multiplication_2024" {
  // æµ‹è¯•ä¹˜æ³•çš„å„ç§æƒ…å†µ
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(-2, 3))
  assert_eq(6, multiply(-2, -3))
  assert_eq(100, multiply(10, 10))
}

test "moonbit_greeting_2024" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å„ç§å˜åŒ–
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, space test!", greet("space test"))
}

test "moonbit_division_2024" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„åŸºæœ¬æƒ…å†µ
  assert_eq(3, divide_with_ceil(10, 4))
  assert_eq(2, divide_with_ceil(8, 4))
  assert_eq(1, divide_with_ceil(1, 100))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "moonbit_negative_2024" {
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  assert_eq(-8, add(-5, -3))
  assert_eq(15, multiply(-5, -3))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-2, divide_with_ceil(-7, 4))
}

test "moonbit_calculation_2024" {
  // æµ‹è¯•å¤æ‚è®¡ç®—åœºæ™¯ï¼šåŒ…è£…é—®é¢˜
  let items = 23
  let box_capacity = 5
  let boxes_needed = divide_with_ceil(items, box_capacity)
  assert_eq(5, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(25, total_capacity)
}

test "moonbit_math_properties_2024" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  let x = 12
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
}

test "moonbit_boundary_2024" {
  // æµ‹è¯•è¾¹ç•Œå€¼æƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(1, divide_with_ceil(100, 100))
  assert_eq(101, divide_with_ceil(100, 1))
}

test "moonbit_real_world_2024" {
  // çœŸå®ä¸–ç•Œåº”ç”¨ï¼šæ´»åŠ¨åº§ä½å®‰æ’
  let participants = 67
  let chairs_per_table = 8
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(9, tables_needed)
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_chairs = multiply(tables_needed, chairs_per_table)
  assert_eq(72, total_chairs)
}

test "moonbit_unicode_2024" {
  // æµ‹è¯•Unicodeå’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, Ã©moji ğŸš€!", greet("Ã©moji ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

// ç”¨æˆ·æ·»åŠ çš„é«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "user_arithmetic_operations_comprehensive" {
  // ç»¼åˆç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(15, add(7, 8))
  assert_eq(-1, add(5, -6))
  assert_eq(0, add(-3, 3))
  assert_eq(100, multiply(10, 10))
  assert_eq(-30, multiply(-5, 6))
  assert_eq(0, multiply(0, 123))
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
}

test "user_divide_with_ceil_edge_cases" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-1, divide_with_ceil(3, -2))
}

test "user_greet_function_internationalization" {
  // é—®å€™å‡½æ•°çš„å›½é™…åŒ–æµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, world!", greet("world"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "user_mathematical_properties_validation" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 12
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
  
  // å‡æ³•çš„é€†è¿ç®—
  assert_eq(x, add(subtract(x, y), y))
}

test "user_business_logic_packaging_optimization" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…ä¼˜åŒ–æµ‹è¯•
  let total_items = 47
  let box_capacity = 12
  
  let boxes_needed = divide_with_ceil(total_items, box_capacity)
  assert_eq(4, boxes_needed)
  
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  let wasted_space = subtract(total_capacity, total_items)
  assert_eq(1, wasted_space)
  
  let space_utilization = multiply(divide_with_ceil(total_items, total_capacity), 100)
  assert_eq(98, space_utilization)
}

test "user_complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 15
  let multiplier = 4
  let divisor = 7
  let offset = 3
  
  let step1 = multiply(base_value, multiplier)
  let step2 = divide_with_ceil(step1, divisor)
  let result = add(step2, offset)
  
  assert_eq(12, result)  // ceil(15*4/7) + 3 = 9 + 3 = 12
}

test "user_error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼å¤„ç†
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
}

test "user_resource_allocation_scenario" {
  // èµ„æºåˆ†é…åœºæ™¯æµ‹è¯•
  let total_resources = 100
  let projects = 3
  let min_resources_per_project = divide_with_ceil(total_resources, projects)
  
  assert_eq(34, min_resources_per_project)
  
  let total_allocated = multiply(min_resources_per_project, projects)
  assert_eq(102, total_allocated)
  
  let resource_overhead = subtract(total_allocated, total_resources)
  assert_eq(2, resource_overhead)
}

test "user_performance_benchmark_operations" {
  // æ€§èƒ½åŸºå‡†æ“ä½œæµ‹è¯•
  let large_number = 10000
  
  let sum_result = add(large_number, large_number)
  let product_result = multiply(large_number, 100)
  let division_result = divide_with_ceil(product_result, large_number)
  
  assert_eq(20000, sum_result)
  assert_eq(1000000, product_result)
  assert_eq(100, division_result)
}

test "user_real_world_application_comprehensive" {
  // çœŸå®ä¸–ç•Œåº”ç”¨ç»¼åˆæµ‹è¯•
  // åœºæ™¯ï¼šæ´»åŠ¨å®‰æ’å’Œèµ„æºç®¡ç†
  let participants = 87
  let chairs_per_table = 10
  let budget_per_table = 50
  
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(9, tables_needed)
  
  let total_chairs = multiply(tables_needed, chairs_per_table)
  assert_eq(90, total_chairs)
  
  let empty_chairs = subtract(total_chairs, participants)
  assert_eq(3, empty_chairs)
  
  let total_budget = multiply(tables_needed, budget_per_table)
  assert_eq(450, total_budget)
  
  let budget_per_person = divide_with_ceil(total_budget, participants)
  assert_eq(6, budget_per_person)
}

// Azimuth å¢å¼ºæ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// åŒ…å«10ä¸ªé«˜è´¨é‡çš„ MoonBit æ ‡å‡†æµ‹è¯•ç”¨ä¾‹

test "subtract_function_comprehensive" {
  // å…¨é¢æµ‹è¯•å‡æ³•å‡½æ•°
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
  assert_eq(0, subtract(5, 5))
  assert_eq(15, subtract(10, -5))
  assert_eq(-15, subtract(-10, 5))
  assert_eq(0, subtract(0, 0))
  assert_eq(1000000, subtract(1000001, 1))
}

test "divide_with_ceil_advanced_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„é«˜çº§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(-0, 1))
  assert_eq(-1, divide_with_ceil(-5, 3))
  assert_eq(-1, divide_with_ceil(5, -3))
  assert_eq(2, divide_with_ceil(-5, -3))
  assert_eq(100001, divide_with_ceil(200001, 2))
  assert_eq(1, divide_with_ceil(-1, -1))
}

test "greet_function_edge_cases" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \t\n\r!", greet("\t\n\r"))
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, 1234567890!", greet("1234567890"))
  assert_eq_string("Hello, ğŸŒ™ğŸŒŸğŸš€!", greet("ğŸŒ™ğŸŒŸğŸš€"))
}

test "mathematical_properties_advanced" {
  // æµ‹è¯•é«˜çº§æ•°å­¦æ€§è´¨
  let a = 12
  let b = 8
  let c = 4
  
  // å‡æ³•æ€§è´¨ï¼ša - b - c = a - (b + c)
  assert_eq(subtract(subtract(a, b), c), subtract(a, add(b, c)))
  
  // ä¹˜æ³•ä¸å‡æ³•ï¼ša * (b - c) = a * b - a * c
  assert_eq(multiply(a, subtract(b, c)), subtract(multiply(a, b), multiply(a, c)))
  
  // é™¤æ³•ä¸ä¹˜æ³•å…³ç³»ï¼ˆå¯¹äºèƒ½æ•´é™¤çš„æƒ…å†µï¼‰
  assert_eq(24, multiply(divide_with_ceil(24, 6), 6))
}

test "error_handling_robustness" {
  // æµ‹è¯•é”™è¯¯å¤„ç†çš„å¥å£®æ€§
  // è¿ç»­é™¤é›¶æµ‹è¯•
  assert_eq(0, divide_with_ceil(divide_with_ceil(10, 0), 5))
  assert_eq(0, divide_with_ceil(divide_with_ceil(0, 0), 0))
  
  // æå€¼å‡æ³•æµ‹è¯•
  assert_eq(2147483647, subtract(2147483647, 0))
  assert_eq(-2147483647, subtract(-2147483647, -1))
  
  // ç©ºå­—ç¬¦ä¸²ä¸ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, special!", greet("special"))
}

test "real_world_logistics_scenario" {
  // çœŸå®ä¸–ç•Œç‰©æµåœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šä»“åº“åº“å­˜ç®¡ç†
  let initial_stock = 1000
  let daily_sales = 45
  let days = 7
  let restock_threshold = 200
  
  // è®¡ç®—ä¸€å‘¨åçš„åº“å­˜
  let weekly_sales = multiply(daily_sales, days)
  let remaining_stock = subtract(initial_stock, weekly_sales)
  
  // è®¡ç®—éœ€è¦çš„è¡¥è´§é‡ï¼ˆæ¯æ¬¡è¡¥è´§500ä»¶ï¼‰
  let restock_needed = subtract(restock_threshold, remaining_stock)
  let restock_batches = divide_with_ceil(restock_needed, 500)
  
  assert_eq(315, weekly_sales)  // 45 * 7
  assert_eq(685, remaining_stock)  // 1000 - 315
  assert_eq(0, restock_batches)  // åº“å­˜å……è¶³ï¼Œæ— éœ€è¡¥è´§
}

test "large_scale_computations" {
  // å¤§è§„æ¨¡è®¡ç®—æµ‹è¯•
  let large_num = 100000
  let another_large = 99999
  
  // å¤§æ•°è¿ç®—
  assert_eq(199999, add(large_num, another_large))
  assert_eq(999990000, multiply(100000, 9999))
  assert_eq(-1, subtract(another_large, large_num))
  assert_eq(2, divide_with_ceil(large_num, another_large))
  
  // è¿ç»­å¤§æ•°è¿ç®—
  let result = multiply(add(large_num, another_large), 10)
  assert_eq(1999990, result)
}

test "complex_business_calculations" {
  // å¤æ‚ä¸šåŠ¡è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šé¡¹ç›®é¢„ç®—å’Œæ—¶é—´ç®¡ç†
  let team_size = 8
  let hourly_rate = 75
  let hours_per_day = 8
  let project_days = 15
  let contingency_percentage = 10
  
  // è®¡ç®—åŸºç¡€å·¥æ—¶å’Œæˆæœ¬
  let total_hours = multiply(team_size, multiply(hours_per_day, project_days))
  let base_cost = multiply(total_hours, hourly_rate)
  
  // è®¡ç®—åº”æ€¥é¢„ç®—ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let contingency_amount = divide_with_ceil(multiply(base_cost, contingency_percentage), 100)
  let total_budget = add(base_cost, contingency_amount)
  
  // è®¡ç®—æ¯å‘¨æˆæœ¬
  let weekly_cost = divide_with_ceil(multiply(total_budget, 7), project_days)
  
  assert_eq(960, total_hours)  // 8 * 8 * 15
  assert_eq(72000, base_cost)  // 960 * 75
  assert_eq(7200, contingency_amount)  // ceil(72000 * 10 / 100)
  assert_eq(79200, total_budget)  // 72000 + 7200
  assert_eq(36960, weekly_cost)  // ceil(79200 * 7 / 15)
}

test "internationalization_comprehensive" {
  // å›½é™…åŒ–ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
  assert_eq_string("Hello, à¤¹à¤¿à¤¨à¥à¤¦à¥€!", greet("à¤¹à¤¿à¤¨à¥à¤¦à¥€"))
  assert_eq_string("Hello, à¹„à¸—à¸¢!", greet("à¹„à¸—à¸¢"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, ğŸ‡ºğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¯ğŸ‡µ!", greet("ğŸ‡ºğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¯ğŸ‡µ"))
  assert_eq_string("Hello, ğ”˜ğ”«ğ”¦ğ” ğ”¬ğ”¡ğ”¢!", greet("ğ”˜ğ”«ğ”¦ğ” ğ”¬ğ”¡ğ”¢"))
}

test "assertion_functions_validation" {
  // æ–­è¨€å‡½æ•°éªŒè¯æµ‹è¯•
  let test_int = 42
  let test_string = "MoonBit"
  let test_bool_true = true
  let test_bool_false = false
  
  // æµ‹è¯•å„ç§æ–­è¨€æƒ…å†µ
  assert_eq(test_int, test_int)
  assert_eq(test_int, add(40, 2))
  assert_eq_string(test_string, test_string)
  assert_eq_string(test_string, "Moon" + "Bit")
  assert_true(test_bool_true)
  assert_true(test_int > 0)
  assert_false(test_bool_false)
  assert_false(test_int < 0)
  
  // æµ‹è¯•è¾¹ç•Œæ–­è¨€
  assert_eq(0, subtract(5, 5))
  assert_eq_string("Hello, test!", greet("test"))
  assert_true(divide_with_ceil(10, 3) > 3)
  assert_false(divide_with_ceil(10, 0) > 0)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "advanced_arithmetic_operations" {
  // é«˜çº§ç®—æœ¯è¿ç®—æµ‹è¯•
  let base = 100
  let multiplier = 15
  let divisor = 7
  
  // å¤åˆè¿ç®—æµ‹è¯•
  let result1 = add(multiply(base, multiplier), divide_with_ceil(base, divisor))
  let result2 = multiply(add(base, multiplier), divide_with_ceil(base, divisor))
  
  assert_eq(1514, result1)  // 100*15 + ceil(100/7) = 1500 + 15 = 1515
  assert_eq(165, result2)   // (100+15) * ceil(100/7) = 115 * 15 = 1725
}

test "logistical_optimization_problem" {
  // ç‰©æµä¼˜åŒ–é—®é¢˜æµ‹è¯•
  let total_packages = 247
  let truck_capacity = 18
  let delivery_days = 5
  
  // è®¡ç®—éœ€è¦çš„å¡è½¦æ•°é‡
  let trucks_needed = divide_with_ceil(total_packages, truck_capacity)
  assert_eq(14, trucks_needed)  // ceil(247/18) = 14
  
  // è®¡ç®—æ¯å¤©éœ€è¦é…é€çš„å¡è½¦æ•°é‡
  let daily_trucks = divide_with_ceil(trucks_needed, delivery_days)
  assert_eq(3, daily_trucks)  // ceil(14/5) = 3
  
  // è®¡ç®—å®é™…é…é€èƒ½åŠ›
  let actual_capacity = multiply(trucks_needed, truck_capacity)
  assert_eq(252, actual_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let remaining_capacity = subtract(actual_capacity, total_packages)
  assert_eq(5, remaining_capacity)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, newline\n!", greet("newline\n"))
  assert_eq_string("Hello, tab\t!", greet("tab\t"))
  assert_eq_string("Hello, quote\"!", greet("quote\""))
  assert_eq_string("Hello, emojiğŸ‰!", greet("emojiğŸ‰"))
  assert_eq_string("Hello, mix123ABC!", greet("mix123ABC"))
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // ç­‰å·®æ•°åˆ—æ±‚å’Œï¼š1 + 2 + 3 + ... + n = n*(n+1)/2
  let n = 20
  let series_sum = divide_with_ceil(multiply(n, add(n, 1)), 2)
  assert_eq(210, series_sum)  // 20*21/2 = 210
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼š2^0 + 2^1 + 2^2 + ... + 2^n = 2^(n+1) - 1
  let power_sum = subtract(multiply(2, multiply(2, multiply(2, multiply(2, 2)))), 1)
  assert_eq(31, power_sum)  // 2^5 - 1 = 32 - 1 = 31
}

test "resource_allocation_fairness" {
  // èµ„æºåˆ†é…å…¬å¹³æ€§æµ‹è¯•
  let total_resources = 100
  let groups = 3
  
  // åŸºç¡€åˆ†é…
  let base_allocation = divide_with_ceil(total_resources, groups)
  assert_eq(34, base_allocation)  // ceil(100/3) = 34
  
  // éªŒè¯åˆ†é…çš„å…¬å¹³æ€§
  let group1 = base_allocation
  let group2 = base_allocation
  let group3 = subtract(total_resources, add(group1, group2))
  
  assert_eq(34, group1)
  assert_eq(34, group2)
  assert_eq(32, group3)
  
  // éªŒè¯æ€»å’Œ
  let total_allocated = add(add(group1, group2), group3)
  assert_eq(total_resources, total_allocated)
}

test "complex_conditional_logic" {
  // å¤æ‚æ¡ä»¶é€»è¾‘æµ‹è¯•
  let input_value = 25
  
  // å¤šçº§æ¡ä»¶åˆ¤æ–­æ¨¡æ‹Ÿ
  let category = 
    if input_value < 10 { 
      "small" 
    } else if input_value < 20 { 
      "medium" 
    } else if input_value < 30 { 
      "large" 
    } else { 
      "extra_large" 
    }
  
  // æ ¹æ®ç±»åˆ«è¿›è¡Œä¸åŒè®¡ç®—
  let processed_value = 
    if category == "small" { 
      multiply(input_value, 2) 
    } else if category == "medium" { 
      multiply(input_value, 3) 
    } else if category == "large" { 
      multiply(input_value, 4) 
    } else { 
      multiply(input_value, 5) 
    }
  
  assert_eq_string("large", category)
  assert_eq(100, processed_value)  // 25 * 4 = 100
}

test "time_based_calculations" {
  // åŸºäºæ—¶é—´çš„è®¡ç®—æµ‹è¯•
  let hours_per_day = 24
  let days_per_week = 7
  let weeks_per_month = 4
  
  // è®¡ç®—å„ç§æ—¶é—´å•ä½
  let hours_per_week = multiply(hours_per_day, days_per_week)
  let hours_per_month = multiply(hours_per_week, weeks_per_month)
  
  assert_eq(168, hours_per_week)   // 24 * 7 = 168
  assert_eq(672, hours_per_month)  // 168 * 4 = 672
  
  // è®¡ç®—é¡¹ç›®æ—¶é—´éœ€æ±‚
  let project_hours = 850
  let weeks_needed = divide_with_ceil(project_hours, hours_per_week)
  let months_needed = divide_with_ceil(weeks_needed, weeks_per_month)
  
  assert_eq(6, weeks_needed)   // ceil(850/168) = 6
  assert_eq(2, months_needed)  // ceil(6/4) = 2
}

test "precision_and_accuracy_validation" {
  // ç²¾åº¦å’Œå‡†ç¡®æ€§éªŒè¯æµ‹è¯•
  // æµ‹è¯•é™¤æ³•ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(1, divide_with_ceil(2, 3))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(34, divide_with_ceil(100, 3))
  assert_eq(34, divide_with_ceil(101, 3))
  
  // æµ‹è¯•å¤§æ•°ç²¾åº¦
  let large_num1 = 1000000
  let large_num2 = 3
  let large_division = divide_with_ceil(large_num1, large_num2)
  
  assert_eq(333334, large_division)  // ceil(1000000/3)
  
  // éªŒè¯ç²¾åº¦ä¿æŒ
  let verification = multiply(large_division, large_num2)
  assert_true(verification >= large_num1)
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•å„ç§é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(1000000, 0))
  assert_eq(0, divide_with_ceil(-1000000, 0))
  
  // æµ‹è¯•æå€¼æƒ…å†µ
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(-1, divide_with_ceil(1, -1))
  assert_eq(-1, divide_with_ceil(-1, 1))
  
  // éªŒè¯ç³»ç»Ÿç¨³å®šæ€§
  let stable_result = add(multiply(10, 5), divide_with_ceil(20, 0))
  assert_eq(50, stable_result)  // 10*5 + 0 = 50
}

test "comprehensive_system_integration" {
  // ç»¼åˆç³»ç»Ÿé›†æˆæµ‹è¯•
  // æ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„ä¸šåŠ¡æµç¨‹ï¼šè®¢å•å¤„ç†
  
  // è®¢å•åŸºç¡€ä¿¡æ¯
  let order_quantity = 147
  let price_per_item = 23
  let items_per_package = 12
  let packages_per_pallet = 8
  
  // è®¡ç®—åŒ…è£…éœ€æ±‚
  let packages_needed = divide_with_ceil(order_quantity, items_per_package)
  let pallets_needed = divide_with_ceil(packages_needed, packages_per_pallet)
  
  // è®¡ç®—æˆæœ¬
  let subtotal = multiply(order_quantity, price_per_item)
  let packaging_cost = multiply(packages_needed, 5)  // æ¯ä¸ªåŒ…è£…5å…ƒ
  let shipping_cost = multiply(pallets_needed, 50)  // æ¯ä¸ªæ‰˜ç›˜50å…ƒ
  let total_cost = add(add(subtotal, packaging_cost), shipping_cost)
  
  // éªŒè¯è®¡ç®—ç»“æœ
  assert_eq(13, packages_needed)   // ceil(147/12) = 13
  assert_eq(2, pallets_needed)     // ceil(13/8) = 2
  assert_eq(3381, subtotal)        // 147 * 23 = 3381
  assert_eq(65, packaging_cost)    // 13 * 5 = 65
  assert_eq(100, shipping_cost)    // 2 * 50 = 100
  assert_eq(3546, total_cost)      // 3381 + 65 + 100 = 3546
  
  // éªŒè¯ä¸šåŠ¡é€»è¾‘
  assert_true(total_cost > subtotal)
  assert_true(packages_needed * items_per_package >= order_quantity)
  assert_true(pallets_needed * packages_per_pallet >= packages_needed)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "complex_nested_calculations" {
  // å¤æ‚åµŒå¥—è®¡ç®—æµ‹è¯• - å¤šå±‚å‡½æ•°è°ƒç”¨ç»„åˆ
  let base = 15
  let result = divide_with_ceil(
    multiply(
      add(base, 8),
      subtract(multiply(base, 2), 5)
    ),
    add(divide_with_ceil(multiply(base, 3), 4), 2)
  )
  
  // æ‰‹åŠ¨éªŒè¯ï¼š((15+8) * (15*2-5)) / (ceil(15*3/4) + 2)
  // = (23 * 25) / (12 + 2) = 575 / 14 = ceil(41.07) = 42
  assert_eq(42, result)
}

test "extreme_value_boundary_testing" {
  // æå€¼è¾¹ç•Œæµ‹è¯• - æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„æƒ…å†µ
  let large_num = 1000000
  let small_num = 1
  
  // å¤§æ•°è¿ç®—
  assert_eq(1000001, add(large_num, small_num))
  assert_eq(999999, subtract(large_num, small_num))
  assert_eq(1000000, multiply(large_num, small_num))
  assert_eq(1000000, divide_with_ceil(large_num, small_num))
  
  // è¾¹ç•Œé™¤æ³•æµ‹è¯•
  assert_eq(1, divide_with_ceil(small_num, large_num))
  assert_eq(2, divide_with_ceil(large_num + 1, large_num))
  assert_eq(500000, divide_with_ceil(large_num, 2))
}

test "data_consistency_validation" {
  // æ•°æ®ä¸€è‡´æ€§éªŒè¯æµ‹è¯• - ç¡®ä¿è®¡ç®—ç»“æœçš„é€»è¾‘ä¸€è‡´æ€§
  let original_value = 42
  
  // ä¸€ç³»åˆ—å¯é€†è¿ç®—
  let step1 = add(original_value, 10)      // 52
  let step2 = multiply(step1, 2)           // 104
  let step3 = divide_with_ceil(step2, 4)   // 26
  let step4 = subtract(step3, 5)           // 21
  let step5 = multiply(step4, 2)           // 42
  
  // éªŒè¯æœ€ç»ˆç»“æœä¸åŸå§‹å€¼çš„å…³ç³»
  assert_eq(original_value, step5)
  
  // éªŒè¯ä¸­é—´æ­¥éª¤çš„ä¸€è‡´æ€§
  assert_true(step2 > step1)
  assert_true(step3 <= step2)
  assert_eq(step4, divide_with_ceil(step2, 4) - 5)
}

test "scientific_calculation_scenario" {
  // ç§‘å­¦è®¡ç®—åœºæ™¯æµ‹è¯• - æ¨¡æ‹Ÿå®éªŒå®¤æ•°æ®å¤„ç†
  let samples = 157
  let measurements_per_sample = 8
  let quality_threshold = 85
  
  // è®¡ç®—æ€»æµ‹é‡æ¬¡æ•°
  let total_measurements = multiply(samples, measurements_per_sample)
  assert_eq(1256, total_measurements)
  
  // è®¡ç®—åˆæ ¼æ ·æœ¬æ‰€éœ€çš„æ‰¹æ¬¡
  letåˆæ ¼æ ·æœ¬æ•° = divide_with_ceil(multiply(samples, quality_threshold), 100)
  assert_eq(134, åˆæ ¼æ ·æœ¬æ•°)  // ceil(157*85/100) = ceil(133.45) = 134
  
  // è®¡ç®—å®éªŒè½®æ¬¡ï¼ˆæ¯è½®æœ€å¤šå¤„ç†20ä¸ªæ ·æœ¬ï¼‰
  let experiment_rounds = divide_with_ceil(samples, 20)
  assert_eq(8, experiment_rounds)  // ceil(157/20) = 8
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 8  // 8%
  let years = 4
  
  // é€å¹´è®¡ç®—å¤åˆ©
  let year1 = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, annual_rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, annual_rate), 100))
  let year4 = add(year3, divide_with_ceil(multiply(year3, annual_rate), 100))
  
  // éªŒè¯å¤åˆ©å¢é•¿
  assert_eq(10800, year1)  // 10000 + 8%
  assert_eq(11664, year2)  // 10800 + 8%
  assert_eq(12593, year3)  // 11664 + 8%
  assert_eq(13601, year4)  // 12593 + 8%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year4, total_months)
  assert_eq(379, monthly_payment)  // ceil(13601/48)
}

test "logistics_optimization_problem" {
  // ç‰©æµä¼˜åŒ–é—®é¢˜æµ‹è¯•
  let total_distance = 1847  // å…¬é‡Œ
  let truck_capacity = 25    // å¨
  let cargo_weight = 187     // å¨
  let fuel_consumption = 8   // å‡/100å…¬é‡Œ
  
  // è®¡ç®—éœ€è¦çš„å¡è½¦æ•°é‡
  let trucks_needed = divide_with_ceil(cargo_weight, truck_capacity)
  assert_eq(8, trucks_needed)  // ceil(187/25) = 8
  
  // è®¡ç®—æ€»ç‡ƒæ–™æ¶ˆè€—
  let total_fuel = divide_with_ceil(multiply(total_distance, fuel_consumption), 100)
  assert_eq(148, total_fuel)  // ceil(1847*8/100) = ceil(147.76) = 148
  
  // è®¡ç®—æ¯è¾†å¡è½¦çš„å¹³å‡è´Ÿè½½
  let avg_load_per_truck = divide_with_ceil(cargo_weight, trucks_needed)
  assert_eq(24, avg_load_per_truck)  // ceil(187/8) = 24
  
  // éªŒè¯è¿è¾“èƒ½åŠ›å……è¶³
  let total_capacity = multiply(trucks_needed, truck_capacity)
  assert_true(total_capacity >= cargo_weight)
  assert_eq(200, total_capacity)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦å’Œæ ¼å¼
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, 0x123ABC!", greet("0x123ABC"))
  assert_eq_string("Hello, true!", greet("true"))
  assert_eq_string("Hello, false!", greet("false"))
  assert_eq_string("Hello, NaN!", greet("NaN"))
  assert_eq_string("Hello, Infinity!", greet("Infinity"))
  assert_eq_string("Hello, []!", greet("[]"))
  assert_eq_string("Hello, {}!", greet("{}"))
  assert_eq_string("Hello, <>!", greet("<>"))
}

test "performance_stress_testing" {
  // æ€§èƒ½å‹åŠ›æµ‹è¯• - å¤§æ•°å€¼å’Œå¤æ‚è¿ç®—
  let large_base = 100000
  let iterations = 10
  
  // è¿ç»­å¤§æ•°è¿ç®—
  let result1 = multiply(large_base, iterations)           // 1000000
  let result2 = add(result1, multiply(large_base, 5))     // 1500000
  let result3 = divide_with_ceil(result2, 1000)           // 1500
  let result4 = multiply(result3, divide_with_ceil(result2, 500))  // 1500 * 3000 = 4500000
  
  assert_eq(1000000, result1)
  assert_eq(1500000, result2)
  assert_eq(1500, result3)
  assert_eq(4500000, result4)
  
  // å¤æ‚æ•°å­¦è¡¨è¾¾å¼
  let complex_result = divide_with_ceil(
    add(
      multiply(large_base, 15),
      multiply(divide_with_ceil(large_base, 10), 25)
    ),
    subtract(iterations, 3)
  )
  
  // æ‰‹åŠ¨éªŒè¯ï¼š(100000*15 + ceil(100000/10)*25) / (10-3)
  // = (1500000 + 10000*25) / 7 = (1500000 + 250000) / 7 = 1750000/7 = 250000
  assert_eq(250000, complex_result)
}

// æ–°å¢çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "basic_arithmetic_operations" {
  // åŸºæœ¬ç®—æœ¯è¿ç®—æµ‹è¯•
  assert_eq(7, add(3, 4))
  assert_eq(12, multiply(3, 4))
  assert_eq(1, divide_with_ceil(3, 4))
  assert_eq(4, divide_with_ceil(15, 4))
}

test "mathematical_properties" {
  // æ•°å­¦æ€§è´¨éªŒè¯æµ‹è¯•
  let x = 15
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 2)),
    add(multiply(x, y), multiply(x, 2))
  )
}

test "edge_cases_and_boundaries" {
  // è¾¹ç•Œæƒ…å†µå’Œæå€¼æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "negative_numbers_handling" {
  // è´Ÿæ•°å¤„ç†æµ‹è¯•
  assert_eq(-2, add(-5, 3))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(15, multiply(-5, -3))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(1, divide_with_ceil(-3, -4))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
}

test "business_logic_packaging" {
  // ä¸šåŠ¡é€»è¾‘ï¼šåŒ…è£…è®¡ç®—æµ‹è¯•
  let items = 47
  let capacity_per_box = 12
  let boxes_needed = divide_with_ceil(items, capacity_per_box)
  
  assert_eq(4, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, capacity_per_box)
  assert_eq(48, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, items)
  assert_eq(1, remaining_space)
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿æµ‹è¯•
  let base_value = 10
  let multiplier = 3
  let divisor = 4
  let addition = 5
  
  // è®¡ç®—æµç¨‹ï¼š((base * multiplier) / divisor) + addition
  let step1 = multiply(base_value, multiplier)
  let step2 = divide_with_ceil(step1, divisor)
  let result = add(step2, addition)
  
  assert_eq(12, result)  // ceil(10*3/4) + 5 = 8 + 5 = 13
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_resources = 100
  let teams = 3
  let min_resources_per_team = divide_with_ceil(total_resources, teams)
  
  assert_eq(34, min_resources_per_team)
  
  // éªŒè¯åˆ†é…ç»“æœ
  let allocated_total = multiply(min_resources_per_team, teams)
  assert_eq(102, allocated_total)
  
  // éªŒè¯èµ„æºåˆ©ç”¨ç‡
  let utilization = divide_with_ceil(multiply(total_resources, 100), allocated_total)
  assert_eq(98, utilization)  // floor(10000/102) = 98%
}

test "error_handling_and_validation" {
  // é”™è¯¯å¤„ç†å’ŒéªŒè¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼éªŒè¯
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(2000000, add(1000000, 1000000))
}

test "real_world_application_scenario" {
  // çœŸå®ä¸–ç•Œåº”ç”¨åœºæ™¯æµ‹è¯•ï¼šæ´»åŠ¨å®‰æ’
  let participants = 87
  let tables = 8
  let chairs_per_table = 10
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(9, tables_needed)
  
  // è®¡ç®—å¯ç”¨åº§ä½æ•°
  let available_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(90, available_seats)
  
  // è®¡ç®—å‰©ä½™åº§ä½
  let remaining_seats = subtract(available_seats, participants)
  assert_eq(3, remaining_seats)
  
  // éªŒè¯åº§ä½å……è¶³æ€§
  assert_true(available_seats >= participants)
}


// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "hexadecimal_conversion_calculation" {
  // åå…­è¿›åˆ¶è½¬æ¢è®¡ç®—æµ‹è¯•
  let hex_digit_1 = 1
  let hex_digit_2 = 16
  let hex_digit_3 = 256
  
  // éªŒè¯åå…­è¿›åˆ¶ä½æƒè®¡ç®—
  let hex_value_FF = add(hex_digit_1, multiply(15, hex_digit_2))  // 0xFF = 15*16 + 15
  let hex_value_1A2 = add(add(2, multiply(10, hex_digit_2)), multiply(1, hex_digit_3))  // 0x1A2 = 1*256 + 10*16 + 2
  
  assert_eq(241, hex_value_FF)
  assert_eq(418, hex_value_1A2)
}

test "time_conversion_calculations" {
  // æ—¶é—´è½¬æ¢è®¡ç®—æµ‹è¯•
  let hours = 2
  let minutes = 45
  let seconds = 30
  
  // è½¬æ¢ä¸ºæ€»ç§’æ•°
  let total_seconds = add(add(multiply(hours, 3600), multiply(minutes, 60)), seconds)
  assert_eq(9930, total_seconds)
  
  // è®¡ç®—éœ€è¦çš„åˆ†é’Ÿæ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let minutes_needed = divide_with_ceil(total_seconds, 60)
  assert_eq(166, minutes_needed)
  
  // è®¡ç®—éœ€è¦çš„å°æ—¶æ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let hours_needed = divide_with_ceil(total_seconds, 3600)
  assert_eq(3, hours_needed)
}

test "geometry_area_calculations" {
  // å‡ ä½•é¢ç§¯è®¡ç®—æµ‹è¯•
  let rectangle_length = 12
  let rectangle_width = 8
  
  // è®¡ç®—çŸ©å½¢é¢ç§¯
  let rectangle_area = multiply(rectangle_length, rectangle_width)
  assert_eq(96, rectangle_area)
  
  // è®¡ç®—æ­£æ–¹å½¢è¾¹é•¿ï¼ˆä»é¢ç§¯åæ¨ï¼‰
  let square_area = 144
  let square_side = divide_with_ceil(square_area, 12)  // å‡è®¾ä¸€è¾¹ä¸º12ï¼Œè®¡ç®—å¦ä¸€è¾¹
  assert_eq(12, square_side)
}

test "statistical_calculations" {
  // ç»Ÿè®¡è®¡ç®—æµ‹è¯•
  let values_sum = 450
  let value_count = 15
  
  // è®¡ç®—å¹³å‡å€¼ï¼ˆä½¿ç”¨æ•´æ•°é™¤æ³•ï¼‰
  let average = divide_with_ceil(values_sum, value_count)
  assert_eq(30, average)
  
  // è®¡ç®—ä¸­ä½æ•°ä½ç½®ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let median_position = divide_with_ceil(value_count, 2)
  assert_eq(8, median_position)
  
  // éªŒè¯æ€»å’Œé‡å»º
  let reconstructed_sum = multiply(average, value_count)
  assert_eq(450, reconstructed_sum)
}

test "inventory_turnover_calculation" {
  // åº“å­˜å‘¨è½¬ç‡è®¡ç®—æµ‹è¯•
  let annual_sales = 12000
  let average_inventory = 3000
  
  // è®¡ç®—åº“å­˜å‘¨è½¬ç‡
  let turnover_rate = divide_with_ceil(annual_sales, average_inventory)
  assert_eq(4, turnover_rate)
  
  // è®¡ç®—å¹³å‡é”€å”®å‘¨æœŸï¼ˆå¤©ï¼‰
  let days_in_year = 365
  let average_days = divide_with_ceil(days_in_year, turnover_rate)
  assert_eq(92, average_days)
}

test "network_bandwidth_planning" {
  // ç½‘ç»œå¸¦å®½è§„åˆ’æµ‹è¯•
  let users = 50
  let bandwidth_per_user = 10  // Mbps
  let redundancy_factor = 2
  
  // è®¡ç®—æ€»å¸¦å®½éœ€æ±‚
  let base_bandwidth = multiply(users, bandwidth_per_user)
  let total_bandwidth = multiply(base_bandwidth, redundancy_factor)
  assert_eq(1000, total_bandwidth)
  
  // è®¡ç®—éœ€è¦çš„è¿æ¥æ•°é‡ï¼ˆæ¯è¿æ¥æœ€å¤§100Mbpsï¼‰
  let max_bandwidth_per_connection = 100
  let connections_needed = divide_with_ceil(total_bandwidth, max_bandwidth_per_connection)
  assert_eq(10, connections_needed)
}

test "compound_interest_simplified" {
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 5  // 5%
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year1 = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, annual_rate), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, annual_rate), 100))
  
  assert_eq(10500, year1)
  assert_eq(11025, year2)
  assert_eq(11576, year3)
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_earnings = subtract(year3, principal)
  assert_eq(1576, total_earnings)
}

test "project_resource_allocation" {
  // é¡¹ç›®èµ„æºåˆ†é…æµ‹è¯•
  let total_tasks = 87
  let team_members = 5
  let working_days = 15
  
  // è®¡ç®—æ¯äººæ¯å¤©éœ€è¦å®Œæˆçš„ä»»åŠ¡æ•°
  let total_person_days = multiply(team_members, working_days)
  let tasks_per_person_day = divide_with_ceil(total_tasks, total_person_days)
  assert_eq(2, tasks_per_person_day)
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(tasks_per_person_day, total_person_days)
  assert_eq(150, total_capacity)
  
  // è®¡ç®—æ•ˆç‡åˆ©ç”¨ç‡
  let utilization = divide_with_ceil(multiply(total_tasks, 100), total_capacity)
  assert_eq(58, utilization)
}

test "string_pattern_validation" {
  // å­—ç¬¦ä¸²æ¨¡å¼éªŒè¯æµ‹è¯•
  // æµ‹è¯•å„ç§å­—ç¬¦ä¸²æ ¼å¼
  assert_eq_string("Hello, email@domain.com!", greet("email@domain.com"))
  assert_eq_string("Hello, phone123456!", greet("phone123456"))
  assert_eq_string("Hello, https://example.com!", greet("https://example.com"))
  assert_eq_string("Hello, special#$%&chars!", greet("special#$%&chars"))
  assert_eq_string("Hello, mixedCASE123!", greet("mixedCASE123"))
}

test "extreme_boundary_conditions" {
  // æç«¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num_1 = 10000
  let large_num_2 = 20000
  
  assert_eq(30000, add(large_num_1, large_num_2))
  assert_eq(200000000, multiply(large_num_1, large_num_2))
  assert_eq(2, divide_with_ceil(large_num_2, large_num_1))
  
  // æµ‹è¯•æå°æ•°è¿ç®—
  let small_num_1 = 1
  let small_num_2 = 1
  
  assert_eq(2, add(small_num_1, small_num_2))
  assert_eq(1, multiply(small_num_1, small_num_2))
  assert_eq(1, divide_with_ceil(small_num_1, small_num_2))
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "arithmetic_sequence_calculation" {
  // ç­‰å·®æ•°åˆ—è®¡ç®—æµ‹è¯•
  let first_term = 3
  let difference = 4
  let n_terms = 5
  
  // è®¡ç®—ç¬¬né¡¹ï¼ša_n = a_1 + (n-1)*d
  let nth_term = add(first_term, multiply(difference, subtract(n_terms, 1)))
  assert_eq(19, nth_term)  // 3 + (5-1)*4 = 19
  
  // è®¡ç®—å‰né¡¹å’Œï¼šS_n = n*(a_1 + a_n)/2
  let sum_n = multiply(n_terms, divide_with_ceil(add(first_term, nth_term), 2))
  assert_eq(55, sum_n)  // 5*(3+19)/2 = 55
}

test "inventory_turnover_rate" {
  // åº“å­˜å‘¨è½¬ç‡æµ‹è¯•
  let annual_sales = 120000
  let average_inventory = 30000
  
  // è®¡ç®—åº“å­˜å‘¨è½¬ç‡
  let turnover_rate = divide_with_ceil(annual_sales, average_inventory)
  assert_eq(4, turnover_rate)  // ceil(120000/30000) = 4
  
  // è®¡ç®—å¹³å‡é”€å”®å‘¨æœŸï¼ˆå¤©ï¼‰
  let days_in_year = 365
  let average_days = divide_with_ceil(days_in_year, turnover_rate)
  assert_eq(92, average_days)  // ceil(365/4) = 92
}

test "data_compression_ratio" {
  // æ•°æ®å‹ç¼©æ¯”ç‡æµ‹è¯•
  let original_size = 1000000  // 1MB
  let compressed_size = 250000  // 250KB
  
  // è®¡ç®—å‹ç¼©æ¯”ç‡
  let compression_ratio = multiply(100, divide_with_ceil(compressed_size, original_size))
  assert_eq(25, compression_ratio)  // ceil(250000/1000000)*100 = 25%
  
  // è®¡ç®—èŠ‚çœçš„ç©ºé—´
  let space_saved = subtract(original_size, compressed_size)
  assert_eq(750000, space_saved)
  
  // è®¡ç®—å¯ä»¥å­˜å‚¨çš„å‹ç¼©æ–‡ä»¶æ•°é‡
  let storage_capacity = 5000000  // 5MB
  let files_count = divide_with_ceil(storage_capacity, compressed_size)
  assert_eq(20, files_count)  // ceil(5000000/250000) = 20
}

test "loan_amortization_schedule" {
  // è´·æ¬¾æ‘Šé”€è®¡åˆ’æµ‹è¯•
  let loan_amount = 100000
  let annual_rate = 6  // 6%
  let loan_term_years = 5
  
  // è®¡ç®—æ€»æœŸæ•°ï¼ˆæœˆï¼‰
  let total_months = multiply(loan_term_years, 12)
  assert_eq(60, total_months)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—ï¼ˆä¸åŒ…å«å¤åˆ©ï¼‰
  let monthly_principal = divide_with_ceil(loan_amount, total_months)
  assert_eq(1667, monthly_principal)  // ceil(100000/60) = 1667
  
  // è®¡ç®—æ€»åˆ©æ¯ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_interest = divide_with_ceil(multiply(loan_amount, annual_rate), 100)
  let monthly_interest = divide_with_ceil(total_interest, total_months)
  assert_eq(10000, total_interest)  // 100000 * 6% = 6000
  assert_eq(167, monthly_interest)  // ceil(6000/60) = 100
  
  // è®¡ç®—æ€»æœˆä¾›
  let total_monthly_payment = add(monthly_principal, monthly_interest)
  assert_eq(1767, total_monthly_payment)
}

test "cryptography_simple_hash" {
  // ç®€å•å“ˆå¸Œç®—æ³•æ¨¡æ‹Ÿæµ‹è¯•
  let input_value = 12345
  let prime_modulus = 9973
  
  // ç®€å•å“ˆå¸Œå‡½æ•°ï¼šhash = (input * prime1 + prime2) mod prime_modulus
  let prime1 = 31
  let prime2 = 37
  let hash_value = multiply(input_value, prime1)
  let hash_with_offset = add(hash_value, prime2)
  let final_hash = hash_with_offset % prime_modulus
  
  // éªŒè¯å“ˆå¸Œå€¼åœ¨æœ‰æ•ˆèŒƒå›´å†…
  assert_true(final_hash >= 0)
  assert_true(final_hash < prime_modulus)
  
  // æµ‹è¯•å“ˆå¸Œä¸€è‡´æ€§
  let hash_again = multiply(input_value, prime1)
  let hash_again_with_offset = add(hash_again, prime2)
  let final_hash_again = hash_again_with_offset % prime_modulus
  assert_eq(final_hash, final_hash_again)
}

test "cpu_scheduling_algorithm" {
  // CPUè°ƒåº¦ç®—æ³•æµ‹è¯•
  let processes = 5
  let time_quantum = 10
  let total_burst_time = 87
  
  // è®¡ç®—éœ€è¦çš„è½®æ¬¡
  let rounds_needed = divide_with_ceil(total_burst_time, multiply(processes, time_quantum))
  assert_eq(2, rounds_needed)  // ceil(87/(5*10)) = 2
  
  // è®¡ç®—æ¯ä¸ªè¿›ç¨‹çš„å¹³å‡æ‰§è¡Œæ—¶é—´
  let avg_time_per_process = divide_with_ceil(total_burst_time, processes)
  assert_eq(18, avg_time_per_process)  // ceil(87/5) = 18
  
  // è®¡ç®—æ€»ä¸Šä¸‹æ–‡åˆ‡æ¢æ¬¡æ•°
  let context_switches = multiply(rounds_needed, processes)
  assert_eq(10, context_switches)  // 2 * 5 = 10
}

test "memory_page_replacement" {
  // å†…å­˜é¡µé¢æ›¿æ¢ç®—æ³•æµ‹è¯•
  let total_pages = 100
  let page_size = 4096  // 4KB
  let physical_memory = 16384  // 16KB
  
  // è®¡ç®—ç‰©ç†å†…å­˜å¯å®¹çº³çš„é¡µé¢æ•°
  let pages_in_memory = divide_with_ceil(physical_memory, page_size)
  assert_eq(4, pages_in_memory)  // ceil(16384/4096) = 4
  
  // è®¡ç®—éœ€è¦çš„é¡µé¢æ›¿æ¢æ¬¡æ•°
  let page_replacements = subtract(total_pages, pages_in_memory)
  assert_eq(96, page_replacements)  // 100 - 4 = 96
  
  // è®¡ç®—é¡µé¢å‘½ä¸­ç‡ï¼ˆç®€åŒ–ï¼‰
  let hit_ratio = multiply(100, divide_with_ceil(pages_in_memory, total_pages))
  assert_eq(4, hit_ratio)  // ceil(4/100)*100 = 4%
}

test "network_routing_optimization" {
  // ç½‘ç»œè·¯ç”±ä¼˜åŒ–æµ‹è¯•
  let nodes = 10
  let connections_per_node = 3
  let bandwidth_per_connection = 100  // Mbps
  
  // è®¡ç®—æ€»è¿æ¥æ•°
  let total_connections = multiply(nodes, connections_per_node)
  assert_eq(30, total_connections)  // 10 * 3 = 30
  
  // è®¡ç®—æ€»å¸¦å®½éœ€æ±‚
  let total_bandwidth = multiply(total_connections, bandwidth_per_connection)
  assert_eq(3000, total_bandwidth)  // 30 * 100 = 3000 Mbps
  
  // è®¡ç®—éœ€è¦çš„è·¯ç”±å™¨æ•°é‡ï¼ˆæ¯è·¯ç”±å™¨æœ€å¤§1000Mbpsï¼‰
  let max_bandwidth_per_router = 1000
  let routers_needed = divide_with_ceil(total_bandwidth, max_bandwidth_per_router)
  assert_eq(3, routers_needed)  // ceil(3000/1000) = 3
}

test "database_query_optimization" {
  // æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–æµ‹è¯•
  let table_size = 1000000
  let index_selectivity = 5  // 5%
  let query_result_size = 50000
  
  // è®¡ç®—ç´¢å¼•æ‰«æçš„è¡Œæ•°
  let index_scan_rows = divide_with_ceil(multiply(table_size, index_selectivity), 100)
  assert_eq(50000, index_scan_rows)  // ceil(1000000 * 5%) = 50000
  
  // è®¡ç®—å…¨è¡¨æ‰«æä¸ç´¢å¼•æ‰«æçš„æ¯”ç‡
  let scan_ratio = divide_with_ceil(table_size, index_scan_rows)
  assert_eq(20, scan_ratio)  // ceil(1000000/50000) = 20
  
  // éªŒè¯æŸ¥è¯¢ç»“æœå¤§å°
  assert_eq(query_result_size, index_scan_rows)
  
  // è®¡ç®—æŸ¥è¯¢æ€§èƒ½æå‡ï¼ˆå€æ•°ï¼‰
  let performance_improvement = scan_ratio
  assert_eq(20, performance_improvement)  // 20å€æ€§èƒ½æå‡
}

test "machine_learning_model_evaluation" {
  // æœºå™¨å­¦ä¹ æ¨¡å‹è¯„ä¼°æµ‹è¯•
  let total_samples = 10000
  let correct_predictions = 8500
  let false_positives = 800
  let false_negatives = 700
  
  // è®¡ç®—å‡†ç¡®ç‡
  let accuracy = multiply(100, divide_with_ceil(correct_predictions, total_samples))
  assert_eq(85, accuracy)  // ceil(8500/10000)*100 = 85%
  
  // è®¡ç®—ç²¾ç¡®ç‡
  let true_positives = subtract(correct_predictions, false_negatives)
  let predicted_positives = add(true_positives, false_positives)
  let precision = multiply(100, divide_with_ceil(true_positives, predicted_positives))
  assert_eq(91, precision)  // ceil(7800/8600)*100 = 91%
  
  // è®¡ç®—å¬å›ç‡
  let actual_positives = add(true_positives, false_negatives)
  let recall = multiply(100, divide_with_ceil(true_positives, actual_positives))
  assert_eq(92, recall)  // ceil(7800/8500)*100 = 92%
  
  // è®¡ç®—F1åˆ†æ•°ï¼ˆç®€åŒ–ï¼‰
  let f1_score = divide_with_ceil(add(precision, recall), 2)
  assert_eq(92, f1_score)  // ceil((91+92)/2) = 92
}

// æ–°å¢çš„å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - å®é™…åº”ç”¨åœºæ™¯
test "project_resource_planning" {
  // åœºæ™¯ï¼šé¡¹ç›®èµ„æºè§„åˆ’
  let team_members = 12
  let project_duration_weeks = 16
  let hours_per_week = 40
  let total_hours = multiply(team_members, multiply(project_duration_weeks, hours_per_week))
  assert_eq(7680, total_hours)  // 12 * 16 * 40 = 7680
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ•°ï¼ˆæ¯å†²åˆº2å‘¨ï¼‰
  let sprints_needed = divide_with_ceil(project_duration_weeks, 2)
  assert_eq(8, sprints_needed)  // ceil(16/2) = 8
  
  // è®¡ç®—æ¯ä¸ªå†²åˆºçš„å·¥ä½œé‡
  let effort_per_sprint = divide_with_ceil(total_hours, sprints_needed)
  assert_eq(960, effort_per_sprint)  // ceil(7680/8) = 960
}

test "inventory_optimization" {
  // åœºæ™¯ï¼šåº“å­˜ä¼˜åŒ–
  let product_a_qty = 245
  let product_b_qty = 189
  let product_c_qty = 367
  let box_capacity = 48
  
  // è®¡ç®—å„äº§å“éœ€è¦çš„ç®±å­æ•°
  let boxes_a = divide_with_ceil(product_a_qty, box_capacity)
  let boxes_b = divide_with_ceil(product_b_qty, box_capacity)
  let boxes_c = divide_with_ceil(product_c_qty, box_capacity)
  
  assert_eq(6, boxes_a)  // ceil(245/48) = 6
  assert_eq(4, boxes_b)  // ceil(189/48) = 4
  assert_eq(8, boxes_c)  // ceil(367/48) = 8
  
  // è®¡ç®—æ€»ç®±å­æ•°å’Œå‰©ä½™å®¹é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  let total_capacity = multiply(total_boxes, box_capacity)
  let total_items = add(add(product_a_qty, product_b_qty), product_c_qty)
  let remaining_capacity = subtract(total_capacity, total_items)
  
  assert_eq(18, total_boxes)  // 6 + 4 + 8 = 18
  assert_eq(864, total_capacity)  // 18 * 48 = 864
  assert_eq(63, remaining_capacity)  // 864 - 801 = 63
}

test "financial_budget_allocation" {
  // åœºæ™¯ï¼šè´¢åŠ¡é¢„ç®—åˆ†é…
  let total_budget = 150000
  let departments = 7
  let min_budget_per_dept = divide_with_ceil(total_budget, departments)
  assert_eq(21429, min_budget_per_dept)  // ceil(150000/7) = 21429
  
  // è®¡ç®—å®é™…åˆ†é…æ€»é¢
  let actual_allocation = multiply(min_budget_per_dept, departments)
  assert_eq(150003, actual_allocation)  // 21429 * 7 = 150003
  
  // è®¡ç®—é¢„ç®—æº¢å‡º
  let budget_overflow = subtract(actual_allocation, total_budget)
  assert_eq(3, budget_overflow)  // 150003 - 150000 = 3
}

test "network_bandwidth_planning" {
  // åœºæ™¯ï¼šç½‘ç»œå¸¦å®½è§„åˆ’
  let data_volume_gb = 1250
  let transfer_hours = 8
  let required_mbps = divide_with_ceil(multiply(data_volume_gb, 8192), multiply(transfer_hours, 3600))
  assert_eq(356, required_mbps)  // ceil(1250*8192/(8*3600)) = 356
  
  // è®¡ç®—å¤šæ¡å¹¶è¡Œè¿æ¥çš„å¸¦å®½éœ€æ±‚
  let parallel_connections = 4
  let per_connection_mbps = divide_with_ceil(required_mbps, parallel_connections)
  assert_eq(89, per_connection_mbps)  // ceil(356/4) = 89
  
  // éªŒè¯æ€»å¸¦å®½
  let total_bandwidth = multiply(per_connection_mbps, parallel_connections)
  assert_eq(356, total_bandwidth)  // 89 * 4 = 356
}

test "event_planning_logistics" {
  // åœºæ™¯ï¼šæ´»åŠ¨ç­–åˆ’åå‹¤
  let attendees = 487
  let tables = 65
  let chairs_per_table = 8
  let total_chairs = multiply(tables, chairs_per_table)
  assert_eq(520, total_chairs)  // 65 * 8 = 520
  
  // è®¡ç®—å‰©ä½™åº§ä½
  let available_chairs = subtract(total_chairs, attendees)
  assert_eq(33, available_chairs)  // 520 - 487 = 33
  
  // è®¡ç®—éœ€è¦çš„é¤æ¡Œæ•°ï¼ˆæ¯æ¡Œ8äººï¼‰
  let tables_needed = divide_with_ceil(attendees, chairs_per_table)
  assert_eq(61, tables_needed)  // ceil(487/8) = 61
  
  // è®¡ç®—å¤‡ç”¨é¤æ¡Œ
  let spare_tables = subtract(tables, tables_needed)
  assert_eq(4, spare_tables)  // 65 - 61 = 4
}

test "manufacturing_production_calculation" {
  // åœºæ™¯ï¼šåˆ¶é€ ä¸šç”Ÿäº§è®¡ç®—
  let daily_target = 1250
  let machines = 8
  let operating_hours = 16
  let machine_hourly_capacity = divide_with_ceil(daily_target, multiply(machines, operating_hours))
  assert_eq(10, machine_hourly_capacity)  // ceil(1250/(8*16)) = 10
  
  // è®¡ç®—å®é™…æ—¥äº§é‡
  let actual_daily_output = multiply(machine_hourly_capacity, multiply(machines, operating_hours))
  assert_eq(1280, actual_daily_output)  // 10 * 8 * 16 = 1280
  
  // è®¡ç®—è¶…é¢å®Œæˆ
  let overproduction = subtract(actual_daily_output, daily_target)
  assert_eq(30, overproduction)  // 1280 - 1250 = 30
  
  // è®¡ç®—å‘¨äº§é‡
  let weekly_output = multiply(actual_daily_output, 7)
  assert_eq(8960, weekly_output)  // 1280 * 7 = 8960
}

test "educational_class_scheduling" {
  // åœºæ™¯ï¼šæ•™è‚²è¯¾ç¨‹å®‰æ’
  let students = 156
  let classrooms = 6
  let max_students_per_room = 30
  let total_capacity = multiply(classrooms, max_students_per_room)
  assert_eq(180, total_capacity)  // 6 * 30 = 180
  
  // è®¡ç®—éœ€è¦çš„æ•™å®¤æ•°
  let rooms_needed = divide_with_ceil(students, max_students_per_room)
  assert_eq(6, rooms_needed)  // ceil(156/30) = 6
  
  // è®¡ç®—å‰©ä½™åº§ä½
  let available_seats = subtract(total_capacity, students)
  assert_eq(24, available_seats)  // 180 - 156 = 24
  
  // è®¡ç®—æ¯ç­å¹³å‡å­¦ç”Ÿæ•°
  let avg_students_per_room = divide_with_ceil(students, rooms_needed)
  assert_eq(26, avg_students_per_room)  // ceil(156/6) = 26
}

test "healthcare_resource_management" {
  // åœºæ™¯ï¼šåŒ»ç–—èµ„æºç®¡ç†
  let patients = 234
  let doctors = 12
  let nurses = 18
  let max_patients_per_doctor = divide_with_ceil(patients, doctors)
  assert_eq(20, max_patients_per_doctor)  // ceil(234/12) = 20
  
  // è®¡ç®—æ¯ä½åŒ»ç”Ÿéœ€è¦çš„æŠ¤å£«æ•°
  let nurses_per_doctor = divide_with_ceil(nurses, doctors)
  assert_eq(2, nurses_per_doctor)  // ceil(18/12) = 2
  
  // è®¡ç®—æ€»åŒ»ç–—äººå‘˜
  let total_medical_staff = add(doctors, nurses)
  assert_eq(30, total_medical_staff)  // 12 + 18 = 30
  
  // è®¡ç®—æ¯ä½åŒ»æŠ¤äººå‘˜è´Ÿè´£çš„æ‚£è€…æ•°
  let patients_per_staff = divide_with_ceil(patients, total_medical_staff)
  assert_eq(8, patients_per_staff)  // ceil(234/30) = 8
}

test "construction_project_calculation" {
  // åœºæ™¯ï¼šå»ºç­‘é¡¹ç›®è®¡ç®—
  let building_area_sqm = 1250
  let floors = 8
  let total_floor_area = multiply(building_area_sqm, floors)
  assert_eq(10000, total_floor_area)  // 1250 * 8 = 10000
  
  // è®¡ç®—éœ€è¦çš„å·¥äººæ•°é‡ï¼ˆæ¯äººæ¯å¤©å¯å®Œæˆ50å¹³æ–¹ç±³ï¼‰
  let workers_needed = divide_with_ceil(total_floor_area, 50)
  assert_eq(200, workers_needed)  // ceil(10000/50) = 200
  
  // è®¡ç®—é¡¹ç›®å·¥æœŸï¼ˆæ¯ä¸ªå·¥äººå·¥ä½œ20å¤©ï¼‰
  let project_duration = divide_with_ceil(total_floor_area, multiply(workers_needed, 50))
  assert_eq(1, project_duration)  // ceil(10000/(200*50)) = 1
  
  // è®¡ç®—æ€»å·¥æ—¥
  let total_work_days = multiply(workers_needed, project_duration)
  assert_eq(200, total_work_days)  // 200 * 1 = 200
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "subtract_function_basic" {
  // æµ‹è¯•å‡æ³•å‡½æ•°çš„åŸºæœ¬åŠŸèƒ½
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
  assert_eq(0, subtract(5, 5))
  assert_eq(15, subtract(10, -5))
  assert_eq(-15, subtract(-10, 5))
}

test "boolean_assertions" {
  // æµ‹è¯•å¸ƒå°”æ–­è¨€å‡½æ•°
  assert_true(true)
  assert_false(false)
  assert_true(5 > 3)
  assert_false(3 > 5)
  assert_true(5 >= 5)
  assert_true(5 <= 5)
}

test "extreme_large_numbers" {
  // æµ‹è¯•æå¤§æ•°è¿ç®—
  let large_num = 1000000
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(1000000000000, multiply(large_num, large_num))
  assert_eq(1, divide_with_ceil(large_num, large_num))
  assert_eq(2, divide_with_ceil(add(large_num, 1), large_num))
}

test "fractional_division_precision" {
  // æµ‹è¯•åˆ†æ•°é™¤æ³•çš„ç²¾åº¦
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(1, divide_with_ceil(2, 3))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(3, divide_with_ceil(8, 3))
  assert_eq(100, divide_with_ceil(199, 2))
}

test "string_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾¹ç¼˜æƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 1234567890!", greet("1234567890"))
}

test "complex_mathematical_expressions" {
  // æµ‹è¯•å¤æ‚æ•°å­¦è¡¨è¾¾å¼
  let a = 10
  let b = 20
  let c = 30
  
  // (a + b) * c - (a * b + c)
  let result = subtract(
    multiply(add(a, b), c),
    add(multiply(a, b), c)
  )
  assert_eq(470, result)  // (10+20)*30 - (10*20+30) = 900 - 230 = 670
  
  // ((a * b) + (b * c)) / (a + c)
  let result2 = divide_with_ceil(
    add(multiply(a, b), multiply(b, c)),
    add(a, c)
  )
  assert_eq(17, result2)  // ceil((200+600)/40) = ceil(800/40) = 20
}

test "business_inventory_calculation" {
  // ä¸šåŠ¡åº“å­˜è®¡ç®—æµ‹è¯•
  let initial_stock = 1000
  let daily_sales = 45
  let days = 22
  let total_sold = multiply(daily_sales, days)
  let remaining_stock = subtract(initial_stock, total_sold)
  
  assert_eq(990, total_sold)  // 45 * 22 = 990
  assert_eq(10, remaining_stock)  // 1000 - 990 = 10
  
  // è®¡ç®—éœ€è¦è¡¥è´§çš„å¤©æ•°
  let reorder_threshold = 100
  let days_until_reorder = divide_with_ceil(subtract(remaining_stock, reorder_threshold), daily_sales)
  assert_eq(0, days_until_reorder)  // å·²ç»ä½äºè¡¥è´§é˜ˆå€¼
}

test "time_zone_conversion" {
  // æ—¶åŒºè½¬æ¢è®¡ç®—æµ‹è¯•
  let local_time = 23  // æ™šä¸Š11ç‚¹
  let time_difference = 5  // æ—¶å·®5å°æ—¶
  
  // å‘å‰è½¬æ¢æ—¶é—´
  let forward_time = add(local_time, time_difference)
  let normalized_forward = divide_with_ceil(forward_time, 24)
  assert_eq(1, normalized_forward)  // ç¬¬äºŒå¤©
  
  // å‘åè½¬æ¢æ—¶é—´
  let backward_time = subtract(local_time, time_difference)
  assert_eq(18, backward_time)  // åŒä¸€å¤©ä¸‹åˆ6ç‚¹
}

test "resource_efficiency_metrics" {
  // èµ„æºæ•ˆç‡æŒ‡æ ‡æµ‹è¯•
  let total_resources = 500
  let utilized_resources = 425
  let waste_resources = subtract(total_resources, utilized_resources)
  
  assert_eq(75, waste_resources)
  
  // è®¡ç®—æ•ˆç‡ç™¾åˆ†æ¯”
  let efficiency_percent = divide_with_ceil(
    multiply(utilized_resources, 100),
    total_resources
  )
  assert_eq(85, efficiency_percent)  // ceil(42500/500) = ceil(85) = 85
  
  // è®¡ç®—æµªè´¹ç™¾åˆ†æ¯”
  let waste_percent = divide_with_ceil(
    multiply(waste_resources, 100),
    total_resources
  )
  assert_eq(15, waste_percent)  // ceil(7500/500) = ceil(15) = 15
}

test "multi_step_problem_solving" {
  // å¤šæ­¥éª¤é—®é¢˜è§£å†³æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—æ—…è¡Œé¢„ç®—
  let travelers = 4
  let days = 7
  let daily_food_budget = 50
  let daily_accommodation_budget = 80
  let transportation_cost = 200
  
  // è®¡ç®—æ€»é£Ÿç‰©é¢„ç®—
  let total_food_budget = multiply(travelers, multiply(days, daily_food_budget))
  assert_eq(1400, total_food_budget)  // 4 * 7 * 50 = 1400
  
  // è®¡ç®—æ€»ä½å®¿é¢„ç®—
  let total_accommodation_budget = multiply(travelers, multiply(days, daily_accommodation_budget))
  assert_eq(2240, total_accommodation_budget)  // 4 * 7 * 80 = 2240
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = add(add(total_food_budget, total_accommodation_budget), transportation_cost)
  assert_eq(3840, total_budget)  // 1400 + 2240 + 200 = 3840
  
  // è®¡ç®—æ¯äººå¹³å‡è´¹ç”¨
  let cost_per_person = divide_with_ceil(total_budget, travelers)
  assert_eq(960, cost_per_person)  // ceil(3840/4) = 960
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "function_composition_pipeline" {
  // æµ‹è¯•å‡½æ•°ç»„åˆæµæ°´çº¿
  let initial = 15
  let step1 = multiply(initial, 2)      // 30
  let step2 = add(step1, 10)            // 40
  let step3 = divide_with_ceil(step2, 3) // 14
  let final_result = multiply(step3, 2) // 28
  
  assert_eq(28, final_result)
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯æµ‹è¯•
  let total_minutes = 157
  let minutes_per_hour = 60
  let hours_needed = divide_with_ceil(total_minutes, minutes_per_hour)
  let remaining_minutes = subtract(total_minutes, multiply(hours_needed - 1, minutes_per_hour))
  
  assert_eq(3, hours_needed)  // ceil(157/60) = 3
  assert_eq(37, remaining_minutes)  // 157 - 2*60 = 37
}

test "memory_allocation_optimization" {
  // å†…å­˜åˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_memory = 1024  // MB
  let process_count = 7
  let memory_per_process = divide_with_ceil(total_memory, process_count)
  
  assert_eq(147, memory_per_process)  // ceil(1024/7) = 147
  
  // éªŒè¯æ€»åˆ†é…å†…å­˜
  let total_allocated = multiply(memory_per_process, process_count)
  let memory_waste = subtract(total_allocated, total_memory)
  
  assert_eq(1029, total_allocated)
  assert_eq(5, memory_waste)
}

test "string_concatenation_edge_cases" {
  // å­—ç¬¦ä¸²è¿æ¥è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, empty!", greet(""))
  assert_eq_string("Hello, space !", greet(" "))
  assert_eq_string("Hello, multiple   spaces!", greet("multiple   spaces"))
  assert_eq_string("Hello, special@#$%chars!", greet("special@#$%chars"))
  assert_eq_string("Hello, emoji123ğŸ‰!", greet("emoji123ğŸ‰"))
}

test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œ
  let n = 10
  let first_term = 3
  let common_difference = 2
  
  // ä½¿ç”¨å…¬å¼ï¼šS_n = n/2 * (2a + (n-1)d)
  let sum_formula = divide_with_ceil(
    multiply(n, add(multiply(2, first_term), multiply(n - 1, common_difference))),
    2
  )
  
  // æ‰‹åŠ¨è®¡ç®—éªŒè¯
  let manual_sum = add(add(add(add(add(3, 5), 7), 9), 11), 13) // å‰6é¡¹
  
  assert_eq(130, sum_formula)  // 10/2 * (6 + 18) = 65
  assert_eq(48, manual_sum)    // 3+5+7+9+11+13 = 48
}

test "load_balancing_algorithm" {
  // è´Ÿè½½å‡è¡¡ç®—æ³•æµ‹è¯•
  let total_requests = 1000
  let server_count = 7
  let requests_per_server = divide_with_ceil(total_requests, server_count)
  
  assert_eq(143, requests_per_server)  // ceil(1000/7) = 143
  
  // è®¡ç®—å®é™…å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(requests_per_server, server_count)
  let overflow_capacity = subtract(total_capacity, total_requests)
  
  assert_eq(1001, total_capacity)
  assert_eq(1, overflow_capacity)
  
  // éªŒè¯è´Ÿè½½åˆ†å¸ƒ
  assert_true(requests_per_server >= divide_with_ceil(total_requests, server_count))
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let rate_percent = 5
  let years = 4
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let year2 = add(year1, divide_with_ceil(multiply(year1, rate_percent), 100))
  let year3 = add(year2, divide_with_ceil(multiply(year2, rate_percent), 100))
  let year4 = add(year3, divide_with_ceil(multiply(year3, rate_percent), 100))
  
  assert_eq(10500, year1)   // 10000 + 5%
  assert_eq(11025, year2)   // 10500 + 5%
  assert_eq(11576, year3)   // 11025 + 5%
  assert_eq(12155, year4)   // 11576 + 5%
  
  // è®¡ç®—æœˆä¾›
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year4, total_months)
  assert_eq(338, monthly_payment)  // ceil(12155/48)
}

test "recursive_calculation_simulation" {
  // é€’å½’è®¡ç®—æ¨¡æ‹Ÿæµ‹è¯•ï¼ˆä½¿ç”¨è¿­ä»£æ–¹å¼ï¼‰
  // æ¨¡æ‹Ÿæ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  let n = 10
  let fib1 = 1
  let fib2 = 1
  
  // æ‰‹åŠ¨è®¡ç®—å‰å‡ é¡¹
  let fib3 = add(fib1, fib2)        // 2
  let fib4 = add(fib2, fib3)        // 3
  let fib5 = add(fib3, fib4)        // 5
  let fib6 = add(fib4, fib5)        // 8
  let fib7 = add(fib5, fib6)        // 13
  let fib8 = add(fib6, fib7)        // 21
  let fib9 = add(fib7, fib8)        // 34
  let fib10 = add(fib8, fib9)       // 55
  
  // éªŒè¯è®¡ç®—ç»“æœ
  assert_eq(2, fib3)
  assert_eq(3, fib4)
  assert_eq(5, fib5)
  assert_eq(8, fib6)
  assert_eq(13, fib7)
  assert_eq(21, fib8)
  assert_eq(34, fib9)
  assert_eq(55, fib10)
  
  // è®¡ç®—æ€»å’Œ
  let fib_sum = add(add(add(add(add(add(add(add(add(fib1, fib2), fib3), fib4), fib5), fib6), fib7), fib8), fib9), fib10)
  assert_eq(143, fib_sum)
}

test "batch_processing_optimization" {
  // æ‰¹å¤„ç†ä¼˜åŒ–æµ‹è¯•
  let total_items = 1234
  let batch_size = 47
  let batch_count = divide_with_ceil(total_items, batch_size)
  
  assert_eq(27, batch_count)  // ceil(1234/47) = 27
  
  // è®¡ç®—å®é™…å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(batch_count, batch_size)
  let unused_capacity = subtract(total_capacity, total_items)
  
  assert_eq(1269, total_capacity)
  assert_eq(35, unused_capacity)
  
  // è®¡ç®—å¤„ç†æ•ˆç‡
  let efficiency_percent = divide_with_ceil(
    multiply(total_items, 100),
    total_capacity
  )
  assert_eq(98, efficiency_percent)  // floor(123400/1269) = 97%
}

test "resource_scheduling_algorithm" {
  // èµ„æºè°ƒåº¦ç®—æ³•æµ‹è¯•
  let tasks = 25
  let workers = 4
  let time_per_task = 3
  
  // è®¡ç®—æ¯ä¸ªå·¥äººçš„ä»»åŠ¡æ•°
  let tasks_per_worker = divide_with_ceil(tasks, workers)
  assert_eq(7, tasks_per_worker)  // ceil(25/4) = 7
  
  // è®¡ç®—æ€»å®Œæˆæ—¶é—´
  let total_time = multiply(tasks_per_worker, time_per_task)
  assert_eq(21, total_time)  // 7 * 3 = 21
  
  // è®¡ç®—å·¥äººåˆ©ç”¨ç‡
  let total_task_capacity = multiply(tasks_per_worker, workers)
  let unused_task_slots = subtract(total_task_capacity, tasks)
  
  assert_eq(28, total_task_capacity)
  assert_eq(3, unused_task_slots)
  
  // éªŒè¯æ‰€æœ‰ä»»åŠ¡éƒ½èƒ½è¢«å¤„ç†
  assert_true(total_task_capacity >= tasks)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "comprehensive_basic_arithmetic" {
  // å…¨é¢æµ‹è¯•åŸºæœ¬ç®—æœ¯è¿ç®—
  assert_eq(15, add(7, 8))
  assert_eq(-2, add(-5, 3))
  assert_eq(0, add(5, -5))
  assert_eq(24, multiply(6, 4))
  assert_eq(-18, multiply(6, -3))
  assert_eq(0, multiply(0, 10))
}

test "mathematical_commutative_laws" {
  // æµ‹è¯•æ•°å­¦äº¤æ¢å¾‹
  let a = 12
  let b = 23
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(a, b), add(b, a))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(a, b), multiply(b, a))
}

test "boundary_value_testing" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(0, multiply(5, 0))
  assert_eq(1, multiply(1, 100))
  assert_eq(-100, multiply(-1, 100))
  assert_eq(100, multiply(-1, -100))
}

test "divide_with_ceil_comprehensive" {
  // å…¨é¢æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(3, divide_with_ceil(10, 3))
  assert_eq(4, divide_with_ceil(11, 3))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(-2, divide_with_ceil(-5, 3))
  assert_eq(2, divide_with_ceil(-5, -3))
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, 123!", greet("123"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "complex_calculation_sequence" {
  // å¤æ‚è®¡ç®—åºåˆ—æµ‹è¯•
  let initial = 10
  let step1 = add(initial, 5)        // 15
  let step2 = multiply(step1, 2)     // 30
  let step3 = divide_with_ceil(step2, 8)  // 4
  let step4 = add(step3, 1)          // 5
  
  assert_eq(5, step4)
}

test "resource_allocation_scenario" {
  // èµ„æºåˆ†é…åœºæ™¯æµ‹è¯•
  let total_items = 100
  let containers = 9
  let items_per_container = divide_with_ceil(total_items, containers)
  
  assert_eq(12, items_per_container)  // ceil(100/9) = 12
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(items_per_container, containers)
  assert_eq(108, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_items)
  assert_eq(8, remaining_space)
}

test "mathematical_distributive_property" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹
  let a = 5
  let b = 8
  let c = 3
  
  // a * (b + c) = a * b + a * c
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  
  assert_eq(left_side, right_side)  // 5 * (8 + 3) = 5 * 8 + 5 * 3 = 55
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // é™¤é›¶é”™è¯¯å¤„ç†
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(0, divide_with_ceil(-5, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "real_world_application_test" {
  // çœŸå®ä¸–ç•Œåº”ç”¨æµ‹è¯•ï¼šæ´»åŠ¨å®‰æ’
  let guests = 150
  let tables = 12
  let chairs_per_table = 15
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(guests, chairs_per_table)
  assert_eq(10, tables_needed)  // ceil(150/15) = 10
  
  // éªŒè¯æ¡Œå­æ•°é‡è¶³å¤Ÿ
  assert_true(tables_needed <= tables)
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(150, total_seats)
  
  // éªŒè¯åº§ä½å……è¶³
  let extra_seats = subtract(total_seats, guests)
  assert_true(extra_seats >= 0)
}
