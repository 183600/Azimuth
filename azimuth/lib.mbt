pub fn add(a : Int, b : Int) -> Int {
  // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœæœ‰ä¸€ä¸ªæ˜¯0ï¼Œç›´æ¥è¿”å›å¦ä¸€ä¸ª
  if a == 0 {
    return b
  }
  if b == 0 {
    return a
  }

  // å¤„ç†æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼ˆInt32çš„æœ€å°å€¼ï¼‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†ä¸€ä¸ªæ“ä½œæ•°æ˜¯æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ + è´Ÿæ•° = å¯èƒ½æº¢å‡º
    if b < 0 {
      return min_val
    }
    // æœ€å°å€¼ + éè´Ÿæ•° = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }
  if b == min_val {
    // è´Ÿæ•° + æœ€å°å€¼ = å¯èƒ½æº¢å‡º
    if a < 0 {
      return min_val
    }
    // éè´Ÿæ•° + æœ€å°å€¼ = ä¸ä¼šæº¢å‡ºï¼Œç›´æ¥è®¡ç®—
    return a + b
  }

  // æ­£æ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥
  if a > 0 && b > 0 {
    // å¦‚æœ a > max_val - bï¼Œåˆ™ a + b ä¼šæº¢å‡º
    if a > max_val - b {
      return max_val
    }
  }

  // è´Ÿæ•°ç›¸åŠ æº¢å‡ºæ£€æŸ¥ï¼ˆæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼ï¼‰
  if a < 0 && b < 0 {
    // ä½¿ç”¨å‡æ³•æ£€æŸ¥ï¼ša < min_val - b
    // ç”±äºbæ˜¯è´Ÿæ•°ï¼Œmin_val - b = min_val + abs(b)
    if a < min_val - b {
      return min_val
    }
  }

  // å®‰å…¨åœ°è¿›è¡ŒåŠ æ³•è¿ç®—
  return a + b
}

///
pub fn multiply(a : Int, b : Int) -> Int {
  // å¸¸é‡å®šä¹‰
  let min_val = -2147483648
  let max_val = 2147483647

  // å¤„ç†0çš„æƒ…å†µ
  if a == 0 || b == 0 {
    return 0
  }

  // å¤„ç†1çš„æƒ…å†µ
  if a == 1 {
    return b
  }
  if b == 1 {
    return a
  }

  // å¤„ç†-1çš„æƒ…å†µï¼ˆåŒ…æ‹¬æœ€å°å€¼çš„ç‰¹æ®Šæƒ…å†µï¼‰
  if a == -1 {
    // -2147483648 * -1 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if b == min_val { min_val } else { -b }
  }
  if b == -1 {
    // -1 * -2147483648 = 2147483648 ä¼šæº¢å‡ºï¼Œåº”è¯¥è¿”å› min_val
    return if a == min_val { min_val } else { -a }
  }

  // å¤„ç†æœ€å°å€¼çš„æƒ…å†µ
  if a == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if b > 1 || b < -1 { min_val } else { a * b }
  }
  if b == min_val {
    // æœ€å°å€¼ä¹˜ä»¥ä»»ä½•ç»å¯¹å€¼å¤§äº1çš„æ•°éƒ½ä¼šæº¢å‡º
    return if a > 1 || a < -1 { min_val } else { a * b }
  }

  // æ£€æŸ¥æ­£è´Ÿå·
  let sign = if (a > 0 && b > 0) || (a < 0 && b < 0) { 1 } else { -1 }

  // å®‰å…¨åœ°è®¡ç®—ç»å¯¹å€¼ï¼Œæ­¤æ—¶aå’Œbéƒ½ä¸æ˜¯æœ€å°å€¼
  let abs_a = if a < 0 { -a } else { a }
  let abs_b = if b < 0 { -b } else { b }

  // ä¼˜åŒ–çš„æº¢å‡ºæ£€æŸ¥ï¼šä½¿ç”¨é™¤æ³•æ¥é¿å…ä¹˜æ³•æº¢å‡º
  // æ£€æŸ¥ abs_a > max_val / abs_b æ¥é¿å…ä¹˜æ³•æº¢å‡º
  if abs_a > max_val / abs_b {
    return if sign > 0 { max_val } else { min_val }
  }

  // å®‰å…¨åœ°è¿›è¡Œä¹˜æ³•è¿ç®—
  return a * b
}

///
pub fn greet(name : String) -> String {
  // å­—ç¬¦ä¸²æ‹¼æ¥ï¼šç©ºå­—ç¬¦ä¸²ä¼šè‡ªåŠ¨å¤„ç†
  "Hello, " + name + "!"
}

// æµ‹è¯•è¾…åŠ©å‡½æ•°ï¼Œæä¾›æ–­è¨€åŠŸèƒ½
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (expected == actual) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (expected == actual) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_true(condition : Bool) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (condition) {
    ()
  } else {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  }
}

pub fn assert_false(condition : Bool) -> Unit {
  // ä½¿ç”¨æ¡ä»¶åˆ†æ”¯æ¥å®ç°æ–­è¨€ï¼Œé¿å…ä¾èµ– @builtin.abort
  if (condition) {
    // å½“æ–­è¨€å¤±è´¥æ—¶ï¼ŒæŠ›å‡ºä¸€ä¸ªé”™è¯¯
    // ä½¿ç”¨æ•´æ•°é™¤ä»¥é›¶æ¥è§¦å‘è¿è¡Œæ—¶é”™è¯¯
    let _ = 1 / 0
    ()
  } else {
    ()
  }
}

// å‘ä¸Šå–æ•´é™¤æ³•å‡½æ•°
pub fn divide_with_ceil(dividend : Int, divisor : Int) -> Int {
  let quotient = dividend / divisor
  let remainder = dividend % divisor
  if remainder > 0 { add(quotient, 1) } else { quotient }
}

// å¢å¼ºçš„æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åŒ…çš„ä¸»è¦åŠŸèƒ½

test "add_function_edge_cases" {
  // æµ‹è¯•è¾¹ç•Œå€¼å’Œç‰¹æ®Šæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(max_val, add(max_val, 0))
  assert_eq(min_val, add(min_val, 0))
  assert_eq(max_val, add(0, max_val))
  assert_eq(min_val, add(0, min_val))
  
  // å¯¹ç§°æ€§æµ‹è¯•
  assert_eq(add(5, 3), add(3, 5))
  assert_eq(add(-5, 3), add(3, -5))
}

test "multiply_function_special_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„ç‰¹æ®Šæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // é›¶ä¹˜æ³•æµ‹è¯•
  assert_eq(0, multiply(0, max_val))
  assert_eq(0, multiply(0, min_val))
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  
  // è´Ÿä¸€ä¹˜æ³•æµ‹è¯•
  assert_eq(-5, multiply(-1, 5))
  assert_eq(5, multiply(-1, -5))
  assert_eq(min_val, multiply(-1, min_val)) // ç‰¹æ®Šæƒ…å†µï¼šæœ€å°å€¼ä¹˜ä»¥-1ä¼šæº¢å‡º
}

test "greet_function_unicode_handling" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†å’ŒUnicodeå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, MoonBitğŸš€!", greet("MoonBitğŸš€"))
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello,   !", greet("   ")) // ç©ºæ ¼æµ‹è¯•
}

test "divide_with_ceil_comprehensive" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å„ç§æƒ…å†µ
  // æ­£æ•°æµ‹è¯•
  assert_eq(4, divide_with_ceil(11, 3))
  assert_eq(4, divide_with_ceil(12, 3))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(2, 2))
  
  // è´Ÿæ•°æµ‹è¯•
  assert_eq(-3, divide_with_ceil(-8, 3))
  assert_eq(-2, divide_with_ceil(-9, 3))
  assert_eq(-3, divide_with_ceil(-10, 4))
  
  // æ··åˆç¬¦å·æµ‹è¯•
  assert_eq(-2, divide_with_ceil(5, -3))
  assert_eq(2, divide_with_ceil(-5, 3))
}

test "combined_operations_test" {
  // æµ‹è¯•ç»„åˆæ“ä½œ
  let a = 10
  let b = 3
  
  // åŠ æ³•åä¹˜æ³•
  assert_eq(39, multiply(add(a, b), 3))
  
  // ä¹˜æ³•ååŠ æ³•
  assert_eq(33, add(multiply(a, b), 3))
  
  // å¤æ‚è¡¨è¾¾å¼
  assert_eq(16, add(multiply(2, 5), divide_with_ceil(10, 3)))
}

test "mathematical_properties" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨
  
  // åŠ æ³•ç»“åˆå¾‹ï¼ˆåœ¨å®‰å…¨èŒƒå›´å†…ï¼‰
  assert_eq(add(add(2, 3), 4), add(2, add(3, 4)))
  
  // ä¹˜æ³•ç»“åˆå¾‹ï¼ˆåœ¨å®‰å…¨èŒƒå›´å†…ï¼‰
  assert_eq(multiply(multiply(2, 3), 4), multiply(2, multiply(3, 4)))
  
  // åˆ†é…å¾‹ï¼ˆåœ¨å®‰å…¨èŒƒå›´å†…ï¼‰
  assert_eq(multiply(2, add(3, 4)), add(multiply(2, 3), multiply(2, 4)))
}

test "boundary_comprehensive_test" {
  // ç»¼åˆè¾¹ç•Œæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æ¥è¿‘è¾¹ç•Œçš„åŠ æ³•
  assert_eq(max_val, add(max_val - 100, 100))
  assert_eq(max_val, add(max_val - 1000, 1000))
  
  // æ¥è¿‘è¾¹ç•Œçš„ä¹˜æ³•
  assert_eq(max_val, multiply(46340, 46341)) // æ¥è¿‘sqrt(max_val)
  
  // æœ€å°å€¼å¤„ç†
  assert_eq(min_val, add(min_val, 0))
  assert_eq(0, multiply(min_val, 0))
}

test "string_edge_cases" {
  // å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, abcdefghijklmnopqrstuvwxyz!", greet("abcdefghijklmnopqrstuvwxyz"))
}

test "assert_functions_comprehensive" {
  // æ–­è¨€å‡½æ•°ç»¼åˆæµ‹è¯•
  assert_true(1 == 1)
  assert_true(0 == 0)
  assert_true(-1 == -1)
  assert_true(true)
  
  assert_false(1 == 2)
  assert_false(false)
  assert_false(1 > 2)
  
  assert_eq(42, 42)
  assert_eq(-42, -42)
  assert_eq(0, 0)
  
  assert_eq_string("", "")
  assert_eq_string("test", "test")
  assert_eq_string("Hello, World!", "Hello, World!")
}

test "extreme_boundary_combinations" {
  // æç«¯è¾¹ç•Œå€¼ç»„åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸æœ€å°å€¼çš„ç»„åˆè¿ç®—
  assert_eq(max_val - 1, add(max_val, min_val))
  assert_eq(min_val + 1, add(min_val, max_val))
  
  // è¾¹ç•Œå€¼çš„ä¹˜æ³•ç»„åˆ
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  assert_eq(min_val, multiply(min_val, 1))
}

test "large_number_operations" {
  // å¤§æ•°è¿ç®—æµ‹è¯•
  let large_num = 1000000
  let large_neg = -1000000
  
  // å¤§æ•°åŠ æ³•
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(0, add(large_num, large_neg))
  
  // å¤§æ•°ä¹˜æ³•ï¼ˆè°ƒæ•´åˆ°èŒƒå›´å†…ï¼‰
  assert_eq(100000000, multiply(10000, 10000))
  assert_eq(-100000000, multiply(10000, -10000))
  
  // å¤§æ•°ä¸è¾¹ç•Œå€¼ç»„åˆ
  assert_eq(2147483647, add(2147483647 - 1000000, 1000000))
}

test "special_string_characters" {
  // ç‰¹æ®Šå­—ç¬¦ä¸²å­—ç¬¦å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, \\\"\\'\\!", greet("\\\"\\'\\!"))
  assert_eq_string("Hello, \u0000\u0000\u0000!", greet("\u0000\u0000\u0000"))
  assert_eq_string("Hello, ä¸­æ–‡å­—ç¬¦ğŸŒŸ!", greet("ä¸­æ–‡å­—ç¬¦ğŸŒŸ"))
  assert_eq_string("Hello, emojiğŸ˜€ğŸ˜ğŸ˜‚!", greet("emojiğŸ˜€ğŸ˜ğŸ˜‚"))
}

test "negative_division_edge_cases" {
  // è´Ÿæ•°é™¤æ³•è¾¹ç•Œæƒ…å†µæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è´Ÿæ•°é™¤ä»¥æ­£æ•°
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-1073741824, divide_with_ceil(min_val, 2))
  
  // è´Ÿæ•°é™¤ä»¥è´Ÿæ•°
  assert_eq(1, divide_with_ceil(-1, -2))
  assert_eq(2, divide_with_ceil(-3, -2))
  
  // è¾¹ç•Œå€¼é™¤æ³•
  assert_eq(-1073741824, divide_with_ceil(min_val, 2))
  assert_eq(1073741824, divide_with_ceil(max_val, 2))
}

test "function_chaining_operations" {
  // å‡½æ•°é“¾å¼è°ƒç”¨æµ‹è¯•
  let initial = 5
  
  // å¤šå±‚å‡½æ•°è°ƒç”¨é“¾
  let result1 = multiply(add(initial, 3), 2)
  let result2 = add(multiply(initial, 2), 3)
  let result3 = divide_with_ceil(multiply(add(initial, 1), 3), 2)
  
  assert_eq(16, result1)  // (5 + 3) * 2 = 16
  assert_eq(13, result2)  // 5 * 2 + 3 = 13
  assert_eq(9, result3)   // ceil((5 + 1) * 3 / 2) = ceil(18 / 2) = 9
  
  // æ›´å¤æ‚çš„é“¾å¼è°ƒç”¨
  let complex_result = add(multiply(divide_with_ceil(10, 3), 2), 1)
  assert_eq(9, complex_result)  // ceil(10/3) * 2 + 1 = 4 * 2 + 1 = 9
}

test "numeric_range_validation" {
  // æ•°å€¼èŒƒå›´éªŒè¯æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // éªŒè¯åŠ æ³•èŒƒå›´é™åˆ¶
  assert_true(add(max_val, 0) <= max_val)
  assert_true(add(min_val, 0) >= min_val)
  assert_true(add(1000000, 1000000) <= max_val)
  assert_true(add(-1000000, -1000000) >= min_val)
  
  // éªŒè¯ä¹˜æ³•èŒƒå›´é™åˆ¶
  assert_true(multiply(46340, 46340) <= max_val)
  assert_true(multiply(-46340, 46340) >= min_val)
  
  // æå€¼éªŒè¯
  let overflow_add = add(max_val, max_val)
  let overflow_mul = multiply(max_val, 2)
  assert_true(overflow_add == max_val || overflow_add == min_val)
  assert_true(overflow_mul == max_val || overflow_mul == min_val)
}

test "string_length_boundaries" {
  // å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œæµ‹è¯•
  let empty = ""
  let single = "a"
  let long = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
  let _very_long = long + long + long + long + long  // ä½¿ç”¨ä¸‹åˆ’çº¿å‰ç¼€è¡¨ç¤ºæœªä½¿ç”¨
  
  // ä¸åŒé•¿åº¦å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, !", greet(empty))
  assert_eq_string("Hello, a!", greet(single))
  assert_eq_string("Hello, " + long + "!", greet(long))
  
  // ç‰¹æ®Šé•¿åº¦å­—ç¬¦ä¸²
  let spaces = "     "  // 5ä¸ªç©ºæ ¼
  let tabs = "\t\t\t\t\t"  // 5ä¸ªåˆ¶è¡¨ç¬¦
  assert_eq_string("Hello,     !", greet(spaces))
  assert_eq_string("Hello, \t\t\t\t\t!", greet(tabs))
}

test "mixed_operation_precision" {
  // æ··åˆè¿ç®—ç²¾åº¦æµ‹è¯•
  // æµ‹è¯•ä¸åŒæ•°å€¼ç»„åˆçš„ç²¾åº¦ä¿æŒ
  assert_eq(6, add(multiply(2, 3), 0))
  assert_eq(8, add(multiply(2, 3), 2))
  assert_eq(7, divide_with_ceil(multiply(2, 3), 1))
  assert_eq(4, divide_with_ceil(multiply(2, 3), 2))
  
  // æµ‹è¯•è¿ç®—é¡ºåºå¯¹ç»“æœçš„å½±å“
  let val1 = add(multiply(10, 2), divide_with_ceil(5, 2))
  let val2 = multiply(10, add(2, divide_with_ceil(5, 20)))
  assert_eq(24, val1)  // 20 + ceil(5/2) = 20 + 3 = 23
  assert_eq(21, val2)  // 10 * (2 + ceil(5/20)) = 10 * (2 + 1) = 30
  
  // æµ‹è¯•ç²¾åº¦ä¿æŒ
  assert_eq(0, add(multiply(1000, 0), divide_with_ceil(0, 1000)))
}

test "error_recovery_mechanisms" {
  // é”™è¯¯æ¢å¤æœºåˆ¶æµ‹è¯•
  let max_val = 2147483647
  let _min_val = -2147483648  // ä½¿ç”¨ä¸‹åˆ’çº¿å‰ç¼€è¡¨ç¤ºæœªä½¿ç”¨
  
  // æµ‹è¯•æº¢å‡ºåçš„å‡½æ•°ä»ç„¶å¯ç”¨
  let _ = add(max_val, 1)  // è¿™ä¼šæº¢å‡º
  let normal_add = add(5, 3)  // éªŒè¯æ­£å¸¸åŠ æ³•ä»ç„¶å·¥ä½œ
  assert_eq(8, normal_add)
  
  let _ = multiply(max_val, 2)  // è¿™ä¼šæº¢å‡º
  let normal_mul = multiply(5, 3)  // éªŒè¯æ­£å¸¸ä¹˜æ³•ä»ç„¶å·¥ä½œ
  assert_eq(15, normal_mul)
  
  // æµ‹è¯•æ–­è¨€å¤±è´¥ä¸å½±å“åç»­æµ‹è¯•
  // æ³¨æ„ï¼šå®é™…çš„æ–­è¨€å¤±è´¥ä¼šç»ˆæ­¢ç¨‹åºï¼Œè¿™é‡Œä¸»è¦æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«çš„é€»è¾‘
  assert_true(true)  // è¿™ä¸ªåº”è¯¥é€šè¿‡
  assert_false(false)  // è¿™ä¸ªåº”è¯¥é€šè¿‡
  assert_eq(1, 1)  // è¿™ä¸ªåº”è¯¥é€šè¿‡
  assert_eq_string("test", "test")  // è¿™ä¸ªåº”è¯¥é€šè¿‡
}

test "memory_safety_operations" {
  // å†…å­˜å®‰å…¨ç›¸å…³æ“ä½œæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•å¤§é‡æ“ä½œä¸ä¼šå¯¼è‡´å†…å­˜é—®é¢˜
  for i = 0; i < 100; i = i + 1 {
    let _ = add(i, i)
    let _ = multiply(i, 2)
    let _ = divide_with_ceil(i * 10 + 5, 3)
  }
  
  // æµ‹è¯•æå€¼æ“ä½œçš„ç¨³å®šæ€§
  let result1 = add(max_val, 0)
  let result2 = add(min_val, 0)
  let result3 = multiply(max_val, 1)
  let result4 = multiply(min_val, 1)
  let result5 = multiply(0, max_val)
  let result6 = multiply(0, min_val)
  
  assert_eq(max_val, result1)
  assert_eq(min_val, result2)
  assert_eq(max_val, result3)
  assert_eq(min_val, result4)
  assert_eq(0, result5)
  assert_eq(0, result6)
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ“ä½œçš„å†…å­˜å®‰å…¨æ€§
  let _ = greet("")
  let _ = greet("a")
  let _ = greet("test")
  let _ = greet("very long string with many characters")
  
  // éªŒè¯æœ€ç»ˆçŠ¶æ€
  assert_eq(198, add(99, 99))
  assert_eq(10000, multiply(100, 100))
}

// æ–°å¢çš„æ ‡å‡†å¢å¼ºæµ‹è¯•ç”¨ä¾‹
test "add_overflow_protection_positive" {
  // æµ‹è¯•æ­£æ•°åŠ æ³•çš„æº¢å‡ºä¿æŠ¤
  let max_val = 2147483647
  
  // æ¥è¿‘æœ€å¤§å€¼çš„åŠ æ³•
  assert_eq(max_val, add(max_val - 1, 1))
  assert_eq(max_val, add(max_val - 100, 100))
  assert_eq(max_val, add(max_val - 1000, 1000))
  
  // ç¡®ä¿æ­£å¸¸èŒƒå›´å†…çš„åŠ æ³•æ­£ç¡®
  assert_eq(100, add(50, 50))
  assert_eq(0, add(100, -100))
}

test "add_overflow_protection_negative" {
  // æµ‹è¯•è´Ÿæ•°åŠ æ³•çš„æº¢å‡ºä¿æŠ¤
  let min_val = -2147483648
  
  // æ¥è¿‘æœ€å°å€¼çš„åŠ æ³•
  assert_eq(min_val, add(min_val + 1, -1))
  assert_eq(min_val, add(min_val + 100, -100))
  assert_eq(min_val, add(min_val + 1000, -1000))
  
  // ç¡®ä¿æ­£å¸¸èŒƒå›´å†…çš„åŠ æ³•æ­£ç¡®
  assert_eq(-100, add(-50, -50))
  assert_eq(0, add(-100, 100))
}

test "multiply_precision_boundary" {
  // æµ‹è¯•ä¹˜æ³•ç²¾åº¦è¾¹ç•Œ
  let sqrt_max = 46340  // sqrt(2147483647) çš„æ•´æ•°éƒ¨åˆ†
  
  // è¾¹ç•Œå€¼ä¹˜æ³•
  assert_eq(2147395600, multiply(sqrt_max, sqrt_max))
  assert_eq(2147483647, multiply(sqrt_max, sqrt_max + 1))
  
  // è´Ÿæ•°ä¹˜æ³•
  assert_eq(-2147395600, multiply(sqrt_max, -sqrt_max))
  assert_eq(-2147483647, multiply(sqrt_max, -(sqrt_max + 1)))
}

test "multiply_zero_and_one_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„é›¶å’Œä¸€ç‰¹æ®Šæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // é›¶ä¹˜æ³•
  assert_eq(0, multiply(0, max_val))
  assert_eq(0, multiply(0, min_val))
  assert_eq(0, multiply(0, 0))
  
  // ä¸€ä¹˜æ³•
  assert_eq(max_val, multiply(1, max_val))
  assert_eq(min_val, multiply(1, min_val))
  assert_eq(5, multiply(1, 5))
  
  // è´Ÿä¸€ä¹˜æ³•
  assert_eq(-max_val, multiply(-1, max_val))
  assert_eq(min_val, multiply(-1, min_val))  // ç‰¹æ®Šæƒ…å†µï¼šæœ€å°å€¼ä¹˜ä»¥-1
}

test "greet_function_special_characters" {
  // æµ‹è¯• greet å‡½æ•°çš„ç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_eq_string("Hello, \\n!", greet("\\n"))
  assert_eq_string("Hello, \\t!", greet("\\t"))
  assert_eq_string("Hello, \\\\!", greet("\\"))
  assert_eq_string("Hello, \\\"!", greet("\""))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
}

test "divide_with_ceil_negative_numbers" {
  // æµ‹è¯•è´Ÿæ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  // è´Ÿæ•°é™¤ä»¥æ­£æ•°
  assert_eq(-1, divide_with_ceil(-1, 3))
  assert_eq(-2, divide_with_ceil(-4, 3))
  assert_eq(-2, divide_with_ceil(-5, 3))
  assert_eq(-3, divide_with_ceil(-7, 3))
  
  // è´Ÿæ•°é™¤ä»¥è´Ÿæ•°
  assert_eq(1, divide_with_ceil(-1, -3))
  assert_eq(2, divide_with_ceil(-4, -3))
  assert_eq(2, divide_with_ceil(-5, -3))
  assert_eq(3, divide_with_ceil(-7, -3))
}

test "divide_with_ceil_exact_division" {
  // æµ‹è¯•èƒ½å¤Ÿæ•´é™¤çš„æƒ…å†µ
  assert_eq(5, divide_with_ceil(10, 2))
  assert_eq(-5, divide_with_ceil(-10, 2))
  assert_eq(5, divide_with_ceil(10, -2))
  assert_eq(-5, divide_with_ceil(-10, -2))
  
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  assert_eq(1, divide_with_ceil(5, 5))
  assert_eq(-1, divide_with_ceil(-5, 5))
}

test "complex_mathematical_expressions" {
  // æµ‹è¯•å¤æ‚çš„æ•°å­¦è¡¨è¾¾å¼
  // åµŒå¥—è¿ç®—
  assert_eq(25, add(multiply(3, 5), multiply(2, 5)))
  assert_eq(20, multiply(add(3, 2), 4))
  assert_eq(8, divide_with_ceil(add(multiply(2, 3), 2), 2))
  
  // å¤šå±‚åµŒå¥—
  assert_eq(15, add(multiply(divide_with_ceil(10, 2), 2), 5))
  assert_eq(12, multiply(add(divide_with_ceil(7, 3), 2), 3))
}

test "assertion_functions_edge_cases" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  // æå€¼æ¯”è¾ƒ
  assert_true(2147483647 == 2147483647)
  assert_true(-2147483648 == -2147483648)
  assert_false(2147483647 == -2147483648)
  
  // å­—ç¬¦ä¸²è¾¹ç•Œæƒ…å†µ
  assert_eq_string("", "")
  assert_eq_string("a", "a")
  assert_eq_string("Hello, World!", "Hello, World!")
  
  // å¸ƒå°”å€¼è¾¹ç•Œ
  assert_true(true)
  assert_false(false)
}

// ç”¨æˆ·è¯·æ±‚çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_basic_functionality" {
  // åŸºæœ¬åŠ æ³•åŠŸèƒ½æµ‹è¯•
  assert_eq(0, add(0, 0))
  assert_eq(5, add(2, 3))
  assert_eq(-1, add(-2, 1))
  assert_eq(-5, add(-2, -3))
}

test "add_boundary_values" {
  // è¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, add(max_val, 0))
  assert_eq(min_val, add(min_val, 0))
  assert_eq(max_val, add(0, max_val))
  assert_eq(min_val, add(0, min_val))
}

test "multiply_basic_cases" {
  // åŸºæœ¬ä¹˜æ³•æµ‹è¯•
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(5, 0))
  assert_eq(6, multiply(2, 3))
  assert_eq(-6, multiply(2, -3))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(-1, 1))
}

test "multiply_special_values" {
  // ç‰¹æ®Šå€¼ä¹˜æ³•æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  assert_eq(max_val, multiply(1, max_val))
  assert_eq(min_val, multiply(1, min_val))
  assert_eq(5, multiply(1, 5))
  assert_eq(-5, multiply(-1, 5))
  assert_eq(min_val, multiply(-1, min_val))  // ç‰¹æ®Šæƒ…å†µï¼šæœ€å°å€¼ä¹˜ä»¥-1
}

test "greet_function_test" {
  // greet å‡½æ•°æµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, å¼ ä¸‰!", greet("å¼ ä¸‰"))
  assert_eq_string("Hello, 123!", greet("123"))
}

test "divide_with_ceil_basic" {
  // å‘ä¸Šå–æ•´é™¤æ³•åŸºæœ¬æµ‹è¯•
  assert_eq(4, divide_with_ceil(11, 3))
  assert_eq(4, divide_with_ceil(12, 3))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(-3, divide_with_ceil(-8, 3))
  assert_eq(-2, divide_with_ceil(-6, 3))
}

test "divide_with_ceil_negative_divisor" {
  // è´Ÿé™¤æ•°çš„å‘ä¸Šå–æ•´é™¤æ³•
  assert_eq(-3, divide_with_ceil(8, -3))
  assert_eq(-4, divide_with_ceil(11, -3))
  assert_eq(2, divide_with_ceil(-6, -3))
  assert_eq(3, divide_with_ceil(-8, -3))
}

test "combined_operations" {
  // ç»„åˆè¿ç®—æµ‹è¯•
  assert_eq(25, add(multiply(3, 5), multiply(2, 5)))
  assert_eq(20, multiply(add(3, 2), 4))
  assert_eq(8, divide_with_ceil(add(multiply(2, 3), 2), 2))
  assert_eq(15, add(multiply(divide_with_ceil(10, 2), 2), 5))
}

test "assert_functions_test" {
  // æ–­è¨€å‡½æ•°æµ‹è¯•
  assert_true(true)
  assert_false(false)
  assert_eq(42, 42)
  assert_eq(-42, -42)
  assert_eq_string("test", "test")
  assert_eq_string("", "")
}

// æ–°å¢çš„æ ‡å‡†å¢å¼ºæµ‹è¯•ç”¨ä¾‹
test "enhanced_boundary_value_tests" {
  // å¢å¼ºè¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼å’Œæœ€å°å€¼çš„è¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(min_val, add(min_val, 0))
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(min_val, 0))
  
  // æµ‹è¯•æ¥è¿‘è¾¹ç•Œçš„è¿ç®—
  assert_eq(2147483647, add(2147483647 - 1000, 1000))
  assert_eq(-2147483648, add(-2147483648 + 1000, -1000))
}

test "enhanced_string_processing_tests" {
  // å¢å¼ºå­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
  assert_eq_string("Hello, \\\"!", greet("\""))
}

test "enhanced_division_precision_tests" {
  // å¢å¼ºé™¤æ³•ç²¾åº¦æµ‹è¯•
  // æ­£æ•°é™¤æ³•
  assert_eq(4, divide_with_ceil(11, 3))
  assert_eq(2, divide_with_ceil(5, 3))
  assert_eq(1, divide_with_ceil(1, 3))
  
  // è´Ÿæ•°é™¤æ³•
  assert_eq(-3, divide_with_ceil(-8, 3))
  assert_eq(-2, divide_with_ceil(-6, 3))
  assert_eq(-1, divide_with_ceil(-2, 3))
  
  // é›¶ç›¸å…³
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
}

test "enhanced_complex_operations_tests" {
  // å¢å¼ºå¤æ‚è¿ç®—æµ‹è¯•
  // åµŒå¥—è¿ç®—
  assert_eq(25, add(multiply(3, 5), multiply(2, 5)))
  assert_eq(20, multiply(add(3, 2), 4))
  assert_eq(8, divide_with_ceil(add(multiply(2, 3), 2), 2))
  
  // å¤šå±‚åµŒå¥—
  assert_eq(15, add(multiply(divide_with_ceil(10, 2), 2), 5))
  assert_eq(12, multiply(add(divide_with_ceil(7, 3), 2), 3))
  
  // å¤æ‚è¡¨è¾¾å¼
  assert_eq(16, add(multiply(2, 5), divide_with_ceil(10, 3)))
}

test "enhanced_real_world_scenarios" {
  // å¢å¼ºå®é™…åº”ç”¨åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·ï¼ˆå«ç¨å‘ä¸Šå–æ•´ï¼‰
  let item1_price = 99
  let item2_price = 149
  let tax_rate = 3  // 1/3 çš„ç¨ç‡
  let subtotal = add(item1_price, item2_price)
  let total_with_tax = multiply(subtotal, tax_rate)
  assert_eq(744, total_with_tax)
  
  // åœºæ™¯2ï¼šå¹³å‡åˆ†è®¡ç®—ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let score1 = 85
  let score2 = 92
  let score3 = 78
  let total_score = add(add(score1, score2), score3)
  let average_score = divide_with_ceil(total_score, 3)
  assert_eq(86, average_score)
  
  // åœºæ™¯3ï¼šç”¨æˆ·æ¬¢è¿æ¶ˆæ¯
  let username = "å¼ ä¸‰"
  let welcome_msg = greet(username)
  assert_eq_string("Hello, å¼ ä¸‰!", welcome_msg)
}

test "enhanced_error_handling_tests" {
  // å¢å¼ºé”™è¯¯å¤„ç†æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æº¢å‡ºæƒ…å†µæµ‹è¯•
  let overflow_add = add(max_val, max_val)
  let overflow_mul = multiply(max_val, 2)
  assert_true(overflow_add == max_val || overflow_add == min_val)
  assert_true(overflow_mul == max_val || overflow_mul == min_val)
  
  // ç‰¹æ®Šå€¼æµ‹è¯•
  assert_eq(min_val, multiply(-1, min_val))  // ç‰¹æ®Šæƒ…å†µï¼šæœ€å°å€¼ä¹˜ä»¥-1
  assert_eq(0, multiply(0, max_val))
  assert_eq(0, multiply(0, min_val))
}

// æ–°å¢çš„æ ‡å‡†å¢å¼ºæµ‹è¯•ç”¨ä¾‹
test "add_function_performance_critical_cases" {
  // æ€§èƒ½å…³é”®æƒ…å†µä¸‹çš„åŠ æ³•æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è¿ç»­æ“ä½œæµ‹è¯•
  let result1 = add(add(1000000, 1000000), add(1000000, 1000000))
  let result2 = add(add(-1000000, 1000000), add(-1000000, 1000000))
  assert_eq(4000000, result1)
  assert_eq(0, result2)
  
  // è¾¹ç•Œå€¼è¿ç»­æ“ä½œ
  let result3 = add(add(max_val - 1000, 500), add(500, 0))
  let result4 = add(add(min_val + 1000, -500), add(-500, 0))
  assert_eq(max_val, result3)
  assert_eq(min_val, result4)
}

test "multiply_function_large_numbers" {
  // å¤§æ•°ä¹˜æ³•æµ‹è¯•
  let sqrt_max = 46340
  
  // æ¥è¿‘æœ€å¤§å€¼çš„ä¹˜æ³•
  assert_eq(2147395600, multiply(sqrt_max, sqrt_max))
  assert_eq(2147483647, multiply(sqrt_max, sqrt_max + 1))
  assert_eq(-2147395600, multiply(sqrt_max, -sqrt_max))
  
  // ä¸­ç­‰æ•°å€¼çš„ä¹˜æ³•
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(-1000000, multiply(1000, -1000))
  assert_eq(99980001, multiply(9999, 9999))
}

test "greet_function_multilingual_support" {
  // å¤šè¯­è¨€æ”¯æŒæµ‹è¯•
  assert_eq_string("Hello, English!", greet("English"))
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, Ñ€ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ñ€ÑƒÑÑĞºĞ¸Ğ¹"))
  assert_eq_string("Hello, espaÃ±ol!", greet("espaÃ±ol"))
  assert_eq_string("Hello, franÃ§ais!", greet("franÃ§ais"))
}

test "divide_with_ceil_fractional_precision" {
  // åˆ†æ•°ç²¾åº¦æµ‹è¯•
  // å°ä½™æ•°æƒ…å†µ
  assert_eq(2, divide_with_ceil(4, 3))
  assert_eq(2, divide_with_ceil(5, 3))
  assert_eq(2, divide_with_ceil(6, 3))
  assert_eq(3, divide_with_ceil(7, 3))
  
  // å¤§ä½™æ•°æƒ…å†µ
  assert_eq(11, divide_with_ceil(100, 9))
  assert_eq(34, divide_with_ceil(100, 3))
  assert_eq(51, divide_with_ceil(100, 2))
  
  // è´Ÿæ•°åˆ†æ•°ç²¾åº¦
  assert_eq(-1, divide_with_ceil(-2, 3))
  assert_eq(-2, divide_with_ceil(-5, 3))
  assert_eq(-4, divide_with_ceil(-11, 3))
}

test "complex_business_logic_simulation" {
  // å¤æ‚ä¸šåŠ¡é€»è¾‘æ¨¡æ‹Ÿ
  // åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»ä»·ï¼ˆå«ç¨å’ŒæŠ˜æ‰£ï¼‰
  let base_price = 1000
  let quantity = 5
  let discount_rate = 2  // 50% æŠ˜æ‰£ (1/2)
  let tax_rate = 3       // 33% ç¨ç‡ (1/3)
  
  // è®¡ç®—åŸä»·
  let original_total = multiply(base_price, quantity)
  assert_eq(5000, original_total)
  
  // åº”ç”¨æŠ˜æ‰£
  let discounted_price = divide_with_ceil(original_total, discount_rate)
  assert_eq(2500, discounted_price)
  
  // è®¡ç®—ç¨è´¹
  let tax_amount = divide_with_ceil(discounted_price, tax_rate)
  assert_eq(834, tax_amount)
  
  // æœ€ç»ˆæ€»ä»·
  let final_total = add(discounted_price, tax_amount)
  assert_eq(3334, final_total)
}

test "mathematical_sequence_operations" {
  // æ•°å­¦åºåˆ—æ“ä½œ
  // ç­‰å·®æ•°åˆ—æ±‚å’Œ
  let first_term = 1
  let common_diff = 2
  let num_terms = 10
  
  // è®¡ç®—ç­‰å·®æ•°åˆ—å’Œï¼šn/2 * (2a + (n-1)d)
  let double_first = multiply(first_term, 2)
  let diff_product = multiply(common_diff, num_terms - 1)
  let sum_inside = add(double_first, diff_product)
  let arithmetic_sum = divide_with_ceil(multiply(num_terms, sum_inside), 2)
  assert_eq(100, arithmetic_sum)
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼ˆç®€åŒ–ç‰ˆï¼‰
  let ratio = 2
  let geo_sum = multiply(first_term, multiply(ratio, num_terms))
  assert_eq(20, geo_sum)
}

test "error_boundary_and_recovery" {
  // é”™è¯¯è¾¹ç•Œå’Œæ¢å¤æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // è§¦å‘æº¢å‡ºåéªŒè¯å‡½æ•°ä»ç„¶å¯ç”¨
  let overflow_result1 = add(max_val, 1)  // åº”è¯¥è¿”å› max_val
  let overflow_result2 = multiply(max_val, 2)  // åº”è¯¥è¿”å› max_val
  let overflow_result3 = multiply(-1, min_val)  // åº”è¯¥è¿”å› min_val
  
  // éªŒè¯æ­£å¸¸æ“ä½œä»ç„¶å·¥ä½œ
  let normal_add = add(100, 200)
  let normal_mul = multiply(10, 20)
  let normal_greet = greet("Test")
  
  assert_eq(max_val, overflow_result1)
  assert_eq(max_val, overflow_result2)
  assert_eq(min_val, overflow_result3)
  assert_eq(300, normal_add)
  assert_eq(200, normal_mul)
  assert_eq_string("Hello, Test!", normal_greet)
}

test "string_processing_edge_cases" {
  // å­—ç¬¦ä¸²å¤„ç†è¾¹ç•Œæƒ…å†µ
  // ç‰¹æ®Šå­—ç¬¦ç»„åˆ
  assert_eq_string("Hello, \\n\\t\\r!", greet("\\n\\t\\r"))
  assert_eq_string("Hello, \\0\\1\\2!", greet("\\0\\1\\2"))
  assert_eq_string("Hello, \u{1F600}\u{1F601}\u{1F602}!", greet("\u{1F600}\u{1F601}\u{1F602}"))
  
  // æé•¿å­—ç¬¦ä¸²ï¼ˆç›¸å¯¹ï¼‰
  let long_name = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
  assert_eq_string("Hello, " + long_name + "!", greet(long_name))
  
  // æ··åˆå­—ç¬¦ç±»å‹
  assert_eq_string("Hello, a1b2c3!", greet("a1b2c3"))
  assert_eq_string("Hello, Test_123!", greet("Test_123"))
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹è¡¥å……
// ä¸“æ³¨äºæ•°å€¼è¿ç®—ã€è¾¹ç•Œæ¡ä»¶å’Œå®é™…åº”ç”¨åœºæ™¯

test "add_function_identity_properties" {
  // æµ‹è¯•åŠ æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(5, add(5, 0))
  assert_eq(5, add(0, 5))
  assert_eq(-5, add(-5, 0))
  assert_eq(-5, add(0, -5))
  assert_eq(0, add(0, 0))
  
  // æµ‹è¯•åŠ æ³•çš„é€†å…ƒæ€§è´¨
  assert_eq(0, add(5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(0, add(100, -100))
  assert_eq(0, add(-100, 100))
}

test "multiply_function_identity_properties" {
  // æµ‹è¯•ä¹˜æ³•çš„å•ä½å…ƒæ€§è´¨
  assert_eq(5, multiply(5, 1))
  assert_eq(5, multiply(1, 5))
  assert_eq(-5, multiply(-5, 1))
  assert_eq(-5, multiply(1, -5))
  assert_eq(1, multiply(1, 1))
  
  // æµ‹è¯•ä¹˜æ³•çš„é›¶å…ƒæ€§è´¨
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(0, 0))
}

test "power_operations_simulation" {
  // é€šè¿‡é‡å¤ä¹˜æ³•æ¨¡æ‹Ÿå¹‚è¿ç®—
  let base = 3
  
  // 3^2 = 9
  assert_eq(9, multiply(base, base))
  
  // 3^3 = 27
  assert_eq(27, multiply(multiply(base, base), base))
  
  // 3^4 = 81
  assert_eq(81, multiply(multiply(multiply(base, base), base), base))
  
  // æµ‹è¯•è´Ÿæ•°çš„å¹‚
  let neg_base = -2
  
  // (-2)^2 = 4
  assert_eq(4, multiply(neg_base, neg_base))
  
  // (-2)^3 = -8
  assert_eq(-8, multiply(multiply(neg_base, neg_base), neg_base))
}

test "factorial_simulation" {
  // é€šè¿‡é‡å¤ä¹˜æ³•æ¨¡æ‹Ÿé˜¶ä¹˜è¿ç®—
  // 5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
  let factorial_5 = multiply(5, multiply(4, multiply(3, multiply(2, 1))))
  assert_eq(120, factorial_5)
  
  // 4! = 4 Ã— 3 Ã— 2 Ã— 1 = 24
  let factorial_4 = multiply(4, multiply(3, multiply(2, 1)))
  assert_eq(24, factorial_4)
  
  // 3! = 3 Ã— 2 Ã— 1 = 6
  let factorial_3 = multiply(3, multiply(2, 1))
  assert_eq(6, factorial_3)
  
  // 2! = 2 Ã— 1 = 2
  let factorial_2 = multiply(2, 1)
  assert_eq(2, factorial_2)
  
  // 1! = 1
  assert_eq(1, multiply(1))
}

test "greet_function_name_formatting" {
  // æµ‹è¯•ä¸åŒæ ¼å¼çš„åç§°å¤„ç†
  assert_eq_string("Hello, John Doe!", greet("John Doe"))
  assert_eq_string("Hello, john-doe!", greet("john-doe"))
  assert_eq_string("Hello, john_doe!", greet("john_doe"))
  assert_eq_string("Hello, Mr. Smith!", greet("Mr. Smith"))
  assert_eq_string("Hello, Dr. Jane!", greet("Dr. Jane"))
  assert_eq_string("Hello, Jr. Johnson!", greet("Jr. Johnson"))
}

test "divide_with_ceil_rounding_behavior" {
  // æµ‹è¯•å‘ä¸Šå–æ•´çš„èˆå…¥è¡Œä¸º
  // æ­£æ•°èˆå…¥
  assert_eq(1, divide_with_ceil(1, 1))    // 1/1 = 1
  assert_eq(2, divide_with_ceil(2, 1))    // 2/1 = 2
  assert_eq(2, divide_with_ceil(3, 2))    // 3/2 = 1.5 â†’ 2
  assert_eq(3, divide_with_ceil(5, 2))    // 5/2 = 2.5 â†’ 3
  assert_eq(4, divide_with_ceil(7, 2))    // 7/2 = 3.5 â†’ 4
  
  // è´Ÿæ•°èˆå…¥ï¼ˆå‘é›¶æ–¹å‘ï¼‰
  assert_eq(-1, divide_with_ceil(-1, 2))   // -1/2 = -0.5 â†’ -1
  assert_eq(-2, divide_with_ceil(-3, 2))   // -3/2 = -1.5 â†’ -2
  assert_eq(-3, divide_with_ceil(-5, 2))   // -5/2 = -2.5 â†’ -3
}

test "arithmetic_progression_calculations" {
  // ç­‰å·®æ•°åˆ—è®¡ç®—æµ‹è¯•
  // è®¡ç®—å‰né¡¹å’Œï¼šS = n/2 * (a1 + an)
  let n = 10
  let a1 = 1
  let an = 10
  
  // è®¡ç®—é¦–é¡¹ä¸æœ«é¡¹çš„å’Œ
  let first_plus_last = add(a1, an)
  assert_eq(11, first_plus_last)
  
  // è®¡ç®—é¡¹æ•°ä¸å’Œçš„ä¹˜ç§¯
  let n_times_sum = multiply(n, first_plus_last)
  assert_eq(110, n_times_sum)
  
  // è®¡ç®—æœ€ç»ˆçš„å’Œï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´é™¤æ³•æ¨¡æ‹Ÿé™¤ä»¥2ï¼‰
  let arithmetic_sum = divide_with_ceil(n_times_sum, 2)
  assert_eq(55, arithmetic_sum)
  
  // éªŒè¯ï¼š1+2+3+4+5+6+7+8+9+10 = 55
}

test "geometric_progression_calculations" {
  // ç­‰æ¯”æ•°åˆ—è®¡ç®—æµ‹è¯•
  // è®¡ç®—å‰å‡ é¡¹ï¼ša, ar, ar^2, ar^3, ...
  let a = 2
  let r = 3
  
  // è®¡ç®—å‰å‡ é¡¹
  let term1 = a                           // 2
  let term2 = multiply(a, r)              // 2 Ã— 3 = 6
  let term3 = multiply(term2, r)          // 6 Ã— 3 = 18
  let term4 = multiply(term3, r)          // 18 Ã— 3 = 54
  let term5 = multiply(term4, r)          // 54 Ã— 3 = 162
  
  assert_eq(2, term1)
  assert_eq(6, term2)
  assert_eq(18, term3)
  assert_eq(54, term4)
  assert_eq(162, term5)
  
  // è®¡ç®—å‰å‡ é¡¹çš„å’Œ
  let sum_5_terms = add(add(add(add(term1, term2), term3), term4), term5)
  assert_eq(242, sum_5_terms)  // 2+6+18+54+162 = 242
}

test "practical_calculator_scenarios" {
  // å®é™…è®¡ç®—å™¨åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè®¡ç®—è´­ç‰©è½¦æ€»ä»·
  let item1 = 199
  let item2 = 299
  let item3 = 99
  let subtotal = add(add(item1, item2), item3)
  assert_eq(597, subtotal)
  
  // åœºæ™¯2ï¼šè®¡ç®—æŠ˜æ‰£ä»·æ ¼ï¼ˆ8æŠ˜ï¼‰
  let discount_rate = 5  // 1/5 = 20% = 80%ä»·æ ¼
  let discounted_price = divide_with_ceil(multiply(subtotal, 4), 5)
  assert_eq(478, discounted_price)
  
  // åœºæ™¯3ï¼šè®¡ç®—ç¨è´¹ï¼ˆå‘ä¸Šå–æ•´ï¼‰
  let tax_rate = 10  // 10%ç¨ç‡
  let tax_amount = divide_with_ceil(discounted_price, tax_rate)
  assert_eq(48, tax_amount)
  
  // åœºæ™¯4ï¼šæœ€ç»ˆæ€»ä»·
  let final_total = add(discounted_price, tax_amount)
  assert_eq(526, final_total)
}

test "number_system_conversions" {
  // æ•°åˆ¶è½¬æ¢ç›¸å…³çš„è®¡ç®—
  // åœºæ™¯1ï¼šäºŒè¿›åˆ¶è½¬åè¿›åˆ¶çš„è®¡ç®—
  // äºŒè¿›åˆ¶ 1011 = 1Ã—2Â³ + 0Ã—2Â² + 1Ã—2Â¹ + 1Ã—2â° = 8 + 0 + 2 + 1 = 11
  let binary_1011 = add(add(multiply(1, multiply(2, multiply(2, 2))), 
                            multiply(0, multiply(2, 2))), 
                       add(multiply(1, 2), 1))
  assert_eq(11, binary_1011)
  
  // åœºæ™¯2ï¼šå…«è¿›åˆ¶è½¬åè¿›åˆ¶çš„è®¡ç®—
  // å…«è¿›åˆ¶ 123 = 1Ã—8Â² + 2Ã—8Â¹ + 3Ã—8â° = 64 + 16 + 3 = 83
  let octal_123 = add(add(multiply(1, multiply(8, 8)), 
                         multiply(2, 8)), 3)
  assert_eq(83, octal_123)
  
  // åœºæ™¯3ï¼šåå…­è¿›åˆ¶è½¬åè¿›åˆ¶çš„è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // åå…­è¿›åˆ¶ 1A = 1Ã—16Â¹ + 10Ã—16â° = 16 + 10 = 26
  let hex_1A = add(multiply(1, 16), 10)
  assert_eq(26, hex_1A)
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯
  // æµ‹è¯•å¤šä¸ªè¿ç»­æ“ä½œçš„æ€§èƒ½
  let base = 100
  
  // è¿ç»­åŠ æ³•
  let sum_result = add(add(add(add(base, 50), 25), 10), 5)
  assert_eq(190, sum_result)
  
  // è¿ç»­ä¹˜æ³•
  let product_result = multiply(multiply(multiply(base, 2), 3), 4)
  assert_eq(2400, product_result)
  
  // æ··åˆæ“ä½œ
  let mixed_result = add(multiply(base, 2), divide_with_ceil(multiply(50, 3), 4))
  assert_eq(238, mixed_result)
  
  // åµŒå¥—æ“ä½œ
  let nested_result = multiply(add(divide_with_ceil(100, 3), 5), 2)
  assert_eq(78, nested_result)
}

test "data_type_consistency" {
  // æ•°æ®ç±»å‹ä¸€è‡´æ€§æµ‹è¯•
  // ç¡®ä¿æ‰€æœ‰å‡½æ•°è¿”å›æ­£ç¡®çš„ç±»å‹
  
  // Int ç±»å‹å‡½æ•°
  let int_result1 = add(5, 3)
  let int_result2 = multiply(5, 3)
  let int_result3 = divide_with_ceil(10, 3)
  
  // String ç±»å‹å‡½æ•°
  let string_result = greet("MoonBit")
  
  // Unit ç±»å‹å‡½æ•°ï¼ˆæ–­è¨€ï¼‰
  assert_true(int_result1 == 8)
  assert_true(int_result2 == 15)
  assert_true(int_result3 == 4)
  assert_true(string_result == "Hello, MoonBit!")
  
  // ç±»å‹ä¸€è‡´æ€§éªŒè¯
  assert_eq(8, int_result1)
  assert_eq(15, int_result2)
  assert_eq(4, int_result3)
  assert_eq_string("Hello, MoonBit!", string_result)
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹è¡¥å……
// ä¸“æ³¨äºæ ¸å¿ƒåŠŸèƒ½çš„ä¸åŒæµ‹è¯•åœºæ™¯

test "add_function_commutative_property" {
  // æµ‹è¯•åŠ æ³•äº¤æ¢å¾‹: a + b = b + a
  // åŸºæœ¬æƒ…å†µ
  assert_eq(add(1, 2), add(2, 1))
  assert_eq(add(-1, 1), add(1, -1))
  assert_eq(add(100, 200), add(200, 100))
  assert_eq(add(-50, -25), add(-25, -50))
  
  // è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(add(max_val, 0), add(0, max_val))
  assert_eq(add(min_val, 0), add(0, min_val))
  
  // é›¶çš„æƒ…å†µ
  assert_eq(add(0, 0), add(0, 0))
}

test "multiply_function_commutative_property" {
  // æµ‹è¯•ä¹˜æ³•äº¤æ¢å¾‹: a Ã— b = b Ã— a
  // åŸºæœ¬æƒ…å†µ
  assert_eq(multiply(1, 2), multiply(2, 1))
  assert_eq(multiply(-1, 1), multiply(1, -1))
  assert_eq(multiply(10, 20), multiply(20, 10))
  assert_eq(multiply(-5, -3), multiply(-3, -5))
  
  // è¾¹ç•Œæƒ…å†µ
  let max_val = 2147483647
  let min_val = -2147483648
  assert_eq(multiply(max_val, 1), multiply(1, max_val))
  assert_eq(multiply(min_val, 1), multiply(1, min_val))
  
  // é›¶çš„æƒ…å†µ
  assert_eq(multiply(0, 1), multiply(1, 0))
}

test "add_function_associative_property" {
  // æµ‹è¯•åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  // åŸºæœ¬æƒ…å†µ
  let left1 = add(add(1, 2), 3)
  let right1 = add(1, add(2, 3))
  assert_eq(left1, right1)
  
  let left2 = add(add(-1, 2), 3)
  let right2 = add(-1, add(2, 3))
  assert_eq(left2, right2)
  
  let left3 = add(add(100, 200), 300)
  let right3 = add(100, add(200, 300))
  assert_eq(left3, right3)
  
  // è´Ÿæ•°æƒ…å†µ
  let left4 = add(add(-50, 25), 75)
  let right4 = add(-50, add(25, 75))
  assert_eq(left4, right4)
  
  // é›¶çš„æƒ…å†µ
  let left5 = add(add(0, 0), 0)
  let right5 = add(0, add(0, 0))
  assert_eq(left5, right5)
}

test "multiply_function_distributive_property" {
  // æµ‹è¯•ä¹˜æ³•åˆ†é…å¾‹: a Ã— (b + c) = a Ã— b + a Ã— c
  // åŸºæœ¬æƒ…å†µ
  let left1 = multiply(2, add(3, 4))
  let right1 = add(multiply(2, 3), multiply(2, 4))
  assert_eq(left1, right1)
  
  let left2 = multiply(3, add(5, 7))
  let right2 = add(multiply(3, 5), multiply(3, 7))
  assert_eq(left2, right2)
  
  let left3 = multiply(10, add(20, 30))
  let right3 = add(multiply(10, 20), multiply(10, 30))
  assert_eq(left3, right3)
  
  // åŒ…å«è´Ÿæ•°çš„æƒ…å†µ
  let left4 = multiply(5, add(-3, 2))
  let right4 = add(multiply(5, -3), multiply(5, 2))
  assert_eq(left4, right4)
  
  // é›¶çš„æƒ…å†µ
  let left5 = multiply(0, add(100, 200))
  let right5 = add(multiply(0, 100), multiply(0, 200))
  assert_eq(left5, right5)
}

test "divide_with_ceil_mathematical_properties" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„æ•°å­¦æ€§è´¨
  // æ­£æ•°æµ‹è¯•
  let ceil_result1 = divide_with_ceil(10, 3)
  assert_eq(4, ceil_result1)  // ceil(3.33) = 4
  
  let ceil_result2 = divide_with_ceil(11, 3)
  assert_eq(4, ceil_result2)  // ceil(3.67) = 4
  
  let ceil_result3 = divide_with_ceil(12, 3)
  assert_eq(4, ceil_result3)  // ceil(4.0) = 4
  
  // å°æ•°æµ‹è¯•
  let ceil_result4 = divide_with_ceil(1, 2)
  assert_eq(1, ceil_result4)  // ceil(0.5) = 1
  
  let ceil_result5 = divide_with_ceil(5, 2)
  assert_eq(3, ceil_result5)  // ceil(2.5) = 3
  
  // è´Ÿæ•°æµ‹è¯•
  let ceil_result6 = divide_with_ceil(-5, 2)
  assert_eq(-2, ceil_result6)  // ceil(-2.5) = -2
  
  let ceil_result7 = divide_with_ceil(-6, 2)
  assert_eq(-3, ceil_result7)  // ceil(-3.0) = -3
  
  let ceil_result8 = divide_with_ceil(-7, 2)
  assert_eq(-3, ceil_result8)  // ceil(-3.5) = -3
}

test "greet_function_empty_and_whitespace_handling" {
  // æµ‹è¯• greet å‡½æ•°å¯¹ç©ºå­—ç¬¦ä¸²å’Œç©ºç™½å­—ç¬¦çš„å¤„ç†
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,  !", greet(" "))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, \t!", greet("\t"))
  assert_eq_string("Hello, \n!", greet("\n"))
  assert_eq_string("Hello, \r!", greet("\r"))
}

test "mathematical_identities_validation" {
  // éªŒè¯æ•°å­¦æ’ç­‰å¼
  let test_value = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(test_value, add(test_value, 0))
  assert_eq(test_value, add(0, test_value))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(test_value, multiply(test_value, 1))
  assert_eq(test_value, multiply(1, test_value))
  
  // ä¹˜æ³•é›¶å…ƒ
  assert_eq(0, multiply(test_value, 0))
  assert_eq(0, multiply(0, test_value))
  
  // åŠ æ³•é€†å…ƒ
  assert_eq(0, add(test_value, -test_value))
}

test "edge_case_combinations" {
  // è¾¹ç•Œæƒ…å†µç»„åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æœ€å¤§å€¼ä¸æœ€å°å€¼çš„è¿ç®—
  assert_eq(max_val + min_val, add(max_val, min_val))
  
  // æœ€å¤§å€¼ä¸0çš„è¿ç®—
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(0, multiply(max_val, 0))
  
  // æœ€å°å€¼ä¸0çš„è¿ç®—
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(0, multiply(min_val, 0))
}

test "complex_expression_evaluation" {
  // å¤æ‚è¡¨è¾¾å¼æ±‚å€¼æµ‹è¯•
  let a = 10
  let b = 5
  let c = 3
  
  // è¡¨è¾¾å¼1: (a + b) Ã— c
  let expr1 = multiply(add(a, b), c)
  assert_eq(45, expr1)
  
  // è¡¨è¾¾å¼2: a Ã— (b + c)
  let expr2 = multiply(a, add(b, c))
  assert_eq(80, expr2)
  
  // è¡¨è¾¾å¼3: ceil((a Ã— b + c) / 2)
  let expr3 = divide_with_ceil(add(multiply(a, b), c), 2)
  assert_eq(27, expr3)
  
  // è¡¨è¾¾å¼4: ceil(a / b) + ceil(b / c)
  let expr4 = add(divide_with_ceil(a, b), divide_with_ceil(b, c))
  assert_eq(3, expr4)
}