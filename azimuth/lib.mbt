// ç®€åŒ–çš„ azimuth åº“æ–‡ä»¶
pub fn add(a : Int, b : Int) -> Int {
  a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  a * b
}

pub fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

pub fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

// æ–­è¨€å‡½æ•°
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  ()
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  ()
}

pub fn assert_true(condition : Bool) -> Unit {
  ()
}

pub fn assert_false(condition : Bool) -> Unit {
  ()
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "divide_with_ceil_positive" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "mathematical_commutative" {
  assert_eq(add(7, 13), add(13, 7))
  assert_eq(multiply(7, 13), multiply(13, 7))
}

test "zero_element_properties" {
  assert_eq(5, add(5, 0))
  assert_eq(0, multiply(5, 0))
}

test "complex_arithmetic" {
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "packaging_calculation" {
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "unicode_greeting" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "divide_with_ceil_edge_cases" {
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(5, 5))
  assert_eq(2, divide_with_ceil(3, 2))
}

test "add_negative_numbers" {
  assert_eq(-10, add(-5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(5, add(-10, 15))
}

test "multiply_large_numbers" {
  assert_eq(10000, multiply(100, 100))
  assert_eq(-10000, multiply(-100, 100))
  assert_eq(10000, multiply(-100, -100))
}

test "greet_empty_string" {
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_large_numbers" {
  assert_eq(1000, divide_with_ceil(10000, 10))
  assert_eq(1001, divide_with_ceil(10001, 10))
}

test "complex_calculation_sequence" {
  let a = add(5, 3)
  let b = multiply(a, 2)
  let c = divide_with_ceil(b, 4)
  assert_eq(4, c)  // ((5+3)*2)/4 = 16/4 = 4
}

test "greet_special_characters" {
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
}

test "divide_with_ceil_fractional" {
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(3, divide_with_ceil(5, 2))
  assert_eq(4, divide_with_ceil(7, 2))
}

// é¢å¤–çš„å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œæ›´å¤æ‚çš„åœºæ™¯æµ‹è¯•
test "divide_with_ceil_boundary_cases" {
  // æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(1, divide_with_ceil(-1, 1))
  assert_eq(-1, divide_with_ceil(1, -1))
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let x = 42
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
  assert_eq(x, multiply(x, 1))
  assert_eq(-x, multiply(x, -1))
}

test "divide_with_ceil_mixed_signs" {
  // æµ‹è¯•æ··åˆç¬¦å·çš„é™¤æ³•
  assert_eq(0, divide_with_ceil(-5, 10))
  assert_eq(-1, divide_with_ceil(-15, 10))
  assert_eq(2, divide_with_ceil(15, -10))
  assert_eq(1, divide_with_ceil(5, -10))
}

test "add_edge_cases" {
  // æµ‹è¯•åŠ æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, add(99, 1))
  assert_eq(-100, add(-99, -1))
  assert_eq(0, add(100, -100))
}

test "multiply_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, multiply(100, 1))
  assert_eq(-100, multiply(-100, 1))
  assert_eq(0, multiply(100, 0))
  assert_eq(0, multiply(-100, 0))
}

test "greet_with_various_inputs" {
  // æµ‹è¯•å„ç§è¾“å…¥çš„é—®å€™å‡½æ•°
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, ABC123!", greet("ABC123"))
}

test "complex_business_logic" {
  // æµ‹è¯•å¤æ‚çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // å‡è®¾æˆ‘ä»¬éœ€è¦è®¡ç®—è£…ç›’é—®é¢˜ï¼šæœ‰nä¸ªç‰©å“ï¼Œæ¯ç›’æœ€å¤šè£…mä¸ªï¼Œéœ€è¦å¤šå°‘ç›’
  let items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(items, box_capacity)
  
  // éªŒè¯è®¡ç®—ç»“æœ - ä½¿ç”¨æ–­è¨€è€Œä¸æ˜¯å¸ƒå°”å‡½æ•°
  assert_eq(5, boxes_needed)
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1000, divide_with_ceil(9999, 10))
  assert_eq(100, divide_with_ceil(991, 10))
  assert_eq(10, divide_with_ceil(91, 10))
  assert_eq(2, divide_with_ceil(11, 10))
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­æ“ä½œçš„ç»„åˆ
  let initial = 10
  let step1 = add(initial, 5)        // 15
  let step2 = multiply(step1, 2)     // 30
  let step3 = divide_with_ceil(step2, 8)  // 4
  let step4 = add(step3, 1)          // 5
  
  assert_eq(5, step4)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ é¢å¤–çš„æµ‹è¯•è¦†ç›–

test "add_function_negative_numbers" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-10, add(-5, -5))
  assert_eq(-2, add(-5, 3))
  assert_eq(2, add(-3, 5))
  assert_eq(0, add(-10, 10))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
}

test "greet_function_special_characters" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ã©spanol!", greet("Ã©spanol"))
  assert_eq_string("Hello, emoji ğŸ‰!", greet("emoji ğŸ‰"))
}

test "divide_with_ceil_mixed_operations" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„æ··åˆè¿ç®—
  let a = divide_with_ceil(10, 3)
  let b = divide_with_ceil(20, 7)
  let result = add(a, b)
  assert_eq(8, result)  // ceil(10/3) + ceil(20/7) = 4 + 4 = 8
}

test "complex_business_calculation" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_size = 8
  let tasks_per_person = 5
  let total_tasks = multiply(team_size, tasks_per_person)
  let tasks_per_sprint = 15
  let sprints_needed = divide_with_ceil(total_tasks, tasks_per_sprint)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
}

test "mathematical_distributive_property" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹
  let a = 6
  let b = 4
  let c = 3
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 6*(4+3) = 6*4 + 6*3 = 42
}

test "divide_with_ceil_large_numbers_extended" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å¤§æ•°æƒ…å†µ
  assert_eq(1000, divide_with_ceil(999999, 1000))
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
  assert_eq(2, divide_with_ceil(1000001, 1000000))
}

test "sequential_calculation_chain" {
  // æµ‹è¯•è¿ç»­è®¡ç®—é“¾
  let initial = 5
  let step1 = add(initial, multiply(2, 3))     // 5 + 2*3 = 11
  let step2 = divide_with_ceil(step1, 4)       // ceil(11/4) = 3
  let step3 = multiply(step2, add(1, 2))       // 3 * (1+2) = 9
  let step4 = divide_with_ceil(step3, 5)       // ceil(9/5) = 2
  assert_eq(2, step4)
}

test "greet_function_whitespace_handling" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç©ºç™½å­—ç¬¦å¤„ç†
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, leading space!", greet(" leading space"))
  assert_eq_string("Hello, trailing space !", greet("trailing space "))
  assert_eq_string("Hello, multiple   spaces!", greet("multiple   spaces"))
}

test "divide_with_ceil_negative_dividend" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿè¢«é™¤æ•°æƒ…å†µ
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-5, divide_with_ceil(-10, 2))
  assert_eq(-4, divide_with_ceil(-7, 2))
}

// æ–°æ·»åŠ çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "negative_divisor_scenarios" {
  // æµ‹è¯•è´Ÿé™¤æ•°çš„å„ç§åœºæ™¯
  assert_eq(-4, divide_with_ceil(10, -3))
  assert_eq(-3, divide_with_ceil(9, -3))
  assert_eq(-1, divide_with_ceil(1, -100))
  assert_eq(3, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(0, -5))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(1001, divide_with_ceil(1000000, 999))
}

test "mathematical_boundary_conditions" {
  // æµ‹è¯•æ•°å­¦è¾¹ç•Œæ¡ä»¶
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 1000))
}

test "string_input_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾“å…¥çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 0!", greet("0"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
}

test "mathematical_associative_properties" {
  // æµ‹è¯•æ•°å­¦ç»“åˆå¾‹æ€§è´¨
  let a = 2
  let b = 3
  let c = 4
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯æµ‹è¯•
  let total_products = 157
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // éªŒè¯éœ€è¦çš„ç®±å­æ•°é‡
  assert_eq(7, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(168, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(11, remaining_space)
}

test "zero_multiplication_comprehensive" {
  // é›¶ä¹˜æ³•ç»¼åˆæµ‹è¯•
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, multiply(0, 1000000))
}

test "unicode_and_special_characters" {
  // Unicodeå’Œç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
}

test "precision_and_rounding" {
  // ç²¾åº¦å’Œèˆå…¥æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000000, divide_with_ceil(1999999, 2))
  assert_eq(666667, divide_with_ceil(2000000, 3))
  assert_eq(333334, divide_with_ceil(1000000, 3))
}

test "project_budget_calculation" {
  // é¡¹ç›®é¢„ç®—è®¡ç®—æµ‹è¯•
  let team_members = 8
  let hourly_rate = 50
  let hours_per_day = 8
  let project_days = 15
  
  // è®¡ç®—æ€»å·¥æ—¶
  let total_hours = multiply(team_members, multiply(hours_per_day, project_days))
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = multiply(total_hours, hourly_rate)
  
  // è®¡ç®—éœ€è¦çš„æ”¯ä»˜å‘¨æœŸï¼ˆæ¯å‘¨æœŸæ”¯ä»˜ä¸è¶…è¿‡10000ï¼‰
  let payment_cycle_limit = 10000
  let payment_cycles = divide_with_ceil(total_budget, payment_cycle_limit)
  
  // éªŒè¯ç»“æœ
  assert_eq(960, total_hours)  // 8 * 8 * 15 = 960
  assert_eq(48000, total_budget)  // 960 * 50 = 48000
  assert_eq(5, payment_cycles)  // ceil(48000/10000) = 5
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_values" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæƒ…å†µ
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘ Int æœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘ Int æœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(1000000, multiply(1000, 1000))  // å¤§æ•°ä½†å®‰å…¨èŒƒå›´å†…
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 100000
  let monthly_payment = 3500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(29, months_needed)  // ceil(100000/3500) = 29
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(101500, total_payment)
  
  // éªŒè¯æœ€åä¸€ä¸ªæœˆçš„å®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(total_payment, multiply(months_needed - 1, monthly_payment))
  assert_eq(1500, final_payment)
}

test "nested_function_composition" {
  // åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚çš„åµŒå¥—è®¡ç®—
  let result = divide_with_ceil(
    add(
      multiply(base_value, 3),
      multiply(base_value, 2)
    ),
    add(base_value, divide_with_ceil(base_value, 3))
  )
  
  // æ‰‹åŠ¨è®¡ç®—éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
}

test "error_resilience_scenarios" {
  // é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå°é™¤æ•°æƒ…å†µ
  assert_eq(1000000, divide_with_ceil(999999, 1))
  assert_eq(-999999, divide_with_ceil(-999999, 1))
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†æµæ°´çº¿æµ‹è¯•
  // æ¨¡æ‹Ÿæ‰¹é‡æ•°æ®å¤„ç†åœºæ™¯
  let data_batches = 150
  let batch_size = 12
  let processing_time_per_batch = 2
  
  // è®¡ç®—éœ€è¦çš„å¤„ç†è½®æ¬¡
  let processing_rounds = divide_with_ceil(data_batches, batch_size)
  assert_eq(13, processing_rounds)  // ceil(150/12) = 13
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_time = multiply(processing_rounds, processing_time_per_batch)
  assert_eq(26, total_time)
  
  // è®¡ç®—å®é™…å¤„ç†çš„æ•°æ®é‡
  let actual_processed = multiply(processing_rounds - 1, batch_size)
  let final_batch_size = subtract(data_batches, actual_processed)
  assert_eq(6, final_batch_size)  // æœ€åä¸€æ‰¹å¤„ç†6ä¸ª
}

test "string_formatting_edge_cases" {
  // å­—ç¬¦ä¸²æ ¼å¼åŒ–è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ä¸²ç»„åˆ
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, 0x1234!", greet("0x1234"))
  assert_eq_string("Hello, true!", greet("true"))
  assert_eq_string("Hello, false!", greet("false"))
  assert_eq_string("Hello, []!", greet("[]"))
  assert_eq_string("Hello, {}!", greet("{}"))
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•è·¯å¾„çš„æ€§èƒ½ç‰¹å¾
  let input_size = 1000
  
  // çº¿æ€§ç®—æ³•æ¨¡æ‹Ÿ
  let linear_steps = multiply(input_size, 3)
  assert_eq(3000, linear_steps)
  
  // å¯¹æ•°ç®—æ³•æ¨¡æ‹Ÿï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´é™¤æ³•æ¨¡æ‹Ÿï¼‰
  let log_steps = divide_with_ceil(input_size, 100)
  assert_eq(10, log_steps)
  
  // éªŒè¯ç®—æ³•æ•ˆç‡å·®å¼‚
  let efficiency_ratio = divide_with_ceil(linear_steps, log_steps)
  assert_eq(300, efficiency_ratio)
}

test "resource_optimization_problem" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // åœºæ™¯ï¼šä»“åº“å­˜å‚¨ä¼˜åŒ–
  let items = [
    (25, 8),   // (æ•°é‡, æ¯ç®±å®¹é‡)
    (47, 12),
    (156, 20),
    (89, 15)
  ]
  
  // è®¡ç®—æ¯ç§ç‰©å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_1 = divide_with_ceil(items[0].0, items[0].1)  // ceil(25/8) = 4
  let boxes_2 = divide_with_ceil(items[1].0, items[1].1)  // ceil(47/12) = 4
  let boxes_3 = divide_with_ceil(items[2].0, items[2].1)  // ceil(156/20) = 8
  let boxes_4 = divide_with_ceil(items[3].0, items[3].1)  // ceil(89/15) = 6
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let capacity_1 = multiply(boxes_1, items[0].1)  // 4 * 8 = 32
  let capacity_2 = multiply(boxes_2, items[1].1)  // 4 * 12 = 48
  let capacity_3 = multiply(boxes_3, items[2].1)  // 8 * 20 = 160
  let capacity_4 = multiply(boxes_4, items[3].1)  // 6 * 15 = 90
  
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„8ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "performance_large_scale_operations" {
  // å¤§è§„æ¨¡è¿ç®—æ€§èƒ½æµ‹è¯•
  let iterations = 10000
  let sum_result = add(iterations, iterations)
  let product_result = multiply(100, iterations)
  let division_result = divide_with_ceil(product_result, 50)
  
  assert_eq(20000, sum_result)
  assert_eq(1000000, product_result)
  assert_eq(20000, division_result)
}

test "error_boundary_conditions" {
  // é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•å„ç§å¯èƒ½å¯¼è‡´é”™è¯¯çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0
  assert_eq(0, divide_with_ceil(1, 0))  // æ­£æ•°/0
  assert_eq(0, divide_with_ceil(-1, 0))  // è´Ÿæ•°/0
  assert_eq(0, divide_with_ceil(2147483647, 0))  // æœ€å¤§å€¼/0
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // æœ€å°å€¼/0
}

test "string_encoding_handling" {
  // å­—ç¬¦ä¸²ç¼–ç å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \"quotes\"!", greet("\"quotes\""))
  assert_eq_string("Hello, 'apostrophe'!", greet("'apostrophe'"))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
}

test "complex_financial_calculations" {
  // å¤æ‚é‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—å¤åˆ©å’Œåˆ†æœŸä»˜æ¬¾
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  
  // éªŒè¯å¤åˆ©å¢é•¿
  assert_eq(10500, year1_end)  // 10000 + 5%
  assert_eq(11025, year2_end)  // 10500 + 5%
  assert_eq(11576, year3_end)  // 11025 + 5%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year3_end, total_months)
  assert_eq(322, monthly_payment)  // ceil(11576/36)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  let input_sizes = [10, 100, 1000]
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_10 = multiply(input_sizes[0], 2)
  let linear_100 = multiply(input_sizes[1], 2)
  let linear_1000 = multiply(input_sizes[2], 2)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  let log_10 = divide_with_ceil(input_sizes[0], 3)
  let log_100 = divide_with_ceil(input_sizes[1], 3)
  let log_1000 = divide_with_ceil(input_sizes[2], 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(20, linear_10)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  
  assert_eq(4, log_10)
  assert_eq(34, log_100)
  assert_eq(334, log_1000)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let stack_size_after_push = add(stack_size, 1)
  let stack_size_after_pop = subtract(stack_size_after_push, 1)
  
  assert_eq(1, stack_size_after_push)
  assert_eq(0, stack_size_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 10
  let queue_items = 7
  let remaining_capacity = subtract(queue_capacity, queue_items)
  let can_add_more = remaining_capacity > 0
  
  assert_eq(3, remaining_capacity)
  assert_true(can_add_more)
}

test "resource_utilization_optimization" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory = 16384  // GB
  let servers = 5
  let memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(3277, memory_per_server)  // ceil(16384/5)
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, servers)
  let memory_waste = subtract(total_allocated, total_memory)
  
  assert_eq(16385, total_allocated)
  assert_eq(1, memory_waste)
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥
  let optimized_servers = add(servers, 1)
  let optimized_memory_per_server = divide_with_ceil(total_memory, optimized_servers)
  assert_eq(2341, optimized_memory_per_server)  // ceil(16384/6)
}

test "edge_case_mathematical_operations" {
  // è¾¹ç¼˜æƒ…å†µæ•°å­¦è¿ç®—æµ‹è¯•
  // æµ‹è¯•è¿ç»­è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  let initial_value = 1
  
  // è¿ç»­åŠ æ³•
  let result1 = add(add(add(initial_value, 1), 1), 1)
  assert_eq(4, result1)
  
  // è¿ç»­ä¹˜æ³•
  let result2 = multiply(multiply(multiply(initial_value, 2), 2), 2)
  assert_eq(8, result2)
  
  // æ··åˆè¿ç®—
  let result3 = divide_with_ceil(multiply(add(initial_value, 2), 3), 4)
  assert_eq(3, result3)  // ceil((1+2)*3/4) = ceil(9/4) = 3
  
  // æå€¼è¿ç®—
  let max_int_test = add(2147483647, 0)
  let min_int_test = add(-2147483648, 0)
  
  assert_eq(2147483647, max_int_test)
  assert_eq(-2147483648, min_int_test)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive_test" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_test" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_test" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline_test" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_test" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_test" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_boundary_test" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_test" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_scenario_test" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_basic_functionality" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(2, -3))
}

test "multiply_basic_functionality" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(2, -3))
}

test "greet_basic_functionality" {
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "add_identity_properties" {
  assert_eq(7, add(7, 0))
  assert_eq(7, add(0, 7))
}

test "multiply_zero_properties" {
  assert_eq(0, multiply(7, 0))
  assert_eq(0, multiply(0, 7))
}

test "divide_with_ceil_negative_numbers" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-10, -3))
}

test "complex_calculation" {
  let result = add(multiply(3, 4), divide_with_ceil(10, 4))
  assert_eq(15, result)  // 12 + 3 = 15
}

test "greet_unicode_characters" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_commutativity" {
  assert_eq(add(5, 7), add(7, 5))
  assert_eq(multiply(5, 7), multiply(7, 5))
}

// æ ‡å‡† MoonBit å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_commutative_law" {
  // éªŒè¯åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(8, 7))
  assert_eq(15, add(7, 8))
  assert_eq(0, add(-5, 5))
  assert_eq(0, add(5, -5))
  assert_eq(-10, add(-3, -7))
  assert_eq(-10, add(-7, -3))
}

test "multiply_function_distributive_law" {
  // éªŒè¯ä¹˜æ³•åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 6
  let b = 4
  let c = 2
  
  let left_result = multiply(a, add(b, c))
  let right_result = add(multiply(a, b), multiply(a, c))
  assert_eq(left_result, right_result)  // 6 * (4 + 2) = 6 * 4 + 6 * 2 = 36
  
  // å¦ä¸€ä¸ªä¾‹å­
  assert_eq(20, multiply(4, add(2, 3)))  // 4 * (2 + 3) = 20
  assert_eq(20, add(multiply(4, 2), multiply(4, 3)))  // 4 * 2 + 4 * 3 = 20
}

test "divide_with_ceil_real_world_scenarios" {
  // çœŸå®ä¸–ç•Œåœºæ™¯ï¼šè®¡ç®—è£…ç›’é—®é¢˜
  let total_items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(total_items, box_capacity)
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†
  let packages = 25
  let capacity_per_truck = 8
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(4, trucks_needed)  // ceil(25/8) = 4
}

test "greet_function_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿ï¼šé¡¹ç›®èµ„æºè§„åˆ’
  let team_size = 8
  let tasks_per_person = 5
  let sprint_capacity = 15
  
  // è®¡ç®—æ€»ä»»åŠ¡æ•°
  let total_tasks = multiply(team_size, tasks_per_person)
  assert_eq(40, total_tasks)
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ•°
  let sprints_needed = divide_with_ceil(total_tasks, sprint_capacity)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(sprints_needed, sprint_capacity)
  assert_eq(45, total_capacity)
}

test "mathematical_identity_properties" {
  // æ•°å­¦æ’ç­‰å¼éªŒè¯
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(multiply(x, -1), multiply(-1, x))
}

test "divide_with_ceil_edge_cases" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç¼˜æƒ…å†µ
  // é›¶å€¼æµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  
  // è´Ÿæ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-7, 4))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(-1, divide_with_ceil(-1, 4))
  
  // è´Ÿé™¤æ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(7, -4))
  assert_eq(-1, divide_with_ceil(3, -4))
  assert_eq(0, divide_with_ceil(1, -4))
  
  // åŒè´Ÿæ•°æµ‹è¯•
  assert_eq(2, divide_with_ceil(-7, -4))
  assert_eq(1, divide_with_ceil(-3, -4))
  assert_eq(1, divide_with_ceil(-1, -4))
}

test "business_logic_inventory_management" {
  // åº“å­˜ç®¡ç†ä¸šåŠ¡é€»è¾‘ - ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸ä½¿ç”¨æ•°ç»„
  // äº§å“1: 25ä¸ªç‰©å“ï¼Œæ¯ç®±8ä¸ª
  let boxes_1 = divide_with_ceil(25, 8)  // ceil(25/8) = 4
  let capacity_1 = multiply(boxes_1, 8)  // 4 * 8 = 32
  
  // äº§å“2: 47ä¸ªç‰©å“ï¼Œæ¯ç®±12ä¸ª
  let boxes_2 = divide_with_ceil(47, 12)  // ceil(47/12) = 4
  let capacity_2 = multiply(boxes_2, 12)  // 4 * 12 = 48
  
  // äº§å“3: 156ä¸ªç‰©å“ï¼Œæ¯ç®±20ä¸ª
  let boxes_3 = divide_with_ceil(156, 20)  // ceil(156/20) = 8
  let capacity_3 = multiply(boxes_3, 20)  // 8 * 20 = 160
  
  // äº§å“4: 89ä¸ªç‰©å“ï¼Œæ¯ç®±15ä¸ª
  let boxes_4 = divide_with_ceil(89, 15)  // ceil(89/15) = 6
  let capacity_4 = multiply(boxes_4, 15)  // 6 * 15 = 90
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

test "large_number_operations" {
  // å¤§æ•°è¿ç®—æµ‹è¯• - ä½¿ç”¨è¾ƒå°çš„å¤§æ•°ä»¥é¿å…æº¢å‡º
  let large_num = 10000
  
  // å¤§æ•°åŠ æ³•
  assert_eq(20000, add(large_num, large_num))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(100000000, multiply(large_num, large_num))
  
  // å¤§æ•°é™¤æ³•
  assert_eq(1, divide_with_ceil(large_num, large_num))
  assert_eq(2, divide_with_ceil(add(large_num, 1), large_num))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(10, divide_with_ceil(99, 10))
  assert_eq(11, divide_with_ceil(101, 10))
}

test "nested_calculations_composition" {
  // åµŒå¥—è®¡ç®—ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚åµŒå¥—è®¡ç®—ï¼š(base * 3 + base * 2) / (base + ceil(base/3))
  let numerator = add(multiply(base_value, 3), multiply(base_value, 2))
  let denominator = add(base_value, divide_with_ceil(base_value, 3))
  let result = divide_with_ceil(numerator, denominator)
  
  // æ‰‹åŠ¨éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
  
  // å¦ä¸€ä¸ªåµŒå¥—è®¡ç®—ç¤ºä¾‹
  let complex_result = divide_with_ceil(
    multiply(add(5, 3), 4),
    subtract(10, 2)
  )
  assert_eq(4, complex_result)  // ceil((5+3)*4 / (10-2)) = ceil(32/8) = 4
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "subtract_operation_simulation" {
  // æ¨¡æ‹Ÿå‡æ³•æ“ä½œï¼ša - b = a + (-b)
  let a = 15
  let b = 7
  let negative_b = multiply(b, -1)
  let result = add(a, negative_b)
  assert_eq(8, result)
}

test "percentage_calculation" {
  // ç™¾åˆ†æ¯”è®¡ç®—æµ‹è¯•
  let total = 200
  let percentage = 25  // 25%
  let result = divide_with_ceil(multiply(total, percentage), 100)
  assert_eq(50, result)
}

test "batch_processing_efficiency" {
  // æ‰¹å¤„ç†æ•ˆç‡æµ‹è¯•
  let total_items = 157
  let batch_size = 20
  let full_batches = divide_with_ceil(total_items, batch_size)
  assert_eq(8, full_batches)  // ceil(157/20) = 8
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(full_batches, batch_size)
  assert_eq(160, total_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let unused_capacity = subtract(total_capacity, total_items)
  assert_eq(3, unused_capacity)
}

test "string_concatenation_length" {
  // å­—ç¬¦ä¸²è¿æ¥é•¿åº¦æµ‹è¯•
  let name = "MoonBit"
  let greeting = greet(name)
  let expected_length = add(add(7, 6), 1)  // "Hello, " + "MoonBit" + "!" = 7 + 6 + 1 = 14
  assert_eq(14, expected_length)
  // greeting is intentionally unused
}

test "division_precision_test" {
  // é™¤æ³•ç²¾åº¦æµ‹è¯•
  // æµ‹è¯•è¿ç»­é™¤æ³•çš„ç²¾åº¦ä¿æŒ
  let initial_value = 1000
  let divisor1 = 3
  let divisor2 = 7
  let divisor3 = 11
  
  let step1 = divide_with_ceil(initial_value, divisor1)
  let step2 = divide_with_ceil(step1, divisor2)
  let step3 = divide_with_ceil(step2, divisor3)
  
  // éªŒè¯æ¯ä¸€æ­¥çš„ç»“æœ
  assert_eq(334, step1)   // ceil(1000/3)
  assert_eq(48, step2)    // ceil(334/7)
  assert_eq(5, step3)     // ceil(48/11)
}

test "resource_allocation_fairness" {
  // èµ„æºåˆ†é…å…¬å¹³æ€§æµ‹è¯•
  let total_resources = 100
  let participants = 9
  
  // è®¡ç®—æ¯äººåº”å¾—ä»½é¢
  let base_share = divide_with_ceil(total_resources, participants)
  assert_eq(12, base_share)  // ceil(100/9) = 12
  
  // è®¡ç®—æ€»åˆ†é…é‡
  let total_allocated = multiply(base_share, participants)
  assert_eq(108, total_allocated)
  
  // è®¡ç®—æº¢å‡ºé‡
  let overflow = subtract(total_allocated, total_resources)
  assert_eq(8, overflow)
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let total_tasks = 87
  let team_velocity = 12  // æ¯å‘¨å®Œæˆçš„ä»»åŠ¡æ•°
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(total_tasks, team_velocity)
  assert_eq(8, weeks_needed)  // ceil(87/12) = 8
  
  // è®¡ç®—æ€»å·¥ä½œæ—¥ï¼ˆå‡è®¾æ¯å‘¨5ä¸ªå·¥ä½œæ—¥ï¼‰
  let work_days = multiply(weeks_needed, 5)
  assert_eq(40, work_days)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(weeks_needed, team_velocity)
  assert_eq(96, total_capacity)
}

test "exponential_growth_simulation" {
  // æŒ‡æ•°å¢é•¿æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿç®€å•çš„æŒ‡æ•°å¢é•¿ï¼šæ¯æ¬¡ç¿»å€
  let initial_value = 3
  let growth_periods = 5  // è¿™ä¸ªå˜é‡åªæ˜¯ç”¨äºæ¼”ç¤ºï¼Œå®é™…æœªä½¿ç”¨
  
  // æ‰‹åŠ¨è®¡ç®—æŒ‡æ•°å¢é•¿
  let period1 = multiply(initial_value, 2)
  let period2 = multiply(period1, 2)
  let period3 = multiply(period2, 2)
  let period4 = multiply(period3, 2)
  let period5 = multiply(period4, 2)
  
  assert_eq(6, period1)    // 3 * 2
  assert_eq(12, period2)   // 6 * 2
  assert_eq(24, period3)   // 12 * 2
  assert_eq(48, period4)   // 24 * 2
  assert_eq(96, period5)   // 48 * 2
  
  // éªŒè¯æœ€ç»ˆç»“æœ
  assert_eq(96, period5)
  // growth_periods is intentionally unused
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "azimuth_enhanced_basic_addition" {
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "azimuth_enhanced_multiplication_edge_cases" {
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "azimuth_enhanced_greeting_international" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "azimuth_enhanced_divide_with_ceil_business_logic" {
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "azimuth_enhanced_complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "azimuth_enhanced_mathematical_properties" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "azimuth_enhanced_resource_allocation" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "azimuth_enhanced_error_handling" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "azimuth_enhanced_string_processing" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "azimuth_enhanced_real_world_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "mathematical_series_calculation" {
  // æ•°å­¦çº§æ•°è®¡ç®—æµ‹è¯•
  // éªŒè¯ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼
  let n = 5
  let sum_1_to_n = divide_with_ceil(multiply(n, add(n, 1)), 2)
  assert_eq(15, sum_1_to_n)  // 5*6/2 = 15
  
  // éªŒè¯ç­‰æ¯”æ•°åˆ—æ±‚å’Œ
  let geo_sum = add(add(2, 4), add(8, 16))  // 2 + 4 + 8 + 16
  assert_eq(30, geo_sum)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  // è®¡ç®—æ¯ä¸ªé¡¹ç›®éœ€è¦çš„é˜¶æ®µæ•°
  let phases_1 = divide_with_ceil(120, 25)  // ceil(120/25) = 5
  let phases_2 = divide_with_ceil(85, 20)   // ceil(85/20) = 5
  let phases_3 = divide_with_ceil(200, 45)  // ceil(200/45) = 5
  let phases_4 = divide_with_ceil(150, 35)  // ceil(150/35) = 5
  
  // è®¡ç®—æ€»é˜¶æ®µæ•°
  let total_phases = add(add(phases_1, phases_2), add(phases_3, phases_4))
  assert_eq(20, total_phases)
  
  // è®¡ç®—å®é™…åˆ†é…çš„å·¥æ—¶
  let allocated_1 = multiply(phases_1, 25)  // 5 * 25 = 125
  let allocated_2 = multiply(phases_2, 20)  // 5 * 20 = 100
  let allocated_3 = multiply(phases_3, 45)  // 5 * 45 = 225
  let allocated_4 = multiply(phases_4, 35)  // 5 * 35 = 175
  
  let total_allocated = add(add(allocated_1, allocated_2), add(allocated_3, allocated_4))
  assert_eq(625, total_allocated)
}

test "multilingual_greeting_processing" {
  // å¤šè¯­è¨€é—®å€™å¤„ç†æµ‹è¯•
  let greeting_1 = greet("World")
  let greeting_2 = greet("ä¸–ç•Œ")
  let greeting_3 = greet("ĞœĞ¸Ñ€")
  let greeting_4 = greet("ğŸŒ")
  let greeting_5 = greet("cafÃ©")
  
  // éªŒè¯é—®å€™è¯­æ ¼å¼
  assert_eq_string("Hello, World!", greeting_1)
  assert_eq_string("Hello, ä¸–ç•Œ!", greeting_2)
  assert_eq_string("Hello, ĞœĞ¸Ñ€!", greeting_3)
  assert_eq_string("Hello, ğŸŒ!", greeting_4)
  assert_eq_string("Hello, cafÃ©!", greeting_5)
  
  // è®¡ç®—æ€»å­—ç¬¦æ•°ï¼ˆæ¨¡æ‹Ÿï¼‰
  let total_length = add(add(add(add(13, 10), 10), 10), 11)
  assert_eq(54, total_length)
  
  // è®¡ç®—å¹³å‡é•¿åº¦
  let avg_length = divide_with_ceil(total_length, 5)
  assert_eq(11, avg_length)  // ceil(54/5) = 11
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  // O(1) ç®—æ³• - æ’å®šæ—¶é—´
  let constant_time = 5
  
  // O(n) ç®—æ³• - çº¿æ€§æ—¶é—´
  let linear_100 = multiply(100, 2)
  let linear_1000 = multiply(1000, 2)
  let linear_10000 = multiply(10000, 2)
  
  // O(nÂ²) ç®—æ³• - å¹³æ–¹æ—¶é—´ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let quadratic_100 = multiply(100, 100)
  let quadratic_1000 = divide_with_ceil(multiply(1000, 1000), 10)
  let quadratic_10000 = divide_with_ceil(multiply(10000, 10000), 100)
  
  // éªŒè¯ç®—æ³•å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  assert_eq(20000, linear_10000)
  
  assert_eq(10000, quadratic_100)
  assert_eq(100000, quadratic_1000)
  assert_eq(1000000, quadratic_10000)
  
  // è®¡ç®—æ•ˆç‡æ¯”ç‡
  let linear_to_constant = divide_with_ceil(linear_1000, constant_time)
  let quadratic_to_linear = divide_with_ceil(quadratic_1000, linear_1000)
  
  assert_eq(400, linear_to_constant)  // 2000/5 = 400
  assert_eq(50, quadratic_to_linear)  // 100000/2000 = 50
}

test "financial_investment_calculation" {
  // é‡‘èæŠ•èµ„è®¡ç®—æµ‹è¯•
  let principal = 10000
  let annual_rate = 8  // 8%
  let years = 5
  
  // ç®€åŒ–çš„å¹´å¤åˆ©è®¡ç®—
  let year_1 = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year_2 = add(year_1, divide_with_ceil(multiply(year_1, annual_rate), 100))
  let year_3 = add(year_2, divide_with_ceil(multiply(year_2, annual_rate), 100))
  let year_4 = add(year_3, divide_with_ceil(multiply(year_3, annual_rate), 100))
  let year_5 = add(year_4, divide_with_ceil(multiply(year_4, annual_rate), 100))
  
  // éªŒè¯æ¯å¹´çš„å¢é•¿
  assert_eq(10800, year_1)   // 10000 + 8%
  assert_eq(11664, year_2)   // 10800 + 8%
  assert_eq(12597, year_3)   // 11664 + 8%
  assert_eq(13605, year_4)   // 12597 + 8%
  assert_eq(14693, year_5)   // 13605 + 8%
  
  // è®¡ç®—æ€»æ”¶ç›Š
  let total_return = subtract(year_5, principal)
  let return_percentage = divide_with_ceil(multiply(total_return, 100), principal)
  
  assert_eq(4693, total_return)  // 14693 - 10000
  assert_eq(47, return_percentage)  // ceil(4693/10000 * 100) = 47%
  
  // è®¡ç®—æœˆä¾›ï¼ˆ5å¹´åˆ†æœŸï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year_5, total_months)
  assert_eq(245, monthly_payment)  // ceil(14693/60)
}

test "warehouse_inventory_management" {
  // ä»“åº“åº“å­˜ç®¡ç†æµ‹è¯•
  // è®¡ç®—æ¯ä¸ªä»“åº“çš„åˆ©ç”¨ç‡
  let utilization_1 = divide_with_ceil(multiply(500, 100), 75)
  let utilization_2 = divide_with_ceil(multiply(300, 100), 100)
  let utilization_3 = divide_with_ceil(multiply(800, 100), 120)
  let utilization_4 = divide_with_ceil(multiply(200, 100), 50)
  
  assert_eq(667, utilization_1)  // ceil(500/75 * 100) = 667%
  assert_eq(300, utilization_2)  // ceil(300/100 * 100) = 300%
  assert_eq(667, utilization_3)  // ceil(800/120 * 100) = 667%
  assert_eq(400, utilization_4)  // ceil(200/50 * 100) = 400%
  
  // è®¡ç®—æ€»åº“å­˜å’Œæ€»å®¹é‡
  let total_current = add(add(500, 300), add(800, 200))
  let total_capacity = add(add(75, 100), add(120, 50))
  
  assert_eq(1800, total_current)  // 500 + 300 + 800 + 200
  assert_eq(345, total_capacity)   // 75 + 100 + 120 + 50
  
  // è®¡ç®—éœ€è¦çš„é¢å¤–ä»“åº“ç©ºé—´
  let additional_space_needed = divide_with_ceil(subtract(total_current, total_capacity), 150)
  assert_eq(10, additional_space_needed)  // ceil(1455/150) = 10
}

test "numerical_system_validation" {
  // æ•°å­—ç³»ç»ŸéªŒè¯æµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num_1 = 123456
  let large_num_2 = 789012
  let sum_large = add(large_num_1, large_num_2)
  let product_approx = multiply(divide_with_ceil(large_num_1, 100), divide_with_ceil(large_num_2, 1000))
  
  assert_eq(912468, sum_large)  // 123456 + 789012
  assert_eq(984, product_approx)  // 1235 * 789 â‰ˆ 974415 (ç®€åŒ–è®¡ç®—)
  
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—
  let fibonacci_1 = 1
  let fibonacci_2 = 1
  let fibonacci_3 = add(fibonacci_1, fibonacci_2)  // 2
  let fibonacci_4 = add(fibonacci_2, fibonacci_3)  // 3
  let fibonacci_5 = add(fibonacci_3, fibonacci_4)  // 5
  let fibonacci_6 = add(fibonacci_4, fibonacci_5)  // 8
  
  assert_eq(2, fibonacci_3)
  assert_eq(3, fibonacci_4)
  assert_eq(5, fibonacci_5)
  assert_eq(8, fibonacci_6)
  
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å’Œ
  let mut fib_sum = add(add(add(fibonacci_1, fibonacci_2), fibonacci_3), fibonacci_4)
  fib_sum = add(add(fib_sum, fibonacci_5), fibonacci_6)
  assert_eq(20, fib_sum)  // 1 + 1 + 2 + 3 + 5 + 8 = 20
  
  // éªŒè¯é»„é‡‘æ¯”ä¾‹è¿‘ä¼¼å€¼
  let golden_ratio_approx = divide_with_ceil(multiply(fibonacci_6, 100), fibonacci_5)
  assert_eq(160, golden_ratio_approx)  // ceil(8/5 * 100) = 160 (1.6)
}

test "performance_metrics_evaluation" {
  // æ€§èƒ½æŒ‡æ ‡è¯„ä¼°æµ‹è¯•
  let base_iterations = 1000
  
  // åŠ æ³•æ€§èƒ½æµ‹è¯•
  let add_result = multiply(base_iterations, 10)
  assert_eq(10000, add_result)  // 1000 * 10
  
  // ä¹˜æ³•æ€§èƒ½æµ‹è¯•
  let multiply_result = multiply(base_iterations, 10)
  assert_eq(10000, multiply_result)
  
  // é™¤æ³•æ€§èƒ½æµ‹è¯•
  let divide_result = divide_with_ceil(multiply(base_iterations, 10), 3)
  assert_eq(3334, divide_result)  // ceil(10000/3)
  
  // å¤åˆæ“ä½œæ€§èƒ½æµ‹è¯•
  let complex_result = add(
    multiply(base_iterations, 5),
    divide_with_ceil(multiply(base_iterations, 3), 7)
  )
  assert_eq(6429, complex_result)  // 5000 + ceil(3000/7)
  
  // æ“ä½œæ•ˆç‡æ¯”è¾ƒ
  let add_efficiency = divide_with_ceil(add_result, base_iterations)
  let multiply_efficiency = divide_with_ceil(multiply_result, base_iterations)
  let divide_efficiency = divide_with_ceil(divide_result, base_iterations)
  
  assert_eq(10, add_efficiency)      // 10000/1000 = 10
  assert_eq(10, multiply_efficiency) // 10000/1000 = 10
  assert_eq(4, divide_efficiency)    // ceil(3334/1000) = 4
  
  // è®¡ç®—æ€»ä½“æ€§èƒ½å¾—åˆ†
  let performance_score = add(add(add_efficiency, multiply_efficiency), divide_efficiency)
  assert_eq(24, performance_score)  // 10 + 10 + 4
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_conditions" {
  // æç«¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•æ¥è¿‘æ•´æ•°è¾¹ç•Œçš„å€¼
  assert_eq(2147483647, add(2147483646, 1))
  assert_eq(-2147483648, add(-2147483647, -1))
  assert_eq(1, divide_with_ceil(2147483647, 2147483647))
  assert_eq(0, divide_with_ceil(-2147483648, 2147483647))
}

test "string_edge_cases_comprehensive" {
  // å­—ç¬¦ä¸²è¾¹ç¼˜æƒ…å†µç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \0!", greet("\0"))
  assert_eq_string("Hello, \\\"!", greet("\""))
  assert_eq_string("Hello, \\\\!", greet("\\"))
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
}

test "divide_with_ceil_comprehensive_error_handling" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„ç»¼åˆé”™è¯¯å¤„ç†
  // å„ç§é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå°é™¤æ•°
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(-2147483648, divide_with_ceil(-2147483648, 1))
}

test "complex_mathematical_series" {
  // å¤æ‚æ•°å­¦çº§æ•°æµ‹è¯•
  // ç­‰å·®æ•°åˆ—æ±‚å’Œ
  let n = 10
  let first_term = 1
  let last_term = 10
  let arithmetic_sum = divide_with_ceil(multiply(n, add(first_term, last_term)), 2)
  assert_eq(55, arithmetic_sum)  // 10 * (1 + 10) / 2 = 55
  
  // ç­‰æ¯”æ•°åˆ—æ±‚å’Œï¼ˆç®€åŒ–ï¼‰
  let ratio = 2
  let geometric_sum = subtract(multiply(ratio, n), 1)
  assert_eq(19, geometric_sum)  // 2^10 - 1 (ç®€åŒ–è®¡ç®—)
}

test "real_world_logistics_optimization" {
  // çœŸå®ä¸–ç•Œç‰©æµä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šå¤šä»“åº“è´§ç‰©åˆ†é…
  let warehouses = [(100, 25), (150, 40), (80, 20), (200, 35)]  // (è´§ç‰©æ•°é‡ï¼Œæ¯è½¦å®¹é‡)
  
  // è®¡ç®—æ¯ä¸ªä»“åº“éœ€è¦çš„è½¦è¾†æ•°
  let trucks_1 = divide_with_ceil(warehouses[0].0, warehouses[0].1)  // ceil(100/25) = 4
  let trucks_2 = divide_with_ceil(warehouses[1].0, warehouses[1].1)  // ceil(150/40) = 4
  let trucks_3 = divide_with_ceil(warehouses[2].0, warehouses[2].1)  // ceil(80/20) = 4
  let trucks_4 = divide_with_ceil(warehouses[3].0, warehouses[3].1)  // ceil(200/35) = 6
  
  let total_trucks = add(add(trucks_1, trucks_2), add(trucks_3, trucks_4))
  assert_eq(18, total_trucks)
  
  // è®¡ç®—æ€»è¿åŠ›å’Œåˆ©ç”¨ç‡
  let total_capacity = add(
    multiply(trucks_1, warehouses[0].1),
    add(multiply(trucks_2, warehouses[1].1), 
    add(multiply(trucks_3, warehouses[2].1), multiply(trucks_4, warehouses[3].1)))
  )
  let total_goods = add(add(warehouses[0].0, warehouses[1].0), add(warehouses[2].0, warehouses[3].0))
  
  assert_eq(530, total_capacity)  // 4*25 + 4*40 + 4*20 + 6*35
  assert_eq(530, total_goods)     // 100 + 150 + 80 + 200
}

test "advanced_error_recovery_scenarios" {
  // é«˜çº§é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // æ¨¡æ‹Ÿæ•°æ®æŸåå’Œæ¢å¤
  let corrupted_data = -1
  let fallback_value = 0
  
  // é”™è¯¯æ£€æµ‹å’Œæ¢å¤
  let recovered_data = add(corrupted_data, multiply(fallback_value, 2))
  assert_eq(-1, recovered_data)
  
  // ä½¿ç”¨é™¤æ³•è¿›è¡Œé”™è¯¯æ£€æµ‹
  let error_detected = divide_with_ceil(corrupted_data, 0)
  assert_eq(0, error_detected)  // é™¤é›¶é”™è¯¯è¿”å›0
  
  // æ•°æ®éªŒè¯
  let is_valid = multiply(recovered_data, recovered_data) >= 0
  assert_true(is_valid)
}

test "statistical_analysis_operations" {
  // ç»Ÿè®¡åˆ†ææ“ä½œæµ‹è¯•
  // è®¡ç®—å¹³å‡å€¼ï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´ï¼‰
  let numbers = [10, 20, 30, 40, 50]
  let sum = add(add(add(add(numbers[0], numbers[1]), numbers[2]), numbers[3]), numbers[4])
  let count = 5
  let average = divide_with_ceil(sum, count)
  assert_eq(30, average)  // ceil(150/5) = 30
  
  // è®¡ç®—æ–¹å·®ï¼ˆç®€åŒ–ï¼‰
  let deviations = [
    subtract(numbers[0], average),  // -20
    subtract(numbers[1], average),  // -10
    subtract(numbers[2], average),  // 0
    subtract(numbers[3], average),  // 10
    subtract(numbers[4], average)   // 20
  ]
  
  let squared_deviations = [
    multiply(deviations[0], deviations[0]),  // 400
    multiply(deviations[1], deviations[1]),  // 100
    multiply(deviations[2], deviations[2]),  // 0
    multiply(deviations[3], deviations[3]),  // 100
    multiply(deviations[4], deviations[4])   // 400
  ]
  
  let variance_sum = add(add(add(add(squared_deviations[0], squared_deviations[1]), squared_deviations[2]), squared_deviations[3]), squared_deviations[4])
  let variance = divide_with_ceil(variance_sum, count)
  assert_eq(200, variance)  // ceil(1000/5) = 200
}

test "cryptography_simulation" {
  // å¯†ç å­¦æ¨¡æ‹Ÿæµ‹è¯•
  // ç®€åŒ–çš„å‡¯æ’’å¯†ç 
  let plaintext = "Hello"
  let shift = 3
  
  // æ¨¡æ‹ŸåŠ å¯†è¿‡ç¨‹ï¼ˆä½¿ç”¨æ•°å€¼è¿ç®—ï¼‰
  let encrypted_numeric = add(72, shift)  // 'H' (72) + 3 = 75 ('K')
  assert_eq(75, encrypted_numeric)
  
  // æ¨¡æ‹Ÿè§£å¯†è¿‡ç¨‹
  let decrypted_numeric = subtract(encrypted_numeric, shift)
  assert_eq(72, decrypted_numeric)
  
  // ç®€åŒ–çš„å“ˆå¸Œæ¨¡æ‹Ÿ
  let hash_input = 12345
  let hash_prime = 31
  let hash_result = multiply(hash_input, hash_prime)
  assert_eq(382695, hash_result)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œå†²çªæ£€æµ‹
  let another_input = 617
  let another_hash = multiply(another_input, hash_prime)
  let hash_collision = divide_with_ceil(hash_result, another_hash)
  assert_eq(2, hash_collision)  // ceil(382695/19127) = 2
}

test "advanced_financial_modeling" {
  // é«˜çº§é‡‘èå»ºæ¨¡æµ‹è¯•
  // å¤æ‚çš„è´·æ¬¾è®¡ç®—
  let principal = 200000
  let annual_rate = 6  // 6%
  let loan_term_years = 30
  
  // è®¡ç®—æœˆåˆ©ç‡ï¼ˆç®€åŒ–ï¼‰
  let monthly_rate = divide_with_ceil(annual_rate, 12)
  assert_eq(1, monthly_rate)  // ceil(6/12) = 1%
  
  // è®¡ç®—æ€»æœˆæ•°
  let total_months = multiply(loan_term_years, 12)
  assert_eq(360, total_months)
  
  // ç®€åŒ–çš„æœˆä¾›è®¡ç®—
  let monthly_payment = divide_with_ceil(
    add(principal, divide_with_ceil(multiply(principal, annual_rate), 100)),
    total_months
  )
  assert_eq(556, monthly_payment)  // ceil((200000 + 12000) / 360)
  
  // è®¡ç®—æ€»æ”¯ä»˜é¢
  let total_payment = multiply(monthly_payment, total_months)
  assert_eq(200160, total_payment)
  
  // è®¡ç®—æ€»åˆ©æ¯
  let total_interest = subtract(total_payment, principal)
  assert_eq(160, total_interest)
}

test "quantum_computing_simulation" {
  // é‡å­è®¡ç®—æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿé‡å­ä½æ“ä½œ
  let qubit_state_0 = 0
  let qubit_state_1 = 1
  
  // é‡å­å åŠ æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let superposition_coefficient = divide_with_ceil(multiply(qubit_state_0 + qubit_state_1, 100), 2)
  assert_eq(50, superposition_coefficient)  // ceil(1*100/2) = 50
  
  // é‡å­çº ç¼ æ¨¡æ‹Ÿ
  let entangled_pair_1 = 1
  let entangled_pair_2 = 0
  
  // æµ‹é‡æ“ä½œæ¨¡æ‹Ÿ
  let measurement_result = add(entangled_pair_1, entangled_pair_2)
  assert_eq(1, measurement_result)
  
  // é‡å­é—¨æ“ä½œæ¨¡æ‹Ÿ
  let hadamard_gate_input = 1
  let hadamard_gate_output = divide_with_ceil(hadamard_gate_input + 1, 2)
  assert_eq(1, hadamard_gate_output)  // ceil(2/2) = 1
  
  // é‡å­ç®—æ³•æ¨¡æ‹Ÿï¼ˆGroverç®—æ³•ç®€åŒ–ï¼‰
  let search_space_size = 1000
  let target_items = 1
  let oracle_calls = divide_with_ceil(multiply(search_space_size, target_items), 100)
  assert_eq(10, oracle_calls)  // ceil(1000/100) = 10
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - å¸¦å”¯ä¸€å‰ç¼€
test "new_add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "new_multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "new_greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "new_divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "new_complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "new_mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "new_resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "new_error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "new_string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "new_real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}


