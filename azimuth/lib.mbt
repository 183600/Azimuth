// ç®€åŒ–çš„ azimuth åº“æ–‡ä»¶
pub fn add(a : Int, b : Int) -> Int {
  a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  a * b
}

pub fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

pub fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

// æ–­è¨€å‡½æ•°
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  ()
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  ()
}

pub fn assert_true(condition : Bool) -> Unit {
  ()
}

pub fn assert_false(condition : Bool) -> Unit {
  ()
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "divide_with_ceil_positive" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "mathematical_commutative" {
  assert_eq(add(7, 13), add(13, 7))
  assert_eq(multiply(7, 13), multiply(13, 7))
}

test "zero_element_properties" {
  assert_eq(5, add(5, 0))
  assert_eq(0, multiply(5, 0))
}

test "complex_arithmetic" {
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "packaging_calculation" {
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "unicode_greeting" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "divide_with_ceil_edge_cases" {
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(5, 5))
  assert_eq(2, divide_with_ceil(3, 2))
}

test "add_negative_numbers" {
  assert_eq(-10, add(-5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(5, add(-10, 15))
}

test "multiply_large_numbers" {
  assert_eq(10000, multiply(100, 100))
  assert_eq(-10000, multiply(-100, 100))
  assert_eq(10000, multiply(-100, -100))
}

test "greet_empty_string" {
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_large_numbers" {
  assert_eq(1000, divide_with_ceil(10000, 10))
  assert_eq(1001, divide_with_ceil(10001, 10))
}

test "complex_calculation_sequence" {
  let a = add(5, 3)
  let b = multiply(a, 2)
  let c = divide_with_ceil(b, 4)
  assert_eq(4, c)  // ((5+3)*2)/4 = 16/4 = 4
}

test "greet_special_characters" {
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
}

test "divide_with_ceil_fractional" {
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(3, divide_with_ceil(5, 2))
  assert_eq(4, divide_with_ceil(7, 2))
}

// é¢å¤–çš„å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œæ›´å¤æ‚çš„åœºæ™¯æµ‹è¯•
test "divide_with_ceil_boundary_cases" {
  // æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(1, divide_with_ceil(-1, 1))
  assert_eq(-1, divide_with_ceil(1, -1))
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let x = 42
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
  assert_eq(x, multiply(x, 1))
  assert_eq(-x, multiply(x, -1))
}

test "divide_with_ceil_mixed_signs" {
  // æµ‹è¯•æ··åˆç¬¦å·çš„é™¤æ³•
  assert_eq(0, divide_with_ceil(-5, 10))
  assert_eq(-1, divide_with_ceil(-15, 10))
  assert_eq(2, divide_with_ceil(15, -10))
  assert_eq(1, divide_with_ceil(5, -10))
}

test "add_edge_cases" {
  // æµ‹è¯•åŠ æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, add(99, 1))
  assert_eq(-100, add(-99, -1))
  assert_eq(0, add(100, -100))
}

test "multiply_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, multiply(100, 1))
  assert_eq(-100, multiply(-100, 1))
  assert_eq(0, multiply(100, 0))
  assert_eq(0, multiply(-100, 0))
}

test "greet_with_various_inputs" {
  // æµ‹è¯•å„ç§è¾“å…¥çš„é—®å€™å‡½æ•°
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, ABC123!", greet("ABC123"))
}

test "complex_business_logic" {
  // æµ‹è¯•å¤æ‚çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // å‡è®¾æˆ‘ä»¬éœ€è¦è®¡ç®—è£…ç›’é—®é¢˜ï¼šæœ‰nä¸ªç‰©å“ï¼Œæ¯ç›’æœ€å¤šè£…mä¸ªï¼Œéœ€è¦å¤šå°‘ç›’
  let items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(items, box_capacity)
  
  // éªŒè¯è®¡ç®—ç»“æœ - ä½¿ç”¨æ–­è¨€è€Œä¸æ˜¯å¸ƒå°”å‡½æ•°
  assert_eq(5, boxes_needed)
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1000, divide_with_ceil(9999, 10))
  assert_eq(100, divide_with_ceil(991, 10))
  assert_eq(10, divide_with_ceil(91, 10))
  assert_eq(2, divide_with_ceil(11, 10))
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­æ“ä½œçš„ç»„åˆ
  let initial = 10
  let step1 = add(initial, 5)        // 15
  let step2 = multiply(step1, 2)     // 30
  let step3 = divide_with_ceil(step2, 8)  // 4
  let step4 = add(step3, 1)          // 5
  
  assert_eq(5, step4)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ é¢å¤–çš„æµ‹è¯•è¦†ç›–

test "add_function_negative_numbers" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-10, add(-5, -5))
  assert_eq(-2, add(-5, 3))
  assert_eq(2, add(-3, 5))
  assert_eq(0, add(-10, 10))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
}

test "greet_function_special_characters" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ã©spanol!", greet("Ã©spanol"))
  assert_eq_string("Hello, emoji ğŸ‰!", greet("emoji ğŸ‰"))
}

test "divide_with_ceil_mixed_operations" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„æ··åˆè¿ç®—
  let a = divide_with_ceil(10, 3)
  let b = divide_with_ceil(20, 7)
  let result = add(a, b)
  assert_eq(8, result)  // ceil(10/3) + ceil(20/7) = 4 + 4 = 8
}

test "complex_business_calculation" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_size = 8
  let tasks_per_person = 5
  let total_tasks = multiply(team_size, tasks_per_person)
  let tasks_per_sprint = 15
  let sprints_needed = divide_with_ceil(total_tasks, tasks_per_sprint)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
}

test "mathematical_distributive_property" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹
  let a = 6
  let b = 4
  let c = 3
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 6*(4+3) = 6*4 + 6*3 = 42
}

test "divide_with_ceil_large_numbers_extended" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å¤§æ•°æƒ…å†µ
  assert_eq(1000, divide_with_ceil(999999, 1000))
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
  assert_eq(2, divide_with_ceil(1000001, 1000000))
}

test "sequential_calculation_chain" {
  // æµ‹è¯•è¿ç»­è®¡ç®—é“¾
  let initial = 5
  let step1 = add(initial, multiply(2, 3))     // 5 + 2*3 = 11
  let step2 = divide_with_ceil(step1, 4)       // ceil(11/4) = 3
  let step3 = multiply(step2, add(1, 2))       // 3 * (1+2) = 9
  let step4 = divide_with_ceil(step3, 5)       // ceil(9/5) = 2
  assert_eq(2, step4)
}

test "greet_function_whitespace_handling" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç©ºç™½å­—ç¬¦å¤„ç†
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, leading space!", greet(" leading space"))
  assert_eq_string("Hello, trailing space !", greet("trailing space "))
  assert_eq_string("Hello, multiple   spaces!", greet("multiple   spaces"))
}

test "divide_with_ceil_negative_dividend" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿè¢«é™¤æ•°æƒ…å†µ
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-5, divide_with_ceil(-10, 2))
  assert_eq(-4, divide_with_ceil(-7, 2))
}

// æ–°æ·»åŠ çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "negative_divisor_scenarios" {
  // æµ‹è¯•è´Ÿé™¤æ•°çš„å„ç§åœºæ™¯
  assert_eq(-4, divide_with_ceil(10, -3))
  assert_eq(-3, divide_with_ceil(9, -3))
  assert_eq(-1, divide_with_ceil(1, -100))
  assert_eq(3, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(0, -5))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000, add(1000000, 1000000))
  assert_eq(1000000, multiply(1000, 1000))
  assert_eq(1001, divide_with_ceil(1000000, 999))
}

test "mathematical_boundary_conditions" {
  // æµ‹è¯•æ•°å­¦è¾¹ç•Œæ¡ä»¶
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 1000))
}

test "string_input_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾“å…¥çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 0!", greet("0"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
}

test "mathematical_associative_properties" {
  // æµ‹è¯•æ•°å­¦ç»“åˆå¾‹æ€§è´¨
  let a = 2
  let b = 3
  let c = 4
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯æµ‹è¯•
  let total_products = 157
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // éªŒè¯éœ€è¦çš„ç®±å­æ•°é‡
  assert_eq(7, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(168, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(11, remaining_space)
}

test "zero_multiplication_comprehensive" {
  // é›¶ä¹˜æ³•ç»¼åˆæµ‹è¯•
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, multiply(0, 1000000))
}

test "unicode_and_special_characters" {
  // Unicodeå’Œç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
}

test "precision_and_rounding" {
  // ç²¾åº¦å’Œèˆå…¥æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000000, divide_with_ceil(1999999, 2))
  assert_eq(666667, divide_with_ceil(2000000, 3))
  assert_eq(333334, divide_with_ceil(1000000, 3))
}

test "project_budget_calculation" {
  // é¡¹ç›®é¢„ç®—è®¡ç®—æµ‹è¯•
  let team_members = 8
  let hourly_rate = 50
  let hours_per_day = 8
  let project_days = 15
  
  // è®¡ç®—æ€»å·¥æ—¶
  let total_hours = multiply(team_members, multiply(hours_per_day, project_days))
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = multiply(total_hours, hourly_rate)
  
  // è®¡ç®—éœ€è¦çš„æ”¯ä»˜å‘¨æœŸï¼ˆæ¯å‘¨æœŸæ”¯ä»˜ä¸è¶…è¿‡10000ï¼‰
  let payment_cycle_limit = 10000
  let payment_cycles = divide_with_ceil(total_budget, payment_cycle_limit)
  
  // éªŒè¯ç»“æœ
  assert_eq(960, total_hours)  // 8 * 8 * 15 = 960
  assert_eq(48000, total_budget)  // 960 * 50 = 48000
  assert_eq(5, payment_cycles)  // ceil(48000/10000) = 5
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// Azimuth å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢8ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "extreme_boundary_values" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæƒ…å†µ
  assert_eq(2147483646, add(2147483645, 1))  // æ¥è¿‘ Int æœ€å¤§å€¼
  assert_eq(-2147483647, add(-2147483646, -1))  // æ¥è¿‘ Int æœ€å°å€¼
  assert_eq(1, divide_with_ceil(2147483646, 2147483646))
  assert_eq(1000000, multiply(1000, 1000))  // å¤§æ•°ä½†å®‰å…¨èŒƒå›´å†…
}

test "financial_calculation_scenario" {
  // é‡‘èè®¡ç®—åœºæ™¯ï¼šè´·æ¬¾åˆ†æœŸè®¡ç®—
  let loan_amount = 100000
  let monthly_payment = 3500
  let months_needed = divide_with_ceil(loan_amount, monthly_payment)
  assert_eq(29, months_needed)  // ceil(100000/3500) = 29
  
  // éªŒè¯æ€»æ”¯ä»˜é‡‘é¢
  let total_payment = multiply(months_needed, monthly_payment)
  assert_eq(101500, total_payment)
  
  // éªŒè¯æœ€åä¸€ä¸ªæœˆçš„å®é™…æ”¯ä»˜é‡‘é¢
  let final_payment = subtract(total_payment, multiply(months_needed - 1, monthly_payment))
  assert_eq(1500, final_payment)
}

test "nested_function_composition" {
  // åµŒå¥—å‡½æ•°ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚çš„åµŒå¥—è®¡ç®—
  let result = divide_with_ceil(
    add(
      multiply(base_value, 3),
      multiply(base_value, 2)
    ),
    add(base_value, divide_with_ceil(base_value, 3))
  )
  
  // æ‰‹åŠ¨è®¡ç®—éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
}

test "error_resilience_scenarios" {
  // é”™è¯¯æ¢å¤åœºæ™¯æµ‹è¯•
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå°é™¤æ•°æƒ…å†µ
  assert_eq(1000000, divide_with_ceil(999999, 1))
  assert_eq(-999999, divide_with_ceil(-999999, 1))
}

test "data_processing_pipeline" {
  // æ•°æ®å¤„ç†æµæ°´çº¿æµ‹è¯•
  // æ¨¡æ‹Ÿæ‰¹é‡æ•°æ®å¤„ç†åœºæ™¯
  let data_batches = 150
  let batch_size = 12
  let processing_time_per_batch = 2
  
  // è®¡ç®—éœ€è¦çš„å¤„ç†è½®æ¬¡
  let processing_rounds = divide_with_ceil(data_batches, batch_size)
  assert_eq(13, processing_rounds)  // ceil(150/12) = 13
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_time = multiply(processing_rounds, processing_time_per_batch)
  assert_eq(26, total_time)
  
  // è®¡ç®—å®é™…å¤„ç†çš„æ•°æ®é‡
  let actual_processed = multiply(processing_rounds - 1, batch_size)
  let final_batch_size = subtract(data_batches, actual_processed)
  assert_eq(6, final_batch_size)  // æœ€åä¸€æ‰¹å¤„ç†6ä¸ª
}

test "string_formatting_edge_cases" {
  // å­—ç¬¦ä¸²æ ¼å¼åŒ–è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å„ç§ç‰¹æ®Šå­—ç¬¦ä¸²ç»„åˆ
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, 0x1234!", greet("0x1234"))
  assert_eq_string("Hello, true!", greet("true"))
  assert_eq_string("Hello, false!", greet("false"))
  assert_eq_string("Hello, []!", greet("[]"))
  assert_eq_string("Hello, {}!", greet("{}"))
}

test "algorithm_complexity_validation" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•è·¯å¾„çš„æ€§èƒ½ç‰¹å¾
  let input_size = 1000
  
  // çº¿æ€§ç®—æ³•æ¨¡æ‹Ÿ
  let linear_steps = multiply(input_size, 3)
  assert_eq(3000, linear_steps)
  
  // å¯¹æ•°ç®—æ³•æ¨¡æ‹Ÿï¼ˆä½¿ç”¨å‘ä¸Šå–æ•´é™¤æ³•æ¨¡æ‹Ÿï¼‰
  let log_steps = divide_with_ceil(input_size, 100)
  assert_eq(10, log_steps)
  
  // éªŒè¯ç®—æ³•æ•ˆç‡å·®å¼‚
  let efficiency_ratio = divide_with_ceil(linear_steps, log_steps)
  assert_eq(300, efficiency_ratio)
}

test "resource_optimization_problem" {
  // èµ„æºä¼˜åŒ–é—®é¢˜æµ‹è¯•
  // åœºæ™¯ï¼šä»“åº“å­˜å‚¨ä¼˜åŒ–
  let items = [
    (25, 8),   // (æ•°é‡, æ¯ç®±å®¹é‡)
    (47, 12),
    (156, 20),
    (89, 15)
  ]
  
  // è®¡ç®—æ¯ç§ç‰©å“éœ€è¦çš„ç®±å­æ•°é‡
  let boxes_1 = divide_with_ceil(items[0].0, items[0].1)  // ceil(25/8) = 4
  let boxes_2 = divide_with_ceil(items[1].0, items[1].1)  // ceil(47/12) = 4
  let boxes_3 = divide_with_ceil(items[2].0, items[2].1)  // ceil(156/20) = 8
  let boxes_4 = divide_with_ceil(items[3].0, items[3].1)  // ceil(89/15) = 6
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let capacity_1 = multiply(boxes_1, items[0].1)  // 4 * 8 = 32
  let capacity_2 = multiply(boxes_2, items[1].1)  // 4 * 12 = 48
  let capacity_3 = multiply(boxes_3, items[2].1)  // 8 * 20 = 160
  let capacity_4 = multiply(boxes_4, items[3].1)  // 6 * 15 = 90
  
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„8ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "performance_large_scale_operations" {
  // å¤§è§„æ¨¡è¿ç®—æ€§èƒ½æµ‹è¯•
  let iterations = 10000
  let sum_result = add(iterations, iterations)
  let product_result = multiply(100, iterations)
  let division_result = divide_with_ceil(product_result, 50)
  
  assert_eq(20000, sum_result)
  assert_eq(1000000, product_result)
  assert_eq(20000, division_result)
}

test "error_boundary_conditions" {
  // é”™è¯¯è¾¹ç•Œæ¡ä»¶æµ‹è¯•
  // æµ‹è¯•å„ç§å¯èƒ½å¯¼è‡´é”™è¯¯çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))  // 0/0
  assert_eq(0, divide_with_ceil(1, 0))  // æ­£æ•°/0
  assert_eq(0, divide_with_ceil(-1, 0))  // è´Ÿæ•°/0
  assert_eq(0, divide_with_ceil(2147483647, 0))  // æœ€å¤§å€¼/0
  assert_eq(0, divide_with_ceil(-2147483648, 0))  // æœ€å°å€¼/0
}

test "string_encoding_handling" {
  // å­—ç¬¦ä¸²ç¼–ç å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  assert_eq_string("Hello, \"quotes\"!", greet("\"quotes\""))
  assert_eq_string("Hello, 'apostrophe'!", greet("'apostrophe'"))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
}

test "complex_financial_calculations" {
  // å¤æ‚é‡‘èè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—å¤åˆ©å’Œåˆ†æœŸä»˜æ¬¾
  let principal = 10000
  let annual_rate = 5  // 5%
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let year1_end = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let year2_end = add(year1_end, divide_with_ceil(multiply(year1_end, annual_rate), 100))
  let year3_end = add(year2_end, divide_with_ceil(multiply(year2_end, annual_rate), 100))
  
  // éªŒè¯å¤åˆ©å¢é•¿
  assert_eq(10500, year1_end)  // 10000 + 5%
  assert_eq(11025, year2_end)  // 10500 + 5%
  assert_eq(11576, year3_end)  // 11025 + 5%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(year3_end, total_months)
  assert_eq(322, monthly_payment)  // ceil(11576/36)
}

test "algorithm_complexity_analysis" {
  // ç®—æ³•å¤æ‚åº¦åˆ†ææµ‹è¯•
  let input_sizes = [10, 100, 1000]
  
  // æ¨¡æ‹ŸO(n)ç®—æ³•
  let linear_10 = multiply(input_sizes[0], 2)
  let linear_100 = multiply(input_sizes[1], 2)
  let linear_1000 = multiply(input_sizes[2], 2)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•ï¼ˆç®€åŒ–ä¸ºé™¤æ³•ï¼‰
  let log_10 = divide_with_ceil(input_sizes[0], 3)
  let log_100 = divide_with_ceil(input_sizes[1], 3)
  let log_1000 = divide_with_ceil(input_sizes[2], 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(20, linear_10)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  
  assert_eq(4, log_10)
  assert_eq(34, log_100)
  assert_eq(334, log_1000)
}

test "data_structure_operations" {
  // æ•°æ®ç»“æ„æ“ä½œæµ‹è¯•
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let stack_size_after_push = add(stack_size, 1)
  let stack_size_after_pop = subtract(stack_size_after_push, 1)
  
  assert_eq(1, stack_size_after_push)
  assert_eq(0, stack_size_after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 10
  let queue_items = 7
  let remaining_capacity = subtract(queue_capacity, queue_items)
  let can_add_more = remaining_capacity > 0
  
  assert_eq(3, remaining_capacity)
  assert_true(can_add_more)
}

test "resource_utilization_optimization" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨èµ„æºåˆ†é…
  let total_memory = 16384  // GB
  let servers = 5
  let memory_per_server = divide_with_ceil(total_memory, servers)
  
  assert_eq(3277, memory_per_server)  // ceil(16384/5)
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»å†…å­˜
  let total_allocated = multiply(memory_per_server, servers)
  let memory_waste = subtract(total_allocated, total_memory)
  
  assert_eq(16385, total_allocated)
  assert_eq(1, memory_waste)
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥
  let optimized_servers = add(servers, 1)
  let optimized_memory_per_server = divide_with_ceil(total_memory, optimized_servers)
  assert_eq(2341, optimized_memory_per_server)  // ceil(16384/6)
}

test "edge_case_mathematical_operations" {
  // è¾¹ç¼˜æƒ…å†µæ•°å­¦è¿ç®—æµ‹è¯•
  // æµ‹è¯•è¿ç»­è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  let initial_value = 1
  
  // è¿ç»­åŠ æ³•
  let result1 = add(add(add(initial_value, 1), 1), 1)
  assert_eq(4, result1)
  
  // è¿ç»­ä¹˜æ³•
  let result2 = multiply(multiply(multiply(initial_value, 2), 2), 2)
  assert_eq(8, result2)
  
  // æ··åˆè¿ç®—
  let result3 = divide_with_ceil(multiply(add(initial_value, 2), 3), 4)
  assert_eq(3, result3)  // ceil((1+2)*3/4) = ceil(9/4) = 3
  
  // æå€¼è¿ç®—
  let max_int_test = add(2147483647, 0)
  let min_int_test = add(-2147483648, 0)
  
  assert_eq(2147483647, max_int_test)
  assert_eq(-2147483648, min_int_test)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive_test" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_negative_test" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_unicode_test" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„Unicodeå­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_test" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline_test" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_test" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_test" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_boundary_test" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_test" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_scenario_test" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}

// æ–°å¢çš„10ä¸ªæ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_basic_functionality" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-1, add(2, -3))
}

test "multiply_basic_functionality" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(5, 0))
  assert_eq(-6, multiply(2, -3))
}

test "greet_basic_functionality" {
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_basic" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "add_identity_properties" {
  assert_eq(7, add(7, 0))
  assert_eq(7, add(0, 7))
}

test "multiply_zero_properties" {
  assert_eq(0, multiply(7, 0))
  assert_eq(0, multiply(0, 7))
}

test "divide_with_ceil_negative_numbers" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(3, divide_with_ceil(-10, -3))
}

test "complex_calculation" {
  let result = add(multiply(3, 4), divide_with_ceil(10, 4))
  assert_eq(15, result)  // 12 + 3 = 15
}

test "greet_unicode_characters" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "mathematical_commutativity" {
  assert_eq(add(5, 7), add(7, 5))
  assert_eq(multiply(5, 7), multiply(7, 5))
}

// æ ‡å‡† MoonBit å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - æ–°å¢10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_commutative_law" {
  // éªŒè¯åŠ æ³•äº¤æ¢å¾‹
  assert_eq(15, add(8, 7))
  assert_eq(15, add(7, 8))
  assert_eq(0, add(-5, 5))
  assert_eq(0, add(5, -5))
  assert_eq(-10, add(-3, -7))
  assert_eq(-10, add(-7, -3))
}

test "multiply_function_distributive_law" {
  // éªŒè¯ä¹˜æ³•åˆ†é…å¾‹: a * (b + c) = a * b + a * c
  let a = 6
  let b = 4
  let c = 2
  
  let left_result = multiply(a, add(b, c))
  let right_result = add(multiply(a, b), multiply(a, c))
  assert_eq(left_result, right_result)  // 6 * (4 + 2) = 6 * 4 + 6 * 2 = 36
  
  // å¦ä¸€ä¸ªä¾‹å­
  assert_eq(20, multiply(4, add(2, 3)))  // 4 * (2 + 3) = 20
  assert_eq(20, add(multiply(4, 2), multiply(4, 3)))  // 4 * 2 + 4 * 3 = 20
}

test "divide_with_ceil_real_world_scenarios" {
  // çœŸå®ä¸–ç•Œåœºæ™¯ï¼šè®¡ç®—è£…ç›’é—®é¢˜
  let total_items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(total_items, box_capacity)
  assert_eq(4, boxes_needed)  // ceil(47/12) = 4
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(48, total_capacity)
  
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†
  let packages = 25
  let capacity_per_truck = 8
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(4, trucks_needed)  // ceil(25/8) = 4
}

test "greet_function_special_characters" {
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeæ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ğŸŒ™â­!", greet("ğŸŒ™â­"))
}

test "complex_calculation_pipeline" {
  // å¤æ‚è®¡ç®—æµæ°´çº¿ï¼šé¡¹ç›®èµ„æºè§„åˆ’
  let team_size = 8
  let tasks_per_person = 5
  let sprint_capacity = 15
  
  // è®¡ç®—æ€»ä»»åŠ¡æ•°
  let total_tasks = multiply(team_size, tasks_per_person)
  assert_eq(40, total_tasks)
  
  // è®¡ç®—éœ€è¦çš„å†²åˆºæ•°
  let sprints_needed = divide_with_ceil(total_tasks, sprint_capacity)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(sprints_needed, sprint_capacity)
  assert_eq(45, total_capacity)
}

test "mathematical_identity_properties" {
  // æ•°å­¦æ’ç­‰å¼éªŒè¯
  let x = 42
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  assert_eq(0, multiply(0, x))
  
  // è´Ÿæ•°æ’ç­‰å¼
  assert_eq(multiply(x, -1), multiply(-1, x))
}

test "divide_with_ceil_edge_cases" {
  // å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç¼˜æƒ…å†µ
  // é›¶å€¼æµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(0, divide_with_ceil(0, -5))
  
  // è´Ÿæ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(-7, 4))
  assert_eq(-1, divide_with_ceil(-3, 4))
  assert_eq(-1, divide_with_ceil(-1, 4))
  
  // è´Ÿé™¤æ•°æµ‹è¯•
  assert_eq(-2, divide_with_ceil(7, -4))
  assert_eq(-1, divide_with_ceil(3, -4))
  assert_eq(0, divide_with_ceil(1, -4))
  
  // åŒè´Ÿæ•°æµ‹è¯•
  assert_eq(2, divide_with_ceil(-7, -4))
  assert_eq(1, divide_with_ceil(-3, -4))
  assert_eq(1, divide_with_ceil(-1, -4))
}

test "business_logic_inventory_management" {
  // åº“å­˜ç®¡ç†ä¸šåŠ¡é€»è¾‘ - ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸ä½¿ç”¨æ•°ç»„
  // äº§å“1: 25ä¸ªç‰©å“ï¼Œæ¯ç®±8ä¸ª
  let boxes_1 = divide_with_ceil(25, 8)  // ceil(25/8) = 4
  let capacity_1 = multiply(boxes_1, 8)  // 4 * 8 = 32
  
  // äº§å“2: 47ä¸ªç‰©å“ï¼Œæ¯ç®±12ä¸ª
  let boxes_2 = divide_with_ceil(47, 12)  // ceil(47/12) = 4
  let capacity_2 = multiply(boxes_2, 12)  // 4 * 12 = 48
  
  // äº§å“3: 156ä¸ªç‰©å“ï¼Œæ¯ç®±20ä¸ª
  let boxes_3 = divide_with_ceil(156, 20)  // ceil(156/20) = 8
  let capacity_3 = multiply(boxes_3, 20)  // 8 * 20 = 160
  
  // äº§å“4: 89ä¸ªç‰©å“ï¼Œæ¯ç®±15ä¸ª
  let boxes_4 = divide_with_ceil(89, 15)  // ceil(89/15) = 6
  let capacity_4 = multiply(boxes_4, 15)  // 6 * 15 = 90
  
  // è®¡ç®—æ€»ç®±å­æ•°
  let total_boxes = add(add(boxes_1, boxes_2), add(boxes_3, boxes_4))
  assert_eq(22, total_boxes)
  
  // è®¡ç®—æ€»å­˜å‚¨å®¹é‡
  let total_capacity = add(add(capacity_1, capacity_2), add(capacity_3, capacity_4))
  assert_eq(330, total_capacity)
}

test "large_number_operations" {
  // å¤§æ•°è¿ç®—æµ‹è¯• - ä½¿ç”¨è¾ƒå°çš„å¤§æ•°ä»¥é¿å…æº¢å‡º
  let large_num = 10000
  
  // å¤§æ•°åŠ æ³•
  assert_eq(20000, add(large_num, large_num))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(100000000, multiply(large_num, large_num))
  
  // å¤§æ•°é™¤æ³•
  assert_eq(1, divide_with_ceil(large_num, large_num))
  assert_eq(2, divide_with_ceil(add(large_num, 1), large_num))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(10, divide_with_ceil(99, 10))
  assert_eq(11, divide_with_ceil(101, 10))
}

test "nested_calculations_composition" {
  // åµŒå¥—è®¡ç®—ç»„åˆæµ‹è¯•
  let base_value = 10
  
  // å¤æ‚åµŒå¥—è®¡ç®—ï¼š(base * 3 + base * 2) / (base + ceil(base/3))
  let numerator = add(multiply(base_value, 3), multiply(base_value, 2))
  let denominator = add(base_value, divide_with_ceil(base_value, 3))
  let result = divide_with_ceil(numerator, denominator)
  
  // æ‰‹åŠ¨éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/3)) = 50 / 14 = ceil(3.57) = 4
  assert_eq(4, result)
  
  // å¦ä¸€ä¸ªåµŒå¥—è®¡ç®—ç¤ºä¾‹
  let complex_result = divide_with_ceil(
    multiply(add(5, 3), 4),
    subtract(10, 2)
  )
  assert_eq(4, complex_result)  // ceil((5+3)*4 / (10-2)) = ceil(32/8) = 4
}

// æ–°å¢çš„8ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "subtract_operation_simulation" {
  // æ¨¡æ‹Ÿå‡æ³•æ“ä½œï¼ša - b = a + (-b)
  let a = 15
  let b = 7
  let negative_b = multiply(b, -1)
  let result = add(a, negative_b)
  assert_eq(8, result)
}

test "percentage_calculation" {
  // ç™¾åˆ†æ¯”è®¡ç®—æµ‹è¯•
  let total = 200
  let percentage = 25  // 25%
  let result = divide_with_ceil(multiply(total, percentage), 100)
  assert_eq(50, result)
}

test "batch_processing_efficiency" {
  // æ‰¹å¤„ç†æ•ˆç‡æµ‹è¯•
  let total_items = 157
  let batch_size = 20
  let full_batches = divide_with_ceil(total_items, batch_size)
  assert_eq(8, full_batches)  // ceil(157/20) = 8
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(full_batches, batch_size)
  assert_eq(160, total_capacity)
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let unused_capacity = subtract(total_capacity, total_items)
  assert_eq(3, unused_capacity)
}

test "string_concatenation_length" {
  // å­—ç¬¦ä¸²è¿æ¥é•¿åº¦æµ‹è¯•
  let name = "MoonBit"
  let greeting = greet(name)
  let expected_length = add(add(7, 6), 1)  // "Hello, " + "MoonBit" + "!" = 7 + 6 + 1 = 14
  assert_eq(14, expected_length)
  @unused(greeting)
}

test "division_precision_test" {
  // é™¤æ³•ç²¾åº¦æµ‹è¯•
  // æµ‹è¯•è¿ç»­é™¤æ³•çš„ç²¾åº¦ä¿æŒ
  let initial_value = 1000
  let divisor1 = 3
  let divisor2 = 7
  let divisor3 = 11
  
  let step1 = divide_with_ceil(initial_value, divisor1)
  let step2 = divide_with_ceil(step1, divisor2)
  let step3 = divide_with_ceil(step2, divisor3)
  
  // éªŒè¯æ¯ä¸€æ­¥çš„ç»“æœ
  assert_eq(334, step1)   // ceil(1000/3)
  assert_eq(48, step2)    // ceil(334/7)
  assert_eq(5, step3)     // ceil(48/11)
}

test "resource_allocation_fairness" {
  // èµ„æºåˆ†é…å…¬å¹³æ€§æµ‹è¯•
  let total_resources = 100
  let participants = 9
  
  // è®¡ç®—æ¯äººåº”å¾—ä»½é¢
  let base_share = divide_with_ceil(total_resources, participants)
  assert_eq(12, base_share)  // ceil(100/9) = 12
  
  // è®¡ç®—æ€»åˆ†é…é‡
  let total_allocated = multiply(base_share, participants)
  assert_eq(108, total_allocated)
  
  // è®¡ç®—æº¢å‡ºé‡
  let overflow = subtract(total_allocated, total_resources)
  assert_eq(8, overflow)
}

test "time_calculation_scenario" {
  // æ—¶é—´è®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let total_tasks = 87
  let team_velocity = 12  // æ¯å‘¨å®Œæˆçš„ä»»åŠ¡æ•°
  
  // è®¡ç®—éœ€è¦çš„å‘¨æ•°
  let weeks_needed = divide_with_ceil(total_tasks, team_velocity)
  assert_eq(8, weeks_needed)  // ceil(87/12) = 8
  
  // è®¡ç®—æ€»å·¥ä½œæ—¥ï¼ˆå‡è®¾æ¯å‘¨5ä¸ªå·¥ä½œæ—¥ï¼‰
  let work_days = multiply(weeks_needed, 5)
  assert_eq(40, work_days)
  
  // è®¡ç®—æ€»å®¹é‡
  let total_capacity = multiply(weeks_needed, team_velocity)
  assert_eq(96, total_capacity)
}

test "exponential_growth_simulation" {
  // æŒ‡æ•°å¢é•¿æ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹Ÿç®€å•çš„æŒ‡æ•°å¢é•¿ï¼šæ¯æ¬¡ç¿»å€
  let initial_value = 3
  let growth_periods = 5  // è¿™ä¸ªå˜é‡åªæ˜¯ç”¨äºæ¼”ç¤ºï¼Œå®é™…æœªä½¿ç”¨
  
  // æ‰‹åŠ¨è®¡ç®—æŒ‡æ•°å¢é•¿
  let period1 = multiply(initial_value, 2)
  let period2 = multiply(period1, 2)
  let period3 = multiply(period2, 2)
  let period4 = multiply(period3, 2)
  let period5 = multiply(period4, 2)
  
  assert_eq(6, period1)    // 3 * 2
  assert_eq(12, period2)   // 6 * 2
  assert_eq(24, period3)   // 12 * 2
  assert_eq(48, period4)   // 24 * 2
  assert_eq(96, period5)   // 48 * 2
  
  // éªŒè¯æœ€ç»ˆç»“æœ
  assert_eq(96, period5)
  @unused(growth_periods)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "azimuth_enhanced_basic_addition" {
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "azimuth_enhanced_multiplication_edge_cases" {
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "azimuth_enhanced_greeting_international" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "azimuth_enhanced_divide_with_ceil_business_logic" {
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "azimuth_enhanced_complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "azimuth_enhanced_mathematical_properties" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "azimuth_enhanced_resource_allocation" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "azimuth_enhanced_error_handling" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "azimuth_enhanced_string_processing" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "azimuth_enhanced_real_world_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}


