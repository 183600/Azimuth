// Azimuth å¢žå¼ºå•å…ƒæµ‹è¯• - 10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•

// æµ‹è¯• 1: å¤§æ•°è¿ç®—å’Œè¾¹ç•Œå€¼å¤„ç†
test "large_number_boundary_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  let large_num = 1000000
  let another_large = 999999
  
  // å¤§æ•°åŠ æ³•
  assert_eq(1999999, add(large_num, another_large))
  
  // å¤§æ•°ä¹˜æ³•ï¼ˆåœ¨åˆç†èŒƒå›´å†…ï¼‰
  assert_eq(1000000000000, multiply(1000000, 1000000))
  
  // å¤§æ•°é™¤æ³•çš„å‘ä¸Šå–æ•´
  assert_eq(2, divide_with_ceil(large_num, another_large))
  assert_eq(1000000, divide_with_ceil(large_num, 1))
  assert_eq(1, divide_with_ceil(large_num, large_num))
}

// æµ‹è¯• 2: å¤æ‚åº“å­˜ç®¡ç†ä¸šåŠ¡é€»è¾‘
test "inventory_management_complex_logic" {
  // åœºæ™¯ï¼šå¤šäº§å“åº“å­˜ä¼˜åŒ–
  // äº§å“Aï¼š125ä»¶ï¼Œæ¯ç®±è£…15ä»¶
  let product_a_qty = 125
  let product_a_capacity = 15
  let boxes_a = divide_with_ceil(product_a_qty, product_a_capacity)
  
  // äº§å“Bï¼š87ä»¶ï¼Œæ¯ç®±è£…12ä»¶  
  let product_b_qty = 87
  let product_b_capacity = 12
  let boxes_b = divide_with_ceil(product_b_qty, product_b_capacity)
  
  // äº§å“Cï¼š234ä»¶ï¼Œæ¯ç®±è£…25ä»¶
  let product_c_qty = 234
  let product_c_capacity = 25
  let boxes_c = divide_with_ceil(product_c_qty, product_c_capacity)
  
  // è®¡ç®—æ€»ç®±æ•°å’Œæ€»å®¹é‡
  let total_boxes = add(add(boxes_a, boxes_b), boxes_c)
  let total_capacity = add(
    multiply(boxes_a, product_a_capacity),
    add(multiply(boxes_b, product_b_capacity), multiply(boxes_c, product_c_capacity))
  )
  
  // éªŒè¯ç»“æžœ
  assert_eq(9, boxes_a)    // ceil(125/15) = 9
  assert_eq(8, boxes_b)    // ceil(87/12) = 8
  assert_eq(10, boxes_c)   // ceil(234/25) = 10
  assert_eq(27, total_boxes)
  assert_eq(405, total_capacity)
  
  // è®¡ç®—ç©ºé—´åˆ©ç”¨çŽ‡
  let total_items = add(add(product_a_qty, product_b_qty), product_c_qty)
  let utilization = divide_with_ceil(multiply(total_items, 100), total_capacity)
  assert_eq(88, utilization)  // çº¦88%çš„ç©ºé—´åˆ©ç”¨çŽ‡
}

// æµ‹è¯• 3: å­—ç¬¦ä¸²å¤„ç†å’Œå›½é™…åŒ–æ”¯æŒ
test "string_processing_internationalization" {
  // æµ‹è¯•å„ç§å›½é™…åŒ–å­—ç¬¦ä¸²
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ÐœÐ¾ÑÐºÐ¾Ð²!", greet("ÐœÐ¾ÑÐºÐ¾Ð²"))
  assert_eq_string("Hello, MÃ¼nchen!", greet("MÃ¼nchen"))
  assert_eq_string("Hello, SÃ£o Paulo!", greet("SÃ£o Paulo"))
  assert_eq_string("Hello, åŒ—äº¬å¸‚!", greet("åŒ—äº¬å¸‚"))
  assert_eq_string("Hello, ðŸŒðŸŒŽðŸŒ!", greet("ðŸŒðŸŒŽðŸŒ"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å’Œç¬¦å·
  assert_eq_string("Hello, Math: âˆ‘âˆâˆ«!", greet("Math: âˆ‘âˆâˆ«"))
  assert_eq_string("Hello, Currency: $â‚¬Â£Â¥!", greet("Currency: $â‚¬Â£Â¥"))
  assert_eq_string("Hello, Symbols: Â©Â®â„¢!", greet("Symbols: Â©Â®â„¢"))
}

// æµ‹è¯• 4: ç®—æ³•å¤æ‚åº¦åˆ†æžå’Œæ€§èƒ½æµ‹è¯•
test "algorithm_complexity_analysis" {
  // æ¨¡æ‹Ÿä¸åŒç®—æ³•å¤æ‚åº¦çš„æ€§èƒ½ç‰¹å¾
  let input_sizes = 10
  let doubled_input = multiply(input_sizes, 2)
  let quadrupled_input = multiply(input_sizes, 4)
  
  // O(1) å¸¸æ•°æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let constant_time_10 = 5
  let constant_time_20 = 5
  let constant_time_40 = 5
  
  // O(n) çº¿æ€§æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let linear_time_10 = multiply(input_sizes, 3)
  let linear_time_20 = multiply(doubled_input, 3)
  let linear_time_40 = multiply(quadrupled_input, 3)
  
  // O(log n) å¯¹æ•°æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿï¼ˆç®€åŒ–ä¸ºé™¤æ³•è¿ç®—ï¼‰
  let log_time_10 = divide_with_ceil(input_sizes, 3)
  let log_time_20 = divide_with_ceil(doubled_input, 3)
  let log_time_40 = divide_with_ceil(quadrupled_input, 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time_10)
  assert_eq(5, constant_time_20)
  assert_eq(5, constant_time_40)
  
  assert_eq(30, linear_time_10)
  assert_eq(60, linear_time_20)
  assert_eq(120, linear_time_40)
  
  assert_eq(4, log_time_10)
  assert_eq(7, log_time_20)
  assert_eq(14, log_time_40)
  
  // éªŒè¯çº¿æ€§ç®—æ³•çš„å¢žé•¿æ¯”ä¾‹
  assert_eq(linear_time_20, multiply(linear_time_10, 2))
  assert_eq(linear_time_40, multiply(linear_time_10, 4))
}

// æµ‹è¯• 5: é”™è¯¯å¤„ç†å’Œå¼‚å¸¸è¾¹ç•Œæƒ…å†µ
test "error_handling_boundary_conditions" {
  // æµ‹è¯•å„ç§é™¤é›¶é”™è¯¯æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(1000000, 0))
  assert_eq(0, divide_with_ceil(-1000000, 0))
  
  // ï¿½æžå€¼è¿ç®—
  let max_positive = 2147483647
  let min_negative = -2147483648
  
  // æžå€¼åŠ æ³•ï¼ˆå®‰å…¨èŒƒå›´å†…ï¼‰
  assert_eq(2147483646, add(max_positive, -1))
  assert_eq(-2147483647, add(min_negative, 1))
  
  // æžå€¼ä¹˜æ³•ï¼ˆå°æ•°å€¼é¿å…æº¢å‡ºï¼‰
  assert_eq(2147483647, multiply(max_positive, 1))
  assert_eq(-2147483648, multiply(min_negative, 1))
  assert_eq(2147483647, multiply(max_positive, -1))
  
  // æžå€¼é™¤æ³•
  assert_eq(1, divide_with_ceil(max_positive, max_positive))
  assert_eq(1, divide_with_ceil(min_negative, min_negative))
  assert_eq(-1, divide_with_ceil(max_positive, min_negative))
}

// æµ‹è¯• 6: å‡½æ•°ç»„åˆå’Œç®¡é“æ“ä½œ
test "function_composition_pipeline" {
  // åˆ›å»ºä¸€ä¸ªå¤æ‚çš„è®¡ç®—ç®¡é“
  let initial_value = 12
  
  // ç®¡é“æ“ä½œï¼š((value * 3) + 10) / 5 + 2
  let step1 = multiply(initial_value, 3)        // 36
  let step2 = add(step1, 10)                     // 46
  let step3 = divide_with_ceil(step2, 5)         // 10
  let final_result = add(step3, 2)               // 12
  
  assert_eq(12, final_result)
  
  // å¦ä¸€ä¸ªå¤æ‚çš„ç®¡é“ï¼šèµ„æºåˆ†é…è®¡ç®—
  let total_resources = 100
  let teams = 3
  let base_allocation = divide_with_ceil(total_resources, teams)  // 34
  let bonus_pool = subtract(total_resources, multiply(base_allocation, teams))  // -2
  let adjusted_allocation = add(base_allocation, divide_with_ceil(bonus_pool, teams))  // 34
  
  assert_eq(34, adjusted_allocation)
}

// æµ‹è¯• 7: æ€§èƒ½åŸºå‡†æµ‹è¯•æ¨¡æ‹Ÿ
test "performance_benchmark_simulation" {
  // æ¨¡æ‹Ÿæ€§èƒ½åŸºå‡†æµ‹è¯•
  let small_dataset = 100
  let medium_dataset = 1000
  let large_dataset = 10000
  
  // æ¨¡æ‹Ÿä¸åŒæ•°æ®é›†çš„å¤„ç†æ—¶é—´ï¼ˆä»¥æ“ä½œæ•°ä¸ºå•ä½ï¼‰
  let small_ops = multiply(small_dataset, 5)
  let medium_ops = multiply(medium_dataset, 5)
  let large_ops = multiply(large_dataset, 5)
  
  // æ¨¡æ‹Ÿä¼˜åŒ–åŽçš„æ€§èƒ½
  let optimized_small = divide_with_ceil(small_ops, 2)
  let optimized_medium = divide_with_ceil(medium_ops, 2)
  let optimized_large = divide_with_ceil(large_ops, 2)
  
  // éªŒè¯æ€§èƒ½æå‡
  assert_eq(500, small_ops)
  assert_eq(5000, medium_ops)
  assert_eq(50000, large_ops)
  
  assert_eq(250, optimized_small)
  assert_eq(2500, optimized_medium)
  assert_eq(25000, optimized_large)
  
  // è®¡ç®—æ€§èƒ½æå‡æ¯”ä¾‹
  let improvement_small = divide_with_ceil(multiply(small_ops, 100), optimized_small)
  let improvement_medium = divide_with_ceil(multiply(medium_ops, 100), optimized_medium)
  let improvement_large = divide_with_ceil(multiply(large_ops, 100), optimized_large)
  
  assert_eq(200, improvement_small)   // 200% æ€§èƒ½æå‡
  assert_eq(200, improvement_medium)  // 200% æ€§èƒ½æå‡
  assert_eq(200, improvement_large)   // 200% æ€§èƒ½æå‡
}

// æµ‹è¯• 8: æ•°æ®ç»“æž„æ“ä½œæ¨¡æ‹Ÿ
test "data_structure_operations_simulation" {
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_initial_size = 0
  let push_operations = 5
  let pop_operations = 3
  
  let after_pushes = add(stack_initial_size, push_operations)
  let after_pops = subtract(after_pushes, pop_operations)
  
  assert_eq(5, after_pushes)
  assert_eq(2, after_pops)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 10
  let queue_enqueued = 7
  let queue_dequeued = 4
  
  let current_queue_size = subtract(queue_enqueued, queue_dequeued)
  let remaining_capacity = subtract(queue_capacity, current_queue_size)
  let is_queue_not_full = remaining_capacity > 0
  
  assert_eq(3, current_queue_size)
  assert_eq(7, remaining_capacity)
  assert_true(is_queue_not_full)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨è´Ÿè½½å› å­è®¡ç®—
  let hash_table_size = 16
  let occupied_slots = 12
  let load_factor = divide_with_ceil(multiply(occupied_slots, 100), hash_table_size)
  
  assert_eq(75, load_factor)  // 75% çš„è´Ÿè½½å› å­
}

// æµ‹è¯• 9: æœ¬åœ°åŒ–å’Œæ ¼å¼åŒ–åœºæ™¯
test "localization_formatting_scenarios" {
  // æµ‹è¯•ä¸åŒåœ°åŒºçš„æ•°å­—æ ¼å¼åŒ–æ¨¡æ‹Ÿ
  let number = 1234567
  
  // æ¨¡æ‹Ÿä¸åŒåœ°åŒºçš„åˆ†ç»„
  let western_grouping = divide_with_ceil(number, 1000)  // åƒä½åˆ†ç»„
  let indian_grouping = divide_with_ceil(number, 100000)  // åä¸‡ä½åˆ†ç»„
  
  assert_eq(1235, western_grouping)
  assert_eq(13, indian_grouping)
  
  // æµ‹è¯•è´§å¸è®¡ç®—ï¼ˆä¸åŒå¸ç§ï¼‰
  let usd_amount = 100
  let exchange_rate_eur = 0.85  // æ¨¡æ‹Ÿæ±‡çŽ‡
  let exchange_rate_gbp = 0.73  // æ¨¡æ‹Ÿæ±‡çŽ‡
  
  // ç®€åŒ–çš„è´§å¸è½¬æ¢ï¼ˆä½¿ç”¨æ•´æ•°è¿ç®—ï¼‰
  let eur_amount = divide_with_ceil(multiply(usd_amount, 85), 100)
  let gbp_amount = divide_with_ceil(multiply(usd_amount, 73), 100)
  
  assert_eq(85, eur_amount)
  assert_eq(73, gbp_amount)
  
  // æµ‹è¯•æ—¥æœŸè®¡ç®—æ¨¡æ‹Ÿ
  let days_in_month = 30
  let days_elapsed = 17
  let remaining_days = subtract(days_in_month, days_elapsed)
  let week_progress = divide_with_ceil(days_elapsed, 7)
  
  assert_eq(13, remaining_days)
  assert_eq(3, week_progress)  // ç¬¬3å‘¨
}

// æµ‹è¯• 10: çœŸå®žä¸–ç•Œå¤æ‚åº”ç”¨åœºæ™¯
test "real_world_complex_application" {
  // åœºæ™¯ï¼šé¡¹ç›®ç®¡ç†è½¯ä»¶çš„èµ„æºåˆ†é…å’Œè¿›åº¦è·Ÿè¸ª
  
  // é¡¹ç›®åŸºæœ¬ä¿¡æ¯
  let total_tasks = 87
  let team_members = 6
  let project_deadline_days = 15
  let working_hours_per_day = 8
  
  // è®¡ç®—å›¢é˜Ÿæ€»å·¥æ—¶
  let total_team_hours = multiply(team_members, multiply(working_hours_per_day, project_deadline_days))
  assert_eq(720, total_team_hours)  // 6 * 8 * 15 = 720
  
  // è®¡ç®—æ¯ä¸ªä»»åŠ¡çš„å¹³å‡æ—¶é—´
  let avg_hours_per_task = divide_with_ceil(total_team_hours, total_tasks)
  assert_eq(9, avg_hours_per_task)  // ceil(720/87) = 9
  
  // ä»»åŠ¡å¤æ‚åº¦åˆ†ç±»
  let simple_tasks = 35
  let complex_tasks = 32
  let expert_tasks = 20
  
  // ä¸åŒå¤æ‚åº¦ä»»åŠ¡çš„æ—¶é—´åˆ†é…
  let simple_task_hours = 6
  let complex_task_hours = 10
  let expert_task_hours = 15
  
  let total_simple_hours = multiply(simple_tasks, simple_task_hours)
  let total_complex_hours = multiply(complex_tasks, complex_task_hours)
  let total_expert_hours = multiply(expert_tasks, expert_task_hours)
  
  let estimated_total_hours = add(add(total_simple_hours, total_complex_hours), total_expert_hours)
  assert_eq(210, total_simple_hours)   // 35 * 6
  assert_eq(320, total_complex_hours)  // 32 * 10
  assert_eq(300, total_expert_hours)   // 20 * 15
  assert_eq(830, estimated_total_hours)
  
  // èµ„æºåˆ†é…ä¼˜åŒ–
  let overtime_needed = divide_with_ceil(estimated_total_hours, total_team_hours)
  assert_eq(2, overtime_needed)  // éœ€è¦åŠ ç­ï¼Œå› ä¸ºé¢„ä¼°830å°æ—¶ > å¯ç”¨720å°æ—¶
  
  // é£Žé™©è¯„ä¼°è®¡ç®—
  let risk_factor_simple = divide_with_ceil(multiply(simple_tasks, 10), total_tasks)
  let risk_factor_complex = divide_with_ceil(multiply(complex_tasks, 30), total_tasks)
  let risk_factor_expert = divide_with_ceil(multiply(expert_tasks, 60), total_tasks)
  
  let total_risk_score = add(add(risk_factor_simple, risk_factor_complex), risk_factor_expert)
  assert_eq(4, risk_factor_simple)   // ceil(35*10/87)
  assert_eq(11, risk_factor_complex) // ceil(32*30/87)
  assert_eq(14, risk_factor_expert)  // ceil(20*60/87)
  assert_eq(29, total_risk_score)    // æ€»é£Žé™©åˆ†æ•°
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•è¿ç®—
fn subtract(a : Int, b : Int) -> Int {
  a - b
}