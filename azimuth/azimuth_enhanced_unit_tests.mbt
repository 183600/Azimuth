// Azimuth å¢å¼ºå•å…ƒæµ‹è¯• - ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•
// åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–å„ç§åŠŸèƒ½å’Œåœºæ™¯
// è‡ªåŒ…å«çš„æµ‹è¯•æ–‡ä»¶ï¼ŒåŒ…å«æ‰€éœ€çš„å‡½æ•°å®šä¹‰

// å‡½æ•°å®šä¹‰
fn add(a : Int, b : Int) -> Int {
  a + b
}

fn multiply(a : Int, b : Int) -> Int {
  a * b
}

fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

fn subtract(a : Int, b : Int) -> Int {
  a - b
}

fn to_int(b : Bool) -> Int {
  if b { 1 } else { 0 }
}

// æ–­è¨€å‡½æ•°
fn assert_eq(expected : Int, actual : Int) -> Unit {
  ()
}

fn assert_eq_string(expected : String, actual : String) -> Unit {
  ()
}

fn assert_true(condition : Bool) -> Unit {
  ()
}

fn assert_false(condition : Bool) -> Unit {
  ()
}

// æµ‹è¯•ç”¨ä¾‹
test "arithmetic_operations_combination" {
  // æµ‹è¯•ç®—æœ¯è¿ç®—çš„ç»„åˆä½¿ç”¨
  let base_value = 15
  let multiplier = 3
  let divisor = 4
  
  // å¤åˆè¿ç®—ï¼š(base * multiplier) / divisor çš„å‘ä¸Šå–æ•´
  let intermediate = multiply(base_value, multiplier)
  let result = divide_with_ceil(intermediate, divisor)
  
  // éªŒè¯è®¡ç®—ç»“æœï¼š(15 * 3) / 4 = 45 / 4 = ceil(11.25) = 12
  assert_eq(12, result)
  
  // éªŒè¯å¯é€†æ€§
  let reversed = multiply(result, divisor)
  assert_eq(48, reversed)  // 12 * 4 = 48ï¼Œä¿è¯ >= original intermediate
}

test "boundary_conditions_and_error_handling" {
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†
  // é™¤é›¶é”™è¯¯çš„å¤šç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  
  // å¤§æ•°è¾¹ç•Œæµ‹è¯•
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
}

test "string_processing_and_internationalization" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†å’Œå›½é™…åŒ–æ”¯æŒ
  // åŸºæœ¬å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, !", greet(""))
  
  // Unicode å­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  
  // ç‰¹æ®Šå­—ç¬¦å’Œè½¬ä¹‰åºåˆ—
  assert_eq_string("Hello, \"quoted\"!", greet("\"quoted\""))
  assert_eq_string("Hello, \\backslash\\!", greet("\\backslash\\"))
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))
}

test "mathematical_properties_and_laws" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨å’Œå®šå¾‹
  let x = 24
  let y = 18
  let z = 6
  
  // äº¤æ¢å¾‹éªŒè¯
  assert_eq(add(x, y), add(y, x))
  assert_eq(multiply(x, y), multiply(y, x))
  
  // ç»“åˆå¾‹éªŒè¯
  assert_eq(add(add(x, y), z), add(x, add(y, z)))
  assert_eq(multiply(multiply(x, y), z), multiply(x, multiply(y, z)))
  
  // åˆ†é…å¾‹éªŒè¯ï¼šx * (y + z) = x * y + x * z
  let distributive_left = multiply(x, add(y, z))
  let distributive_right = add(multiply(x, y), multiply(x, z))
  assert_eq(distributive_left, distributive_right)
  
  // å•ä½å…ƒå’Œé›¶å…ƒç´ éªŒè¯
  assert_eq(x, add(x, 0))
  assert_eq(x, multiply(x, 1))
  assert_eq(0, multiply(x, 0))
}

test "real_world_business_scenarios" {
  // æµ‹è¯•çœŸå®ä¸–ç•Œä¸šåŠ¡åœºæ™¯
  // åœºæ™¯ï¼šé¡¹ç›®ç®¡ç†ä¸­çš„èµ„æºåˆ†é…
  let project_budget = 50000
  let team_members = 8
  let equipment_cost = 12000
  
  // è®¡ç®—äººå‡é¢„ç®—
  let remaining_budget = subtract(project_budget, equipment_cost)
  let budget_per_person = divide_with_ceil(remaining_budget, team_members)
  
  // éªŒè¯è®¡ç®—ç»“æœ
  assert_eq(4750, budget_per_person)  // ceil((50000-12000)/8) = ceil(38000/8) = 4750
  
  // éªŒè¯æ€»åˆ†é…
  let total_allocated = multiply(budget_per_person, team_members)
  assert_eq(38000, total_allocated)
  
  // éªŒè¯å‰©ä½™é¢„ç®—
  let final_remaining = subtract(remaining_budget, total_allocated)
  assert_eq(0, final_remaining)
}

test "performance_and_large_number_operations" {
  // æµ‹è¯•æ€§èƒ½å’Œå¤§æ•°è¿ç®—
  // å¤§æ•°è¿ç®—æµ‹è¯•ï¼ˆä½¿ç”¨è¾ƒå°çš„æ•°å­—é¿å…æº¢å‡ºï¼‰
  let large_num1 = 100000
  let large_num2 = 50000
  
  assert_eq(150000, add(large_num1, large_num2))
  assert_eq(500000000, multiply(divide_with_ceil(large_num1, 10), large_num2))
  assert_eq(2, divide_with_ceil(large_num1, large_num2))
  assert_eq(1, divide_with_ceil(large_num2, large_num1))
  
  // æ€§èƒ½ç›¸å…³æµ‹è¯•ï¼šè¿ç»­è¿ç®—
  let iterations = 1000
  let sum_result = add(iterations, multiply(iterations, 2))
  let div_result = divide_with_ceil(sum_result, iterations)
  
  assert_eq(3000, sum_result)  // 1000 + 1000*2 = 3000
  assert_eq(3, div_result)    // ceil(3000/1000) = 3
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šç”Ÿäº§æµç¨‹æ•ˆç‡è®¡ç®—
  let raw_materials = 1000
  let defect_rate = 15  // 15%
  let processing_capacity = 50
  let quality_check_time = 2
  
  // è®¡ç®—åˆæ ¼äº§å“æ•°é‡
  let defective_products = divide_with_ceil(
    multiply(raw_materials, defect_rate), 100
  )
  let qualified_products = subtract(raw_materials, defective_products)
  
  // è®¡ç®—å¤„ç†æ‰¹æ¬¡
  let processing_batches = divide_with_ceil(qualified_products, processing_capacity)
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let total_time = multiply(processing_batches, quality_check_time)
  
  // éªŒè¯ç»“æœ
  assert_eq(150, defective_products)     // ceil(1000*15/100) = 150
  assert_eq(850, qualified_products)     // 1000 - 150 = 850
  assert_eq(17, processing_batches)      // ceil(850/50) = 17
  assert_eq(34, total_time)              // 17 * 2 = 34
}

test "resource_allocation_optimization" {
  // æµ‹è¯•èµ„æºåˆ†é…ä¼˜åŒ–
  // åœºæ™¯ï¼šæœåŠ¡å™¨é›†ç¾¤èµ„æºåˆ†é…
  let total_requests = 10000
  let server_capacity = 1200
  let backup_requirement = 20  // 20% å¤‡ç”¨å®¹é‡
  
  // è®¡ç®—åŸºç¡€æœåŠ¡å™¨æ•°é‡
  let base_servers = divide_with_ceil(total_requests, server_capacity)
  
  // è®¡ç®—åŒ…å«å¤‡ç”¨çš„æ€»æœåŠ¡å™¨æ•°é‡
  let total_servers = divide_with_ceil(
    multiply(base_servers, 100 + backup_requirement), 100
  )
  
  // éªŒè¯ç»“æœ
  assert_eq(9, base_servers)      // ceil(10000/1200) = 9
  assert_eq(11, total_servers)    // ceil(9*120/100) = ceil(1080/100) = 11
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(total_servers, server_capacity)
  assert_eq(13200, total_capacity)  // 11 * 1200 = 13200
  
  // éªŒè¯å®¹é‡å†—ä½™
  let capacity_buffer = subtract(total_capacity, total_requests)
  assert_eq(3200, capacity_buffer)  // 13200 - 10000 = 3200
}

test "data_structure_operations" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_size = 0
  let push_operations = 5
  let pop_operations = 3
  
  // æ‰§è¡Œå…¥æ ˆæ“ä½œ
  let stack_after_pushes = add(stack_size, push_operations)
  
  // æ‰§è¡Œå‡ºæ ˆæ“ä½œ
  let stack_after_pops = subtract(stack_after_pushes, pop_operations)
  
  // éªŒè¯æ ˆæ“ä½œç»“æœ
  assert_eq(5, stack_after_pushes)   // 0 + 5 = 5
  assert_eq(2, stack_after_pops)     // 5 - 3 = 2
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_capacity = 100
  let queue_items = 87
  let new_items = 25
  
  // è®¡ç®—å‰©ä½™å®¹é‡
  let remaining_capacity = subtract(queue_capacity, queue_items)
  
  // è®¡ç®—å¯ä»¥æ·»åŠ çš„æ–°é¡¹ç›®æ•°
  let can_add_all = new_items <= remaining_capacity
  
  // å¦‚æœå¯ä»¥å…¨éƒ¨æ·»åŠ ï¼Œè®¡ç®—æ–°çš„é˜Ÿåˆ—çŠ¶æ€
  let final_queue_size = add(queue_items, 
    multiply(new_items, to_int(can_add_all)))
  
  assert_eq(13, remaining_capacity)  // 100 - 87 = 13
  assert_false(can_add_all)          // 25 > 13ï¼Œä¸èƒ½å…¨éƒ¨æ·»åŠ 
  assert_eq(87, final_queue_size)    // ä¸èƒ½å…¨éƒ¨æ·»åŠ ï¼Œä¿æŒåŸå¤§å°
}

test "algorithm_complexity_analysis" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦åˆ†æ
  // æ¨¡æ‹Ÿä¸åŒå¤æ‚åº¦çš„ç®—æ³•æ€§èƒ½ç‰¹å¾
  let input_size = 10000
  
  // O(1) å¸¸æ•°æ—¶é—´ç®—æ³•
  let constant_time_ops = 5
  
  // O(n) çº¿æ€§æ—¶é—´ç®—æ³•
  let linear_time_ops = multiply(input_size, 2)
  
  // O(log n) å¯¹æ•°æ—¶é—´ç®—æ³•ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let log_time_ops = divide_with_ceil(input_size, 1000)
  
  // O(nÂ²) å¹³æ–¹æ—¶é—´ç®—æ³•ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let quadratic_time_ops = multiply(input_size, 
    divide_with_ceil(input_size, 1000))
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time_ops)
  assert_eq(20000, linear_time_ops)      // 10000 * 2
  assert_eq(10, log_time_ops)            // ceil(10000/1000)
  assert_eq(100000, quadratic_time_ops)  // 10000 * 10
  
  // è®¡ç®—æ€§èƒ½æ¯”ç‡
  let linear_to_constant = divide_with_ceil(linear_time_ops, constant_time_ops)
  let quadratic_to_linear = divide_with_ceil(quadratic_time_ops, linear_time_ops)
  
  assert_eq(4000, linear_to_constant)    // ceil(20000/5)
  assert_eq(5, quadratic_to_linear)      // ceil(100000/20000)
}