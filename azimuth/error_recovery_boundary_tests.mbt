// é”™è¯¯æ¢å¤å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•ç³»ç»Ÿåœ¨å„ç§å¼‚å¸¸æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º

test "æ— æ•ˆè¾“å…¥å‚æ•°å¤„ç†æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.test")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²spanåç§°
  let empty_span = Tracer::start_span(tracer, "")
  assert_eq(Span::name(empty_span), "")
  Span::end(empty_span)
  
  // æµ‹è¯•æé•¿spanåç§°
  let very_long_name = "a" * 10000
  let long_span = Tracer::start_span(tracer, very_long_name)
  assert_eq(Span::name(long_span), very_long_name)
  Span::end(long_span)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„spanåç§°
  let special_chars_span = Tracer::start_span(tracer, "ç‰¹æ®Šå­—ç¬¦!@#$%^&*()_+-={}[]|\\:;\"'<>?,./")
  assert_true(Span::name(special_chars_span).length() > 0)
  Span::end(special_chars_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "SpanContextè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶çš„SpanContext
  let empty_trace_ctx = SpanContext::new("", "valid_span_id", true, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  assert_eq(SpanContext::trace_id(empty_trace_ctx), "")
  assert_eq(SpanContext::span_id(empty_trace_ctx), "valid_span_id")
  
  let empty_span_ctx = SpanContext::new("valid_trace_id", "", false, "")
  assert_false(SpanContext::is_valid(empty_span_ctx))
  assert_eq(SpanContext::trace_id(empty_span_ctx), "valid_trace_id")
  assert_eq(SpanContext::span_id(empty_span_ctx), "")
  
  let both_empty_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(both_empty_ctx))
  assert_false(SpanContext::is_sampled(both_empty_ctx))
  
  // æµ‹è¯•éƒ¨åˆ†æœ‰æ•ˆçš„trace_idå’Œspan_id
  let short_trace_ctx = SpanContext::new("short", "valid_span", true, "")
  assert_false(SpanContext::is_valid(short_trace_ctx)) // å¤ªçŸ­çš„trace_id
  
  let short_span_ctx = SpanContext::new("valid_trace_id_long_enough", "short", true, "")
  assert_false(SpanContext::is_valid(short_span_ctx)) // å¤ªçŸ­çš„span_id
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "å±æ€§æ“ä½œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºé”®å
  Attributes::set(attrs, "", StringValue("empty_key_value"))
  let empty_key_result = Attributes::get(attrs, "")
  // ç®€åŒ–å®ç°å¯èƒ½ä¸å¤„ç†ç©ºé”®ï¼Œä½†åº”è¯¥ä¸ä¼šå´©æºƒ
  
  // æµ‹è¯•æé•¿é”®å
  let long_key = "k" * 1000
  Attributes::set(attrs, long_key, StringValue("long_key_value"))
  let long_key_result = Attributes::get(attrs, long_key)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®å
  let special_key = "key!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  Attributes::set(attrs, special_key, StringValue("special_key_value"))
  let special_key_result = Attributes::get(attrs, special_key)
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  Attributes::set(attrs, "empty_value", StringValue(""))
  let empty_value_result = Attributes::get(attrs, "empty_value")
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²å€¼
  let long_value = "v" * 10000
  Attributes::set(attrs, "long_value", StringValue(long_value))
  let long_value_result = Attributes::get(attrs, "long_value")
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  Attributes::set(attrs, "unicode_key", StringValue("æµ‹è¯•ğŸš€emojiå’Œä¸­æ–‡æ··åˆ"))
  let unicode_result = Attributes::get(attrs, "unicode_key")
  
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œ
  Attributes::set(attrs, "max_int", IntValue(2147483647))
  Attributes::set(attrs, "min_int", IntValue(-2147483648))
  Attributes::set(attrs, "zero_int", IntValue(0))
  
  Attributes::set(attrs, "max_double", FloatValue(1.7976931348623157e+308))
  Attributes::set(attrs, "min_double", FloatValue(-1.7976931348623157e+308))
  Attributes::set(attrs, "inf_double", FloatValue(1.0/0.0))
  Attributes::set(attrs, "nan_double", FloatValue(0.0/0.0))
  Attributes::set(attrs, "zero_double", FloatValue(0.0))
  
  // æµ‹è¯•ç©ºæ•°ç»„
  Attributes::set(attrs, "empty_string_array", ArrayStringValue([]))
  Attributes::set(attrs, "empty_int_array", ArrayIntValue([]))
  
  // æµ‹è¯•å¤§æ•°ç»„
  let large_string_array = ArrayStringValue([])
  for i = 0; i < 1000; i = i + 1 {
    large_string_array.push("item_" + i.to_string())
  }
  Attributes::set(attrs, "large_string_array", large_string_array)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "æ—¥å¿—è®°å½•è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "boundary.test")
  
  // æµ‹è¯•ç©ºæ¶ˆæ¯ä½“
  let empty_body_record = LogRecord::new(Info, "")
  Logger::emit(logger, empty_body_record)
  
  // æµ‹è¯•æé•¿æ¶ˆæ¯ä½“
  let long_body = "m" * 50000
  let long_body_record = LogRecord::new(Error, long_body)
  Logger::emit(logger, long_body_record)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ¶ˆæ¯ä½“
  let special_body = "ç‰¹æ®Šå­—ç¬¦!@#$%^&*()_+-={}[]|\\:;\"'<>?,./\n\t\r"
  let special_body_record = LogRecord::new(Warn, special_body)
  Logger::emit(logger, special_body_record)
  
  // æµ‹è¯•æ‰€æœ‰ä¸¥é‡æ€§çº§åˆ«
  let trace_record = LogRecord::new(Trace, "Trace message")
  let debug_record = LogRecord::new(Debug, "Debug message")
  let info_record = LogRecord::new(Info, "Info message")
  let warn_record = LogRecord::new(Warn, "Warning message")
  let error_record = LogRecord::new(Error, "Error message")
  let fatal_record = LogRecord::new(Fatal, "Fatal message")
  
  Logger::emit(logger, trace_record)
  Logger::emit(logger, debug_record)
  Logger::emit(logger, info_record)
  Logger::emit(logger, warn_record)
  Logger::emit(logger, error_record)
  Logger::emit(logger, fatal_record)
  
  // æµ‹è¯•è¾¹ç•Œæ—¶é—´æˆ³
  let zero_timestamp_record = LogRecord::new_with_context(
    Info,
    Some("Zero timestamp"),
    None,
    Some(0L),
    Some(0L),
    None,
    None,
    None
  )
  Logger::emit(logger, zero_timestamp_record)
  
  let max_timestamp_record = LogRecord::new_with_context(
    Info,
    Some("Max timestamp"),
    None,
    Some(9223372036854775807L),
    Some(9223372036854775807L),
    None,
    None,
    None
  )
  Logger::emit(logger, max_timestamp_record)
  
  let negative_timestamp_record = LogRecord::new_with_context(
    Info,
    Some("Negative timestamp"),
    None,
    Some(-1L),
    Some(-1L),
    None,
    None,
    None
  )
  Logger::emit(logger, negative_timestamp_record)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "HTTPæ“ä½œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let client = HttpClient::new()
  
  // æµ‹è¯•ç©ºURL
  let empty_url_request = HttpRequest::new("GET", "", [])
  assert_eq(HttpRequest::url(empty_url_request), "")
  
  // æµ‹è¯•æé•¿URL
  let long_url = "https://example.com/" + "a" * 10000
  let long_url_request = HttpRequest::new("GET", long_url, [])
  assert_eq(HttpRequest::url(long_url_request), long_url)
  
  // æµ‹è¯•æ— æ•ˆURLæ ¼å¼
  let invalid_url_request = HttpRequest::new("GET", "not-a-valid-url", [])
  assert_eq(HttpRequest::url(invalid_url_request), "not-a-valid-url")
  
  // æµ‹è¯•ç©ºHTTPæ–¹æ³•
  let empty_method_request = HttpRequest::new("", "https://example.com", [])
  assert_eq(HttpRequest::http_method(empty_method_request), "")
  
  // æµ‹è¯•ä¸å¸¸è§çš„HTTPæ–¹æ³•
  let uncommon_methods = ["PATCH", "OPTIONS", "HEAD", "CONNECT", "TRACE", "CUSTOM"]
  for method in uncommon_methods {
    let request = HttpRequest::new(method, "https://example.com", [])
    assert_eq(HttpRequest::http_method(request), method)
  }
  
  // æµ‹è¯•æé•¿è¯·æ±‚ä½“
  let long_body = "b" * 100000
  let long_body_request = HttpRequest::new("POST", "https://example.com", [], Some(long_body))
  match HttpRequest::body(long_body_request) {
    Some(body) => assert_eq(body.length(), 100000)
    None => assert_true(false)
  }
  
  // æµ‹è¯•è¾¹ç•ŒçŠ¶æ€ç 
  let status_codes = [-1, 0, 99, 100, 199, 200, 299, 300, 399, 400, 499, 500, 599, 600, 999, 1000]
  for code in status_codes {
    let response = HttpResponse::new(code, [])
    assert_eq(HttpResponse::status_code(response), code)
  }
  
  // æµ‹è¯•æé•¿å“åº”ä½“
  let long_response_body = "r" * 200000
  let long_response = HttpResponse::new(200, [], Some(long_response_body))
  match HttpResponse::body(long_response) {
    Some(body) => assert_eq(body.length(), 200000)
    None => assert_true(false)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "Contextä¼ æ’­é”™è¯¯å¤„ç†æµ‹è¯•" {
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  
  // æµ‹è¯•ç©ºè½½ä½“
  let empty_carrier = TextMapCarrier::new()
  let ctx_from_empty = CompositePropagator::extract(propagator, empty_carrier)
  assert_true(true) // åº”è¯¥èƒ½å¤„ç†ç©ºè½½ä½“
  
  // æµ‹è¯•æŸåçš„traceparentæ ¼å¼
  let corrupted_carrier = TextMapCarrier::new()
  TextMapCarrier::set(corrupted_carrier, "traceparent", "invalid-format")
  let ctx_from_corrupted = CompositePropagator::extract(propagator, corrupted_carrier)
  assert_true(true) // åº”è¯¥èƒ½å¤„ç†æŸåæ ¼å¼
  
  // æµ‹è¯•éƒ¨åˆ†traceparentæ ¼å¼
  let partial_carrier = TextMapCarrier::new()
  TextMapCarrier::set(partial_carrier, "traceparent", "00-")
  let ctx_from_partial = CompositePropagator::extract(propagator, partial_carrier)
  assert_true(true) // åº”è¯¥èƒ½å¤„ç†éƒ¨åˆ†æ ¼å¼
  
  // æµ‹è¯•è¶…é•¿traceparent
  let long_traceparent = "00-" + "a" * 100 + "-" + "b" * 50 + "-01"
  let long_carrier = TextMapCarrier::new()
  TextMapCarrier::set(long_carrier, "traceparent", long_traceparent)
  let ctx_from_long = CompositePropagator::extract(propagator, long_carrier)
  assert_true(true) // åº”è¯¥èƒ½å¤„ç†è¶…é•¿æ ¼å¼
  
  // æµ‹è¯•å‘ç©ºcontextæ³¨å…¥
  let empty_ctx = Context::root()
  let injection_carrier = TextMapCarrier::new()
  CompositePropagator::inject(propagator, empty_ctx, injection_carrier)
  assert_true(true) // åº”è¯¥èƒ½å¤„ç†ç©ºcontext
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "Baggageæ“ä½œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let baggage = Baggage::new()
  
  // æµ‹è¯•ç©ºé”®å
  let baggage_with_empty_key = Baggage::set_entry(baggage, "", "empty_key_value")
  let empty_key_value = Baggage::get_entry(baggage_with_empty_key, "")
  // åº”è¯¥èƒ½å¤„ç†ç©ºé”®
  
  // æµ‹è¯•ç©ºå€¼
  let baggage_with_empty_value = Baggage::set_entry(baggage, "empty_value", "")
  let empty_value_result = Baggage::get_entry(baggage_with_empty_value, "empty_value")
  
  // æµ‹è¯•æé•¿é”®åå’Œå€¼
  let long_key = "k" * 1000
  let long_value = "v" * 1000
  let baggage_with_long = Baggage::set_entry(baggage, long_key, long_value)
  let long_key_result = Baggage::get_entry(baggage_with_long, long_key)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®åå’Œå€¼
  let special_key = "key!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let special_value = "value!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"
  let baggage_with_special = Baggage::set_entry(baggage, special_key, special_value)
  let special_result = Baggage::get_entry(baggage_with_special, special_key)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_key = "é”®åğŸš€"
  let unicode_value = "å€¼ğŸŒŸ"
  let baggage_with_unicode = Baggage::set_entry(baggage, unicode_key, unicode_value)
  let unicode_result = Baggage::get_entry(baggage_with_unicode, unicode_key)
  
  // æµ‹è¯•åˆ é™¤ä¸å­˜åœ¨çš„æ¡ç›®
  let baggage_after_remove = Baggage::remove_entry(baggage, "nonexistent.key")
  let nonexistent_result = Baggage::get_entry(baggage_after_remove, "nonexistent.key")
  assert_true(nonexistent_result is None)
  
  // æµ‹è¯•ä»ç©ºbaggageåˆ é™¤æ¡ç›®
  let empty_baggage = Baggage::new()
  let empty_after_remove = Baggage::remove_entry(empty_baggage, "any.key")
  let result_from_empty = Baggage::get_entry(empty_after_remove, "any.key")
  assert_true(result_from_empty is None)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "Resourceæ“ä½œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let resource = Resource::new()
  
  // æµ‹è¯•ç©ºå±æ€§å
  let attrs_with_empty_key = [("", StringValue("empty_key_value"))]
  let resource_with_empty_key = Resource::with_attributes(resource, attrs_with_empty_key)
  let empty_key_attr = Resource::get_attribute(resource_with_empty_key, "")
  
  // æµ‹è¯•æé•¿å±æ€§å
  let long_key = "k" * 1000
  let attrs_with_long_key = [(long_key, StringValue("long_key_value"))]
  let resource_with_long_key = Resource::with_attributes(resource, attrs_with_long_key)
  let long_key_attr = Resource::get_attribute(resource_with_long_key, long_key)
  
  // æµ‹è¯•ç©ºå±æ€§å€¼
  let attrs_with_empty_value = [("empty_value", StringValue(""))]
  let resource_with_empty_value = Resource::with_attributes(resource, attrs_with_empty_value)
  let empty_value_attr = Resource::get_attribute(resource_with_empty_value, "empty_value")
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = []
  for i = 0; i < 1000; i = i + 1 {
    many_attrs.push(("attr_" + i.to_string(), StringValue("value_" + i.to_string())))
  }
  let resource_with_many_attrs = Resource::with_attributes(resource, many_attrs)
  
  // éªŒè¯èƒ½è·å–åˆ°ä¸€äº›å±æ€§
  let first_attr = Resource::get_attribute(resource_with_many_attrs, "attr_0")
  let last_attr = Resource::get_attribute(resource_with_many_attrs, "attr_999")
  
  // æµ‹è¯•åˆå¹¶ç©ºèµ„æº
  let empty_resource1 = Resource::new()
  let empty_resource2 = Resource::new()
  let merged_empty = Resource::merge(empty_resource1, empty_resource2)
  
  // æµ‹è¯•åˆå¹¶å¤§é‡å±æ€§çš„resource
  let resource1_attrs = []
  let resource2_attrs = []
  for i = 0; i < 500; i = i + 1 {
    resource1_attrs.push(("resource1_attr_" + i.to_string(), StringValue("value1_" + i.to_string())))
    resource2_attrs.push(("resource2_attr_" + i.to_string(), StringValue("value2_" + i.to_string())))
  }
  
  let resource1 = Resource::with_attributes(Resource::new(), resource1_attrs)
  let resource2 = Resource::with_attributes(Resource::new(), resource2_attrs)
  let merged_complex = Resource::merge(resource1, resource2)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "éšæœºæ•°ç”Ÿæˆè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let random = Random::system()
  
  // æµ‹è¯•è´Ÿæ•°é•¿åº¦
  let negative_bytes = Random::next_bytes(random, -1)
  // åº”è¯¥èƒ½å¤„ç†è´Ÿæ•°é•¿åº¦ï¼ˆå¯èƒ½è¿”å›ç©ºæ•°ç»„æˆ–å›ºå®šé•¿åº¦ï¼‰
  
  // æµ‹è¯•é›¶é•¿åº¦
  let zero_bytes = Random::next_bytes(random, 0)
  assert_eq(zero_bytes.length(), 0)
  
  // æµ‹è¯•æå¤§é•¿åº¦
  let large_bytes = Random::next_bytes(random, 100000)
  // åº”è¯¥èƒ½å¤„ç†å¤§é•¿åº¦è¯·æ±‚
  
  // æµ‹è¯•å¤šæ¬¡ç”Ÿæˆç›¸åŒé•¿åº¦
  let bytes1 = Random::next_bytes(random, 10)
  let bytes2 = Random::next_bytes(random, 10)
  let bytes3 = Random::next_bytes(random, 10)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­å¯èƒ½è¿”å›ç›¸åŒçš„å€¼ï¼Œä½†ä¸åº”è¯¥å´©æºƒ
  assert_eq(bytes1.length(), 10)
  assert_eq(bytes2.length(), 10)
  assert_eq(bytes3.length(), 10)
  
  // æµ‹è¯•å¤šæ¬¡ç”ŸæˆUInt64
  let u64_1 = Random::next_u64(random)
  let u64_2 = Random::next_u64(random)
  let u64_3 = Random::next_u64(random)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­å¯èƒ½è¿”å›ç›¸åŒçš„å€¼ï¼Œä½†ä¸åº”è¯¥å´©æºƒ
  assert_true(true)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "ç³»ç»Ÿæ¢å¤èƒ½åŠ›æµ‹è¯•" {
  // æµ‹è¯•ç³»ç»Ÿåœ¨ä¸€ç³»åˆ—å¼‚å¸¸æ“ä½œåçš„æ¢å¤èƒ½åŠ›
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  // æ‰§è¡Œä¸€ç³»åˆ—è¾¹ç•Œæ¡ä»¶æ“ä½œ
  let tracer = TracerProvider::get_tracer(tracer_provider, "recovery.test")
  let meter = MeterProvider::get_meter(meter_provider, "recovery.test")
  let logger = LoggerProvider::get_logger(logger_provider, "recovery.test")
  
  // å¼‚å¸¸æ“ä½œåºåˆ—
  let invalid_span = Tracer::start_span(tracer, "")
  Span::end(invalid_span)
  
  let counter = Meter::create_counter(meter, "")
  Counter::add(counter, -1.0) // è´Ÿæ•°
  
  let invalid_log = LogRecord::new(Info, "")
  Logger::emit(logger, invalid_log)
  
  let empty_ctx = Context::root()
  let empty_carrier = TextMapCarrier::new()
  let propagator = CompositePropagator::new([])
  CompositePropagator::inject(propagator, empty_ctx, empty_carrier)
  
  // éªŒè¯ç³»ç»Ÿä»èƒ½æ­£å¸¸å·¥ä½œ
  let normal_span = Tracer::start_span(tracer, "normal.span")
  assert_eq(Span::name(normal_span), "normal.span")
  Span::set_status(normal_span, Ok)
  Span::end(normal_span)
  
  let normal_counter = Meter::create_counter(meter, "normal.counter")
  Counter::add(normal_counter, 1.0)
  
  let normal_log = LogRecord::new(Info, "Normal log message")
  Logger::emit(logger, normal_log)
  
  assert_true(true) // å¦‚æœç³»ç»Ÿèƒ½æ­£å¸¸æ¢å¤åˆ™æµ‹è¯•é€šè¿‡
}