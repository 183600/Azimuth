// Essential Comprehensive Tests for Azimuth Telemetry System
// æ ¸å¿ƒç»¼åˆæµ‹è¯•ç”¨ä¾‹

test "å±æ€§å€¼ç±»å‹æ·±åº¦åµŒå¥—æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•å­—ç¬¦ä¸²å±æ€§çš„å„ç§æƒ…å†µ
  Attributes::set(attrs, "empty.string", StringValue(""))
  Attributes::set(attrs, "normal.string", StringValue("normal value"))
  Attributes::set(attrs, "unicode.string", StringValue("æµ‹è¯•ğŸš€emoji"))
  Attributes::set(attrs, "special.chars", StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  
  // æµ‹è¯•æ•´æ•°å±æ€§çš„è¾¹ç•Œå€¼
  Attributes::set(attrs, "zero.int", IntValue(0))
  Attributes::set(attrs, "positive.int", IntValue(2147483647))
  Attributes::set(attrs, "negative.int", IntValue(-2147483648))
  
  // æµ‹è¯•æµ®ç‚¹æ•°å±æ€§çš„ç‰¹æ®Šå€¼
  Attributes::set(attrs, "zero.float", FloatValue(0.0))
  Attributes::set(attrs, "positive.float", FloatValue(3.14159265359))
  Attributes::set(attrs, "negative.float", FloatValue(-2.71828182846))
  
  // æµ‹è¯•å¸ƒå°”å±æ€§
  Attributes::set(attrs, "true.bool", BoolValue(true))
  Attributes::set(attrs, "false.bool", BoolValue(false))
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ•°ç»„
  Attributes::set(attrs, "empty.string.array", ArrayStringValue([]))
  Attributes::set(attrs, "single.string.array", ArrayStringValue(["single"]))
  Attributes::set(attrs, "multi.string.array", ArrayStringValue(["item1", "item2", "item3"]))
  
  // æµ‹è¯•æ•´æ•°æ•°ç»„
  Attributes::set(attrs, "empty.int.array", ArrayIntValue([]))
  Attributes::set(attrs, "single.int.array", ArrayIntValue([42]))
  Attributes::set(attrs, "multi.int.array", ArrayIntValue([1, 2, 3, 4, 5]))
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½èƒ½æ­£ç¡®è®¾ç½®å’Œè·å–
  let empty_string = Attributes::get(attrs, "empty.string")
  match empty_string {
    Some(StringValue(value)) => assert_eq(value, "")
    _ => assert_true(false)
  }
  
  let unicode_string = Attributes::get(attrs, "unicode.string")
  match unicode_string {
    Some(StringValue(value)) => assert_eq(value, "æµ‹è¯•ğŸš€emoji")
    _ => assert_true(false)
  }
  
  let positive_int = Attributes::get(attrs, "positive.int")
  match positive_int {
    Some(IntValue(value)) => assert_eq(value, 2147483647)
    _ => assert_true(false)
  }
  
  let true_bool = Attributes::get(attrs, "true.bool")
  match true_bool {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  let multi_string_array = Attributes::get(attrs, "multi.string.array")
  match multi_string_array {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "item1")
      assert_eq(values[1], "item2")
      assert_eq(values[2], "item3")
    }
    _ => assert_true(false)
  }
  
  let multi_int_array = Attributes::get(attrs, "multi.int.array")
  match multi_int_array {
    Some(ArrayIntValue(values)) => {
      assert_eq(values.length(), 5)
      assert_eq(values[0], 1)
      assert_eq(values[4], 5)
    }
    _ => assert_true(false)
  }
}

test "SpanContextè¾¹ç•Œæ¡ä»¶è¯¦ç»†æµ‹è¯•" {
  // æµ‹è¯•å„ç§æœ‰æ•ˆçš„SpanContextç»„åˆ
  let valid_ctx1 = SpanContext::new("0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", true, "rojo=00f067aa0ba902b7")
  assert_true(SpanContext::is_valid(valid_ctx1))
  assert_true(SpanContext::is_sampled(valid_ctx1))
  assert_eq(SpanContext::trace_id(valid_ctx1), "0af7651916cd43dd8448eb211c80319c")
  assert_eq(SpanContext::span_id(valid_ctx1), "b7ad6b7169203331")
  
  // æµ‹è¯•æœªé‡‡æ ·çš„æœ‰æ•ˆä¸Šä¸‹æ–‡
  let valid_ctx2 = SpanContext::new("0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", false, "")
  assert_true(SpanContext::is_valid(valid_ctx2))
  assert_false(SpanContext::is_sampled(valid_ctx2))
  
  // æµ‹è¯•ç©ºtrace_idçš„å„ç§æƒ…å†µ
  let empty_trace_ctx1 = SpanContext::new("", "b7ad6b7169203331", true, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx1))
  assert_eq(SpanContext::trace_id(empty_trace_ctx1), "")
  assert_eq(SpanContext::span_id(empty_trace_ctx1), "b7ad6b7169203331")
  
  let empty_trace_ctx2 = SpanContext::new("", "b7ad6b7169203331", false, "some=state")
  assert_false(SpanContext::is_valid(empty_trace_ctx2))
  assert_false(SpanContext::is_sampled(empty_trace_ctx2))
  
  // æµ‹è¯•ç©ºspan_idçš„å„ç§æƒ…å†µ
  let empty_span_ctx1 = SpanContext::new("0af7651916cd43dd8448eb211c80319c", "", true, "")
  assert_false(SpanContext::is_valid(empty_span_ctx1))
  assert_eq(SpanContext::trace_id(empty_span_ctx1), "0af7651916cd43dd8448eb211c80319c")
  assert_eq(SpanContext::span_id(empty_span_ctx1), "")
  
  let empty_span_ctx2 = SpanContext::new("0af7651916cd43dd8448eb211c80319c", "", false, "state=value")
  assert_false(SpanContext::is_valid(empty_span_ctx2))
  assert_false(SpanContext::is_sampled(empty_span_ctx2))
  
  // æµ‹è¯•ä¸¤è€…éƒ½ä¸ºç©ºçš„æƒ…å†µ
  let both_empty_ctx1 = SpanContext::new("", "", true, "")
  assert_false(SpanContext::is_valid(both_empty_ctx1))
  assert_true(SpanContext::is_sampled(both_empty_ctx1))
  
  let both_empty_ctx2 = SpanContext::new("", "", false, "state=value")
  assert_false(SpanContext::is_valid(both_empty_ctx2))
  assert_false(SpanContext::is_sampled(both_empty_ctx2))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„trace_idå’Œspan_id
  let special_chars_ctx = SpanContext::new("special-chars_123.abc", "span_id_special!@#", true, "")
  assert_true(SpanContext::is_valid(special_chars_ctx))
  assert_eq(SpanContext::trace_id(special_chars_ctx), "special-chars_123.abc")
  assert_eq(SpanContext::span_id(special_chars_ctx), "span_id_special!@#")
  
  // æµ‹è¯•é•¿ID
  let long_trace_id = "a" * 32 // 32ä¸ªå­—ç¬¦
  let long_span_id = "b" * 16  // 16ä¸ªå­—ç¬¦
  let long_id_ctx = SpanContext::new(long_trace_id, long_span_id, true, "")
  assert_true(SpanContext::is_valid(long_id_ctx))
  assert_eq(SpanContext::trace_id(long_id_ctx), long_trace_id)
  assert_eq(SpanContext::span_id(long_id_ctx), long_span_id)
}

test "æ—¥å¿—è®°å½•å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // æµ‹è¯•åŸºæœ¬æ—¥å¿—è®°å½•åˆ›å»º
  let basic_log = LogRecord::new(Info, "Basic log message")
  assert_eq(LogRecord::severity_number(basic_log), Info)
  match LogRecord::body(basic_log) {
    Some(body) => assert_eq(body, "Basic log message")
    None => assert_true(false)
  }
  assert_true(LogRecord::trace_id(basic_log) is None)
  assert_true(LogRecord::span_id(basic_log) is None)
  
  // æµ‹è¯•å®Œæ•´æ—¥å¿—è®°å½•åˆ›å»º
  let attrs = Attributes::new()
  Attributes::set(attrs, "user.id", StringValue("12345"))
  Attributes::set(attrs, "action", StringValue("login"))
  
  let timestamp = 1735689600000000000L
  let observed_timestamp = 1735689600000000001L
  let trace_id = "0af7651916cd43dd8448eb211c80319c"
  let span_id = "b7ad6b7169203331"
  
  let complete_log = LogRecord::new_with_context(
    Error,
    Some("Complete log with context"),
    Some(attrs),
    Some(timestamp),
    Some(observed_timestamp),
    Some(trace_id),
    Some(span_id),
    Some(Context::root())
  )
  
  assert_eq(LogRecord::severity_number(complete_log), Error)
  match LogRecord::body(complete_log) {
    Some(body) => assert_eq(body, "Complete log with context")
    None => assert_true(false)
  }
  assert_eq(LogRecord::trace_id(complete_log), Some(trace_id))
  assert_eq(LogRecord::span_id(complete_log), Some(span_id))
  assert_eq(complete_log.timestamp, Some(timestamp))
  assert_eq(complete_log.observed_timestamp, Some(observed_timestamp))
  
  // æµ‹è¯•ä¸åŒä¸¥é‡æ€§çº§åˆ«çš„æ—¥å¿—è®°å½•
  let severity_levels = [
    (Trace, "Trace message"),
    (Debug, "Debug message"),
    (Info, "Info message"),
    (Warn, "Warning message"),
    (Error, "Error message"),
    (Fatal, "Fatal message")
  ]
  
  for (severity, message) in severity_levels {
    let log = LogRecord::new(severity, message)
    assert_eq(LogRecord::severity_number(log), severity)
    match LogRecord::body(log) {
      Some(body) => assert_eq(body, message)
      None => assert_true(false)
    }
  }
  
  // æµ‹è¯•ç©ºå’Œç‰¹æ®Šæƒ…å†µçš„æ—¥å¿—è®°å½•
  let empty_body_log = LogRecord::new(Info, "")
  match LogRecord::body(empty_body_log) {
    Some(body) => assert_eq(body, "")
    None => assert_true(false)
  }
  
  let unicode_log = LogRecord::new(Warn, "Unicodeæµ‹è¯•ğŸš€message")
  match LogRecord::body(unicode_log) {
    Some(body) => assert_eq(body, "Unicodeæµ‹è¯•ğŸš€message")
    None => assert_true(false)
  }
  
  // æµ‹è¯•None bodyçš„æ—¥å¿—è®°å½•
  let none_body_log = LogRecord::new_with_context(
    Debug,
    None,
    None,
    None,
    None,
    None,
    None,
    None
  )
  assert_eq(LogRecord::severity_number(none_body_log), Debug)
  assert_true(LogRecord::body(none_body_log) is None)
}

test "ä¼ æ’­æœºåˆ¶å¤åˆæ“ä½œæµ‹è¯•" {
  // åˆ›å»ºå¤åˆä¼ æ’­å™¨
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  
  // æµ‹è¯•æ³¨å…¥æ“ä½œ
  let ctx = Context::root()
  let carrier = TextMapCarrier::new()
  
  CompositePropagator::inject(composite, ctx, carrier)
  
  // éªŒè¯æ³¨å…¥ç»“æœ
  let injected_traceparent = TextMapCarrier::get(carrier, "traceparent")
  assert_true(injected_traceparent is Some)
  
  // æµ‹è¯•æå–æ“ä½œ
  let carrier_with_data = TextMapCarrier::new()
  TextMapCarrier::set(carrier_with_data, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  TextMapCarrier::set(carrier_with_data, "baggage", "user.id=12345,session.id=session67890")
  
  let extracted_ctx = CompositePropagator::extract(composite, carrier_with_data)
  
  // éªŒè¯æå–ç»“æœ
  let extracted_value = Context::get(extracted_ctx, ContextKey::new("extracted"))
  match extracted_value {
    Some(value) => assert_eq(value, "true")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¤šæ¬¡æ³¨å…¥å’Œæå–
  let carrier2 = TextMapCarrier::new()
  CompositePropagator::inject(composite, extracted_ctx, carrier2)
  
  let extracted_ctx2 = CompositePropagator::extract(composite, carrier2)
  let extracted_value2 = Context::get(extracted_ctx2, ContextKey::new("extracted"))
  match extracted_value2 {
    Some(value) => assert_eq(value, "true")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºè½½ä½“çš„å¤„ç†
  let empty_carrier = TextMapCarrier::new()
  let ctx_from_empty = CompositePropagator::extract(composite, empty_carrier)
  // åº”è¯¥è¿”å›æœ‰æ•ˆçš„ä¸Šä¸‹æ–‡
  assert_true(true)
  
  // æµ‹è¯•æ— æ•ˆtraceparentçš„å¤„ç†
  let invalid_carrier = TextMapCarrier::new()
  TextMapCarrier::set(invalid_carrier, "traceparent", "invalid-traceparent-format")
  let ctx_from_invalid = CompositePropagator::extract(composite, invalid_carrier)
  // åº”è¯¥èƒ½å¤„ç†æ— æ•ˆæ ¼å¼è€Œä¸å´©æºƒ
  assert_true(true)
}

test "èµ„æºç®¡ç†å†…å­˜å®‰å…¨æµ‹è¯•" {
  // åˆ›å»ºå¤šä¸ªèµ„æºå¹¶æµ‹è¯•å†…å­˜ç®¡ç†
  let resource1 = Resource::new()
  let resource2 = Resource::new()
  let resource3 = Resource::new()
  
  // ä¸ºæ¯ä¸ªèµ„æºæ·»åŠ å¤§é‡å±æ€§
  let large_attrs1 = [
    ("service.name", StringValue("service1")),
    ("service.version", StringValue("1.0.0")),
    ("service.instance.id", StringValue("instance-1")),
    ("host.name", StringValue("host1")),
    ("process.pid", IntValue(1001)),
    ("process.memory.usage", IntValue(1024)),
    ("feature.enabled", BoolValue(true)),
    ("sample.rate", FloatValue(0.85))
  ]
  
  let large_attrs2 = [
    ("service.name", StringValue("service2")),
    ("service.version", StringValue("2.0.0")),
    ("service.instance.id", StringValue("instance-2")),
    ("host.name", StringValue("host2")),
    ("process.pid", IntValue(2002)),
    ("process.memory.usage", IntValue(2048)),
    ("feature.enabled", BoolValue(false)),
    ("sample.rate", FloatValue(0.75))
  ]
  
  let large_attrs3 = [
    ("service.name", StringValue("service3")),
    ("service.version", StringValue("3.0.0")),
    ("service.instance.id", StringValue("instance-3")),
    ("host.name", StringValue("host3")),
    ("process.pid", IntValue(3003)),
    ("process.memory.usage", IntValue(3072)),
    ("feature.enabled", BoolValue(true)),
    ("sample.rate", FloatValue(0.95))
  ]
  
  let resource1_with_attrs = Resource::with_attributes(resource1, large_attrs1)
  let resource2_with_attrs = Resource::with_attributes(resource2, large_attrs2)
  let resource3_with_attrs = Resource::with_attributes(resource3, large_attrs3)
  
  // æµ‹è¯•èµ„æºåˆå¹¶
  let merged1_2 = Resource::merge(resource1_with_attrs, resource2_with_attrs)
  let merged_all = Resource::merge(merged1_2, resource3_with_attrs)
  
  // éªŒè¯åˆå¹¶åçš„å±æ€§
  let service_name = Resource::get_attribute(merged_all, "service.name")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "service3") // æœ€ååˆå¹¶çš„èµ„æº
    _ => assert_true(false)
  }
  
  let process_pid = Resource::get_attribute(merged_all, "process.pid")
  match process_pid {
    Some(IntValue(value)) => assert_eq(value, 3003)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¤§é‡èµ„æºçš„åˆ›å»ºå’Œé”€æ¯
  let mut resources = []
  for i in 0..10 {
    let resource = Resource::new()
    let attrs = [
      ("index", IntValue(i)),
      ("name", StringValue("resource-" + i.to_string())),
      ("active", BoolValue(i % 2 == 0))
    ]
    let resource_with_attrs = Resource::with_attributes(resource, attrs)
    resources.push(resource_with_attrs)
  }
  
  // éªŒè¯æ‰€æœ‰èµ„æºçš„å±æ€§
  for i in 0..resources.length() {
    let resource = resources[i]
    let index = Resource::get_attribute(resource, "index")
    match index {
      Some(IntValue(value)) => assert_eq(value, i)
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•èµ„æºå±æ€§çš„è·å–å’Œè®¾ç½®
  let test_resource = Resource::new()
  let test_attrs = [
    ("string.attr", StringValue("test string")),
    ("int.attr", IntValue(42)),
    ("float.attr", FloatValue(3.14)),
    ("bool.attr", BoolValue(true)),
    ("array.string", ArrayStringValue(["item1", "item2", "item3"])),
    ("array.int", ArrayIntValue([1, 2, 3, 4, 5]))
  ]
  
  let test_resource_with_attrs = Resource::with_attributes(test_resource, test_attrs)
  
  // éªŒè¯æ‰€æœ‰ç±»å‹çš„å±æ€§
  let string_attr = Resource::get_attribute(test_resource_with_attrs, "string.attr")
  match string_attr {
    Some(StringValue(value)) => assert_eq(value, "test string")
    _ => assert_true(false)
  }
  
  let int_attr = Resource::get_attribute(test_resource_with_attrs, "int.attr")
  match int_attr {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  let float_attr = Resource::get_attribute(test_resource_with_attrs, "float.attr")
  match float_attr {
    Some(FloatValue(value)) => assert_eq(value, 3.14)
    _ => assert_true(false)
  }
  
  let bool_attr = Resource::get_attribute(test_resource_with_attrs, "bool.attr")
  match bool_attr {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  let array_string_attr = Resource::get_attribute(test_resource_with_attrs, "array.string")
  match array_string_attr {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "item1")
      assert_eq(values[2], "item3")
    }
    _ => assert_true(false)
  }
  
  let array_int_attr = Resource::get_attribute(test_resource_with_attrs, "array.int")
  match array_int_attr {
    Some(ArrayIntValue(values)) => {
      assert_eq(values.length(), 5)
      assert_eq(values[0], 1)
      assert_eq(values[4], 5)
    }
    _ => assert_true(false)
  }
}

test "è·¨æœåŠ¡æ•°æ®ä¸€è‡´æ€§æµ‹è¯•" {
  // æ¨¡æ‹Ÿè·¨æœåŠ¡åœºæ™¯ä¸‹çš„æ•°æ®ä¸€è‡´æ€§
  let service1_trace_id = "0af7651916cd43dd8448eb211c80319c"
  let service1_span_id = "b7ad6b7169203331"
  let service1_ctx = SpanContext::new(service1_trace_id, service1_span_id, true, "rojo=00f067aa0ba902b7")
  
  // æœåŠ¡1åˆ›å»ºspan
  let tracer_provider1 = TracerProvider::default()
  let tracer1 = TracerProvider::get_tracer(tracer_provider1, "service1.tracer")
  let span1 = Tracer::start_span(tracer1, "service1.operation")
  
  // æœåŠ¡1æ·»åŠ äº‹ä»¶
  Span::add_event(span1, "service1.start", None)
  Span::set_status(span1, Ok)
  
  // æ¨¡æ‹Ÿä¼ æ’­åˆ°æœåŠ¡2
  let carrier = TextMapCarrier::new()
  TextMapCarrier::set(carrier, "traceparent", "00-" + service1_trace_id + "-" + service1_span_id + "-01")
  TextMapCarrier::set(carrier, "baggage", "user.id=12345,service=service1")
  
  // æœåŠ¡2æå–ä¸Šä¸‹æ–‡
  let composite = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let ctx2 = CompositePropagator::extract(composite, carrier)
  
  // æœåŠ¡2åˆ›å»ºå­span
  let tracer_provider2 = TracerProvider::default()
  let tracer2 = TracerProvider::get_tracer(tracer_provider2, "service2.tracer")
  let span2 = Tracer::start_span(tracer2, "service2.operation")
  
  // æœåŠ¡2æ·»åŠ äº‹ä»¶
  Span::add_event(span2, "service2.start", Some([("parent.service", StringValue("service1"))]))
  Span::set_status(span2, Ok)
  
  // æœåŠ¡2ä¼ æ’­åˆ°æœåŠ¡3
  let carrier2 = TextMapCarrier::new()
  TextMapCarrier::set(carrier2, "traceparent", "00-" + service1_trace_id + "-b7ad6b7169203332-01")
  TextMapCarrier::set(carrier2, "baggage", "user.id=12345,service=service2")
  
  // æœåŠ¡3æå–ä¸Šä¸‹æ–‡
  let ctx3 = CompositePropagator::extract(composite, carrier2)
  
  // æœåŠ¡3åˆ›å»ºspan
  let tracer_provider3 = TracerProvider::default()
  let tracer3 = TracerProvider::get_tracer(tracer_provider3, "service3.tracer")
  let span3 = Tracer::start_span(tracer3, "service3.operation")
  
  // æœåŠ¡3æ·»åŠ äº‹ä»¶
  Span::add_event(span3, "service3.start", Some([("parent.service", StringValue("service2"))]))
  Span::set_status(span3, Error)
  
  // éªŒè¯æ‰€æœ‰spanéƒ½æœ‰ç›¸åŒçš„trace_id
  assert_eq(SpanContext::trace_id(span1.span_context), service1_trace_id)
  assert_eq(SpanContext::trace_id(span2.span_context), service1_trace_id)
  assert_eq(SpanContext::trace_id(span3.span_context), service1_trace_id)
  
  // éªŒè¯span_idä¸åŒ
  assert_true(SpanContext::span_id(span1.span_context) != SpanContext::span_id(span2.span_context))
  assert_true(SpanContext::span_id(span2.span_context) != SpanContext::span_id(span3.span_context))
  assert_true(SpanContext::span_id(span1.span_context) != SpanContext::span_id(span3.span_context))
  
  // ç»“æŸæ‰€æœ‰span
  Span::end(span1)
  Span::end(span2)
  Span::end(span3)
  
  // éªŒè¯è·¨æœåŠ¡çš„æ—¥å¿—è®°å½•ä¸€è‡´æ€§
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "cross.service.logger")
  
  let log1 = LogRecord::new_with_context(
    Info,
    Some("Service1 operation completed"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(service1_trace_id),
    Some(service1_span_id),
    None
  )
  
  let log2 = LogRecord::new_with_context(
    Info,
    Some("Service2 operation completed"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(service1_trace_id),
    Some("b7ad6b7169203332"),
    None
  )
  
  let log3 = LogRecord::new_with_context(
    Error,
    Some("Service3 operation failed"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(service1_trace_id),
    Some("b7ad6b7169203333"),
    None
  )
  
  // éªŒè¯æ‰€æœ‰æ—¥å¿—éƒ½æœ‰ç›¸åŒçš„trace_id
  assert_eq(LogRecord::trace_id(log1), Some(service1_trace_id))
  assert_eq(LogRecord::trace_id(log2), Some(service1_trace_id))
  assert_eq(LogRecord::trace_id(log3), Some(service1_trace_id))
  
  // éªŒè¯span_idä¸åŒ
  assert_true(LogRecord::span_id(log1) != LogRecord::span_id(log2))
  assert_true(LogRecord::span_id(log2) != LogRecord::span_id(log3))
  assert_true(LogRecord::span_id(log1) != LogRecord::span_id(log3))
  
  // å‘å‡ºæ—¥å¿—è®°å½•
  Logger::emit(logger, log1)
  Logger::emit(logger, log2)
  Logger::emit(logger, log3)
}

test "é”™è¯¯æ¢å¤è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å„ç§é”™è¯¯æƒ…å†µçš„æ¢å¤èƒ½åŠ›
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²trace_idçš„æ¢å¤
  let empty_trace_ctx = SpanContext::new("", "span123", true, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  
  // åˆ›å»ºæ–°çš„æœ‰æ•ˆä¸Šä¸‹æ–‡è¿›è¡Œæ¢å¤
  let recovery_ctx = SpanContext::new("recovery_trace_id", "recovery_span_id", true, "")
  assert_true(SpanContext::is_valid(recovery_ctx))
  
  // æµ‹è¯•æ— æ•ˆå±æ€§å€¼çš„å¤„ç†
  let attrs = Attributes::new()
  
  // è®¾ç½®æ­£å¸¸å±æ€§
  Attributes::set(attrs, "normal.attr", StringValue("normal value"))
  let normal_result = Attributes::get(attrs, "normal.attr")
  match normal_result {
    Some(StringValue(value)) => assert_eq(value, "normal value")
    _ => assert_true(false)
  }
  
  // å°è¯•è·å–ä¸å­˜åœ¨çš„å±æ€§
  let missing_result = Attributes::get(attrs, "missing.attr")
  assert_true(missing_result is None)
  
  // æµ‹è¯•HTTPé”™è¯¯å¤„ç†
  let client = HttpClient::new()
  
  // æµ‹è¯•é”™è¯¯å“åº”
  let error_response = HttpResponse::new(500, [("Content-Type", "text/plain")], Some("Internal Server Error"))
  assert_eq(HttpResponse::status_code(error_response), 500)
  match HttpResponse::body(error_response) {
    Some(body) => assert_eq(body, "Internal Server Error")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºå“åº”
  let empty_response = HttpResponse::new(204, [], None)
  assert_eq(HttpResponse::status_code(empty_response), 204)
  assert_true(HttpResponse::body(empty_response) is None)
  
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„é”™è¯¯å¤„ç†
  let error_log = LogRecord::new(Error, "Error occurred")
  assert_eq(LogRecord::severity_number(error_log), Error)
  
  // æµ‹è¯•å¸¦æœ‰Noneå€¼çš„æ—¥å¿—è®°å½•
  let none_log = LogRecord::new_with_context(
    Warn,
    None,
    None,
    None,
    None,
    None,
    None,
    None
  )
  assert_eq(LogRecord::severity_number(none_log), Warn)
  assert_true(LogRecord::body(none_log) is None)
  
  // æµ‹è¯•ä¼ æ’­å™¨çš„é”™è¯¯å¤„ç†
  let carrier = TextMapCarrier::new()
  TextMapCarrier::set(carrier, "invalid.header", "invalid value")
  
  let composite = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let ctx = CompositePropagator::extract(composite, carrier)
  // åº”è¯¥èƒ½å¤„ç†æ— æ•ˆæ•°æ®è€Œä¸å´©æºƒ
  assert_true(true)
  
  // æµ‹è¯•èµ„æºåˆå¹¶çš„é”™è¯¯å¤„ç†
  let resource1 = Resource::new()
  let resource2 = Resource::new()
  
  // åˆå¹¶ç©ºèµ„æº
  let merged_empty = Resource::merge(resource1, resource2)
  assert_true(true) // åº”è¯¥ä¸å´©æºƒ
  
  // æµ‹è¯•å¸¦æœ‰æ— æ•ˆå±æ€§çš„èµ„æº
  let invalid_attrs = [("invalid.key", StringValue(""))]
  let resource_with_invalid = Resource::with_attributes(resource1, invalid_attrs)
  let merged_with_invalid = Resource::merge(resource_with_invalid, resource2)
  assert_true(true) // åº”è¯¥ä¸å´©æºƒ
  
  // æµ‹è¯•spançš„é”™è¯¯å¤„ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.test.tracer")
  let error_span = Tracer::start_span(tracer, "error.test.span")
  
  // è®¾ç½®é”™è¯¯çŠ¶æ€
  Span::set_status(error_span, Error)
  match Span::status(error_span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°è¿”å›Unset
    _ => assert_true(false)
  }
  
  // æ·»åŠ é”™è¯¯äº‹ä»¶
  Span::add_event(error_span, "error.occurred", Some([("error.type", StringValue("timeout"))]))
  
  // ç»“æŸspan
  Span::end(error_span)
  assert_true(true) // åº”è¯¥ä¸å´©æºƒ
}

test "æ€§èƒ½åŸºå‡†ç®€å•æµ‹è¯•" {
  // ç®€å•çš„æ€§èƒ½åŸºå‡†æµ‹è¯•
  
  // æµ‹è¯•å±æ€§æ“ä½œæ€§èƒ½
  let attrs = Attributes::new()
  let start_time = Clock::now_unix_nanos(Clock::system())
  
  // è®¾ç½®100ä¸ªå±æ€§
  for i in 0..100 {
    Attributes::set(attrs, "attr." + i.to_string(), StringValue("value." + i.to_string()))
  }
  
  // è·å–100ä¸ªå±æ€§
  for i in 0..100 {
    let result = Attributes::get(attrs, "attr." + i.to_string())
    assert_true(result is Some)
  }
  
  let end_time = Clock::now_unix_nanos(Clock::system())
  let duration = end_time - start_time
  
  // éªŒè¯æ“ä½œå®Œæˆï¼ˆä¸éªŒè¯å…·ä½“æ—¶é—´ï¼Œå› ä¸ºç¯å¢ƒä¸åŒï¼‰
  assert_true(duration >= 0L)
  
  // æµ‹è¯•spanåˆ›å»ºæ€§èƒ½
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "performance.tracer")
  
  let span_start_time = Clock::now_unix_nanos(Clock::system())
  
  // åˆ›å»º50ä¸ªspan
  let mut spans = []
  for i in 0..50 {
    let span = Tracer::start_span(tracer, "span." + i.to_string())
    spans.push(span)
  }
  
  // ç»“æŸæ‰€æœ‰span
  for span in spans {
    Span::end(span)
  }
  
  let span_end_time = Clock::now_unix_nanos(Clock::system())
  let span_duration = span_end_time - span_start_time
  
  // éªŒè¯æ“ä½œå®Œæˆ
  assert_true(span_duration >= 0L)
  
  // æµ‹è¯•æ—¥å¿—è®°å½•æ€§èƒ½
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "performance.logger")
  
  let log_start_time = Clock::now_unix_nanos(Clock::system())
  
  // åˆ›å»º50ä¸ªæ—¥å¿—è®°å½•
  for i in 0..50 {
    let log = LogRecord::new(Info, "Log message " + i.to_string())
    Logger::emit(logger, log)
  }
  
  let log_end_time = Clock::now_unix_nanos(Clock::system())
  let log_duration = log_end_time - log_start_time
  
  // éªŒè¯æ“ä½œå®Œæˆ
  assert_true(log_duration >= 0L)
  
  // æµ‹è¯•ä¼ æ’­æ“ä½œæ€§èƒ½
  let composite = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let ctx = Context::root()
  
  let prop_start_time = Clock::now_unix_nanos(Clock::system())
  
  // è¿›è¡Œ50æ¬¡æ³¨å…¥å’Œæå–æ“ä½œ
  for i in 0..50 {
    let carrier = TextMapCarrier::new()
    CompositePropagator::inject(composite, ctx, carrier)
    let extracted_ctx = CompositePropagator::extract(composite, carrier)
    assert_true(true) // éªŒè¯æ“ä½œæˆåŠŸ
  }
  
  let prop_end_time = Clock::now_unix_nanos(Clock::system())
  let prop_duration = prop_end_time - prop_start_time
  
  // éªŒè¯æ“ä½œå®Œæˆ
  assert_true(prop_duration >= 0L)
}

test "å¹¶å‘å®‰å…¨æ€§åŸºç¡€æµ‹è¯•" {
  // åŸºç¡€çš„å¹¶å‘å®‰å…¨æ€§æµ‹è¯•
  
  // åˆ›å»ºå¤šä¸ªtracer
  let tracer_provider = TracerProvider::default()
  let tracer1 = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer1")
  let tracer2 = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer2")
  let tracer3 = TracerProvider::get_tracer(tracer_provider, "concurrent.tracer3")
  
  // åŒæ—¶åˆ›å»ºå¤šä¸ªspan
  let span1 = Tracer::start_span(tracer1, "concurrent.span1")
  let span2 = Tracer::start_span(tracer2, "concurrent.span2")
  let span3 = Tracer::start_span(tracer3, "concurrent.span3")
  
  // åŒæ—¶æ·»åŠ äº‹ä»¶
  Span::add_event(span1, "event1", Some([("tracer", StringValue("tracer1"))]))
  Span::add_event(span2, "event2", Some([("tracer", StringValue("tracer2"))]))
  Span::add_event(span3, "event3", Some([("tracer", StringValue("tracer3"))]))
  
  // åŒæ—¶è®¾ç½®çŠ¶æ€
  Span::set_status(span1, Ok)
  Span::set_status(span2, Error)
  Span::set_status(span3, Ok)
  
  // éªŒè¯spanå±æ€§
  assert_eq(Span::name(span1), "concurrent.span1")
  assert_eq(Span::name(span2), "concurrent.span2")
  assert_eq(Span::name(span3), "concurrent.span3")
  
  // åŒæ—¶ç»“æŸspan
  Span::end(span1)
  Span::end(span2)
  Span::end(span3)
  
  // åˆ›å»ºå¤šä¸ªlogger
  let logger_provider = LoggerProvider::default()
  let logger1 = LoggerProvider::get_logger(logger_provider, "concurrent.logger1")
  let logger2 = LoggerProvider::get_logger(logger_provider, "concurrent.logger2")
  let logger3 = LoggerProvider::get_logger(logger_provider, "concurrent.logger3")
  
  // åŒæ—¶åˆ›å»ºæ—¥å¿—è®°å½•
  let log1 = LogRecord::new(Info, "Concurrent log 1")
  let log2 = LogRecord::new(Warn, "Concurrent log 2")
  let log3 = LogRecord::new(Error, "Concurrent log 3")
  
  // åŒæ—¶å‘å‡ºæ—¥å¿—
  Logger::emit(logger1, log1)
  Logger::emit(logger2, log2)
  Logger::emit(logger3, log3)
  
  // éªŒè¯æ—¥å¿—è®°å½•å±æ€§
  assert_eq(LogRecord::severity_number(log1), Info)
  assert_eq(LogRecord::severity_number(log2), Warn)
  assert_eq(LogRecord::severity_number(log3), Error)
  
  match LogRecord::body(log1) {
    Some(body) => assert_eq(body, "Concurrent log 1")
    None => assert_true(false)
  }
  
  match LogRecord::body(log2) {
    Some(body) => assert_eq(body, "Concurrent log 2")
    None => assert_true(false)
  }
  
  match LogRecord::body(log3) {
    Some(body) => assert_eq(body, "Concurrent log 3")
    None => assert_true(false)
  }
  
  // åˆ›å»ºå¤šä¸ªmeter
  let meter_provider = MeterProvider::default()
  let meter1 = MeterProvider::get_meter(meter_provider, "concurrent.meter1")
  let meter2 = MeterProvider::get_meter(meter_provider, "concurrent.meter2")
  let meter3 = MeterProvider::get_meter(meter_provider, "concurrent.meter3")
  
  // åŒæ—¶åˆ›å»ºæŒ‡æ ‡
  let counter1 = Meter::create_counter(meter1, "concurrent.counter1")
  let counter2 = Meter::create_counter(meter2, "concurrent.counter2")
  let counter3 = Meter::create_counter(meter3, "concurrent.counter3")
  
  let histogram1 = Meter::create_histogram(meter1, "concurrent.histogram1")
  let histogram2 = Meter::create_histogram(meter2, "concurrent.histogram2")
  let histogram3 = Meter::create_histogram(meter3, "concurrent.histogram3")
  
  // åŒæ—¶è®°å½•æŒ‡æ ‡
  Counter::add(counter1, 1.0)
  Counter::add(counter2, 2.0)
  Counter::add(counter3, 3.0)
  
  Histogram::record(histogram1, 100.0)
  Histogram::record(histogram2, 200.0)
  Histogram::record(histogram3, 300.0)
  
  // éªŒè¯æŒ‡æ ‡åç§°
  assert_eq(counter1.name, "concurrent.counter1")
  assert_eq(counter2.name, "concurrent.counter2")
  assert_eq(counter3.name, "concurrent.counter3")
  
  assert_eq(histogram1.name, "concurrent.histogram1")
  assert_eq(histogram2.name, "concurrent.histogram2")
  assert_eq(histogram3.name, "concurrent.histogram3")
  
  // æµ‹è¯•å¤šä¸ªä¼ æ’­å™¨çš„å¹¶å‘ä½¿ç”¨
  let composite1 = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let composite2 = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let composite3 = CompositePropagator::new([W3CTraceContextPropagator::new()])
  
  let carrier1 = TextMapCarrier::new()
  let carrier2 = TextMapCarrier::new()
  let carrier3 = TextMapCarrier::new()
  
  // åŒæ—¶è¿›è¡Œæ³¨å…¥
  CompositePropagator::inject(composite1, Context::root(), carrier1)
  CompositePropagator::inject(composite2, Context::root(), carrier2)
  CompositePropagator::inject(composite3, Context::root(), carrier3)
  
  // åŒæ—¶è¿›è¡Œæå–
  let ctx1 = CompositePropagator::extract(composite1, carrier1)
  let ctx2 = CompositePropagator::extract(composite2, carrier2)
  let ctx3 = CompositePropagator::extract(composite3, carrier3)
  
  // éªŒè¯æå–æ“ä½œæˆåŠŸ
  assert_true(true)
}

test "å›½é™…åŒ–æ”¯æŒåŸºç¡€æµ‹è¯•" {
  // åŸºç¡€çš„å›½é™…åŒ–æ”¯æŒæµ‹è¯•
  
  // æµ‹è¯•ä¸­æ–‡å±æ€§å€¼
  let attrs = Attributes::new()
  Attributes::set(attrs, "ç”¨æˆ·å", StringValue("å¼ ä¸‰"))
  Attributes::set(attrs, "æ“ä½œ", StringValue("ç™»å½•"))
  Attributes::set(attrs, "æè¿°", StringValue("ç”¨æˆ·æˆåŠŸç™»å½•ç³»ç»Ÿ"))
  
  let username = Attributes::get(attrs, "ç”¨æˆ·å")
  match username {
    Some(StringValue(value)) => assert_eq(value, "å¼ ä¸‰")
    _ => assert_true(false)
  }
  
  let operation = Attributes::get(attrs, "æ“ä½œ")
  match operation {
    Some(StringValue(value)) => assert_eq(value, "ç™»å½•")
    _ => assert_true(false)
  }
  
  let description = Attributes::get(attrs, "æè¿°")
  match description {
    Some(StringValue(value)) => assert_eq(value, "ç”¨æˆ·æˆåŠŸç™»å½•ç³»ç»Ÿ")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•emojiå’Œç‰¹æ®Šå­—ç¬¦
  Attributes::set(attrs, "emoji.test", StringValue("æµ‹è¯•ğŸš€ğŸŒŸğŸ’«"))
  Attributes::set(attrs, "special.chars", StringValue("ç‰¹æ®Šå­—ç¬¦!@#$%^&*()"))
  
  let emoji_test = Attributes::get(attrs, "emoji.test")
  match emoji_test {
    Some(StringValue(value)) => assert_eq(value, "æµ‹è¯•ğŸš€ğŸŒŸğŸ’«")
    _ => assert_true(false)
  }
  
  let special_chars = Attributes::get(attrs, "special.chars")
  match special_chars {
    Some(StringValue(value)) => assert_eq(value, "ç‰¹æ®Šå­—ç¬¦!@#$%^&*()")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¤šè¯­è¨€æ•°ç»„
  Attributes::set(attrs, "å¤šè¯­è¨€æ ‡ç­¾", ArrayStringValue(["ä¸­æ–‡", "English", "æ—¥æœ¬èª", "í•œêµ­ì–´"]))
  
  let multilingual_tags = Attributes::get(attrs, "å¤šè¯­è¨€æ ‡ç­¾")
  match multilingual_tags {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 4)
      assert_eq(values[0], "ä¸­æ–‡")
      assert_eq(values[1], "English")
      assert_eq(values[2], "æ—¥æœ¬èª")
      assert_eq(values[3], "í•œêµ­ì–´")
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å›½é™…åŒ–æ—¥å¿—è®°å½•
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "å›½é™…åŒ–æ—¥å¿—")
  
  let chinese_log = LogRecord::new(Info, "ç”¨æˆ·ç™»å½•æˆåŠŸ")
  let english_log = LogRecord::new(Info, "User login successful")
  let japanese_log = LogRecord::new(Info, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
  
  match LogRecord::body(chinese_log) {
    Some(body) => assert_eq(body, "ç”¨æˆ·ç™»å½•æˆåŠŸ")
    None => assert_true(false)
  }
  
  match LogRecord::body(english_log) {
    Some(body) => assert_eq(body, "User login successful")
    None => assert_true(false)
  }
  
  match LogRecord::body(japanese_log) {
    Some(body) => assert_eq(body, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
    None => assert_true(false)
  }
  
  // å‘å‡ºå›½é™…åŒ–æ—¥å¿—
  Logger::emit(logger, chinese_log)
  Logger::emit(logger, english_log)
  Logger::emit(logger, japanese_log)
  
  // æµ‹è¯•å›½é™…åŒ–spanåç§°
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "å›½é™…åŒ–è¿½è¸ªå™¨")
  
  let chinese_span = Tracer::start_span(tracer, "ä¸­æ–‡æ“ä½œ")
  let english_span = Tracer::start_span(tracer, "English Operation")
  let japanese_span = Tracer::start_span(tracer, "æ—¥æœ¬èªæ“ä½œ")
  
  assert_eq(Span::name(chinese_span), "ä¸­æ–‡æ“ä½œ")
  assert_eq(Span::name(english_span), "English Operation")
  assert_eq(Span::name(japanese_span), "æ—¥æœ¬èªæ“ä½œ")
  
  // æ·»åŠ å›½é™…åŒ–äº‹ä»¶
  Span::add_event(chinese_span, "å¼€å§‹å¤„ç†", Some([("æ­¥éª¤", StringValue("åˆå§‹åŒ–"))]))
  Span::add_event(english_span, "Start processing", Some([("step", StringValue("initialization"))]))
  Span::add_event(japanese_span, "å‡¦ç†é–‹å§‹", Some([("ã‚¹ãƒ†ãƒƒãƒ—", StringValue("åˆæœŸåŒ–"))]))
  
  // ç»“æŸspan
  Span::end(chinese_span)
  Span::end(english_span)
  Span::end(japanese_span)
  
  // æµ‹è¯•å›½é™…åŒ–èµ„æºå±æ€§
  let resource = Resource::new()
  let international_attrs = [
    ("æœåŠ¡åç§°", StringValue("é¥æµ‹æœåŠ¡")),
    ("æœåŠ¡ç‰ˆæœ¬", StringValue("1.0.0")),
    ("ä¸»æœºå", StringValue("æœ¬åœ°ä¸»æœº")),
    ("æè¿°", StringValue("è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æœåŠ¡"))
  ]
  
  let resource_with_international_attrs = Resource::with_attributes(resource, international_attrs)
  
  let service_name = Resource::get_attribute(resource_with_international_attrs, "æœåŠ¡åç§°")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "é¥æµ‹æœåŠ¡")
    _ => assert_true(false)
  }
  
  let host_name = Resource::get_attribute(resource_with_international_attrs, "ä¸»æœºå")
  match host_name {
    Some(StringValue(value)) => assert_eq(value, "æœ¬åœ°ä¸»æœº")
    _ => assert_true(false)
  }
  
  let description = Resource::get_attribute(resource_with_international_attrs, "æè¿°")
  match description {
    Some(StringValue(value)) => assert_eq(value, "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æœåŠ¡")
    _ => assert_true(false)
  }
}