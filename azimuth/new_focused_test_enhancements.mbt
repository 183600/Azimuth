// New Focused Test Enhancements for Azimuth Telemetry System
// ä¸“æ³¨äºæ–°çš„æµ‹è¯•åœºæ™¯å’Œè¾¹ç•Œæ¡ä»¶

// Test 1: é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
pub test "error handling and boundary conditions" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œnullå€¼å¤„ç†
  let empty_attrs = azimuth::Attributes::new()
  azimuth::Attributes::set(empty_attrs, "", azimuth::StringValue(""))
  let empty_result = azimuth::Attributes::get(empty_attrs, "")
  assert_eq(empty_result, Some(azimuth::StringValue("")))
  
  // æµ‹è¯•æå€¼å¤„ç†
  let extreme_attrs = azimuth::Attributes::new()
  azimuth::Attributes::set(extreme_attrs, "max.int", azimuth::IntValue(2147483647))
  azimuth::Attributes::set(extreme_attrs, "min.int", azimuth::IntValue(-2147483648))
  azimuth::Attributes::set(extreme_attrs, "max.float", azimuth::FloatValue(1.7976931348623157e+308))
  azimuth::Attributes::set(extreme_attrs, "min.float", azimuth::FloatValue(-1.7976931348623157e+308))
  
  let max_int = azimuth::Attributes::get(extreme_attrs, "max.int")
  let min_int = azimuth::Attributes::get(extreme_attrs, "min.int")
  let max_float = azimuth::Attributes::get(extreme_attrs, "max.float")
  let min_float = azimuth::Attributes::get(extreme_attrs, "min.float")
  
  assert_eq(max_int, Some(azimuth::IntValue(2147483647)))
  assert_eq(min_int, Some(azimuth::IntValue(-2147483648)))
  assert_eq(max_float, Some(azimuth::FloatValue(1.7976931348623157e+308)))
  assert_eq(min_float, Some(azimuth::FloatValue(-1.7976931348623157e+308)))
  
  // æµ‹è¯•è¾¹ç•ŒSpanContext
  let empty_span_ctx = azimuth::SpanContext::new("", "", false, "")
  assert_false(azimuth::SpanContext::is_valid(empty_span_ctx))
  assert_false(azimuth::SpanContext::is_sampled(empty_span_ctx))
  
  let valid_span_ctx = azimuth::SpanContext::new("1234567890123456", "7890123456789012", true, "test-state")
  assert_true(azimuth::SpanContext::is_valid(valid_span_ctx))
  assert_true(azimuth::SpanContext::is_sampled(valid_span_ctx))
}

// Test 2: æ€§èƒ½å’Œå†…å­˜ç®¡ç†æµ‹è¯•
pub test "performance and memory management" {
  // æµ‹è¯•å¤§é‡å±æ€§æ“ä½œ
  let large_attrs = azimuth::Attributes::new()
  for i = 0; i < 1000; i = i + 1 {
    let key = "key." + i.to_string()
    let value = "value." + i.to_string()
    azimuth::Attributes::set(large_attrs, key, azimuth::StringValue(value))
  }
  
  // éªŒè¯æ€§èƒ½ - åº”è¯¥èƒ½å¤Ÿåœ¨åˆç†æ—¶é—´å†…å®Œæˆ
  let start_time = azimuth::Clock::now_unix_nanos(azimuth::Clock::system())
  
  for i = 0; i < 100; i = i + 1 {
    let key = "key." + i.to_string()
    let _ = azimuth::Attributes::get(large_attrs, key)
  }
  
  let end_time = azimuth::Clock::now_unix_nanos(azimuth::Clock::system())
  let duration = end_time - start_time
  
  // éªŒè¯æ“ä½œåœ¨åˆç†æ—¶é—´å†…å®Œæˆï¼ˆå°äº1ç§’ï¼‰
  assert_true(duration < 1000000000L)
  
  // æµ‹è¯•å¤§é‡baggageæ¡ç›®
  let large_baggage = azimuth::Baggage::new()
  let updated_baggage = large_baggage
  for i = 0; i < 500; i = i + 1 {
    let key = "baggage." + i.to_string()
    let value = "value." + i.to_string()
    updated_baggage = azimuth::Baggage::set_entry(updated_baggage, key, value)
  }
  
  // éªŒè¯baggageæ“ä½œ
  let test_value = azimuth::Baggage::get_entry(updated_baggage, "baggage.100")
  assert_eq(test_value, Some("value.100"))
}

// Test 3: å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•
pub test "internationalization and localization" {
  // æµ‹è¯•Unicodeå­—ç¬¦å¤„ç†
  let unicode_attrs = azimuth::Attributes::new()
  azimuth::Attributes::set(unicode_attrs, "ä¸­æ–‡.é”®", azimuth::StringValue("ä¸­æ–‡å€¼"))
  azimuth::Attributes::set(unicode_attrs, "emoji.key", azimuth::StringValue("ğŸš€ğŸŒŸğŸ’«"))
  azimuth::Attributes::set(unicode_attrs, "arabic.key", azimuth::StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"))
  azimuth::Attributes::set(unicode_attrs, "russian.key", azimuth::StringValue("ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€"))
  
  let chinese_value = azimuth::Attributes::get(unicode_attrs, "ä¸­æ–‡.é”®")
  let emoji_value = azimuth::Attributes::get(unicode_attrs, "emoji.key")
  let arabic_value = azimuth::Attributes::get(unicode_attrs, "arabic.key")
  let russian_value = azimuth::Attributes::get(unicode_attrs, "russian.key")
  
  assert_eq(chinese_value, Some(azimuth::StringValue("ä¸­æ–‡å€¼")))
  assert_eq(emoji_value, Some(azimuth::StringValue("ğŸš€ğŸŒŸğŸ’«")))
  assert_eq(arabic_value, Some(azimuth::StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…")))
  assert_eq(russian_value, Some(azimuth::StringValue("ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€")))
  
  // æµ‹è¯•å›½é™…åŒ–æ—¥å¿—æ¶ˆæ¯
  let i18n_log_record = azimuth::LogRecord::new(azimuth::Info, "æµ‹è¯•æ¶ˆæ¯ï¼šç”¨æˆ·æ“ä½œå®Œæˆ âœ“")
  assert_eq(azimuth::LogRecord::body(i18n_log_record), Some("æµ‹è¯•æ¶ˆæ¯ï¼šç”¨æˆ·æ“ä½œå®Œæˆ âœ“"))
  
  let error_log = azimuth::LogRecord::new(azimuth::Error, "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ")
  assert_eq(azimuth::LogRecord::body(error_log), Some("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ"))
}

// Test 4: å¹¶å‘å®‰å…¨æ€§æµ‹è¯•
pub test "concurrency safety" {
  // æµ‹è¯•å¹¶å‘å±æ€§æ“ä½œ
  let shared_attrs = azimuth::Attributes::new()
  
  // æ¨¡æ‹Ÿå¹¶å‘å†™å…¥
  for i = 0; i < 100; i = i + 1 {
    let key = "concurrent." + i.to_string()
    let value = i.to_string()
    azimuth::Attributes::set(shared_attrs, key, azimuth::StringValue(value))
  }
  
  // æ¨¡æ‹Ÿå¹¶å‘è¯»å–
  for i = 0; i < 100; i = i + 1 {
    let key = "concurrent." + i.to_string()
    let value = azimuth::Attributes::get(shared_attrs, key)
    assert_eq(value, Some(azimuth::StringValue(i.to_string())))
  }
  
  // æµ‹è¯•å¹¶å‘ä¸Šä¸‹æ–‡æ“ä½œ
  let base_ctx = azimuth::Context::root()
  let ctx_with_values = base_ctx
  
  for i = 0; i < 50; i = i + 1 {
    let key = azimuth::ContextKey::new("context." + i.to_string())
    ctx_with_values = azimuth::Context::with_value(ctx_with_values, key, i.to_string())
  }
  
  // éªŒè¯ä¸Šä¸‹æ–‡å€¼
  for i = 0; i < 50; i = i + 1 {
    let key = azimuth::ContextKey::new("context." + i.to_string())
    let value = azimuth::Context::get(ctx_with_values, key)
    assert_eq(value, Some(i.to_string()))
  }
}

// Test 5: æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–æµ‹è¯•
pub test "data serialization and deserialization" {
  // æµ‹è¯•å¤æ‚æ•°æ®ç»“æ„çš„åºåˆ—åŒ–
  let complex_attrs = azimuth::Attributes::new()
  azimuth::Attributes::set(complex_attrs, "string.array", azimuth::ArrayStringValue(["a", "b", "c"]))
  azimuth::Attributes::set(complex_attrs, "int.array", azimuth::ArrayIntValue([1, 2, 3, 4, 5]))
  azimuth::Attributes::set(complex_attrs, "nested.value", azimuth::StringValue("{\"key\":\"value\",\"number\":42}"))
  
  let string_array = azimuth::Attributes::get(complex_attrs, "string.array")
  let int_array = azimuth::Attributes::get(complex_attrs, "int.array")
  let nested_value = azimuth::Attributes::get(complex_attrs, "nested.value")
  
  assert_eq(string_array, Some(azimuth::ArrayStringValue(["a", "b", "c"])))
  assert_eq(int_array, Some(azimuth::ArrayIntValue([1, 2, 3, 4, 5])))
  assert_eq(nested_value, Some(azimuth::StringValue("{\"key\":\"value\",\"number\":42}")))
  
  // æµ‹è¯•æ—¶é—´æˆ³åºåˆ—åŒ–
  let timestamp = azimuth::Clock::now_unix_nanos(azimuth::Clock::system())
  let timestamped_log = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Timestamped message"),
    None,
    Some(timestamp),
    Some(timestamp + 1000L),
    Some("trace-123"),
    Some("span-456"),
    Some(azimuth::Context::root())
  )
  
  assert_eq(azimuth::LogRecord::timestamp(timestamped_log), Some(timestamp))
  assert_eq(azimuth::LogRecord::observed_timestamp(timestamped_log), Some(timestamp + 1000L))
}

// Test 6: é…ç½®ç®¡ç†æµ‹è¯•
pub test "configuration management" {
  // æµ‹è¯•åŠ¨æ€é…ç½®æ›´æ–°
  let config_attrs = azimuth::Attributes::new()
  azimuth::Attributes::set(config_attrs, "service.name", azimuth::StringValue("test-service"))
  azimuth::Attributes::set(config_attrs, "service.version", azimuth::StringValue("1.0.0"))
  azimuth::Attributes::set(config_attrs, "environment", azimuth::StringValue("development"))
  
  // æ¨¡æ‹Ÿé…ç½®æ›´æ–°
  azimuth::Attributes::set(config_attrs, "service.version", azimuth::StringValue("1.1.0"))
  azimuth::Attributes::set(config_attrs, "environment", azimuth::StringValue("production"))
  
  let updated_version = azimuth::Attributes::get(config_attrs, "service.version")
  let updated_env = azimuth::Attributes::get(config_attrs, "environment")
  
  assert_eq(updated_version, Some(azimuth::StringValue("1.1.0")))
  assert_eq(updated_env, Some(azimuth::StringValue("production")))
  
  // æµ‹è¯•é…ç½®ç»§æ‰¿å’Œè¦†ç›–
  let base_config = azimuth::Resource::new()
  let base_attrs = [("default.timeout", azimuth::IntValue(30)), 
                    ("default.retries", azimuth::IntValue(3))]
  let base_resource = azimuth::Resource::with_attributes(base_config, base_attrs)
  
  let override_config = azimuth::Resource::new()
  let override_attrs = [("default.timeout", azimuth::IntValue(60))]
  let override_resource = azimuth::Resource::with_attributes(override_config, override_attrs)
  
  let merged_config = azimuth::Resource::merge(base_resource, override_resource)
  let timeout = azimuth::Resource::get_attribute(merged_config, "default.timeout")
  let retries = azimuth::Resource::get_attribute(merged_config, "default.retries")
  
  assert_eq(timeout, Some(azimuth::IntValue(60)))
  assert_eq(retries, Some(azimuth::IntValue(3)))
}

// Test 7: æ—¶é—´åºåˆ—æ•°æ®å¤„ç†æµ‹è¯•
pub test "time series data processing" {
  // æµ‹è¯•æ—¶é—´åºåˆ—æ•°æ®ç”Ÿæˆ
  let base_time = azimuth::Clock::now_unix_nanos(azimuth::Clock::system())
  let time_series_data = []
  
  for i = 0; i < 10; i = i + 1 {
    let timestamp = base_time + (i * 1000000L)  // æ¯æ¯«ç§’ä¸€ä¸ªæ•°æ®ç‚¹
    let value = 100.0 + (i.to_int() * 10.0).to_double()
    time_series_data.push((timestamp, value))
  }
  
  // éªŒè¯æ—¶é—´åºåˆ—æ•°æ®
  assert_eq(time_series_data.length(), 10)
  assert_eq(time_series_data[0], (base_time, 100.0))
  assert_eq(time_series_data[9], (base_time + 9000000L, 190.0))
  
  // æµ‹è¯•æ—¶é—´çª—å£èšåˆ
  let meter_provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(meter_provider, "time-series-meter")
  let histogram = azimuth::Meter::create_histogram(meter, "response.time", Some("Response time histogram"), Some("ms"))
  
  // è®°å½•æ—¶é—´åºåˆ—æ•°æ®
  for (_, value) in time_series_data {
    azimuth::Histogram::record(histogram, value)
  }
  
  assert_eq(histogram.name, "response.time")
  assert_eq(histogram.description, Some("Response time histogram"))
  assert_eq(histogram.unit, Some("ms"))
}

// Test 8: è·¨æœåŠ¡é›†æˆæµ‹è¯•
pub test "cross-service integration" {
  // æµ‹è¯•æœåŠ¡é—´è¿½è¸ªä¼ æ’­
  let service_a_ctx = azimuth::Context::root()
  let trace_key = azimuth::ContextKey::new("trace.id")
  let service_a_ctx_with_trace = azimuth::Context::with_value(service_a_ctx, trace_key, "trace-12345")
  
  // æ¨¡æ‹ŸæœåŠ¡é—´ä¼ æ’­
  let carrier = azimuth::TextMapCarrier::new()
  let propagator = azimuth::W3CTraceContextPropagator::new()
  let composite_propagator = azimuth::CompositePropagator::new([propagator])
  
  azimuth::CompositePropagator::inject(composite_propagator, service_a_ctx_with_trace, carrier)
  
  // æœåŠ¡Bæå–ä¸Šä¸‹æ–‡
  let service_b_ctx = azimuth::CompositePropagator::extract(composite_propagator, carrier)
  let extracted_trace = azimuth::Context::get(service_b_ctx, trace_key)
  
  assert_eq(extracted_trace, Some("true"))  // åŸºäºç®€åŒ–å®ç°çš„é¢„æœŸç»“æœ
  
  // æµ‹è¯•æœåŠ¡é—´åº¦é‡èšåˆ
  let service_a_meter = azimuth::MeterProvider::get_meter(azimuth::MeterProvider::default(), "service-a")
  let service_b_meter = azimuth::MeterProvider::get_meter(azimuth::MeterProvider::default(), "service-b")
  
  let service_a_counter = azimuth::Meter::create_counter(service_a_meter, "requests.total")
  let service_b_counter = azimuth::Meter::create_counter(service_b_meter, "requests.total")
  
  azimuth::Counter::add(service_a_counter, 100.0)
  azimuth::Counter::add(service_b_counter, 150.0)
  
  assert_eq(service_a_counter.name, "requests.total")
  assert_eq(service_b_counter.name, "requests.total")
  
  // æµ‹è¯•æœåŠ¡é—´æ—¥å¿—å…³è”
  let service_a_logger = azimuth::LoggerProvider::get_logger(azimuth::LoggerProvider::default(), "service-a")
  let service_b_logger = azimuth::LoggerProvider::get_logger(azimuth::LoggerProvider::default(), "service-b")
  
  let correlated_log = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Cross-service operation completed"),
    None,
    Some(azimuth::Clock::now_unix_nanos(azimuth::Clock::system())),
    None,
    Some("trace-12345"),
    Some("span-67890"),
    Some(service_b_ctx)
  )
  
  azimuth::Logger::emit(service_b_logger, correlated_log)
  assert_eq(service_a_logger.scope.name, "service-a")
  assert_eq(service_b_logger.scope.name, "service-b")
}