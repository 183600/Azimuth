test "InstrumentationScopeåˆ›å»ºå’Œå±æ€§æµ‹è¯•" {
  // æµ‹è¯•åŸºæœ¬çš„InstrumentationScopeåˆ›å»º
  let basic_scope = InstrumentationScope::{ 
    name: "test.scope", 
    version: None, 
    schema_url: None 
  }
  assert_eq(basic_scope.name, "test.scope")
  assert_true(basic_scope.version is None)
  assert_true(basic_scope.schema_url is None)
  
  // æµ‹è¯•å¸¦æœ‰ç‰ˆæœ¬çš„InstrumentationScope
  let versioned_scope = InstrumentationScope::{ 
    name: "versioned.scope", 
    version: Some("1.2.3"), 
    schema_url: None 
  }
  assert_eq(versioned_scope.name, "versioned.scope")
  match versioned_scope.version {
    Some(v) => assert_eq(v, "1.2.3")
    None => assert_true(false)
  }
  assert_true(versioned_scope.schema_url is None)
  
  // æµ‹è¯•å¸¦æœ‰schema_urlçš„InstrumentationScope
  let schema_scope = InstrumentationScope::{ 
    name: "schema.scope", 
    version: None, 
    schema_url: Some("https://opentelemetry.io/schemas/1.20.0") 
  }
  assert_eq(schema_scope.name, "schema.scope")
  assert_true(schema_scope.version is None)
  match schema_scope.schema_url {
    Some(url) => assert_eq(url, "https://opentelemetry.io/schemas/1.20.0")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å®Œæ•´çš„InstrumentationScope
  let full_scope = InstrumentationScope::{ 
    name: "full.scope", 
    version: Some("2.0.0"), 
    schema_url: Some("https://opentelemetry.io/schemas/1.20.0") 
  }
  assert_eq(full_scope.name, "full.scope")
  match full_scope.version {
    Some(v) => assert_eq(v, "2.0.0")
    None => assert_true(false)
  }
  match full_scope.schema_url {
    Some(url) => assert_eq(url, "https://opentelemetry.io/schemas/1.20.0")
    None => assert_true(false)
  }
  
  // æµ‹è¯•é€šè¿‡Tracerè·å–çš„InstrumentationScope
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "test.tracer", Some("1.0.0"))
  let tracer_scope = Tracer::instrumentation_scope(tracer)
  assert_eq(tracer_scope.name, "test.tracer")
  match tracer_scope.version {
    Some(v) => assert_eq(v, "1.0.0")
    None => assert_true(false)
  }
  
  // æµ‹è¯•é€šè¿‡Meterè·å–çš„InstrumentationScope
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "test.meter", Some("2.0.0"))
  let meter_scope = meter.scope
  assert_eq(meter_scope.name, "test.meter")
  match meter_scope.version {
    Some(v) => assert_eq(v, "2.0.0")
    None => assert_true(false)
  }
  
  // æµ‹è¯•é€šè¿‡Loggerè·å–çš„InstrumentationScope
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "test.logger", Some("3.0.0"))
  let logger_scope = logger.scope
  assert_eq(logger_scope.name, "test.logger")
  match logger_scope.version {
    Some(v) => assert_eq(v, "3.0.0")
    None => assert_true(false)
  }
}

test "UpDownCounterè¯¦ç»†æ“ä½œæµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "updown.test.meter")
  
  // æµ‹è¯•åŸºæœ¬çš„UpDownCounteråˆ›å»º
  let basic_counter = Meter::create_updown_counter(meter, "basic.counter")
  assert_eq(basic_counter.name, "basic.counter")
  assert_true(basic_counter.description is None)
  assert_true(basic_counter.unit is None)
  
  // æµ‹è¯•å¸¦æœ‰æè¿°å’Œå•ä½çš„UpDownCounter
  let detailed_counter = Meter::create_updown_counter(
    meter, 
    "detailed.counter", 
    Some("Detailed counter for testing"), 
    Some("operations")
  )
  assert_eq(detailed_counter.name, "detailed.counter")
  match detailed_counter.description {
    Some(desc) => assert_eq(desc, "Detailed counter for testing")
    None => assert_true(false)
  }
  match detailed_counter.unit {
    Some(unit) => assert_eq(unit, "operations")
    None => assert_true(false)
  }
  
  // æµ‹è¯•UpDownCounterçš„å¢å‡æ“ä½œ
  UpDownCounter::add(basic_counter, 10.0) // å¢åŠ 10
  UpDownCounter::add(basic_counter, -5.0) // å‡å°‘5
  UpDownCounter::add(basic_counter, 0.0)  // å¢åŠ 0
  UpDownCounter::add(basic_counter, 3.14) // å¢åŠ æµ®ç‚¹æ•°
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„UpDownCounteræ“ä½œ
  let attrs = Attributes::new()
  Attributes::set(attrs, "operation.type", StringValue("read"))
  Attributes::set(attrs, "user.id", StringValue("12345"))
  
  UpDownCounter::add(detailed_counter, 1.0, Some(attrs))
  UpDownCounter::add(detailed_counter, -1.0, Some(attrs))
  UpDownCounter::add(detailed_counter, 2.5, Some(attrs))
  
  // æµ‹è¯•è´Ÿæ•°æ“ä½œ
  UpDownCounter::add(basic_counter, -100.0)
  UpDownCounter::add(basic_counter, 50.0)
  
  // æµ‹è¯•å¤§æ•°å€¼æ“ä½œ
  UpDownCounter::add(basic_counter, 1000000.0)
  UpDownCounter::add(basic_counter, -500000.0)
  
  // æµ‹è¯•å°æ•°æ“ä½œ
  UpDownCounter::add(basic_counter, 0.001)
  UpDownCounter::add(basic_counter, -0.0005)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "Gaugeè¯¦ç»†æ“ä½œæµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "gauge.test.meter")
  
  // æµ‹è¯•åŸºæœ¬çš„Gaugeåˆ›å»º
  let basic_gauge = Meter::create_gauge(meter, "basic.gauge")
  assert_eq(basic_gauge.name, "basic.gauge")
  assert_true(basic_gauge.description is None)
  assert_true(basic_gauge.unit is None)
  
  // æµ‹è¯•å¸¦æœ‰æè¿°å’Œå•ä½çš„Gauge
  let memory_gauge = Meter::create_gauge(
    meter, 
    "memory.usage", 
    Some("Current memory usage in bytes"), 
    Some("bytes")
  )
  assert_eq(memory_gauge.name, "memory.usage")
  match memory_gauge.description {
    Some(desc) => assert_eq(desc, "Current memory usage in bytes")
    None => assert_true(false)
  }
  match memory_gauge.unit {
    Some(unit) => assert_eq(unit, "bytes")
    None => assert_true(false)
  }
  
  // æµ‹è¯•CPUä½¿ç”¨ç‡Gauge
  let cpu_gauge = Meter::create_gauge(
    meter, 
    "cpu.usage", 
    Some("Current CPU usage percentage"), 
    Some("percent")
  )
  assert_eq(cpu_gauge.name, "cpu.usage")
  
  // æ¨¡æ‹Ÿè®¾ç½®Gaugeå€¼ï¼ˆé€šè¿‡addæ“ä½œï¼Œè™½ç„¶è¯­ä¹‰ä¸Šä¸å¤ªå‡†ç¡®ï¼‰
  Gauge::add(memory_gauge, 1024.0)  // 1KB
  Gauge::add(memory_gauge, 2048.0)  // 2KB
  Gauge::add(memory_gauge, 512.0)   // 512B
  
  Gauge::add(cpu_gauge, 25.5)       // 25.5%
  Gauge::add(cpu_gauge, 75.0)       // 75.0%
  Gauge::add(cpu_gauge, 100.0)      // 100.0%
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„Gaugeæ“ä½œ
  let attrs = Attributes::new()
  Attributes::set(attrs, "instance.id", StringValue("server-001"))
  Attributes::set(attrs, "region", StringValue("us-west-2"))
  
  Gauge::add(memory_gauge, 4096.0, Some(attrs))
  Gauge::add(cpu_gauge, 50.0, Some(attrs))
  
  // æµ‹è¯•è¾¹ç•Œå€¼
  Gauge::add(memory_gauge, 0.0)      // é›¶å€¼
  Gauge::add(cpu_gauge, 0.0)         // é›¶å€¼
  
  Gauge::add(memory_gauge, 9223372036854775807.0)  // æ¥è¿‘æœ€å¤§å€¼
  Gauge::add(cpu_gauge, 0.01)       // å°æ•°å€¼
  
  // æµ‹è¯•è´Ÿæ•°ï¼ˆè™½ç„¶æŸäº›Gaugeå¯èƒ½ä¸å…è®¸è´Ÿå€¼ï¼‰
  Gauge::add(memory_gauge, -1.0)    // è´Ÿæ•°æµ‹è¯•
  Gauge::add(cpu_gauge, -0.1)       // è´Ÿæ•°æµ‹è¯•
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "LoggerProviderå’ŒLoggerè¯¦ç»†æ“ä½œæµ‹è¯•" {
  // æµ‹è¯•LoggerProvideråˆ›å»º
  let noop_provider = LoggerProvider::noop()
  let default_provider = LoggerProvider::default()
  
  // æµ‹è¯•ä»ä¸åŒProviderè·å–Logger
  let noop_logger = LoggerProvider::get_logger(noop_provider, "noop.logger")
  let default_logger = LoggerProvider::get_logger(default_provider, "default.logger")
  
  // éªŒè¯Loggerçš„InstrumentationScope
  assert_eq(noop_logger.scope.name, "noop.logger")
  assert_eq(default_logger.scope.name, "default.logger")
  
  // æµ‹è¯•å¸¦æœ‰ç‰ˆæœ¬çš„Logger
  let versioned_logger = LoggerProvider::get_logger(
    default_provider, 
    "versioned.logger", 
    Some("1.2.3")
  )
  assert_eq(versioned_logger.scope.name, "versioned.logger")
  match versioned_logger.scope.version {
    Some(v) => assert_eq(v, "1.2.3")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ä¸åŒä¸¥é‡æ€§çº§åˆ«çš„LogRecord
  let trace_record = LogRecord::new(Trace, "Trace message for debugging")
  let debug_record = LogRecord::new(Debug, "Debug message with details")
  let info_record = LogRecord::new(Info, "Info message for general information")
  let warn_record = LogRecord::new(Warn, "Warning message for potential issues")
  let error_record = LogRecord::new(Error, "Error message for failures")
  let fatal_record = LogRecord::new(Fatal, "Fatal message for critical failures")
  
  // å‘é€ä¸åŒçº§åˆ«çš„æ—¥å¿—
  Logger::emit(noop_logger, trace_record)
  Logger::emit(noop_logger, debug_record)
  Logger::emit(noop_logger, info_record)
  Logger::emit(default_logger, warn_record)
  Logger::emit(default_logger, error_record)
  Logger::emit(versioned_logger, fatal_record)
  
  // æµ‹è¯•å¸¦æœ‰å±æ€§çš„å¤æ‚LogRecord
  let attrs = Attributes::new()
  Attributes::set(attrs, "user.id", StringValue("12345"))
  Attributes::set(attrs, "session.id", StringValue("session-67890"))
  Attributes::set(attrs, "request.id", StringValue("req-abcdef"))
  Attributes::set(attrs, "response.time", IntValue(150))
  Attributes::set(attrs, "success", BoolValue(true))
  
  let complex_record = LogRecord::new_with_context(
    Info,
    Some("User operation completed successfully"),
    Some(attrs),
    Some(Clock::now_unix_nanos(Clock::system())),
    Some(Clock::now_unix_nanos(Clock::system()) + 1000000L),
    Some("0af7651916cd43dd8448eb211c80319c"),
    Some("b7ad6b7169203331"),
    Some(Context::root())
  )
  
  Logger::emit(default_logger, complex_record)
  
  // æµ‹è¯•å¸¦æœ‰é”™è¯¯ä¸Šä¸‹æ–‡çš„LogRecord
  let error_attrs = Attributes::new()
  Attributes::set(error_attrs, "error.type", StringValue("DatabaseError"))
  Attributes::set(error_attrs, "error.message", StringValue("Connection timeout"))
  Attributes::set(error_attrs, "retry.count", IntValue(3))
  Attributes::set(error_attrs, "stack.trace", StringValue("at database.connect (line 42)"))
  
  let error_record = LogRecord::new_with_context(
    Error,
    Some("Database operation failed after 3 retries"),
    Some(error_attrs),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some("trace123"),
    Some("span456"),
    None
  )
  
  Logger::emit(default_logger, error_record)
  
  // æµ‹è¯•æ‰¹é‡æ—¥å¿—å‘é€
  for i in 0..10 {
    let batch_record = LogRecord::new_with_context(
      Info,
      Some("Batch log message " + i.to_string()),
      None,
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      None,
      None,
      None
    )
    Logger::emit(default_logger, batch_record)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "è·¨ç»„ä»¶é›†æˆæµ‹è¯•" {
  // åˆ›å»ºæ‰€æœ‰éœ€è¦çš„Provider
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  // åˆ›å»ºæ‰€æœ‰éœ€è¦çš„ç»„ä»¶
  let tracer = TracerProvider::get_tracer(tracer_provider, "integration.tracer", Some("1.0.0"))
  let meter = MeterProvider::get_meter(meter_provider, "integration.meter", Some("1.0.0"))
  let logger = LoggerProvider::get_logger(logger_provider, "integration.logger", Some("1.0.0"))
  
  // éªŒè¯æ‰€æœ‰ç»„ä»¶éƒ½æœ‰ç›¸åŒçš„InstrumentationScopeä¿¡æ¯
  assert_eq(tracer.scope.name, "integration.tracer")
  assert_eq(meter.scope.name, "integration.meter")
  assert_eq(logger.scope.name, "integration.logger")
  
  match tracer.scope.version {
    Some(v) => assert_eq(v, "1.0.0")
    None => assert_true(false)
  }
  
  // åˆ›å»ºSpanå¹¶è®°å½•æŒ‡æ ‡å’Œæ—¥å¿—
  let span = Tracer::start_span(tracer, "integration.operation")
  
  // åœ¨Spanæ“ä½œè¿‡ç¨‹ä¸­è®°å½•æŒ‡æ ‡
  let counter = Meter::create_counter(meter, "operations.total")
  let histogram = Meter::create_histogram(meter, "operation.duration")
  let updown_counter = Meter::create_updown_counter(meter, "active.operations")
  let gauge = Meter::create_gauge(meter, "memory.usage")
  
  Counter::add(counter, 1.0)
  Histogram::record(histogram, 150.0)
  UpDownCounter::add(updown_counter, 1.0)
  Gauge::add(gauge, 1024.0)
  
  // æ·»åŠ Spanäº‹ä»¶
  Span::add_event(span, "operation.started", Some([("timestamp", StringValue("now"))]))
  
  // è®°å½•æ—¥å¿—
  let start_log = LogRecord::new_with_context(
    Info,
    Some("Operation started"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(span.span_context)),
    Some(SpanContext::span_id(span.span_context)),
    None
  )
  Logger::emit(logger, start_log)
  
  // æ¨¡æ‹Ÿæ“ä½œè¿‡ç¨‹ä¸­çš„æ›´å¤šæŒ‡æ ‡è®°å½•
  Histogram::record(histogram, 200.0)
  Gauge::add(gauge, 2048.0)
  
  // æ·»åŠ æ›´å¤šSpanäº‹ä»¶
  Span::add_event(span, "database.query", Some([("query.time", IntValue(50))]))
  
  // è®°å½•æ›´å¤šæ—¥å¿—
  let progress_log = LogRecord::new_with_context(
    Debug,
    Some("Operation in progress"),
    Some([("progress", IntValue(50)]),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(span.span_context)),
    Some(SpanContext::span_id(span.span_context)),
    None
  )
  Logger::emit(logger, progress_log)
  
  // æ“ä½œå®Œæˆ
  Span::add_event(span, "operation.completed", Some([("success", BoolValue(true))]))
  Histogram::record(histogram, 300.0)
  UpDownCounter::add(updown_counter, -1.0)
  Gauge::add(gauge, 512.0)
  
  let completion_log = LogRecord::new_with_context(
    Info,
    Some("Operation completed successfully"),
    Some([("duration", IntValue(300)]),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(span.span_context)),
    Some(SpanContext::span_id(span.span_context)),
    None
  )
  Logger::emit(logger, completion_log)
  
  // è®¾ç½®SpançŠ¶æ€å¹¶ç»“æŸ
  Span::set_status(span, Ok)
  Span::end(span)
  
  // è®°å½•æœ€ç»ˆæŒ‡æ ‡
  Counter::add(counter, 1.0)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "Contextå’ŒPropagationé›†æˆæµ‹è¯•" {
  // åˆ›å»ºContextå’ŒBaggage
  let root_ctx = Context::root()
  let baggage = Baggage::new()
  
  // è®¾ç½®Contextå€¼
  let user_key = ContextKey::new("user.id")
  let session_key = ContextKey::new("session.id")
  let request_key = ContextKey::new("request.id")
  
  let ctx_with_user = Context::with_value(root_ctx, user_key, "user123")
  let ctx_with_session = Context::with_value(ctx_with_user, session_key, "session456")
  let ctx_with_request = Context::with_value(ctx_with_session, request_key, "req789")
  
  // è®¾ç½®Baggageæ¡ç›®
  let baggage1 = Baggage::set_entry(baggage, "user.role", StringValue("admin"))
  let baggage2 = Baggage::set_entry(baggage1, "tenant.id", StringValue("tenant123"))
  let final_baggage = Baggage::set_entry(baggage2, "feature.flags", StringValue("beta,experimental"))
  
  // åˆ›å»ºä¼ æ’­å™¨
  let trace_propagator = W3CTraceContextPropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  
  // åˆ›å»ºSpanContext
  let span_ctx = SpanContext::new(
    "0af7651916cd43dd8448eb211c80319c",
    "b7ad6b7169203331",
    true,
    "rojo=00f067aa0ba902b7"
  )
  
  // æ³¨å…¥Contextåˆ°è½½ä½“
  let carrier = TextMapCarrier::new()
  CompositePropagator::inject(composite, ctx_with_request, carrier)
  
  // æ‰‹åŠ¨æ·»åŠ ä¸€äº›å¤´éƒ¨ä»¥æ¨¡æ‹Ÿå®Œæ•´çš„ä¼ æ’­
  TextMapCarrier::set(carrier, "baggage", "user.role=admin,tenant.id=tenant123,feature.flags=beta,experimental")
  TextMapCarrier::set(carrier, "x-request-id", "req789")
  
  // éªŒè¯æ³¨å…¥çš„å¤´éƒ¨
  let traceparent = TextMapCarrier::get(carrier, "traceparent")
  assert_true(traceparent is Some)
  
  let baggage_header = TextMapCarrier::get(carrier, "baggage")
  match baggage_header {
    Some(value) => assert_true(value.contains("user.role=admin"))
    None => assert_true(false)
  }
  
  // ä»è½½ä½“ä¸­æå–Context
  let extracted_ctx = CompositePropagator::extract(composite, carrier)
  
  // éªŒè¯æå–çš„Context
  let extracted_user = Context::get(extracted_ctx, ContextKey::new("extracted"))
  match extracted_user {
    Some(value) => assert_eq(value, "true")
    None => assert_true(false)
  }
  
  // åˆ›å»ºæ–°çš„Spanå¹¶ä½¿ç”¨æå–çš„Context
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "propagation.test")
  let span = Tracer::start_span(tracer, "propagation.operation")
  
  // åœ¨Spanä¸­è®°å½•Contextä¿¡æ¯
  Span::add_event(span, "context.extracted", Some([
    ("user.id", StringValue("user123")),
    ("session.id", StringValue("session456")),
    ("request.id", StringValue("req789"))
  ]))
  
  // è®°å½•å¸¦æœ‰Contextçš„æ—¥å¿—
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "propagation.logger")
  
  let context_log = LogRecord::new_with_context(
    Info,
    Some("Context propagation test"),
    Some([
      ("user.role", StringValue("admin")),
      ("tenant.id", StringValue("tenant123")),
      ("feature.flags", StringValue("beta,experimental"))
    ]),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(span.span_context)),
    Some(SpanContext::span_id(span.span_context)),
    Some(extracted_ctx)
  )
  
  Logger::emit(logger, context_log)
  
  Span::end(span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "é”™è¯¯å¤„ç†å’Œå¼‚å¸¸æƒ…å†µæµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’ŒNoneå€¼çš„å¤„ç†
  let empty_name_scope = InstrumentationScope::{ 
    name: "", 
    version: None, 
    schema_url: None 
  }
  assert_eq(empty_name_scope.name, "")
  
  let empty_version_scope = InstrumentationScope::{ 
    name: "test.scope", 
    version: Some(""), 
    schema_url: None 
  }
  match empty_version_scope.version {
    Some(v) => assert_eq(v, "")
    None => assert_true(false)
  }
  
  // æµ‹è¯•æå€¼å±æ€§
  let attrs = Attributes::new()
  Attributes::set(attrs, "max.int", IntValue(2147483647))
  Attributes::set(attrs, "min.int", IntValue(-2147483648))
  Attributes::set(attrs, "max.float", FloatValue(1.7976931348623157e+308))
  Attributes::set(attrs, "min.float", FloatValue(-1.7976931348623157e+308))
  Attributes::set(attrs, "zero.float", FloatValue(0.0))
  Attributes::set(attrs, "negative.zero", FloatValue(-0.0))
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  Attributes::set(attrs, "infinity", FloatValue(1.0/0.0))
  Attributes::set(attrs, "negative.infinity", FloatValue(-1.0/0.0))
  Attributes::set(attrs, "nan", FloatValue(0.0/0.0))
  
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let very_long_string = "a" * 10000
  Attributes::set(attrs, "long.string", StringValue(very_long_string))
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = ArrayStringValue([])
  let empty_int_array = ArrayIntValue([])
  Attributes::set(attrs, "empty.string.array", empty_string_array)
  Attributes::set(attrs, "empty.int.array", empty_int_array)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "ç‰¹æ®Šå­—ç¬¦!@#$%^&*(){}[]|\\:;\"'<>?,./"
  Attributes::set(attrs, "special.chars", StringValue(special_chars))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•ğŸš€emojiå’Œä¸­æ–‡æ··åˆğŸŒŸ"
  Attributes::set(attrs, "unicode", StringValue(unicode_string))
  
  // æµ‹è¯•æ— æ•ˆçš„SpanContext
  let invalid_ctx1 = SpanContext::new("", "", false, "")
  let invalid_ctx2 = SpanContext::new("trace", "", true, "")
  let invalid_ctx3 = SpanContext::new("", "span", true, "")
  
  assert_false(SpanContext::is_valid(invalid_ctx1))
  assert_false(SpanContext::is_valid(invalid_ctx2))
  assert_false(SpanContext::is_valid(invalid_ctx3))
  
  // æµ‹è¯•ç©ºLogRecord
  let empty_log = LogRecord::new_with_context(
    Info,
    None,
    None,
    None,
    None,
    None,
    None,
    None
  )
  match LogRecord::body(empty_log) {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
  
  // æµ‹è¯•è¾¹ç•Œæƒ…å†µçš„æŒ‡æ ‡å€¼
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary.test")
  
  let counter = Meter::create_counter(meter, "boundary.counter")
  let histogram = Meter::create_histogram(meter, "boundary.histogram")
  let updown_counter = Meter::create_updown_counter(meter, "boundary.updown")
  let gauge = Meter::create_gauge(meter, "boundary.gauge")
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(counter, 1.7976931348623157e+308)
  Histogram::record(histogram, 1.7976931348623157e+308)
  UpDownCounter::add(updown_counter, 1.7976931348623157e+308)
  Gauge::add(gauge, 1.7976931348623157e+308)
  
  // æµ‹è¯•æå°å€¼
  Counter::add(counter, 4.940656458412465e-324)
  Histogram::record(histogram, 4.940656458412465e-324)
  UpDownCounter::add(updown_counter, 4.940656458412465e-324)
  Gauge::add(gauge, 4.940656458412465e-324)
  
  // æµ‹è¯•è´Ÿå€¼
  UpDownCounter::add(updown_counter, -1.7976931348623157e+308)
  Gauge::add(gauge, -1.7976931348623157e+308)
  
  // æµ‹è¯•é›¶å€¼
  Counter::add(counter, 0.0)
  Histogram::record(histogram, 0.0)
  UpDownCounter::add(updown_counter, 0.0)
  Gauge::add(gauge, 0.0)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "æ€§èƒ½å’Œèµ„æºç®¡ç†æµ‹è¯•" {
  // æµ‹è¯•å¤§é‡Spanåˆ›å»ºå’Œé”€æ¯
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "performance.test")
  
  for i in 0..100 {
    let span = Tracer::start_span(tracer, "perf.span." + i.to_string())
    Span::add_event(span, "event." + i.to_string(), None)
    Span::set_status(span, Ok)
    Span::end(span)
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§æ“ä½œ
  let attrs = Attributes::new()
  for i in 0..100 {
    Attributes::set(attrs, "key." + i.to_string(), StringValue("value." + i.to_string()))
  }
  
  // æµ‹è¯•å¤§é‡æŒ‡æ ‡è®°å½•
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "perf.meter")
  
  let counter = Meter::create_counter(meter, "perf.counter")
  let histogram = Meter::create_histogram(meter, "perf.histogram")
  let updown_counter = Meter::create_updown_counter(meter, "perf.updown")
  let gauge = Meter::create_gauge(meter, "perf.gauge")
  
  for i in 0..100 {
    Counter::add(counter, i.to_double())
    Histogram::record(histogram, i.to_double() * 1.5)
    UpDownCounter::add(updown_counter, i.to_double() - 50.0)
    Gauge::add(gauge, i.to_double() * 10.0)
  }
  
  // æµ‹è¯•å¤§é‡æ—¥å¿—è®°å½•
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "perf.logger")
  
  for i in 0..100 {
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Performance log message " + i.to_string()),
      Some([("iteration", IntValue(i))]),
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      None,
      None,
      None
    )
    Logger::emit(logger, log_record)
  }
  
  // æµ‹è¯•å¤§é‡Baggageæ“ä½œ
  let baggage = Baggage::new()
  for i in 0..100 {
    baggage = Baggage::set_entry(baggage, "baggage.key." + i.to_string(), "baggage.value." + i.to_string())
  }
  
  // æµ‹è¯•å¤§é‡Contextæ“ä½œ
  let ctx = Context::root()
  for i in 0..100 {
    let key = ContextKey::new("context.key." + i.to_string())
    ctx = Context::with_value(ctx, key, "context.value." + i.to_string())
  }
  
  // æµ‹è¯•å¤§é‡TextMapCarrieræ“ä½œ
  let carrier = TextMapCarrier::new()
  for i in 0..100 {
    TextMapCarrier::set(carrier, "header." + i.to_string(), "value." + i.to_string())
  }
  
  // æµ‹è¯•å¤§é‡Propagationæ“ä½œ
  let trace_propagator = W3CTraceContextPropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  
  for i in 0..100 {
    let test_carrier = TextMapCarrier::new()
    TextMapCarrier::set(test_carrier, "traceparent", "00-trace" + i.to_string() + "-span" + i.to_string() + "-01")
    let extracted_ctx = CompositePropagator::extract(composite, test_carrier)
    CompositePropagator::inject(composite, extracted_ctx, test_carrier)
  }
  
  // æµ‹è¯•å¤§é‡Resourceæ“ä½œ
  let resource = Resource::new()
  let mut resource_attrs = []
  for i in 0..100 {
    resource_attrs = resource_attrs.push(("resource.key." + i.to_string(), StringValue("resource.value." + i.to_string())))
  }
  let resource_with_attrs = Resource::with_attributes(resource, resource_attrs)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "å¤šçº¿ç¨‹å¹¶å‘å®‰å…¨æ€§æ¨¡æ‹Ÿæµ‹è¯•" {
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œçš„æµ‹è¯•ï¼ˆå•çº¿ç¨‹ç¯å¢ƒä¸­æ¨¡æ‹Ÿå¹¶å‘åœºæ™¯ï¼‰
  
  // åˆ›å»ºå…±äº«èµ„æº
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrent.test")
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "concurrent.meter")
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "concurrent.logger")
  
  // åˆ›å»ºå¤šä¸ªSpanï¼ˆæ¨¡æ‹Ÿå¹¶å‘ï¼‰
  let spans = []
  for i in 0..10 {
    spans = spans.push(Tracer::start_span(tracer, "concurrent.span." + i.to_string()))
  }
  
  // å¹¶å‘æ“ä½œæŒ‡æ ‡
  let counter = Meter::create_counter(meter, "concurrent.counter")
  let histogram = Meter::create_histogram(meter, "concurrent.histogram")
  let updown_counter = Meter::create_updown_counter(meter, "concurrent.updown")
  let gauge = Meter::create_gauge(meter, "concurrent.gauge")
  
  // æ¨¡æ‹Ÿå¹¶å‘æŒ‡æ ‡æ“ä½œ
  for i in 0..10 {
    Counter::add(counter, i.to_double())
    Histogram::record(histogram, i.to_double() * 100.0)
    UpDownCounter::add(updown_counter, 1.0)
    Gauge::add(gauge, i.to_double() * 1024.0)
  }
  
  // ä¸ºæ¯ä¸ªSpanæ·»åŠ äº‹ä»¶ï¼ˆæ¨¡æ‹Ÿå¹¶å‘æ“ä½œï¼‰
  for i in 0..10 {
    match spans[i] {
      Some(span) => {
        Span::add_event(span, "concurrent.event." + i.to_string(), Some([
          ("thread.id", IntValue(i)),
          ("timestamp", StringValue("now"))
        ]))
        Span::set_status(span, Ok)
      }
      None => ()
    }
  }
  
  // å¹¶å‘æ—¥å¿—è®°å½•
  for i in 0..10 {
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Concurrent log message " + i.to_string()),
      Some([
        ("thread.id", IntValue(i)),
        ("operation", StringValue("concurrent.test"))
      ]),
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      Some("concurrent.trace.id"),
      Some("concurrent.span.id." + i.to_string()),
      None
    )
    Logger::emit(logger, log_record)
  }
  
  // ç»“æŸæ‰€æœ‰Spanï¼ˆæ¨¡æ‹Ÿå¹¶å‘æ¸…ç†ï¼‰
  for i in 0..10 {
    match spans[i] {
      Some(span) => Span::end(span)
      None => ()
    }
  }
  
  // æ¨¡æ‹Ÿå¹¶å‘Baggageæ“ä½œ
  let baggage = Baggage::new()
  for i in 0..10 {
    baggage = Baggage::set_entry(baggage, "concurrent.key." + i.to_string(), "concurrent.value." + i.to_string())
  }
  
  // æ¨¡æ‹Ÿå¹¶å‘Contextæ“ä½œ
  let ctx = Context::root()
  for i in 0..10 {
    let key = ContextKey::new("concurrent.context." + i.to_string())
    ctx = Context::with_value(ctx, key, "concurrent.value." + i.to_string())
  }
  
  // æ¨¡æ‹Ÿå¹¶å‘Propagationæ“ä½œ
  let trace_propagator = W3CTraceContextPropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  
  for i in 0..10 {
    let carrier = TextMapCarrier::new()
    TextMapCarrier::set(carrier, "traceparent", "00-concurrent.trace-" + i.to_string() + "-concurrent.span-" + i.to_string() + "-01")
    let extracted_ctx = CompositePropagator::extract(composite, carrier)
    CompositePropagator::inject(composite, extracted_ctx, carrier)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}