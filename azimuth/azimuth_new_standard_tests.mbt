// æ–°å¢çš„ MoonBit æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–å„ç§åœºæ™¯å’Œè¾¹ç•Œæ¡ä»¶

test "advanced_arithmetic_sequences" {
  // æµ‹è¯•é«˜çº§ç®—æœ¯åºåˆ—è®¡ç®—
  // åœºæ™¯ï¼šè®¡ç®—ç­‰å·®æ•°åˆ—å’Œç­‰æ¯”æ•°åˆ—
  
  // ç­‰å·®æ•°åˆ—ï¼š3, 7, 11, 15, 19 (å…¬å·®ä¸º4)
  let arithmetic_sum = add(add(add(3, 7), add(11, 15)), 19)
  assert_eq(55, arithmetic_sum)
  
  // ç­‰æ¯”æ•°åˆ—ï¼š2, 4, 8, 16, 32 (å…¬æ¯”ä¸º2)
  let geometric_sum = add(add(add(2, 4), add(8, 16)), 32)
  assert_eq(62, geometric_sum)
  
  // éªŒè¯æ•°åˆ—å…³ç³»
  let arithmetic_avg = divide_with_ceil(arithmetic_sum, 5)
  let geometric_avg = divide_with_ceil(geometric_sum, 5)
  assert_eq(11, arithmetic_avg)  // ceil(55/5) = 11
  assert_eq(13, geometric_avg)   // ceil(62/5) = 13
}

test "inventory_optimization_algorithm" {
  // åº“å­˜ä¼˜åŒ–ç®—æ³•æµ‹è¯•
  // åœºæ™¯ï¼šå¤šä»“åº“åº“å­˜åˆ†é…ä¼˜åŒ–
  
  // ä»“åº“Aï¼šå®¹é‡150ï¼Œå½“å‰åº“å­˜120
  // ä»“åº“Bï¼šå®¹é‡200ï¼Œå½“å‰åº“å­˜180
  // ä»“åº“Cï¼šå®¹é‡100ï¼Œå½“å‰åº“å­˜70
  // æ–°åˆ°è´§ç‰©ï¼š95ä»¶
  
  let warehouse_a_capacity = 150
  let warehouse_a_current = 120
  let warehouse_a_remaining = subtract(warehouse_a_capacity, warehouse_a_current)
  
  let warehouse_b_capacity = 200
  let warehouse_b_current = 180
  let warehouse_b_remaining = subtract(warehouse_b_capacity, warehouse_b_current)
  
  let warehouse_c_capacity = 100
  let warehouse_c_current = 70
  let warehouse_c_remaining = subtract(warehouse_c_capacity, warehouse_c_current)
  
  let new_inventory = 95
  let total_remaining = add(add(warehouse_a_remaining, warehouse_b_remaining), warehouse_c_remaining)
  
  // ä¼˜åŒ–åˆ†é…ç­–ç•¥ï¼šä¼˜å…ˆåˆ†é…ç»™å‰©ä½™ç©ºé—´å¤šçš„ä»“åº“
  let allocation_a = divide_with_ceil(multiply(new_inventory, warehouse_a_remaining), total_remaining)
  let allocation_b = divide_with_ceil(multiply(new_inventory, warehouse_b_remaining), total_remaining)
  let allocation_c = subtract(new_inventory, add(allocation_a, allocation_b))
  
  assert_eq(23, allocation_a)  // ceil(95*30/80) = 36
  assert_eq(47, allocation_b)  // ceil(95*20/80) = 24
  assert_eq(25, allocation_c)  // 95 - (36+24) = 35
}

test "time_complexity_validation" {
  // æ—¶é—´å¤æ‚åº¦éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ç‰¹å¾
  
  let input_sizes = [10, 100, 1000]
  
  // O(1) å¸¸æ•°æ—¶é—´ç®—æ³•
  let constant_time_10 = 5
  let constant_time_100 = 5
  let constant_time_1000 = 5
  
  // O(n) çº¿æ€§æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿ
  let linear_time_10 = multiply(10, 2)
  let linear_time_100 = multiply(100, 2)
  let linear_time_1000 = multiply(1000, 2)
  
  // O(log n) å¯¹æ•°æ—¶é—´ç®—æ³•æ¨¡æ‹Ÿï¼ˆç®€åŒ–ï¼‰
  let log_time_10 = divide_with_ceil(10, 3)
  let log_time_100 = divide_with_ceil(100, 3)
  let log_time_1000 = divide_with_ceil(1000, 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(5, constant_time_10)
  assert_eq(5, constant_time_100)
  assert_eq(5, constant_time_1000)
  
  assert_eq(20, linear_time_10)
  assert_eq(200, linear_time_100)
  assert_eq(2000, linear_time_1000)
  
  assert_eq(4, log_time_10)
  assert_eq(34, log_time_100)
  assert_eq(334, log_time_1000)
}

test "financial_compound_interest_calculation" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šè®¡ç®—ä¸åŒå¤åˆ©å‘¨æœŸçš„æŠ•èµ„æ”¶ç›Š
  
  let principal = 10000
  let annual_rate = 6  // 6%å¹´åˆ©ç‡
  let years = 5
  
  // å¹´å¤åˆ©è®¡ç®—
  let yearly_year1 = add(principal, divide_with_ceil(multiply(principal, annual_rate), 100))
  let yearly_year2 = add(yearly_year1, divide_with_ceil(multiply(yearly_year1, annual_rate), 100))
  let yearly_year3 = add(yearly_year2, divide_with_ceil(multiply(yearly_year2, annual_rate), 100))
  let yearly_final = add(add(add(yearly_year3, divide_with_ceil(multiply(yearly_year3, annual_rate), 100)), 
                          add(divide_with_ceil(multiply(add(yearly_year3, divide_with_ceil(multiply(yearly_year3, annual_rate), 100)), annual_rate), 100), 
                              divide_with_ceil(multiply(add(add(yearly_year3, divide_with_ceil(multiply(yearly_year3, annual_rate), 100)), 
                                                          divide_with_ceil(multiply(add(yearly_year3, divide_with_ceil(multiply(yearly_year3, annual_rate), 100)), annual_rate), 100)), annual_rate), 100)))
  
  // éªŒè¯å¤åˆ©å¢é•¿
  assert_eq(10600, yearly_year1)  // ç¬¬ä¸€å¹´ï¼š10000 + 6%
  assert_eq(11236, yearly_year2)  // ç¬¬äºŒå¹´ï¼š10600 + 6%
  assert_eq(11910, yearly_year3)  // ç¬¬ä¸‰å¹´ï¼š11236 + 6%
  
  // è®¡ç®—æœˆä¾›ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
  let total_months = multiply(years, 12)
  let monthly_payment = divide_with_ceil(yearly_final, total_months)
  assert_eq(198, monthly_payment)  // ceil(final_amount/60)
}

test "data_structure_performance_analysis" {
  // æ•°æ®ç»“æ„æ€§èƒ½åˆ†ææµ‹è¯•
  // æ¨¡æ‹Ÿä¸åŒæ•°æ®ç»“æ„çš„æ“ä½œæ€§èƒ½
  
  let operations = 1000
  
  // æ•°ç»„æ“ä½œæ¨¡æ‹Ÿï¼ˆéšæœºè®¿é—®O(1)ï¼‰
  let array_access_time = 1
  let total_array_time = multiply(operations, array_access_time)
  
  // é“¾è¡¨æ“ä½œæ¨¡æ‹Ÿï¼ˆé¡ºåºè®¿é—®O(n)ï¼‰
  let linked_list_access_time = divide_with_ceil(operations, 2)
  let total_linked_list_time = multiply(operations, linked_list_access_time)
  
  // æ ‘æ“ä½œæ¨¡æ‹Ÿï¼ˆå¹³è¡¡æ ‘O(log n)ï¼‰
  let tree_access_time = divide_with_ceil(operations, 10)
  let total_tree_time = multiply(operations, tree_access_time)
  
  // æ€§èƒ½æ¯”è¾ƒ
  assert_eq(1000, total_array_time)
  assert_eq(500000, total_linked_list_time)
  assert_eq(100000, total_tree_time)
  
  // è®¡ç®—æ€§èƒ½æ¯”ç‡
  let array_vs_tree = divide_with_ceil(total_tree_time, total_array_time)
  let linked_list_vs_tree = divide_with_ceil(total_linked_list_time, total_tree_time)
  
  assert_eq(100, array_vs_tree)
  assert_eq(5, linked_list_vs_tree)
}

test "resource_scheduling_algorithm" {
  // èµ„æºè°ƒåº¦ç®—æ³•æµ‹è¯•
  // åœºæ™¯ï¼šå¤šä»»åŠ¡å¤„ç†å™¨è°ƒåº¦ä¼˜åŒ–
  
  let tasks = [25, 40, 15, 30, 20]  // ä»»åŠ¡æ‰§è¡Œæ—¶é—´
  let processors = 3
  let time_quantum = 10
  
  // ç®€åŒ–çš„è½®è½¬è°ƒåº¦æ¨¡æ‹Ÿ
  let task1_quanta = divide_with_ceil(25, time_quantum)
  let task2_quanta = divide_with_ceil(40, time_quantum)
  let task3_quanta = divide_with_ceil(15, time_quantum)
  let task4_quanta = divide_with_ceil(30, time_quantum)
  let task5_quanta = divide_with_ceil(20, time_quantum)
  
  let total_quanta = add(add(add(add(task1_quanta, task2_quanta), task3_quanta), task4_quanta), task5_quanta)
  let scheduling_rounds = divide_with_ceil(total_quanta, processors)
  
  assert_eq(3, task1_quanta)   // ceil(25/10) = 3
  assert_eq(4, task2_quanta)   // ceil(40/10) = 4
  assert_eq(2, task3_quanta)   // ceil(15/10) = 2
  assert_eq(3, task4_quanta)   // ceil(30/10) = 3
  assert_eq(2, task5_quanta)   // ceil(20/10) = 2
  
  assert_eq(14, total_quanta)  // 3+4+2+3+2 = 14
  assert_eq(5, scheduling_rounds)  // ceil(14/3) = 5
}

test "error_recovery_and_robustness" {
  // é”™è¯¯æ¢å¤å’Œå¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•ç³»ç»Ÿåœ¨å„ç§å¼‚å¸¸æƒ…å†µä¸‹çš„è¡¨ç°
  
  // é™¤é›¶é”™è¯¯çš„å¤šç§å¤„ç†æ–¹å¼
  let normal_division = divide_with_ceil(100, 25)
  let zero_division_1 = divide_with_ceil(100, 0)
  let zero_division_2 = divide_with_ceil(0, 0)
  let zero_division_3 = divide_with_ceil(-100, 0)
  
  // æå€¼æµ‹è¯•
  let max_safe_division = divide_with_ceil(2147483647, 1)
  let min_safe_division = divide_with_ceil(-2147483648, 1)
  
  // éªŒè¯é”™è¯¯å¤„ç†
  assert_eq(4, normal_division)
  assert_eq(0, zero_division_1)
  assert_eq(0, zero_division_2)
  assert_eq(0, zero_division_3)
  assert_eq(2147483647, max_safe_division)
  assert_eq(-2147483648, min_safe_division)
  
  // çº§è”é”™è¯¯æ¢å¤æµ‹è¯•
  let step1 = add(10, divide_with_ceil(20, 0))  // 10 + 0 = 10
  let step2 = multiply(step1, 5)  // 10 * 5 = 50
  let step3 = divide_with_ceil(step2, 25)  // ceil(50/25) = 2
  
  assert_eq(10, step1)
  assert_eq(50, step2)
  assert_eq(2, step3)
}

test "string_processing_advanced_patterns" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æ¨¡å¼æµ‹è¯•
  // æµ‹è¯•å„ç§å­—ç¬¦ä¸²å¤„ç†åœºæ™¯
  
  // åŸºæœ¬å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, empty!", greet(""))
  assert_eq_string("Hello, space test!", greet("space test"))
  
  // ç‰¹æ®Šå­—ç¬¦å’Œç¼–ç æµ‹è¯•
  assert_eq_string("Hello, æ–°å¹´å¿«ä¹!", greet("æ–°å¹´å¿«ä¹"))
  assert_eq_string("Hello, emoji ğŸŠ!", greet("emoji ğŸŠ"))
  assert_eq_string("Hello, math Ï€â‰ˆ3.14!", greet("math Ï€â‰ˆ3.14"))
  assert_eq_string("Hello, symbols @#$%!", greet("symbols @#$%"))
  
  // è¾¹ç•Œæƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, 123456789!", greet("123456789"))
  assert_eq_string("Hello, MixedCase!", greet("MixedCase"))
  assert_eq_string("Hello,   spaces   !", greet("   spaces   "))
}

test "mathematical_series_convergence" {
  // æ•°å­¦çº§æ•°æ”¶æ•›æ€§æµ‹è¯•
  // æµ‹è¯•ä¸åŒæ•°å­¦çº§æ•°çš„æ”¶æ•›ç‰¹æ€§
  
  // è°ƒå’Œçº§æ•°å‰né¡¹å’Œçš„è¿‘ä¼¼è®¡ç®—
  let harmonic_n1 = 1
  let harmonic_n2 = add(harmonic_n1, divide_with_ceil(2, 2))  // 1 + 1
  let harmonic_n3 = add(harmonic_n2, divide_with_ceil(3, 3))  // 2 + 1
  let harmonic_n4 = add(harmonic_n3, divide_with_ceil(4, 4))  // 3 + 1
  let harmonic_n5 = add(harmonic_n4, divide_with_ceil(5, 5))  // 4 + 1
  
  // å‡ ä½•çº§æ•°æ±‚å’Œ (1/2 + 1/4 + 1/8 + 1/16 + 1/32)
  let geometric_term1 = divide_with_ceil(1, 2)
  let geometric_term2 = divide_with_ceil(1, 4)
  let geometric_term3 = divide_with_ceil(1, 8)
  let geometric_term4 = divide_with_ceil(1, 16)
  let geometric_term5 = divide_with_ceil(1, 32)
  let geometric_sum = add(add(add(add(geometric_term1, geometric_term2), geometric_term3), geometric_term4), geometric_term5)
  
  // éªŒè¯çº§æ•°æ€§è´¨
  assert_eq(1, harmonic_n1)
  assert_eq(2, harmonic_n2)
  assert_eq(3, harmonic_n3)
  assert_eq(4, harmonic_n4)
  assert_eq(5, harmonic_n5)
  
  assert_eq(1, geometric_term1)  // ceil(0.5) = 1
  assert_eq(1, geometric_term2)  // ceil(0.25) = 1
  assert_eq(1, geometric_term3)  // ceil(0.125) = 1
  assert_eq(1, geometric_term4)  // ceil(0.0625) = 1
  assert_eq(1, geometric_term5)  // ceil(0.03125) = 1
  assert_eq(5, geometric_sum)    // 1+1+1+1+1 = 5
}

test "real_world_business_intelligence" {
  // çœŸå®ä¸–ç•Œå•†ä¸šæ™ºèƒ½æµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†é”€å”®æ•°æ®åˆ†æå’Œé¢„æµ‹
  
  // äº§å“é”€å”®æ•°æ®ï¼ˆå­£åº¦ï¼‰
  let product_a_q1 = 1200
  let product_a_q2 = 1350
  let product_a_q3 = 1480
  let product_a_q4 = 1620
  
  let product_b_q1 = 800
  let product_b_q2 = 920
  let product_b_q3 = 1050
  let product_b_q4 = 1180
  
  // è®¡ç®—å¹´åº¦æ€»é”€å”®é¢
  let product_a_yearly = add(add(add(product_a_q1, product_a_q2), product_a_q3), product_a_q4)
  let product_b_yearly = add(add(add(product_b_q1, product_b_q2), product_b_q3), product_b_q4)
  let total_yearly_sales = add(product_a_yearly, product_b_yearly)
  
  // è®¡ç®—å¢é•¿ç‡
  let product_a_growth = subtract(product_a_q4, product_a_q1)
  let product_b_growth = subtract(product_b_q4, product_b_q1)
  let total_growth = add(product_a_growth, product_b_growth)
  
  // é¢„æµ‹ä¸‹ä¸€å¹´åº¦é”€å”®ï¼ˆç®€åŒ–æ¨¡å‹ï¼šåŸºäºå¢é•¿ç‡ï¼‰
  let growth_rate = divide_with_ceil(multiply(total_growth, 100), total_yearly_sales)
  let predicted_next_year = add(total_yearly_sales, divide_with_ceil(multiply(total_yearly_sales, growth_rate), 100))
  
  // åº“å­˜è§„åˆ’è®¡ç®—
  let average_monthly_sales = divide_with_ceil(total_yearly_sales, 12)
  let safety_stock_months = 2
  let safety_stock_level = multiply(average_monthly_sales, safety_stock_months)
  
  assert_eq(5650, product_a_yearly)
  assert_eq(3950, product_b_yearly)
  assert_eq(9600, total_yearly_sales)
  assert_eq(1050, total_growth)
  assert_eq(11, growth_rate)  // ceil(1050*100/9600) = 11
  assert_eq(10656, predicted_next_year)  // 9600 + ceil(9600*11/100)
  assert_eq(1600, average_monthly_sales)  // ceil(9600/12)
  assert_eq(3200, safety_stock_level)  // 1600 * 2
}