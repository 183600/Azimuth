// Focused Advanced Test Suite for Azimuth Telemetry System
// ä¸“æ³¨çš„é«˜çº§æµ‹è¯•å¥—ä»¶

// æµ‹è¯•ç”¨ä¾‹1: å¤åˆä¼ æ’­åœºæ™¯æµ‹è¯•
test "composite_propagation_multi_scenario_test" {
  // åˆ›å»ºå¤šä¸ªä¼ æ’­å™¨ç»„æˆçš„å¤åˆä¼ æ’­å™¨
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  let composite = CompositePropagator::new([trace_propagator])
  
  // åˆ›å»ºåŸå§‹ä¸Šä¸‹æ–‡
  let root_ctx = Context::root()
  let ctx_with_data = Context::with_value(root_ctx, ContextKey::new("user.id"), "12345")
  
  // åˆ›å»ºè½½ä½“å¹¶æ³¨å…¥æ•°æ®
  let carrier = TextMapCarrier::new()
  CompositePropagator::inject(composite, ctx_with_data, carrier)
  
  // éªŒè¯æ³¨å…¥çš„æ•°æ®
  let injected_trace = TextMapCarrier::get(carrier, "traceparent")
  assert_true(injected_trace is Some)
  
  // æµ‹è¯•æå–åŠŸèƒ½
  let extracted_ctx = CompositePropagator::extract(composite, carrier)
  let extracted_value = Context::get(extracted_ctx, ContextKey::new("extracted"))
  assert_true(extracted_value is Some)
  
  // æµ‹è¯•å¤šå±‚ä¼ æ’­
  let carrier2 = TextMapCarrier::new()
  CompositePropagator::inject(composite, extracted_ctx, carrier2)
  let extracted_ctx2 = CompositePropagator::extract(composite, carrier2)
  let extracted_value2 = Context::get(extracted_ctx2, ContextKey::new("extracted"))
  assert_true(extracted_value2 is Some)
}

// æµ‹è¯•ç”¨ä¾‹2: æ—¶åºä¸€è‡´æ€§æµ‹è¯•
test "temporal_consistency_across_components" {
  let clock = Clock::system()
  let base_time = Clock::now_unix_nanos(clock)
  
  // åˆ›å»ºå¤šä¸ªæ—¶é—´æˆ³ç›¸å…³çš„ç»„ä»¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "temporal.test")
  let span = Tracer::start_span(tracer, "temporal.span")
  
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "temporal.meter")
  let counter = Meter::create_counter(meter, "temporal.counter")
  
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "temporal.logger")
  
  // è®°å½•æ“ä½œæ—¶é—´åºåˆ—
  let span_start_time = Clock::now_unix_nanos(clock)
  Counter::add(counter, 1.0)
  let metric_time = Clock::now_unix_nanos(clock)
  
  let log_record = LogRecord::new_with_context(
    Info,
    Some("Temporal consistency test"),
    None,
    Some(metric_time),
    None,
    Some(SpanContext::trace_id(Span::span_context(span))),
    Some(SpanContext::span_id(Span::span_context(span))),
    Some(Context::root())
  )
  let log_time = Clock::now_unix_nanos(clock)
  
  // éªŒè¯æ—¶é—´åºåˆ—çš„åˆç†æ€§
  assert_true(base_time <= span_start_time)
  assert_true(span_start_time <= metric_time)
  assert_true(metric_time <= log_time)
  
  // éªŒè¯æ—¶é—´æˆ³åœ¨åˆç†èŒƒå›´å†…ï¼ˆä¸èƒ½æ˜¯æœªæ¥æ—¶é—´ï¼‰
  let current_time = Clock::now_unix_nanos(clock)
  assert_true(log_time <= current_time)
  
  Span::end(span)
}

// æµ‹è¯•ç”¨ä¾‹3: èµ„æºå±‚æ¬¡ç»“æ„æµ‹è¯•
test "resource_hierarchy_and_merge_semantics" {
  // åˆ›å»ºåŸºç¡€èµ„æº
  let base_resource = Resource::new()
  let base_attrs = [
    ("service.name", StringValue("azimuth.telemetry")),
    ("service.version", StringValue("1.0.0")),
    ("deployment.environment", StringValue("production"))
  ]
  let base_with_attrs = Resource::with_attributes(base_resource, base_attrs)
  
  // åˆ›å»ºè¦†ç›–èµ„æº
  let override_resource = Resource::new()
  let override_attrs = [
    ("service.instance.id", StringValue("instance-123")),
    ("host.name", StringValue("production-server-01")),
    ("service.version", StringValue("1.0.1")) // è¦†ç›–ç‰ˆæœ¬
  ]
  let override_with_attrs = Resource::with_attributes(override_resource, override_attrs)
  
  // æµ‹è¯•èµ„æºåˆå¹¶
  let merged_resource = Resource::merge(base_with_attrs, override_with_attrs)
  
  // éªŒè¯åˆå¹¶åçš„å±æ€§
  let service_name = Resource::get_attribute(merged_resource, "service.name")
  assert_true(service_name is Some)
  match service_name {
    Some(StringValue(name)) => assert_eq(name, "azimuth.telemetry")
    _ => assert_true(false)
  }
  
  let instance_id = Resource::get_attribute(merged_resource, "service.instance.id")
  assert_true(instance_id is Some)
  match instance_id {
    Some(StringValue(id)) => assert_eq(id, "instance-123")
    _ => assert_true(false)
  }
  
  // éªŒè¯ç‰ˆæœ¬è¢«æ­£ç¡®è¦†ç›–
  let version = Resource::get_attribute(merged_resource, "service.version")
  assert_true(version is Some)
  match version {
    Some(StringValue(v)) => assert_eq(v, "1.0.1") // åº”è¯¥æ˜¯è¦†ç›–åçš„ç‰ˆæœ¬
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„å±æ€§
  let non_existent = Resource::get_attribute(merged_resource, "non.existent.attr")
  assert_true(non_existent is None)
}

// æµ‹è¯•ç”¨ä¾‹4: æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•
test "data_integrity_across_serialization" {
  // åˆ›å»ºåŒ…å«å¤æ‚æ•°æ®çš„span
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "integrity.test")
  let span = Tracer::start_span(tracer, "integrity.span")
  
  // æ·»åŠ å¤æ‚çš„å±æ€§æ•°æ®
  Span::add_event(span, "complex.data", Some([
    ("unicode.text", StringValue("æµ‹è¯•æ•°æ®ğŸš€")),
    ("numeric.precision", FloatValue(3.14159265359)),
    ("boolean.flag", BoolValue(true)),
    ("large.number", IntValue(9223372036854775807L)),
    ("array.data", StringValue("[1,2,3,4,5]"))
  ]))
  
  // è®¾ç½®spançŠ¶æ€
  Span::set_status(span, Ok)
  Span::set_status(span, Ok, Some("Integrity test completed"))
  
  // è·å–spanä¸Šä¸‹æ–‡ä¿¡æ¯
  let span_ctx = Span::span_context(span)
  let trace_id = SpanContext::trace_id(span_ctx)
  let span_id = SpanContext::span_id(span_ctx)
  
  // éªŒè¯ä¸Šä¸‹æ–‡æ•°æ®çš„å®Œæ•´æ€§
  assert_true(trace_id.length() > 0)
  assert_true(span_id.length() > 0)
  assert_true(SpanContext::is_valid(span_ctx))
  
  // åˆ›å»ºå¯¹åº”çš„æ—¥å¿—è®°å½•
  let log_record = LogRecord::new_with_context(
    Info,
    Some("Data integrity verification"),
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(trace_id),
    Some(span_id),
    Some(Context::root())
  )
  
  // éªŒè¯æ—¥å¿—è®°å½•ä¸spançš„å…³è”æ€§
  assert_eq(LogRecord::trace_id(log_record), Some(trace_id))
  assert_eq(LogRecord::span_id(log_record), Some(span_id))
  
  Span::end(span)
}

// æµ‹è¯•ç”¨ä¾‹5: æ•…éšœæ¢å¤æµ‹è¯•
test "fault_tolerance_and_recovery" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "fault.tolerance")
  
  // æµ‹è¯•åœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„spanåˆ›å»º
  let span_under_stress = Tracer::start_span(tracer, "stress.test.span")
  
  // æ¨¡æ‹Ÿå„ç§å¼‚å¸¸æƒ…å†µ
  Span::add_event(span_under_stress, "error.simulation", Some([
    ("error.type", StringValue("simulated.network.error")),
    ("error.code", IntValue(500)),
    ("retry.count", IntValue(3)),
    ("recovery.action", StringValue("circuit.breaker.activation"))
  ]))
  
  // è®¾ç½®é”™è¯¯çŠ¶æ€
  Span::set_status(span_under_stress, Error)
  Span::set_status(span_under_stress, Error, Some("Simulated error for testing"))
  
  // æµ‹è¯•é”™è¯¯æ¢å¤
  Span::add_event(span_under_stress, "recovery.attempt", Some([
    ("recovery.strategy", StringValue("exponential.backoff")),
    ("recovery.time", StringValue("2025-12-28T12:05:00Z")),
    ("success", BoolValue(true))
  ]))
  
  // æ¢å¤åˆ°æ­£å¸¸çŠ¶æ€
  Span::set_status(span_under_stress, Ok)
  Span::set_status(span_under_stress, Ok, Some("Recovered from simulated error"))
  
  // éªŒè¯spanä»ç„¶å¯ç”¨
  assert_true(Span::is_recording(span_under_stress))
  
  Span::end(span_under_stress)
  
  // åˆ›å»ºæ¢å¤åçš„span
  let recovery_span = Tracer::start_span(tracer, "recovery.validation")
  Span::add_event(recovery_span, "system.recovered", Some([
    ("recovery.timestamp", StringValue("2025-12-28T12:10:00Z")),
    ("system.status", StringValue("operational"))
  ]))
  
  Span::end(recovery_span)
}