// Azimuth ç»¼åˆæ–°æµ‹è¯•ç”¨ä¾‹ - 10ä¸ªé«˜è´¨é‡æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•è¦†ç›–åŸºæœ¬ç®—æœ¯ã€è¾¹ç•Œæƒ…å†µã€ä¸šåŠ¡é€»è¾‘å’Œé”™è¯¯å¤„ç†åœºæ™¯

test "subtract_function_comprehensive" {
  // å…¨é¢æµ‹è¯•å‡æ³•å‡½æ•°
  assert_eq(5, subtract(10, 5))
  assert_eq(-5, subtract(5, 10))
  assert_eq(0, subtract(5, 5))
  assert_eq(15, subtract(10, -5))
  assert_eq(-15, subtract(-10, 5))
  assert_eq(0, subtract(0, 0))
}

test "compound_arithmetic_operations" {
  // å¤åˆç®—æœ¯è¿ç®—æµ‹è¯•
  let a = 12
  let b = 8
  let c = 3
  
  // æµ‹è¯•å¤åˆè¿ç®—ï¼š(a + b) * c - a / c
  let step1 = add(a, b)           // 12 + 8 = 20
  let step2 = multiply(step1, c)   // 20 * 3 = 60
  let step3 = divide_with_ceil(a, c)  // ceil(12/3) = 4
  let result = subtract(step2, step3) // 60 - 4 = 56
  
  assert_eq(56, result)
}

test "inventory_management_calculations" {
  // åº“å­˜ç®¡ç†è®¡ç®—æµ‹è¯•
  let initial_stock = 150
  let sales_per_day = 12
  let days = 5
  let new_shipment = 80
  
  // è®¡ç®—é”€å”®åçš„åº“å­˜
  let total_sales = multiply(sales_per_day, days)  // 12 * 5 = 60
  let remaining_stock = subtract(initial_stock, total_sales)  // 150 - 60 = 90
  
  // è®¡ç®—æ–°åº“å­˜
  let new_total_stock = add(remaining_stock, new_shipment)  // 90 + 80 = 170
  
  // è®¡ç®—éœ€è¦çš„å­˜å‚¨ç®±æ•°ï¼ˆæ¯ç®±30ä¸ªï¼‰
  let boxes_needed = divide_with_ceil(new_total_stock, 30)  // ceil(170/30) = 6
  
  assert_eq(170, new_total_stock)
  assert_eq(6, boxes_needed)
}

test "financial_compound_interest" {
  // é‡‘èå¤åˆ©è®¡ç®—æµ‹è¯•
  let principal = 1000
  let rate_percent = 8
  let years = 3
  
  // ç¬¬ä¸€å¹´
  let year1_interest = divide_with_ceil(multiply(principal, rate_percent), 100)  // ceil(1000*8/100) = 80
  let year1_total = add(principal, year1_interest)  // 1000 + 80 = 1080
  
  // ç¬¬äºŒå¹´
  let year2_interest = divide_with_ceil(multiply(year1_total, rate_percent), 100)  // ceil(1080*8/100) = 87
  let year2_total = add(year1_total, year2_interest)  // 1080 + 87 = 1167
  
  // ç¬¬ä¸‰å¹´
  let year3_interest = divide_with_ceil(multiply(year2_total, rate_percent), 100)  // ceil(1167*8/100) = 94
  let year3_total = add(year2_total, year3_interest)  // 1167 + 94 = 1261
  
  assert_eq(1080, year1_total)
  assert_eq(1167, year2_total)
  assert_eq(1261, year3_total)
}

test "resource_allocation_fair_distribution" {
  // èµ„æºåˆ†é…å…¬å¹³åˆ†å¸ƒæµ‹è¯•
  let total_resources = 100
  let groups = 3
  let min_per_group = divide_with_ceil(total_resources, groups)  // ceil(100/3) = 34
  
  // è®¡ç®—å®é™…åˆ†é…
  let allocated_total = multiply(min_per_group, groups)  // 34 * 3 = 102
  let overflow = subtract(allocated_total, total_resources)  // 102 - 100 = 2
  
  // éªŒè¯æ¯ä¸ªç»„è‡³å°‘è·å¾—åŸºæœ¬ä»½é¢
  assert_eq(34, min_per_group)
  assert_eq(102, allocated_total)
  assert_eq(2, overflow)
  
  // éªŒè¯åˆ†é…çš„å…¬å¹³æ€§ï¼ˆæ²¡æœ‰ç»„è·å¾—å°‘äºå…¶ä»–ç»„ï¼‰
  assert_true(min_per_group > divide_with_ceil(total_resources, groups + 1))
}

test "unicode_string_edge_cases" {
  // Unicode å­—ç¬¦ä¸²è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  assert_eq_string("Hello, ğŸŒ™ğŸŒŸğŸŒ™!", greet("ğŸŒ™ğŸŒŸğŸŒ™"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
  assert_eq_string("Hello, à¤¹à¤¿à¤¨à¥à¤¦à¥€!", greet("à¤¹à¤¿à¤¨à¥à¤¦à¥€"))
  assert_eq_string("Hello, ğŸ‰ğŸš€ğŸŒŸ!", greet("ğŸ‰ğŸš€ğŸŒŸ"))
}

test "mathematical_series_calculation" {
  // æ•°å­¦æ•°åˆ—è®¡ç®—æµ‹è¯•
  // è®¡ç®—ç­‰å·®æ•°åˆ—ï¼š2, 5, 8, 11, 14 çš„å’Œ
  let first_term = 2
  let common_diff = 3
  let terms = 5
  
  // ä½¿ç”¨å…¬å¼è®¡ç®—ï¼šå’Œ = n/2 * (2a + (n-1)d)
  let double_sum = multiply(terms, add(multiply(2, first_term), multiply(terms - 1, common_diff)))
  let series_sum = divide_with_ceil(double_sum, 2)
  
  // æ‰‹åŠ¨éªŒè¯ï¼š2 + 5 + 8 + 11 + 14 = 40
  assert_eq(40, series_sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let average = divide_with_ceil(series_sum, terms)
  assert_eq(8, average)  // ceil(40/5) = 8
}

test "project_timeline_optimization" {
  // é¡¹ç›®æ—¶é—´çº¿ä¼˜åŒ–æµ‹è¯•
  let total_tasks = 45
  let team_size = 4
  let tasks_per_person_per_day = 2
  let buffer_days = 3
  
  // è®¡ç®—åŸºç¡€å·¥ä½œæ—¥
  let daily_capacity = multiply(team_size, tasks_per_person_per_day)  // 4 * 2 = 8
  let base_days = divide_with_ceil(total_tasks, daily_capacity)  // ceil(45/8) = 6
  
  // åŠ ä¸Šç¼“å†²æ—¶é—´
  let total_days = add(base_days, buffer_days)  // 6 + 3 = 9
  
  // è®¡ç®—å®é™…å®Œæˆèƒ½åŠ›
  let actual_capacity = multiply(total_days, daily_capacity)  // 9 * 8 = 72
  let slack_capacity = subtract(actual_capacity, total_tasks)  // 72 - 45 = 27
  
  assert_eq(6, base_days)
  assert_eq(9, total_days)
  assert_eq(27, slack_capacity)
}

test "error_resilience_boundary_testing" {
  // é”™è¯¯æ¢å¤è¾¹ç•Œæµ‹è¯•
  // æµ‹è¯•å„ç§æç«¯è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 1000))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(-1, divide_with_ceil(-1, -1))
  assert_eq(1, divide_with_ceil(-1, 1))
  assert_eq(-1, divide_with_ceil(1, -1))
  
  // æµ‹è¯•å¤§æ•°è¿ç®—
  let large_num = 1000000
  assert_eq(2000000, add(large_num, large_num))
  assert_eq(1000000000000, multiply(large_num, large_num))
  assert_eq(1, divide_with_ceil(large_num, large_num))
  assert_eq(2, divide_with_ceil(add(large_num, 1), large_num))
}

test "complex_business_workflow" {
  // å¤æ‚ä¸šåŠ¡å·¥ä½œæµæµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†
  let order_items = 25
  let items_per_box = 6
  let processing_time_per_box = 30  // åˆ†é’Ÿ
  let preparation_time = 15  // åˆ†é’Ÿ
  
  // è®¡ç®—éœ€è¦çš„ç®±å­æ•°
  let boxes_needed = divide_with_ceil(order_items, items_per_box)  // ceil(25/6) = 5
  
  // è®¡ç®—æ€»å¤„ç†æ—¶é—´
  let boxing_time = multiply(boxes_needed, processing_time_per_box)  // 5 * 30 = 150
  let total_time = add(boxing_time, preparation_time)  // 150 + 15 = 165
  
  // è®¡ç®—æ¯å°æ—¶å¤„ç†çš„è®¢å•æ•°
  let hourly_capacity = divide_with_ceil(3600, multiply(total_time, 60))  // ceil(3600/9900) = 1
  
  // éªŒè¯è£…ç®±åˆ©ç”¨ç‡
  let total_capacity = multiply(boxes_needed, items_per_box)  // 5 * 6 = 30
  let unused_space = subtract(total_capacity, order_items)  // 30 - 25 = 5
  let utilization_rate = multiply(divide_with_ceil(multiply(order_items, 100), total_capacity), 1)  // ceil(2500/30) = 84
  
  assert_eq(5, boxes_needed)
  assert_eq(165, total_time)
  assert_eq(1, hourly_capacity)
  assert_eq(5, unused_space)
  assert_eq(84, utilization_rate)
}