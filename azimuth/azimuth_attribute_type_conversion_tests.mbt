// Azimuth Attribute Type Conversion Tests
// å±æ€§ç±»å‹è½¬æ¢æµ‹è¯•

test "åŸºç¡€å±æ€§ç±»å‹è½¬æ¢æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•å­—ç¬¦ä¸²ç±»å‹
  let string_value = StringValue("test.string.value")
  Attributes::set(attrs, "string.key", string_value)
  
  let retrieved_string = Attributes::get(attrs, "string.key")
  match retrieved_string {
    Some(StringValue(value)) => assert_eq(value, "test.string.value")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ•´æ•°ç±»å‹
  let int_value = IntValue(42)
  Attributes::set(attrs, "int.key", int_value)
  
  let retrieved_int = Attributes::get(attrs, "int.key")
  match retrieved_int {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æµ®ç‚¹ç±»å‹
  let float_value = FloatValue(3.14159)
  Attributes::set(attrs, "float.key", float_value)
  
  let retrieved_float = Attributes::get(attrs, "float.key")
  match retrieved_float {
    Some(FloatValue(value)) => assert_eq(value, 3.14159)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¸ƒå°”ç±»å‹
  let bool_value = BoolValue(true)
  Attributes::set(attrs, "bool.key", bool_value)
  
  let retrieved_bool = Attributes::get(attrs, "bool.key")
  match retrieved_bool {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
}

test "æ•°ç»„å±æ€§ç±»å‹è½¬æ¢æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ•°ç»„ç±»å‹
  let string_array_value = ArrayStringValue(["item1", "item2", "item3"])
  Attributes::set(attrs, "string.array.key", string_array_value)
  
  let retrieved_string_array = Attributes::get(attrs, "string.array.key")
  match retrieved_string_array {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "item1")
      assert_eq(values[1], "item2")
      assert_eq(values[2], "item3")
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ•´æ•°æ•°ç»„ç±»å‹
  let int_array_value = ArrayIntValue([1, 2, 3, 4, 5])
  Attributes::set(attrs, "int.array.key", int_array_value)
  
  let retrieved_int_array = Attributes::get(attrs, "int.array.key")
  match retrieved_int_array {
    Some(ArrayIntValue(values)) => {
      assert_eq(values.length(), 5)
      assert_eq(values[0], 1)
      assert_eq(values[1], 2)
      assert_eq(values[2], 3)
      assert_eq(values[3], 4)
      assert_eq(values[4], 5)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array = ArrayStringValue([])
  Attributes::set(attrs, "empty.string.array.key", empty_string_array)
  
  let retrieved_empty_string_array = Attributes::get(attrs, "empty.string.array.key")
  match retrieved_empty_string_array {
    Some(ArrayStringValue(values)) => assert_eq(values.length(), 0)
    _ => assert_true(false)
  }
  
  let empty_int_array = ArrayIntValue([])
  Attributes::set(attrs, "empty.int.array.key", empty_int_array)
  
  let retrieved_empty_int_array = Attributes::get(attrs, "empty.int.array.key")
  match retrieved_empty_int_array {
    Some(ArrayIntValue(values)) => assert_eq(values.length(), 0)
    _ => assert_true(false)
  }
}

test "å±æ€§ç±»å‹è¾¹ç•Œå€¼è½¬æ¢æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•æ•´æ•°çš„è¾¹ç•Œå€¼
  let max_int = IntValue(2147483647)
  Attributes::set(attrs, "max.int.key", max_int)
  
  let min_int = IntValue(-2147483648)
  Attributes::set(attrs, "min.int.key", min_int)
  
  let zero_int = IntValue(0)
  Attributes::set(attrs, "zero.int.key", zero_int)
  
  // éªŒè¯è¾¹ç•Œæ•´æ•°
  let retrieved_max_int = Attributes::get(attrs, "max.int.key")
  match retrieved_max_int {
    Some(IntValue(value)) => assert_eq(value, 2147483647)
    _ => assert_true(false)
  }
  
  let retrieved_min_int = Attributes::get(attrs, "min.int.key")
  match retrieved_min_int {
    Some(IntValue(value)) => assert_eq(value, -2147483648)
    _ => assert_true(false)
  }
  
  let retrieved_zero_int = Attributes::get(attrs, "zero.int.key")
  match retrieved_zero_int {
    Some(IntValue(value)) => assert_eq(value, 0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°çš„è¾¹ç•Œå€¼
  let max_float = FloatValue(1.7976931348623157e+308) // æœ€å¤§doubleå€¼
  Attributes::set(attrs, "max.float.key", max_float)
  
  let min_float = FloatValue(2.2250738585072014e-308) // æœ€å°æ­£doubleå€¼
  Attributes::set(attrs, "min.float.key", min_float)
  
  let zero_float = FloatValue(0.0)
  Attributes::set(attrs, "zero.float.key", zero_float)
  
  let negative_zero_float = FloatValue(-0.0)
  Attributes::set(attrs, "negative.zero.float.key", negative_zero_float)
  
  // éªŒè¯è¾¹ç•Œæµ®ç‚¹æ•°
  let retrieved_max_float = Attributes::get(attrs, "max.float.key")
  match retrieved_max_float {
    Some(FloatValue(value)) => assert_eq(value, 1.7976931348623157e+308)
    _ => assert_true(false)
  }
  
  let retrieved_min_float = Attributes::get(attrs, "min.float.key")
  match retrieved_min_float {
    Some(FloatValue(value)) => assert_eq(value, 2.2250738585072014e-308)
    _ => assert_true(false)
  }
  
  let retrieved_zero_float = Attributes::get(attrs, "zero.float.key")
  match retrieved_zero_float {
    Some(FloatValue(value)) => assert_eq(value, 0.0)
    _ => assert_true(false)
  }
  
  let retrieved_negative_zero_float = Attributes::get(attrs, "negative.zero.float.key")
  match retrieved_negative_zero_float {
    Some(FloatValue(value)) => assert_eq(value, -0.0)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  let infinity_float = FloatValue(1.0 / 0.0) // æ­£æ— ç©·
  Attributes::set(attrs, "infinity.float.key", infinity_float)
  
  let negative_infinity_float = FloatValue(-1.0 / 0.0) // è´Ÿæ— ç©·
  Attributes::set(attrs, "negative.infinity.float.key", negative_infinity_float)
  
  let nan_float = FloatValue(0.0 / 0.0) // NaN
  Attributes::set(attrs, "nan.float.key", nan_float)
  
  // éªŒè¯ç‰¹æ®Šæµ®ç‚¹å€¼
  let retrieved_infinity_float = Attributes::get(attrs, "infinity.float.key")
  match retrieved_infinity_float {
    Some(FloatValue(value)) => assert_true(value.is_infinite() && value > 0.0)
    _ => assert_true(false)
  }
  
  let retrieved_negative_infinity_float = Attributes::get(attrs, "negative.infinity.float.key")
  match retrieved_negative_infinity_float {
    Some(FloatValue(value)) => assert_true(value.is_infinite() && value < 0.0)
    _ => assert_true(false)
  }
  
  let retrieved_nan_float = Attributes::get(attrs, "nan.float.key")
  match retrieved_nan_float {
    Some(FloatValue(value)) => assert_true(value.is_nan())
    _ => assert_true(false)
  }
}

test "å­—ç¬¦ä¸²å±æ€§ç‰¹æ®Šå€¼è½¬æ¢æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_string = StringValue("")
  Attributes::set(attrs, "empty.string.key", empty_string)
  
  let retrieved_empty_string = Attributes::get(attrs, "empty.string.key")
  match retrieved_empty_string {
    Some(StringValue(value)) => assert_eq(value, "")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å•å­—ç¬¦å­—ç¬¦ä¸²
  let single_char_string = StringValue("a")
  Attributes::set(attrs, "single.char.string.key", single_char_string)
  
  let retrieved_single_char_string = Attributes::get(attrs, "single.char.string.key")
  match retrieved_single_char_string {
    Some(StringValue(value)) => assert_eq(value, "a")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²
  let space_string = StringValue("string with spaces")
  Attributes::set(attrs, "space.string.key", space_string)
  
  let retrieved_space_string = Attributes::get(attrs, "space.string.key")
  match retrieved_space_string {
    Some(StringValue(value)) => assert_eq(value, "string with spaces")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_char_string = StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?")
  Attributes::set(attrs, "special.char.string.key", special_char_string)
  
  let retrieved_special_char_string = Attributes::get(attrs, "special.char.string.key")
  match retrieved_special_char_string {
    Some(StringValue(value)) => assert_eq(value, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_string = StringValue("æµ‹è¯•å­—ç¬¦ä¸²ğŸš€ğŸ“ŠÎ±Î²Î³Î´ÎµÎ¶Î·Î¸")
  Attributes::set(attrs, "unicode.string.key", unicode_string)
  
  let retrieved_unicode_string = Attributes::get(attrs, "unicode.string.key")
  match retrieved_unicode_string {
    Some(StringValue(value)) => assert_eq(value, "æµ‹è¯•å­—ç¬¦ä¸²ğŸš€ğŸ“ŠÎ±Î²Î³Î´ÎµÎ¶Î·Î¸")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²
  let long_string = StringValue("This is a very long string that exceeds normal length limits and tests boundary conditions for string handling in the telemetry system. It contains multiple sentences and should test how the system handles unusually long strings.")
  Attributes::set(attrs, "long.string.key", long_string)
  
  let retrieved_long_string = Attributes::get(attrs, "long.string.key")
  match retrieved_long_string {
    Some(StringValue(value)) => assert_eq(value, "This is a very long string that exceeds normal length limits and tests boundary conditions for string handling in the telemetry system. It contains multiple sentences and should test how the system handles unusually long strings.")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸²
  let numeric_string = StringValue("1234567890")
  Attributes::set(attrs, "numeric.string.key", numeric_string)
  
  let retrieved_numeric_string = Attributes::get(attrs, "numeric.string.key")
  match retrieved_numeric_string {
    Some(StringValue(value)) => assert_eq(value, "1234567890")
    _ => assert_true(false)
  }
}

test "å±æ€§ç±»å‹æ··åˆè½¬æ¢æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // è®¾ç½®å„ç§ç±»å‹çš„å±æ€§
  Attributes::set(attrs, "string.value", StringValue("test"))
  Attributes::set(attrs, "int.value", IntValue(42))
  Attributes::set(attrs, "float.value", FloatValue(3.14))
  Attributes::set(attrs, "bool.value", BoolValue(true))
  Attributes::set(attrs, "string.array.value", ArrayStringValue(["a", "b", "c"]))
  Attributes::set(attrs, "int.array.value", ArrayIntValue([1, 2, 3]))
  
  // éªŒè¯æ‰€æœ‰ç±»å‹éƒ½èƒ½æ­£ç¡®æ£€ç´¢
  let string_value = Attributes::get(attrs, "string.value")
  match string_value {
    Some(StringValue(value)) => assert_eq(value, "test")
    _ => assert_true(false)
  }
  
  let int_value = Attributes::get(attrs, "int.value")
  match int_value {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  let float_value = Attributes::get(attrs, "float.value")
  match float_value {
    Some(FloatValue(value)) => assert_eq(value, 3.14)
    _ => assert_true(false)
  }
  
  let bool_value = Attributes::get(attrs, "bool.value")
  match bool_value {
    Some(BoolValue(value)) => assert_eq(value, true)
    _ => assert_true(false)
  }
  
  let string_array_value = Attributes::get(attrs, "string.array.value")
  match string_array_value {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], "a")
      assert_eq(values[1], "b")
      assert_eq(values[2], "c")
    }
    _ => assert_true(false)
  }
  
  let int_array_value = Attributes::get(attrs, "int.array.value")
  match int_array_value {
    Some(ArrayIntValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], 1)
      assert_eq(values[1], 2)
      assert_eq(values[2], 3)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•è¦†ç›–ä¸åŒç±»å‹çš„å€¼
  Attributes::set(attrs, "mixed.value", StringValue("initial.string"))
  Attributes::set(attrs, "mixed.value", IntValue(123))
  Attributes::set(attrs, "mixed.value", FloatValue(456.789))
  Attributes::set(attrs, "mixed.value", BoolValue(false))
  
  // éªŒè¯æœ€ç»ˆå€¼
  let final_mixed_value = Attributes::get(attrs, "mixed.value")
  match final_mixed_value {
    Some(BoolValue(value)) => assert_eq(value, false)
    _ => assert_true(false)
  }
}

test "æ•°ç»„å±æ€§å¤æ‚å€¼è½¬æ¢æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²æ•°ç»„
  let special_string_array = ArrayStringValue([
    "item with spaces",
    "item@with#special$chars",
    "æµ‹è¯•é¡¹ç›®",
    "itemğŸš€withğŸ“Šemoji"
  ])
  Attributes::set(attrs, "special.string.array.key", special_string_array)
  
  let retrieved_special_string_array = Attributes::get(attrs, "special.string.array.key")
  match retrieved_special_string_array {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 4)
      assert_eq(values[0], "item with spaces")
      assert_eq(values[1], "item@with#special$chars")
      assert_eq(values[2], "æµ‹è¯•é¡¹ç›®")
      assert_eq(values[3], "itemğŸš€withğŸ“Šemoji")
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«è¾¹ç•Œå€¼çš„æ•´æ•°æ•°ç»„
  let boundary_int_array = ArrayIntValue([
    -2147483648, // æœ€å°int
    0,           // é›¶
    2147483647   // æœ€å¤§int
  ])
  Attributes::set(attrs, "boundary.int.array.key", boundary_int_array)
  
  let retrieved_boundary_int_array = Attributes::get(attrs, "boundary.int.array.key")
  match retrieved_boundary_int_array {
    Some(ArrayIntValue(values)) => {
      assert_eq(values.length(), 3)
      assert_eq(values[0], -2147483648)
      assert_eq(values[1], 0)
      assert_eq(values[2], 2147483647)
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«é‡å¤å…ƒç´ çš„æ•°ç»„
  let duplicate_string_array = ArrayStringValue([
    "duplicate",
    "duplicate",
    "unique",
    "duplicate"
  ])
  Attributes::set(attrs, "duplicate.string.array.key", duplicate_string_array)
  
  let retrieved_duplicate_string_array = Attributes::get(attrs, "duplicate.string.array.key")
  match retrieved_duplicate_string_array {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 4)
      assert_eq(values[0], "duplicate")
      assert_eq(values[1], "duplicate")
      assert_eq(values[2], "unique")
      assert_eq(values[3], "duplicate")
    }
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_string_array = ArrayStringValue(["single.element"])
  Attributes::set(attrs, "single.string.array.key", single_string_array)
  
  let retrieved_single_string_array = Attributes::get(attrs, "single.string.array.key")
  match retrieved_single_string_array {
    Some(ArrayStringValue(values)) => {
      assert_eq(values.length(), 1)
      assert_eq(values[0], "single.element")
    }
    _ => assert_true(false)
  }
  
  let single_int_array = ArrayIntValue([42])
  Attributes::set(attrs, "single.int.array.key", single_int_array)
  
  let retrieved_single_int_array = Attributes::get(attrs, "single.int.array.key")
  match retrieved_single_int_array {
    Some(ArrayIntValue(values)) => {
      assert_eq(values.length(), 1)
      assert_eq(values[0], 42)
    }
    _ => assert_true(false)
  }
}

test "å±æ€§ç±»å‹è½¬æ¢é”™è¯¯å¤„ç†æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•è·å–ä¸å­˜åœ¨çš„å±æ€§
  let missing_attribute = Attributes::get(attrs, "nonexistent.key")
  assert_eq(missing_attribute, None)
  
  // æµ‹è¯•è®¾ç½®å’Œè·å–ä¸åŒç±»å‹çš„å±æ€§
  Attributes::set(attrs, "test.key", StringValue("string.value"))
  
  // å°è¯•ä»¥ä¸åŒç±»å‹è·å–ï¼ˆåº”è¯¥è¿”å›Noneæˆ–æ­£ç¡®çš„å€¼ï¼‰
  let string_result = Attributes::get(attrs, "test.key")
  match string_result {
    Some(StringValue(value)) => assert_eq(value, "string.value")
    _ => assert_true(false)
  }
  
  // è®¾ç½®æ•´æ•°å¹¶å°è¯•ä»¥å­—ç¬¦ä¸²è·å–
  Attributes::set(attrs, "int.key", IntValue(123))
  let int_result = Attributes::get(attrs, "int.key")
  match int_result {
    Some(IntValue(value)) => assert_eq(value, 123)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºé”®å
  Attributes::set(attrs, "", StringValue("empty.key.value"))
  let empty_key_result = Attributes::get(attrs, "")
  match empty_key_result {
    Some(StringValue(value)) => assert_eq(value, "empty.key.value")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„é”®å
  Attributes::set(attrs, "key with spaces", StringValue("spaces.key.value"))
  let spaces_key_result = Attributes::get(attrs, "key with spaces")
  match spaces_key_result {
    Some(StringValue(value)) => assert_eq(value, "spaces.key.value")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„é”®å
  Attributes::set(attrs, "key@with#special$chars", StringValue("special.chars.key.value"))
  let special_chars_key_result = Attributes::get(attrs, "key@with#special$chars")
  match special_chars_key_result {
    Some(StringValue(value)) => assert_eq(value, "special.chars.key.value")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•Unicodeé”®å
  Attributes::set(attrs, "æµ‹è¯•é”®", StringValue("Unicodeé”®å€¼"))
  let unicode_key_result = Attributes::get(attrs, "æµ‹è¯•é”®")
  match unicode_key_result {
    Some(StringValue(value)) => assert_eq(value, "Unicodeé”®å€¼")
    _ => assert_true(false)
  }
}

test "å±æ€§ç±»å‹è½¬æ¢æ€§èƒ½æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•å¤§é‡å±æ€§è®¾ç½®å’Œæ£€ç´¢çš„æ€§èƒ½
  let attribute_count = 1000
  
  // è®¾ç½®å¤§é‡å±æ€§
  for i = 0; i < attribute_count; i = i + 1 {
    let key = "perf.test.key." + i.to_string()
    
    // å¾ªç¯è®¾ç½®ä¸åŒç±»å‹çš„å±æ€§
    if i % 6 == 0 {
      Attributes::set(attrs, key, StringValue("string.value." + i.to_string()))
    } else if i % 6 == 1 {
      Attributes::set(attrs, key, IntValue(i))
    } else if i % 6 == 2 {
      Attributes::set(attrs, key, FloatValue(i.to_double() * 0.1))
    } else if i % 6 == 3 {
      Attributes::set(attrs, key, BoolValue(i % 2 == 0))
    } else if i % 6 == 4 {
      Attributes::set(attrs, key, ArrayStringValue(["item1", "item2", "item3"]))
    } else {
      Attributes::set(attrs, key, ArrayIntValue([1, 2, 3, 4, 5]))
    }
  }
  
  // æ£€ç´¢å¤§é‡å±æ€§
  for i = 0; i < attribute_count; i = i + 1 {
    let key = "perf.test.key." + i.to_string()
    let value = Attributes::get(attrs, key)
    
    // éªŒè¯æ£€ç´¢åˆ°çš„å€¼ä¸ä¸ºNone
    assert_true(value is Some)
  }
  
  // æµ‹è¯•æ•°ç»„å±æ€§çš„æ€§èƒ½
  let array_attr_count = 100
  
  for i = 0; i < array_attr_count; i = i + 1 {
    let string_array_key = "perf.string.array.key." + i.to_string()
    let int_array_key = "perf.int.array.key." + i.to_string()
    
    let string_array = ArrayStringValue([
      "item1." + i.to_string(),
      "item2." + i.to_string(),
      "item3." + i.to_string()
    ])
    
    let int_array = ArrayIntValue([
      i * 1,
      i * 2,
      i * 3,
      i * 4,
      i * 5
    ])
    
    Attributes::set(attrs, string_array_key, string_array)
    Attributes::set(attrs, int_array_key, int_array)
  }
  
  // æ£€ç´¢æ•°ç»„å±æ€§
  for i = 0; i < array_attr_count; i = i + 1 {
    let string_array_key = "perf.string.array.key." + i.to_string()
    let int_array_key = "perf.int.array.key." + i.to_string()
    
    let string_array_value = Attributes::get(attrs, string_array_key)
    let int_array_value = Attributes::get(attrs, int_array_key)
    
    // éªŒè¯æ£€ç´¢åˆ°çš„æ•°ç»„ä¸ä¸ºNone
    assert_true(string_array_value is Some)
    assert_true(int_array_value is Some)
  }
  
  assert_true(true)
}
