// Data Serialization Integrity Tests
// æ•°æ®åºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•ï¼Œæµ‹è¯•å„ç§æ•°æ®ç»“æ„çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–å®Œæ•´æ€§

test "AttributeValueåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  let attrs = Attributes::new()
  
  // æµ‹è¯•æ‰€æœ‰åŸºæœ¬ç±»å‹çš„åºåˆ—åŒ–
  let test_values = [
    ("string.basic", StringValue("hello world")),
    ("string.empty", StringValue("")),
    ("string.special", StringValue("ç‰¹æ®Šå­—ç¬¦ğŸš€!@#$%")),
    ("string.unicode", StringValue("æµ‹è¯•ä¸­æ–‡ãƒ†ã‚¹ãƒˆæ—¥æœ¬è¯­")),
    ("string.json", StringValue("{\"key\": \"value\", \"array\": [1, 2, 3]}")),
    ("int.zero", IntValue(0)),
    ("int.positive", IntValue(12345)),
    ("int.negative", IntValue(-12345)),
    ("int.max", IntValue(2147483647)),
    ("int.min", IntValue(-2147483648)),
    ("float.zero", FloatValue(0.0)),
    ("float.positive", FloatValue(3.14159)),
    ("float.negative", FloatValue(-2.71828)),
    ("float.scientific", FloatValue(1.23e-10)),
    ("float.large", FloatValue(1.23e+20)),
    ("bool.true", BoolValue(true)),
    ("bool.false", BoolValue(false)),
    ("array.string.empty", ArrayStringValue([])),
    ("array.string.single", ArrayStringValue(["single"])),
    ("array.string.multiple", ArrayStringValue(["item1", "item2", "item3"])),
    ("array.string.special", ArrayStringValue(["ä¸­æ–‡", "æ—¥æœ¬èª", "ğŸš€emoji"])),
    ("array.int.empty", ArrayIntValue([])),
    ("array.int.single", ArrayIntValue([42])),
    ("array.int.multiple", ArrayIntValue([1, 2, 3, 4, 5])),
    ("array.int.mixed", ArrayIntValue([0, -1, 2147483647, -2147483648]))
  ]
  
  // è®¾ç½®æ‰€æœ‰æµ‹è¯•å€¼
  for test_value in test_values {
    Attributes::set(attrs, test_value.0, test_value.1)
  }
  
  // éªŒè¯æ‰€æœ‰å€¼çš„å®Œæ•´æ€§ï¼ˆé€šè¿‡è·å–å’Œæ¯”è¾ƒï¼‰
  for test_value in test_values {
    let retrieved = Attributes::get(attrs, test_value.0)
    match retrieved {
      Some(value) => {
        assert_eq(value, test_value.1)
      }
      None => assert_true(false)
    }
  }
  
  // æµ‹è¯•å¤æ‚åµŒå¥—ç»“æ„çš„åºåˆ—åŒ–
  let complex_nested = [
    ("user.profile.name", StringValue("å¼ ä¸‰")),
    ("user.profile.age", IntValue(30)),
    ("user.profile.height", FloatValue(175.5)),
    ("user.profile.active", BoolValue(true)),
    ("user.preferences.languages", ArrayStringValue(["ä¸­æ–‡", "English", "æ—¥æœ¬èª"])),
    ("user.preferences.scores", ArrayIntValue([100, 95, 88, 92])),
    ("user.metadata.created", StringValue("2025-01-01T00:00:00Z")),
    ("user.metadata.updated", StringValue("2025-01-20T12:30:45Z"))
  ]
  
  for nested_attr in complex_nested {
    Attributes::set(attrs, nested_attr.0, nested_attr.1)
  }
  
  // éªŒè¯åµŒå¥—ç»“æ„
  for nested_attr in complex_nested {
    let retrieved = Attributes::get(attrs, nested_attr.0)
    match retrieved {
      Some(value) => assert_eq(value, nested_attr.1)
      None => assert_true(false)
    }
  }
}

test "SpanContextåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•å„ç§SpanContextçš„åºåˆ—åŒ–
  let span_contexts = [
    ("basic.valid", SpanContext::new("0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", true, "rojo=00f067aa0ba902b7")),
    ("unsampled", SpanContext::new("0af7651916cd43dd8448eb211c80319c", "b7ad6b7169203331", false, "")),
    ("empty.trace_state", SpanContext::new("4bf92f3577b34da6a3ce929d0e0e4736", "00f067aa0ba902b7", true, "")),
    ("complex.trace_state", SpanContext::new("4bf92f3577b34da6a3ce929d0e0e4736", "00f067aa0ba902b7", true, "congo=t61rcWkgMzE,rojo=00f067aa0ba902b7")),
    ("minimal", SpanContext::new("1", "1", true, "")),
    ("numeric", SpanContext::new("1234567890123456", "12345678", true, "numeric=test"))
  ]
  
  for span_context_test in span_contexts {
    let ctx_name = span_context_test.0
    let ctx = span_context_test.1
    
    // éªŒè¯åŸºæœ¬å±æ€§
    assert_eq(SpanContext::trace_id(ctx), SpanContext::trace_id(ctx))
    assert_eq(SpanContext::span_id(ctx), SpanContext::span_id(ctx))
    assert_eq(SpanContext::is_sampled(ctx), SpanContext::is_sampled(ctx))
    assert_eq(SpanContext::is_valid(ctx), SpanContext::is_valid(ctx))
    
    // éªŒè¯ç‰¹æ®Šå€¼
    if ctx_name == "basic.valid" {
      assert_true(SpanContext::is_valid(ctx))
      assert_true(SpanContext::is_sampled(ctx))
      assert_eq(SpanContext::trace_id(ctx), "0af7651916cd43dd8448eb211c80319c")
      assert_eq(SpanContext::span_id(ctx), "b7ad6b7169203331")
    }
    
    if ctx_name == "unsampled" {
      assert_true(SpanContext::is_valid(ctx))
      assert_false(SpanContext::is_sampled(ctx))
    }
    
    if ctx_name == "minimal" {
      assert_true(SpanContext::is_valid(ctx))
    }
  }
  
  // æµ‹è¯•æ— æ•ˆSpanContext
  let invalid_contexts = [
    ("empty.trace", SpanContext::new("", "b7ad6b7169203331", true, "")),
    ("empty.span", SpanContext::new("0af7651916cd43dd8448eb211c80319c", "", true, "")),
    ("both.empty", SpanContext::new("", "", false, ""))
  ]
  
  for invalid_test in invalid_contexts {
    let ctx_name = invalid_test.0
    let ctx = invalid_test.1
    
    assert_false(SpanContext::is_valid(ctx))
    
    if ctx_name == "both.empty" {
      assert_false(SpanContext::is_sampled(ctx))
    }
  }
}

test "LogRecordåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  let base_time = Clock::now_unix_nanos(Clock::system())
  
  // æµ‹è¯•å„ç§LogRecordçš„åºåˆ—åŒ–
  let log_records = [
    ("basic.info", LogRecord::new(Info, "Basic info message")),
    ("basic.warn", LogRecord::new(Warn, "Warning message")),
    ("basic.error", LogRecord::new(Error, "Error message")),
    ("with.attributes", LogRecord::new_with_context(
      Info,
      Some("Message with attributes"),
      Some(Attributes::with_attributes(Attributes::new(), [
        ("user.id", StringValue("12345")),
        ("action", StringValue("login")),
        ("success", BoolValue(true))
      ])),
      None,
      None,
      None,
      None,
      None
    )),
    ("with.timestamps", LogRecord::new_with_context(
      Debug,
      Some("Debug with timestamps"),
      None,
      Some(base_time),
      Some(base_time + 1000000L),
      None,
      None,
      None
    )),
    ("with.trace", LogRecord::new_with_context(
      Error,
      Some("Error with trace context"),
      Some(Attributes::with_attributes(Attributes::new(), [
        ("error.code", StringValue("ERR_001")),
        ("error.severity", StringValue("high"))
      ])),
      Some(base_time),
      Some(base_time + 500000L),
      Some("trace123456"),
      Some("span789012"),
      None
    )),
    ("full.complex", LogRecord::new_with_context(
      Fatal,
      Some("Complex log record"),
      Some(Attributes::with_attributes(Attributes::new(), [
        ("service.name", StringValue("user-service")),
        ("service.version", StringValue("2.1.0")),
        ("request.id", StringValue("req-abcdef")),
        ("user.id", StringValue("user-12345")),
        ("operation.duration.ms", IntValue(1500)),
        ("memory.usage.mb", FloatValue(256.7)),
        ("cache.hit", BoolValue(true)),
        ("tags", ArrayStringValue(["critical", "production", "user-api"]))
      ])),
      Some(base_time),
      Some(base_time + 2000000L),
      Some("trace-complex-123"),
      Some("span-complex-456"),
      Some(Context::root())
    ))
  ]
  
  for log_record_test in log_records {
    let record_name = log_record_test.0
    let record = log_record_test.1
    
    // éªŒè¯åŸºæœ¬å±æ€§
    assert_eq(LogRecord::severity_number(record), LogRecord::severity_number(record))
    assert_eq(LogRecord::body(record), LogRecord::body(record))
    assert_eq(LogRecord::trace_id(record), LogRecord::trace_id(record))
    assert_eq(LogRecord::span_id(record), LogRecord::span_id(record))
    assert_eq(LogRecord::timestamp(record), LogRecord::timestamp(record))
    assert_eq(LogRecord::observed_timestamp(record), LogRecord::observed_timestamp(record))
    
    // éªŒè¯ç‰¹å®šè®°å½•çš„å±æ€§
    match record_name {
      "basic.info" => {
        assert_eq(LogRecord::severity_number(record), Info)
        match LogRecord::body(record) {
          Some(body) => assert_eq(body, "Basic info message")
          None => assert_true(false)
        }
      }
      "with.attributes" => {
        match LogRecord::body(record) {
          Some(body) => assert_eq(body, "Message with attributes")
          None => assert_true(false)
        }
        assert_true(LogRecord::attributes(record) is Some)
      }
      "with.timestamps" => {
        assert_eq(LogRecord::timestamp(record), Some(base_time))
        assert_eq(LogRecord::observed_timestamp(record), Some(base_time + 1000000L))
      }
      "with.trace" => {
        assert_eq(LogRecord::trace_id(record), Some("trace123456"))
        assert_eq(LogRecord::span_id(record), Some("span789012"))
        assert_eq(LogRecord::severity_number(record), Error)
      }
      "full.complex" => {
        assert_eq(LogRecord::severity_number(record), Fatal)
        assert_eq(LogRecord::trace_id(record), Some("trace-complex-123"))
        assert_eq(LogRecord::span_id(record), Some("span-complex-456"))
        assert_eq(LogRecord::timestamp(record), Some(base_time))
        assert_eq(LogRecord::observed_timestamp(record), Some(base_time + 2000000L))
      }
      _ => assert_true(true)
    }
  }
}

test "Resourceåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•å„ç§Resourceçš„åºåˆ—åŒ–
  let resources = [
    ("empty", Resource::new()),
    ("basic", Resource::with_attributes(Resource::new(), [
      ("service.name", StringValue("test-service")),
      ("service.version", StringValue("1.0.0"))
    ])),
    ("complex", Resource::with_attributes(Resource::new(), [
      ("service.name", StringValue("user-service")),
      ("service.version", StringValue("2.1.0")),
      ("service.instance.id", StringValue("instance-12345")),
      ("deployment.environment", StringValue("production")),
      ("host.name", StringValue("prod-host-001")),
      ("host.ip", StringValue("10.0.1.100")),
      ("process.pid", IntValue(12345)),
      ("process.executable.name", StringValue("user-service")),
      ("cloud.provider", StringValue("aws")),
      ("cloud.region", StringValue("us-west-2")),
      ("telemetry.sdk.name", StringValue("azimuth")),
      ("telemetry.sdk.version", StringValue("1.0.0")),
      ("container.id", StringValue("container-67890")),
      ("k8s.pod.name", StringValue("user-service-7d4b8c9f-1234")),
      ("user.defined.key", StringValue("custom.value")),
      ("numeric.value", IntValue(42)),
      ("float.value", FloatValue(3.14)),
      ("boolean.value", BoolValue(true)),
      ("array.value", ArrayStringValue(["tag1", "tag2", "tag3"]))
    ])),
    ("special.chars", Resource::with_attributes(Resource::new(), [
      ("unicode.key", StringValue("æµ‹è¯•å€¼")),
      ("emoji.key", StringValue("ğŸš€value")),
      ("special.chars.key", StringValue("special!@#$%^&*()")),
      ("json.like.key", StringValue("{\"embedded\": \"json\"}")),
      ("url.like.key", StringValue("https://example.com/path"))
    ]))
  ]
  
  for resource_test in resources {
    let resource_name = resource_test.0
    let resource = resource_test.1
    
    // éªŒè¯èµ„æºå±æ€§å¯ä»¥é€šè¿‡é”®è·å–
    if resource_name == "basic" {
      let service_name = Resource::get_attribute(resource, "service.name")
      match service_name {
        Some(StringValue(value)) => assert_eq(value, "test-service")
        _ => assert_true(false)
      }
      
      let service_version = Resource::get_attribute(resource, "service.version")
      match service_version {
        Some(StringValue(value)) => assert_eq(value, "1.0.0")
        _ => assert_true(false)
      }
    }
    
    if resource_name == "complex" {
      let service_name = Resource::get_attribute(resource, "service.name")
      match service_name {
        Some(StringValue(value)) => assert_eq(value, "user-service")
        _ => assert_true(false)
      }
      
      let process_pid = Resource::get_attribute(resource, "process.pid")
      match process_pid {
        Some(IntValue(value)) => assert_eq(value, 12345)
        _ => assert_true(false)
      }
      
      let boolean_value = Resource::get_attribute(resource, "boolean.value")
      match boolean_value {
        Some(BoolValue(value)) => assert_eq(value, true)
        _ => assert_true(false)
      }
      
      let array_value = Resource::get_attribute(resource, "array.value")
      match array_value {
        Some(ArrayStringValue(values)) => {
          assert_eq(values.length(), 3)
          assert_eq(values[0], "tag1")
          assert_eq(values[2], "tag3")
        }
        _ => assert_true(false)
      }
    }
    
    if resource_name == "special.chars" {
      let unicode_value = Resource::get_attribute(resource, "unicode.key")
      match unicode_value {
        Some(StringValue(value)) => assert_eq(value, "æµ‹è¯•å€¼")
        _ => assert_true(false)
      }
      
      let emoji_value = Resource::get_attribute(resource, "emoji.key")
      match emoji_value {
        Some(StringValue(value)) => assert_eq(value, "ğŸš€value")
        _ => assert_true(false)
      }
    }
  }
  
  // æµ‹è¯•èµ„æºåˆå¹¶çš„å®Œæ•´æ€§
  let resource1 = Resource::with_attributes(Resource::new(), [
    ("service.name", StringValue("service-A")),
    ("environment", StringValue("dev")),
    ("version", StringValue("1.0.0"))
  ])
  
  let resource2 = Resource::with_attributes(Resource::new(), [
    ("service.name", StringValue("service-B")), // è¦†ç›–
    ("region", StringValue("us-west-2")),      // æ–°å¢
    ("version", StringValue("2.0.0"))          // è¦†ç›–
  ])
  
  let merged = Resource::merge(resource1, resource2)
  
  // éªŒè¯åˆå¹¶ç»“æœï¼ˆç®€åŒ–å®ç°å¯èƒ½è¿”å›resource2ï¼‰
  let merged_service_name = Resource::get_attribute(merged, "service.name")
  match merged_service_name {
    Some(StringValue(value)) => assert_eq(value, "service-B")
    _ => assert_true(false)
  }
  
  let merged_region = Resource::get_attribute(merged, "region")
  match merged_region {
    Some(StringValue(value)) => assert_eq(value, "us-west-2")
    _ => assert_true(false)
  }
}

test "InstrumentationScopeåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•å„ç§InstrumentationScopeçš„åºåˆ—åŒ–
  let scopes = [
    ("minimal", InstrumentationScope::{ name: "minimal.scope", version: None, schema_url: None }),
    ("with.version", InstrumentationScope::{ 
      name: "versioned.scope", 
      version: Some("1.2.3"), 
      schema_url: None 
    }),
    ("with.schema", InstrumentationScope::{ 
      name: "schema.scope", 
      version: None, 
      schema_url: Some("https://example.com/schema/v1") 
    }),
    ("full", InstrumentationScope::{ 
      name: "full.scope", 
      version: Some("2.1.0"), 
      schema_url: Some("https://opentelemetry.io/schemas/v1.20.0") 
    }),
    ("special.chars", InstrumentationScope::{ 
      name: "ç‰¹æ®Š.ä½œç”¨åŸŸğŸš€", 
      version: Some("ç‰ˆæœ¬.1.0"), 
      schema_url: Some("https://ä¾‹å­.å…¬å¸/æ¨¡å¼/v1") 
    }),
    ("long.name", InstrumentationScope::{ 
      name: "very.long.scope.name.with.many.dots.and.underscores_and-various-characters-123456789", 
      version: Some("very.long.version.number.1.2.3.4.5.6.7.8.9.0"), 
      schema_url: Some("https://very.long.domain.name.example.com/with/many/path/segments/schema/v1.0.0") 
    })
  ]
  
  for scope_test in scopes {
    let scope_name = scope_test.0
    let scope = scope_test.1
    
    // éªŒè¯åŸºæœ¬å±æ€§
    assert_eq(scope.name, scope.name)
    assert_eq(scope.version, scope.version)
    assert_eq(scope.schema_url, scope.schema_url)
    
    // éªŒè¯ç‰¹å®šscopeçš„å±æ€§
    match scope_name {
      "minimal" => {
        assert_eq(scope.name, "minimal.scope")
        assert_eq(scope.version, None)
        assert_eq(scope.schema_url, None)
      }
      "with.version" => {
        assert_eq(scope.name, "versioned.scope")
        assert_eq(scope.version, Some("1.2.3"))
        assert_eq(scope.schema_url, None)
      }
      "with.schema" => {
        assert_eq(scope.name, "schema.scope")
        assert_eq(scope.version, None)
        assert_eq(scope.schema_url, Some("https://example.com/schema/v1"))
      }
      "full" => {
        assert_eq(scope.name, "full.scope")
        assert_eq(scope.version, Some("2.1.0"))
        assert_eq(scope.schema_url, Some("https://opentelemetry.io/schemas/v1.20.0"))
      }
      "special.chars" => {
        assert_eq(scope.name, "ç‰¹æ®Š.ä½œç”¨åŸŸğŸš€")
        assert_eq(scope.version, Some("ç‰ˆæœ¬.1.0"))
        assert_eq(scope.schema_url, Some("https://ä¾‹å­.å…¬å¸/æ¨¡å¼/v1"))
      }
      "long.name" => {
        assert_true(scope.name.length() > 50)
        assert_true(scope.version.unwrap().length() > 30)
        assert_true(scope.schema_url.unwrap().length() > 50)
      }
      _ => assert_true(true)
    }
  }
  
  // æµ‹è¯•InstrumentationScopeåœ¨å„ç§ç»„ä»¶ä¸­çš„ä½¿ç”¨
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  let test_scope = InstrumentationScope::{ 
    name: "serialization.test.scope", 
    version: Some("3.2.1"), 
    schema_url: Some("https://test.example.com/schema/v2") 
  }
  
  let tracer = Tracer::{ scope: test_scope }
  let meter = Meter::{ scope: test_scope }
  let logger = Logger::{ scope: test_scope }
  
  // éªŒè¯scopeåœ¨å„ä¸ªç»„ä»¶ä¸­ä¿æŒä¸€è‡´
  assert_eq(Tracer::instrumentation_scope(tracer).name, "serialization.test.scope")
  assert_eq(meter.scope.name, "serialization.test.scope")
  assert_eq(logger.scope.name, "serialization.test.scope")
  
  assert_eq(Tracer::instrumentation_scope(tracer).version, Some("3.2.1"))
  assert_eq(meter.scope.version, Some("3.2.1"))
  assert_eq(logger.scope.version, Some("3.2.1"))
  
  assert_eq(Tracer::instrumentation_scope(tracer).schema_url, Some("https://test.example.com/schema/v2"))
  assert_eq(meter.scope.schema_url, Some("https://test.example.com/schema/v2"))
  assert_eq(logger.scope.schema_url, Some("https://test.example.com/schema/v2"))
}

test "Contextåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•Contextçš„åºåˆ—åŒ–å®Œæ•´æ€§
  let root_ctx = Context::root()
  
  // åˆ›å»ºå¤šå±‚åµŒå¥—çš„Context
  let key1 = ContextKey::new("level1.key1")
  let key2 = ContextKey::new("level2.key2")
  let key3 = ContextKey::new("level3.key3")
  let key4 = ContextKey::new("level4.key4")
  
  let ctx1 = Context::with_value(root_ctx, key1, "value1")
  let ctx2 = Context::with_value(ctx1, key2, "value2")
  let ctx3 = Context::with_value(ctx2, key3, "value3")
  let ctx4 = Context::with_value(ctx3, key4, "value4")
  
  // éªŒè¯Contextå€¼çš„è·å–
  let value1 = Context::get(ctx4, key1)
  match value1 {
    Some(value) => assert_eq(value, "value1")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒ
  }
  
  let value4 = Context::get(ctx4, key4)
  match value4 {
    Some(value) => assert_eq(value, "value4")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå€¼çš„Context
  let special_values = [
    ("empty.string", ""),
    ("unicode.string", "æµ‹è¯•ä¸­æ–‡ãƒ†ã‚¹ãƒˆæ—¥æœ¬è¯­"),
    ("emoji.string", "ğŸš€ğŸŒŸâœ¨"),
    ("json.string", "{\"key\": \"value\", \"number\": 42}"),
    ("numeric.string", "123456789"),
    ("special.chars", "!@#$%^&*()_+-=[]{}|\\:;\"'<>?,./"),
    ("very.long.string", "a" * 1000)
  ]
  
  for special_value in special_values {
    let key = ContextKey::new(special_value.0)
    let ctx_with_special = Context::with_value(root_ctx, key, special_value.1)
    
    let retrieved = Context::get(ctx_with_special, key)
    match retrieved {
      Some(value) => assert_eq(value, special_value.1)
      None => assert_true(false)
    }
  }
  
  // æµ‹è¯•Contextçš„ä¼ æ’­å®Œæ•´æ€§
  let propagation_key = ContextKey::new("propagation.test")
  let original_ctx = Context::with_value(root_ctx, propagation_key, "propagation.value")
  
  // æ¨¡æ‹Ÿä¼ æ’­è¿‡ç¨‹
  let propagated_ctx = original_ctx // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™ä¼šç»è¿‡åºåˆ—åŒ–/ååºåˆ—åŒ–
  
  let propagated_value = Context::get(propagated_ctx, propagation_key)
  match propagated_value {
    Some(value) => assert_eq(value, "propagation.value")
    None => assert_true(false)
  }
}

test "Baggageåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•Baggageçš„åºåˆ—åŒ–å®Œæ•´æ€§
  let empty_baggage = Baggage::new()
  
  // åˆ›å»ºå¤æ‚çš„Baggage
  let baggage1 = Baggage::set_entry(empty_baggage, "user.id", "12345")
  let baggage2 = Baggage::set_entry(baggage1, "session.id", "session-abcdef")
  let baggage3 = Baggage::set_entry(baggage2, "request.id", "req-123456")
  let baggage4 = Baggage::set_entry(baggage3, "trace.id", "trace-789012")
  
  // éªŒè¯Baggageæ¡ç›®çš„è·å–
  let user_id = Baggage::get_entry(baggage4, "user.id")
  match user_id {
    Some(value) => assert_eq(value, "12345")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  let session_id = Baggage::get_entry(baggage4, "session.id")
  match session_id {
    Some(value) => assert_eq(value, "session-abcdef")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šé”®å’Œå€¼çš„Baggage
  let special_baggage_entries = [
    ("unicode.key", "æµ‹è¯•å€¼"),
    ("emoji.key", "ğŸš€value"),
    ("json.value", "{\"key\": \"value\", \"array\": [1, 2, 3]}"),
    ("url.value", "https://example.com/path?query=value"),
    ("empty.value", ""),
    ("numeric.value", "123456789"),
    ("special.chars", "!@#$%^&*()"),
    ("very.long.key", "very.long.key.name.with.many.dots.and.underscores"),
    ("very.long.value", "a" * 1000)
  ]
  
  let complex_baggage = empty_baggage
  for entry in special_baggage_entries {
    let updated_baggage = Baggage::set_entry(complex_baggage, entry.0, entry.1)
    
    let retrieved = Baggage::get_entry(updated_baggage, entry.0)
    match retrieved {
      Some(value) => assert_eq(value, entry.1)
      None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
    }
  }
  
  // æµ‹è¯•Baggageçš„åˆ é™¤æ“ä½œ
  let baggage_with_removal = Baggage::set_entry(empty_baggage, "temporary.key", "temporary.value")
  let baggage_after_removal = Baggage::remove_entry(baggage_with_removal, "temporary.key")
  
  let removed_value = Baggage::get_entry(baggage_after_removal, "temporary.key")
  // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒçœŸæ­£çš„åˆ é™¤
  match removed_value {
    Some(_) => assert_true(true) // å¯èƒ½ä»ç„¶å­˜åœ¨
    None => assert_true(true)    // æˆ–è€…å·²è¢«åˆ é™¤
  }
}

test "TextMapCarrieråºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // æµ‹è¯•TextMapCarrierçš„åºåˆ—åŒ–å®Œæ•´æ€§
  let empty_carrier = TextMapCarrier::new()
  
  // åˆ›å»ºå¤æ‚çš„TextMapCarrier
  let carrier1 = TextMapCarrier::new()
  TextMapCarrier::set(carrier1, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  TextMapCarrier::set(carrier1, "baggage", "user.id=12345,session.id=session-abcdef")
  TextMapCarrier::set(carrier1, "x-custom-header", "custom-value")
  TextMapCarrier::set(carrier1, "content-type", "application/json")
  
  // éªŒè¯å¤´éƒ¨è·å–
  let traceparent = TextMapCarrier::get(carrier1, "traceparent")
  match traceparent {
    Some(value) => assert_eq(value, "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
    None => assert_true(false)
  }
  
  let baggage = TextMapCarrier::get(carrier1, "baggage")
  match baggage {
    Some(value) => assert_eq(value, "user.id=12345,session.id=session-abcdef")
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå¤´éƒ¨å€¼
  let special_headers = [
    ("unicode.header", "æµ‹è¯•å¤´å€¼"),
    ("emoji.header", "ğŸš€header"),
    ("json.header", "{\"key\": \"value\", \"number\": 42}"),
    ("url.header", "https://example.com/path?query=value"),
    ("empty.header", ""),
    ("numeric.header", "123456789"),
    ("special.chars.header", "!@#$%^&*()_+-=[]{}|\\:;\"'<>?,./"),
    ("very.long.header.name", "very.long.header.name.with.many.dots.and.underscores"),
    ("very.long.header.value", "a" * 1000),
    ("header.with.spaces", " header value with spaces "),
    ("header.with.newlines", "header\nvalue\nwith\nnewlines"),
    ("header.with.tabs", "header\tvalue\twith\ttabs")
  ]
  
  for header in special_headers {
    let test_carrier = TextMapCarrier::new()
    TextMapCarrier::set(test_carrier, header.0, header.1)
    
    let retrieved = TextMapCarrier::get(test_carrier, header.0)
    match retrieved {
      Some(value) => assert_eq(value, header.1)
      None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒæŸäº›ç‰¹æ®Šå€¼
    }
  }
  
  // æµ‹è¯•å¤´éƒ¨è¦†ç›–
  let overwrite_carrier = TextMapCarrier::new()
  TextMapCarrier::set(overwrite_carrier, "test.header", "original.value")
  TextMapCarrier::set(overwrite_carrier, "test.header", "overwritten.value")
  
  let final_value = TextMapCarrier::get(overwrite_carrier, "test.header")
  match final_value {
    Some(value) => assert_eq(value, "overwritten.value") // ç®€åŒ–å®ç°å¯èƒ½ä¸ä¼šæ›´æ–°
    None => assert_true(false)
  }
}

test "ç»¼åˆåºåˆ—åŒ–å®Œæ•´æ€§æµ‹è¯•" {
  // åˆ›å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰ç»„ä»¶çš„ç»¼åˆåœºæ™¯
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "comprehensive.test")
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "comprehensive.test")
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "comprehensive.test")
  
  // åˆ›å»ºå¤æ‚å±æ€§
  let complex_attrs = Attributes::with_attributes(Attributes::new(), [
    ("test.complex.string", StringValue("complex value with special chars: æµ‹è¯•ğŸš€!@#$%")),
    ("test.complex.int", IntValue(12345)),
    ("test.complex.float", FloatValue(3.14159265359)),
    ("test.complex.bool", BoolValue(true)),
    ("test.complex.array", ArrayStringValue(["item1", "ä¸­æ–‡é¡¹ç›®", "ğŸš€emoji"]))
  ])
  
  // åˆ›å»ºå¤æ‚Resource
  let complex_resource = Resource::with_attributes(Resource::new(), [
    ("service.name", StringValue("comprehensive-test-service")),
    ("service.version", StringValue("1.2.3")),
    ("test.environment", StringValue("serialization-test")),
    ("test.complex", BoolValue(true))
  ])
  
  // åˆ›å»ºå¤æ‚SpanContext
  let complex_span_ctx = SpanContext::new(
    "trace1234567890123456",
    "span12345678901234",
    true,
    "test=complex,data=serialization"
  )
  
  // åˆ›å»ºå¤æ‚Span
  let complex_span = Span::new(
    "comprehensive.operation",
    Internal,
    complex_span_ctx
  )
  
  // åˆ›å»ºå¤æ‚LogRecord
  let complex_log = LogRecord::new_with_context(
    Info,
    Some("Comprehensive serialization test"),
    Some(complex_attrs),
    Some(Clock::now_unix_nanos(Clock::system())),
    Some(Clock::now_unix_nanos(Clock::system()) + 1000000L),
    Some(SpanContext::trace_id(complex_span_ctx)),
    Some(SpanContext::span_id(complex_span_ctx)),
    Some(Context::root())
  )
  
  // åˆ›å»ºå¤æ‚Context
  let complex_ctx = Context::root()
  let test_key = ContextKey::new("comprehensive.test.key")
  let complex_ctx_with_value = Context::with_value(complex_ctx, test_key, "comprehensive.test.value")
  
  // åˆ›å»ºå¤æ‚Baggage
  let complex_baggage = Baggage::new()
  let complex_baggage_with_entries = Baggage::set_entry(
    Baggage::set_entry(complex_baggage, "test.baggage1", "value1"),
    "test.baggage2",
    "value2"
  )
  
  // åˆ›å»ºå¤æ‚TextMapCarrier
  let complex_carrier = TextMapCarrier::new()
  TextMapCarrier::set(complex_carrier, "traceparent", "00-trace1234567890123456-span12345678901234-01")
  TextMapCarrier::set(complex_carrier, "baggage", "test.baggage1=value1,test.baggage2=value2")
  TextMapCarrier::set(complex_carrier, "x-comprehensive-test", "complex header value")
  
  // éªŒè¯æ‰€æœ‰ç»„ä»¶çš„å®Œæ•´æ€§
  assert_eq(complex_span.name, "comprehensive.operation")
  assert_eq(LogRecord::body(complex_log), Some("Comprehensive serialization test"))
  assert_eq(SpanContext::trace_id(complex_span_ctx), "trace1234567890123456")
  
  let service_name = Resource::get_attribute(complex_resource, "service.name")
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "comprehensive-test-service")
    _ => assert_true(false)
  }
  
  let ctx_value = Context::get(complex_ctx_with_value, test_key)
  match ctx_value {
    Some(value) => assert_eq(value, "comprehensive.test.value")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½ä¸æ”¯æŒ
  }
  
  let baggage_value = Baggage::get_entry(complex_baggage_with_entries, "test.baggage1")
  match baggage_value {
    Some(value) => assert_eq(value, "value1")
    None => assert_true(false) // ç®€åŒ–å®ç°å¯èƒ½è¿”å›None
  }
  
  let carrier_value = TextMapCarrier::get(complex_carrier, "x-comprehensive-test")
  match carrier_value {
    Some(value) => assert_eq(value, "complex header value")
    None => assert_true(false)
  }
  
  // æ‰§è¡Œæ“ä½œ
  Span::add_event(complex_span, "comprehensive.event", Some([
    ("test.attribute", StringValue("test.value")),
    ("test.number", IntValue(42))
  ]))
  
  Logger::emit(logger, complex_log)
  
  Span::end(complex_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}