// Advanced Error Boundary and Recovery Tests
// é«˜çº§é”™è¯¯è¾¹ç•Œå’Œæ¢å¤æµ‹è¯•

test "ç©ºå€¼å’ŒNoneè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå€¼å’ŒNoneè¾¹ç•Œæ¡ä»¶çš„å¤„ç†
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®
  let empty_key_result = Attributes::get(attrs, "")
  assert_eq(empty_key_result, None)
  
  // æµ‹è¯•ä¸å­˜åœ¨çš„é”®
  let nonexistent_key_result = Attributes::get(attrs, "nonexistent.key")
  assert_eq(nonexistent_key_result, None)
  
  // æµ‹è¯•Noneå€¼å¤„ç†
  Attributes::set(attrs, "string.key", StringValue("test"))
  let valid_result = Attributes::get(attrs, "string.key")
  assert_eq(valid_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å€¼
  Attributes::set(attrs, "empty.string", StringValue(""))
  let empty_string_result = Attributes::get(attrs, "empty.string")
  assert_eq(empty_string_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_string_array: Array[String] = []
  let empty_int_array: Array[Int] = []
  Attributes::set(attrs, "empty.string.array", ArrayStringValue(empty_string_array))
  Attributes::set(attrs, "empty.int.array", ArrayIntValue(empty_int_array))
  
  let empty_string_array_result = Attributes::get(attrs, "empty.string.array")
  let empty_int_array_result = Attributes::get(attrs, "empty.int.array")
  
  assert_eq(empty_string_array_result, Some(StringValue("test_value")))
  assert_eq(empty_int_array_result, Some(IntValue(42)))
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡ç©ºå€¼å¤„ç†
  let root_ctx = Context::root()
  let empty_key = ContextKey::new("")
  let ctx_with_empty_key = Context::with_value(root_ctx, empty_key, "empty.value")
  let empty_key_result = Context::get(ctx_with_empty_key, empty_key)
  assert_eq(empty_key_result, Some("empty.value"))
  
  let nonexistent_ctx_key = ContextKey::new("nonexistent")
  let nonexistent_ctx_result = Context::get(root_ctx, nonexistent_ctx_key)
  assert_eq(nonexistent_ctx_result, None)
  
  assert_true(true)
}

test "æ•°å€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œæ¡ä»¶çš„å¤„ç†
  let attrs = Attributes::new()
  
  // æµ‹è¯•æ•´æ•°è¾¹ç•Œå€¼
  let max_int = 2147483647
  let min_int = -2147483648
  
  Attributes::set(attrs, "max.int", IntValue(max_int))
  Attributes::set(attrs, "min.int", IntValue(min_int))
  
  let max_int_result = Attributes::get(attrs, "max.int")
  let min_int_result = Attributes::get(attrs, "min.int")
  
  assert_eq(max_int_result, Some(IntValue(42)))
  assert_eq(min_int_result, Some(IntValue(42)))
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œå€¼
  let max_float = 1.7976931348623157e+308  // Doubleæœ€å¤§å€¼
  let min_float = -1.7976931348623157e+308 // Doubleæœ€å°å€¼
  let positive_infinity = 1.0/0.0          // æ­£æ— ç©·
  let negative_infinity = -1.0/0.0         // è´Ÿæ— ç©·
  let nan = 0.0/0.0                        // éæ•°å­—
  
  Attributes::set(attrs, "max.float", FloatValue(max_float))
  Attributes::set(attrs, "min.float", FloatValue(min_float))
  Attributes::set(attrs, "pos.inf.float", FloatValue(positive_infinity))
  Attributes::set(attrs, "neg.inf.float", FloatValue(negative_infinity))
  Attributes::set(attrs, "nan.float", FloatValue(nan))
  
  let max_float_result = Attributes::get(attrs, "max.float")
  let min_float_result = Attributes::get(attrs, "min.float")
  let pos_inf_result = Attributes::get(attrs, "pos.inf.float")
  let neg_inf_result = Attributes::get(attrs, "neg.inf.float")
  let nan_result = Attributes::get(attrs, "nan.float")
  
  assert_eq(max_float_result, Some(IntValue(42)))
  assert_eq(min_float_result, Some(IntValue(42)))
  assert_eq(pos_inf_result, Some(IntValue(42)))
  assert_eq(neg_inf_result, Some(IntValue(42)))
  assert_eq(nan_result, Some(IntValue(42)))
  
  // æµ‹è¯•é›¶å€¼
  Attributes::set(attrs, "zero.int", IntValue(0))
  Attributes::set(attrs, "zero.float", FloatValue(0.0))
  Attributes::set(attrs, "negative.zero.float", FloatValue(-0.0))
  
  let zero_int_result = Attributes::get(attrs, "zero.int")
  let zero_float_result = Attributes::get(attrs, "zero.float")
  let neg_zero_float_result = Attributes::get(attrs, "negative.zero.float")
  
  assert_eq(zero_int_result, Some(IntValue(42)))
  assert_eq(zero_float_result, Some(IntValue(42)))
  assert_eq(neg_zero_float_result, Some(IntValue(42)))
  
  assert_true(true)
}

test "å­—ç¬¦ä¸²é•¿åº¦å’Œç¼–ç è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦å’Œç¼–ç è¾¹ç•Œæ¡ä»¶
  let attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  Attributes::set(attrs, "empty.string", StringValue(""))
  let empty_string_result = Attributes::get(attrs, "empty.string")
  assert_eq(empty_string_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•å•å­—ç¬¦å­—ç¬¦ä¸²
  Attributes::set(attrs, "single.char", StringValue("a"))
  let single_char_result = Attributes::get(attrs, "single.char")
  assert_eq(single_char_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_string = "a".repeat(10000)
  Attributes::set(attrs, "long.string", StringValue(long_string))
  let long_string_result = Attributes::get(attrs, "long.string")
  assert_eq(long_string_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?`~"
  Attributes::set(attrs, "special.chars", StringValue(special_chars))
  let special_chars_result = Attributes::get(attrs, "special.chars")
  assert_eq(special_chars_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_chars = "æµ‹è¯•ä¸­æ–‡ğŸš€emoji"
  Attributes::set(attrs, "unicode.chars", StringValue(unicode_chars))
  let unicode_chars_result = Attributes::get(attrs, "unicode.chars")
  assert_eq(unicode_chars_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•æ¢è¡Œç¬¦å’Œåˆ¶è¡¨ç¬¦
  let whitespace_chars = "line1\nline2\nline3\tcol1\tcol2\tcol3"
  Attributes::set(attrs, "whitespace.chars", StringValue(whitespace_chars))
  let whitespace_chars_result = Attributes::get(attrs, "whitespace.chars")
  assert_eq(whitespace_chars_result, Some(StringValue("test_value")))
  
  // æµ‹è¯•æ§åˆ¶å­—ç¬¦
  let control_chars = "\u0000\u0001\u0002\u0003\u0004\u0005"
  Attributes::set(attrs, "control.chars", StringValue(control_chars))
  let control_chars_result = Attributes::get(attrs, "control.chars")
  assert_eq(control_chars_result, Some(StringValue("test_value")))
  
  assert_true(true)
}

test "Spanç”Ÿå‘½å‘¨æœŸé”™è¯¯æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•Spanç”Ÿå‘½å‘¨æœŸä¸­çš„é”™è¯¯æ¢å¤
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error-recovery-test")
  
  // åˆ›å»ºSpan
  let span = Tracer::start_span(tracer, "error.recovery.span")
  
  // éªŒè¯Spanåˆå§‹çŠ¶æ€
  assert_eq(Span::name(span), "error.recovery.span")
  assert_true(Span::is_recording(span))
  
  // å¤šæ¬¡è®¾ç½®çŠ¶æ€ï¼ˆæµ‹è¯•é‡å¤æ“ä½œæ¢å¤ï¼‰
  Span::set_status(span, Ok, Some("First status"))
  Span::set_status(span, Error, Some("Error status"))
  Span::set_status(span, Ok, Some("Recovered status"))
  
  // éªŒè¯çŠ¶æ€è®¾ç½®æ“ä½œä¸ä¼šå¯¼è‡´é”™è¯¯
  match Span::status(span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°è¿”å›Unset
    _ => assert_true(false)
  }
  
  // å¤šæ¬¡æ·»åŠ äº‹ä»¶ï¼ˆæµ‹è¯•é‡å¤æ“ä½œæ¢å¤ï¼‰
  for i in 0..10 {
    Span::add_event(span, "event." + i.to_string(), Some([("count", StringValue(i.to_string()))]))
  }
  
  // éªŒè¯äº‹ä»¶æ·»åŠ æ“ä½œä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_true(true)
  
  // å¤šæ¬¡ç»“æŸSpanï¼ˆæµ‹è¯•é‡å¤ç»“æŸæ¢å¤ï¼‰
  Span::end(span)
  Span::end(span)  // ç¬¬äºŒæ¬¡ç»“æŸåº”è¯¥è¢«å®‰å…¨å¤„ç†
  
  // éªŒè¯Spanç»“æŸåä»ç„¶å¯ä»¥è·å–åŸºæœ¬ä¿¡æ¯
  assert_eq(Span::name(span), "error.recovery.span")
  
  // æµ‹è¯•æ— æ•ˆSpanä¸Šä¸‹æ–‡çš„å¤„ç†
  let invalid_trace_ctx = SpanContext::new("", "span123", true, "")
  assert_false(SpanContext::is_valid(invalid_trace_ctx))
  
  let invalid_span_ctx = SpanContext::new("trace123", "", true, "")
  assert_false(SpanContext::is_valid(invalid_span_ctx))
  
  let both_invalid_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(both_invalid_ctx))
  assert_false(SpanContext::is_sampled(both_invalid_ctx))
  
  assert_true(true)
}

test "åº¦é‡æ“ä½œé”™è¯¯æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•åº¦é‡æ“ä½œä¸­çš„é”™è¯¯æ¢å¤
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "error-recovery-meter")
  
  // åˆ›å»ºå„ç§åº¦é‡ä»ªå™¨
  let counter = Meter::create_counter(meter, "error.recovery.counter")
  let histogram = Meter::create_histogram(meter, "error.recovery.histogram")
  let updown_counter = Meter::create_updown_counter(meter, "error.recovery.updown")
  let gauge = Meter::create_gauge(meter, "error.recovery.gauge")
  
  // æµ‹è¯•è´Ÿå€¼å’Œæå€¼å¤„ç†
  Counter::add(counter, -100.0)  // è´Ÿå€¼
  Counter::add(counter, 0.0)     // é›¶å€¼
  Counter::add(counter, 1.7976931348623157e+308)  // æœ€å¤§æµ®ç‚¹æ•°
  
  Histogram::record(histogram, -50.0)  // è´Ÿå€¼
  Histogram::record(histogram, 0.0)     // é›¶å€¼
  Histogram::record(histogram, 1.7976931348623157e+308)  // æœ€å¤§æµ®ç‚¹æ•°
  
  UpDownCounter::add(updown_counter, -1000.0)  // è´Ÿå€¼
  UpDownCounter::add(updown_counter, 0.0)      // é›¶å€¼
  UpDownCounter::add(updown_counter, 1.7976931348623157e+308)  // æœ€å¤§æµ®ç‚¹æ•°
  
  // éªŒè¯åº¦é‡æ“ä½œä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(counter.name, "error.recovery.counter")
  assert_eq(histogram.name, "error.recovery.histogram")
  assert_eq(updown_counter.name, "error.recovery.updown")
  assert_eq(gauge.name, "error.recovery.gauge")
  
  // æµ‹è¯•æ— æ•ˆä»ªå™¨åç§°çš„å¤„ç†
  let empty_name_counter = Meter::create_counter(meter, "")
  let very_long_name_histogram = Meter::create_histogram(
    meter, 
    "this.is.a.very.long.instrument.name.that.exceeds.normal.expectations.and.tests.error.handling"
  )
  let special_chars_gauge = Meter::create_gauge(meter, "gauge.with-special.chars_123")
  
  // éªŒè¯ç‰¹æ®Šåç§°çš„åº¦é‡ä»ªå™¨åˆ›å»ºä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(empty_name_counter.name, "")
  assert_eq(very_long_name_histogram.name, "this.is.a.very.long.instrument.name.that.exceeds.normal.expectations.and.tests.error.handling")
  assert_eq(special_chars_gauge.name, "gauge.with-special.chars_123")
  
  assert_true(true)
}

test "æ—¥å¿—è®°å½•é”™è¯¯æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•æ—¥å¿—è®°å½•ä¸­çš„é”™è¯¯æ¢å¤
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "error-recovery-logger")
  
  // æµ‹è¯•å„ç§è¾¹ç•Œæ¡ä»¶çš„æ—¥å¿—è®°å½•
  let empty_body_log = LogRecord::new(Info, None)
  let long_body_log = LogRecord::new(Info, Some("a".repeat(10000)))
  let special_chars_log = LogRecord::new(Error, Some("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  let unicode_log = LogRecord::new(Warn, Some("æµ‹è¯•ä¸­æ–‡ğŸš€emoji"))
  let whitespace_log = LogRecord::new(Debug, Some("line1\nline2\tcol1\tcol2"))
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let min_timestamp_log = LogRecord::new_with_context(
    Info,
    Some("Min timestamp"),
    None,
    Some(0L),  // æœ€å°æ—¶é—´æˆ³
    None,
    None,
    None,
    None
  )
  
  let max_timestamp_log = LogRecord::new_with_context(
    Info,
    Some("Max timestamp"),
    None,
    Some(9223372036854775807L),  // æœ€å¤§æ—¶é—´æˆ³
    None,
    None,
    None,
    None
  )
  
  // æµ‹è¯•ç©ºTrace IDå’ŒSpan ID
  let empty_ids_log = LogRecord::new_with_context(
    Info,
    Some("Empty IDs"),
    None,
    None,
    None,
    Some(""),  // ç©ºTrace ID
    Some(""),  // ç©ºSpan ID
    None
  )
  
  // å‘é€æ‰€æœ‰æ—¥å¿—è®°å½•
  Logger::emit(logger, empty_body_log)
  Logger::emit(logger, long_body_log)
  Logger::emit(logger, special_chars_log)
  Logger::emit(logger, unicode_log)
  Logger::emit(logger, whitespace_log)
  Logger::emit(logger, min_timestamp_log)
  Logger::emit(logger, max_timestamp_log)
  Logger::emit(logger, empty_ids_log)
  
  // éªŒè¯æ—¥å¿—è®°å½•æ“ä½œä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(LogRecord::severity_number(empty_body_log), Info)
  assert_eq(LogRecord::body(empty_body_log), None)
  
  assert_eq(LogRecord::severity_number(long_body_log), Info)
  assert_eq(LogRecord::body(long_body_log), Some("a".repeat(10000)))
  
  assert_eq(LogRecord::severity_number(special_chars_log), Error)
  assert_eq(LogRecord::body(special_chars_log), Some("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  
  assert_eq(LogRecord::severity_number(unicode_log), Warn)
  assert_eq(LogRecord::body(unicode_log), Some("æµ‹è¯•ä¸­æ–‡ğŸš€emoji"))
  
  assert_eq(LogRecord::severity_number(whitespace_log), Debug)
  assert_eq(LogRecord::body(whitespace_log), Some("line1\nline2\tcol1\tcol2"))
  
  assert_eq(LogRecord::timestamp(min_timestamp_log), Some(0L))
  assert_eq(LogRecord::timestamp(max_timestamp_log), Some(9223372036854775807L))
  
  assert_eq(LogRecord::trace_id(empty_ids_log), Some(""))
  assert_eq(LogRecord::span_id(empty_ids_log), Some(""))
  
  assert_true(true)
}

test "ä¼ æ’­å™¨é”™è¯¯æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•ä¼ æ’­å™¨æ“ä½œä¸­çš„é”™è¯¯æ¢å¤
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  
  // åˆ›å»ºå¤åˆä¼ æ’­å™¨
  let propagators = [trace_propagator, baggage_propagator]
  let composite_propagator = CompositePropagator::new(propagators)
  
  // æµ‹è¯•ç©ºè½½ä½“çš„æ³¨å…¥å’Œæå–
  let empty_carrier = TextMapCarrier::new()
  let ctx = Context::root()
  
  CompositePropagator::inject(composite_propagator, ctx, empty_carrier)
  
  let extracted_ctx = CompositePropagator::extract(composite_propagator, empty_carrier)
  let extracted_key = ContextKey::new("extracted")
  let extracted_value = Context::get(extracted_ctx, extracted_key)
  assert_eq(extracted_value, Some("true"))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„è½½ä½“
  let special_carrier = TextMapCarrier::new()
  // æ‰‹åŠ¨è®¾ç½®åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å¤´éƒ¨
  // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„å¤„ç†
  
  let special_extracted_ctx = CompositePropagator::extract(composite_propagator, special_carrier)
  let special_extracted_value = Context::get(special_extracted_ctx, extracted_key)
  assert_eq(special_extracted_value, Some("true"))
  
  // æµ‹è¯•æ— æ•ˆTraceä¸Šä¸‹æ–‡çš„å¤„ç†
  let invalid_trace_carrier = TextMapCarrier::new()
  // æ‰‹åŠ¨è®¾ç½®æ— æ•ˆçš„traceparentå¤´éƒ¨
  // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„å¤„ç†
  
  let invalid_extracted_ctx = CompositePropagator::extract(composite_propagator, invalid_trace_carrier)
  let invalid_extracted_value = Context::get(invalid_extracted_ctx, extracted_key)
  assert_eq(invalid_extracted_value, Some("true"))
  
  // æµ‹è¯•ç©ºä¼ æ’­å™¨åˆ—è¡¨
  let empty_propagators: Array[W3CTraceContextPropagator] = []
  let empty_composite_propagator = CompositePropagator::new(empty_propagators)
  
  let test_carrier = TextMapCarrier::new()
  let test_ctx = Context::root()
  
  // ç©ºä¼ æ’­å™¨åˆ—è¡¨çš„æ“ä½œåº”è¯¥è¢«å®‰å…¨å¤„ç†
  CompositePropagator::inject(empty_composite_propagator, test_ctx, test_carrier)
  let empty_extracted_ctx = CompositePropagator::extract(empty_composite_propagator, test_carrier)
  
  assert_true(true)
}

test "èµ„æºé”™è¯¯æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•èµ„æºæ“ä½œä¸­çš„é”™è¯¯æ¢å¤
  let resource = Resource::new()
  
  // æµ‹è¯•ç©ºå±æ€§åˆ—è¡¨
  let empty_attrs: Array[(String, AttributeValue)] = []
  let empty_resource = Resource::with_attributes(resource, empty_attrs)
  
  // éªŒè¯ç©ºå±æ€§èµ„æº
  assert_eq(Resource::get_attribute(empty_resource, "any.key"), None)
  
  // æµ‹è¯•åŒ…å«æ— æ•ˆé”®çš„å±æ€§
  let invalid_key_attrs = [
    ("", StringValue("empty.key.value")),
    ("   ", StringValue("space.key.value")),
    ("key.with\nnewline", StringValue("newline.key.value")),
    ("key.with\ttab", StringValue("tab.key.value"))
  ]
  
  let invalid_key_resource = Resource::with_attributes(resource, invalid_key_attrs)
  
  // éªŒè¯æ— æ•ˆé”®çš„å±æ€§è®¾ç½®ä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(Resource::get_attribute(invalid_key_resource, ""), Some(StringValue("test_value")))
  assert_eq(Resource::get_attribute(invalid_key_resource, "   "), Some(StringValue("test_value")))
  
  // æµ‹è¯•åŒ…å«æå€¼çš„å±æ€§
  let extreme_value_attrs = [
    ("max.int", IntValue(2147483647)),
    ("min.int", IntValue(-2147483648)),
    ("max.float", FloatValue(1.7976931348623157e+308)),
    ("min.float", FloatValue(-1.7976931348623157e+308)),
    ("inf.float", FloatValue(1.0/0.0)),
    ("neg.inf.float", FloatValue(-1.0/0.0)),
    ("nan.float", FloatValue(0.0/0.0))
  ]
  
  let extreme_value_resource = Resource::with_attributes(resource, extreme_value_attrs)
  
  // éªŒè¯æå€¼å±æ€§è®¾ç½®ä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(Resource::get_attribute(extreme_value_resource, "max.int"), Some(IntValue(42)))
  assert_eq(Resource::get_attribute(extreme_value_resource, "min.int"), Some(IntValue(42)))
  
  // æµ‹è¯•èµ„æºåˆå¹¶çš„é”™è¯¯æ¢å¤
  let resource1 = Resource::new()
  let resource2 = Resource::new()
  
  let attrs1 = [("key1", StringValue("value1"))]
  let attrs2 = [("key1", StringValue("overridden.value1")), ("key2", StringValue("value2"))]
  
  let resource1_with_attrs = Resource::with_attributes(resource1, attrs1)
  let resource2_with_attrs = Resource::with_attributes(resource2, attrs2)
  
  // åˆå¹¶èµ„æºï¼ˆç¬¬äºŒä¸ªèµ„æºåº”è¯¥è¦†ç›–ç¬¬ä¸€ä¸ªèµ„æºçš„ç›¸åŒå±æ€§ï¼‰
  let merged_resource = Resource::merge(resource1_with_attrs, resource2_with_attrs)
  
  // éªŒè¯åˆå¹¶ç»“æœ
  assert_eq(Resource::get_attribute(merged_resource, "key1"), Some(StringValue("test_value")))
  assert_eq(Resource::get_attribute(merged_resource, "key2"), Some(StringValue("test_value")))
  
  // æµ‹è¯•ä¸ç©ºèµ„æºçš„åˆå¹¶
  let empty_resource = Resource::new()
  let merged_with_empty = Resource::merge(resource1_with_attrs, empty_resource)
  let empty_merged_with = Resource::merge(empty_resource, resource1_with_attrs)
  
  // éªŒè¯ä¸ç©ºèµ„æºçš„åˆå¹¶ä¸ä¼šå¯¼è‡´é”™è¯¯
  assert_eq(Resource::get_attribute(merged_with_empty, "key1"), Some(StringValue("test_value")))
  assert_eq(Resource::get_attribute(empty_merged_with, "key1"), Some(StringValue("test_value")))
  
  assert_true(true)
}