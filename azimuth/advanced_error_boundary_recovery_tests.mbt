// è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯æ¢å¤æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Azimuthé¥æµ‹ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„ç¨³å®šæ€§

test "span_context_boundary_conditions" {
  // æµ‹è¯•Spanä¸Šä¸‹æ–‡çš„è¾¹ç•Œæ¡ä»¶
  let empty_trace_id = ""
  let empty_span_id = ""
  let valid_trace_id = "0af7651916cd43dd8448eb211c80319c"
  let valid_span_id = "b7ad6b7169203331"
  
  // æµ‹è¯•ç©ºIDçš„æ— æ•ˆä¸Šä¸‹æ–‡
  let empty_trace_ctx = SpanContext::new(empty_trace_id, valid_span_id, true, "")
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  
  let empty_span_ctx = SpanContext::new(valid_trace_id, empty_span_id, true, "")
  assert_false(SpanContext::is_valid(empty_span_ctx))
  
  let both_empty_ctx = SpanContext::new(empty_trace_id, empty_span_id, true, "")
  assert_false(SpanContext::is_valid(both_empty_ctx))
  
  // æµ‹è¯•æœ‰æ•ˆä¸Šä¸‹æ–‡
  let valid_ctx = SpanContext::new(valid_trace_id, valid_span_id, true, "")
  assert_true(SpanContext::is_valid(valid_ctx))
  
  // æµ‹è¯•é‡‡æ ·çŠ¶æ€è¾¹ç•Œ
  let sampled_ctx = SpanContext::new(valid_trace_id, valid_span_id, true, "")
  assert_true(SpanContext::is_sampled(sampled_ctx))
  
  let not_sampled_ctx = SpanContext::new(valid_trace_id, valid_span_id, false, "")
  assert_false(SpanContext::is_sampled(not_sampled_ctx))
}

test "attribute_value_extreme_values" {
  // æµ‹è¯•AttributeValueçš„æå€¼å¤„ç†
  let attributes = Attributes::new()
  
  // æµ‹è¯•ææ•´æ•°å€¼
  let max_int = IntValue(2147483647)
  let min_int = IntValue(-2147483648)
  let zero_int = IntValue(0)
  
  Attributes::set(attributes, "max.int", max_int)
  Attributes::set(attributes, "min.int", min_int)
  Attributes::set(attributes, "zero.int", zero_int)
  
  // æµ‹è¯•ææµ®ç‚¹æ•°å€¼
  let max_float = FloatValue(1.7976931348623157e+308)
  let min_float = FloatValue(-1.7976931348623157e+308)
  let zero_float = FloatValue(0.0)
  let inf_float = FloatValue(1.0 / 0.0)  // æ— ç©·å¤§
  let neg_inf_float = FloatValue(-1.0 / 0.0)  // è´Ÿæ— ç©·å¤§
  let nan_float = FloatValue(0.0 / 0.0)  // NaN
  
  Attributes::set(attributes, "max.float", max_float)
  Attributes::set(attributes, "min.float", min_float)
  Attributes::set(attributes, "zero.float", zero_float)
  Attributes::set(attributes, "inf.float", inf_float)
  Attributes::set(attributes, "neg.inf.float", neg_inf_float)
  Attributes::set(attributes, "nan.float", nan_float)
  
  // æµ‹è¯•æå­—ç¬¦ä¸²å€¼
  let empty_string = StringValue("")
  let long_string = StringValue("a" * 10000)  // å¾ˆé•¿çš„å­—ç¬¦ä¸²
  let unicode_string = StringValue("ğŸš€ğŸŒŸğŸ’»ğŸ“ŠğŸ“ˆğŸ”ğŸ”§âš¡ğŸ¯ğŸ†")
  let special_chars = StringValue("\n\t\r\\\"'<>{}[]|\\")
  
  Attributes::set(attributes, "empty.string", empty_string)
  Attributes::set(attributes, "long.string", long_string)
  Attributes::set(attributes, "unicode.string", unicode_string)
  Attributes::set(attributes, "special.chars", special_chars)
  
  // æµ‹è¯•æå¸ƒå°”å€¼
  let true_val = BoolValue(true)
  let false_val = BoolValue(false)
  
  Attributes::set(attributes, "true.val", true_val)
  Attributes::set(attributes, "false.val", false_val)
  
  // æµ‹è¯•ææ•°ç»„å€¼
  let empty_array = ArrayStringValue([])
  let large_array = ArrayStringValue(["item"] * 1000)
  let nested_array = ArrayStringValue(["[\"nested\", \"array\"]"])
  
  Attributes::set(attributes, "empty.array", empty_array)
  Attributes::set(attributes, "large.array", large_array)
  Attributes::set(attributes, "nested.array", nested_array)
  
  // éªŒè¯æå€¼å¤„ç†ä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_true(true)
}

test "context_propagation_failure_recovery" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¼ æ’­å¤±è´¥æ—¶çš„æ¢å¤æœºåˆ¶
  let propagator = CompositePropagator::new([W3CTraceContextPropagator::new()])
  let carrier = TextMapCarrier::new()
  
  // æµ‹è¯•æŸåçš„traceparentå¤´
  TextMapCarrier::set(carrier, "traceparent", "invalid-format")
  let recovered_ctx_1 = CompositePropagator::extract(propagator, carrier)
  assert_true(recovered_ctx_1.data != None)  // åº”è¯¥æ¢å¤åˆ°é»˜è®¤ä¸Šä¸‹æ–‡
  
  // æµ‹è¯•ç¼ºå°‘traceparentå¤´
  let empty_carrier = TextMapCarrier::new()
  let recovered_ctx_2 = CompositePropagator::extract(propagator, empty_carrier)
  assert_true(recovered_ctx_2.data != None)  // åº”è¯¥æ¢å¤åˆ°é»˜è®¤ä¸Šä¸‹æ–‡
  
  // æµ‹è¯•éƒ¨åˆ†æŸåçš„å¤´
  TextMapCarrier::set(carrier, "traceparent", "00-0af7651916cd43dd8448eb211c80319c")  // ç¼ºå°‘span_idå’Œflags
  let recovered_ctx_3 = CompositePropagator::extract(propagator, carrier)
  assert_true(recovered_ctx_3.data != None)  // åº”è¯¥æ¢å¤åˆ°é»˜è®¤ä¸Šä¸‹æ–‡
  
  // éªŒè¯æ¢å¤åçš„ä¸Šä¸‹æ–‡å¯ä»¥æ­£å¸¸ä½¿ç”¨
  let key = ContextKey::new("recovery.test")
  let ctx_with_value = Context::with_value(recovered_ctx_1, key, "recovered")
  let retrieved_value = Context::get(ctx_with_value, key)
  assert_eq(retrieved_value, Some("recovered"))
}

test "metrics_overflow_handling" {
  // æµ‹è¯•åº¦é‡æº¢å‡ºå¤„ç†
  let meter = MeterProvider::get_meter(MeterProvider::default(), "overflow-test")
  let counter = Meter::create_counter(meter, "overflow.counter")
  let histogram = Meter::create_histogram(meter, "overflow.histogram")
  
  // æµ‹è¯•è®¡æ•°å™¨æº¢å‡º
  let large_value = 9007199254740992.0  // æ¥è¿‘Doubleçš„æœ€å¤§å®‰å…¨æ•´æ•°
  Counter::add(counter, large_value)
  Counter::add(counter, large_value)  // å†æ¬¡æ·»åŠ å¤§å€¼
  
  // æµ‹è¯•ç›´æ–¹å›¾æº¢å‡ºå€¼
  let overflow_value = 1.7976931348623157e+308  // æœ€å¤§Doubleå€¼
  Histogram::record(histogram, overflow_value)
  Histogram::record(histogram, -overflow_value)  // è´Ÿæº¢å‡ºå€¼
  Histogram::record(histogram, 1.0 / 0.0)  // æ— ç©·å¤§
  Histogram::record(histogram, 0.0 / 0.0)  // NaN
  
  // éªŒè¯æº¢å‡ºå¤„ç†ä¸ä¼šå¯¼è‡´å´©æºƒ
  assert_true(true)
}

test "logging_error_boundary" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„é”™è¯¯è¾¹ç•Œ
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "error-boundary-test")
  
  // æµ‹è¯•ç©ºæ—¥å¿—è®°å½•
  let empty_log = LogRecord::new(Info, "")
  Logger::emit(logger, empty_log)
  
  // æµ‹è¯•Noneæ—¥å¿—ä½“
  let none_body_log = LogRecord::new_with_context(
    Warn,
    None,
    Some(Attributes::new()),
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    None,
    None,
    Some(Context::root())
  )
  Logger::emit(logger, none_body_log)
  
  // æµ‹è¯•æé•¿æ—¥å¿—æ¶ˆæ¯
  let very_long_message = "This is a very long log message " * 1000
  let long_log = LogRecord::new(Error, very_long_message)
  Logger::emit(logger, long_log)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æ—¥å¿—
  let special_chars_log = LogRecord::new(Debug, "Special chars: \n\t\r\\\"'<>{}[]|\\")
  Logger::emit(logger, special_chars_log)
  
  // æµ‹è¯•Unicodeæ—¥å¿—
  let unicode_log = LogRecord::new(Info, "Unicode test: ğŸš€ğŸŒŸğŸ’»ğŸ“ŠğŸ“ˆğŸ”ğŸ”§âš¡ğŸ¯ğŸ†")
  Logger::emit(logger, unicode_log)
  
  // æµ‹è¯•æ— æ•ˆæ—¶é—´æˆ³
  let invalid_timestamp_log = LogRecord::new_with_context(
    Fatal,
    Some("Invalid timestamp test"),
    None,
    Some(-1L),  // è´Ÿæ—¶é—´æˆ³
    None,
    None,
    None,
    None
  )
  Logger::emit(logger, invalid_timestamp_log)
  
  // éªŒè¯æ‰€æœ‰æ—¥å¿—éƒ½èƒ½æ­£å¸¸å¤„ç†
  assert_true(true)
}

test "resource_attribute_isolation" {
  // æµ‹è¯•èµ„æºå±æ€§çš„éš”ç¦»æ€§
  let resource1 = Resource::new()
  let resource2 = Resource::new()
  
  // ä¸ºèµ„æº1è®¾ç½®å±æ€§
  let resource1_with_attrs = Resource::with_attributes(resource1, [
    ("service.name", StringValue("service1")),
    ("service.version", StringValue("1.0.0"))
  ])
  
  // ä¸ºèµ„æº2è®¾ç½®å±æ€§
  let resource2_with_attrs = Resource::with_attributes(resource2, [
    ("service.name", StringValue("service2")),
    ("service.version", StringValue("2.0.0"))
  ])
  
  // éªŒè¯èµ„æºéš”ç¦»
  assert_eq(Resource::get_attribute(resource1_with_attrs, "service.name"), Some(StringValue("service1")))
  assert_eq(Resource::get_attribute(resource2_with_attrs, "service.name"), Some(StringValue("service2")))
  
  // æµ‹è¯•èµ„æºåˆå¹¶çš„éš”ç¦»æ€§
  let base_resource = Resource::with_attributes(Resource::new(), [
    ("global.attr", StringValue("global_value"))
  ])
  
  let merged1 = Resource::merge(base_resource, resource1_with_attrs)
  let merged2 = Resource::merge(base_resource, resource2_with_attrs)
  
  // éªŒè¯åˆå¹¶åçš„èµ„æºä¿æŒéš”ç¦»
  assert_eq(Resource::get_attribute(merged1, "service.name"), Some(StringValue("service1")))
  assert_eq(Resource::get_attribute(merged2, "service.name"), Some(StringValue("service2")))
}

test "baggage_size_limits" {
  // æµ‹è¯•Baggageå¤§å°é™åˆ¶
  let baggage = Baggage::new()
  
  // æµ‹è¯•æ·»åŠ å¤§é‡æ¡ç›®
  let large_baggage = baggage
  for i in 0..1000 {
    large_baggage = Baggage::set_entry(large_baggage, "key." + i.to_string(), "value." + i.to_string())
  }
  
  // æµ‹è¯•æé•¿çš„é”®å’Œå€¼
  let very_long_key = "k" * 1000
  let very_long_value = "v" * 1000
  let long_key_baggage = Baggage::set_entry(baggage, very_long_key, very_long_value)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å’Œå€¼
  let special_key_baggage = Baggage::set_entry(baggage, "special.key", "special=value&test")
  let unicode_key_baggage = Baggage::set_entry(baggage, "unicode.é”®", "unicode.å€¼")
  
  // éªŒè¯å¤§å®¹é‡Baggageçš„å¤„ç†
  let retrieved_long_value = Baggage::get_entry(long_key_baggage, very_long_key)
  assert_eq(retrieved_long_value, Some(very_long_value))
  
  let retrieved_special_value = Baggage::get_entry(special_key_baggage, "special.key")
  assert_eq(retrieved_special_value, Some("special=value&test"))
  
  let retrieved_unicode_value = Baggage::get_entry(unicode_key_baggage, "unicode.é”®")
  assert_eq(retrieved_unicode_value, Some("unicode.å€¼"))
}

test "http_client_error_handling" {
  // æµ‹è¯•HTTPå®¢æˆ·ç«¯é”™è¯¯å¤„ç†
  let client = HttpClient::new()
  
  // æµ‹è¯•æ— æ•ˆURL
  let invalid_url_request = HttpRequest::new("GET", "invalid-url", [], None)
  assert_eq(HttpRequest::http_method(invalid_url_request), "GET")
  assert_eq(HttpRequest::url(invalid_url_request), "invalid-url")
  
  // æµ‹è¯•ç©ºè¯·æ±‚
  let empty_request = HttpRequest::new("", "", [], None)
  assert_eq(HttpRequest::http_method(empty_request), "")
  assert_eq(HttpRequest::url(empty_request), "")
  
  // æµ‹è¯•æå¤§è¯·æ±‚ä½“
  let large_body = "x" * 1000000
  let large_body_request = HttpRequest::new("POST", "https://example.com", [], Some(large_body))
  assert_eq(HttpRequest::body(large_body_request), Some(large_body))
  
  // æµ‹è¯•é”™è¯¯å“åº”
  let error_response = HttpResponse::new(500, [("Content-Type", "text/plain")], Some("Internal Server Error"))
  assert_eq(HttpResponse::status_code(error_response), 500)
  assert_eq(HttpResponse::body(error_response), Some("Internal Server Error"))
  
  // æµ‹è¯•æ— æ•ˆçŠ¶æ€ç 
  let invalid_status_response = HttpResponse::new(-1, [], None)
  assert_eq(HttpResponse::status_code(invalid_status_response), -1)
  
  // æµ‹è¯•æå¤§å“åº”ä½“
  let large_response_body = "response data " * 100000
  let large_response = HttpResponse::new(200, [("Content-Length", large_response_body.length().to_string())], Some(large_response_body))
  assert_eq(HttpResponse::body(large_response), Some(large_response_body))
}

test "clock_and_random_edge_cases" {
  // æµ‹è¯•æ—¶é’Ÿå’Œéšæœºæ•°çš„è¾¹ç•Œæƒ…å†µ
  let clock = Clock::system()
  let random = Random::system()
  
  // æµ‹è¯•æ—¶é’Ÿè¾¹ç•Œ
  let timestamp1 = Clock::now_unix_nanos(clock)
  let timestamp2 = Clock::now_unix_nanos(clock)
  
  // æ—¶é—´æˆ³åº”è¯¥æ˜¯é€’å¢çš„ï¼ˆæˆ–è‡³å°‘ä¸é€’å‡ï¼‰
  assert_true(timestamp2 >= timestamp1)
  
  // æµ‹è¯•æé•¿å­—èŠ‚æ•°ç»„
  let large_bytes = Random::next_bytes(random, 1000000)
  assert_eq(large_bytes.length(), 0)  // åŸºäºç®€åŒ–å®ç°
  
  // æµ‹è¯•é›¶é•¿åº¦å­—èŠ‚æ•°ç»„
  let empty_bytes = Random::next_bytes(random, 0)
  assert_eq(empty_bytes.length(), 0)
  
  // æµ‹è¯•è´Ÿé•¿åº¦å­—èŠ‚æ•°ç»„
  let negative_bytes = Random::next_bytes(random, -1)
  assert_eq(negative_bytes.length(), 0)
  
  // æµ‹è¯•éšæœºæ•°ç”Ÿæˆ
  let random1 = Random::next_u64(random)
  let random2 = Random::next_u64(random)
  
  // åœ¨ç®€åŒ–å®ç°ä¸­ï¼Œéšæœºæ•°æ˜¯å›ºå®šçš„ï¼Œä½†åœ¨å®é™…å®ç°ä¸­åº”è¯¥æ˜¯éšæœºçš„
  assert_eq(random1, 12345UL)
  assert_eq(random2, 12345UL)
}

test "memory_pressure_simulation" {
  // æµ‹è¯•å†…å­˜å‹åŠ›ä¸‹çš„ç³»ç»Ÿç¨³å®šæ€§
  let meter = MeterProvider::get_meter(MeterProvider::default(), "memory-pressure-test")
  
  // åˆ›å»ºå¤§é‡å¯¹è±¡æ¨¡æ‹Ÿå†…å­˜å‹åŠ›
  let spans = []
  let log_records = []
  let attributes_list = []
  let contexts = []
  
  // ç”Ÿæˆå¤§é‡Span
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "memory-pressure")
  for i in 0..1000 {
    let span = Tracer::start_span(tracer, "memory.pressure.span." + i.to_string())
    spans.push(span)
  }
  
  // ç”Ÿæˆå¤§é‡æ—¥å¿—è®°å½•
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "memory-pressure")
  for i in 0..1000 {
    let log_record = LogRecord::new_with_context(
      Info,
      Some("Memory pressure log " + i.to_string()),
      Some(Attributes::new()),
      Some(Clock::now_unix_nanos(Clock::system())),
      None,
      Some("trace-" + i.to_string()),
      Some("span-" + i.to_string()),
      Some(Context::root())
    )
    log_records.push(log_record)
  }
  
  // ç”Ÿæˆå¤§é‡å±æ€§
  for i in 0..1000 {
    let attrs = Attributes::new()
    Attributes::set(attrs, "memory.pressure.key." + i.to_string(), StringValue("value." + i.to_string()))
    attributes_list.push(attrs)
  }
  
  // ç”Ÿæˆå¤§é‡ä¸Šä¸‹æ–‡
  for i in 0..1000 {
    let ctx = Context::root()
    let key = ContextKey::new("memory.pressure.key." + i.to_string())
    let ctx_with_value = Context::with_value(ctx, key, "value." + i.to_string())
    contexts.push(ctx_with_value)
  }
  
  // åœ¨å†…å­˜å‹åŠ›ä¸‹æ‰§è¡Œæ“ä½œ
  for span in spans {
    Span::add_event(span, "memory.pressure.event", Some([("pressure", StringValue("high"))]))
    Span::end(span)
  }
  
  for record in log_records {
    Logger::emit(logger, record)
  }
  
  // éªŒè¯ç³»ç»Ÿåœ¨å†…å­˜å‹åŠ›ä¸‹ä»ç„¶ç¨³å®š
  assert_eq(spans.length(), 1000)
  assert_eq(log_records.length(), 1000)
  assert_eq(attributes_list.length(), 1000)
  assert_eq(contexts.length(), 1000)
}