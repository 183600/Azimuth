// SpanKind and StatusCode Boundary Tests
// SpanKindå’ŒStatusCodeè¾¹ç•Œæµ‹è¯•ï¼Œæµ‹è¯•æ‰€æœ‰SpanKindå’ŒStatusCodeçš„ç»„åˆåŠè¾¹ç•Œæƒ…å†µ

test "SpanKindåŸºæœ¬ç±»å‹æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "spankind.test")
  
  // æµ‹è¯•æ‰€æœ‰SpanKindç±»å‹
  let internal_span = Tracer::start_span(tracer, "internal.span")
  let server_span = Tracer::start_span(tracer, "server.span")
  let client_span = Tracer::start_span(tracer, "client.span")
  let producer_span = Tracer::start_span(tracer, "producer.span")
  let consumer_span = Tracer::start_span(tracer, "consumer.span")
  
  // éªŒè¯é»˜è®¤åˆ›å»ºçš„spanæ˜¯Internalç±»å‹
  match Span::kind(internal_span) {
    Internal => assert_true(true)
    _ => assert_true(false)
  }
  
  // æ³¨æ„ï¼šå½“å‰ç®€åŒ–å®ç°ä¸­ï¼Œæ‰€æœ‰spanéƒ½é»˜è®¤ä¸ºInternalç±»å‹
  // åœ¨å®é™…å®ç°ä¸­ï¼Œåº”è¯¥èƒ½å¤ŸæŒ‡å®šä¸åŒçš„SpanKind
  match Span::kind(server_span) {
    Internal => assert_true(true) // ç®€åŒ–å®ç°
    _ => assert_true(false)
  }
  
  match Span::kind(client_span) {
    Internal => assert_true(true) // ç®€åŒ–å®ç°
    _ => assert_true(false)
  }
  
  match Span::kind(producer_span) {
    Internal => assert_true(true) // ç®€åŒ–å®ç°
    _ => assert_true(false)
  }
  
  match Span::kind(consumer_span) {
    Internal => assert_true(true) // ç®€åŒ–å®ç°
    _ => assert_true(false)
  }
  
  // éªŒè¯spanåç§°è®¾ç½®æ­£ç¡®
  assert_eq(Span::name(internal_span), "internal.span")
  assert_eq(Span::name(server_span), "server.span")
  assert_eq(Span::name(client_span), "client.span")
  assert_eq(Span::name(producer_span), "producer.span")
  assert_eq(Span::name(consumer_span), "consumer.span")
  
  // æ¸…ç†
  Span::end(internal_span)
  Span::end(server_span)
  Span::end(client_span)
  Span::end(producer_span)
  Span::end(consumer_span)
}

test "StatusCodeåŸºæœ¬ç±»å‹æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "statuscode.test")
  
  // åˆ›å»ºå¤šä¸ªspanç”¨äºæµ‹è¯•ä¸åŒçš„çŠ¶æ€ç 
  let unset_span = Tracer::start_span(tracer, "unset.span")
  let ok_span = Tracer::start_span(tracer, "ok.span")
  let error_span = Tracer::start_span(tracer, "error.span")
  
  // æµ‹è¯•é»˜è®¤çŠ¶æ€ï¼ˆåº”è¯¥æ˜¯Unsetï¼‰
  match Span::status(unset_span) {
    Unset => assert_true(true)
    _ => assert_true(false)
  }
  
  match Span::status(ok_span) {
    Unset => assert_true(true) // é»˜è®¤çŠ¶æ€
    _ => assert_true(false)
  }
  
  match Span::status(error_span) {
    Unset => assert_true(true) // é»˜è®¤çŠ¶æ€
    _ => assert_true(false)
  }
  
  // è®¾ç½®çŠ¶æ€ç 
  Span::set_status(ok_span, Ok)
  Span::set_status(error_span, Error)
  
  // éªŒè¯çŠ¶æ€ç è®¾ç½®ï¼ˆç®€åŒ–å®ç°å¯èƒ½æ€»æ˜¯è¿”å›Unsetï¼‰
  match Span::status(ok_span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°
    Ok => assert_true(true) // ç†æƒ³å®ç°
    _ => assert_true(false)
  }
  
  match Span::status(error_span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°
    Error => assert_true(true) // ç†æƒ³å®ç°
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¤šæ¬¡è®¾ç½®çŠ¶æ€ç 
  Span::set_status(unset_span, Ok)
  Span::set_status(unset_span, Error)
  Span::set_status(unset_span, Unset)
  
  match Span::status(unset_span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°
    _ => assert_true(false)
  }
  
  // æ¸…ç†
  Span::end(unset_span)
  Span::end(ok_span)
  Span::end(error_span)
}

test "SpanKindå’ŒStatusCodeç»„åˆæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "combination.test")
  
  // æµ‹è¯•æ‰€æœ‰SpanKindä¸æ‰€æœ‰StatusCodeçš„ç»„åˆ
  let span_kinds = ["internal", "server", "client", "producer", "consumer"]
  let status_codes = [Unset, Ok, Error]
  
  for kind_name in span_kinds {
    for status_code in status_codes {
      let span = Tracer::start_span(tracer, kind_name + ".status.test")
      
      // éªŒè¯åˆå§‹çŠ¶æ€
      match Span::status(span) {
        Unset => assert_true(true)
        _ => assert_true(false)
      }
      
      // è®¾ç½®çŠ¶æ€ç 
      Span::set_status(span, status_code)
      
      // æ·»åŠ äº‹ä»¶ä»¥æµ‹è¯•ç»„åˆ
      let event_attributes = [
        ("span.kind", StringValue(kind_name)),
        ("status.code", StringValue(match status_code {
          Unset => "unset"
          Ok => "ok"
          Error => "error"
        }))
      ]
      Span::add_event(span, "status.changed", Some(event_attributes))
      
      // ç»“æŸspan
      Span::end(span)
    }
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "SpanKindåœ¨çœŸå®åœºæ™¯ä¸­çš„ä½¿ç”¨æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "realistic.test")
  
  // æ¨¡æ‹Ÿä¸€ä¸ªå®Œæ•´çš„è¯·æ±‚å¤„ç†æµç¨‹
  
  // 1. Server span - æ¥æ”¶è¯·æ±‚
  let server_span = Tracer::start_span(tracer, "http.request")
  Span::add_event(server_span, "request.received", Some([
    ("http.method", StringValue("GET")),
    ("http.url", StringValue("/api/users")),
    ("user.agent", StringValue("Mozilla/5.0..."))
  ]))
  
  // 2. å†…éƒ¨å¤„ç†
  let internal_span = Tracer::start_span(tracer, "user.authentication")
  Span::add_event(internal_span, "auth.started", None)
  Span::set_status(internal_span, Ok)
  Span::add_event(internal_span, "auth.completed", Some([
    ("user.id", StringValue("12345")),
    ("auth.method", StringValue("jwt"))
  ]))
  Span::end(internal_span)
  
  // 3. Client span - è°ƒç”¨ä¸‹æ¸¸æœåŠ¡
  let client_span = Tracer::start_span(tracer, "database.query")
  Span::add_event(client_span, "query.started", Some([
    ("db.statement", StringValue("SELECT * FROM users WHERE id = ?")),
    ("db.type", StringValue("postgresql"))
  ]))
  Span::set_status(client_span, Ok)
  Span::add_event(client_span, "query.completed", Some([
    ("db.rows", IntValue(1)),
    ("db.duration.ms", IntValue(25))
  ]))
  Span::end(client_span)
  
  // 4. Producer span - å‘é€æ¶ˆæ¯
  let producer_span = Tracer::start_span(tracer, "message.publish")
  Span::add_event(producer_span, "message.sent", Some([
    ("messaging.system", StringValue("kafka")),
    ("messaging.destination", StringValue("user.notifications")),
    ("message.id", StringValue("msg-12345"))
  ]))
  Span::set_status(producer_span, Ok)
  Span::end(producer_span)
  
  // 5. Consumer span - å¤„ç†å“åº”
  let consumer_span = Tracer::start_span(tracer, "response.processing")
  Span::add_event(consumer_span, "processing.started", None)
  Span::set_status(consumer_span, Ok)
  Span::add_event(consumer_span, "processing.completed", Some([
    ("response.size", IntValue(1024)),
    ("response.format", StringValue("json"))
  ]))
  Span::end(consumer_span)
  
  // å®Œæˆserver span
  Span::set_status(server_span, Ok)
  Span::add_event(server_span, "response.sent", Some([
    ("http.status_code", IntValue(200)),
    ("response.duration.ms", IntValue(150))
  ]))
  Span::end(server_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "StatusCodeé”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.boundary.test")
  
  // æµ‹è¯•é”™è¯¯çŠ¶æ€çš„è¯¦ç»†å¤„ç†
  let error_span = Tracer::start_span(tracer, "error.test.span")
  
  // è®¾ç½®é”™è¯¯çŠ¶æ€
  Span::set_status(error_span, Error)
  
  // æ·»åŠ é”™è¯¯ç›¸å…³çš„äº‹ä»¶
  Span::add_event(error_span, "error.occurred", Some([
    ("error.type", StringValue("ValidationError")),
    ("error.message", StringValue("Invalid input parameter")),
    ("error.code", StringValue("ERR_001")),
    ("error.stack", StringValue("at processRequest (line 42)"))
  ]))
  
  // æ·»åŠ æ›´å¤šé”™è¯¯ä¸Šä¸‹æ–‡
  Span::add_event(error_span, "error.context", Some([
    ("user.id", StringValue("12345")),
    ("request.id", StringValue("req-67890")),
    ("retry.count", IntValue(3)),
    ("timeout.ms", IntValue(5000))
  ]))
  
  // æµ‹è¯•ä»é”™è¯¯çŠ¶æ€æ¢å¤
  Span::set_status(error_span, Ok)
  Span::add_event(error_span, "recovery.attempted", Some([
    ("recovery.strategy", StringValue("retry_with_backoff")),
    ("recovery.success", BoolValue(true))
  ]))
  
  Span::end(error_span)
  
  // æµ‹è¯•å¤šç§é”™è¯¯åœºæ™¯
  let error_scenarios = [
    ("timeout.error", "Request timeout after 30 seconds"),
    ("connection.error", "Failed to connect to database"),
    ("permission.error", "User does not have required permissions"),
    ("validation.error", "Input validation failed"),
    ("system.error", "Internal system error")
  ]
  
  for scenario in error_scenarios {
    let scenario_span = Tracer::start_span(tracer, scenario.0)
    Span::set_status(scenario_span, Error)
    Span::add_event(scenario_span, "error.details", Some([
      ("error.type", StringValue(scenario.0)),
      ("error.description", StringValue(scenario.1))
    ]))
    Span::end(scenario_span)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "SpanKindå’ŒStatusCodeåœ¨å¹¶å‘åœºæ™¯ä¸­çš„æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrent.test")
  
  // åˆ›å»ºå¤šä¸ªå¹¶å‘spanï¼Œæ¨¡æ‹Ÿå¹¶å‘è¯·æ±‚å¤„ç†
  let spans = []
  
  // åˆ›å»ºä¸åŒç±»å‹çš„å¹¶å‘span
  for i in 0..10 {
    let server_span = Tracer::start_span(tracer, "concurrent.server." + i.to_string())
    let client_span = Tracer::start_span(tracer, "concurrent.client." + i.to_string())
    
    // è®¾ç½®ä¸åŒçš„çŠ¶æ€
    if i % 3 == 0 {
      Span::set_status(server_span, Error)
      Span::set_status(client_span, Error)
    } else if i % 3 == 1 {
      Span::set_status(server_span, Ok)
      Span::set_status(client_span, Ok)
    } else {
      // ä¿æŒUnsetçŠ¶æ€
    }
    
    // æ·»åŠ äº‹ä»¶
    Span::add_event(server_span, "server.event", Some([
      ("span.index", IntValue(i)),
      ("event.type", StringValue("server_processing"))
    ]))
    
    Span::add_event(client_span, "client.event", Some([
      ("span.index", IntValue(i)),
      ("event.type", StringValue("client_request"))
    ]))
    
    // ç»“æŸspan
    Span::end(server_span)
    Span::end(client_span)
  }
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}

test "SpanKindå’ŒStatusCodeçš„æ€§èƒ½æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "performance.test")
  
  // æµ‹è¯•å¤§é‡spançš„åˆ›å»ºå’ŒçŠ¶æ€è®¾ç½®æ€§èƒ½
  let start_time = Clock::now_unix_nanos(Clock::system())
  
  for i in 0..1000 {
    let span = Tracer::start_span(tracer, "performance.span." + i.to_string())
    
    // è®¾ç½®çŠ¶æ€
    if i % 10 == 0 {
      Span::set_status(span, Error)
    } else if i % 5 == 0 {
      Span::set_status(span, Ok)
    }
    
    // æ·»åŠ äº‹ä»¶
    if i % 3 == 0 {
      Span::add_event(span, "performance.event", Some([
        ("span.index", IntValue(i)),
        ("batch.size", IntValue(1000))
      ]))
    }
    
    Span::end(span)
  }
  
  let end_time = Clock::now_unix_nanos(Clock::system())
  let duration = end_time - start_time
  
  // éªŒè¯æ€§èƒ½åœ¨åˆç†èŒƒå›´å†…ï¼ˆè¿™é‡Œåªæ˜¯éªŒè¯å®Œæˆï¼Œä¸è¿›è¡Œä¸¥æ ¼çš„æ€§èƒ½æ–­è¨€ï¼‰
  assert_true(duration > 0L)
  assert_true(duration < 10000000000L) // å°äº10ç§’
  
  // æµ‹è¯•ä¸åŒSpanKindçš„æ€§èƒ½å·®å¼‚
  let span_types = ["internal", "server", "client", "producer", "consumer"]
  
  for span_type in span_types {
    let type_start_time = Clock::now_unix_nanos(Clock::system())
    
    for i in 0..100 {
      let span = Tracer::start_span(tracer, span_type + ".perf." + i.to_string())
      Span::set_status(span, Ok)
      Span::end(span)
    }
    
    let type_end_time = Clock::now_unix_nanos(Clock::system())
    let type_duration = type_end_time - type_start_time
    
    assert_true(type_duration > 0L)
  }
}

test "SpanKindå’ŒStatusCodeçš„è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.test")
  
  // æµ‹è¯•æé•¿spanåç§°
  let very_long_name = "a" * 1000
  let long_name_span = Tracer::start_span(tracer, very_long_name)
  assert_eq(Span::name(long_name_span).length(), 1000)
  Span::end(long_name_span)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„spanåç§°
  let special_names = [
    "span.with.dots",
    "span-with-dashes",
    "span_with_underscores",
    "span.with.numbers123",
    "span.withç‰¹æ®Šå­—ç¬¦",
    "span.with.emojiğŸš€",
    "span.with spaces",
    "span.with/slashes",
    "span.with\\backslashes"
  ]
  
  for special_name in special_names {
    let special_span = Tracer::start_span(tracer, special_name)
    assert_eq(Span::name(special_span), special_name)
    Span::set_status(special_span, Ok)
    Span::end(special_span)
  }
  
  // æµ‹è¯•ç©ºspanåç§°ï¼ˆå¦‚æœå…è®¸ï¼‰
  let empty_name_span = Tracer::start_span(tracer, "")
  assert_eq(Span::name(empty_name_span), "")
  Span::end(empty_name_span)
  
  // æµ‹è¯•é¢‘ç¹çš„çŠ¶æ€åˆ‡æ¢
  let switching_span = Tracer::start_span(tracer, "status.switching")
  
  for i in 0..100 {
    if i % 2 == 0 {
      Span::set_status(switching_span, Ok)
    } else {
      Span::set_status(switching_span, Error)
    }
  }
  
  Span::set_status(switching_span, Unset)
  Span::end(switching_span)
  
  // æµ‹è¯•å¤§é‡äº‹ä»¶æ·»åŠ 
  let many_events_span = Tracer::start_span(tracer, "many.events")
  
  for i in 0..1000 {
    Span::add_event(many_events_span, "event." + i.to_string(), Some([
      ("event.index", IntValue(i)),
      ("event.data", StringValue("data for event " + i.to_string()))
    ]))
  }
  
  Span::end(many_events_span)
  
  assert_true(true) // å¦‚æœæ²¡æœ‰å´©æºƒåˆ™æµ‹è¯•é€šè¿‡
}