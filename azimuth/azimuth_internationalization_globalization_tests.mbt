// Azimuth Internationalization and Globalization Tests
// This file contains tests for internationalization and globalization features in the Azimuth telemetry system

// Test 1: Unicode and multi-language support in telemetry data
pub test "unicode and multi-language support in telemetry data" {
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "i18n-test")
  
  // Test spans with Unicode names and attributes
  let chinese_span = azimuth::Tracer::start_span(tracer, "ä¸­æ–‡æ“ä½œè¿½è¸ª")
  azimuth::Span::set_attribute(chinese_span, "ç”¨æˆ·å", azimuth::StringValue("å¼ ä¸‰"))
  azimuth::Span::set_attribute(chinese_span, "æ“ä½œæè¿°", azimuth::StringValue("ç”¨æˆ·æ‰§è¡Œäº†æ•°æ®æŸ¥è¯¢æ“ä½œ"))
  azimuth::Span::add_event(chinese_span, "ä¸­æ–‡äº‹ä»¶", Some([("äº‹ä»¶è¯¦æƒ…", azimuth::StringValue("æŸ¥è¯¢å®Œæˆ"))]))
  
  let japanese_span = azimuth::Tracer::start_span(tracer, "æ—¥æœ¬èªã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³")
  azimuth::Span::set_attribute(japanese_span, "ãƒ¦ãƒ¼ã‚¶ãƒ¼å", azimuth::StringValue("ç”°ä¸­å¤ªéƒ"))
  azimuth::Span::set_attribute(japanese_span, "æ“ä½œèª¬æ˜", azimuth::StringValue("ãƒ‡ãƒ¼ã‚¿æ¤œç´¢æ“ä½œã‚’å®Ÿè¡Œ"))
  azimuth::Span::add_event(japanese_span, "æ—¥æœ¬èªã‚¤ãƒ™ãƒ³ãƒˆ", Some([("ã‚¤ãƒ™ãƒ³ãƒˆè©³ç´°", azimuth::StringValue("æ¤œç´¢å®Œäº†"))]))
  
  let arabic_span = azimuth::Tracer::start_span(tracer, "Ø¹Ù…Ù„ÙŠØ© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  azimuth::Span::set_attribute(arabic_span, "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", azimuth::StringValue("Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"))
  azimuth::Span::set_attribute(arabic_span, "ÙˆØµÙ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©", azimuth::StringValue("ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"))
  azimuth::Span::add_event(arabic_span, "Ø­Ø¯Ø« Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", Some([("ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø­Ø¯Ø«", azimuth::StringValue("Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…"))]))
  
  let russian_span = azimuth::Tracer::start_span(tracer, "Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ")
  azimuth::Span::set_attribute(russian_span, "Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ", azimuth::StringValue("Ğ˜Ğ²Ğ°Ğ½ ĞŸĞµÑ‚Ñ€Ğ¾Ğ²"))
  azimuth::Span::set_attribute(russian_span, "Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸", azimuth::StringValue("Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"))
  azimuth::Span::add_event(russian_span, "ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼", Some([("Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ", azimuth::StringValue("Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½"))]))
  
  // Test emoji and special characters
  let emoji_span = azimuth::Tracer::start_span(tracer, "Emoji Test ğŸš€ğŸ”¥ğŸ’¯")
  azimuth::Span::set_attribute(emoji_span, "emoji.test", azimuth::StringValue("ğŸ˜€ğŸ‰ğŸŒŸâ­ğŸ’«"))
  azimuth::Span::set_attribute(emoji_span, "special.chars", azimuth::StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  azimuth::Span::add_event(emoji_span, "Emoji Event ğŸŠ", Some([("emoji.data", azimuth::StringValue("ğŸš€ğŸ”¥ğŸŒŸ"))]))
  
  // End all spans
  azimuth::Span::end(chinese_span)
  azimuth::Span::end(japanese_span)
  azimuth::Span::end(arabic_span)
  azimuth::Span::end(russian_span)
  azimuth::Span::end(emoji_span)
  
  // Verify span properties
  assert_eq(azimuth::Span::name(chinese_span), "ä¸­æ–‡æ“ä½œè¿½è¸ª")
  assert_eq(azimuth::Span::name(japanese_span), "æ—¥æœ¬èªã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³")
  assert_eq(azimuth::Span::name(arabic_span), "Ø¹Ù…Ù„ÙŠØ© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  assert_eq(azimuth::Span::name(russian_span), "Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ")
  assert_eq(azimuth::Span::name(emoji_span), "Emoji Test ğŸš€ğŸ”¥ğŸ’¯")
}

// Test 2: Locale-aware formatting and parsing
pub test "locale-aware formatting and parsing" {
  let provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(provider, "locale-test")
  
  // Test locale-aware counter
  let counter = azimuth::Meter::create_counter(meter, "locale.counter", Some("å›½é™…åŒ–è®¡æ•°å™¨"), Some("è®¡æ•°"))
  
  // Configure different locales
  let us_locale = azimuth::Locale::new("en-US")
  let french_locale = azimuth::Locale::new("fr-FR")
  let german_locale = azimuth::Locale::new("de-DE")
  let chinese_locale = azimuth::Locale::new("zh-CN")
  let japanese_locale = azimuth::Locale::new("ja-JP")
  let arabic_locale = azimuth::Locale::new("ar-SA")
  
  // Record metrics with locale-specific formatting
  azimuth::Counter::add(counter, 1234567.89, [("locale", "en-US")])
  azimuth::Counter::add(counter, 1234567.89, [("locale", "fr-FR")])
  azimuth::Counter::add(counter, 1234567.89, [("locale", "de-DE")])
  azimuth::Counter::add(counter, 1234567.89, [("locale", "zh-CN")])
  azimuth::Counter::add(counter, 1234567.89, [("locale", "ja-JP")])
  azimuth::Counter::add(counter, 1234567.89, [("locale", "ar-SA")])
  
  // Test locale-aware number formatting
  let us_formatted = azimuth::LocaleFormatter::format_number(us_locale, 1234567.89)
  let french_formatted = azimuth::LocaleFormatter::format_number(french_locale, 1234567.89)
  let german_formatted = azimuth::LocaleFormatter::format_number(german_locale, 1234567.89)
  let chinese_formatted = azimuth::LocaleFormatter::format_number(chinese_locale, 1234567.89)
  let japanese_formatted = azimuth::LocaleFormatter::format_number(japanese_locale, 1234567.89)
  let arabic_formatted = azimuth::LocaleFormatter::format_number(arabic_locale, 1234567.89)
  
  // Verify locale-specific formatting
  assert_eq(us_formatted, "1,234,567.89")      // US: comma separator, dot decimal
  assert_eq(french_formatted, "1 234 567,89")  // French: space separator, comma decimal
  assert_eq(german_formatted, "1.234.567,89")  // German: dot separator, comma decimal
  assert_eq(chinese_formatted, "1,234,567.89") // Chinese: similar to US
  assert_eq(japanese_formatted, "1,234,567.89") // Japanese: similar to US
  assert_eq(arabic_formatted, "1,234,567.89")   // Arabic: similar to US (numbers remain Western)
  
  // Test locale-aware date/time formatting
  let timestamp = azimuth::Clock::now_unix_nanos(azimuth::Clock::system())
  
  let us_date = azimuth::LocaleFormatter::format_date_time(us_locale, timestamp)
  let french_date = azimuth::LocaleFormatter::format_date_time(french_locale, timestamp)
  let german_date = azimuth::LocaleFormatter::format_date_time(german_locale, timestamp)
  let chinese_date = azimuth::LocaleFormatter::format_date_time(chinese_locale, timestamp)
  let japanese_date = azimuth::LocaleFormatter::format_date_time(japanese_locale, timestamp)
  let arabic_date = azimuth::LocaleFormatter::format_date_time(arabic_locale, timestamp)
  
  // Verify date formatting contains locale-specific elements
  assert_true(us_date.contains("/"))     // US: MM/DD/YYYY
  assert_true(french_date.contains("/")) // French: DD/MM/YYYY
  assert_true(german_date.contains(".")) // German: DD.MM.YYYY
  assert_true(chinese_date.contains("/") || chinese_date.contains("-")) // Chinese: YYYY/MM/DD or YYYY-MM-DD
  assert_true(japanese_date.contains("/") || japanese_date.contains("-")) // Japanese: similar to Chinese
  assert_true(arabic_date.contains("/") || arabic_date.contains("-")) // Arabic: varies by region
  
  // Test locale-aware currency formatting
  let us_currency = azimuth::LocaleFormatter::format_currency(us_locale, 1234.56, "USD")
  let euro_currency = azimuth::LocaleFormatter::format_currency(french_locale, 1234.56, "EUR")
  let yen_currency = azimuth::LocaleFormatter::format_currency(japanese_locale, 1234.56, "JPY")
  
  assert_true(us_currency.contains("$") || us_currency.contains("USD"))
  assert_true(euro_currency.contains("â‚¬") || euro_currency.contains("EUR"))
  assert_true(yen_currency.contains("Â¥") || yen_currency.contains("JPY"))
}

// Test 3: Right-to-left (RTL) language support
pub test "right-to-left language support" {
  let logger_provider = azimuth::LoggerProvider::default()
  let logger = azimuth::LoggerProvider::get_logger(logger_provider, "rtl-test")
  
  // Test Arabic log messages
  let arabic_log = azimuth::LogRecord::new(azimuth::Info, "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­")
  azimuth::LogRecord::set_attribute(arabic_log, "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…", azimuth::StringValue("Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"))
  azimuth::LogRecord::set_attribute(arabic_log, "Ø§Ù„Ø¹Ù…Ù„ÙŠØ©", azimuth::StringValue("ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„"))
  azimuth::LogRecord::set_attribute(arabic_log, "Ø§Ù„Ù†ØªÙŠØ¬Ø©", azimuth::StringValue("Ù†Ø¬Ø§Ø­"))
  azimuth::LogRecord::set_attribute(arabic_log, "Ø§Ù„Ø§ØªØ¬Ø§Ù‡", azimuth::StringValue("Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø±"))
  
  // Test Hebrew log messages
  let hebrew_log = azimuth::LogRecord::new(azimuth::Info, "×”×”×ª×—×‘×¨×•×ª ×‘×•×¦×¢×” ×‘×”×¦×œ×—×”")
  azimuth::LogRecord::set_attribute(hebrew_log, "×©× ××©×ª××©", azimuth::StringValue("×“×•×“ ×›×”×Ÿ"))
  azimuth::LogRecord::set_attribute(hebrew_log, "×¤×¢×•×œ×”", azimuth::StringValue("×”×ª×—×‘×¨×•×ª"))
  azimuth::LogRecord::set_attribute(hebrew_log, "×ª×•×¦××”", azimuth::StringValue("×”×¦×œ×—×”"))
  azimuth::LogRecord::set_attribute(hebrew_log, "×›×™×•×•×Ÿ", azimuth::StringValue("×™××™×Ÿ ×œ×©×××œ"))
  
  // Test Persian log messages
  let persian_log = azimuth::LogRecord::new(azimuth::Info, "ÙˆØ±ÙˆØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯")
  azimuth::LogRecord::set_attribute(persian_log, "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ", azimuth::StringValue("Ø¹Ù„ÛŒ Ø±Ø¶Ø§ÛŒÛŒ"))
  azimuth::LogRecord::set_attribute(persian_log, "Ø¹Ù…Ù„ÛŒØ§Øª", azimuth::StringValue("ÙˆØ±ÙˆØ¯"))
  azimuth::LogRecord::set_attribute(persian_log, "Ù†ØªÛŒØ¬Ù‡", azimuth::StringValue("Ù…ÙˆÙÙ‚ÛŒØª"))
  azimuth::LogRecord::set_attribute(persian_log, "Ø¬Ù‡Øª", azimuth::StringValue("Ø±Ø§Ø³Øª Ø¨Ù‡ Ú†Ù¾"))
  
  // Test Urdu log messages
  let urdu_log = azimuth::LogRecord::new(azimuth::Info, "Ù„Ø§Ú¯ Ø§Ù† Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ ÛÙˆÚ¯ÛŒØ§")
  azimuth::LogRecord::set_attribute(urdu_log, "ØµØ§Ø±Ù Ú©Ø§ Ù†Ø§Ù…", azimuth::StringValue("Ù…Ø­Ù…Ø¯ Ø¹Ù„ÛŒ"))
  azimuth::LogRecord::set_attribute(urdu_log, "Ø¹Ù…Ù„", azimuth::StringValue("Ù„Ø§Ú¯ Ø§Ù†"))
  azimuth::LogRecord::set_attribute(urdu_log, "Ù†ØªÛŒØ¬Û", azimuth::StringValue("Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ"))
  azimuth::LogRecord::set_attribute(urdu_log, "Ø³Ù…Øª", azimuth::StringValue("Ø¯Ø§Ø¦ÛŒÚº Ø³Û’ Ø¨Ø§Ø¦ÛŒÚº"))
  
  // Emit all log records
  azimuth::Logger::emit(logger, arabic_log)
  azimuth::Logger::emit(logger, hebrew_log)
  azimuth::Logger::emit(logger, persian_log)
  azimuth::Logger::emit(logger, urdu_log)
  
  // Test RTL text direction detection
  let arabic_direction = azimuth::TextDirection::detect_direction("ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­")
  let hebrew_direction = azimuth::TextDirection::detect_direction("×”×”×ª×—×‘×¨×•×ª ×‘×•×¦×¢×” ×‘×”×¦×œ×—×”")
  let persian_direction = azimuth::TextDirection::detect_direction("ÙˆØ±ÙˆØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯")
  let urdu_direction = azimuth::TextDirection::detect_direction("Ù„Ø§Ú¯ Ø§Ù† Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ ÛÙˆÚ¯ÛŒØ§")
  let english_direction = azimuth::TextDirection::detect_direction("Login successful")
  
  assert_eq(arabic_direction, azimuth::RTL)
  assert_eq(hebrew_direction, azimuth::RTL)
  assert_eq(persian_direction, azimuth::RTL)
  assert_eq(urdu_direction, azimuth::RTL)
  assert_eq(english_direction, azimuth::LTR)
  
  // Test mixed LTR/RTL text handling
  let mixed_text = "Hello Ù…Ø±Ø­Ø¨Ø§ world Ø¹Ø§Ù„Ù…"
  let mixed_direction = azimuth::TextDirection::detect_direction(mixed_text)
  assert_eq(mixed_direction, azimuth::Mixed)  // Should detect as mixed
  
  // Test RTL-aware text formatting
  let rtl_formatter = azimuth::RTLFormatter::new()
  let formatted_arabic = azimuth::RTLFormatter::format(rtl_formatter, "Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: Ø£Ø­Ù…Ø¯")
  let formatted_hebrew = azimuth::RTLFormatter::format(rtl_formatter, "×©× ××©×ª××©: ×“×•×“")
  
  // Verify RTL formatting preserves text direction
  assert_true(azimuth::TextDirection::detect_direction(formatted_arabic) == azimuth::RTL)
  assert_true(azimuth::TextDirection::detect_direction(formatted_hebrew) == azimuth::RTL)
}

// Test 4: Timezone and calendar system support
pub test "timezone and calendar system support" {
  let provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(provider, "timezone-test")
  
  // Test different timezones
  let utc_timezone = azimuth::Timezone::new("UTC")
  let us_eastern = azimuth::Timezone::new("America/New_York")
  let us_pacific = azimuth::Timezone::new("America/Los_Angeles")
  let european = azimuth::Timezone::new("Europe/Paris")
  let asian = azimuth::Timezone::new("Asia/Tokyo")
  let australian = azimuth::Timezone::new("Australia/Sydney")
  
  // Create a fixed timestamp for testing
  let test_timestamp = 1672531200000000000L  // 2023-01-01 00:00:00 UTC
  
  // Test timezone conversions
  let utc_time = azimuth::Timezone::convert(utc_timezone, test_timestamp)
  let eastern_time = azimuth::Timezone::convert(us_eastern, test_timestamp)
  let pacific_time = azimuth::Timezone::convert(us_pacific, test_timestamp)
  let european_time = azimuth::Timezone::convert(european, test_timestamp)
  let asian_time = azimuth::Timezone::convert(asian, test_timestamp)
  let australian_time = azimuth::Timezone::convert(australian, test_timestamp)
  
  // Verify timezone offsets
  assert_eq(azimuth::Timezone::get_offset_hours(utc_timezone), 0)
  assert_eq(azimuth::Timezone::get_offset_hours(us_eastern), -5)  // EST (ignoring DST)
  assert_eq(azimuth::Timezone::get_offset_hours(us_pacific), -8)  // PST (ignoring DST)
  assert_eq(azimuth::Timezone::get_offset_hours(european), 1)     // CET (ignoring DST)
  assert_eq(azimuth::Timezone::get_offset_hours(asian), 9)        // JST
  assert_eq(azimuth::Timezone::get_offset_hours(australian), 11)  // AEDT (ignoring DST)
  
  // Test calendar systems
  let gregorian = azimuth::Calendar::new("gregorian")
  let islamic = azimuth::Calendar::new("islamic")
  let hebrew = azimuth::Calendar::new("hebrew")
  let chinese = azimuth::Calendar::new("chinese")
  let japanese = azimuth::Calendar::new("japanese")
  let indian = azimuth::Calendar::new("indian")
  
  // Convert timestamp to different calendar systems
  let gregorian_date = azimuth::Calendar::convert_to_calendar(gregorian, test_timestamp)
  let islamic_date = azimuth::Calendar::convert_to_calendar(islamic, test_timestamp)
  let hebrew_date = azimuth::Calendar::convert_to_calendar(hebrew, test_timestamp)
  let chinese_date = azimuth::Calendar::convert_to_calendar(chinese, test_timestamp)
  let japanese_date = azimuth::Calendar::convert_to_calendar(japanese, test_timestamp)
  let indian_date = azimuth::Calendar::convert_to_calendar(indian, test_timestamp)
  
  // Verify calendar system differences
  assert_eq(gregorian_date.year, 2023)
  assert_eq(gregorian_date.month, 1)
  assert_eq(gregorian_date.day, 1)
  
  // Islamic calendar should have different year/month/day
  assert_true(islamic_date.year != gregorian_date.year)
  assert_true(islamic_date.month >= 1 && islamic_date.month <= 12)
  assert_true(islamic_date.day >= 1 && islamic_date.day <= 30)
  
  // Hebrew calendar should have different year/month/day
  assert_true(hebrew_date.year != gregorian_date.year)
  assert_true(hebrew_date.month >= 1 && hebrew_date.month <= 13)
  assert_true(hebrew_date.day >= 1 && hebrew_date.day <= 30)
  
  // Test timezone-aware metric recording
  let timezone_counter = azimuth::Meter::create_counter(meter, "timezone.counter", Some("æ—¶åŒºè®¡æ•°å™¨"), Some("è®¡æ•°"))
  
  azimuth::Counter::add(timezone_counter, 1, [("timezone", "UTC"), ("local_time", utc_time)])
  azimuth::Counter::add(timezone_counter, 1, [("timezone", "US/Eastern"), ("local_time", eastern_time)])
  azimuth::Counter::add(timezone_counter, 1, [("timezone", "US/Pacific"), ("local_time", pacific_time)])
  azimuth::Counter::add(timezone_counter, 1, [("timezone", "Europe/Paris"), ("local_time", european_time)])
  azimuth::Counter::add(timezone_counter, 1, [("timezone", "Asia/Tokyo"), ("local_time", asian_time)])
  azimuth::Counter::add(timezone_counter, 1, [("timezone", "Australia/Sydney"), ("local_time", australian_time)])
  
  // Test daylight saving time transitions
  let dst_transition_spring = azimuth::Timezone::get_dst_transition(us_eastern, 2023, 3)  // Spring forward
  let dst_transition_fall = azimuth::Timezone::get_dst_transition(us_eastern, 2023, 11)  // Fall back
  
  assert_true(dst_transition_spring.is_some)
  assert_true(dst_transition_fall.is_some)
  
  match dst_transition_spring {
    Some(transition) => {
      assert_eq(transition.month, 3)
      assert_true(transition.hour >= 2 && transition.hour <= 3)
    }
    None => assert_true(false)
  }
  
  match dst_transition_fall {
    Some(transition) => {
      assert_eq(transition.month, 11)
      assert_true(transition.hour >= 1 && transition.hour <= 2)
    }
    None => assert_true(false)
  }
}

// Test 5: Cultural and regional conventions
pub test "cultural and regional conventions" {
  let provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(provider, "cultural-test")
  
  // Test address formatting for different regions
  let us_address = azimuth::AddressFormatter::format("US", [
    ("street", "123 Main St"),
    ("city", "New York"),
    ("state", "NY"),
    ("postal", "10001"),
    ("country", "USA")
  ])
  
  let uk_address = azimuth::AddressFormatter::format("GB", [
    ("street", "123 High Street"),
    ("city", "London"),
    ("postal", "SW1A 1AA"),
    ("country", "UK")
  ])
  
  let japanese_address = azimuth::AddressFormatter::format("JP", [
    ("postal", "100-0001"),
    ("prefecture", "æ±äº¬éƒ½"),
    ("city", "åƒä»£ç”°åŒº"),
    ("street", "åƒä»£ç”°1-1"),
    ("country", "æ—¥æœ¬")
  ])
  
  let chinese_address = azimuth::AddressFormatter::format("CN", [
    ("country", "ä¸­å›½"),
    ("province", "åŒ—äº¬å¸‚"),
    ("city", "åŒ—äº¬å¸‚"),
    ("district", "ä¸œåŸåŒº"),
    ("street", "ä¸œåé—¨å¤§è¡—1å·"),
    ("postal", "100006")
  ])
  
  // Verify address formatting follows regional conventions
  assert_true(us_address.contains("123 Main St"))
  assert_true(us_address.contains("New York, NY 10001"))
  
  assert_true(uk_address.contains("123 High Street"))
  assert_true(uk_address.contains("London"))
  assert_true(uk_address.contains("SW1A 1AA"))
  
  assert_true(japanese_address.contains("ã€’100-0001"))
  assert_true(japanese_address.contains("æ±äº¬éƒ½åƒä»£ç”°åŒº"))
  
  assert_true(chinese_address.contains("ä¸­å›½åŒ—äº¬å¸‚"))
  assert_true(chinese_address.contains("ä¸œåŸåŒº"))
  
  // Test personal name formatting
  let western_name = azimuth::NameFormatter::format("western", [
    ("first", "John"),
    ("middle", "F."),
    ("last", "Kennedy"),
    ("title", "Mr.")
  ])
  
  let eastern_name = azimuth::NameFormatter::format("eastern", [
    ("family", "ç”°ä¸­"),
    ("given", "å¤ªéƒ"),
    ("title", "æ§˜")
  ])
  
  let chinese_name = azimuth::NameFormatter::format("chinese", [
    ("family", "å¼ "),
    ("given", "ä¼Ÿ"),
    ("title", "å…ˆç”Ÿ")
  ])
  
  // Verify name formatting follows cultural conventions
  assert_true(western_name.contains("John F. Kennedy") || western_name.contains("Kennedy, John F."))
  assert_true(eastern_name.contains("ç”°ä¸­å¤ªéƒ"))
  assert_true(chinese_name.contains("å¼ ä¼Ÿ"))
  
  // Test measurement units and conversions
  let metric_height = azimuth::UnitConverter::convert(180.0, "cm", "m")
  let imperial_height = azimuth::UnitConverter::convert(180.0, "cm", "ft")
  let metric_weight = azimuth::UnitConverter::convert(70.0, "kg", "g")
  let imperial_weight = azimuth::UnitConverter::convert(70.0, "kg", "lb")
  let metric_temp = azimuth::UnitConverter::convert(25.0, "C", "K")
  let imperial_temp = azimuth::UnitConverter::convert(25.0, "C", "F")
  
  // Verify unit conversions
  assert_eq(metric_height, 1.8)
  assert_true(imperial_height > 5.0 && imperial_height < 7.0)  // ~5.9 feet
  assert_eq(metric_weight, 70000.0)
  assert_true(imperial_weight > 150.0 && imperial_weight < 160.0)  // ~154 lbs
  assert_eq(metric_temp, 298.15)  // 25Â°C = 298.15K
  assert_eq(imperial_temp, 77.0)  // 25Â°C = 77Â°F
  
  // Create metrics with cultural context
  let cultural_counter = azimuth::Meter::create_counter(meter, "cultural.interactions", Some("æ–‡åŒ–äº¤æµè®¡æ•°å™¨"), Some("è®¡æ•°"))
  
  azimuth::Counter::add(cultural_counter, 1, [
    ("region", "US"),
    ("language", "en"),
    ("date_format", "MM/DD/YYYY"),
    ("measurement_system", "imperial")
  ])
  
  azimuth::Counter::add(cultural_counter, 1, [
    ("region", "JP"),
    ("language", "ja"),
    ("date_format", "YYYY/MM/DD"),
    ("measurement_system", "metric")
  ])
  
  azimuth::Counter::add(cultural_counter, 1, [
    ("region", "CN"),
    ("language", "zh"),
    ("date_format", "YYYY-MM-DD"),
    ("measurement_system", "metric")
  ])
  
  azimuth::Counter::add(cultural_counter, 1, [
    ("region", "GB"),
    ("language", "en"),
    ("date_format", "DD/MM/YYYY"),
    ("measurement_system", "metric")
  ])
}