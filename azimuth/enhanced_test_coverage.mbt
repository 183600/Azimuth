// è¡¥å……çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºè¦†ç›–ç°æœ‰æµ‹è¯•ä¸­è¾ƒå°‘æ¶‰åŠçš„æ–¹é¢

test "assertion_functions_test" {
  // æµ‹è¯•æ–­è¨€å‡½æ•°æœ¬èº«çš„åŠŸèƒ½
  assert_eq(10, 10)  // ç›¸ç­‰æ–­è¨€
  assert_eq_string("test", "test")  // å­—ç¬¦ä¸²ç›¸ç­‰æ–­è¨€
  assert_true(true)  // çœŸå€¼æ–­è¨€
  assert_false(false)  // å‡å€¼æ–­è¨€
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, 0)
  assert_eq(-1, -1)
  assert_eq_string("", "")
  assert_true(1 == 1)
  assert_false(1 == 0)
}

test "extreme_boundary_values" {
  // æµ‹è¯•æå€¼è¾¹ç•Œæƒ…å†µ
  let max_int = 2147483647
  let min_int = -2147483648
  
  // å¤§æ•°åŠ æ³•æµ‹è¯•
  assert_eq(max_int, add(max_int - 1, 1))
  assert_eq(min_int, add(min_int + 1, -1))
  
  // å¤§æ•°ä¹˜æ³•æµ‹è¯•ï¼ˆé¿å…æº¢å‡ºï¼‰
  assert_eq(46340, multiply(46340, 1))  // sqrt(2^31-1)
  assert_eq(-46340, multiply(-46340, 1))
  
  // è¾¹ç•Œé™¤æ³•æµ‹è¯•
  assert_eq(1, divide_with_ceil(max_int, max_int))
  assert_eq(1, divide_with_ceil(min_int, min_int))
  assert_eq(0, divide_with_ceil(1, max_int))
}

test "advanced_function_combinations" {
  // æµ‹è¯•å‡½æ•°çš„é«˜çº§ç»„åˆä½¿ç”¨
  let base1 = 10
  let base2 = 20
  let base3 = 30
  let base4 = 40
  let base5 = 50
  
  // è®¡ç®—æ•°åˆ—çš„æ€»å’Œä¸å¹³å‡å€¼ç›¸å…³çš„è®¡ç®—
  let sum1 = add(add(base1, base2), add(base3, base4))
  let total_sum = add(sum1, base5)
  assert_eq(150, total_sum)
  
  // è®¡ç®—åŠ æƒå¹³å‡çš„ç›¸å…³è®¡ç®—
  let weight1 = 1
  let weight2 = 2
  let weight3 = 3
  let weighted_sum = add(multiply(base1, weight1),
                        add(multiply(base2, weight2),
                           multiply(base3, weight3)))
  assert_eq(140, weighted_sum)
  
  // å¤æ‚çš„åŒ…è£…è®¡ç®—
  let items_per_package = 12
  let total_items = total_sum
  let packages_needed = divide_with_ceil(total_items, items_per_package)
  assert_eq(13, packages_needed)  // ceil(150/12) = 13
}

test "business_logic_scenarios" {
  // æµ‹è¯•å®é™…ä¸šåŠ¡é€»è¾‘åœºæ™¯
  
  // åœºæ™¯1ï¼šåº“å­˜ç®¡ç†è®¡ç®—
  let initial_stock = 1000
  let sale1 = 150
  let sale2 = 200
  let sale3 = 175
  let sale4 = 125
  let sale5 = 180
  let total_sales = add(add(add(sale1, sale2), add(sale3, sale4)), sale5)
  let remaining_stock = add(initial_stock, -total_sales)
  assert_eq(170, remaining_stock)
  
  // åœºæ™¯2ï¼šè®¢å•å¤„ç†å’Œç‰©æµè®¡ç®—
  let order1 = 25
  let order2 = 30
  let order3 = 15
  let order4 = 45
  let order5 = 20
  let box_capacity = 24
  let total_orders = add(add(order1, order2), add(order3, order4))
  let final_total = add(total_orders, order5)
  let boxes_needed = divide_with_ceil(final_total, box_capacity)
  assert_eq(6, boxes_needed)  // ceil(135/24) = 6
  
  // åœºæ™¯3ï¼šä»·æ ¼è®¡ç®—å’ŒæŠ˜æ‰£
  let base_price = 50
  let discount1 = 0
  let discount2 = 5
  let quantity1 = 1
  let quantity2 = 5
  
  let price1 = multiply(base_price, quantity1)
  let price2 = multiply(add(base_price, -discount2), quantity2)
  assert_eq(50, price1)
  assert_eq(225, price2)
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  
  // ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, \n\r\t!", greet("\n\r\t"))
  
  // æé•¿å­—ç¬¦ä¸²æµ‹è¯•
  let long_name = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
  let expected_long = "Hello, " + long_name + "!"
  assert_eq_string(expected_long, greet(long_name))
  
  // ç‰¹æ®ŠUnicodeå­—ç¬¦
  assert_eq_string("Hello, Ã±Ã¡Ã©Ã­Ã³Ãº!", greet("Ã±Ã¡Ã©Ã­Ã³Ãº"))
  assert_eq_string("Hello, ğŸ‰ğŸš€ğŸŒŸ!", greet("ğŸ‰ğŸš€ğŸŒŸ"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  
  // æ•°å­—å’Œå­—æ¯æ··åˆ
  assert_eq_string("Hello, test123!", greet("test123"))
  assert_eq_string("Hello, 123test!", greet("123test"))
}

test "mathematical_series_and_patterns" {
  // æµ‹è¯•æ•°å­¦åºåˆ—å’Œæ¨¡å¼
  
  // ç­‰å·®æ•°åˆ—è®¡ç®—
  let first_term = 3
  let common_diff = 5
  
  let term1 = first_term
  let term2 = add(term1, common_diff)
  let term3 = add(term2, common_diff)
  let term4 = add(term3, common_diff)
  let term5 = add(term4, common_diff)
  let term6 = add(term5, common_diff)
  
  let series_sum = add(add(add(term1, term2), 
                           add(term3, term4)),
                       add(term5, term6))
  assert_eq(78, series_sum)  // 3+8+13+18+23+28 = 78
  
  // ç­‰æ¯”æ•°åˆ—è®¡ç®—ï¼ˆç®€å•æƒ…å†µï¼‰
  let geo_first = 2
  let ratio = 3
  let geo_term1 = geo_first
  let geo_term2 = multiply(geo_term1, ratio)
  let geo_term3 = multiply(geo_term2, ratio)
  let geo_sum = add(add(geo_term1, geo_term2), geo_term3)
  assert_eq(26, geo_sum)  // 2+6+18 = 26
  
  // å¹³æ–¹æ•°è®¡ç®—
  let num1 = 4
  let num2 = 7
  let square1 = multiply(num1, num1)
  let square2 = multiply(num2, num2)
  let sum_of_squares = add(square1, square2)
  assert_eq(65, sum_of_squares)  // 16+49 = 65
}

test "error_handling_and_robustness" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’Œå¥å£®æ€§
  
  // é™¤é›¶æƒ…å†µçš„å¤šç§æµ‹è¯•
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(-1, 0))
  assert_eq(0, divide_with_ceil(1, 0))
  
  // è´Ÿæ•°é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-1, divide_with_ceil(-2, 3))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-5, divide_with_ceil(-21, 5))
  
  // æå°å€¼é™¤æ³•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(-1, divide_with_ceil(1, -1))
  assert_eq(-1, divide_with_ceil(-1, 1))
}

test "performance_and_stress_testing" {
  // æµ‹è¯•æ€§èƒ½å’Œå‹åŠ›æƒ…å†µ
  
  // è¿ç»­è¿ç®—æµ‹è¯•
  let mut accumulator = 1
  accumulator = multiply(accumulator, 2)
  accumulator = add(accumulator, 3)
  accumulator = multiply(accumulator, 4)
  accumulator = add(accumulator, 5)
  accumulator = multiply(accumulator, 6)
  assert_eq(126, accumulator)  // ((1*2+3)*4+5)*6 = 126
  
  // åµŒå¥—è®¡ç®—å‹åŠ›æµ‹è¯•
  let nested_result = divide_with_ceil(
    multiply(
      add(10, 20),
      add(30, 40)
    ),
    add(5, 5)
  )
  assert_eq(210, nested_result)  // ceil((10+20)*(30+40)/10) = ceil(30*70/10) = ceil(2100/10) = 210
  
  // å¤§é‡æ•°æ®å¤„ç†æ¨¡æ‹Ÿ
  let batch_size = 50
  let items_per_batch = 12
  let total_batches = multiply(batch_size, items_per_batch)
  let containers = divide_with_ceil(total_batches, 100)
  assert_eq(6, containers)  // ceil(50*12/100) = ceil(600/100) = 6
}