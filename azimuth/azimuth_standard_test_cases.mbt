// Azimuth é¡¹ç›®æ ‡å‡†æµ‹è¯•ç”¨ä¾‹
// åŒ…å« 10 ä¸ªé«˜è´¨é‡çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–å„ç§åŠŸèƒ½ç‚¹å’Œè¾¹ç¼˜æƒ…å†µ

test "numeric_precision_edge_cases" {
  // æ•°å€¼ç²¾åº¦è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•å¤§æ•°è¿ç®—å’Œå°æ•°è¿ç®—çš„è¾¹ç•Œæƒ…å†µ
  
  // å¤§æ•°åŠ æ³•æµ‹è¯•
  assert_eq(2000000000, add(1000000000, 1000000000))
  
  // è´Ÿæ•°å¤§æ•°æµ‹è¯•
  assert_eq(-2000000000, add(-1000000000, -1000000000))
  
  // æ··åˆç¬¦å·å¤§æ•°æµ‹è¯•
  assert_eq(0, add(1000000000, -1000000000))
  
  // å¤§æ•°ä¹˜æ³•æµ‹è¯•
  assert_eq(1000000, multiply(1000, 1000))
  
  // è¾¹ç•Œé™¤æ³•æµ‹è¯•
  assert_eq(1, divide_with_ceil(1000000, 1000000))
  assert_eq(2, divide_with_ceil(1000001, 1000000))
}

test "string_formatting_comprehensive" {
  // å­—ç¬¦ä¸²æ ¼å¼åŒ–ç»¼åˆæµ‹è¯•
  // æµ‹è¯•å„ç§å­—ç¬¦ä¸²è¾“å…¥æƒ…å†µå’Œç‰¹æ®Šå­—ç¬¦å¤„ç†
  
  // ç©ºå­—ç¬¦ä¸²å’Œç©ºç™½å­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
  assert_eq_string("Hello, \t\n\r!", greet("\t\n\r"))
  
  // ç‰¹æ®Šç¬¦å·æµ‹è¯•
  assert_eq_string("Hello, !@#$%^&*()!", greet("!@#$%^&*()"))
  assert_eq_string("Hello, []{}<>!", greet("[]{}<>"))
  
  // æ•°å­—å­—ç¬¦ä¸²æµ‹è¯•
  assert_eq_string("Hello, 1234567890!", greet("1234567890"))
  assert_eq_string("Hello, 3.14159!", greet("3.14159"))
}

test "mathematical_identities_verification" {
  // æ•°å­¦æ’ç­‰å¼éªŒè¯æµ‹è¯•
  // éªŒè¯åŸºæœ¬çš„æ•°å­¦æ’ç­‰å¼å’Œæ€§è´¨
  
  let x = 42
  let y = 17
  let z = 5
  
  // åŠ æ³•æ’ç­‰å¼
  assert_eq(x, add(x, 0))
  assert_eq(x, add(0, x))
  
  // ä¹˜æ³•æ’ç­‰å¼
  assert_eq(x, multiply(x, 1))
  assert_eq(x, multiply(1, x))
  assert_eq(0, multiply(x, 0))
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))
}

test "business_logistics_simulation" {
  // ä¸šåŠ¡ç‰©æµæ¨¡æ‹Ÿæµ‹è¯•
  // æ¨¡æ‹ŸçœŸå®ä¸–ç•Œçš„ç‰©æµå’Œåº“å­˜ç®¡ç†åœºæ™¯
  
  // ä»“åº“åº“å­˜ç®¡ç†
  let total_products = 1587
  let pallet_capacity = 144
  let pallets_needed = divide_with_ceil(total_products, pallet_capacity)
  
  // éªŒè¯éœ€è¦çš„æ‰˜ç›˜æ•°é‡
  assert_eq(12, pallets_needed)  // ceil(1587/144) = 12
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(pallets_needed, pallet_capacity)
  assert_eq(1728, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let unused_space = subtract(total_capacity, total_products)
  assert_eq(141, unused_space)
  
  // è¿è¾“è½¦è¾†è®¡ç®—
  let trucks_available = 3
  let products_per_truck = divide_with_ceil(total_products, trucks_available)
  assert_eq(529, products_per_truck)  // ceil(1587/3) = 529
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•å„ç§é”™è¯¯æƒ…å†µå’Œå¼‚å¸¸å¤„ç†
  
  // é™¤é›¶é”™è¯¯çš„å„ç§æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(2147483647, 0))
  assert_eq(0, divide_with_ceil(-2147483648, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(-2147483648, divide_with_ceil(-2147483648, 1))
}

test "computational_efficiency_validation" {
  // è®¡ç®—æ•ˆç‡éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒè®¡ç®—è·¯å¾„çš„æ•ˆç‡å’Œæ­£ç¡®æ€§
  
  // æ‰¹é‡è®¡ç®—æ•ˆç‡æµ‹è¯•
  let batch_size = 1000
  let operations_per_item = 5
  
  // çº¿æ€§è®¡ç®—è·¯å¾„
  let linear_result = multiply(batch_size, operations_per_item)
  assert_eq(5000, linear_result)
  
  // åˆ†å—è®¡ç®—è·¯å¾„
  let chunk_size = 100
  let chunks = divide_with_ceil(batch_size, chunk_size)
  let chunked_result = multiply(chunks, multiply(chunk_size, operations_per_item))
  assert_eq(5000, chunked_result)
  
  // ä¼˜åŒ–è®¡ç®—è·¯å¾„
  let optimized_result = multiply(divide_with_ceil(batch_size, chunk_size), multiply(chunk_size, operations_per_item))
  assert_eq(5000, optimized_result)
}

test "complex_calculation_workflow" {
  // å¤æ‚è®¡ç®—å·¥ä½œæµæµ‹è¯•
  // æµ‹è¯•å¤šæ­¥éª¤ã€å¤šå‡½æ•°çš„å¤æ‚è®¡ç®—æµç¨‹
  
  // é¡¹ç›®èµ„æºè®¡ç®—å·¥ä½œæµ
  let project_duration = 18  // æœˆ
  let team_size = 8
  let monthly_cost_per_person = 7500
  let contingency_rate = 15  // ç™¾åˆ†æ¯”
  
  // åŸºç¡€æˆæœ¬è®¡ç®—
  let base_monthly_cost = multiply(team_size, monthly_cost_per_person)
  assert_eq(60000, base_monthly_cost)
  
  // é¡¹ç›®æ€»æˆæœ¬
  let total_base_cost = multiply(base_monthly_cost, project_duration)
  assert_eq(1080000, total_base_cost)
  
  // åº”æ€¥è´¹ç”¨
  let contingency_cost = divide_with_ceil(multiply(total_base_cost, contingency_rate), 100)
  assert_eq(162000, contingency_cost)
  
  // é¡¹ç›®æ€»é¢„ç®—
  let total_budget = add(total_base_cost, contingency_cost)
  assert_eq(1242000, total_budget)
  
  // æœˆå‡é¢„ç®—ï¼ˆåŒ…å«åº”æ€¥è´¹ç”¨ï¼‰
  let monthly_budget = divide_with_ceil(total_budget, project_duration)
  assert_eq(69000, monthly_budget)  // ceil(1242000/18) = 69000
}

test "data_type_boundary_testing" {
  // æ•°æ®ç±»å‹è¾¹ç•Œæµ‹è¯•
  // æµ‹è¯•æ•´æ•°ç±»å‹çš„è¾¹ç•Œæƒ…å†µå’Œé™åˆ¶
  
  // æ¥è¿‘æœ€å¤§å€¼çš„è¿ç®—
  let near_max = 2147483640
  let small_increment = 5
  let max_result = add(near_max, small_increment)
  assert_eq(2147483645, max_result)
  
  // æ¥è¿‘æœ€å°å€¼çš„è¿ç®—
  let near_min = -2147483640
  let small_decrement = -5
  let min_result = add(near_min, small_decrement)
  assert_eq(-2147483645, min_result)
  
  // è¾¹ç•Œé™¤æ³•æµ‹è¯•
  assert_eq(2147483647, divide_with_ceil(2147483647, 1))
  assert_eq(1, divide_with_ceil(2147483647, 2147483647))
  assert_eq(2, divide_with_ceil(2147483647, 2147483646))
}

test "algorithm_correctness_verification" {
  // ç®—æ³•æ­£ç¡®æ€§éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•å®ç°çš„æ­£ç¡®æ€§
  
  // æœç´¢ç®—æ³•æ¨¡æ‹Ÿï¼ˆçº¿æ€§æœç´¢ vs äºŒåˆ†æœç´¢æ•ˆæœï¼‰
  let data_size = 1000
  let target_position = 789
  
  // çº¿æ€§æœç´¢æ­¥æ•°
  let linear_steps = target_position
  assert_eq(789, linear_steps)
  
  // äºŒåˆ†æœç´¢æ­¥æ•°ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
  let binary_steps = divide_with_ceil(data_size, 100)
  assert_eq(10, binary_steps)
  
  // éªŒè¯æ‰¾åˆ°ç›®æ ‡
  let found_linear = linear_steps > 0
  let found_binary = binary_steps > 0
  assert_true(found_linear)
  assert_true(found_binary)
  
  // æ’åºç®—æ³•æ¨¡æ‹Ÿï¼ˆå†’æ³¡æ’åºæ•ˆæœï¼‰
  let sort_passes = divide_with_ceil(data_size, 10)
  let total_comparisons = multiply(sort_passes, data_size)
  assert_eq(100000, total_comparisons)  // 100 * 1000
}

test "internationalization_special_chars" {
  // å›½é™…åŒ–å’Œç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  // æµ‹è¯•å„ç§å›½é™…åŒ–å­—ç¬¦å’Œç‰¹æ®Šç¼–ç çš„å¤„ç†
  
  // äºšæ´²å­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, à¹„à¸—à¸¢!", greet("à¹„à¸—à¸¢"))
  
  // æ¬§æ´²å­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, franÃ§ais!", greet("franÃ§ais"))
  assert_eq_string("Hello, espaÃ±ol!", greet("espaÃ±ol"))
  assert_eq_string("Hello, portuguÃªs!", greet("portuguÃªs"))
  assert_eq_string("Hello, Ñ€ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ñ€ÑƒÑÑĞºĞ¸Ğ¹"))
  
  // ä¸­ä¸œå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
  
  // ç‰¹æ®Šç¬¦å·å’Œè¡¨æƒ…ç¬¦å·
  assert_eq_string("Hello, ğŸŒŸğŸŒ™ğŸš€!", greet("ğŸŒŸğŸŒ™ğŸš€"))
  assert_eq_string("Hello, â¤ï¸ğŸ’™ğŸ’š!", greet("â¤ï¸ğŸ’™ğŸ’š"))
  assert_eq_string("Hello, â–²â–¼â—„â–º!", greet("â–²â–¼â—„â–º"))
  
  // æŠ€æœ¯ç¬¦å·
  assert_eq_string("Hello, â‰¤â‰¥â‰ â‰ˆ!", greet("â‰¤â‰¥â‰ â‰ˆ"))
  assert_eq_string("Hello, Â±Ã—Ã·âˆ‘âˆ!", greet("Â±Ã—Ã·âˆ‘âˆ"))
}
