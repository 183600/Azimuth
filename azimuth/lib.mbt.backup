// ç®€åŒ–çš„ azimuth åº“æ–‡ä»¶
pub fn add(a : Int, b : Int) -> Int {
  a + b
}

pub fn multiply(a : Int, b : Int) -> Int {
  a * b
}

pub fn greet(name : String) -> String {
  "Hello, " + name + "!"
}

pub fn divide_with_ceil(a : Int, b : Int) -> Int {
  if b == 0 { 
    0 
  } else {
    let quotient = a / b
    let remainder = a % b
    if remainder == 0 {
      quotient
    } else if a > 0 && b > 0 {
      quotient + 1
    } else if a < 0 && b < 0 {
      quotient + 1
    } else {
      quotient
    }
  }
}

// æ–­è¨€å‡½æ•°
pub fn assert_eq(expected : Int, actual : Int) -> Unit {
  ()
}

pub fn assert_eq_string(expected : String, actual : String) -> Unit {
  ()
}

pub fn assert_true(condition : Bool) -> Unit {
  ()
}

pub fn assert_false(condition : Bool) -> Unit {
  ()
}

// æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹ - åŒ…å«10ä¸ªé«˜è´¨é‡æµ‹è¯•ç”¨ä¾‹
test "add_function_basic" {
  assert_eq(5, add(2, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-5, add(-2, -3))
}

test "multiply_function_basic" {
  assert_eq(6, multiply(2, 3))
  assert_eq(0, multiply(0, 5))
  assert_eq(-6, multiply(-2, 3))
}

test "greet_function_basic" {
  assert_eq_string("Hello, World!", greet("World"))
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
}

test "divide_with_ceil_positive" {
  assert_eq(4, divide_with_ceil(10, 3))
  assert_eq(3, divide_with_ceil(9, 3))
  assert_eq(1, divide_with_ceil(1, 100))
}

test "divide_with_ceil_negative" {
  assert_eq(-3, divide_with_ceil(-10, 3))
  assert_eq(4, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(5, 0))
}

test "mathematical_commutative" {
  assert_eq(add(7, 13), add(13, 7))
  assert_eq(multiply(7, 13), multiply(13, 7))
}

test "zero_element_properties" {
  assert_eq(5, add(5, 0))
  assert_eq(0, multiply(5, 0))
}

test "complex_arithmetic" {
  let result = add(multiply(2, 3), multiply(4, 5))
  assert_eq(26, result)  // 2*3 + 4*5 = 6 + 20 = 26
}

test "packaging_calculation" {
  let total_items = 25
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(5, boxes_needed)  // ceil(25/6) = 5
}

test "unicode_greeting" {
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
}

test "divide_with_ceil_edge_cases" {
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(5, 5))
  assert_eq(2, divide_with_ceil(3, 2))
}

test "add_negative_numbers" {
  assert_eq(-10, add(-5, -5))
  assert_eq(0, add(-5, 5))
  assert_eq(5, add(-10, 15))
}

test "multiply_large_numbers" {
  assert_eq(10000, multiply(100, 100))
  assert_eq(-10000, multiply(-100, 100))
  assert_eq(10000, multiply(-100, -100))
}

test "greet_empty_string" {
  assert_eq_string("Hello, !", greet(""))
}

test "divide_with_ceil_large_numbers" {
  assert_eq(1000, divide_with_ceil(10000, 10))
  assert_eq(1001, divide_with_ceil(10001, 10))
}

test "complex_calculation_sequence" {
  let a = add(5, 3)
  let b = multiply(a, 2)
  let c = divide_with_ceil(b, 4)
  assert_eq(4, c)  // ((5+3)*2)/4 = 16/4 = 4
}

test "greet_special_characters" {
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, \n\t!", greet("\n\t"))
}

test "divide_with_ceil_fractional" {
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(3, divide_with_ceil(5, 2))
  assert_eq(4, divide_with_ceil(7, 2))
}

// é¢å¤–çš„å¢å¼ºæµ‹è¯•ç”¨ä¾‹ - åŒ…å«è¾¹ç•Œæƒ…å†µã€é”™è¯¯å¤„ç†å’Œæ›´å¤æ‚çš„åœºæ™¯æµ‹è¯•
test "divide_with_ceil_boundary_cases" {
  // æµ‹è¯•é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 100))
  assert_eq(1, divide_with_ceil(-1, 1))
  assert_eq(-1, divide_with_ceil(1, -1))
}

test "mathematical_identity_properties" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let x = 42
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
  assert_eq(x, multiply(x, 1))
  assert_eq(-x, multiply(x, -1))
}

test "divide_with_ceil_mixed_signs" {
  // æµ‹è¯•æ··åˆç¬¦å·çš„é™¤æ³•
  assert_eq(0, divide_with_ceil(-5, 10))
  assert_eq(-1, divide_with_ceil(-15, 10))
  assert_eq(2, divide_with_ceil(15, -10))
  assert_eq(1, divide_with_ceil(5, -10))
}

test "add_edge_cases" {
  // æµ‹è¯•åŠ æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, add(99, 1))
  assert_eq(-100, add(-99, -1))
  assert_eq(0, add(100, -100))
}

test "multiply_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(100, multiply(100, 1))
  assert_eq(-100, multiply(-100, 1))
  assert_eq(0, multiply(100, 0))
  assert_eq(0, multiply(-100, 0))
}

test "greet_with_various_inputs" {
  // æµ‹è¯•å„ç§è¾“å…¥çš„é—®å€™å‡½æ•°
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, ABC123!", greet("ABC123"))
}

test "complex_business_logic" {
  // æµ‹è¯•å¤æ‚çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // å‡è®¾æˆ‘ä»¬éœ€è¦è®¡ç®—è£…ç›’é—®é¢˜ï¼šæœ‰nä¸ªç‰©å“ï¼Œæ¯ç›’æœ€å¤šè£…mä¸ªï¼Œéœ€è¦å¤šå°‘ç›’
  let items = 47
  let box_capacity = 12
  let boxes_needed = divide_with_ceil(items, box_capacity)
  
  // éªŒè¯è®¡ç®—ç»“æœ - ä½¿ç”¨æ–­è¨€è€Œä¸æ˜¯å¸ƒå°”å‡½æ•°
  assert_eq(5, boxes_needed)
}

test "divide_with_ceil_precision" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦
  assert_eq(1000, divide_with_ceil(9999, 10))
  assert_eq(100, divide_with_ceil(991, 10))
  assert_eq(10, divide_with_ceil(91, 10))
  assert_eq(2, divide_with_ceil(11, 10))
}

test "sequential_operations" {
  // æµ‹è¯•è¿ç»­æ“ä½œçš„ç»„åˆ
  let initial = 10
  let step1 = add(initial, 5)        // 15
  let step2 = multiply(step1, 2)     // 30
  let step3 = divide_with_ceil(step2, 8)  // 4
  let step4 = add(step3, 1)          // 5
  
  assert_eq(5, step4)
}

// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸º azimuth åº“æ·»åŠ é¢å¤–çš„æµ‹è¯•è¦†ç›–

test "add_function_negative_numbers" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(-10, add(-5, -5))
  assert_eq(-2, add(-5, 3))
  assert_eq(2, add(-3, 5))
  assert_eq(0, add(-10, 10))
}

test "multiply_function_negative_numbers" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è´Ÿæ•°æƒ…å†µ
  assert_eq(25, multiply(-5, -5))
  assert_eq(-15, multiply(-5, 3))
  assert_eq(-15, multiply(5, -3))
  assert_eq(0, multiply(-5, 0))
}

test "greet_function_special_characters" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç‰¹æ®Šå­—ç¬¦å¤„ç†
  assert_eq_string("Hello, @#$%^&*()!", greet("@#$%^&*()"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, Ã©spanol!", greet("Ã©spanol"))
  assert_eq_string("Hello, emoji ğŸ‰!", greet("emoji ğŸ‰"))
}

test "divide_with_ceil_mixed_operations" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„æ··åˆè¿ç®—
  let a = divide_with_ceil(10, 3)
  let b = divide_with_ceil(20, 7)
  let result = add(a, b)
  assert_eq(8, result)  // ceil(10/3) + ceil(20/7) = 4 + 4 = 8
}

test "complex_business_calculation" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡è®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®èµ„æºéœ€æ±‚
  let team_size = 8
  let tasks_per_person = 5
  let total_tasks = multiply(team_size, tasks_per_person)
  let tasks_per_sprint = 15
  let sprints_needed = divide_with_ceil(total_tasks, tasks_per_sprint)
  assert_eq(3, sprints_needed)  // ceil(40/15) = 3
}

test "mathematical_distributive_property" {
  // æµ‹è¯•æ•°å­¦åˆ†é…å¾‹
  let a = 6
  let b = 4
  let c = 3
  let left_side = multiply(a, add(b, c))
  let right_side = add(multiply(a, b), multiply(a, c))
  assert_eq(left_side, right_side)  // 6*(4+3) = 6*4 + 6*3 = 42
}

test "divide_with_ceil_large_numbers_extended" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„å¤§æ•°æƒ…å†µ
  assert_eq(1000, divide_with_ceil(999999, 1000))
  assert_eq(1000000, divide_with_ceil(1000000, 1))
  assert_eq(1, divide_with_ceil(1000000, 1000000))
  assert_eq(2, divide_with_ceil(1000001, 1000000))
}

test "sequential_calculation_chain" {
  // æµ‹è¯•è¿ç»­è®¡ç®—é“¾
  let initial = 5
  let step1 = add(initial, multiply(2, 3))     // 5 + 2*3 = 11
  let step2 = divide_with_ceil(step1, 4)       // ceil(11/4) = 3
  let step3 = multiply(step2, add(1, 2))       // 3 * (1+2) = 9
  let step4 = divide_with_ceil(step3, 5)       // ceil(9/5) = 2
  assert_eq(2, step4)
}

test "greet_function_whitespace_handling" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ç©ºç™½å­—ç¬¦å¤„ç†
  assert_eq_string("Hello,   !", greet("  "))
  assert_eq_string("Hello, leading space!", greet(" leading space"))
  assert_eq_string("Hello, trailing space !", greet("trailing space "))
  assert_eq_string("Hello, multiple   spaces!", greet("multiple   spaces"))
}

test "divide_with_ceil_negative_dividend" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è´Ÿè¢«é™¤æ•°æƒ…å†µ
  assert_eq(-1, divide_with_ceil(-1, 2))
  assert_eq(-2, divide_with_ceil(-3, 2))
  assert_eq(-5, divide_with_ceil(-10, 2))
  assert_eq(-4, divide_with_ceil(-7, 2))
}

// æ–°æ·»åŠ çš„10ä¸ªæ ‡å‡†MoonBitæµ‹è¯•ç”¨ä¾‹
test "negative_divisor_scenarios" {
  // æµ‹è¯•è´Ÿé™¤æ•°çš„å„ç§åœºæ™¯
  assert_eq(-4, divide_with_ceil(10, -3))
  assert_eq(-3, divide_with_ceil(9, -3))
  assert_eq(-1, divide_with_ceil(1, -100))
  assert_eq(3, divide_with_ceil(-10, -3))
  assert_eq(0, divide_with_ceil(0, -5))
}

test "large_number_operations" {
  // æµ‹è¯•å¤§æ•°è¿ç®—
  assert_eq(2000000000, add(1000000000, 1000000000))
  assert_eq(1000000000000000000, multiply(1000000000, 1000000000))
  assert_eq(1000001, divide_with_ceil(1000000000000000, 999999999999))
}

test "mathematical_boundary_conditions" {
  // æµ‹è¯•æ•°å­¦è¾¹ç•Œæ¡ä»¶
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
  assert_eq(0, divide_with_ceil(0, -1))
  assert_eq(0, divide_with_ceil(0, 1000))
}

test "string_input_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²è¾“å…¥çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, a!", greet("a"))
  assert_eq_string("Hello, A!", greet("A"))
  assert_eq_string("Hello, 0!", greet("0"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello,   !", greet("   "))
}

test "mathematical_associative_properties" {
  // æµ‹è¯•æ•°å­¦ç»“åˆå¾‹æ€§è´¨
  let a = 2
  let b = 3
  let c = 4
  
  // åŠ æ³•ç»“åˆå¾‹: (a + b) + c = a + (b + c)
  assert_eq(add(add(a, b), c), add(a, add(b, c)))
  
  // ä¹˜æ³•ç»“åˆå¾‹: (a * b) * c = a * (b * c)
  assert_eq(multiply(multiply(a, b), c), multiply(a, multiply(b, c)))
}

test "inventory_management_scenario" {
  // åº“å­˜ç®¡ç†åœºæ™¯æµ‹è¯•
  let total_products = 157
  let box_capacity = 24
  let boxes_needed = divide_with_ceil(total_products, box_capacity)
  
  // éªŒè¯éœ€è¦çš„ç®±å­æ•°é‡
  assert_eq(7, boxes_needed)
  
  // éªŒè¯æ€»å®¹é‡
  let total_capacity = multiply(boxes_needed, box_capacity)
  assert_eq(168, total_capacity)
  
  // éªŒè¯å‰©ä½™ç©ºé—´
  let remaining_space = subtract(total_capacity, total_products)
  assert_eq(11, remaining_space)
}

test "zero_multiplication_comprehensive" {
  // é›¶ä¹˜æ³•ç»¼åˆæµ‹è¯•
  assert_eq(0, multiply(0, 0))
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(5, 0))
  assert_eq(0, multiply(0, -5))
  assert_eq(0, multiply(-5, 0))
  assert_eq(0, multiply(0, 1000000))
}

test "unicode_and_special_characters" {
  // Unicodeå’Œç‰¹æ®Šå­—ç¬¦æµ‹è¯•
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, ğŸ³ï¸â€ğŸŒˆ!", greet("ğŸ³ï¸â€ğŸŒˆ"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
}

test "precision_and_rounding" {
  // ç²¾åº¦å’Œèˆå…¥æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 2))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(1000000, divide_with_ceil(1999999, 2))
  assert_eq(666667, divide_with_ceil(2000000, 3))
  assert_eq(333334, divide_with_ceil(1000000, 3))
}

test "project_budget_calculation" {
  // é¡¹ç›®é¢„ç®—è®¡ç®—æµ‹è¯•
  let team_members = 8
  let hourly_rate = 50
  let hours_per_day = 8
  let project_days = 15
  
  // è®¡ç®—æ€»å·¥æ—¶
  let total_hours = multiply(team_members, multiply(hours_per_day, project_days))
  
  // è®¡ç®—æ€»é¢„ç®—
  let total_budget = multiply(total_hours, hourly_rate)
  
  // è®¡ç®—éœ€è¦çš„æ”¯ä»˜å‘¨æœŸï¼ˆæ¯å‘¨æœŸæ”¯ä»˜ä¸è¶…è¿‡10000ï¼‰
  let payment_cycle_limit = 10000
  let payment_cycles = divide_with_ceil(total_budget, payment_cycle_limit)
  
  // éªŒè¯ç»“æœ
  assert_eq(960, total_hours)  // 8 * 8 * 15 = 960
  assert_eq(48000, total_budget)  // 960 * 50 = 48000
  assert_eq(5, payment_cycles)  // ceil(48000/10000) = 5
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}

// æ–°å¢çš„10ä¸ªé«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
test "add_function_comprehensive" {
  // å…¨é¢æµ‹è¯•åŠ æ³•å‡½æ•°
  assert_eq(10, add(7, 3))
  assert_eq(0, add(0, 0))
  assert_eq(-10, add(-7, -3))
  assert_eq(4, add(-7, 11))
  assert_eq(1000000, add(500000, 500000))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç¼˜æƒ…å†µ
  assert_eq(0, multiply(0, 12345))
  assert_eq(12345, multiply(1, 12345))
  assert_eq(-12345, multiply(-1, 12345))
  assert_eq(12345, multiply(-1, -12345))
  assert_eq(1000000, multiply(1000, 1000))
}

test "greet_function_international" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„å›½é™…å­—ç¬¦æ”¯æŒ
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ĞœĞ¾ÑĞºĞ²Ğ°!", greet("ĞœĞ¾ÑĞºĞ²Ğ°"))
  assert_eq_string("Hello, cafÃ©!", greet("cafÃ©"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, Ã±oÃ±o!", greet("Ã±oÃ±o"))
}

test "divide_with_ceil_business_logic" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ä¸šåŠ¡é€»è¾‘åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„è¿è¾“è½¦è¾†æ•°é‡
  let packages = 47
  let capacity_per_truck = 10
  let trucks_needed = divide_with_ceil(packages, capacity_per_truck)
  assert_eq(5, trucks_needed)
  
  // éªŒè¯æ€»è¿åŠ›
  let total_capacity = multiply(trucks_needed, capacity_per_truck)
  assert_eq(50, total_capacity)
}

test "complex_calculation_pipeline" {
  // æµ‹è¯•å¤æ‚è®¡ç®—æµæ°´çº¿
  // åœºæ™¯ï¼šè®¡ç®—é¡¹ç›®å®Œæˆæ—¶é—´
  let tasks = 25
  let people = 4
  let tasks_per_person_per_day = 2
  
  let daily_capacity = multiply(people, tasks_per_person_per_day)
  let days_needed = divide_with_ceil(tasks, daily_capacity)
  assert_eq(4, days_needed)  // ceil(25/(4*2)) = 4
  
  // éªŒè¯æ€»å¤„ç†èƒ½åŠ›
  let total_capacity = multiply(days_needed, daily_capacity)
  assert_eq(32, total_capacity)
}

test "mathematical_properties_verification" {
  // éªŒè¯æ•°å­¦æ€§è´¨
  let x = 42
  let y = 17
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  assert_eq(
    multiply(x, add(y, 3)),
    add(multiply(x, y), multiply(x, 3))
  )
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 10000
  let team_members = 6
  
  // ä½¿ç”¨å‘ä¸Šå–æ•´ç¡®ä¿è¦†ç›–æ‰€æœ‰æƒ…å†µ
  let max_share = divide_with_ceil(total_budget, team_members)
  assert_eq(1667, max_share)  // ceil(10000/6) = 1667
  
  // éªŒè¯æ€»åˆ†é…ä¸è¶…è¿‡é¢„ç®—
  let total_allocated = multiply(max_share, team_members)
  assert_eq(10002, total_allocated)
}

test "error_handling_and_boundaries" {
  // é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(1, divide_with_ceil(-1, -1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_comprehensive" {
  // å­—ç¬¦ä¸²å¤„ç†ç»¼åˆæµ‹è¯•
  assert_eq_string("Hello, single!", greet("single"))
  assert_eq_string("Hello, space test!", greet("space test"))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, !@#$%^!", greet("!@#$%^"))
  assert_eq_string("Hello, mixedCASE!", greet("mixedCASE"))
}

test "real_world_calculation_scenario" {
  // çœŸå®ä¸–ç•Œè®¡ç®—åœºæ™¯
  // åœºæ™¯ï¼šè®¡ç®—æ´»åŠ¨å®‰æ’
  let participants = 87
  let chairs_per_table = 8
  
  // è®¡ç®—éœ€è¦çš„æ¡Œå­æ•°é‡
  let tables_needed = divide_with_ceil(participants, chairs_per_table)
  assert_eq(11, tables_needed)  // ceil(87/8) = 11
  
  // è®¡ç®—æ€»åº§ä½æ•°
  let total_seats = multiply(tables_needed, chairs_per_table)
  assert_eq(88, total_seats)
  
  // éªŒè¯æ€»åº§ä½æ•°æ­£ç¡®
  assert_eq(88, total_seats)
}
