// Azimuth Span Lifecycle Comprehensive Tests
// Spanç”Ÿå‘½å‘¨æœŸå…¨é¢æµ‹è¯•

test "spanåˆ›å»ºå’Œåˆå§‹åŒ–æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "lifecycle.test")
  
  // æµ‹è¯•åŸºæœ¬spanåˆ›å»º
  let span_name = "lifecycle.test.span"
  let span = Tracer::start_span(tracer, span_name)
  
  // éªŒè¯spanåˆå§‹çŠ¶æ€
  assert_eq(Span::name(span), span_name)
  assert_true(Span::is_recording(span))
  match Span::status(span) {
    Unset => assert_true(true)
    _ => assert_true(false)
  }
  
  // éªŒè¯span context
  let span_ctx = Span::span_context(span)
  assert_true(SpanContext::is_valid(span_ctx))
  assert_true(SpanContext::is_sampled(span_ctx))
  
  // æµ‹è¯•ä¸åŒç±»å‹çš„spanåˆ›å»º
  let internal_span = Tracer::start_span(tracer, "internal.span")
  let server_span = Tracer::start_span(tracer, "server.span")
  let client_span = Tracer::start_span(tracer, "client.span")
  let producer_span = Tracer::start_span(tracer, "producer.span")
  let consumer_span = Tracer::start_span(tracer, "consumer.span")
  
  // éªŒè¯æ‰€æœ‰spanéƒ½æ­£ç¡®åˆ›å»º
  assert_eq(Span::name(internal_span), "internal.span")
  assert_eq(Span::name(server_span), "server.span")
  assert_eq(Span::name(client_span), "client.span")
  assert_eq(Span::name(producer_span), "producer.span")
  assert_eq(Span::name(consumer_span), "consumer.span")
  
  // éªŒè¯æ‰€æœ‰spanéƒ½åœ¨recordingçŠ¶æ€
  assert_true(Span::is_recording(internal_span))
  assert_true(Span::is_recording(server_span))
  assert_true(Span::is_recording(client_span))
  assert_true(Span::is_recording(producer_span))
  assert_true(Span::is_recording(consumer_span))
  
  // ç»“æŸæ‰€æœ‰span
  Span::end(internal_span)
  Span::end(server_span)
  Span::end(client_span)
  Span::end(producer_span)
  Span::end(consumer_span)
  Span::end(span)
}

test "spançŠ¶æ€è½¬æ¢æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "state.transition.test")
  
  let span = Tracer::start_span(tracer, "state.transition.span")
  
  // åˆå§‹çŠ¶æ€åº”ä¸ºUnset
  match Span::status(span) {
    Unset => assert_true(true)
    _ => assert_true(false)
  }
  
  // è½¬æ¢åˆ°OkçŠ¶æ€
  Span::set_status(span, Ok, Some("Operation completed successfully"))
  match Span::status(span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°è¿”å›Unset
    _ => assert_true(false)
  }
  
  // è½¬æ¢åˆ°ErrorçŠ¶æ€
  Span::set_status(span, Error, Some("Operation failed"))
  match Span::status(span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°è¿”å›Unset
    _ => assert_true(false)
  }
  
  // è½¬æ¢å›OkçŠ¶æ€ï¼ˆæ¢å¤ï¼‰
  Span::set_status(span, Ok, Some("Operation recovered"))
  match Span::status(span) {
    Unset => assert_true(true) // ç®€åŒ–å®ç°è¿”å›Unset
    _ => assert_true(false)
  }
  
  // è½¬æ¢å›UnsetçŠ¶æ€
  Span::set_status(span, Unset)
  match Span::status(span) {
    Unset => assert_true(true)
    _ => assert_true(false)
  }
  
  Span::end(span)
}

test "spanäº‹ä»¶æ·»åŠ å’Œç”Ÿå‘½å‘¨æœŸæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "event.lifecycle.test")
  
  let span = Tracer::start_span(tracer, "event.lifecycle.span")
  
  // æµ‹è¯•æ·»åŠ åŸºæœ¬äº‹ä»¶
  Span::add_event(span, "operation.start", None)
  
  // æµ‹è¯•æ·»åŠ å¸¦å±æ€§çš„äº‹ä»¶
  Span::add_event(span, "operation.progress", Some([
    ("progress.percent", IntValue(25)),
    ("operation.type", StringValue("data.processing"))
  ]))
  
  // æµ‹è¯•æ·»åŠ å¤šä¸ªäº‹ä»¶
  Span::add_event(span, "checkpoint.reached", Some([
    ("checkpoint.name", StringValue("mid.processing")),
    ("checkpoint.time", StringValue("2025-01-01T00:00:00Z"))
  ]))
  
  Span::add_event(span, "operation.progress", Some([
    ("progress.percent", IntValue(50)),
    ("operation.type", StringValue("data.processing"))
  ]))
  
  Span::add_event(span, "operation.progress", Some([
    ("progress.percent", IntValue(75)),
    ("operation.type", StringValue("data.processing"))
  ]))
  
  // æµ‹è¯•æ·»åŠ é”™è¯¯äº‹ä»¶
  Span::add_event(span, "error.occurred", Some([
    ("error.type", StringValue("timeout")),
    ("error.message", StringValue("Operation timed out")),
    ("retry.count", IntValue(3))
  ]))
  
  // æµ‹è¯•æ·»åŠ æ¢å¤äº‹ä»¶
  Span::add_event(span, "error.recovered", Some([
    ("recovery.time", StringValue("5s")),
    ("recovery.strategy", StringValue("retry"))
  ]))
  
  // æµ‹è¯•æ·»åŠ å®Œæˆäº‹ä»¶
  Span::add_event(span, "operation.complete", Some([
    ("duration", StringValue("10s")),
    ("records.processed", IntValue(1000))
  ]))
  
  // éªŒè¯spanä»åœ¨recordingçŠ¶æ€
  assert_true(Span::is_recording(span))
  
  Span::end(span)
}

test "spanåµŒå¥—å’Œçˆ¶å­å…³ç³»æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "nested.span.test")
  
  // åˆ›å»ºçˆ¶span
  let parent_span = Tracer::start_span(tracer, "parent.span")
  
  // éªŒè¯çˆ¶spançŠ¶æ€
  assert_eq(Span::name(parent_span), "parent.span")
  assert_true(Span::is_recording(parent_span))
  
  // åœ¨çˆ¶spanä¸­æ·»åŠ äº‹ä»¶
  Span::add_event(parent_span, "parent.operation.start", None)
  
  // åˆ›å»ºå­spanï¼ˆæ¨¡æ‹ŸåµŒå¥—ï¼‰
  let child_span1 = Tracer::start_span(tracer, "child.span.1")
  let child_span2 = Tracer::start_span(tracer, "child.span.2")
  
  // éªŒè¯å­spançŠ¶æ€
  assert_eq(Span::name(child_span1), "child.span.1")
  assert_eq(Span::name(child_span2), "child.span.2")
  assert_true(Span::is_recording(child_span1))
  assert_true(Span::is_recording(child_span2))
  
  // åœ¨å­spanä¸­æ·»åŠ äº‹ä»¶
  Span::add_event(child_span1, "child.operation.start", Some([
    ("child.id", IntValue(1)),
    ("parent.id", StringValue("parent.span"))
  ]))
  
  Span::add_event(child_span2, "child.operation.start", Some([
    ("child.id", IntValue(2)),
    ("parent.id", StringValue("parent.span"))
  ]))
  
  // åˆ›å»ºå­™spanï¼ˆæ›´æ·±å±‚æ¬¡çš„åµŒå¥—ï¼‰
  let grandchild_span = Tracer::start_span(tracer, "grandchild.span")
  
  // éªŒè¯å­™spançŠ¶æ€
  assert_eq(Span::name(grandchild_span), "grandchild.span")
  assert_true(Span::is_recording(grandchild_span))
  
  // åœ¨å­™spanä¸­æ·»åŠ äº‹ä»¶
  Span::add_event(grandchild_span, "grandchild.operation.start", Some([
    ("grandchild.id", IntValue(1)),
    ("parent.id", StringValue("child.span.1"))
  ]))
  
  // æŒ‰é¡ºåºç»“æŸspanï¼ˆå…ˆç»“æŸæœ€æ·±å±‚çš„ï¼‰
  Span::end(grandchild_span)
  
  // åœ¨å­spanä¸­æ·»åŠ å®Œæˆäº‹ä»¶
  Span::add_event(child_span1, "child.operation.complete", Some([
    ("grandchild.completed", BoolValue(true))
  ]))
  
  Span::end(child_span1)
  Span::end(child_span2)
  
  // åœ¨çˆ¶spanä¸­æ·»åŠ å®Œæˆäº‹ä»¶
  Span::add_event(parent_span, "parent.operation.complete", Some([
    ("children.completed", IntValue(2))
  ]))
  
  Span::end(parent_span)
}

test "spanå¹¶å‘æ“ä½œæµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrent.span.test")
  
  // åˆ›å»ºå¤šä¸ªspan
  let span_count = 100
  let spans = []
  
  for i = 0; i < span_count; i = i + 1 {
    let span_name = "concurrent.span." + i.to_string()
    let span = Tracer::start_span(tracer, span_name)
    spans.push(span)
  }
  
  // å¹¶å‘æ‰§è¡Œspanæ“ä½œ
  for i = 0; i < span_count; i = i + 1 {
    let span = spans[i]
    
    // è®¾ç½®çŠ¶æ€
    if i % 3 == 0 {
      Span::set_status(span, Ok, Some("Success operation " + i.to_string()))
    } else if i % 3 == 1 {
      Span::set_status(span, Error, Some("Error operation " + i.to_string()))
    } else {
      Span::set_status(span, Unset)
    }
    
    // æ·»åŠ äº‹ä»¶
    Span::add_event(span, "concurrent.event", Some([
      ("event.index", IntValue(i)),
      ("event.type", StringValue("concurrent.test"))
    ]))
    
    // æ·»åŠ æ›´å¤šäº‹ä»¶
    if i % 10 == 0 {
      Span::add_event(span, "milestone.event", Some([
        ("milestone", StringValue("important")),
        ("milestone.index", IntValue(i / 10))
      ]))
    }
  }
  
  // æ‰¹é‡ç»“æŸspan
  for span in spans {
    Span::end(span)
  }
  
  // éªŒè¯æ‰€æœ‰spanéƒ½æˆåŠŸåˆ›å»ºå’Œæ“ä½œ
  assert_eq(spans.length(), span_count)
}

test "spanå±æ€§å’Œå…ƒæ•°æ®æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "metadata.test")
  
  // åˆ›å»ºspanå¹¶æµ‹è¯•å…ƒæ•°æ®
  let span = Tracer::start_span(tracer, "metadata.test.span")
  
  // éªŒè¯åŸºæœ¬å±æ€§
  assert_eq(Span::name(span), "metadata.test.span")
  assert_true(Span::is_recording(span))
  
  // éªŒè¯span contextå±æ€§
  let span_ctx = Span::span_context(span)
  let trace_id = SpanContext::trace_id(span_ctx)
  let span_id = SpanContext::span_id(span_ctx)
  
  assert_true(trace_id != "")
  assert_true(span_id != "")
  assert_true(SpanContext::is_valid(span_ctx))
  
  // æµ‹è¯•span kindï¼ˆå¦‚æœæ”¯æŒï¼‰
  // æ³¨æ„ï¼šå½“å‰å®ç°å¯èƒ½ä¸ç›´æ¥æ”¯æŒè®¾ç½®span kindï¼Œä½†å¯ä»¥éªŒè¯é»˜è®¤å€¼
  
  // æµ‹è¯•spanä¸instrumentation scopeçš„å…³ç³»
  let scope = Tracer::instrumentation_scope(tracer)
  assert_eq(scope.name, "metadata.test")
  
  // æ·»åŠ å¸¦æœ‰å¤æ‚å±æ€§çš„äº‹ä»¶
  let complex_attrs = [
    ("string.attr", StringValue("string.value")),
    ("int.attr", IntValue(42)),
    ("float.attr", FloatValue(3.14)),
    ("bool.attr", BoolValue(true)),
    ("array.string.attr", ArrayStringValue(["item1", "item2", "item3"])),
    ("array.int.attr", ArrayIntValue([1, 2, 3, 4, 5]))
  ]
  
  Span::add_event(span, "complex.attr.event", Some(complex_attrs))
  
  // æµ‹è¯•å¸¦æœ‰ç‰¹æ®Šå­—ç¬¦çš„å±æ€§
  let special_attrs = [
    ("special.chars.attr", StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?")),
    ("unicode.attr", StringValue("æµ‹è¯•å±æ€§ğŸš€ğŸ“Š")),
    ("empty.attr", StringValue("")),
    ("spaces.attr", StringValue("value with spaces"))
  ]
  
  Span::add_event(span, "special.attr.event", Some(special_attrs))
  
  // æµ‹è¯•è¾¹ç•Œå€¼å±æ€§
  let boundary_attrs = [
    ("max.int.attr", IntValue(2147483647)),
    ("min.int.attr", IntValue(-2147483648)),
    ("zero.int.attr", IntValue(0)),
    ("max.float.attr", FloatValue(1.7976931348623157e+308)),
    ("min.float.attr", FloatValue(2.2250738585072014e-308)),
    ("zero.float.attr", FloatValue(0.0))
  ]
  
  Span::add_event(span, "boundary.attr.event", Some(boundary_attrs))
  
  Span::end(span)
}

test "spané”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.recovery.test")
  
  let span = Tracer::start_span(tracer, "error.recovery.span")
  
  // æ·»åŠ å¼€å§‹äº‹ä»¶
  Span::add_event(span, "operation.start", None)
  
  // æ¨¡æ‹Ÿé”™è¯¯å‘ç”Ÿ
  Span::set_status(span, Error, Some("Simulated error occurred"))
  Span::add_event(span, "error.occurred", Some([
    ("error.type", StringValue("simulated")),
    ("error.code", StringValue("SIM_001")),
    ("error.message", StringValue("This is a simulated error for testing")),
    ("error.timestamp", StringValue("2025-01-01T00:00:00Z"))
  ]))
  
  // æ¨¡æ‹Ÿé”™è¯¯å¤„ç†
  Span::add_event(span, "error.handling.start", Some([
    ("handling.strategy", StringValue("retry")),
    ("max.retries", IntValue(3))
  ]))
  
  // æ¨¡æ‹Ÿé‡è¯•è¿‡ç¨‹
  for i = 1; i <= 3; i = i + 1 {
    Span::add_event(span, "retry.attempt", Some([
      ("retry.count", IntValue(i)),
      ("retry.timestamp", StringValue("2025-01-01T00:00:" + i.to_string() + "Z"))
    ]))
  }
  
  // æ¨¡æ‹Ÿé”™è¯¯æ¢å¤
  Span::set_status(span, Ok, Some("Error recovered successfully"))
  Span::add_event(span, "error.recovered", Some([
    ("recovery.time", StringValue("5s")),
    ("total.retries", IntValue(3)),
    ("recovery.strategy", StringValue("retry.with.backoff"))
  ]))
  
  // æ·»åŠ å®Œæˆäº‹ä»¶
  Span::add_event(span, "operation.complete", Some([
    ("final.status", StringValue("success")),
    ("total.duration", StringValue("10s")),
    ("error.recovered", BoolValue(true))
  ]))
  
  Span::end(span)
}

test "spanç”Ÿå‘½å‘¨æœŸè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.test")
  
  // æµ‹è¯•ç©ºåç§°span
  let empty_name_span = Tracer::start_span(tracer, "")
  assert_eq(Span::name(empty_name_span), "")
  assert_true(Span::is_recording(empty_name_span))
  Span::end(empty_name_span)
  
  // æµ‹è¯•éå¸¸é•¿çš„åç§°span
  let long_name = "this.is.a.very.long.span.name.that.exceeds.normal.limits.and.tests.boundary.conditions.for.span.name.handling.in.the.telemetry.system"
  let long_name_span = Tracer::start_span(tracer, long_name)
  assert_eq(Span::name(long_name_span), long_name)
  assert_true(Span::is_recording(long_name_span))
  Span::end(long_name_span)
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„åç§°span
  let special_name_span = Tracer::start_span(tracer, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  assert_eq(Span::name(special_name_span), "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  assert_true(Span::is_recording(special_name_span))
  Span::end(special_name_span)
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„åç§°span
  let unicode_name_span = Tracer::start_span(tracer, "æµ‹è¯•spanåç§°ğŸš€ğŸ“Š")
  assert_eq(Span::name(unicode_name_span), "æµ‹è¯•spanåç§°ğŸš€ğŸ“Š")
  assert_true(Span::is_recording(unicode_name_span))
  Span::end(unicode_name_span)
  
  // æµ‹è¯•å¿«é€Ÿåˆ›å»ºå’Œç»“æŸspan
  for i = 0; i < 100; i = i + 1 {
    let quick_span = Tracer::start_span(tracer, "quick.span." + i.to_string())
    Span::end(quick_span)
  }
  
  // æµ‹è¯•åˆ›å»ºspanä½†ä¸æ·»åŠ ä»»ä½•äº‹ä»¶æˆ–çŠ¶æ€
  let minimal_span = Tracer::start_span(tracer, "minimal.span")
  Span::end(minimal_span)
  
  // æµ‹è¯•åˆ›å»ºspanå¹¶æ·»åŠ å¤§é‡äº‹ä»¶
  let many_events_span = Tracer::start_span(tracer, "many.events.span")
  for i = 0; i < 1000; i = i + 1 {
    Span::add_event(many_events_span, "event." + i.to_string(), Some([
      ("event.index", IntValue(i)),
      ("event.data", StringValue("data.for.event." + i.to_string()))
    ]))
  }
  Span::end(many_events_span)
  
  // æµ‹è¯•å¤šæ¬¡è®¾ç½®çŠ¶æ€
  let multi_status_span = Tracer::start_span(tracer, "multi.status.span")
  for i = 0; i < 100; i = i + 1 {
    if i % 3 == 0 {
      Span::set_status(multi_status_span, Ok, Some("Status " + i.to_string()))
    } else if i % 3 == 1 {
      Span::set_status(multi_status_span, Error, Some("Error " + i.to_string()))
    } else {
      Span::set_status(multi_status_span, Unset)
    }
  }
  Span::end(multi_status_span)
}

test "spanèµ„æºç®¡ç†å’Œæ¸…ç†æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "resource.management.test")
  
  // åˆ›å»ºå¤§é‡spanä»¥æµ‹è¯•èµ„æºç®¡ç†
  let span_count = 1000
  let spans = []
  
  for i = 0; i < span_count; i = i + 1 {
    let span = Tracer::start_span(tracer, "resource.test.span." + i.to_string())
    spans.push(span)
  }
  
  // ä¸ºæ¯ä¸ªspanæ·»åŠ äº‹ä»¶å’ŒçŠ¶æ€
  for i = 0; i < span_count; i = i + 1 {
    let span = spans[i]
    
    Span::add_event(span, "resource.test.event", Some([
      ("span.index", IntValue(i)),
      ("resource.test", StringValue("true"))
    ]))
    
    if i % 10 == 0 {
      Span::set_status(span, Ok, Some("Completed successfully"))
    } else if i % 10 == 5 {
      Span::set_status(span, Error, Some("Completed with error"))
    }
  }
  
  // æ‰¹é‡ç»“æŸspanä»¥æµ‹è¯•èµ„æºæ¸…ç†
  for span in spans {
    Span::end(span)
  }
  
  // éªŒè¯æ‰€æœ‰spanéƒ½å·²ç»“æŸ
  // æ³¨æ„ï¼šåœ¨ç®€åŒ–å®ç°ä¸­ï¼Œspanå¯èƒ½ä»ç„¶æŠ¥å‘Šä¸ºrecordingï¼Œä½†ä¸åº”è¯¥å´©æºƒ
  
  // æµ‹è¯•åˆ›å»ºspanåç«‹å³ç»“æŸ
  for i = 0; i < 100; i = i + 1 {
    let immediate_span = Tracer::start_span(tracer, "immediate.span." + i.to_string())
    Span::end(immediate_span)
  }
  
  // æµ‹è¯•åœ¨å·²ç»“æŸçš„spanä¸Šæ“ä½œï¼ˆåº”è¯¥è¢«å¿½ç•¥æˆ–å¤„ç†ï¼‰
  let ended_span = Tracer::start_span(tracer, "ended.test.span")
  Span::end(ended_span)
  
  // å°è¯•åœ¨å·²ç»“æŸçš„spanä¸Šæ·»åŠ äº‹ä»¶
  Span::add_event(ended_span, "after.end.event", Some([
    ("event.type", StringValue("after.end")),
    ("should.be", StringValue("ignored"))
  ]))
  
  // å°è¯•åœ¨å·²ç»“æŸçš„spanä¸Šè®¾ç½®çŠ¶æ€
  Span::set_status(ended_span, Ok, Some("Should be ignored"))
  
  // å†æ¬¡å°è¯•ç»“æŸå·²ç»“æŸçš„span
  Span::end(ended_span)
  
  assert_true(true)
}