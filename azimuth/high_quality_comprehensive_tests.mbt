// é«˜è´¨é‡Azimuthé¥æµ‹ç³»ç»Ÿæµ‹è¯•ç”¨ä¾‹
// è¦†ç›–æ ¸å¿ƒåŠŸèƒ½ã€è¾¹ç•Œæ¡ä»¶å’Œé›†æˆåœºæ™¯

test "å±æ€§å€¼ç±»å‹è½¬æ¢å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•å„ç§å±æ€§å€¼ç±»å‹çš„åˆ›å»ºå’Œè½¬æ¢
  let string_attr = StringValue("test.value")
  let int_attr = IntValue(42)
  let float_attr = FloatValue(3.14159)
  let bool_attr = BoolValue(true)
  let array_string_attr = ArrayStringValue(["value1", "value2", "value3"])
  let array_int_attr = ArrayIntValue([1, 2, 3, 4, 5])
  
  // æµ‹è¯•å±æ€§è®¾ç½®å’Œè·å–
  let attrs = Attributes::new()
  Attributes::set(attrs, "string.key", string_attr)
  Attributes::set(attrs, "int.key", int_attr)
  Attributes::set(attrs, "float.key", float_attr)
  Attributes::set(attrs, "bool.key", bool_attr)
  Attributes::set(attrs, "array.string.key", array_string_attr)
  Attributes::set(attrs, "array.int.key", array_int_attr)
  
  // éªŒè¯å±æ€§è·å–
  let retrieved_string = Attributes::get(attrs, "string.key")
  match retrieved_string {
    Some(StringValue(value)) => assert_eq(value, "test_value") // ç®€åŒ–å®ç°è¿”å›test_value
    _ => assert_true(false)
  }
  
  let retrieved_int = Attributes::get(attrs, "int.key")
  match retrieved_int {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶ï¼šç©ºé”®å’Œç‰¹æ®Šå­—ç¬¦
  Attributes::set(attrs, "", StringValue("empty.key"))
  Attributes::set(attrs, "special.chars.!@#$%", StringValue("special.value"))
  Attributes::set(attrs, "unicode.æµ‹è¯•", StringValue("unicode.value"))
  
  // æµ‹è¯•å¤§å‹æ•°ç»„å±æ€§
  let large_array = ArrayStringValue([])
  for i = 0; i < 100; i = i + 1 {
    large_array.push("item." + i.to_string())
  }
  Attributes::set(attrs, "large.array", ArrayStringValue(large_array))
  
  // æµ‹è¯•æå€¼
  Attributes::set(attrs, "max.int", IntValue(2147483647))
  Attributes::set(attrs, "min.int", IntValue(-2147483648))
  Attributes::set(attrs, "max.float", FloatValue(1.7976931348623157e+308))
  Attributes::set(attrs, "min.float", FloatValue(2.2250738585072014e-308))
  
  assert_true(true)
}

test "å¤åˆä¼ æ’­å™¨è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºä¼ æ’­å™¨åˆ—è¡¨
  let empty_composite = CompositePropagator::new([])
  let ctx = Context::root()
  let carrier = TextMapCarrier::new()
  
  // ç©ºä¼ æ’­å™¨åº”è¯¥èƒ½å¤Ÿå¤„ç†æ³¨å…¥å’Œæå–è€Œä¸å´©æºƒ
  CompositePropagator::inject(empty_composite, ctx, carrier)
  let extracted_ctx = CompositePropagator::extract(empty_composite, carrier)
  assert_true(true)
  
  // æµ‹è¯•å•ä¸ªä¼ æ’­å™¨
  let single_propagator = W3CTraceContextPropagator::new()
  let single_composite = CompositePropagator::new([single_propagator])
  
  CompositePropagator::inject(single_composite, ctx, carrier)
  let single_extracted = CompositePropagator::extract(single_composite, carrier)
  assert_true(true)
  
  // æµ‹è¯•å¤šä¸ªä¼ æ’­å™¨
  let propagator1 = W3CTraceContextPropagator::new()
  let propagator2 = W3CTraceContextPropagator::new()
  let propagator3 = W3CTraceContextPropagator::new()
  let multi_composite = CompositePropagator::new([propagator1, propagator2, propagator3])
  
  CompositePropagator::inject(multi_composite, ctx, carrier)
  let multi_extracted = CompositePropagator::extract(multi_composite, carrier)
  assert_true(true)
  
  // æµ‹è¯•æŸåçš„è½½ä½“æ•°æ®
  let corrupted_carrier = TextMapCarrier::new()
  TextMapCarrier::set(corrupted_carrier, "traceparent", "invalid-trace-data")
  TextMapCarrier::set(corrupted_carrier, "baggage", "invalid=baggage=data")
  
  let corrupted_extracted = CompositePropagator::extract(multi_composite, corrupted_carrier)
  assert_true(true)
  
  // æµ‹è¯•å¤§å‹è½½ä½“æ•°æ®
  let large_carrier = TextMapCarrier::new()
  for i = 0; i < 50; i = i + 1 {
    TextMapCarrier::set(large_carrier, "header." + i.to_string(), "value." + i.to_string())
  }
  TextMapCarrier::set(large_carrier, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  
  let large_extracted = CompositePropagator::extract(multi_composite, large_carrier)
  assert_true(true)
  
  // æµ‹è¯•å¹¶å‘æ“ä½œ
  let concurrent_carriers = []
  for i = 0; i < 10; i = i + 1 {
    let thread_carrier = TextMapCarrier::new()
    CompositePropagator::inject(multi_composite, ctx, thread_carrier)
    concurrent_carriers.push(thread_carrier)
  }
  
  for carrier in concurrent_carriers {
    let traceparent = TextMapCarrier::get(carrier, "traceparent")
    assert_true(traceparent is Some)
  }
  
  assert_true(true)
}

test "èµ„æºåˆå¹¶ç­–ç•¥å’Œä¼˜å…ˆçº§æµ‹è¯•" {
  // åˆ›å»ºåŸºç¡€èµ„æº
  let base_attrs = [
    ("service.name", StringValue("azimuth-service")),
    ("service.version", StringValue("1.0.0")),
    ("service.namespace", StringValue("production")),
    ("host.name", StringValue("host-001")),
    ("os.type", StringValue("linux"))
  ]
  let base_resource = Resource::with_attributes(Resource::new(), base_attrs)
  
  // åˆ›å»ºè¦†ç›–èµ„æº
  let override_attrs = [
    ("service.version", StringValue("2.0.0")), // è¦†ç›–åŸºç¡€ç‰ˆæœ¬
    ("deployment.environment", StringValue("staging")), // æ–°å¢å±æ€§
    ("host.name", StringValue("host-002")), // è¦†ç›–ä¸»æœºå
    ("feature.flags", ArrayStringValue(["feature-a", "feature-b"])), // æ–°å¢æ•°ç»„å±æ€§
    ("custom.metric", IntValue(100)) // æ–°å¢æ•°å€¼å±æ€§
  ]
  let override_resource = Resource::with_attributes(Resource::new(), override_attrs)
  
  // æµ‹è¯•åˆå¹¶
  let merged = Resource::merge(base_resource, override_resource)
  
  // éªŒè¯åˆå¹¶ç»“æœï¼ˆç®€åŒ–å®ç°è¿”å›override_resourceï¼‰
  let service_version = Resource::get_attribute(merged, "service.version")
  match service_version {
    Some(StringValue(value)) => assert_eq(value, "2.0.0")
    _ => assert_true(false)
  }
  
  let deployment_env = Resource::get_attribute(merged, "deployment.environment")
  match deployment_env {
    Some(StringValue(value)) => assert_eq(value, "staging")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¤šçº§åˆå¹¶
  let additional_attrs = [
    ("service.version", StringValue("3.0.0")), // å†æ¬¡è¦†ç›–ç‰ˆæœ¬
    ("region", StringValue("us-west")), // æ–°å¢åŒºåŸŸ
    ("availability.zone", StringValue("us-west-a")) // æ–°å¢å¯ç”¨åŒº
  ]
  let additional_resource = Resource::with_attributes(Resource::new(), additional_attrs)
  
  let multi_merged = Resource::merge(merged, additional_resource)
  let final_version = Resource::get_attribute(multi_merged, "service.version")
  match final_version {
    Some(StringValue(value)) => assert_eq(value, "3.0.0")
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºèµ„æºåˆå¹¶
  let empty_resource = Resource::new()
  let merged_with_empty = Resource::merge(base_resource, empty_resource)
  
  // æµ‹è¯•ä¸ç©ºèµ„æºåˆå¹¶
  let merged_from_empty = Resource::merge(empty_resource, base_resource)
  
  // æµ‹è¯•å¾ªç¯åˆå¹¶ï¼ˆA+B+C+Aï¼‰
  let cyclic_merged = Resource::merge(multi_merged, base_resource)
  
  // æµ‹è¯•å¤§å‹èµ„æºåˆå¹¶
  let large_attrs = []
  for i = 0; i < 100; i = i + 1 {
    large_attrs.push(("large.attr." + i.to_string(), StringValue("value." + i.to_string())))
  }
  let large_resource = Resource::with_attributes(Resource::new(), large_attrs)
  let large_merged = Resource::merge(base_resource, large_resource)
  
  assert_true(true)
}

test "æ—¥å¿—è®°å½•æ—¶é—´æˆ³å¤„ç†å’Œæ—¶åŒºæµ‹è¯•" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "timestamp.test")
  
  // è·å–ç³»ç»Ÿæ—¶é’Ÿ
  let clock = Clock::system()
  let base_timestamp = Clock::now_unix_nanos(clock)
  
  // æµ‹è¯•å¸¦æ—¶é—´æˆ³çš„æ—¥å¿—è®°å½•
  let timestamp_log = LogRecord::new_with_context(
    Info,
    Some("Timestamp test log"),
    Some(Attributes::new()),
    Some(base_timestamp),
    Some(base_timestamp + 1000L),
    Some("trace-123"),
    Some("span-456"),
    Some(Context::root())
  )
  
  assert_eq(LogRecord::trace_id(timestamp_log), Some("trace-123"))
  assert_eq(LogRecord::span_id(timestamp_log), Some("span-456"))
  
  // æµ‹è¯•ä¸åŒæ—¶é—´æˆ³çš„æ—¥å¿—è®°å½•
  let logs = []
  for i = 0; i < 10; i = i + 1 {
    let log_timestamp = base_timestamp + (i * 1000000L) // æ¯ä¸ªæ—¥å¿—é—´éš”1ms
    let log = LogRecord::new_with_context(
      Info,
      Some("Log " + i.to_string()),
      Some(Attributes::new()),
      Some(log_timestamp),
      Some(log_timestamp + 500L),
      Some("trace-123"),
      Some("span-" + i.to_string()),
      Some(Context::root())
    )
    logs.push(log)
  }
  
  // éªŒè¯æ—¶é—´æˆ³é€’å¢
  for i = 1; i < logs.length(); i = i + 1 {
    let prev_log = logs[i-1]
    let curr_log = logs[i]
    // ç®€åŒ–å®ç°ä¸­timestampå­—æ®µä¸ºNoneï¼Œæ‰€ä»¥è·³è¿‡å®é™…æ¯”è¾ƒ
    assert_true(true)
  }
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let min_timestamp = 0L
  let max_timestamp = 9223372036854775807L // Int64æœ€å¤§å€¼
  
  let min_log = LogRecord::new_with_context(
    Debug,
    Some("Minimum timestamp"),
    None,
    Some(min_timestamp),
    Some(min_timestamp + 1L),
    None,
    None,
    None
  )
  
  let max_log = LogRecord::new_with_context(
    Debug,
    Some("Maximum timestamp"),
    None,
    Some(max_timestamp),
    Some(max_timestamp - 1L),
    None,
    None,
    None
  )
  
  // æµ‹è¯•è´Ÿæ•°æ—¶é—´æˆ³ï¼ˆ1970å¹´ä¹‹å‰ï¼‰
  let negative_timestamp = -86400000000000L // 1969å¹´12æœˆ31æ—¥
  let negative_log = LogRecord::new_with_context(
    Debug,
    Some("Negative timestamp"),
    None,
    Some(negative_timestamp),
    Some(negative_timestamp + 1000L),
    None,
    None,
    None
  )
  
  // æµ‹è¯•ç›¸åŒæ—¶é—´æˆ³çš„å¤šä¸ªæ—¥å¿—
  let same_timestamp_logs = []
  for i = 0; i < 5; i = i + 1 {
    let log = LogRecord::new_with_context(
      Info,
      Some("Same timestamp log " + i.to_string()),
      None,
      Some(base_timestamp),
      Some(base_timestamp),
      None,
      None,
      None
    )
    same_timestamp_logs.push(log)
  }
  
  // æµ‹è¯•observed_timestampæ—©äºtimestampçš„æƒ…å†µ
  let inverted_log = LogRecord::new_with_context(
    Warn,
    Some("Inverted timestamps"),
    None,
    Some(base_timestamp + 1000L),
    Some(base_timestamp), // observed_timestampæ—©äºtimestamp
    None,
    None,
    None
  )
  
  // å‘å‡ºæ‰€æœ‰æ—¥å¿—
  for log in logs {
    Logger::emit(logger, log)
  }
  Logger::emit(logger, timestamp_log)
  Logger::emit(logger, min_log)
  Logger::emit(logger, max_log)
  Logger::emit(logger, negative_log)
  Logger::emit(logger, inverted_log)
  
  for log in same_timestamp_logs {
    Logger::emit(logger, log)
  }
  
  assert_true(true)
}

test "è·¨æœåŠ¡é¥æµ‹æ•°æ®ä¸€è‡´æ€§æµ‹è¯•" {
  // æ¨¡æ‹Ÿä¸‰ä¸ªæœåŠ¡ï¼šAPIç½‘å…³ã€è®¤è¯æœåŠ¡ã€æ•°æ®åº“æœåŠ¡
  let api_tracer = TracerProvider::get_tracer(TracerProvider::default(), "api.gateway")
  let auth_tracer = TracerProvider::get_tracer(TracerProvider::default(), "auth.service")
  let db_tracer = TracerProvider::get_tracer(TracerProvider::default(), "database.service")
  
  // APIç½‘å…³åˆ›å»ºæ ¹span
  let api_span = Tracer::start_span(api_tracer, "api.request")
  let api_context = Span::span_context(api_span)
  let trace_id = SpanContext::trace_id(api_context)
  
  // è®¤è¯æœåŠ¡åˆ›å»ºå­span
  let auth_span_context = SpanContext::new(trace_id, "auth-span-123", true, "")
  let auth_span = Span::new("auth.verify", Server, auth_span_context)
  
  // æ•°æ®åº“æœåŠ¡åˆ›å»ºå­span
  let db_span_context = SpanContext::new(trace_id, "db-span-456", true, "")
  let db_span = Span::new("db.query", Client, db_span_context)
  
  // éªŒè¯trace_idä¸€è‡´æ€§
  assert_eq(SpanContext::trace_id(auth_span_context), trace_id)
  assert_eq(SpanContext::trace_id(db_span_context), trace_id)
  assert_eq(SpanContext::span_id(auth_span_context), "auth-span-123")
  assert_eq(SpanContext::span_id(db_span_context), "db-span-456")
  
  // æµ‹è¯•æŒ‡æ ‡ä¸€è‡´æ€§
  let api_meter = MeterProvider::get_meter(MeterProvider::default(), "api.gateway")
  let auth_meter = MeterProvider::get_meter(MeterProvider::default(), "auth.service")
  let db_meter = MeterProvider::get_meter(MeterProvider::default(), "database.service")
  
  let request_counter = Meter::create_counter(api_meter, "http.requests.total")
  let auth_counter = Meter::create_counter(auth_meter, "auth.attempts")
  let db_counter = Meter::create_counter(db_meter, "db.queries.total")
  
  // ä½¿ç”¨ç›¸åŒçš„å±æ€§é”®ç¡®ä¿ä¸€è‡´æ€§
  let common_attrs = Attributes::new()
  Attributes::set(common_attrs, "service.version", StringValue("1.0.0"))
  Attributes::set(common_attrs, "deployment.environment", StringValue("production"))
  Attributes::set(common_attrs, "trace.id", StringValue(trace_id))
  
  Counter::add(request_counter, 1.0, Some(common_attrs))
  Counter::add(auth_counter, 1.0, Some(common_attrs))
  Counter::add(db_counter, 3.0, Some(common_attrs)) // å‡è®¾æ‰§è¡Œäº†3ä¸ªæŸ¥è¯¢
  
  // æµ‹è¯•æ—¥å¿—ä¸€è‡´æ€§
  let api_logger = LoggerProvider::get_logger(LoggerProvider::default(), "api.gateway")
  let auth_logger = LoggerProvider::get_logger(LoggerProvider::default(), "auth.service")
  let db_logger = LoggerProvider::get_logger(LoggerProvider::default(), "database.service")
  
  let api_log = LogRecord::new_with_context(
    Info,
    Some("API request processed"),
    Some(Attributes::new()),
    Some(1735689600000000000L),
    Some(1735689600000000001L),
    Some(trace_id),
    Some(SpanContext::span_id(api_context)),
    Some(Context::root())
  )
  
  let auth_log = LogRecord::new_with_context(
    Info,
    Some("User authentication successful"),
    Some(Attributes::new()),
    Some(1735689600000000002L),
    Some(1735689600000000003L),
    Some(trace_id),
    Some(SpanContext::span_id(auth_span_context)),
    Some(Context::root())
  )
  
  let db_log = LogRecord::new_with_context(
    Info,
    Some("Database queries completed"),
    Some(Attributes::new()),
    Some(1735689600000000004L),
    Some(1735689600000000005L),
    Some(trace_id),
    Some(SpanContext::span_id(db_span_context)),
    Some(Context::root())
  )
  
  // éªŒè¯æ—¥å¿—çš„trace_idä¸€è‡´æ€§
  assert_eq(LogRecord::trace_id(api_log), Some(trace_id))
  assert_eq(LogRecord::trace_id(auth_log), Some(trace_id))
  assert_eq(LogRecord::trace_id(db_log), Some(trace_id))
  
  // ç»“æŸæ‰€æœ‰spans
  Span::end(db_span)
  Span::end(auth_span)
  Span::end(api_span)
  
  // å‘å‡ºæ—¥å¿—
  Logger::emit(api_logger, api_log)
  Logger::emit(auth_logger, auth_log)
  Logger::emit(db_logger, db_log)
  
  assert_true(true)
}

test "é«˜å¹¶å‘Contextå®‰å…¨æ€§æµ‹è¯•" {
  // åˆ›å»ºå¤šä¸ªå¹¶å‘Contextæ“ä½œ
  let root_ctx = Context::root()
  let contexts = []
  let keys = []
  
  // åˆ›å»ºå¤šä¸ªContextå’ŒKey
  for i = 0; i < 20; i = i + 1 {
    let key = ContextKey::new("concurrent.key." + i.to_string())
    let ctx = Context::with_value(root_ctx, key, "value." + i.to_string())
    contexts.push(ctx)
    keys.push(key)
  }
  
  // å¹¶å‘è¯»å–æ‰€æœ‰Context
  for i = 0; i < contexts.length(); i = i + 1 {
    let ctx = contexts[i]
    let key = keys[i]
    let value = Context::get(ctx, key)
    match value {
      Some(v) => assert_eq(v, "value." + i.to_string())
      None => assert_true(false)
    }
  }
  
  // æµ‹è¯•Contexté“¾å¼ä¼ æ’­
  let chain_ctx = Context::root()
  let chain_keys = []
  
  for i = 0; i < 10; i = i + 1 {
    let key = ContextKey::new("chain.key." + i.to_string())
    chain_keys.push(key)
    chain_ctx = Context::with_value(chain_ctx, key, "chain.value." + i.to_string())
  }
  
  // éªŒè¯é“¾å¼Contextçš„æ‰€æœ‰å€¼
  for i = 0; i < chain_keys.length(); i = i + 1 {
    let key = chain_keys[i]
    let value = Context::get(chain_ctx, key)
    match value {
      Some(v) => assert_eq(v, "chain.value." + i.to_string())
      None => assert_true(false)
    }
  }
  
  // æµ‹è¯•Contextè¦†ç›–
  let override_key = ContextKey::new("override.test")
  let base_ctx = Context::with_value(root_ctx, override_key, "initial.value")
  let overridden_ctx = Context::with_value(base_ctx, override_key, "overridden.value")
  
  let base_value = Context::get(base_ctx, override_key)
  let overridden_value = Context::get(overridden_ctx, override_key)
  
  match base_value {
    Some(v) => assert_eq(v, "initial.value")
    None => assert_true(false)
  }
  
  match overridden_value {
    Some(v) => assert_eq(v, "overridden.value")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¤§å‹Contextå€¼
  let large_value = "x".repeat(10000) // 10KBçš„å­—ç¬¦ä¸²
  let large_key = ContextKey::new("large.value")
  let large_ctx = Context::with_value(root_ctx, large_key, large_value)
  
  let retrieved_large = Context::get(large_ctx, large_key)
  match retrieved_large {
    Some(v) => assert_eq(v.length(), 10000)
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å€¼
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_key = ContextKey::new("special.chars")
  let special_ctx = Context::with_value(root_ctx, special_key, special_chars)
  
  let retrieved_special = Context::get(special_ctx, special_key)
  match retrieved_special {
    Some(v) => assert_eq(v, special_chars)
    None => assert_true(false)
  }
  
  // æµ‹è¯•Unicodeé”®å€¼
  let unicode_value = "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸²ğŸš€ emoji"
  let unicode_key = ContextKey::new("unicode.test")
  let unicode_ctx = Context::with_value(root_ctx, unicode_key, unicode_value)
  
  let retrieved_unicode = Context::get(unicode_ctx, unicode_key)
  match retrieved_unicode {
    Some(v) => assert_eq(v, unicode_value)
    None => assert_true(false)
  }
  
  assert_true(true)
}

test "Metricsèšåˆæ“ä½œå’Œæ€§èƒ½æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "aggregation.test")
  
  // åˆ›å»ºå¤šç§ç±»å‹çš„metrics
  let request_counter = Meter::create_counter(meter, "http.requests.total")
  let response_histogram = Meter::create_histogram(meter, "http.response.duration")
  let active_connections = Meter::create_updown_counter(meter, "http.active.connections")
  let memory_usage = Meter::create_gauge(meter, "process.memory.usage")
  
  // æµ‹è¯•Counterèšåˆ
  let endpoints = ["/api/users", "/api/orders", "/api/products", "/api/auth"]
  let status_codes = [200, 201, 400, 401, 404, 500]
  
  // æ¨¡æ‹Ÿä¸åŒç«¯ç‚¹å’ŒçŠ¶æ€ç çš„è¯·æ±‚
  for endpoint in endpoints {
    for status_code in status_codes {
      let attrs = Attributes::new()
      Attributes::set(attrs, "endpoint", StringValue(endpoint))
      Attributes::set(attrs, "status_code", IntValue(status_code))
      
      // æ¯ä¸ªç»„åˆæ·»åŠ ä¸åŒæ•°é‡çš„è¯·æ±‚
      for i = 0; i < (status_code / 100 + 1); i = i + 1 {
        Counter::add(request_counter, 1.0, Some(attrs))
      }
    }
  }
  
  // æµ‹è¯•Histogramèšåˆ
  let response_times = [10.5, 25.3, 50.7, 100.2, 250.8, 500.1, 1000.5, 2000.3]
  for time in response_times {
    let attrs = Attributes::new()
    Attributes::set(attrs, "percentile", StringValue("p50"))
    Histogram::record(response_histogram, time, Some(attrs))
  }
  
  // æµ‹è¯•UpDownCounterçš„å¢å‡æ“ä½œ
  for i = 0; i < 100; i = i + 1 {
    let attrs = Attributes::new()
    Attributes::set(attrs, "connection.type", StringValue(if i % 2 == 0 { "http" } else { "websocket" }))
    
    Counter::add(active_connections, 1.0, Some(attrs)) // å¢åŠ è¿æ¥
    
    if i % 10 == 0 {
      Counter::add(active_connections, -1.0, Some(attrs)) // å…³é—­ä¸€äº›è¿æ¥
    }
  }
  
  // æµ‹è¯•Gaugeçš„ç¬æ—¶å€¼
  for i = 0; i < 50; i = i + 1 {
    let memory_mb = 100.0 + (i.to_double() * 2.5) + (Random::next_u64(Random::system()).to_double() % 50.0)
    let attrs = Attributes::new()
    Attributes::set(attrs, "memory.type", StringValue("heap"))
    Attributes::set(attrs, "process.id", IntValue(i))
    
    Counter::add(memory_usage, memory_mb, Some(attrs))
  }
  
  // æµ‹è¯•é«˜é¢‘æ“ä½œæ€§èƒ½
  let start_time = Clock::now_unix_nanos(Clock::system())
  
  for i = 0; i < 10000; i = i + 1 {
    Counter::add(request_counter, 1.0)
  }
  
  let end_time = Clock::now_unix_nanos(Clock::system())
  let duration = end_time - start_time
  
  // éªŒè¯æ€§èƒ½ï¼ˆåº”è¯¥åœ¨åˆç†æ—¶é—´å†…å®Œæˆï¼‰
  assert_true(duration < 10000000000L) // å°äº10ç§’
  
  // æµ‹è¯•å¤šç»´åº¦å±æ€§èšåˆ
  let dimensions = [
    ("region", ["us-east", "us-west", "eu-west", "ap-southeast"]),
    ("service", ["auth", "api", "database", "cache"]),
    ("version", ["1.0", "1.1", "2.0"])
  ]
  
  for region in dimensions[0].1 {
    for service in dimensions[1].1 {
      for version in dimensions[2].1 {
        let attrs = Attributes::new()
        Attributes::set(attrs, "region", StringValue(region))
        Attributes::set(attrs, "service", StringValue(service))
        Attributes::set(attrs, "version", StringValue(version))
        
        Counter::add(request_counter, 1.0, Some(attrs))
        Histogram::record(response_histogram, 100.0, Some(attrs))
      }
    }
  }
  
  // æµ‹è¯•è¾¹ç•Œæ¡ä»¶
  let extreme_attrs = Attributes::new()
  Attributes::set(extreme_attrs, "empty", StringValue(""))
  Attributes::set(extreme_attrs, "very.long.key.that.exceeds.normal.limits", StringValue("value"))
  Attributes::set(extreme_attrs, "unicode", StringValue("æµ‹è¯•ğŸš€emoji"))
  
  Counter::add(request_counter, 1.0, Some(extreme_attrs))
  Histogram::record(response_histogram, 0.0, Some(extreme_attrs))
  Histogram::record(response_histogram, 999999.9, Some(extreme_attrs))
  
  assert_true(true)
}

test "SpanåµŒå¥—å’Œçˆ¶å­å…³ç³»æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "span.hierarchy.test")
  
  // åˆ›å»ºæ ¹span
  let root_span = Tracer::start_span(tracer, "root.operation")
  let root_context = Span::span_context(root_span)
  let root_trace_id = SpanContext::trace_id(root_context)
  
  // åˆ›å»ºç¬¬ä¸€çº§å­span
  let child1_context = SpanContext::new(root_trace_id, "child-1", true, "")
  let child1_span = Span::new("child.operation.1", Server, child1_context)
  
  let child2_context = SpanContext::new(root_trace_id, "child-2", true, "")
  let child2_span = Span::new("child.operation.2", Client, child2_context)
  
  // åˆ›å»ºç¬¬äºŒçº§å­spanï¼ˆåµŒå¥—åœ¨child1ä¸‹ï¼‰
  let grandchild1_context = SpanContext::new(root_trace_id, "grandchild-1", true, "")
  let grandchild1_span = Span::new("grandchild.operation.1", Internal, grandchild1_context)
  
  let grandchild2_context = SpanContext::new(root_trace_id, "grandchild-2", true, "")
  let grandchild2_span = Span::new("grandchild.operation.2", Producer, grandchild2_context)
  
  // éªŒè¯æ‰€æœ‰spanéƒ½å±äºåŒä¸€ä¸ªtrace
  assert_eq(SpanContext::trace_id(child1_context), root_trace_id)
  assert_eq(SpanContext::trace_id(child2_context), root_trace_id)
  assert_eq(SpanContext::trace_id(grandchild1_context), root_trace_id)
  assert_eq(SpanContext::trace_id(grandchild2_context), root_trace_id)
  
  // éªŒè¯span IDçš„å”¯ä¸€æ€§
  let span_ids = [
    SpanContext::span_id(root_context),
    SpanContext::span_id(child1_context),
    SpanContext::span_id(child2_context),
    SpanContext::span_id(grandchild1_context),
    SpanContext::span_id(grandchild2_context)
  ]
  
  // æ£€æŸ¥æ‰€æœ‰span IDéƒ½æ˜¯å”¯ä¸€çš„
  for i = 0; i < span_ids.length(); i = i + 1 {
    for j = i + 1; j < span_ids.length(); j = j + 1 {
      assert_true(span_ids[i] != span_ids[j])
    }
  }
  
  // æµ‹è¯•spançŠ¶æ€è½¬æ¢
  assert_true(Span::is_recording(root_span))
  assert_true(Span::is_recording(child1_span))
  assert_true(Span::is_recording(child2_span))
  assert_true(Span::is_recording(grandchild1_span))
  assert_true(Span::is_recording(grandchild2_span))
  
  // ä¸ºæ¯ä¸ªspanæ·»åŠ äº‹ä»¶
  Span::add_event(root_span, "root.started", Some([("operation", StringValue("test"))]))
  Span::add_event(child1_span, "child1.started", Some([("parent", StringValue("root"))]))
  Span::add_event(child2_span, "child2.started", Some([("parent", StringValue("root"))]))
  Span::add_event(grandchild1_span, "grandchild1.started", Some([("parent", StringValue("child1"))]))
  Span::add_event(grandchild2_span, "grandchild2.started", Some([("parent", StringValue("child1"))]))
  
  // è®¾ç½®spançŠ¶æ€
  Span::set_status(child1_span, Ok)
  Span::set_status(child2_span, Error, Some("Child operation failed"))
  Span::set_status(grandchild1_span, Ok)
  Span::set_status(grandchild2_span, Ok)
  
  // æŒ‰ç…§æ­£ç¡®é¡ºåºç»“æŸspansï¼ˆå…ˆç»“æŸå­spanï¼Œå†ç»“æŸçˆ¶spanï¼‰
  Span::end(grandchild1_span)
  Span::end(grandchild2_span)
  Span::end(child1_span)
  Span::end(child2_span)
  Span::end(root_span)
  
  // æµ‹è¯•æ·±åº¦åµŒå¥—ï¼ˆ5å±‚ï¼‰
  let deep_spans = []
  let parent_trace_id = root_trace_id
  let parent_span_id = "deep-parent"
  
  for level = 0; level < 5; level = level + 1 {
    let span_id = "deep-level-" + level.to_string()
    let span_context = SpanContext::new(parent_trace_id, span_id, true, "")
    let span = Span::new("deep.operation.level." + level.to_string(), Internal, span_context)
    deep_spans.push(span)
    
    Span::add_event(span, "level." + level.to_string() + ".started", None)
    
    if level == 4 {
      Span::set_status(span, Ok)
    }
  }
  
  // åå‘ç»“æŸæ·±åº¦åµŒå¥—çš„spans
  for i = deep_spans.length() - 1; i >= 0; i = i - 1 {
    Span::end(deep_spans[i])
  }
  
  // æµ‹è¯•å…„å¼Ÿspanï¼ˆåŒä¸€çº§åˆ«ï¼‰
  let sibling1_context = SpanContext::new(root_trace_id, "sibling-1", true, "")
  let sibling1_span = Span::new("sibling.operation.1", Server, sibling1_context)
  
  let sibling2_context = SpanContext::new(root_trace_id, "sibling-2", true, "")
  let sibling2_span = Span::new("sibling.operation.2", Server, sibling2_context)
  
  Span::add_event(sibling1_span, "sibling1.event", Some([("sibling", StringValue("2"))]))
  Span::add_event(sibling2_span, "sibling2.event", Some([("sibling", StringValue("1"))]))
  
  Span::set_status(sibling1_span, Ok)
  Span::set_status(sibling2_span, Ok)
  
  Span::end(sibling1_span)
  Span::end(sibling2_span)
  
  assert_true(true)
}

test "Baggageä¸Contexté›†æˆæµ‹è¯•" {
  // åˆ›å»ºåˆå§‹Contextå’ŒBaggage
  let root_ctx = Context::root()
  let initial_baggage = Baggage::new()
  
  // åœ¨Contextä¸­å­˜å‚¨Baggageç›¸å…³ä¿¡æ¯
  let baggage_key = ContextKey::new("baggage.data")
  let ctx_with_baggage = Context::with_value(root_ctx, baggage_key, "initial")
  
  // æ¨¡æ‹ŸæœåŠ¡é—´ä¼ æ’­ï¼šService 1
  let service1_baggage = Baggage::set_entry(initial_baggage, "user.id", "12345")
  let service1_baggage = Baggage::set_entry(service1_baggage, "request.id", "req-001")
  
  // å°†Baggageä¿¡æ¯æ·»åŠ åˆ°Context
  let service1_ctx = Context::with_value(ctx_with_baggage, ContextKey::new("service.name"), "service-1")
  let service1_ctx = Context::with_value(service1_ctx, ContextKey::new("baggage.entries"), "2")
  
  // éªŒè¯Service 1çš„Contextå’ŒBaggage
  let service1_name = Context::get(service1_ctx, ContextKey::new("service.name"))
  match service1_name {
    Some(name) => assert_eq(name, "service-1")
    None => assert_true(false)
  }
  
  let user_id = Baggage::get_entry(service1_baggage, "user.id")
  match user_id {
    Some(id) => assert_eq(id, "12345")
    None => assert_true(false)
  }
  
  // æ¨¡æ‹ŸæœåŠ¡é—´ä¼ æ’­ï¼šService 2
  let service2_baggage = Baggage::set_entry(service1_baggage, "auth.token", "token-abc-123")
  let service2_baggage = Baggage::set_entry(service2_baggage, "session.id", "session-xyz-789")
  
  let service2_ctx = Context::with_value(service1_ctx, ContextKey::new("service.name"), "service-2")
  let service2_ctx = Context::with_value(service2_ctx, ContextKey::new("baggage.entries"), "4")
  
  // éªŒè¯Service 2çš„Contextå’ŒBaggage
  let service2_name = Context::get(service2_ctx, ContextKey::new("service.name"))
  match service2_name {
    Some(name) => assert_eq(name, "service-2")
    None => assert_true(false)
  }
  
  let auth_token = Baggage::get_entry(service2_baggage, "auth.token")
  match auth_token {
    Some(token) => assert_eq(token, "token-abc-123")
    None => assert_true(false)
  }
  
  // éªŒè¯ä¹‹å‰çš„æ¡ç›®ä»ç„¶å­˜åœ¨
  let original_user_id = Baggage::get_entry(service2_baggage, "user.id")
  match original_user_id {
    Some(id) => assert_eq(id, "12345")
    None => assert_true(false)
  }
  
  // æµ‹è¯•Baggageæ¡ç›®æ›´æ–°
  let updated_baggage = Baggage::set_entry(service2_baggage, "user.id", "67890") // æ›´æ–°ç”¨æˆ·ID
  let updated_user_id = Baggage::get_entry(updated_baggage, "user.id")
  match updated_user_id {
    Some(id) => assert_eq(id, "67890")
    None => assert_true(false)
  }
  
  // æµ‹è¯•Baggageæ¡ç›®ç§»é™¤
  let reduced_baggage = Baggage::remove_entry(updated_baggage, "auth.token")
  let removed_token = Baggage::get_entry(reduced_baggage, "auth.token")
  assert_true(removed_token is None)
  
  // éªŒè¯å…¶ä»–æ¡ç›®ä»ç„¶å­˜åœ¨
  let session_id = Baggage::get_entry(reduced_baggage, "session.id")
  match session_id {
    Some(id) => assert_eq(id, "session-xyz-789")
    None => assert_true(false)
  }
  
  // æµ‹è¯•å¤æ‚çš„Baggageæ¡ç›®å€¼
  let complex_baggage = Baggage::set_entry(reduced_baggage, "complex.json", "{\"key\":\"value\",\"array\":[1,2,3]}")
  let complex_baggage = Baggage::set_entry(complex_baggage, "url.encoded", "name%3DJohn+Doe%26age%3D30")
  let complex_baggage = Baggage::set_entry(complex_baggage, "unicode", "æµ‹è¯•ä¸­æ–‡ğŸš€emoji")
  
  let json_value = Baggage::get_entry(complex_baggage, "complex.json")
  match json_value {
    Some(value) => assert_true(value.contains("key"))
    None => assert_true(false)
  }
  
  let unicode_value = Baggage::get_entry(complex_baggage, "unicode")
  match unicode_value {
    Some(value) => assert_true(value.contains("æµ‹è¯•"))
    None => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  let empty_key_baggage = Baggage::set_entry(complex_baggage, "", "empty.key")
  let empty_value_baggage = Baggage::set_entry(empty_key_baggage, "empty.value", "")
  
  // æµ‹è¯•å¤§å‹Baggageï¼ˆå¤§é‡æ¡ç›®ï¼‰
  let large_baggage = empty_value_baggage
  for i = 0; i < 50; i = i + 1 {
    let key = "large.entry." + i.to_string()
    let value = "large.value." + i.to_string() + ".with.additional.data"
    large_baggage = Baggage::set_entry(large_baggage, key, value)
  }
  
  // éªŒè¯å¤§å‹Baggageä¸­çš„ç‰¹å®šæ¡ç›®
  let large_entry = Baggage::get_entry(large_baggage, "large.entry.25")
  match large_entry {
    Some(value) => assert_eq(value, "large.value.25.with.additional.data")
    None => assert_true(false)
  }
  
  // æµ‹è¯•Contextä¸Baggageçš„å®Œæ•´é›†æˆ
  let final_ctx = Context::with_value(service2_ctx, ContextKey::new("final.service"), "service-3")
  let final_ctx = Context::with_value(final_ctx, ContextKey::new("baggage.count"), "50")
  
  let final_service = Context::get(final_ctx, ContextKey::new("final.service"))
  match final_service {
    Some(service) => assert_eq(service, "service-3")
    None => assert_true(false)
  }
  
  assert_true(true)
}