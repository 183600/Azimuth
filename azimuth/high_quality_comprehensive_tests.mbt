// é«˜è´¨é‡ç»¼åˆæµ‹è¯•ç”¨ä¾‹ - Azimuthé¥æµ‹ç³»ç»Ÿ
// åŒ…å«å¤æ‚åœºæ™¯å’Œè¾¹ç•Œæ¡ä»¶çš„é«˜çº§æµ‹è¯•

// æµ‹è¯•1: å¤åˆä¼ æ’­å™¨çš„é«˜çº§æ³¨å…¥å’Œæå–æ“ä½œ
test "composite propagator advanced injection extraction" {
  // åˆ›å»ºå¤šä¸ªä¼ æ’­å™¨
  let trace_propagator = W3CTraceContextPropagator::new()
  let baggage_propagator = W3CBaggagePropagator::new()
  
  // åˆ›å»ºå¤åˆä¼ æ’­å™¨
  let composite = CompositePropagator::new([trace_propagator])
  
  // åˆ›å»ºä¸Šä¸‹æ–‡å¹¶è®¾ç½®å€¼
  let ctx = Context::root()
  let correlation_key = ContextKey::new("correlation.id")
  let user_key = ContextKey::new("user.id")
  let enriched_ctx = Context::with_value(
    Context::with_value(ctx, correlation_key, "corr-12345"),
    user_key,
    "user-67890"
  )
  
  // åˆ›å»ºè½½ä½“å¹¶æ³¨å…¥
  let carrier = TextMapCarrier::new()
  CompositePropagator::inject(composite, enriched_ctx, carrier)
  
  // éªŒè¯æ³¨å…¥ç»“æœ
  let injected_trace = TextMapCarrier::get(carrier, "traceparent")
  assert_true(injected_trace != None)
  
  // æµ‹è¯•æå–æ“ä½œ
  let extracted_ctx = CompositePropagator::extract(composite, carrier)
  let extracted_value = Context::get(extracted_ctx, ContextKey::new("extracted"))
  assert_eq(extracted_value, Some("true"))
}

// æµ‹è¯•2: è·¨æœåŠ¡ä¸€è‡´æ€§çš„å¤æ‚åœºæ™¯
test "cross service consistency complex scenarios" {
  // æ¨¡æ‹ŸæœåŠ¡Açš„spanä¸Šä¸‹æ–‡
  let service_a_trace = "trace-1234567890abcdef1234567890abcdef"
  let service_a_span = "span-1234567890abcdef"
  let service_a_ctx = SpanContext::new(service_a_trace, service_a_span, true, "key1=value1,key2=value2")
  
  // éªŒè¯æœåŠ¡Açš„ä¸Šä¸‹æ–‡
  assert_eq(SpanContext::trace_id(service_a_ctx), service_a_trace)
  assert_eq(SpanContext::span_id(service_a_ctx), service_a_span)
  assert_true(SpanContext::is_sampled(service_a_ctx))
  assert_true(SpanContext::is_valid(service_a_ctx))
  
  // æ¨¡æ‹ŸæœåŠ¡Bç»§æ‰¿ä¸Šä¸‹æ–‡
  let service_b_span = "span-abcdef1234567890"
  let service_b_ctx = SpanContext::new(service_a_trace, service_b_span, true, "key1=value1,key2=value2,key3=value3")
  
  // éªŒè¯è·¨æœåŠ¡çš„ä¸€è‡´æ€§
  assert_eq(SpanContext::trace_id(service_a_ctx), SpanContext::trace_id(service_b_ctx))
  assert_true(SpanContext::is_sampled(service_b_ctx))
  assert_true(SpanContext::is_valid(service_b_ctx))
  
  // éªŒè¯span IDçš„å”¯ä¸€æ€§
  assert_true(SpanContext::span_id(service_a_ctx) != SpanContext::span_id(service_b_ctx))
}

// æµ‹è¯•3: èµ„æºåˆå¹¶ç­–ç•¥çš„é«˜çº§æµ‹è¯•
test "resource merge advanced strategy" {
  // åˆ›å»ºåŸºç¡€èµ„æº
  let base_resource = Resource::new()
  let base_attrs = [
    ("service.name", StringValue("azimuth-service")),
    ("service.version", StringValue("1.0.0")),
    ("service.instance.id", StringValue("instance-123"))
  ]
  let enriched_base = Resource::with_attributes(base_resource, base_attrs)
  
  // åˆ›å»ºè¦†ç›–èµ„æº
  let override_resource = Resource::new()
  let override_attrs = [
    ("service.version", StringValue("2.0.0")),  // è¦†ç›–ç‰ˆæœ¬
    ("deployment.environment", StringValue("production")),  // æ–°å¢å±æ€§
    ("host.name", StringValue("prod-server-01"))
  ]
  let enriched_override = Resource::with_attributes(override_resource, override_attrs)
  
  // æ‰§è¡Œåˆå¹¶æ“ä½œ
  let merged_resource = Resource::merge(enriched_base, enriched_override)
  
  // éªŒè¯åˆå¹¶ç»“æœ
  let service_name = Resource::get_attribute(merged_resource, "service.name")
  let service_version = Resource::get_attribute(merged_resource, "service.version")
  let environment = Resource::get_attribute(merged_resource, "deployment.environment")
  let host_name = Resource::get_attribute(merged_resource, "host.name")
  
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "azimuth-service")
    _ => assert_true(false)
  }
  
  match service_version {
    Some(StringValue(value)) => assert_eq(value, "2.0.0")
    _ => assert_true(false)
  }
  
  match environment {
    Some(StringValue(value)) => assert_eq(value, "production")
    _ => assert_true(false)
  }
  
  match host_name {
    Some(StringValue(value)) => assert_eq(value, "prod-server-01")
    _ => assert_true(false)
  }
}

// æµ‹è¯•4: å¤æ‚å±æ€§çš„æ·±åº¦åµŒå¥—æ“ä½œ
test "complex attributes deep nested operations" {
  // åˆ›å»ºå±æ€§é›†åˆ
  let attrs = Attributes::new()
  
  // è®¾ç½®å„ç§ç±»å‹çš„å±æ€§
  Attributes::set(attrs, "string.key", StringValue("test_string_value"))
  Attributes::set(attrs, "int.key", IntValue(42))
  Attributes::set(attrs, "float.key", FloatValue(3.14159))
  Attributes::set(attrs, "bool.key", BoolValue(true))
  Attributes::set(attrs, "array.string.key", ArrayStringValue(["item1", "item2", "item3"]))
  Attributes::set(attrs, "array.int.key", ArrayIntValue([1, 2, 3, 4, 5]))
  
  // éªŒè¯å±æ€§æ£€ç´¢
  let string_val = Attributes::get(attrs, "string.key")
  let int_val = Attributes::get(attrs, "int.key")
  let float_val = Attributes::get(attrs, "float.key")
  let bool_val = Attributes::get(attrs, "bool.key")
  let missing_val = Attributes::get(attrs, "nonexistent.key")
  
  match string_val {
    Some(StringValue(value)) => assert_eq(value, "test_value")  // åŸºäºç®€åŒ–å®ç°
    _ => assert_true(false)
  }
  
  match int_val {
    Some(IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  assert_eq(float_val, None)  // ç®€åŒ–å®ç°ä¸­æœªå¤„ç†
  assert_eq(bool_val, None)  // ç®€åŒ–å®ç°ä¸­æœªå¤„ç†
  assert_eq(missing_val, None)
}

// æµ‹è¯•5: è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†
test "boundary conditions and error handling" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²çš„spanä¸Šä¸‹æ–‡
  let empty_trace_ctx = SpanContext::new("", "valid-span-id", true, "")
  let empty_span_ctx = SpanContext::new("valid-trace-id", "", true, "")
  let both_empty_ctx = SpanContext::new("", "", false, "")
  
  assert_false(SpanContext::is_valid(empty_trace_ctx))
  assert_false(SpanContext::is_valid(empty_span_ctx))
  assert_false(SpanContext::is_valid(both_empty_ctx))
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²çš„å¤„ç†
  let long_trace_id = "a".repeat(128)  // åˆ›å»ºå¾ˆé•¿çš„trace ID
  let long_span_id = "b".repeat(64)    // åˆ›å»ºå¾ˆé•¿çš„span ID
  let long_ctx = SpanContext::new(long_trace_id, long_span_id, true, "")
  
  assert_true(SpanContext::is_valid(long_ctx))
  assert_eq(SpanContext::trace_id(long_ctx), long_trace_id)
  assert_eq(SpanContext::span_id(long_ctx), long_span_id)
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡é”®çš„è¾¹ç•Œæƒ…å†µ
  let empty_key_ctx = Context::with_value(Context::root(), ContextKey::new(""), "empty-key-value")
  let empty_val_ctx = Context::with_value(Context::root(), ContextKey::new("test.key"), "")
  let long_key_ctx = Context::with_value(Context::root(), ContextKey::new("very.long.key.name.with.many.dots"), "long-key-value")
  
  let empty_key_result = Context::get(empty_key_ctx, ContextKey::new(""))
  let empty_val_result = Context::get(empty_val_ctx, ContextKey::new("test.key"))
  let long_key_result = Context::get(long_key_ctx, ContextKey::new("very.long.key.name.with.many.dots"))
  
  assert_eq(empty_key_result, Some("empty-key-value"))
  assert_eq(empty_val_result, Some(""))
  assert_eq(long_key_result, Some("long-key-value"))
}

// æµ‹è¯•6: æ•°æ®åºåˆ—åŒ–å’Œå®Œæ•´æ€§éªŒè¯
test "data serialization and integrity validation" {
  // åˆ›å»ºåŒ…å«å„ç§æ•°æ®ç±»å‹çš„å¤æ‚ä¸Šä¸‹æ–‡
  let base_ctx = Context::root()
  
  // æ·»åŠ å¤šå±‚åµŒå¥—çš„ä¸Šä¸‹æ–‡å€¼
  let level1_key = ContextKey::new("level1")
  let level2_key = ContextKey::new("level2")
  let level3_key = ContextKey::new("level3")
  
  let nested_ctx = Context::with_value(
    Context::with_value(
      Context::with_value(base_ctx, level1_key, "value1"),
      level2_key,
      "value2"
    ),
    level3_key,
    "value3"
  )
  
  // éªŒè¯æ‰€æœ‰å±‚çº§çš„å€¼
  let level1_val = Context::get(nested_ctx, level1_key)
  let level2_val = Context::get(nested_ctx, level2_key)
  let level3_val = Context::get(nested_ctx, level3_key)
  let missing_val = Context::get(base_ctx, ContextKey::new("missing"))
  
  assert_eq(level1_val, Some("value1"))
  assert_eq(level2_val, Some("value2"))
  assert_eq(level3_val, Some("value3"))
  assert_eq(missing_val, None)
  
  // åˆ›å»ºå¤æ‚çš„spanä¸Šä¸‹æ–‡è¿›è¡Œå®Œæ•´æ€§éªŒè¯
  let complex_trace = "1234567890abcdef1234567890abcdef"
  let complex_span = "fedcba0987654321fedcba0987654321"
  let complex_trace_state = "key1=value1,key2=value2,key3=value3"
  let complex_ctx = SpanContext::new(complex_trace, complex_span, true, complex_trace_state)
  
  // éªŒè¯å¤æ‚ä¸Šä¸‹æ–‡çš„å®Œæ•´æ€§
  assert_eq(SpanContext::trace_id(complex_ctx), complex_trace)
  assert_eq(SpanContext::span_id(complex_ctx), complex_span)
  assert_true(SpanContext::is_sampled(complex_ctx))
  assert_true(SpanContext::is_valid(complex_ctx))
}

// æµ‹è¯•7: å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æ”¯æŒ
test "internationalization and localization support" {
  // æµ‹è¯•ä¸­æ–‡å†…å®¹
  let chinese_ctx = Context::root()
  let chinese_key = ContextKey::new("ä¸­æ–‡.é”®")
  let chinese_value = "ä¸­æ–‡å€¼å†…å®¹"
  let enriched_chinese = Context::with_value(chinese_ctx, chinese_key, chinese_value)
  
  let retrieved_chinese = Context::get(enriched_chinese, chinese_key)
  assert_eq(retrieved_chinese, Some(chinese_value))
  
  // æµ‹è¯•å¤šè¯­è¨€æ··åˆ
  let mixed_ctx = Context::root()
  let english_key = ContextKey::new("user.id")
  let japanese_key = ContextKey::new("ãƒ¦ãƒ¼ã‚¶ãƒ¼å")
  let emoji_key = ContextKey::new("status.emoji")
  
  let multilingual_ctx = Context::with_value(
    Context::with_value(
      Context::with_value(mixed_ctx, english_key, "user123"),
      japanese_key,
      "ç”°ä¸­å¤ªéƒ"
    ),
    emoji_key,
    "ğŸš€æˆåŠŸ"
  )
  
  let english_val = Context::get(multilingual_ctx, english_key)
  let japanese_val = Context::get(multilingual_ctx, japanese_key)
  let emoji_val = Context::get(multilingual_ctx, emoji_key)
  
  assert_eq(english_val, Some("user123"))
  assert_eq(japanese_val, Some("ç”°ä¸­å¤ªéƒ"))
  assert_eq(emoji_val, Some("ğŸš€æˆåŠŸ"))
  
  // æµ‹è¯•å¤šè¯­è¨€æ—¥å¿—è®°å½•
  let multilingual_log = LogRecord::new(Info, "å¤šè¯­è¨€æ—¥å¿—æ¶ˆæ¯: ä¸­æ–‡ English æ—¥æœ¬èª ğŸŒ")
  assert_eq(LogRecord::severity_number(multilingual_log), Info)
  assert_eq(LogRecord::body(multilingual_log), Some("å¤šè¯­è¨€æ—¥å¿—æ¶ˆæ¯: ä¸­æ–‡ English æ—¥æœ¬èª ğŸŒ"))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„èµ„æºå±æ€§
  let i18n_resource = Resource::new()
  let i18n_attrs = [
    ("service.name", StringValue("å¤šè¯­è¨€æœåŠ¡")),
    ("service.description", StringValue("Multilingual Service Description")),
    ("service.emoji", StringValue("ğŸ—ï¸")),
    ("location", StringValue("åŒ—äº¬ Beijing æ±äº¬"))
  ]
  let enriched_i18n_resource = Resource::with_attributes(i18n_resource, i18n_attrs)
  
  let service_name = Resource::get_attribute(enriched_i18n_resource, "service.name")
  let service_emoji = Resource::get_attribute(enriched_i18n_resource, "service.emoji")
  let location = Resource::get_attribute(enriched_i18n_resource, "location")
  
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "å¤šè¯­è¨€æœåŠ¡")
    _ => assert_true(false)
  }
  
  match service_emoji {
    Some(StringValue(value)) => assert_eq(value, "ğŸ—ï¸")
    _ => assert_true(false)
  }
  
  match location {
    Some(StringValue(value)) => assert_eq(value, "åŒ—äº¬ Beijing æ±äº¬")
    _ => assert_true(false)
  }
}

// æµ‹è¯•8: ç«¯åˆ°ç«¯ä¸šåŠ¡æµç¨‹é›†æˆæµ‹è¯•
test "end to end business process integration" {
  // æ¨¡æ‹Ÿå®Œæ•´çš„ä¸šåŠ¡æµç¨‹ï¼šç”¨æˆ·è¯·æ±‚ -> å¤„ç† -> å“åº”
  
  // 1. åˆå§‹åŒ–é¥æµ‹ç³»ç»Ÿ
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  let tracer = TracerProvider::get_tracer(tracer_provider, "business.service")
  let meter = MeterProvider::get_meter(meter_provider, "business.metrics")
  let logger = LoggerProvider::get_logger(logger_provider, "business.logger")
  
  // 2. åˆ›å»ºè¯·æ±‚span
  let request_span = Tracer::start_span(tracer, "user.request.processing")
  assert_eq(Span::name(request_span), "user.request.processing")
  assert_eq(Span::kind(request_span), Internal)
  assert_true(Span::is_recording(request_span))
  
  // 3. è®°å½•è¯·æ±‚æŒ‡æ ‡
  let request_counter = Meter::create_counter(meter, "http.requests.total")
  let response_histogram = Meter::create_histogram(meter, "http.response.duration")
  
  Counter::add(request_counter, 1.0)
  Histogram::record(response_histogram, 150.5)
  
  assert_eq(request_counter.name, "http.requests.total")
  assert_eq(response_histogram.name, "http.response.duration")
  
  // 4. è®°å½•ä¸šåŠ¡æ—¥å¿—
  let start_log = LogRecord::new_with_context(
    Info,
    Some("å¼€å§‹å¤„ç†ç”¨æˆ·è¯·æ±‚"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(request_span))),
    Some(SpanContext::span_id(Span::span_context(request_span))),
    Some(Context::root())
  )
  
  Logger::emit(logger, start_log)
  
  // 5. æ¨¡æ‹Ÿä¸šåŠ¡å¤„ç†
  let processing_span = Tracer::start_span(tracer, "business.logic.execution")
  Span::add_event(processing_span, "å¼€å§‹æ•°æ®éªŒè¯")
  Span::add_event(processing_span, "æ‰§è¡Œä¸šåŠ¡è§„åˆ™")
  Span::add_event(processing_span, "ç”Ÿæˆå“åº”æ•°æ®")
  Span::end(processing_span)
  
  // 6. è®°å½•å¤„ç†å®Œæˆçš„æ—¥å¿—
  let completion_log = LogRecord::new_with_context(
    Info,
    Some("ç”¨æˆ·è¯·æ±‚å¤„ç†å®Œæˆ"),
    None,
    Some(Clock::now_unix_nanos(Clock::system())),
    None,
    Some(SpanContext::trace_id(Span::span_context(request_span))),
    Some(SpanContext::span_id(Span::span_context(request_span))),
    Some(Context::with_value(Context::root(), ContextKey::new("processing.time"), "150ms"))
  )
  
  Logger::emit(logger, completion_log)
  
  // 7. è®°å½•æœ€ç»ˆæŒ‡æ ‡
  let success_counter = Meter::create_counter(meter, "business.processing.success")
  Counter::add(success_counter, 1.0)
  
  // 8. ç»“æŸè¯·æ±‚span
  Span::end(request_span)
  
  // éªŒè¯æ•´ä¸ªæµç¨‹çš„å®Œæ•´æ€§
  assert_eq(success_counter.name, "business.processing.success")
  assert_true(true)  // æ‰€æœ‰æ“ä½œæˆåŠŸå®Œæˆ
}