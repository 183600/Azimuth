// é«˜è´¨é‡ç»¼åˆæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯• azimuth åº“çš„æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "add_function_comprehensive" {
  // æµ‹è¯•åŠ æ³•å‡½æ•°çš„å„ç§æƒ…å†µ
  assert_eq(0, add(0, 0))
  assert_eq(10, add(3, 7))
  assert_eq(-10, add(-3, -7))
  assert_eq(4, add(-3, 7))
  assert_eq(-4, add(3, -7))
  assert_eq(1000, add(500, 500))
}

test "multiply_function_edge_cases" {
  // æµ‹è¯•ä¹˜æ³•å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, multiply(0, 5))
  assert_eq(0, multiply(5, 0))
  assert_eq(1, multiply(1, 1))
  assert_eq(-1, multiply(-1, 1))
  assert_eq(1, multiply(-1, -1))
  assert_eq(100, multiply(10, 10))
}

test "greet_function_unicode_and_special" {
  // æµ‹è¯•é—®å€™å‡½æ•°çš„ Unicode å’Œç‰¹æ®Šå­—ç¬¦
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ğŸŒ™!", greet("ğŸŒ™"))
  assert_eq_string("Hello, @#$%!", greet("@#$%"))
  assert_eq_string("Hello, line1
line2!", greet("line1
line2"))
  assert_eq_string("Hello, tab	test!", greet("tab	test"))
}

test "divide_with_ceil_comprehensive" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„ç»¼åˆæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(2, divide_with_ceil(3, 2))
  assert_eq(3, divide_with_ceil(8, 3))
  assert_eq(0, divide_with_ceil(5, 0))
  assert_eq(-2, divide_with_ceil(-7, 4))
  assert_eq(2, divide_with_ceil(-7, -4))
}

test "complex_business_logic" {
  // æµ‹è¯•å¤æ‚ä¸šåŠ¡é€»è¾‘è®¡ç®—
  // åœºæ™¯ï¼šè®¡ç®—è®¢å•æ€»æˆæœ¬ï¼ˆå•†å“ä»·æ ¼ Ã— æ•°é‡ + è¿è´¹ï¼‰
  let item_price = 25
  let quantity = 8
  let shipping_cost = 15
  let total_cost = add(multiply(item_price, quantity), shipping_cost)
  assert_eq(215, total_cost)  // 25*8 + 15 = 200 + 15 = 215
  
  // åœºæ™¯ï¼šè®¡ç®—éœ€è¦çš„åŒ…è£…ç›’æ•°é‡
  let total_items = 37
  let items_per_box = 6
  let boxes_needed = divide_with_ceil(total_items, items_per_box)
  assert_eq(7, boxes_needed)  // ceil(37/6) = 7
}

test "mathematical_properties_verification" {
  // æµ‹è¯•æ•°å­¦æ€§è´¨çš„éªŒè¯
  let x = 12
  let y = 8
  
  // åŠ æ³•äº¤æ¢å¾‹
  assert_eq(add(x, y), add(y, x))
  
  // ä¹˜æ³•äº¤æ¢å¾‹
  assert_eq(multiply(x, y), multiply(y, x))
  
  // åˆ†é…å¾‹
  let z = 5
  assert_eq(multiply(x, add(y, z)), add(multiply(x, y), multiply(x, z)))
  
  // é›¶å…ƒç´ æ€§è´¨
  assert_eq(x, add(x, 0))
  assert_eq(0, multiply(x, 0))
}

test "error_handling_and_boundary_values" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’Œè¾¹ç•Œå€¼
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 0))
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  
  // æå€¼æµ‹è¯•
  assert_eq(2000000000, add(1000000000, 1000000000))
  assert_eq(-2000000000, add(-1000000000, -1000000000))
  assert_eq(0, add(1000000000, -1000000000))
}

test "string_processing_comprehensive" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„ç»¼åˆæƒ…å†µ
  assert_eq_string("Hello, Alice!", greet("Alice"))
  assert_eq_string("Hello, !", greet(""))
  assert_eq_string("Hello, 12345!", greet("12345"))
  assert_eq_string("Hello, John Doe!", greet("John Doe"))
  assert_eq_string("Hello, email@domain.com!", greet("email@domain.com"))
  assert_eq_string("Hello, (parentheses)!", greet("(parentheses)"))
}

test "nested_calculations_workflow" {
  // æµ‹è¯•åµŒå¥—è®¡ç®—å·¥ä½œæµ
  // åœºæ™¯ï¼šè®¡ç®—å¤šæ‰¹æ¬¡è´§ç‰©çš„æ€»å®¹å™¨éœ€æ±‚
  let batch_sizes = [23, 15, 8, 31]
  let container_capacity = 10
  
  let batch1_containers = divide_with_ceil(batch_sizes[0], container_capacity)
  let batch2_containers = divide_with_ceil(batch_sizes[1], container_capacity)
  let batch3_containers = divide_with_ceil(batch_sizes[2], container_capacity)
  let batch4_containers = divide_with_ceil(batch_sizes[3], container_capacity)
  
  let total_containers = add(add(batch1_containers, batch2_containers), 
                             add(batch3_containers, batch4_containers))
  
  assert_eq(10, total_containers)  // 3+2+1+4 = 10
  
  // å¤æ‚åµŒå¥—è®¡ç®—éªŒè¯
  let complex_result = divide_with_ceil(multiply(add(5, 3), 4), 6)
  assert_eq(6, complex_result)  // ceil((5+3)*4/6) = ceil(32/6) = 6
}

test "performance_large_numbers" {
  // æµ‹è¯•å¤§æ•°æ€§èƒ½è®¡ç®—
  let large_num1 = 100000
  let large_num2 = 20000
  
  // å¤§æ•°åŠ æ³•
  assert_eq(120000, add(large_num1, large_num2))
  
  // å¤§æ•°ä¹˜æ³•
  assert_eq(2000000000, multiply(large_num1, large_num2))
  
  // å¤§æ•°é™¤æ³•
  assert_eq(10, divide_with_ceil(large_num1, 10000))
  assert_eq(11, divide_with_ceil(large_num1, 9500))
  
  // å¤åˆå¤§æ•°è®¡ç®—
  let complex_large = add(multiply(large_num1, 2), divide_with_ceil(large_num2, 1000))
  assert_eq(200020, complex_large)  // 100000*2 + ceil(20000/1000) = 200000 + 20 = 200020
}