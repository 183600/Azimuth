// è¾¹ç•Œæ¡ä»¶é”™è¯¯å¤„ç†é«˜çº§æµ‹è¯•
// æµ‹è¯•ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶ã€å¼‚å¸¸æƒ…å†µå’Œé”™è¯¯è¾“å…¥ä¸‹çš„è¡Œä¸º

test "ç©ºå€¼å’ŒNoneè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å¤„ç†
  let empty_string = StringValue("")
  match empty_string {
    StringValue(s) => {
      assert_eq(s.length(), 0, "ç©ºå­—ç¬¦ä¸²é•¿åº¦åº”è¯¥ä¸º0")
      assert_eq(s, "", "ç©ºå­—ç¬¦ä¸²åº”è¯¥ç­‰äºç©ºå­—ç¬¦ä¸²")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„å¤„ç†
  let empty_string_array = ArrayStringValue([])
  let empty_int_array = ArrayIntValue([])
  
  match empty_string_array {
    ArrayStringValue(arr) => assert_eq(arr.length(), 0, "ç©ºå­—ç¬¦ä¸²æ•°ç»„é•¿åº¦åº”è¯¥ä¸º0")
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²æ•°ç»„å€¼")
  }
  
  match empty_int_array {
    ArrayIntValue(arr) => assert_eq(arr.length(), 0, "ç©ºæ•´æ•°æ•°ç»„é•¿åº¦åº”è¯¥ä¸º0")
    _ => assert_true(false, "æœŸæœ›æ•´æ•°æ•°ç»„å€¼")
  }
  
  // æµ‹è¯•Noneå€¼å¤„ç†
  let none_option : Option[String] = None
  assert_eq(none_option, None, "Noneå€¼åº”è¯¥ç­‰äºNone")
  
  // æµ‹è¯•ç©ºå±æ€§é›†åˆ
  let empty_attributes = Attributes::new()
  let empty_result = Attributes::get(empty_attributes, "any.key")
  assert_eq(empty_result, None, "ç©ºå±æ€§é›†åˆåº”è¯¥è¿”å›None")
  
  // æµ‹è¯•ç©ºèµ„æº
  let empty_resource = Resource::new()
  assert_eq(empty_resource.attributes.length(), 0, "ç©ºèµ„æºå±æ€§é•¿åº¦åº”è¯¥ä¸º0")
  
  let empty_resource_result = Resource::get_attribute(empty_resource, "any.attribute")
  assert_eq(empty_resource_result, None, "ç©ºèµ„æºåº”è¯¥è¿”å›None")
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_context = Context::root()
  let empty_context_result = Context::get(empty_context, ContextKey::new("any.key"))
  assert_eq(empty_context_result, None, "ç©ºä¸Šä¸‹æ–‡åº”è¯¥è¿”å›None")
  
  // æµ‹è¯•ç©ºè½½ä½“
  let empty_carrier = TextMapCarrier::new()
  let empty_carrier_result = TextMapCarrier::get(empty_carrier, "any.header")
  assert_eq(empty_carrier_result, None, "ç©ºè½½ä½“åº”è¯¥è¿”å›None")
}

test "æå€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æ•´æ•°æå€¼
  let max_int = IntValue(2147483647)
  let min_int = IntValue(-2147483648)
  let zero_int = IntValue(0)
  
  match max_int {
    IntValue(i) => assert_eq(i, 2147483647, "æœ€å¤§æ•´æ•°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æ•´æ•°å€¼")
  }
  
  match min_int {
    IntValue(i) => assert_eq(i, -2147483648, "æœ€å°æ•´æ•°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æ•´æ•°å€¼")
  }
  
  match zero_int {
    IntValue(i) => assert_eq(i, 0, "é›¶æ•´æ•°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æ•´æ•°å€¼")
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°æå€¼
  let very_large_float = FloatValue(1.7976931348623157e+308)
  let very_small_float = FloatValue(2.2250738585072014e-308)
  let zero_float = FloatValue(0.0)
  let negative_float = FloatValue(-1.23456789)
  
  match very_large_float {
    FloatValue(f) => assert_true(f > 1.0e+307, "æå¤§æµ®ç‚¹æ•°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  match very_small_float {
    FloatValue(f) => assert_true(f > 0.0 && f < 1.0e-307, "æå°æµ®ç‚¹æ•°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  match zero_float {
    FloatValue(f) => assert_true(f == 0.0, "é›¶æµ®ç‚¹æ•°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  match negative_float {
    FloatValue(f) => assert_true(f < 0.0, "è´Ÿæµ®ç‚¹æ•°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  // æµ‹è¯•ç‰¹æ®Šæµ®ç‚¹å€¼
  let infinity_float = FloatValue(1.0 / 0.0) // æ­£æ— ç©·
  let neg_infinity_float = FloatValue(-1.0 / 0.0) // è´Ÿæ— ç©·
  let nan_float = FloatValue(0.0 / 0.0) // NaN
  
  match infinity_float {
    FloatValue(f) => assert_true(f > 1.0e+308, "æ­£æ— ç©·åº”è¯¥è¢«è¯†åˆ«")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  match neg_infinity_float {
    FloatValue(f) => assert_true(f < -1.0e+308, "è´Ÿæ— ç©·åº”è¯¥è¢«è¯†åˆ«")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  match nan_float {
    FloatValue(f) => assert_true(f != f, "NaNåº”è¯¥è¢«è¯†åˆ«ï¼ˆNaN != NaNï¼‰")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²
  let very_long_string = StringValue("è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹é•¿å­—ç¬¦ä¸²çš„å¤„ç†èƒ½åŠ›ã€‚" * 20)
  match very_long_string {
    StringValue(s) => assert_true(s.length() > 200, "æé•¿å­—ç¬¦ä¸²åº”è¯¥è¢«æ­£ç¡®å¤„ç†")
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
}

test "Spanä¸Šä¸‹æ–‡è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æ— æ•ˆçš„Spanä¸Šä¸‹æ–‡
  let invalid_trace_id = SpanContext::new("", "1234567890abcdef", true, "")
  let invalid_span_id = SpanContext::new("1234567890abcdef1234567890abcdef", "", true, "")
  let both_invalid = SpanContext::new("", "", false, "")
  
  // éªŒè¯æ— æ•ˆä¸Šä¸‹æ–‡
  assert_false(SpanContext::is_valid(invalid_trace_id), "ç©ºtrace IDçš„ä¸Šä¸‹æ–‡åº”è¯¥æ— æ•ˆ")
  assert_false(SpanContext::is_valid(invalid_span_id), "ç©ºspan IDçš„ä¸Šä¸‹æ–‡åº”è¯¥æ— æ•ˆ")
  assert_false(SpanContext::is_valid(both_invalid), "ç©ºIDçš„ä¸Šä¸‹æ–‡åº”è¯¥æ— æ•ˆ")
  
  // æµ‹è¯•æœ‰æ•ˆçš„Spanä¸Šä¸‹æ–‡
  let valid_context = SpanContext::new("1234567890abcdef1234567890abcdef", "1234567890abcdef", true, "key1=value1")
  assert_true(SpanContext::is_valid(valid_context), "æœ‰æ•ˆä¸Šä¸‹æ–‡åº”è¯¥è¢«è¯†åˆ«ä¸ºæœ‰æ•ˆ")
  
  // æµ‹è¯•é‡‡æ ·çŠ¶æ€
  let sampled_context = SpanContext::new("1234567890abcdef1234567890abcdef", "1234567890abcdef", true, "")
  let not_sampled_context = SpanContext::new("1234567890abcdef1234567890abcdef", "1234567890abcdef", false, "")
  
  assert_true(SpanContext::is_sampled(sampled_context), "é‡‡æ ·ä¸Šä¸‹æ–‡åº”è¯¥è¢«è¯†åˆ«ä¸ºå·²é‡‡æ ·")
  assert_false(SpanContext::is_sampled(not_sampled_context), "æœªé‡‡æ ·ä¸Šä¸‹æ–‡åº”è¯¥è¢«è¯†åˆ«ä¸ºæœªé‡‡æ ·")
  
  // æµ‹è¯•trace stateè¾¹ç•Œæ¡ä»¶
  let empty_trace_state = SpanContext::new("1234567890abcdef1234567890abcdef", "1234567890abcdef", true, "")
  let long_trace_state = SpanContext::new("1234567890abcdef1234567890abcdef", "1234567890abcdef", true, "key1=value1,key2=value2,key3=value3,key4=value4,key5=value5")
  
  assert_eq(SpanContext::trace_state(empty_trace_state), "", "ç©ºtrace stateåº”è¯¥ä¸ºç©ºå­—ç¬¦ä¸²")
  assert_true(SpanContext::trace_state(long_trace_state).length() > 20, "é•¿trace stateåº”è¯¥è¢«æ­£ç¡®å¤„ç†")
}

test "é”™è¯¯æ¢å¤å’Œå®¹é”™æµ‹è¯•" {
  // æµ‹è¯•æŸåçš„traceparentå¤´å¤„ç†
  let corrupted_carrier = TextMapCarrier::new()
  TextMapCarrier::set(corrupted_carrier, "traceparent", "invalid-trace-data")
  
  let propagator = W3CTraceContextPropagator::new()
  let composite_propagator = CompositePropagator::new([propagator])
  
  // å°è¯•ä»æŸåæ•°æ®æå–
  let ctx_from_corrupted = CompositePropagator::extract(composite_propagator, corrupted_carrier)
  let extracted_from_corrupted = Context::get(ctx_from_corrupted, ContextKey::new("extracted"))
  
  // ç³»ç»Ÿåº”è¯¥èƒ½ä»æŸåæ•°æ®æ¢å¤
  assert_eq(extracted_from_corrupted, Some("true"), "åº”è¯¥èƒ½ä»æŸåæ•°æ®æ¢å¤")
  
  // æµ‹è¯•éƒ¨åˆ†ç¼ºå¤±çš„å¤´éƒ¨
  let partial_carrier = TextMapCarrier::new()
  TextMapCarrier::set(partial_carrier, "baggage", "key1=value1")
  // æ•…æ„ä¸è®¾ç½®traceparent
  
  let ctx_from_partial = CompositePropagator::extract(composite_propagator, partial_carrier)
  let extracted_from_partial = Context::get(ctx_from_partial, ContextKey::new("extracted"))
  
  assert_eq(extracted_from_partial, Some("true"), "åº”è¯¥èƒ½å¤„ç†éƒ¨åˆ†ç¼ºå¤±çš„å¤´éƒ¨")
  
  // æµ‹è¯•ç©ºè½½ä½“å¤„ç†
  let empty_carrier = TextMapCarrier::new()
  let ctx_from_empty = CompositePropagator::extract(composite_propagator, empty_carrier)
  let extracted_from_empty = Context::get(ctx_from_empty, ContextKey::new("extracted"))
  
  assert_eq(extracted_from_empty, Some("true"), "åº”è¯¥èƒ½å¤„ç†ç©ºè½½ä½“")
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å¤´éƒ¨
  let special_char_carrier = TextMapCarrier::new()
  TextMapCarrier::set(special_char_carrier, "traceparent", "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01")
  TextMapCarrier::set(special_char_carrier, "baggage", "key1=value-with-dashes,key2=value_with_underscores")
  TextMapCarrier::set(special_char_carrier, "x-custom-header", "special!@#$%^&*()chars")
  
  let ctx_from_special = CompositePropagator::extract(composite_propagator, special_char_carrier)
  let extracted_from_special = Context::get(ctx_from_special, ContextKey::new("extracted"))
  
  assert_eq(extracted_from_special, Some("true"), "åº”è¯¥èƒ½å¤„ç†åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å¤´éƒ¨")
}

test "å†…å­˜å’Œèµ„æºè¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å¤§å‹æ•°ç»„å¤„ç†
  let large_string_array = ArrayStringValue([
    "item1", "item2", "item3", "item4", "item5", "item6", "item7", "item8", "item9", "item10",
    "item11", "item12", "item13", "item14", "item15", "item16", "item17", "item18", "item19", "item20"
  ])
  
  let large_int_array = ArrayIntValue([
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
  ])
  
  match large_string_array {
    ArrayStringValue(arr) => {
      assert_eq(arr.length(), 20, "å¤§å‹å­—ç¬¦ä¸²æ•°ç»„é•¿åº¦åº”è¯¥æ­£ç¡®")
      assert_eq(arr[0], "item1", "ç¬¬ä¸€ä¸ªå…ƒç´ åº”è¯¥æ­£ç¡®")
      assert_eq(arr[19], "item20", "æœ€åä¸€ä¸ªå…ƒç´ åº”è¯¥æ­£ç¡®")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²æ•°ç»„å€¼")
  }
  
  match large_int_array {
    ArrayIntValue(arr) => {
      assert_eq(arr.length(), 20, "å¤§å‹æ•´æ•°æ•°ç»„é•¿åº¦åº”è¯¥æ­£ç¡®")
      assert_eq(arr[0], 1, "ç¬¬ä¸€ä¸ªå…ƒç´ åº”è¯¥æ­£ç¡®")
      assert_eq(arr[19], 20, "æœ€åä¸€ä¸ªå…ƒç´ åº”è¯¥æ­£ç¡®")
    }
    _ => assert_true(false, "æœŸæœ›æ•´æ•°æ•°ç»„å€¼")
  }
  
  // æµ‹è¯•å¤§å‹å±æ€§é›†åˆ
  let large_attributes = Attributes::new()
  
  // è®¾ç½®å¤§é‡å±æ€§
  Attributes::set(large_attributes, "attr1", StringValue("value1"))
  Attributes::set(large_attributes, "attr2", IntValue(2))
  Attributes::set(large_attributes, "attr3", FloatValue(3.14))
  Attributes::set(large_attributes, "attr4", BoolValue(true))
  Attributes::set(large_attributes, "attr5", ArrayStringValue(["a", "b", "c"]))
  
  // éªŒè¯å¤§å‹å±æ€§é›†åˆ
  let attr1_result = Attributes::get(large_attributes, "attr1")
  let attr2_result = Attributes::get(large_attributes, "attr2")
  let attr3_result = Attributes::get(large_attributes, "attr3")
  let attr4_result = Attributes::get(large_attributes, "attr4")
  let attr5_result = Attributes::get(large_attributes, "attr5")
  
  match attr1_result {
    Some(StringValue(value)) => assert_eq(value, "value1", "å¤§å‹å±æ€§é›†åˆattr1åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  match attr2_result {
    Some(IntValue(value)) => assert_eq(value, 2, "å¤§å‹å±æ€§é›†åˆattr2åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æ•´æ•°å€¼")
  }
  
  match attr3_result {
    Some(FloatValue(value)) => assert_true(value > 3.1 && value < 3.2, "å¤§å‹å±æ€§é›†åˆattr3åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›æµ®ç‚¹æ•°å€¼")
  }
  
  match attr4_result {
    Some(BoolValue(value)) => assert_true(value, "å¤§å‹å±æ€§é›†åˆattr4åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›å¸ƒå°”å€¼")
  }
  
  match attr5_result {
    Some(ArrayStringValue(arr)) => {
      assert_eq(arr.length(), 3, "å¤§å‹å±æ€§é›†åˆattr5æ•°ç»„é•¿åº¦åº”è¯¥æ­£ç¡®")
      assert_eq(arr[0], "a", "å¤§å‹å±æ€§é›†åˆattr5ç¬¬ä¸€ä¸ªå…ƒç´ åº”è¯¥æ­£ç¡®")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²æ•°ç»„å€¼")
  }
  
  // æµ‹è¯•å¤§å‹èµ„æº
  let large_resource = Resource::new()
  let large_resource_attributes = [
    ("service.name", StringValue("large-test-service")),
    ("service.version", StringValue("1.0.0")),
    ("service.instance.id", StringValue("instance-12345")),
    ("host.name", StringValue("large-test-host")),
    ("environment", StringValue("test")),
    ("region", StringValue("us-west-2")),
    ("zone", StringValue("us-west-2a")),
    ("datacenter", StringValue("dc1")),
    ("rack", StringValue("rack-01")),
    ("server", StringValue("server-001"))
  ]
  let enriched_large_resource = Resource::with_attributes(large_resource, large_resource_attributes)
  
  // éªŒè¯å¤§å‹èµ„æº
  let service_name = Resource::get_attribute(enriched_large_resource, "service.name")
  let server = Resource::get_attribute(enriched_large_resource, "server")
  
  match service_name {
    Some(StringValue(value)) => assert_eq(value, "large-test-service", "å¤§å‹èµ„æºæœåŠ¡åç§°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  match server {
    Some(StringValue(value)) => assert_eq(value, "server-001", "å¤§å‹èµ„æºæœåŠ¡å™¨åç§°åº”è¯¥æ­£ç¡®")
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
}

test "å¹¶å‘å’Œç«äº‰è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å¹¶å‘ä¸Šä¸‹æ–‡æ“ä½œ
  let base_context = Context::root()
  let key1 = ContextKey::new("concurrent.key1")
  let key2 = ContextKey::new("concurrent.key2")
  let key3 = ContextKey::new("concurrent.key3")
  
  // åˆ›å»ºå¤šä¸ªå¹¶å‘ä¸Šä¸‹æ–‡
  let ctx1 = Context::with_value(base_context, key1, "value1")
  let ctx2 = Context::with_value(base_context, key2, "value2")
  let ctx3 = Context::with_value(base_context, key3, "value3")
  
  // éªŒè¯å¹¶å‘ä¸Šä¸‹æ–‡ç‹¬ç«‹æ€§
  let value1 = Context::get(ctx1, key1)
  let value2 = Context::get(ctx2, key2)
  let value3 = Context::get(ctx3, key3)
  
  assert_eq(value1, Some("value1"), "å¹¶å‘ä¸Šä¸‹æ–‡1åº”è¯¥ç‹¬ç«‹")
  assert_eq(value2, Some("value2"), "å¹¶å‘ä¸Šä¸‹æ–‡2åº”è¯¥ç‹¬ç«‹")
  assert_eq(value3, Some("value3"), "å¹¶å‘ä¸Šä¸‹æ–‡3åº”è¯¥ç‹¬ç«‹")
  
  // æµ‹è¯•å¹¶å‘åº¦é‡æ“ä½œ
  let provider = MeterProvider::default()
  let meter1 = MeterProvider::get_meter(provider, "concurrent-service-1")
  let meter2 = MeterProvider::get_meter(provider, "concurrent-service-2")
  let meter3 = MeterProvider::get_meter(provider, "concurrent-service-3")
  
  let counter1 = Meter::create_counter(meter1, "concurrent.requests")
  let counter2 = Meter::create_counter(meter2, "concurrent.requests")
  let counter3 = Meter::create_counter(meter3, "concurrent.requests")
  
  // å¹¶å‘è®°å½•åº¦é‡
  Counter::add(counter1, 10.0)
  Counter::add(counter2, 20.0)
  Counter::add(counter3, 30.0)
  
  // éªŒè¯å¹¶å‘åº¦é‡ç‹¬ç«‹æ€§
  assert_eq(counter1.name, counter2.name, "å¹¶å‘è®¡æ•°å™¨åç§°åº”è¯¥ä¸€è‡´")
  assert_eq(counter2.name, counter3.name, "å¹¶å‘è®¡æ•°å™¨åç§°åº”è¯¥ä¸€è‡´")
  assert_eq(counter1.name, "concurrent.requests", "è®¡æ•°å™¨åç§°åº”è¯¥æ­£ç¡®")
  
  // æµ‹è¯•å¹¶å‘æ—¥å¿—æ“ä½œ
  let logger_provider = LoggerProvider::default()
  let logger1 = LoggerProvider::get_logger(logger_provider, "concurrent-logger-1")
  let logger2 = LoggerProvider::get_logger(logger_provider, "concurrent-logger-2")
  let logger3 = LoggerProvider::get_logger(logger_provider, "concurrent-logger-3")
  
  let timestamp = 1735689600000000000L
  
  let log1 = LogRecord::new_with_context(
    Info, Some("Concurrent log 1"), None,
    Some(timestamp), Some(timestamp),
    Some("trace-1111"), Some("span-1111"),
    Some(ctx1)
  )
  
  let log2 = LogRecord::new_with_context(
    Info, Some("Concurrent log 2"), None,
    Some(timestamp + 1000000L), Some(timestamp + 1000000L),
    Some("trace-2222"), Some("span-2222"),
    Some(ctx2)
  )
  
  let log3 = LogRecord::new_with_context(
    Info, Some("Concurrent log 3"), None,
    Some(timestamp + 2000000L), Some(timestamp + 2000000L),
    Some("trace-3333"), Some("span-3333"),
    Some(ctx3)
  )
  
  // å¹¶å‘å‘é€æ—¥å¿—
  Logger::emit(logger1, log1)
  Logger::emit(logger2, log2)
  Logger::emit(logger3, log3)
  
  // éªŒè¯å¹¶å‘æ—¥å¿—ç‹¬ç«‹æ€§
  assert_eq(LogRecord::trace_id(log1), Some("trace-1111"), "å¹¶å‘æ—¥å¿—1è¿½è¸ªIDåº”è¯¥ç‹¬ç«‹")
  assert_eq(LogRecord::trace_id(log2), Some("trace-2222"), "å¹¶å‘æ—¥å¿—2è¿½è¸ªIDåº”è¯¥ç‹¬ç«‹")
  assert_eq(LogRecord::trace_id(log3), Some("trace-3333"), "å¹¶å‘æ—¥å¿—3è¿½è¸ªIDåº”è¯¥ç‹¬ç«‹")
  
  assert_eq(LogRecord::span_id(log1), Some("span-1111"), "å¹¶å‘æ—¥å¿—1 span IDåº”è¯¥ç‹¬ç«‹")
  assert_eq(LogRecord::span_id(log2), Some("span-2222"), "å¹¶å‘æ—¥å¿—2 span IDåº”è¯¥ç‹¬ç«‹")
  assert_eq(LogRecord::span_id(log3), Some("span-3333"), "å¹¶å‘æ—¥å¿—3 span IDåº”è¯¥ç‹¬ç«‹")
}

test "è¾“å…¥éªŒè¯å’Œæ¸…ç†æµ‹è¯•" {
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²è¾“å…¥
  let special_char_string = StringValue("Special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?")
  match special_char_string {
    StringValue(s) => {
      assert_true(s.contains("!@#$%^&*()"), "ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²åº”è¯¥åŒ…å«ç‰¹æ®Šå­—ç¬¦")
      assert_eq(s.length(), 47, "ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²é•¿åº¦åº”è¯¥æ­£ç¡®")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦ä¸²è¾“å…¥
  let unicode_string = StringValue("Unicode: æµ‹è¯• ğŸš€ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ×¢×‘×¨×™×ª")
  match unicode_string {
    StringValue(s) => {
      assert_true(s.contains("æµ‹è¯•"), "Unicodeå­—ç¬¦ä¸²åº”è¯¥åŒ…å«ä¸­æ–‡")
      assert_true(s.contains("ğŸš€"), "Unicodeå­—ç¬¦ä¸²åº”è¯¥åŒ…å«emoji")
      assert_true(s.contains("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"), "Unicodeå­—ç¬¦ä¸²åº”è¯¥åŒ…å«é˜¿æ‹‰ä¼¯æ–‡")
      assert_true(s.contains("Ñ€ÑƒÑÑĞºĞ¸Ğ¹"), "Unicodeå­—ç¬¦ä¸²åº”è¯¥åŒ…å«ä¿„æ–‡")
      assert_true(s.contains("×¢×‘×¨×™×ª"), "Unicodeå­—ç¬¦ä¸²åº”è¯¥åŒ…å«å¸Œä¼¯æ¥æ–‡")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  // æµ‹è¯•åŒ…å«æ§åˆ¶å­—ç¬¦çš„å­—ç¬¦ä¸²è¾“å…¥
  let control_char_string = StringValue("Control chars: 
	")
  match control_char_string {
    StringValue(s) => {
      assert_true(s.contains("
"), "æ§åˆ¶å­—ç¬¦å­—ç¬¦ä¸²åº”è¯¥åŒ…å«æ¢è¡Œç¬¦")
      assert_true(s.contains("	"), "æ§åˆ¶å­—ç¬¦å­—ç¬¦ä¸²åº”è¯¥åŒ…å«åˆ¶è¡¨ç¬¦")
      assert_true(s.contains(""), "æ§åˆ¶å­—ç¬¦å­—ç¬¦ä¸²åº”è¯¥åŒ…å«å›è½¦ç¬¦")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  // æµ‹è¯•åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²è¾“å…¥
  let whitespace_string = StringValue("   leading and trailing spaces   ")
  match whitespace_string {
    StringValue(s) => {
      assert_true(s.starts_with("   "), "å­—ç¬¦ä¸²åº”è¯¥ä»¥å‰å¯¼ç©ºæ ¼å¼€å§‹")
      assert_true(s.ends_with("   "), "å­—ç¬¦ä¸²åº”è¯¥ä»¥å°¾éšç©ºæ ¼ç»“æŸ")
      assert_eq(s.length(), 35, "åŒ…å«ç©ºæ ¼çš„å­—ç¬¦ä¸²é•¿åº¦åº”è¯¥æ­£ç¡®")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  // æµ‹è¯•åŒ…å«HTML/XMLç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²è¾“å…¥
  let html_string = StringValue("HTML chars: <script>alert('xss')</script> &amp; &lt; &gt; &quot;")
  match html_string {
    StringValue(s) => {
      assert_true(s.contains("<script>"), "HTMLå­—ç¬¦ä¸²åº”è¯¥åŒ…å«scriptæ ‡ç­¾")
      assert_true(s.contains("&amp;"), "HTMLå­—ç¬¦ä¸²åº”è¯¥åŒ…å«HTMLå®ä½“")
      assert_true(s.contains("&lt;"), "HTMLå­—ç¬¦ä¸²åº”è¯¥åŒ…å«å°äºå·å®ä½“")
      assert_true(s.contains("&gt;"), "HTMLå­—ç¬¦ä¸²åº”è¯¥åŒ…å«å¤§äºå·å®ä½“")
      assert_true(s.contains("&quot;"), "HTMLå­—ç¬¦ä¸²åº”è¯¥åŒ…å«å¼•å·å®ä½“")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  // æµ‹è¯•åŒ…å«SQLæ³¨å…¥å°è¯•çš„å­—ç¬¦ä¸²è¾“å…¥
  let sql_injection_string = StringValue("SQL injection: '; DROP TABLE users; --")
  match sql_injection_string {
    StringValue(s) => {
      assert_true(s.contains("DROP TABLE"), "SQLæ³¨å…¥å­—ç¬¦ä¸²åº”è¯¥åŒ…å«æ¶æ„SQL")
      assert_true(s.contains("--"), "SQLæ³¨å…¥å­—ç¬¦ä¸²åº”è¯¥åŒ…å«SQLæ³¨é‡Š")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
  
  // æµ‹è¯•è·¯å¾„éå†æ”»å‡»å­—ç¬¦ä¸²è¾“å…¥
  let path_traversal_string = StringValue("Path traversal: ../../etc/passwd")
  match path_traversal_string {
    StringValue(s) => {
      assert_true(s.contains("../"), "è·¯å¾„éå†å­—ç¬¦ä¸²åº”è¯¥åŒ…å«ç›¸å¯¹è·¯å¾„")
      assert_true(s.contains("etc/passwd"), "è·¯å¾„éå†å­—ç¬¦ä¸²åº”è¯¥åŒ…å«ç³»ç»Ÿæ–‡ä»¶è·¯å¾„")
    }
    _ => assert_true(false, "æœŸæœ›å­—ç¬¦ä¸²å€¼")
  }
}