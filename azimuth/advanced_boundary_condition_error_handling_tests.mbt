// Azimuth Advanced Boundary Condition Error Handling Tests - é«˜çº§è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•
// æµ‹è¯•ç³»ç»Ÿè¾¹ç•Œæ¡ä»¶ã€å¼‚å¸¸å¤„ç†ã€é”™è¯¯æ¢å¤å’Œå®¹é”™æœºåˆ¶

test "ç©ºå€¼å’Œnullè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå€¼å’Œnullå¤„ç†
  let empty_attrs = Attributes::new()
  
  // æµ‹è¯•ç©ºå±æ€§çš„è·å–
  match Attributes::get(empty_attrs, "nonexistent.key") {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²é”®
  match Attributes::get(empty_attrs, "") {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_ctx = Context::root()
  let empty_key = ContextKey::new("")
  
  match Context::get(empty_ctx, empty_key) {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºBaggage
  let empty_baggage = Baggage::new()
  
  match Baggage::get_entry(empty_baggage, "nonexistent") {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºResource
  let empty_resource = Resource::new()
  
  match Resource::get_attribute(empty_resource, "nonexistent") {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºTextMapCarrier
  let empty_carrier = TextMapCarrier::new()
  
  match TextMapCarrier::get(empty_carrier, "nonexistent") {
    None => assert_true(true)
    Some(_) => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºSpanä¸Šä¸‹æ–‡
  let empty_span_ctx = SpanContext::new("", "", false, "")
  assert_false(SpanContext::is_valid(empty_span_ctx))
  assert_false(SpanContext::is_sampled(empty_span_ctx))
  
  // æµ‹è¯•åŒ…å«ç©ºå€¼çš„å±æ€§è®¾ç½®
  let null_test_attrs = Attributes::new()
  Attributes::set(null_test_attrs, "empty.string", StringValue(""))
  Attributes::set(null_test_attrs, "normal.string", StringValue("normal"))
  
  match Attributes::get(null_test_attrs, "empty.string") {
    Some(StringValue("")) => assert_true(true)
    _ => assert_true(false)
  }
  
  match Attributes::get(null_test_attrs, "normal.string") {
    Some(StringValue("normal")) => assert_true(true)
    _ => assert_true(false)
  }
}

test "æå€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æ•°å€¼æå€¼
  let extreme_attrs = Attributes::new()
  
  // æµ‹è¯•æœ€å¤§å’Œæœ€å°æ•´æ•°å€¼
  Attributes::set(extreme_attrs, "max.int", IntValue(2147483647))
  Attributes::set(extreme_attrs, "min.int", IntValue(-2147483648))
  
  match Attributes::get(extreme_attrs, "max.int") {
    Some(IntValue(2147483647)) => assert_true(true)
    _ => assert_true(false)
  }
  
  match Attributes::get(extreme_attrs, "min.int") {
    Some(IntValue(-2147483648)) => assert_true(true)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æµ®ç‚¹æ•°æå€¼
  Attributes::set(extreme_attrs, "max.float", FloatValue(1.7976931348623157e+308))
  Attributes::set(extreme_attrs, "min.float", FloatValue(-1.7976931348623157e+308))
  Attributes::set(extreme_attrs, "zero.float", FloatValue(0.0))
  Attributes::set(extreme_attrs, "tiny.float", FloatValue(1.0e-308))
  
  match Attributes::get(extreme_attrs, "max.float") {
    Some(FloatValue(_)) => assert_true(true)
    _ => assert_true(false)
  }
  
  match Attributes::get(extreme_attrs, "min.float") {
    Some(FloatValue(_)) => assert_true(true)
    _ => assert_true(false)
  }
  
  match Attributes::get(extreme_attrs, "zero.float") {
    Some(FloatValue(0.0)) => assert_true(true)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•å¸ƒå°”å€¼è¾¹ç•Œ
  Attributes::set(extreme_attrs, "true.value", BoolValue(true))
  Attributes::set(extreme_attrs, "false.value", BoolValue(false))
  
  match Attributes::get(extreme_attrs, "true.value") {
    Some(BoolValue(true)) => assert_true(true)
    _ => assert_true(false)
  }
  
  match Attributes::get(extreme_attrs, "false.value") {
    Some(BoolValue(false)) => assert_true(true)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ•°ç»„æå€¼
  let empty_array : Array[String] = []
  let large_array = []
  for i in 0..=999 {
    large_array.push("item_" + i.to_string())
  }
  
  Attributes::set(extreme_attrs, "empty.array", ArrayStringValue(empty_array))
  Attributes::set(extreme_attrs, "large.array", ArrayStringValue(large_array))
  
  match Attributes::get(extreme_attrs, "empty.array") {
    Some(ArrayStringValue(arr)) => assert_true(arr.length() == 0)
    _ => assert_true(false)
  }
  
  match Attributes::get(extreme_attrs, "large.array") {
    Some(ArrayStringValue(arr)) => assert_true(arr.length() == 1000)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•æ—¶é—´æˆ³æå€¼
  let zero_timestamp = 0L
  let max_timestamp = 9223372036854775807L  // Int64æœ€å¤§å€¼
  let current_timestamp = Clock::now_unix_nanos(Clock::system())
  
  assert_true(zero_timestamp < current_timestamp)
  assert_true(current_timestamp < max_timestamp)
  
  // æµ‹è¯•Spanä¸Šä¸‹æ–‡æå€¼
  let max_trace_id = "ffffffffffffffffffffffffffffffff"
  let max_span_id = "ffffffffffffffff"
  let min_trace_id = "00000000000000000000000000000000"
  let min_span_id = "0000000000000000"
  
  let max_span_ctx = SpanContext::new(max_trace_id, max_span_id, true, "")
  let min_span_ctx = SpanContext::new(min_trace_id, min_span_id, false, "")
  
  assert_true(SpanContext::is_valid(max_span_ctx))
  assert_true(SpanContext::is_sampled(max_span_ctx))
  assert_true(SpanContext::is_valid(min_span_ctx))
  assert_false(SpanContext::is_sampled(min_span_ctx))
}

test "å­—ç¬¦ä¸²é•¿åº¦å’Œç‰¹æ®Šå­—ç¬¦è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²
  let very_long_string = "a".repeat(10000)  // 10Kå­—ç¬¦
  let extremely_long_string = "x".repeat(100000)  // 100Kå­—ç¬¦
  
  let string_length_attrs = Attributes::new()
  Attributes::set(string_length_attrs, "very.long", StringValue(very_long_string))
  Attributes::set(string_length_attrs, "extremely.long", StringValue(extremely_long_string))
  
  match Attributes::get(string_length_attrs, "very.long") {
    Some(StringValue(value)) => assert_true(value.length() == 10000)
    _ => assert_true(false)
  }
  
  match Attributes::get(string_length_attrs, "extremely.long") {
    Some(StringValue(value)) => assert_true(value.length() == 100000)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = [
    "",  // ç©ºå­—ç¬¦ä¸²
    " ",  // ç©ºæ ¼
    "\t",  // åˆ¶è¡¨ç¬¦
    "\n",  // æ¢è¡Œç¬¦
    "\r",  // å›è½¦ç¬¦
    "\\",  // åæ–œæ 
    "/",   // æ­£æ–œæ 
    "\"",  // åŒå¼•å·
    "'",   // å•å¼•å·
    "`",   // åå¼•å·
    "~",   // æ³¢æµªå·
    "!",   // æ„Ÿå¹å·
    "@",   // atç¬¦å·
    "#",   // äº•å·
    "$",   // ç¾å…ƒç¬¦å·
    "%",   // ç™¾åˆ†å·
    "^",   // è„±å­—ç¬¦
    "&",   // å’Œå·
    "*",   // æ˜Ÿå·
    "(",   // å·¦æ‹¬å·
    ")",   // å³æ‹¬å·
    "-",   // å‡å·
    "_",   // ä¸‹åˆ’çº¿
    "+",   // åŠ å·
    "=",   // ç­‰å·
    "{",   // å·¦èŠ±æ‹¬å·
    "}",   // å³èŠ±æ‹¬å·
    "[",   // å·¦æ–¹æ‹¬å·
    "]",   // å³æ–¹æ‹¬å·
    "|",   // ç«–çº¿
    ":",   // å†’å·
    ";",   // åˆ†å·
    ",",   // é€—å·
    ".",   // ç‚¹å·
    "<",   // å°äºå·
    ">",   // å¤§äºå·
    "?"    // é—®å·
  ]
  
  let special_char_attrs = Attributes::new()
  for i in 0..=special_chars.length() - 1 {
    let char = special_chars[i]
    Attributes::set(special_char_attrs, "special.char." + i.to_string(), StringValue(char))
  }
  
  // éªŒè¯ç‰¹æ®Šå­—ç¬¦å¤„ç†
  for i in 0..=special_chars.length() - 1 {
    let key = "special.char." + i.to_string()
    let expected_char = special_chars[i]
    
    match Attributes::get(special_char_attrs, key) {
      Some(StringValue(value)) => assert_eq(value, expected_char)
      _ => assert_true(false)
    }
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_chars = [
    "æµ‹è¯•ä¸­æ–‡",  // ä¸­æ–‡
    "æ—¥æœ¬èª",    // æ—¥æ–‡
    "í•œêµ­ì–´",    // éŸ©æ–‡
    "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©",  // é˜¿æ‹‰ä¼¯æ–‡
    "×¢×‘×¨×™×ª",    // å¸Œä¼¯æ¥æ–‡
    "Ğ ÑƒÑÑĞºĞ¸Ğ¹",  // ä¿„æ–‡
    "EspaÃ±ol",  // è¥¿ç­ç‰™æ–‡
    "FranÃ§ais", // æ³•æ–‡
    "ğŸš€ğŸŒŸğŸ’«",   // Emoji
    "â™ â™¥â™¦â™£",    // æ‰‘å…‹ç‰ŒèŠ±è‰²
    "Î±Î²Î³Î´Îµ",    // å¸Œè…Šå­—æ¯
    "â†â†’â†‘â†“"     // ç®­å¤´
  ]
  
  let unicode_attrs = Attributes::new()
  for i in 0..=unicode_chars.length() - 1 {
    let unicode_char = unicode_chars[i]
    Attributes::set(unicode_attrs, "unicode." + i.to_string(), StringValue(unicode_char))
  }
  
  // éªŒè¯Unicodeå­—ç¬¦å¤„ç†
  for i in 0..=unicode_chars.length() - 1 {
    let key = "unicode." + i.to_string()
    let expected_unicode = unicode_chars[i]
    
    match Attributes::get(unicode_attrs, key) {
      Some(StringValue(value)) => assert_eq(value, expected_unicode)
      _ => assert_true(false)
    }
  }
}

test "é”™è¯¯æ¢å¤å’Œå®¹é”™æœºåˆ¶æµ‹è¯•" {
  // æµ‹è¯•Spanåˆ›å»ºé”™è¯¯æ¢å¤
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error-recovery-test")
  
  // æµ‹è¯•ç©ºåç§°Span
  let empty_name_span = Tracer::start_span(tracer, "")
  assert_eq(Span::name(empty_name_span), "")
  
  // æµ‹è¯•æé•¿åç§°Span
  let long_span_name = "this.is.a.very.long.span.name.that.tests.the.error.recovery.mechanisms".repeat(10)
  let long_name_span = Tracer::start_span(tracer, long_span_name)
  assert_eq(Span::name(long_name_span), long_span_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°Span
  let special_char_span = Tracer::start_span(tracer, "æµ‹è¯•/Span@Name#$%")
  assert_eq(Span::name(special_char_span), "æµ‹è¯•/Span@Name#$%")
  
  // æµ‹è¯•åº¦é‡åˆ›å»ºé”™è¯¯æ¢å¤
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "error-recovery-metrics")
  
  // æµ‹è¯•ç©ºåç§°åº¦é‡
  let empty_counter = Meter::create_counter(meter, "")
  assert_eq(empty_counter.name, "")
  
  // æµ‹è¯•æé•¿åç§°åº¦é‡
  let long_metric_name = "this.is.a.very.long.metric.name.that.tests.error.recovery".repeat(5)
  let long_counter = Meter::create_counter(meter, long_metric_name)
  assert_eq(long_counter.name, long_metric_name)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦åç§°åº¦é‡
  let special_char_counter = Meter::create_counter(meter, "æµ‹è¯•/Metric@Name#$%")
  assert_eq(special_char_counter.name, "æµ‹è¯•/Metric@Name#$%")
  
  // æµ‹è¯•æ—¥å¿—è®°å½•é”™è¯¯æ¢å¤
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "error-recovery-logger")
  
  // æµ‹è¯•ç©ºæ¶ˆæ¯æ—¥å¿—
  let empty_log = LogRecord::new(Info, "")
  assert_eq(LogRecord::body(empty_log), Some(""))
  
  // æµ‹è¯•æé•¿æ¶ˆæ¯æ—¥å¿—
  let long_log_message = "This is a very long log message that tests error recovery mechanisms".repeat(20)
  let long_log = LogRecord::new(Error, long_log_message)
  assert_eq(LogRecord::body(long_log), Some(long_log_message))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦æ¶ˆæ¯æ—¥å¿—
  let special_char_log = LogRecord::new(Warn, "æµ‹è¯•/Log@Message#$%")
  assert_eq(LogRecord::body(special_char_log), Some("æµ‹è¯•/Log@Message#$%"))
  
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¼ æ’­é”™è¯¯æ¢å¤
  let error_propagator = CompositePropagator::new([])
  let error_ctx = Context::with_value(Context::root(), ContextKey::new("error.test"), "value")
  let error_carrier = TextMapCarrier::new()
  
  // å³ä½¿ä¼ æ’­å™¨ä¸ºç©ºï¼Œä¹Ÿåº”è¯¥èƒ½ä¼˜é›…å¤„ç†
  CompositePropagator::inject(error_propagator, error_ctx, error_carrier)
  let extracted_error_ctx = CompositePropagator::extract(error_propagator, error_carrier)
  
  // éªŒè¯é”™è¯¯æ¢å¤
  assert_true(true)  // å¦‚æœæ²¡æœ‰å´©æºƒï¼Œè¯´æ˜é”™è¯¯æ¢å¤æˆåŠŸ
}

test "å¹¶å‘é”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•å¹¶å‘ç¯å¢ƒä¸‹çš„é”™è¯¯å¤„ç†
  let concurrent_tracer = TracerProvider::get_tracer(TracerProvider::default(), "concurrent-error-test")
  let concurrent_meter = MeterProvider::get_meter(MeterProvider::default(), "concurrent-error-metrics")
  let concurrent_logger = LoggerProvider::get_logger(LoggerProvider::default(), "concurrent-error-logger")
  
  // å¹¶å‘åˆ›å»ºå¯èƒ½å‡ºé”™çš„å¯¹è±¡
  let concurrent_spans = []
  let concurrent_counters = []
  let concurrent_logs = []
  
  for i in 0..=49 {
    // åˆ›å»ºå¯èƒ½åŒ…å«é”™è¯¯çš„Span
    let span_name = if i % 10 == 0 { "" } else { "concurrent-span-" + i.to_string() }
    let span = Tracer::start_span(concurrent_tracer, span_name)
    concurrent_spans.push(span)
    
    // åˆ›å»ºå¯èƒ½åŒ…å«é”™è¯¯çš„åº¦é‡
    let counter_name = if i % 15 == 0 { "" } else { "concurrent-counter-" + i.to_string() }
    let counter = Meter::create_counter(concurrent_meter, counter_name)
    concurrent_counters.push(counter)
    
    // åˆ›å»ºå¯èƒ½åŒ…å«é”™è¯¯çš„æ—¥å¿—
    let log_message = if i % 20 == 0 { "" } else { "concurrent-log-" + i.to_string() }
    let log = LogRecord::new(Info, log_message)
    concurrent_logs.push(log)
  }
  
  // å¹¶å‘æ“ä½œè¿™äº›å¯¹è±¡
  for i in 0..=concurrent_spans.length() - 1 {
    let span = concurrent_spans[i]
    Span::add_event(span, "concurrent.event")
    Span::set_status(span, Ok)
    Span::end(span)
  }
  
  for i in 0..=concurrent_counters.length() - 1 {
    let counter = concurrent_counters[i]
    Counter::add(counter, 1.0)
  }
  
  for i in 0..=concurrent_logs.length() - 1 {
    let log = concurrent_logs[i]
    Logger::emit(concurrent_logger, log)
  }
  
  // éªŒè¯å¹¶å‘é”™è¯¯å¤„ç†
  assert_true(concurrent_spans.length() == 50)
  assert_true(concurrent_counters.length() == 50)
  assert_true(concurrent_logs.length() == 50)
  
  // éªŒè¯ç©ºåç§°å¯¹è±¡çš„å¤„ç†
  assert_eq(Span::name(concurrent_spans[0]), "")
  assert_eq(concurrent_counters[0].name, "")
  assert_eq(LogRecord::body(concurrent_logs[0]), Some(""))
}

test "èµ„æºè€—å°½å’Œå†…å­˜å‹åŠ›æµ‹è¯•" {
  // æµ‹è¯•èµ„æºè€—å°½æƒ…å†µä¸‹çš„å¤„ç†
  let resource_test_start = Clock::now_unix_nanos(Clock::system())
  
  // åˆ›å»ºå¤§é‡å¯¹è±¡æµ‹è¯•å†…å­˜å‹åŠ›
  let memory_pressure_attrs = []
  let memory_pressure_spans = []
  let memory_pressure_metrics = []
  
  // åˆ›å»ºå¤§é‡å±æ€§å¯¹è±¡
  for i in 0..=99 {
    let attrs = Attributes::new()
    for j in 0..=9 {
      Attributes::set(attrs, "attr." + j.to_string(), StringValue("value_" + i.to_string() + "_" + j.to_string()))
    }
    memory_pressure_attrs.push(attrs)
  }
  
  // åˆ›å»ºå¤§é‡Span
  let memory_tracer = TracerProvider::get_tracer(TracerProvider::default(), "memory-pressure-test")
  for i in 0..=99 {
    let span = Tracer::start_span(memory_tracer, "memory-pressure-span-" + i.to_string())
    for j in 0..=9 {
      Span::add_event(span, "event-" + j.to_string())
    }
    memory_pressure_spans.push(span)
  }
  
  // åˆ›å»ºå¤§é‡åº¦é‡
  let memory_meter = MeterProvider::get_meter(MeterProvider::default(), "memory-pressure-metrics")
  for i in 0..=99 {
    let counter = Meter::create_counter(memory_meter, "memory-pressure-counter-" + i.to_string())
    for j in 0..=9 {
      Counter::add(counter, j.to_double())
    }
    memory_pressure_metrics.push(counter)
  }
  
  let resource_test_end = Clock::now_unix_nanos(Clock::system())
  let resource_test_duration = resource_test_end - resource_test_start
  
  // éªŒè¯èµ„æºå‹åŠ›æµ‹è¯•ç»“æœ
  assert_true(memory_pressure_attrs.length() == 100)
  assert_true(memory_pressure_spans.length() == 100)
  assert_true(memory_pressure_metrics.length() == 100)
  assert_true(resource_test_duration < 30000000000L)  // å°äº30ç§’
  
  // æµ‹è¯•èµ„æºæ¸…ç†
  for span in memory_pressure_spans {
    Span::end(span)
  }
  
  // éªŒè¯æ¸…ç†åçš„çŠ¶æ€
  for span in memory_pressure_spans {
    assert_true(true)  // å¦‚æœèƒ½è®¿é—®æ‰€æœ‰Spanï¼Œè¯´æ˜æ²¡æœ‰å†…å­˜æ³„æ¼
  }
}

test "ç½‘ç»œå’ŒIOé”™è¯¯å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•HTTPå®¢æˆ·ç«¯é”™è¯¯å¤„ç†
  let http_client = HttpClient::new()
  
  // æµ‹è¯•æ— æ•ˆURL
  let invalid_url_request = HttpRequest::new(
    "GET",
    "invalid-url",
    [("Content-Type", "application/json")],
    { body: "{\"test\": \"data\"}" }
  )
  
  assert_eq(HttpRequest::http_method(invalid_url_request), "GET")
  assert_eq(HttpRequest::url(invalid_url_request), "invalid-url")
  assert_eq(HttpRequest::body(invalid_url_request), Some("{\"test\": \"data\"}"))
  
  // æµ‹è¯•ç©ºURL
  let empty_url_request = HttpRequest::new(
    "POST",
    "",
    [],
    { body: "empty url test" }
  )
  
  assert_eq(HttpRequest::url(empty_url_request), "")
  
  // æµ‹è¯•æé•¿URL
  let long_url = "https://example.com/" + "path".repeat(1000)
  let long_url_request = HttpRequest::new("GET", long_url, [])
  
  assert_eq(HttpRequest::url(long_url_request), long_url)
  
  // æµ‹è¯•HTTPå“åº”é”™è¯¯å¤„ç†
  let error_response = HttpResponse::new(500, [("Content-Type", "text/plain")], { body: "Internal Server Error" })
  
  assert_eq(HttpResponse::status_code(error_response), 500)
  assert_eq(HttpResponse::body(error_response), Some("Internal Server Error"))
  
  // æµ‹è¯•ç©ºå“åº”
  let empty_response = HttpResponse::new(200, [], { body: "" })
  
  assert_eq(HttpResponse::status_code(empty_response), 200)
  assert_eq(HttpResponse::body(empty_response), Some(""))
  
  // æµ‹è¯•TextMapCarrieré”™è¯¯å¤„ç†
  let error_carrier = TextMapCarrier::new()
  
  // æµ‹è¯•ç©ºé”®å€¼å¯¹
  TextMapCarrier::set(error_carrier, "", "")
  TextMapCarrier::set(error_carrier, "key", "")
  TextMapCarrier::set(error_carrier, "", "value")
  
  match TextMapCarrier::get(error_carrier, "") {
    Some(_) => assert_true(true)  // åº”è¯¥èƒ½å¤„ç†ç©ºé”®
    None => assert_true(true)     // æˆ–è€…è¿”å›Noneä¹Ÿæ˜¯åˆç†çš„
  }
  
  match TextMapCarrier::get(error_carrier, "key") {
    Some("") => assert_true(true)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦é”®å€¼å¯¹
  TextMapCarrier::set(error_carrier, "æµ‹è¯•/key", "æµ‹è¯•/value")
  TextMapCarrier::set(error_carrier, "special@chars", "!@#$%^&*()")
  
  match TextMapCarrier::get(error_carrier, "æµ‹è¯•/key") {
    Some("æµ‹è¯•/value") => assert_true(true)
    _ => assert_true(false)
  }
  
  match TextMapCarrier::get(error_carrier, "special@chars") {
    Some("!@#$%^&*()") => assert_true(true)
    _ => assert_true(false)
  }
}