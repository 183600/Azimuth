// é«˜çº§ MoonBit æµ‹è¯•ç”¨ä¾‹ - ä¸“æ³¨äºæ€§èƒ½ã€è¾¹ç•Œæ¡ä»¶å’Œå¤æ‚åœºæ™¯
// è¿™äº›æµ‹è¯•ç”¨ä¾‹è¡¥å……ç°æœ‰çš„åŸºç¡€æµ‹è¯•ï¼Œæä¾›æ›´å…¨é¢çš„è¦†ç›–

test "performance_efficiency_validation" {
  // æ€§èƒ½æ•ˆç‡éªŒè¯æµ‹è¯•
  // æµ‹è¯•å¤§è§„æ¨¡æ•°æ®å¤„ç†çš„æ•ˆç‡
  let large_dataset_size = 100000
  
  // æµ‹è¯•çº¿æ€§è¿ç®—æ€§èƒ½
  let start_value = 1
  let increment = 2
  let final_value = add(start_value, multiply(large_dataset_size, increment))
  
  // éªŒè¯è®¡ç®—ç»“æœçš„æ­£ç¡®æ€§
  assert_eq(200001, final_value)  // 1 + 100000 * 2 = 200001
  
  // æµ‹è¯•é™¤æ³•è¿ç®—åœ¨å¤§æ•°æƒ…å†µä¸‹çš„æ€§èƒ½
  let division_result = divide_with_ceil(final_value, 1000)
  assert_eq(201, division_result)  // ceil(200001/1000) = 201
}

test "numerical_stability_edge_cases" {
  // æ•°å€¼ç¨³å®šæ€§è¾¹ç¼˜æƒ…å†µæµ‹è¯•
  // æµ‹è¯•æå€¼è¿ç®—çš„ç¨³å®šæ€§
  
  // æ¥è¿‘æ•´æ•°æº¢å‡ºçš„æƒ…å†µ
  let near_max_int = 2147483640
  let safe_increment = 5
  let result = add(near_max_int, safe_increment)
  
  // éªŒè¯åŠ æ³•åœ¨æå€¼æƒ…å†µä¸‹çš„ç¨³å®šæ€§
  assert_eq(2147483645, result)
  
  // æµ‹è¯•è´Ÿæå€¼çš„ç¨³å®šæ€§
  let near_min_int = -2147483640
  let negative_result = add(near_min_int, multiply(-1, safe_increment))
  assert_eq(-2147483645, negative_result)
  
  // æµ‹è¯•é™¤æ³•åœ¨æå€¼æƒ…å†µä¸‹çš„è¡Œä¸º
  let extreme_division = divide_with_ceil(near_max_int, 1000000)
  assert_eq(2148, extreme_division)  // ceil(2147483640/1000000) = 2148
}

test "algorithm_complexity_verification" {
  // ç®—æ³•å¤æ‚åº¦éªŒè¯æµ‹è¯•
  // éªŒè¯ä¸åŒç®—æ³•è·¯å¾„çš„å¤æ‚åº¦ç‰¹å¾
  
  let problem_sizes = [10, 100, 1000, 10000]
  
  // æ¨¡æ‹ŸO(1)ç®—æ³• - å¸¸æ•°æ—¶é—´
  let constant_10 = divide_with_ceil(problem_sizes[0], 1)
  let constant_100 = divide_with_ceil(problem_sizes[1], 1)
  let constant_1000 = divide_with_ceil(problem_sizes[2], 1)
  let constant_10000 = divide_with_ceil(problem_sizes[3], 1)
  
  // æ¨¡æ‹ŸO(n)ç®—æ³• - çº¿æ€§æ—¶é—´
  let linear_10 = multiply(problem_sizes[0], 2)
  let linear_100 = multiply(problem_sizes[1], 2)
  let linear_1000 = multiply(problem_sizes[2], 2)
  let linear_10000 = multiply(problem_sizes[3], 2)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³• - å¯¹æ•°æ—¶é—´
  let log_10 = divide_with_ceil(problem_sizes[0], 3)
  let log_100 = divide_with_ceil(problem_sizes[1], 3)
  let log_1000 = divide_with_ceil(problem_sizes[2], 3)
  let log_10000 = divide_with_ceil(problem_sizes[3], 3)
  
  // éªŒè¯å¤æ‚åº¦ç‰¹å¾
  assert_eq(10, constant_10)
  assert_eq(100, constant_100)
  assert_eq(1000, constant_1000)
  assert_eq(10000, constant_10000)
  
  assert_eq(20, linear_10)
  assert_eq(200, linear_100)
  assert_eq(2000, linear_1000)
  assert_eq(20000, linear_10000)
  
  assert_eq(4, log_10)
  assert_eq(34, log_100)
  assert_eq(334, log_1000)
  assert_eq(3334, log_10000)
}

test "business_domain_specific_calculations" {
  // ä¸šåŠ¡é¢†åŸŸç‰¹å®šè®¡ç®—æµ‹è¯•
  // åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†å’Œåº“å­˜ç®¡ç†
  
  // è®¢å•å¤„ç†åœºæ™¯
  let order_items = [
    (5, 12),   // (å•†å“æ•°é‡, æ¯ç®±å®¹é‡)
    (8, 6),
    (15, 20),
    (3, 4),
    (22, 10)
  ]
  
  // è®¡ç®—æ¯ç§å•†å“éœ€è¦çš„åŒ…è£…ç®±æ•°é‡
  let boxes_1 = divide_with_ceil(order_items[0].0, order_items[0].1)  // ceil(5/12) = 1
  let boxes_2 = divide_with_ceil(order_items[1].0, order_items[1].1)  // ceil(8/6) = 2
  let boxes_3 = divide_with_ceil(order_items[2].0, order_items[2].1)  // ceil(15/20) = 1
  let boxes_4 = divide_with_ceil(order_items[3].0, order_items[3].1)  // ceil(3/4) = 1
  let boxes_5 = divide_with_ceil(order_items[4].0, order_items[4].1)  // ceil(22/10) = 3
  
  // è®¡ç®—æ€»ç®±æ•°
  let total_boxes = add(add(add(boxes_1, boxes_2), add(boxes_3, boxes_4)), boxes_5)
  assert_eq(8, total_boxes)
  
  // è®¡ç®—æ€»å•†å“æ•°é‡
  let total_items = add(add(add(order_items[0].0, order_items[1].0), 
                             add(order_items[2].0, order_items[3].0)), order_items[4].0)
  assert_eq(53, total_items)
  
  // è®¡ç®—å¹³å‡æ¯ç®±å•†å“æ•°
  let avg_items_per_box = divide_with_ceil(total_items, total_boxes)
  assert_eq(7, avg_items_per_box)  // ceil(53/8) = 7
}

test "function_composition_and_chaining" {
  // å‡½æ•°ç»„åˆå’Œé“¾å¼è°ƒç”¨æµ‹è¯•
  // æµ‹è¯•å¤æ‚å‡½æ•°ç»„åˆçš„æ­£ç¡®æ€§
  
  let initial_value = 10
  
  // é“¾å¼è®¡ç®—ï¼š((x * 2) + 5) / 3) * 4 - 2
  let step1 = multiply(initial_value, 2)        // 20
  let step2 = add(step1, 5)                      // 25
  let step3 = divide_with_ceil(step2, 3)         // 9
  let step4 = multiply(step3, 4)                 // 36
  let step5 = add(step4, multiply(-1, 2))        // 34
  
  assert_eq(34, step5)
  
  // åµŒå¥—å‡½æ•°ç»„åˆ
  let nested_result = divide_with_ceil(
    add(
      multiply(initial_value, 3),
      multiply(initial_value, 2)
    ),
    add(initial_value, divide_with_ceil(initial_value, 2))
  )
  
  // æ‰‹åŠ¨è®¡ç®—éªŒè¯ï¼š(10*3 + 10*2) / (10 + ceil(10/2)) = 50 / 15 = ceil(3.33) = 4
  assert_eq(4, nested_result)
}

test "resource_utilization_optimization" {
  // èµ„æºåˆ©ç”¨ä¼˜åŒ–æµ‹è¯•
  // åœºæ™¯ï¼šæœåŠ¡å™¨é›†ç¾¤èµ„æºåˆ†é…ä¼˜åŒ–
  
  let total_memory_gb = 1024
  let total_cpu_cores = 64
  let total_storage_tb = 100
  let num_services = 8
  
  // è®¡ç®—æ¯ä¸ªæœåŠ¡çš„èµ„æºåˆ†é…
  let memory_per_service = divide_with_ceil(total_memory_gb, num_services)
  let cpu_per_service = divide_with_ceil(total_cpu_cores, num_services)
  let storage_per_service = divide_with_ceil(total_storage_tb, num_services)
  
  assert_eq(128, memory_per_service)   // ceil(1024/8) = 128
  assert_eq(8, cpu_per_service)        // ceil(64/8) = 8
  assert_eq(13, storage_per_service)   // ceil(100/8) = 13
  
  // è®¡ç®—å®é™…åˆ†é…çš„æ€»èµ„æº
  let actual_memory = multiply(memory_per_service, num_services)
  let actual_cpu = multiply(cpu_per_service, num_services)
  let actual_storage = multiply(storage_per_service, num_services)
  
  assert_eq(1024, actual_memory)
  assert_eq(64, actual_cpu)
  assert_eq(104, actual_storage)
  
  // è®¡ç®—èµ„æºæµªè´¹
  let memory_waste = subtract(actual_memory, total_memory_gb)
  let cpu_waste = subtract(actual_cpu, total_cpu_cores)
  let storage_waste = subtract(actual_storage, total_storage_tb)
  
  assert_eq(0, memory_waste)
  assert_eq(0, cpu_waste)
  assert_eq(4, storage_waste)
}

test "internationalization_and_localization" {
  // å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•
  // æµ‹è¯•ä¸åŒè¯­è¨€å’Œåœ°åŒºçš„å­—ç¬¦ä¸²å¤„ç†
  
  // æµ‹è¯•å¤šç§è¯­è¨€çš„é—®å€™
  assert_eq_string("Hello, ä¸­æ–‡!", greet("ä¸­æ–‡"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, í•œêµ­ì–´!", greet("í•œêµ­ì–´"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, ×¢×‘×¨×™×ª!", greet("×¢×‘×¨×™×ª"))
  assert_eq_string("Hello, à¤¹à¤¿à¤¨à¥à¤¦à¥€!", greet("à¤¹à¤¿à¤¨à¥à¤¦à¥€"))
  
  // æµ‹è¯•å¤åˆUnicodeå­—ç¬¦
  assert_eq_string("Hello, ğŸ‡ºğŸ‡¸!", greet("ğŸ‡ºğŸ‡¸"))
  assert_eq_string("Hello, ğŸ‡¨ğŸ‡³!", greet("ğŸ‡¨ğŸ‡³"))
  assert_eq_string("Hello, ğŸ‡¯ğŸ‡µ!", greet("ğŸ‡¯ğŸ‡µ"))
  
  // æµ‹è¯•ä»å³åˆ°å·¦çš„æ–‡å­—
  assert_eq_string("Hello, ×©×œ×•×!", greet("×©×œ×•×"))
  assert_eq_string("Hello, Ù…Ø±Ø­Ø¨Ø§!", greet("Ù…Ø±Ø­Ø¨Ø§"))
  
  // æµ‹è¯•ç‰¹æ®ŠUnicodeç»„åˆ
  assert_eq_string("Hello, Ã©!", greet("Ã©"))  // ç»„åˆå­—ç¬¦
  assert_eq_string("Hello, ğŸ§‘â€ğŸ’»!", greet("ğŸ§‘â€ğŸ’»"))  // ZWJåºåˆ—
}

test "data_structure_simulation" {
  // æ•°æ®ç»“æ„æ¨¡æ‹Ÿæµ‹è¯•
  // ä½¿ç”¨åŸºç¡€å‡½æ•°æ¨¡æ‹Ÿå¤æ‚æ•°æ®ç»“æ„æ“ä½œ
  
  // æ¨¡æ‹Ÿæ ˆæ“ä½œ
  let stack_capacity = 10
  let stack_items = 7
  
  // å…¥æ ˆæ“ä½œ
  let after_push = add(stack_items, 1)
  assert_eq(8, after_push)
  
  // æ£€æŸ¥æ ˆæ˜¯å¦å·²æ»¡
  let is_full = after_push >= stack_capacity
  assert_false(is_full)
  
  // å‡ºæ ˆæ“ä½œ
  let after_pop = subtract(after_push, 1)
  assert_eq(7, after_pop)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œ
  let queue_size = 15
  let queue_head = 3
  let queue_tail = 12
  
  // è®¡ç®—é˜Ÿåˆ—ä¸­å…ƒç´ æ•°é‡
  let queue_count = subtract(queue_tail, queue_head)
  assert_eq(9, queue_count)
  
  // æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
  let is_empty = queue_count <= 0
  assert_false(is_empty)
  
  // è®¡ç®—å‰©ä½™ç©ºé—´
  let remaining_space = subtract(queue_size, queue_count)
  assert_eq(6, remaining_space)
}

test "security_input_validation" {
  // å®‰å…¨è¾“å…¥éªŒè¯æµ‹è¯•
  // æµ‹è¯•å„ç§æ½œåœ¨æ¶æ„è¾“å…¥çš„å¤„ç†
  
  // æµ‹è¯•ç©ºå€¼å’Œç‰¹æ®Šå­—ç¬¦ä¸²
  assert_eq_string("Hello, null!", greet("null"))
  assert_eq_string("Hello, undefined!", greet("undefined"))
  assert_eq_string("Hello, NaN!", greet("NaN"))
  assert_eq_string("Hello, Infinity!", greet("Infinity"))
  
  // æµ‹è¯•åŒ…å«è„šæœ¬æ ‡ç­¾çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, <script>!", greet("<script>"))
  assert_eq_string("Hello, </script>!", greet("</script>"))
  assert_eq_string("Hello, javascript:!", greet("javascript:"))
  
  // æµ‹è¯•SQLæ³¨å…¥ç›¸å…³å­—ç¬¦ä¸²
  assert_eq_string("Hello, ' OR 1=1--!", greet("' OR 1=1--"))
  assert_eq_string("Hello, DROP TABLE!", greet("DROP TABLE"))
  
  // æµ‹è¯•è·¯å¾„éå†å­—ç¬¦ä¸²
  assert_eq_string("Hello, ../../etc/passwd!", greet("../../etc/passwd"))
  assert_eq_string("Hello, ..\\..\\windows\\system32!", greet("..\\..\\windows\\system32"))
  
  // éªŒè¯å‡½æ•°åœ¨å¤„ç†è¿™äº›è¾“å…¥æ—¶ä¸ä¼šå´©æºƒ
  let safe_result = add(1, 1)  // ç¡®ä¿å‡½æ•°ä»ç„¶æ­£å¸¸å·¥ä½œ
  assert_eq(2, safe_result)
}

test "accessibility_compatibility" {
  // å¯è®¿é—®æ€§å…¼å®¹æ€§æµ‹è¯•
  // æµ‹è¯•ä¸è¾…åŠ©æŠ€æœ¯çš„å…¼å®¹æ€§
  
  // æµ‹è¯•å±å¹•é˜…è¯»å™¨å‹å¥½çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, button: submit!", greet("button: submit"))
  assert_eq_string("Hello, link: homepage!", greet("link: homepage"))
  assert_eq_string("Hello, heading: main title!", greet("heading: main title"))
  
  // æµ‹è¯•ARIAæ ‡ç­¾ç›¸å…³å­—ç¬¦ä¸²
  assert_eq_string("Hello, aria-label: close dialog!", greet("aria-label: close dialog"))
  assert_eq_string("Hello, role: navigation!", greet("role: navigation"))
  
  // æµ‹è¯•é«˜å¯¹æ¯”åº¦æ¨¡å¼ä¸‹çš„å­—ç¬¦
  assert_eq_string("Hello, âš ï¸ warning!", greet("âš ï¸ warning"))
  assert_eq_string("Hello, âœ… success!", greet("âœ… success"))
  assert_eq_string("Hello, âŒ error!", greet("âŒ error"))
  
  // æµ‹è¯•é”®ç›˜å¯¼èˆªç›¸å…³å­—ç¬¦ä¸²
  assert_eq_string("Hello, tab: next!", greet("tab: next"))
  assert_eq_string("Hello, enter: activate!", greet("enter: activate"))
  assert_eq_string("Hello, escape: close!", greet("escape: close"))
  
  // éªŒè¯æ ¸å¿ƒåŠŸèƒ½åœ¨å¯è®¿é—®æ€§æµ‹è¯•åä»ç„¶æ­£å¸¸
  let accessibility_check = multiply(5, 4)
  assert_eq(20, accessibility_check)
}

// è¾…åŠ©å‡½æ•°ï¼šå‡æ³•
fn subtract(a : Int, b : Int) -> Int {
  a - b
}