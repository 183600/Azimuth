// Enhanced Attribute Type Conversion and Boundary Tests
// æµ‹è¯•å±æ€§ç±»å‹è½¬æ¢çš„è¾¹ç•Œæ¡ä»¶å’Œå¤æ‚åœºæ™¯

test "attribute_value_type_conversion_edge_cases" {
  // æµ‹è¯•æå€¼è½¬æ¢
  let max_int = 2147483647
  let min_int = -2147483648
  let max_float = 1.7976931348623157e+308
  let min_float = -1.7976931348623157e+308
  
  // æ•´æ•°åˆ°æµ®ç‚¹æ•°è½¬æ¢
  let int_attr = azimuth.AttributeValue.IntValue(max_int)
  match int_attr {
    azimuth.AttributeValue.IntValue(v) => 
      let float_attr = azimuth.AttributeValue.FloatValue(@unsafe.Double.from_int(v))
      @assertion.assert_true(true) // è½¬æ¢æˆåŠŸ
    _ => @assertion.assert_true(false)
  }
  
  // å­—ç¬¦ä¸²åˆ°æ•°å­—è½¬æ¢çš„è¾¹ç•Œæµ‹è¯•
  let large_num_str = "9223372036854775807" // è¶…è¿‡IntèŒƒå›´
  let string_attr = azimuth.AttributeValue.StringValue(large_num_str)
  @assertion.assert_true(true) // å­—ç¬¦ä¸²å±æ€§åˆ›å»ºæˆåŠŸ
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å’Œç‰¹æ®Šå­—ç¬¦
  let empty_string = azimuth.AttributeValue.StringValue("")
  let special_chars = azimuth.AttributeValue.StringValue("ğŸŒŸæµ‹è¯•@#$%^&*()")
  @assertion.assert_true(true)
  
  // æµ‹è¯•æ•°ç»„å±æ€§çš„è¾¹ç•Œ
  let empty_array = azimuth.AttributeValue.ArrayStringValue([])
  let large_array = azimuth.AttributeValue.ArrayStringValue([for i = 0; i < 1000; i + 1 => "item_\{i}"])
  @assertion.assert_true(true)
}

test "attribute_value_type_safety_validation" {
  // æµ‹è¯•ç±»å‹å®‰å…¨æ€§éªŒè¯
  
  // åˆ›å»ºåŒ…å«æ··åˆç±»å‹çš„å±æ€§é›†åˆ
  let attributes = azimuth.Attributes.new()
  azimuth.Attributes.set_string(attributes, "string_key", "test_value")
  azimuth.Attributes.set_int(attributes, "int_key", 42)
  azimuth.Attributes.set_float(attributes, "float_key", 3.14)
  azimuth.Attributes.set_bool(attributes, "bool_key", true)
  
  // éªŒè¯ç±»å‹è·å–çš„æ­£ç¡®æ€§
  match azimuth.Attributes.get_string(attributes, "string_key") {
    Some(v) => @assertion.assert_equal(v, "test_value")
    _ => @assertion.assert_true(false)
  }
  
  match azimuth.Attributes.get_int(attributes, "int_key") {
    Some(v) => @assertion.assert_equal(v, 42)
    _ => @assertion.assert_true(false)
  }
  
  // æµ‹è¯•ç±»å‹é”™è¯¯å¤„ç†
  match azimuth.Attributes.get_string(attributes, "int_key") {
    None => @assertion.assert_true(true) // æ­£ç¡®è¿”å›None
    _ => @assertion.assert_true(false)
  }
}

test "attribute_value_serialization_boundary" {
  // æµ‹è¯•åºåˆ—åŒ–è¾¹ç•Œæ¡ä»¶
  
  // åˆ›å»ºåŒ…å«å¤æ‚åµŒå¥—ç»“æ„çš„å±æ€§
  let attributes = azimuth.Attributes.new()
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_string = @unsafe.String.init(10000, 'A') // 10Kçš„å­—ç¬¦ä¸²
  azimuth.Attributes.set_string(attributes, "long_string", long_string)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•ä¸­æ–‡ğŸŒŸÎ±Î²Î³Î´ÎµÎ¶Î·Î¸"
  azimuth.Attributes.set_string(attributes, "unicode", unicode_string)
  
  // æµ‹è¯•ç‰¹æ®Šæ•°å€¼
  let special_float = @unsafe.Double.from_string("NaN")
  azimuth.Attributes.set_float(attributes, "nan_value", special_float)
  
  let infinity = @unsafe.Double.from_string("Infinity")
  azimuth.Attributes.set_float(attributes, "infinity", infinity)
  
  // éªŒè¯å±æ€§æ•°é‡
  let count = azimuth.Attributes.len(attributes)
  @assertion.assert_equal(count, 4)
}

test "attribute_value_memory_efficiency" {
  // æµ‹è¯•å†…å­˜æ•ˆç‡å’Œæ€§èƒ½
  
  let attributes = azimuth.Attributes.new()
  
  // æ·»åŠ å¤§é‡å±æ€§æµ‹è¯•å†…å­˜ä½¿ç”¨
  for i = 0; i < 1000; i + 1 {
    let key = "attr_\{i}"
    let value = "value_\{i}"
    azimuth.Attributes.set_string(attributes, key, value)
  }
  
  // éªŒè¯æ‰€æœ‰å±æ€§éƒ½è¢«æ­£ç¡®æ·»åŠ 
  let count = azimuth.Attributes.len(attributes)
  @assertion.assert_equal(count, 1000)
  
  // æµ‹è¯•å±æ€§æŸ¥æ‰¾æ€§èƒ½
  match azimuth.Attributes.get_string(attributes, "attr_500") {
    Some(v) => @assertion.assert_equal(v, "value_500")
    _ => @assertion.assert_true(false)
  }
  
  // æµ‹è¯•å±æ€§åˆ é™¤å’Œå†…å­˜å›æ”¶
  for i = 0; i < 500; i + 1 {
    let key = "attr_\{i}"
    azimuth.Attributes.remove(attributes, key)
  }
  
  let final_count = azimuth.Attributes.len(attributes)
  @assertion.assert_equal(final_count, 500)
}