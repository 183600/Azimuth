// æ–°å¢žçš„é«˜è´¨é‡ MoonBit æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºŽå‡½æ•°ç»„åˆå’Œå¤æ‚è®¡ç®—åœºæ™¯

test "function_composition_basic" {
  // æµ‹è¯•åŸºæœ¬å‡½æ•°ç»„åˆ
  let initial = 5
  let result = add(multiply(initial, 2), 3)  // 5*2 + 3 = 13
  assert_eq(13, result)
}

test "complex_calculation_chain" {
  // æµ‹è¯•å¤æ‚è®¡ç®—é“¾
  let base = 10
  let step1 = multiply(base, 3)        // 30
  let step2 = add(step1, 5)            // 35
  let step3 = divide_with_ceil(step2, 8)  // ceil(35/8) = 5
  assert_eq(5, step3)
}

test "mathematical_properties_extended" {
  // æµ‹è¯•æ‰©å±•çš„æ•°å­¦æ€§è´¨
  let x = 15
  let y = 7
  
  // åˆ†é…å¾‹éªŒè¯
  let distributive_left = multiply(x, add(y, 2))
  let distributive_right = add(multiply(x, y), multiply(x, 2))
  assert_eq(distributive_left, distributive_right)
}

test "business_logic_simulation" {
  // ä¸šåŠ¡é€»è¾‘æ¨¡æ‹Ÿæµ‹è¯•
  let items = 47
  let capacity = 12
  let containers = divide_with_ceil(items, capacity)  // ceil(47/12) = 4
  let total_capacity = multiply(containers, capacity)  // 4*12 = 48
  let unused_space = subtract(total_capacity, items)  // 48-47 = 1
  
  assert_eq(4, containers)
  assert_eq(48, total_capacity)
  assert_eq(1, unused_space)
}

test "error_handling_comprehensive" {
  // ç»¼åˆé”™è¯¯å¤„ç†æµ‹è¯•
  // é™¤é›¶æƒ…å†µ
  assert_eq(0, divide_with_ceil(10, 0))
  assert_eq(0, divide_with_ceil(-10, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // è¾¹ç•Œå€¼æµ‹è¯•
  assert_eq(1, divide_with_ceil(1, 1))
  assert_eq(0, divide_with_ceil(0, 1))
}

test "string_processing_advanced" {
  // é«˜çº§å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  assert_eq_string("Hello, MoonBit!", greet("MoonBit"))
  assert_eq_string("Hello, ä¸–ç•Œ!", greet("ä¸–ç•Œ"))
  assert_eq_string("Hello, ðŸš€!", greet("ðŸš€"))
  assert_eq_string("Hello, !", greet(""))
}

test "performance_calculation" {
  // æ€§èƒ½è®¡ç®—æµ‹è¯•
  let large_number = 10000
  let operations = 100
  let result = divide_with_ceil(multiply(large_number, operations), 50000)
  assert_eq(20, result)
}

test "nested_function_calls" {
  // åµŒå¥—å‡½æ•°è°ƒç”¨æµ‹è¯•
  let a = 8
  let b = 3
  let c = 2
  
  // å¤æ‚åµŒå¥—ï¼š((a*b) + c) / (b+c)
  let numerator = add(multiply(a, b), c)  // 8*3 + 2 = 26
  let denominator = add(b, c)             // 3 + 2 = 5
  let result = divide_with_ceil(numerator, denominator)  // ceil(26/5) = 6
  
  assert_eq(6, result)
}

// è¾…åŠ©å‡½æ•°
fn subtract(a : Int, b : Int) -> Int {
  a - b
}