// Multilingual Text Processing Tests
// æµ‹è¯•å¤šè¯­è¨€æ–‡æœ¬å¤„ç†å’Œå›½é™…åŒ–çš„åŠŸèƒ½

test "unicode_character_handling" {
  // Unicodeå­—ç¬¦å¤„ç†æµ‹è¯•
  
  let tracer = azimuth.Tracer.new("å›½é™…åŒ–æµ‹è¯•æœåŠ¡")
  let span = azimuth.Tracer.start_span(tracer, "å¤šè¯­è¨€æ“ä½œ")
  
  // æµ‹è¯•å„ç§Unicodeå­—ç¬¦
  let chinese_text = "ä¸­æ–‡æµ‹è¯•æ–‡æœ¬"
  let japanese_text = "æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆ"
  let korean_text = "í•œêµ­ì–´ í…ìŠ¤íŠ¸"
  let arabic_text = "Ù†Øµ Ø¹Ø±Ø¨ÙŠ"
  let russian_text = "Ğ ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµĞºÑÑ‚"
  let emoji_text = "ğŸŒŸğŸš€ğŸ’»ğŸ“Š"
  let mixed_text = "ä¸­æ–‡ English æ—¥æœ¬èª ğŸŒŸ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  
  // è®¾ç½®å¤šè¯­è¨€å±æ€§
  azimuth.Span.set_attribute_string(span, "chinese_message", chinese_text)
  azimuth.Span.set_attribute_string(span, "japanese_message", japanese_text)
  azimuth.Span.set_attribute_string(span, "korean_message", korean_text)
  azimuth.Span.set_attribute_string(span, "arabic_message", arabic_text)
  azimuth.Span.set_attribute_string(span, "russian_message", russian_text)
  azimuth.Span.set_attribute_string(span, "emoji_message", emoji_text)
  azimuth.Span.set_attribute_string(span, "mixed_message", mixed_text)
  
  // éªŒè¯Unicodeå­—ç¬¦é•¿åº¦è®¡ç®—
  let chinese_len = @unsafe.String.length(chinese_text)
  let japanese_len = @unsafe.String.length(japanese_text)
  let emoji_len = @unsafe.String.length(emoji_text)
  
  @assertion.assert_equal(chinese_len, 6)
  @assertion.assert_equal(japanese_len, 7)
  @assertion.assert_equal(emoji_len, 4)
  
  // éªŒè¯å±æ€§å­˜å‚¨å’Œæ£€ç´¢
  let attributes = azimuth.Span.get_attributes(span)
  
  match azimuth.Attributes.get_string(attributes, "chinese_message") {
    Some(v) => @assertion.assert_equal(v, chinese_text)
    _ => @assertion.assert_true(false)
  }
  
  match azimuth.Attributes.get_string(attributes, "mixed_message") {
    Some(v) => @assertion.assert_equal(v, mixed_text)
    _ => @assertion.assert_true(false)
  }
}

test "multilingual_error_messages" {
  // å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯æµ‹è¯•
  
  let tracer = azimuth.Tracer.new("å¤šè¯­è¨€é”™è¯¯å¤„ç†æœåŠ¡")
  let span = azimuth.Tracer.start_span(tracer, "å¤šè¯­è¨€é”™è¯¯å¤„ç†")
  
  // åˆ›å»ºä¸åŒè¯­è¨€çš„é”™è¯¯æ¶ˆæ¯
  let error_messages = [
    ("zh", "æ“ä½œå¤±è´¥ï¼šæ•°æ®åº“è¿æ¥è¶…æ—¶"),
    ("en", "Operation failed: Database connection timeout"),
    ("ja", "æ“ä½œå¤±æ•—ï¼šãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"),
    ("ko", "ì‘ì—… ì‹¤íŒ¨: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹œê°„ ì´ˆê³¼"),
    ("ar", "ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"),
    ("ru", "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ°ÑÑŒ: Ñ‚Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…")
  ]
  
  // æ·»åŠ å¤šè¯­è¨€é”™è¯¯äº‹ä»¶
  for (lang, message) in error_messages {
    azimuth.Span.add_event_with_attributes(span, "error_occurred", [
      ("language", azimuth.AttributeValue.StringValue(lang)),
      ("error_message", azimuth.AttributeValue.StringValue(message)),
      ("error_code", azimuth.AttributeValue.IntValue(500))
    ])
  }
  
  // éªŒè¯å¤šè¯­è¨€é”™è¯¯äº‹ä»¶
  let events = azimuth.Span.get_events(span)
  @assertion.assert_equal(@unsafe.Array.length(events), 6)
  
  // éªŒè¯ç‰¹å®šè¯­è¨€çš„é”™è¯¯æ¶ˆæ¯
  for i = 0; i < @unsafe.Array.length(events); i + 1 {
    let event = @unsafe.Array.get(events, i)
    let event_attrs = azimuth.Event.get_attributes(event)
    let (expected_lang, expected_message) = @unsafe.Array.get(error_messages, i)
    
    match azimuth.Attributes.get_string(event_attrs, "language") {
      Some(v) => @assertion.assert_equal(v, expected_lang)
      _ => @assertion.assert_true(false)
    }
    
    match azimuth.Attributes.get_string(event_attrs, "error_message") {
      Some(v) => @assertion.assert_equal(v, expected_message)
      _ => @assertion.assert_true(false)
    }
  }
}

test "localized_logging_messages" {
  // æœ¬åœ°åŒ–æ—¥å¿—æ¶ˆæ¯æµ‹è¯•
  
  let logger_provider = azimuth.LoggerProvider.new()
  let logger = azimuth.LoggerProvider.get_logger(logger_provider, "å¤šè¯­è¨€æ—¥å¿—æœåŠ¡", "1.0.0")
  
  // åˆ›å»ºä¸åŒè¯­è¨€çš„æ—¥å¿—è®°å½•å™¨
  let log_messages = [
    ("zh", "ç”¨æˆ·ç™»å½•æˆåŠŸ", "INFO"),
    ("en", "User login successful", "INFO"),
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ", "INFO"),
    ("ko", "ì‚¬ìš©ì ë¡œê·¸ì¸ ì„±ê³µ", "INFO"),
    ("zh", "æ•°æ®åº“è¿æ¥å¤±è´¥", "ERROR"),
    ("en", "Database connection failed", "ERROR"),
    ("ja", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šå¤±æ•—", "ERROR"),
    ("ko", "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨", "ERROR")
  ]
  
  // è®°å½•å¤šè¯­è¨€æ—¥å¿—
  for (lang, message, level) in log_messages {
    let log_record = azimuth.Logger.emit_log_with_attributes(logger, [
      ("message", azimuth.AttributeValue.StringValue(message)),
      ("language", azimuth.AttributeValue.StringValue(lang)),
      ("level", azimuth.AttributeValue.StringValue(level)),
      ("timestamp", azimuth.AttributeValue.IntValue(@unsafe.Time.now()))
    ])
    
    @assertion.assert_true(log_record)
  }
  
  // éªŒè¯æ—¥å¿—è®°å½•æ•°é‡
  let logs = azimuth.Logger.get_logs(logger)
  @assertion.assert_equal(@unsafe.Array.length(logs), 8)
  
  // éªŒè¯ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯
  let chinese_logs = @unsafe.Array.filter(logs, fn(log) {
    let attrs = azimuth.LogRecord.get_attributes(log)
    match azimuth.Attributes.get_string(attrs, "language") {
      Some(v) => v == "zh"
      None => false
    }
  })
  
  @assertion.assert_equal(@unsafe.Array.length(chinese_logs), 2)
}

test "multilingual_baggage_propagation" {
  // å¤šè¯­è¨€Baggageä¼ æ’­æµ‹è¯•
  
  let parent_context = azimuth.Context.new()
  
  // æ·»åŠ å¤šè¯­è¨€Baggageé¡¹
  let multilingual_baggage = [
    ("user_locale", "zh-CN"),
    ("preferred_language", "ä¸­æ–‡"),
    ("service_name", "ç”¨æˆ·æœåŠ¡"),
    ("operation_name", "ãƒ‡ãƒ¼ã‚¿å‡¦ç†"), // æ—¥æ–‡
    ("error_message", "OperaciÃ³n fallida"), // è¥¿ç­ç‰™æ–‡
    ("custom_field", "ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒÑĞºĞ¾Ğµ Ğ¿Ğ¾Ğ»Ğµ") // ä¿„æ–‡
  ]
  
  for (key, value) in multilingual_baggage {
    azimuth.Context.set_baggage(parent_context, key, value)
  }
  
  // åˆ›å»ºå­ä¸Šä¸‹æ–‡å¹¶éªŒè¯Baggageä¼ æ’­
  let child_context = azimuth.Context.copy(parent_context)
  azimuth.Context.set_baggage(child_context, "child_locale", "en-US")
  
  // éªŒè¯çˆ¶Baggageåœ¨å­ä¸Šä¸‹æ–‡ä¸­å­˜åœ¨
  for (key, expected_value) in multilingual_baggage {
    match azimuth.Context.get_baggage(child_context, key) {
      Some(actual_value) => @assertion.assert_equal(actual_value, expected_value)
      None => @assertion.assert_true(false)
    }
  }
  
  // éªŒè¯å­ä¸Šä¸‹æ–‡ç‰¹å®šçš„Baggage
  match azimuth.Context.get_baggage(child_context, "child_locale") {
    Some(v) => @assertion.assert_equal(v, "en-US")
    None => @assertion.assert_true(false)
  }
}

test "internationalization_time_formatting" {
  // å›½é™…åŒ–æ—¶é—´æ ¼å¼æµ‹è¯•
  
  let tracer = azimuth.Tracer.new("å›½é™…åŒ–æ—¶é—´æœåŠ¡")
  let span = azimuth.Tracer.start_span(tracer, "å¤šè¯­è¨€æ—¶é—´å¤„ç†")
  
  // è·å–å½“å‰æ—¶é—´æˆ³
  let timestamp = @unsafe.Time.now()
  
  // åˆ›å»ºä¸åŒåœ°åŒºçš„æ—¶é—´æ ¼å¼
  let time_formats = [
    ("zh-CN", "2024-01-15 14:30:25 CST"),
    ("en-US", "01/15/2024 02:30:25 PM EST"),
    ("ja-JP", "2024/01/15 14:30:25 JST"),
    ("ko-KR", "2024. 01. 15. ì˜¤í›„ 2:30:25 KST"),
    ("ar-SA", "Ù¡Ù¥/Ù Ù¡/Ù¢Ù Ù¢Ù¤ Ù Ù¢:Ù£Ù :Ù¢Ù¥ Ù… AST"),
    ("ru-RU", "15.01.2024 14:30:25 MSK")
  ]
  
  // æ·»åŠ å¤šè¯­è¨€æ—¶é—´æ ¼å¼äº‹ä»¶
  for (locale, formatted_time) in time_formats {
    azimuth.Span.add_event_with_attributes(span, "time_formatted", [
      ("locale", azimuth.AttributeValue.StringValue(locale)),
      ("formatted_time", azimuth.AttributeValue.StringValue(formatted_time)),
      ("timestamp", azimuth.AttributeValue.IntValue(timestamp))
    ])
  }
  
  // éªŒè¯æ—¶é—´æ ¼å¼äº‹ä»¶
  let events = azimuth.Span.get_events(span)
  @assertion.assert_equal(@unsafe.Array.length(events), 6)
  
  // éªŒè¯ç‰¹å®šåœ°åŒºçš„æ—¶é—´æ ¼å¼
  for i = 0; i < @unsafe.Array.length(events); i + 1 {
    let event = @unsafe.Array.get(events, i)
    let event_attrs = azimuth.Event.get_attributes(event)
    let (expected_locale, expected_time) = @unsafe.Array.get(time_formats, i)
    
    match azimuth.Attributes.get_string(event_attrs, "locale") {
      Some(v) => @assertion.assert_equal(v, expected_locale)
      None => @assertion.assert_true(false)
    }
    
    match azimuth.Attributes.get_string(event_attrs, "formatted_time") {
      Some(v) => @assertion.assert_equal(v, expected_time)
      None => @assertion.assert_true(false)
    }
  }
}

test "multilingual_resource_attributes" {
  // å¤šè¯­è¨€èµ„æºå±æ€§æµ‹è¯•
  
  // åˆ›å»ºåŒ…å«å¤šè¯­è¨€ä¿¡æ¯çš„èµ„æº
  let resource = azimuth.Resource.new([
    ("service.name", azimuth.AttributeValue.StringValue("å¤šè¯­è¨€é¥æµ‹æœåŠ¡")),
    ("service.description", azimuth.AttributeValue.StringValue("Multilingual Telemetry Service")),
    ("service.version", azimuth.AttributeValue.StringValue("1.0.0")),
    ("service.owner", azimuth.AttributeValue.StringValue("å¼€å‘å›¢é˜Ÿ")),
    ("service.owner_en", azimuth.AttributeValue.StringValue("Development Team")),
    ("deployment.region", azimuth.AttributeValue.StringValue("äºšå¤ªåœ°åŒº")),
    ("deployment.region_en", azimuth.AttributeValue.StringValue("Asia Pacific")),
    ("support.contact", azimuth.AttributeValue.StringValue("æŠ€æœ¯æ”¯æŒå›¢é˜Ÿ")),
    ("support.contact_en", azimuth.AttributeValue.StringValue("Technical Support Team"))
  ])
  
  // éªŒè¯å¤šè¯­è¨€èµ„æºå±æ€§
  let attributes = azimuth.Resource.get_attributes(resource)
  
  // éªŒè¯ä¸­æ–‡å±æ€§
  match azimuth.Attributes.get_string(attributes, "service.name") {
    Some(v) => @assertion.assert_equal(v, "å¤šè¯­è¨€é¥æµ‹æœåŠ¡")
    None => @assertion.assert_true(false)
  }
  
  match azimuth.Attributes.get_string(attributes, "service.owner") {
    Some(v) => @assertion.assert_equal(v, "å¼€å‘å›¢é˜Ÿ")
    None => @assertion.assert_true(false)
  }
  
  // éªŒè¯è‹±æ–‡å±æ€§
  match azimuth.Attributes.get_string(attributes, "service.description") {
    Some(v) => @assertion.assert_equal(v, "Multilingual Telemetry Service")
    None => @assertion.assert_true(false)
  }
  
  match azimuth.Attributes.get_string(attributes, "service.owner_en") {
    Some(v) => @assertion.assert_equal(v, "Development Team")
    None => @assertion.assert_true(false)
  }
  
  // éªŒè¯å±æ€§æ€»æ•°
  @assertion.assert_equal(azimuth.Attributes.len(attributes), 9)
}

test "text_encoding_conversion" {
  // æ–‡æœ¬ç¼–ç è½¬æ¢æµ‹è¯•
  
  let tracer = azimuth.Tracer.new("ç¼–ç è½¬æ¢æœåŠ¡")
  let span = azimuth.Tracer.start_span(tracer, "å¤šè¯­è¨€ç¼–ç å¤„ç†")
  
  // æµ‹è¯•ä¸åŒç¼–ç çš„æ–‡æœ¬
  let utf8_texts = [
    "ç®€ä½“ä¸­æ–‡ï¼šä½ å¥½ä¸–ç•Œ",
    "ç¹é«”ä¸­æ–‡ï¼šä½ å¥½ä¸–ç•Œ",
    "æ—¥æœ¬èªï¼šã“ã‚“ã«ã¡ã¯ä¸–ç•Œ",
    "í•œêµ­ì–´: ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„",
    "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©: Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…",
    "Ğ ÑƒÑÑĞºĞ¸Ğ¹: ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€",
    "English: Hello World",
    "EspaÃ±ol: Hola Mundo",
    "FranÃ§ais: Bonjour le monde",
    "Deutsch: Hallo Welt",
    "ğŸŒğŸŒğŸŒğŸŒğŸŒ‘ğŸŒ’ğŸŒ“ğŸŒ”ğŸŒ•ğŸŒ–ğŸŒ—ğŸŒ˜"
  ]
  
  // å¤„ç†æ¯ä¸ªæ–‡æœ¬å¹¶è®°å½•
  for text in utf8_texts {
    // æ¨¡æ‹Ÿæ–‡æœ¬å¤„ç†æ“ä½œ
    let processed_text = text // åœ¨å®é™…åº”ç”¨ä¸­è¿™é‡Œå¯èƒ½æœ‰ç¼–ç è½¬æ¢
    
    azimuth.Span.add_event_with_attributes(span, "text_processed", [
      ("original_text", azimuth.AttributeValue.StringValue(text)),
      ("processed_text", azimuth.AttributeValue.StringValue(processed_text)),
      ("text_length", azimuth.AttributeValue.IntValue(@unsafe.String.length(text))),
      ("encoding", azimuth.AttributeValue.StringValue("UTF-8"))
    ])
  }
  
  // éªŒè¯æ–‡æœ¬å¤„ç†äº‹ä»¶
  let events = azimuth.Span.get_events(span)
  @assertion.assert_equal(@unsafe.Array.length(events), 12)
  
  // éªŒè¯ç‰¹å®šæ–‡æœ¬çš„å¤„ç†
  let emoji_event = @unsafe.Array.get(events, 11) // æœ€åä¸€ä¸ªemojiäº‹ä»¶
  let emoji_attrs = azimuth.Event.get_attributes(emoji_event)
  
  match azimuth.Attributes.get_string(emoji_attrs, "original_text") {
    Some(v) => @assertion.assert_equal(v, "ğŸŒğŸŒğŸŒğŸŒğŸŒ‘ğŸŒ’ğŸŒ“ğŸŒ”ğŸŒ•ğŸŒ–ğŸŒ—ğŸŒ˜")
    None => @assertion.assert_true(false)
  }
  
  match azimuth.Attributes.get_int(emoji_attrs, "text_length") {
    Some(v) => @assertion.assert_equal(v, 12)
    None => @assertion.assert_true(false)
  }
}