// Internationalization and Localization Tests
// This file contains test cases for internationalization and localization support

test "unicode and multilingual attribute handling" {
  // Test handling of Unicode and multilingual content in attributes
  let attrs = azimuth::Attributes::new()
  
  // Test various Unicode scripts
  azimuth::Attributes::set(attrs, "chinese.text", azimuth::StringValue("æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸²æ”¯æŒ"))
  azimuth::Attributes::set(attrs, "japanese.text", azimuth::StringValue("æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ"))
  azimuth::Attributes::set(attrs, "korean.text", azimuth::StringValue("í•œêµ­ì–´ í…ŒìŠ¤íŠ¸"))
  azimuth::Attributes::set(attrs, "arabic.text", azimuth::StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  azimuth::Attributes::set(attrs, "hebrew.text", azimuth::StringValue("×‘×“×™×§×ª ×©×¤×” ×¢×‘×¨×™×ª"))
  azimuth::Attributes::set(attrs, "russian.text", azimuth::StringValue("Ğ¢ĞµÑÑ‚ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ"))
  azimuth::Attributes::set(attrs, "thai.text", azimuth::StringValue("à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢"))
  azimuth::Attributes::set(attrs, "emoji.text", azimuth::StringValue("ğŸš€ğŸ”¥ğŸ’¡ğŸ‰âœ¨"))
  
  // Test right-to-left languages
  azimuth::Attributes::set(attrs, "rtl.hebrew", azimuth::StringValue("×©×œ×•× ×¢×•×œ×"))
  azimuth::Attributes::set(attrs, "rtl.arabic", azimuth::StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"))
  
  // Test mixed language content
  azimuth::Attributes::set(attrs, "mixed.content", azimuth::StringValue("Hello ä¸–ç•Œ ğŸŒ Bonjour le monde"))
  
  // Test special Unicode characters
  azimuth::Attributes::set(attrs, "special.chars", azimuth::StringValue("Â©Â®â„¢â‚¬Â£Â¥Â§Â¶â€ â€¡â€¢â€¦â€°â€¹â€º""''""â€“â€”"))
  azimuth::Attributes::set(attrs, "math.symbols", azimuth::StringValue("âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚âˆšâˆâ‰ˆâ‰ â‰¤â‰¥Â±Ã—Ã·"))
  azimuth::Attributes::set(attrs, "currency.symbols", azimuth::StringValue("$â‚¬Â£Â¥â‚¹â‚½â‚©â‚ªâ‚«â‚¡â‚¦â‚¨â‚±â‚²â‚´â‚¸â‚¼â‚½"))
  
  // Verify attribute retrieval and integrity
  let chinese_text = azimuth::Attributes::get(attrs, "chinese.text")
  let japanese_text = azimuth::Attributes::get(attrs, "japanese.text")
  let korean_text = azimuth::Attributes::get(attrs, "korean.text")
  let arabic_text = azimuth::Attributes::get(attrs, "arabic.text")
  let hebrew_text = azimuth::Attributes::get(attrs, "hebrew.text")
  let russian_text = azimuth::Attributes::get(attrs, "russian.text")
  let thai_text = azimuth::Attributes::get(attrs, "thai.text")
  let emoji_text = azimuth::Attributes::get(attrs, "emoji.text")
  
  assert_eq(chinese_text, Some(azimuth::StringValue("æµ‹è¯•ä¸­æ–‡å­—ç¬¦ä¸²æ”¯æŒ")))
  assert_eq(japanese_text, Some(azimuth::StringValue("æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ")))
  assert_eq(korean_text, Some(azimuth::StringValue("í•œêµ­ì–´ í…ŒìŠ¤íŠ¸")))
  assert_eq(arabic_text, Some(azimuth::StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")))
  assert_eq(hebrew_text, Some(azimuth::StringValue("×‘×“×™×§×ª ×©×¤×” ×¢×‘×¨×™×ª")))
  assert_eq(russian_text, Some(azimuth::StringValue("Ğ¢ĞµÑÑ‚ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ")))
  assert_eq(thai_text, Some(azimuth::StringValue("à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢")))
  assert_eq(emoji_text, Some(azimuth::StringValue("ğŸš€ğŸ”¥ğŸ’¡ğŸ‰âœ¨")))
  
  // Test array attributes with multilingual content
  let multilingual_array = azimuth::ArrayStringValue([
    "Hello World", "Hola Mundo", "Bonjour le monde", "Hallo Welt", 
    "Ciao Mondo", "OlÃ¡ Mundo", "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ", "ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„",
    "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", "×©×œ×•× ×¢×•×œ×", "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€"
  ])
  azimuth::Attributes::set(attrs, "multilingual.greetings", multilingual_array)
  
  let retrieved_array = azimuth::Attributes::get(attrs, "multilingual.greetings")
  assert_eq(retrieved_array, Some(multilingual_array))
}

test "localized log messages" {
  // Test localized log messages
  let logger_provider = azimuth::LoggerProvider::default()
  let logger = azimuth::LoggerProvider::get_logger(logger_provider, "i18n-logger")
  
  // Create localized messages
  let messages = [
    ("en", "User login successful"),
    ("es", "Inicio de sesiÃ³n de usuario exitoso"),
    ("fr", "Connexion utilisateur rÃ©ussie"),
    ("de", "Benutzeranmeldung erfolgreich"),
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ"),
    ("ko", "ì‚¬ìš©ì ë¡œê·¸ì¸ ì„±ê³µ"),
    ("zh", "ç”¨æˆ·ç™»å½•æˆåŠŸ"),
    ("ar", "ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­"),
    ("ru", "Ğ’Ñ…Ğ¾Ğ´ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾"),
    ("th", "à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¸ªà¸¹à¹ˆà¸£à¸°à¸šà¸šà¸‚à¸­à¸‡à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸ªà¸³à¹€à¸£à¹‡à¸ˆ")
  ]
  
  // Log messages in different languages
  for (locale, message) in messages {
    let localized_attrs = [
      ("locale", azimuth::StringValue(locale)),
      ("user.id", azimuth::StringValue("user-12345")),
      ("timestamp", azimuth::StringValue(azimuth::Time::now().to_string()))
    ]
    
    azimuth::Logger::log(logger, azimuth::Info, message, localized_attrs)
  }
  
  // Test error messages in different languages
  let error_messages = [
    ("en", "Database connection failed"),
    ("es", "Error de conexiÃ³n a la base de datos"),
    ("fr", "Ã‰chec de connexion Ã  la base de donnÃ©es"),
    ("de", "Datenbankverbindung fehlgeschlagen"),
    ("ja", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ"),
    ("ko", "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨"),
    ("zh", "æ•°æ®åº“è¿æ¥å¤±è´¥"),
    ("ar", "ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"),
    ("ru", "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"),
    ("th", "à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸à¸²à¸™à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸¥à¹‰à¸¡à¹€à¸«à¸¥à¸§")
  ]
  
  for (locale, message) in error_messages {
    let error_attrs = [
      ("locale", azimuth::StringValue(locale)),
      ("error.code", azimuth::IntValue(500)),
      ("retry.count", azimuth::IntValue(3))
    ]
    
    azimuth::Logger::log(logger, azimuth::Error, message, error_attrs)
  }
  
  // Collect and verify log records
  let log_records = azimuth::Logger::get_log_records(logger)
  assert_eq(log_records.length, messages.length + error_messages.length)
  
  // Verify message integrity
  for i = 0; i < messages.length; i = i + 1 {
    let (locale, expected_message) = messages[i]
    let log_record = log_records[i]
    
    assert_eq(azimuth::LogRecord::body(log_record), expected_message)
    assert_eq(azimuth::LogRecord::get_attribute(log_record, "locale"), Some(azimuth::StringValue(locale)))
  }
  
  // Verify error messages
  for i = 0; i < error_messages.length; i = i + 1 {
    let (locale, expected_message) = error_messages[i]
    let log_record = log_records[messages.length + i]
    
    assert_eq(azimuth::LogRecord::body(log_record), expected_message)
    assert_eq(azimuth::LogRecord::severity(log_record), azimuth::Error)
    assert_eq(azimuth::LogRecord::get_attribute(log_record, "locale"), Some(azimuth::StringValue(locale)))
  }
}

test "localized span names and events" {
  // Test localized span names and events
  let tracer_provider = azimuth::TracerProvider::default()
  let tracer = azimuth::TracerProvider::get_tracer(tracer_provider, "i18n-tracer")
  
  // Create spans with localized names
  let span_operations = [
    ("en", "HTTP Request Processing"),
    ("es", "Procesamiento de Solicitud HTTP"),
    ("fr", "Traitement de la RequÃªte HTTP"),
    ("de", "HTTP-Anfrageverarbeitung"),
    ("ja", "HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆå‡¦ç†"),
    ("ko", "HTTP ìš”ì²­ ì²˜ë¦¬"),
    ("zh", "HTTPè¯·æ±‚å¤„ç†"),
    ("ar", "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ HTTP"),
    ("ru", "ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° HTTP-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°"),
    ("th", "à¸à¸²à¸£à¸›à¸£à¸°à¸¡à¸§à¸¥à¸œà¸¥à¸„à¸³à¸‚à¸­ HTTP")
  ]
  
  for (locale, operation_name) in span_operations {
    let span = azimuth::Tracer::start_span(tracer, operation_name)
    
    // Add localized attributes
    let localized_attrs = [
      ("locale", azimuth::StringValue(locale)),
      ("operation.type", azimuth::StringValue("http.request")),
      ("service.name", azimuth::StringValue("web-service"))
    ]
    
    for (key, value) in localized_attrs {
      azimuth::Span::set_attribute(span, key, value)
    }
    
    // Add localized events
    let events = [
      ("request.received", [
        ("en", "HTTP request received"),
        ("es", "Solicitud HTTP recibida"),
        ("fr", "RequÃªte HTTP reÃ§ue"),
        ("de", "HTTP-Anfrage empfangen"),
        ("ja", "HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆå—ä¿¡"),
        ("ko", "HTTP ìš”ì²­ ìˆ˜ì‹ "),
        ("zh", "æ”¶åˆ°HTTPè¯·æ±‚"),
        ("ar", "ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø·Ù„Ø¨ HTTP"),
        ("ru", "HTTP-Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½"),
        ("th", "à¹„à¸”à¹‰à¸£à¸±à¸šà¸„à¸³à¸‚à¸­ HTTP")
      ]),
      ("processing.started", [
        ("en", "Started processing request"),
        ("es", "ComenzÃ³ el procesamiento de la solicitud"),
        ("fr", "Traitement de la requÃªte dÃ©marrÃ©"),
        ("de", "Verarbeitung der Anfrage gestartet"),
        ("ja", "ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å‡¦ç†ã‚’é–‹å§‹"),
        ("ko", "ìš”ì²­ ì²˜ë¦¬ ì‹œì‘"),
        ("zh", "å¼€å§‹å¤„ç†è¯·æ±‚"),
        ("ar", "Ø¨Ø¯Ø£ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨"),
        ("ru", "ĞĞ°Ñ‡Ğ°Ñ‚Ğ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ°"),
        ("th", "à¹€à¸£à¸´à¹ˆà¸¡à¸›à¸£à¸°à¸¡à¸§à¸¥à¸œà¸¥à¸„à¸³à¸‚à¸­")
      ]),
      ("request.completed", [
        ("en", "Request processing completed"),
        ("es", "Procesamiento de solicitud completado"),
        ("fr", "Traitement de la requÃªte terminÃ©"),
        ("de", "Anfrageverarbeitung abgeschlossen"),
        ("ja", "ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å‡¦ç†ãŒå®Œäº†"),
        ("ko", "ìš”ì²­ ì²˜ë¦¬ ì™„ë£Œ"),
        ("zh", "è¯·æ±‚å¤„ç†å®Œæˆ"),
        ("ar", "Ø§ÙƒØªÙ…Ù„Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨"),
        ("ru", "ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°"),
        ("th", "à¸à¸²à¸£à¸›à¸£à¸°à¸¡à¸§à¸¥à¸œà¸¥à¸„à¸³à¸‚à¸­à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ")
      ])
    ]
    
    for (event_key, event_messages) in events {
      let message = match event_messages.get(locale) {
        Some(msg) => msg,
        None => event_messages.get("en").unwrap_or("Unknown message")
      }
      
      azimuth::Span::add_event(span, event_key, [
        ("message", azimuth::StringValue(message)),
        ("locale", azimuth::StringValue(locale))
      ])
    }
    
    azimuth::Span::end(span)
  }
  
  // Verify span integrity
  let spans = azimuth::Tracer::get_finished_spans(tracer)
  assert_eq(spans.length, span_operations.length)
  
  for i = 0; i < spans.length; i = i + 1 {
    let (expected_locale, expected_name) = span_operations[i]
    let span = spans[i]
    
    assert_eq(azimuth::Span::name(span), expected_name)
    assert_eq(azimuth::Span::get_attribute(span, "locale"), Some(azimuth::StringValue(expected_locale)))
    
    // Verify events
    let events = azimuth::Span::get_events(span)
    assert_eq(events.length, 3)
    
    for event in events {
      let event_locale = azimuth::SpanEvent::get_attribute(event, "locale")
      assert_eq(event_locale, Some(azimuth::StringValue(expected_locale)))
    }
  }
}

test "localized metric names and descriptions" {
  // Test localized metric names and descriptions
  let provider = azimuth::MeterProvider::default()
  let meter = azimuth::MeterProvider::get_meter(provider, "i18n-metrics")
  
  // Define localized metric configurations
  let metric_configs = [
    {
      "name": "request.count",
      "descriptions": [
        ("en", "Total number of HTTP requests"),
        ("es", "NÃºmero total de solicitudes HTTP"),
        ("fr", "Nombre total de requÃªtes HTTP"),
        ("de", "Gesamtzahl der HTTP-Anfragen"),
        ("ja", "HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ç·æ•°"),
        ("ko", "HTTP ìš”ì²­ì˜ ì´ìˆ˜"),
        ("zh", "HTTPè¯·æ±‚æ€»æ•°"),
        ("ar", "Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø·Ù„Ø¨Ø§Øª HTTP"),
        ("ru", "ĞĞ±Ñ‰ĞµĞµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ HTTP-Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²"),
        ("th", "à¸ˆà¸³à¸™à¸§à¸™à¸„à¸³à¸‚à¸­ HTTP à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”")
      ]
    },
    {
      "name": "response.time",
      "descriptions": [
        ("en", "HTTP response time in milliseconds"),
        ("es", "Tiempo de respuesta HTTP en milisegundos"),
        ("fr", "Temps de rÃ©ponse HTTP en millisecondes"),
        ("de", "HTTP-Antwortzeit in Millisekunden"),
        ("ja", "HTTPå¿œç­”æ™‚é–“ï¼ˆãƒŸãƒªç§’ï¼‰"),
        ("ko", "HTTP ì‘ë‹µ ì‹œê°„(ë°€ë¦¬ì´ˆ)"),
        ("zh", "HTTPå“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰"),
        ("ar", "ÙˆÙ‚Øª Ø§Ø³ØªØ¬Ø§Ø¨Ø© HTTP Ø¨Ø§Ù„Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©"),
        ("ru", "Ğ’Ñ€ĞµĞ¼Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° HTTP Ğ² Ğ¼Ğ¸Ğ»Ğ»Ğ¸ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…"),
        ("th", "à¹€à¸§à¸¥à¸²à¸•à¸­à¸šà¸ªà¸™à¸­à¸‡ HTTP à¹ƒà¸™à¸¡à¸´à¸¥à¸¥à¸´à¸§à¸´à¸™à¸²à¸—à¸µ")
      ]
    },
    {
      "name": "error.rate",
      "descriptions": [
        ("en", "Rate of errors per minute"),
        ("es", "Tasa de errores por minuto"),
        ("fr", "Taux d'erreurs par minute"),
        ("de", "Fehlerrate pro Minute"),
        ("ja", "1åˆ†ã‚ãŸã‚Šã®ã‚¨ãƒ©ãƒ¼ç‡"),
        ("ko", "ë¶„ë‹¹ ì˜¤ë¥˜ìœ¨"),
        ("zh", "æ¯åˆ†é’Ÿé”™è¯¯ç‡"),
        ("ar", "Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©"),
        ("ru", "ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ² Ğ¼Ğ¸Ğ½ÑƒÑ‚Ñƒ"),
        ("th", "à¸­à¸±à¸•à¸£à¸²à¸„à¸§à¸²à¸¡à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¸•à¹ˆà¸­à¸™à¸²à¸—à¸µ")
      ]
    }
  ]
  
  // Create metrics with localized descriptions
  for config in metric_configs {
    let name = config["name"]
    
    // Create metrics with English description as default
    let english_description = match config["descriptions"].find(|(locale, _)| locale == "en") {
      Some((_, desc)) => desc,
      None => "Metric description"
    }
    
    let counter = azimuth::Meter::create_counter(meter, name, english_description, "1")
    
    // Add localized descriptions as attributes
    for (locale, description) in config["descriptions"] {
      let attribute_key = "description." + locale
      azimuth::Counter::add(counter, 0, [(attribute_key, azimuth::StringValue(description))])
    }
    
    // Record some sample data
    azimuth::Counter::add(counter, 10, [
      ("locale", azimuth::StringValue("en")),
      ("endpoint", azimuth::StringValue("/api/test"))
    ])
    
    azimuth::Counter::add(counter, 5, [
      ("locale", azimuth::StringValue("es")),
      ("endpoint", azimuth::StringValue("/api/prueba"))
    ])
  }
  
  // Collect and verify metrics
  let metrics = azimuth::Meter::collect_metrics(meter)
  assert_true(metrics.length >= metric_configs.length)
  
  // Verify localized descriptions are preserved
  for config in metric_configs {
    let name = config["name"]
    let metric_data = azimuth::MetricData::get_by_name(metrics, name)
    
    match metric_data {
      Some(data) => {
        // Verify English description is primary
        let english_desc = match config["descriptions"].find(|(locale, _)| locale == "en") {
          Some((_, desc)) => desc,
          None => ""
        }
        assert_eq(azimuth::MetricData::description(data), Some(english_desc))
        
        // Verify localized descriptions are in attributes
        for (locale, expected_description) in config["descriptions"] {
          if locale != "en" {
            let attribute_key = "description." + locale
            let found_desc = azimuth::MetricData::get_attribute(data, attribute_key)
            assert_eq(found_desc, Some(azimuth::StringValue(expected_description)))
          }
        }
      }
      None => assert_true(false, "Metric not found: " + name)
    }
  }
}