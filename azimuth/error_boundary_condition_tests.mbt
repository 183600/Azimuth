// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿåœ¨å„ç§å¼‚å¸¸æƒ…å†µå’Œè¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º

test "span context validation with invalid inputs" {
  // æµ‹è¯•æ— æ•ˆçš„span contextè¾“å…¥
  
  // ç©ºtrace_id
  let empty_trace_ctx = azimuth::SpanContext::new("", "1234567890abcdef", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_trace_ctx))
  
  // ç©ºspan_id
  let empty_span_ctx = azimuth::SpanContext::new("1234567890abcdef1234567890abcdef", "", true, "")
  assert_false(azimuth::SpanContext::is_valid(empty_span_ctx))
  
  // ä¸¤è€…éƒ½ä¸ºç©º
  let both_empty_ctx = azimuth::SpanContext::new("", "", true, "")
  assert_false(azimuth::SpanContext::is_valid(both_empty_ctx))
  
  // æ— æ•ˆçš„trace_idé•¿åº¦
  let short_trace_ctx = azimuth::SpanContext::new("123", "1234567890abcdef", true, "")
  assert_false(azimuth::SpanContext::is_valid(short_trace_ctx))
  
  // æ— æ•ˆçš„span_idé•¿åº¦
  let short_span_ctx = azimuth::SpanContext::new("1234567890abcdef1234567890abcdef", "123", true, "")
  assert_false(azimuth::SpanContext::is_valid(short_span_ctx))
  
  // æœ‰æ•ˆçš„æƒ…å†µ
  let valid_ctx = azimuth::SpanContext::new("1234567890abcdef1234567890abcdef", "1234567890abcdef", true, "")
  assert_true(azimuth::SpanContext::is_valid(valid_ctx))
}

test "attribute value type conversion edge cases" {
  // æµ‹è¯•å±æ€§å€¼ç±»å‹è½¬æ¢çš„è¾¹ç•Œæƒ…å†µ
  let attrs = azimuth::Attributes::new()
  
  // æå¤§çš„æ•´æ•°å€¼
  azimuth::Attributes::set(attrs, "max.int", azimuth::IntValue(2147483647))
  let max_int = azimuth::Attributes::get(attrs, "max.int")
  assert_eq(max_int, Some(azimuth::IntValue(2147483647)))
  
  // æå°çš„æ•´æ•°å€¼
  azimuth::Attributes::set(attrs, "min.int", azimuth::IntValue(-2147483648))
  let min_int = azimuth::Attributes::get(attrs, "min.int")
  assert_eq(min_int, Some(azimuth::IntValue(-2147483648)))
  
  // æå¤§çš„æµ®ç‚¹æ•°å€¼
  azimuth::Attributes::set(attrs, "max.float", azimuth::FloatValue(1.7976931348623157e+308))
  let max_float = azimuth::Attributes::get(attrs, "max.float")
  assert_eq(max_float, Some(azimuth::FloatValue(1.7976931348623157e+308)))
  
  // æå°çš„æµ®ç‚¹æ•°å€¼
  azimuth::Attributes::set(attrs, "min.float", azimuth::FloatValue(2.2250738585072014e-308))
  let min_float = azimuth::Attributes::get(attrs, "min.float")
  assert_eq(min_float, Some(azimuth::FloatValue(2.2250738585072014e-308)))
  
  // ç©ºå­—ç¬¦ä¸²
  azimuth::Attributes::set(attrs, "empty.string", azimuth::StringValue(""))
  let empty_string = azimuth::Attributes::get(attrs, "empty.string")
  assert_eq(empty_string, Some(azimuth::StringValue("")))
  
  // é•¿å­—ç¬¦ä¸²
  let long_string = "a" * 10000
  azimuth::Attributes::set(attrs, "long.string", azimuth::StringValue(long_string))
  let retrieved_long = azimuth::Attributes::get(attrs, "long.string")
  assert_eq(retrieved_long, Some(azimuth::StringValue(long_string)))
  
  // ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  azimuth::Attributes::set(attrs, "special.chars", azimuth::StringValue(special_chars))
  let retrieved_special = azimuth::Attributes::get(attrs, "special.chars")
  assert_eq(retrieved_special, Some(azimuth::StringValue(special_chars)))
  
  // Unicodeå­—ç¬¦ä¸²
  let unicode_string = "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ ğŸš€ emoji and Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  azimuth::Attributes::set(attrs, "unicode.string", azimuth::StringValue(unicode_string))
  let retrieved_unicode = azimuth::Attributes::get(attrs, "unicode.string")
  assert_eq(retrieved_unicode, Some(azimuth::StringValue(unicode_string)))
}

test "log record boundary conditions" {
  // æµ‹è¯•æ—¥å¿—è®°å½•çš„è¾¹ç•Œæ¡ä»¶
  
  // å„ç§ä¸¥é‡çº§åˆ«
  let trace_record = azimuth::LogRecord::new(azimuth::Trace, "Trace message")
  assert_eq(azimuth::LogRecord::severity_number(trace_record), azimuth::Trace)
  
  let debug_record = azimuth::LogRecord::new(azimuth::Debug, "Debug message")
  assert_eq(azimuth::LogRecord::severity_number(debug_record), azimuth::Debug)
  
  let info_record = azimuth::LogRecord::new(azimuth::Info, "Info message")
  assert_eq(azimuth::LogRecord::severity_number(info_record), azimuth::Info)
  
  let warn_record = azimuth::LogRecord::new(azimuth::Warn, "Warning message")
  assert_eq(azimuth::LogRecord::severity_number(warn_record), azimuth::Warn)
  
  let error_record = azimuth::LogRecord::new(azimuth::Error, "Error message")
  assert_eq(azimuth::LogRecord::severity_number(error_record), azimuth::Error)
  
  let fatal_record = azimuth::LogRecord::new(azimuth::Fatal, "Fatal message")
  assert_eq(azimuth::LogRecord::severity_number(fatal_record), azimuth::Fatal)
  
  // ç©ºæ¶ˆæ¯ä½“
  let empty_body_record = azimuth::LogRecord::new(azimuth::Info, "")
  assert_eq(azimuth::LogRecord::body(empty_body_record), Some(""))
  
  // æé•¿æ¶ˆæ¯ä½“
  let long_message = "x" * 50000
  let long_message_record = azimuth::LogRecord::new(azimuth::Info, long_message)
  assert_eq(azimuth::LogRecord::body(long_message_record), Some(long_message))
  
  // è¾¹ç•Œæ—¶é—´æˆ³
  let min_timestamp = -9223372036854775808L  // Int64æœ€å°å€¼
  let max_timestamp = 9223372036854775807L   // Int64æœ€å¤§å€¼
  
  let min_timestamp_record = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Min timestamp"),
    None,
    Some(min_timestamp),
    None,
    None,
    None,
    None
  )
  
  let max_timestamp_record = azimuth::LogRecord::new_with_context(
    azimuth::Info,
    Some("Max timestamp"),
    None,
    Some(max_timestamp),
    None,
    None,
    None,
    None
  )
  
  // éªŒè¯è®°å½•åˆ›å»ºæˆåŠŸ
  assert_eq(azimuth::LogRecord::body(min_timestamp_record), Some("Min timestamp"))
  assert_eq(azimuth::LogRecord::body(max_timestamp_record), Some("Max timestamp"))
}

test "http client error handling" {
  // æµ‹è¯•HTTPå®¢æˆ·ç«¯çš„é”™è¯¯å¤„ç†
  
  // æ— æ•ˆçš„HTTPæ–¹æ³•
  let invalid_method_request = azimuth::HttpRequest::new(
    "INVALID_METHOD", 
    "https://example.com", 
    []
  )
  assert_eq(azimuth::HttpRequest::http_method(invalid_method_request), "INVALID_METHOD")
  
  // ç©ºURL
  let empty_url_request = azimuth::HttpRequest::new("GET", "", [])
  assert_eq(azimuth::HttpRequest::url(empty_url_request), "")
  
  // æ— æ•ˆçš„çŠ¶æ€ç 
  let invalid_status_response = azimuth::HttpResponse::new(999, [])
  assert_eq(azimuth::HttpResponse::status_code(invalid_status_response), 999)
  
  // è¾¹ç•ŒçŠ¶æ€ç 
  let min_status_response = azimuth::HttpResponse::new(0, [])
  assert_eq(azimuth::HttpResponse::status_code(min_status_response), 0)
  
  let max_status_response = azimuth::HttpResponse::new(9999, [])
  assert_eq(azimuth::HttpResponse::status_code(max_status_response), 9999)
  
  // æ ‡å‡†çŠ¶æ€ç 
  let status_200_response = azimuth::HttpResponse::new(200, [])
  assert_eq(azimuth::HttpResponse::status_code(status_200_response), 200)
  
  let status_404_response = azimuth::HttpResponse::new(404, [])
  assert_eq(azimuth::HttpResponse::status_code(status_404_response), 404)
  
  let status_500_response = azimuth::HttpResponse::new(500, [])
  assert_eq(azimuth::HttpResponse::status_code(status_500_response), 500)
}

test "baggage operations boundary conditions" {
  // æµ‹è¯•baggageæ“ä½œçš„è¾¹ç•Œæ¡ä»¶
  
  // ç©ºé”®
  let baggage = azimuth::Baggage::new()
  let empty_key_baggage = azimuth::Baggage::set_entry(baggage, "", "value")
  let empty_key_value = azimuth::Baggage::get_entry(empty_key_baggage, "")
  // ç®€åŒ–å®ç°å¯èƒ½ä¸å¤„ç†ç©ºé”®ï¼Œä½†åº”è¯¥ä¸ä¼šå´©æºƒ
  
  // ç©ºå€¼
  let empty_value_baggage = azimuth::Baggage::set_entry(baggage, "key", "")
  let empty_value_result = azimuth::Baggage::get_entry(empty_value_baggage, "key")
  // ç®€åŒ–å®ç°å¯èƒ½ä¸å¤„ç†ç©ºå€¼ï¼Œä½†åº”è¯¥ä¸ä¼šå´©æºƒ
  
  // é•¿é”®
  let long_key = "k" * 1000
  let long_key_baggage = azimuth::Baggage::set_entry(baggage, long_key, "value")
  let long_key_result = azimuth::Baggage::get_entry(long_key_baggage, long_key)
  
  // é•¿å€¼
  let long_value = "v" * 1000
  let long_value_baggage = azimuth::Baggage::set_entry(baggage, "key", long_value)
  let long_value_result = azimuth::Baggage::get_entry(long_value_baggage, "key")
  
  // ç‰¹æ®Šå­—ç¬¦é”®å€¼
  let special_key = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_value = "ğŸš€ æµ‹è¯• Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  let special_baggage = azimuth::Baggage::set_entry(baggage, special_key, special_value)
  let special_result = azimuth::Baggage::get_entry(special_baggage, special_key)
  
  // ç§»é™¤ä¸å­˜åœ¨çš„æ¡ç›®
  let non_existent_baggage = azimuth::Baggage::remove_entry(baggage, "non.existent.key")
  let non_existent_result = azimuth::Baggage::get_entry(non_existent_baggage, "non.existent.key")
  assert_eq(non_existent_result, None)
  
  // å¤šæ¬¡è®¾ç½®ç›¸åŒé”®
  let baggage1 = azimuth::Baggage::set_entry(baggage, "duplicate.key", "value1")
  let baggage2 = azimuth::Baggage::set_entry(baggage1, "duplicate.key", "value2")
  let duplicate_result = azimuth::Baggage::get_entry(baggage2, "duplicate.key")
  // ç®€åŒ–å®ç°å¯èƒ½ä¸è¦†ç›–ï¼Œä½†åº”è¯¥ä¸ä¼šå´©æºƒ
}

test "instrument type validation" {
  // æµ‹è¯•ä»ªå™¨ç±»å‹éªŒè¯
  
  // ç©ºåç§°
  let meter = azimuth::MeterProvider::get_meter(
    azimuth::MeterProvider::default(), 
    "test-meter"
  )
  
  let empty_name_counter = azimuth::Meter::create_counter(meter, "")
  assert_eq(empty_name_counter.name, "")
  
  // é•¿åç§°
  let long_name = "instrument.name." + ("very.long." * 100)
  let long_name_counter = azimuth::Meter::create_counter(meter, long_name)
  assert_eq(long_name_counter.name, long_name)
  
  // ç‰¹æ®Šå­—ç¬¦åç§°
  let special_name = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let special_name_counter = azimuth::Meter::create_counter(meter, special_name)
  assert_eq(special_name_counter.name, special_name)
  
  // Unicodeåç§°
  let unicode_name = "æµ‹è¯•ä»ªå™¨åç§° ğŸš€ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  let unicode_name_counter = azimuth::Meter::create_counter(meter, unicode_name)
  assert_eq(unicode_name_counter.name, unicode_name)
  
  // è¾¹ç•Œæè¿°å’Œå•ä½
  let empty_desc_counter = azimuth::Meter::create_counter(meter, "test", Some(""), Some(""))
  assert_eq(empty_desc_counter.description, Some(""))
  assert_eq(empty_desc_counter.unit, Some(""))
  
  let long_desc = "This is a very long description that contains many words and should be handled properly by the system without causing any issues or crashes " + ("extended description " * 100)
  let long_desc_counter = azimuth::Meter::create_counter(meter, "test", Some(long_desc), Some("very-long-unit-name"))
  assert_eq(long_desc_counter.description, Some(long_desc))
  assert_eq(long_desc_counter.unit, Some("very-long-unit-name"))
}