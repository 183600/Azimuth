// Azimuth Internationalization Support Test Suite
// This file contains test cases for internationalization functionality

// Test 1: Unicode character support in spans
test "unicode character support in spans" {
  // Test span creation with Unicode names
  let span_ctx = SpanContext::new("trace-unicode", "span-unicode", true, "")
  
  // Create spans with different Unicode character sets
  let chinese_span = Span::new("ä¸­æ–‡æ“ä½œ", Internal, span_ctx)
  let japanese_span = Span::new("æ—¥æœ¬èªæ“ä½œ", Internal, span_ctx)
  let korean_span = Span::new("í•œêµ­ì–´ ì‘ì—…", Internal, span_ctx)
  let arabic_span = Span::new("Ø¹Ù…Ù„ÙŠØ© Ø¹Ø±Ø¨ÙŠØ©", Internal, span_ctx)
  let russian_span = Span::new("Ñ€ÑƒÑÑĞºĞ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ", Internal, span_ctx)
  let emoji_span = Span::new("emoji operation ğŸš€ğŸ”¥ğŸ’¯", Internal, span_ctx)
  let mixed_span = Span::new("mixed ä¸­æ–‡ ğŸš€ English æ—¥æœ¬èª ğŸ”¥ í•œêµ­ì–´", Internal, span_ctx)
  
  // Verify span names
  assert_eq(Span::name(chinese_span), "ä¸­æ–‡æ“ä½œ")
  assert_eq(Span::name(japanese_span), "æ—¥æœ¬èªæ“ä½œ")
  assert_eq(Span::name(korean_span), "í•œêµ­ì–´ ì‘ì—…")
  assert_eq(Span::name(arabic_span), "Ø¹Ù…Ù„ÙŠØ© Ø¹Ø±Ø¨ÙŠØ©")
  assert_eq(Span::name(russian_span), "Ñ€ÑƒÑÑĞºĞ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ")
  assert_eq(Span::name(emoji_span), "emoji operation ğŸš€ğŸ”¥ğŸ’¯")
  assert_eq(Span::name(mixed_span), "mixed ä¸­æ–‡ ğŸš€ English æ—¥æœ¬èª ğŸ”¥ í•œêµ­ì–´")
  
  // Test span events with Unicode descriptions
  Span::add_event(chinese_span, "ä¸­æ–‡äº‹ä»¶", Some([("ä¸­æ–‡å±æ€§", StringValue("ä¸­æ–‡å€¼"))]))
  Span::add_event(japanese_span, "æ—¥æœ¬èªã‚¤ãƒ™ãƒ³ãƒˆ", Some([("æ—¥æœ¬èªå±æ€§", StringValue("æ—¥æœ¬èªå€¤"))]))
  Span::add_event(korean_span, "í•œêµ­ì–´ ì´ë²¤íŠ¸", Some([("í•œêµ­ì–´ ì†ì„±", StringValue("í•œêµ­ì–´ ê°’"))]))
  Span::add_event(arabic_span, "Ø­Ø¯Ø« Ø¹Ø±Ø¨ÙŠ", Some([("Ø®Ø§ØµÙŠØ© Ø¹Ø±Ø¨ÙŠØ©", StringValue("Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©"))]))
  Span::add_event(russian_span, "Ñ€ÑƒÑÑĞºĞ¾Ğµ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ", Some([("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚", StringValue("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"))]))
  Span::add_event(emoji_span, "emoji event ğŸ‰", Some([("emoji attr", StringValue("emoji value ğŸš€"))]))
  
  // Test span status with Unicode descriptions
  Span::set_status(chinese_span, Ok, Some("ä¸­æ–‡æ“ä½œå®Œæˆ"))
  Span::set_status(japanese_span, Error, Some("æ—¥æœ¬èªæ“ä½œã‚¨ãƒ©ãƒ¼"))
  Span::set_status(korean_span, Ok, Some("í•œêµ­ì–´ ì‘ì—… ì™„ë£Œ"))
  Span::set_status(arabic_span, Error, Some("Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  Span::set_status(russian_span, Ok, Some("Ñ€ÑƒÑÑĞºĞ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°"))
  Span::set_status(emoji_span, Ok, Some("emoji operation complete âœ…"))
  
  // End all spans
  Span::end(chinese_span)
  Span::end(japanese_span)
  Span::end(korean_span)
  Span::end(arabic_span)
  Span::end(russian_span)
  Span::end(emoji_span)
  Span::end(mixed_span)
}

// Test 2: Unicode character support in attributes
test "unicode character support in attributes" {
  // Test attributes with Unicode keys and values
  let attrs = Attributes::new()
  
  // Set attributes with different Unicode character sets
  Attributes::set(attrs, "ä¸­æ–‡é”®", StringValue("ä¸­æ–‡å€¼"))
  Attributes::set(attrs, "æ—¥æœ¬èªã‚­ãƒ¼", StringValue("æ—¥æœ¬èªå€¤"))
  Attributes::set(attrs, "í•œêµ­ì–´ í‚¤", StringValue("í•œêµ­ì–´ ê°’"))
  Attributes::set(attrs, "Ù…ÙØªØ§Ø­ Ø¹Ø±Ø¨ÙŠ", StringValue("Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©"))
  Attributes::set(attrs, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡", StringValue("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"))
  Attributes::set(attrs, "emoji key ğŸš€", StringValue("emoji value ğŸ”¥"))
  
  // Get attributes (simplified implementation returns None for most keys)
  let chinese_value = Attributes::get(attrs, "ä¸­æ–‡é”®")
  let japanese_value = Attributes::get(attrs, "æ—¥æœ¬èªã‚­ãƒ¼")
  let korean_value = Attributes::get(attrs, "í•œêµ­ì–´ í‚¤")
  let arabic_value = Attributes::get(attrs, "Ù…ÙØªØ§Ø­ Ø¹Ø±Ø¨ÙŠ")
  let russian_value = Attributes::get(attrs, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡")
  let emoji_value = Attributes::get(attrs, "emoji key ğŸš€")
  
  // In simplified implementation, these return None
  assert_eq(chinese_value, None)
  assert_eq(japanese_value, None)
  assert_eq(korean_value, None)
  assert_eq(arabic_value, None)
  assert_eq(russian_value, None)
  assert_eq(emoji_value, None)
  
  // Test array attributes with Unicode values
  Attributes::set(attrs, "ä¸­æ–‡æ•°ç»„", ArrayStringValue(["ä¸­æ–‡å€¼1", "ä¸­æ–‡å€¼2", "ä¸­æ–‡å€¼3"]))
  Attributes::set(attrs, "æ—¥æœ¬èªé…åˆ—", ArrayStringValue(["æ—¥æœ¬èªå€¤1", "æ—¥æœ¬èªå€¤2", "æ—¥æœ¬èªå€¤3"]))
  Attributes::set(attrs, "í•œêµ­ì–´ ë°°ì—´", ArrayStringValue(["í•œêµ­ì–´ ê°’1", "í•œêµ­ì–´ ê°’2", "í•œêµ­ì–´ ê°’3"]))
  Attributes::set(attrs, "Ù…ØµÙÙˆÙØ© Ø¹Ø±Ø¨ÙŠØ©", ArrayStringValue(["Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ© 1", "Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ© 2", "Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ© 3"]))
  Attributes::set(attrs, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ğ¼Ğ°ÑÑĞ¸Ğ²", ArrayStringValue(["Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 1", "Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 2", "Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ 3"]))
  Attributes::set(attrs, "emoji array", ArrayStringValue(["emoji 1 ğŸš€", "emoji 2 ğŸ”¥", "emoji 3 ğŸ’¯"]))
}

// Test 3: Unicode character support in context
test "unicode character support in context" {
  // Test context with Unicode keys and values
  let ctx = Context::root()
  
  // Create context keys with Unicode
  let chinese_key = ContextKey::new("ä¸­æ–‡é”®")
  let japanese_key = ContextKey::new("æ—¥æœ¬èªã‚­ãƒ¼")
  let korean_key = ContextKey::new("í•œêµ­ì–´ í‚¤")
  let arabic_key = ContextKey::new("Ù…ÙØªØ§Ø­ Ø¹Ø±Ø¨ÙŠ")
  let russian_key = ContextKey::new("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡")
  let emoji_key = ContextKey::new("emoji key ğŸš€")
  
  // Set context values with Unicode
  let ctx_with_chinese = Context::with_value(ctx, chinese_key, "ä¸­æ–‡å€¼")
  let ctx_with_japanese = Context::with_value(ctx_with_chinese, japanese_key, "æ—¥æœ¬èªå€¤")
  let ctx_with_korean = Context::with_value(ctx_with_japanese, korean_key, "í•œêµ­ì–´ ê°’")
  let ctx_with_arabic = Context::with_value(ctx_with_korean, arabic_key, "Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©")
  let ctx_with_russian = Context::with_value(ctx_with_arabic, russian_key, "Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ")
  let ctx_with_emoji = Context::with_value(ctx_with_russian, emoji_key, "emoji value ğŸ”¥")
  
  // Get context values
  let chinese_value = Context::get(ctx_with_emoji, chinese_key)
  let japanese_value = Context::get(ctx_with_emoji, japanese_key)
  let korean_value = Context::get(ctx_with_emoji, korean_key)
  let arabic_value = Context::get(ctx_with_emoji, arabic_key)
  let russian_value = Context::get(ctx_with_emoji, russian_key)
  let emoji_value = Context::get(ctx_with_emoji, emoji_key)
  
  // Verify context values
  assert_eq(chinese_value, Some("ä¸­æ–‡å€¼"))
  assert_eq(japanese_value, Some("æ—¥æœ¬èªå€¤"))
  assert_eq(korean_value, Some("í•œêµ­ì–´ ê°’"))
  assert_eq(arabic_value, Some("Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq(russian_value, Some("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"))
  assert_eq(emoji_value, Some("emoji value ğŸ”¥"))
}

// Test 4: Unicode character support in baggage
test "unicode character support in baggage" {
  // Test baggage with Unicode keys and values
  let baggage = Baggage::new()
  
  // Set baggage entries with different Unicode character sets
  let baggage_with_chinese = Baggage::set_entry(baggage, "ä¸­æ–‡é”®", "ä¸­æ–‡å€¼")
  let baggage_with_japanese = Baggage::set_entry(baggage_with_chinese, "æ—¥æœ¬èªã‚­ãƒ¼", "æ—¥æœ¬èªå€¤")
  let baggage_with_korean = Baggage::set_entry(baggage_with_japanese, "í•œêµ­ì–´ í‚¤", "í•œêµ­ì–´ ê°’")
  let baggage_with_arabic = Baggage::set_entry(baggage_with_korean, "Ù…ÙØªØ§Ø­ Ø¹Ø±Ø¨ÙŠ", "Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©")
  let baggage_with_russian = Baggage::set_entry(baggage_with_arabic, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡", "Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ")
  let baggage_with_emoji = Baggage::set_entry(baggage_with_russian, "emoji key ğŸš€", "emoji value ğŸ”¥")
  
  // Get baggage entries
  let chinese_value = Baggage::get_entry(baggage_with_emoji, "ä¸­æ–‡é”®")
  let japanese_value = Baggage::get_entry(baggage_with_emoji, "æ—¥æœ¬èªã‚­ãƒ¼")
  let korean_value = Baggage::get_entry(baggage_with_emoji, "í•œêµ­ì–´ í‚¤")
  let arabic_value = Baggage::get_entry(baggage_with_emoji, "Ù…ÙØªØ§Ø­ Ø¹Ø±Ø¨ÙŠ")
  let russian_value = Baggage::get_entry(baggage_with_emoji, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡")
  let emoji_value = Baggage::get_entry(baggage_with_emoji, "emoji key ğŸš€")
  
  // Verify baggage entries
  assert_eq(chinese_value, Some("ä¸­æ–‡å€¼"))
  assert_eq(japanese_value, Some("æ—¥æœ¬èªå€¤"))
  assert_eq(korean_value, Some("í•œêµ­ì–´ ê°’"))
  assert_eq(arabic_value, Some("Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq(russian_value, Some("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ"))
  assert_eq(emoji_value, Some("emoji value ğŸ”¥"))
}

// Test 5: Unicode character support in resources
test "unicode character support in resources" {
  // Test resource with Unicode attributes
  let resource = Resource::new()
  
  // Create resource with Unicode attributes
  let resource_with_unicode = Resource::with_attributes(resource, [
    ("service.name", StringValue("æµ‹è¯•æœåŠ¡")),
    ("service.description", StringValue("è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æœåŠ¡")),
    ("deployment.region", StringValue("ã‚¢ã‚¸ã‚¢")),
    ("host.name", StringValue("ì„œë²„-í•œêµ­")),
    ("os.name", StringValue("Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„")),
    ("process.name", StringValue("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ")),
    ("custom.attribute", StringValue("custom value with emoji ğŸš€"))
  ])
  
  // Get resource attributes
  let service_name = Resource::get_attribute(resource_with_unicode, "service.name")
  let service_description = Resource::get_attribute(resource_with_unicode, "service.description")
  let deployment_region = Resource::get_attribute(resource_with_unicode, "deployment.region")
  let host_name = Resource::get_attribute(resource_with_unicode, "host.name")
  let os_name = Resource::get_attribute(resource_with_unicode, "os.name")
  let process_name = Resource::get_attribute(resource_with_unicode, "process.name")
  let custom_attribute = Resource::get_attribute(resource_with_unicode, "custom.attribute")
  
  // Verify resource attributes
  assert_eq(service_name, Some(StringValue("æµ‹è¯•æœåŠ¡")))
  assert_eq(service_description, Some(StringValue("è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æœåŠ¡")))
  assert_eq(deployment_region, Some(StringValue("ã‚¢ã‚¸ã‚¢")))
  assert_eq(host_name, Some(StringValue("ì„œë²„-í•œêµ­")))
  assert_eq(os_name, Some(StringValue("Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ´ØºÙŠÙ„")))
  assert_eq(process_name, Some(StringValue("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ")))
  assert_eq(custom_attribute, Some(StringValue("custom value with emoji ğŸš€")))
}

// Test 6: Unicode character support in log records
test "unicode character support in log records" {
  // Test log records with Unicode messages
  let chinese_log = LogRecord::new(Info, "ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯")
  let japanese_log = LogRecord::new(Warn, "æ—¥æœ¬èªãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
  let korean_log = LogRecord::new(Error, "í•œêµ­ì–´ ë¡œê·¸ ë©”ì‹œì§€")
  let arabic_log = LogRecord::new(Debug, "Ø±Ø³Ø§Ù„Ø© Ø³Ø¬Ù„ Ø¹Ø±Ø¨ÙŠØ©")
  let russian_log = LogRecord::new(Trace, "Ñ€ÑƒÑÑĞºĞ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¶ÑƒÑ€Ğ½Ğ°Ğ»Ğ°")
  let emoji_log = LogRecord::new(Info, "emoji log message ğŸš€ğŸ”¥ğŸ’¯")
  let mixed_log = LogRecord::new(Error, "mixed language log: ä¸­æ–‡ æ—¥æœ¬ì–´ í•œêµ­Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ğŸŒ")
  
  // Verify log record bodies
  assert_eq(LogRecord::body(chinese_log), Some("ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯"))
  assert_eq(LogRecord::body(japanese_log), Some("æ—¥æœ¬èªãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"))
  assert_eq(LogRecord::body(korean_log), Some("í•œêµ­ì–´ ë¡œê·¸ ë©”ì‹œì§€"))
  assert_eq(LogRecord::body(arabic_log), Some("Ø±Ø³Ø§Ù„Ø© Ø³Ø¬Ù„ Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq(LogRecord::body(russian_log), Some("Ñ€ÑƒÑÑĞºĞ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¶ÑƒÑ€Ğ½Ğ°Ğ»Ğ°"))
  assert_eq(LogRecord::body(emoji_log), Some("emoji log message ğŸš€ğŸ”¥ğŸ’¯"))
  assert_eq(LogRecord::body(mixed_log), Some("mixed language log: ä¸­æ–‡ æ—¥æœ¬ì–´ í•œêµ­Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ğŸŒ"))
  
  // Test log records with Unicode attributes
  let unicode_attrs = Attributes::new()
  Attributes::set(unicode_attrs, "ä¸­æ–‡å±æ€§", StringValue("ä¸­æ–‡å€¼"))
  Attributes::set(unicode_attrs, "æ—¥æœ¬èªå±æ€§", StringValue("æ—¥æœ¬èªå€¤"))
  Attributes::set(unicode_attrs, "í•œêµ­ì–´ ì†ì„±", StringValue("í•œêµ­ì–´ ê°’"))
  
  let log_with_unicode_attrs = LogRecord::new_with_context(
    Error,
    Some("Log with Unicode attributes"),
    Some(unicode_attrs),
    Some(1735689600000000000L),
    Some(1735689600000001000L),
    Some("ä¸­æ–‡è·Ÿè¸ªID"),
    Some("æ—¥æœ¬èªã‚¹ãƒ‘ãƒ³ID"),
    Some(Context::root())
  )
  
  assert_eq(LogRecord::body(log_with_unicode_attrs), Some("Log with Unicode attributes"))
  assert_eq(LogRecord::trace_id(log_with_unicode_attrs), Some("ä¸­æ–‡è·Ÿè¸ªID"))
  assert_eq(LogRecord::span_id(log_with_unicode_attrs), Some("æ—¥æœ¬èªã‚¹ãƒ‘ãƒ³ID"))
}

// Test 7: Unicode character support in instrumentation scopes
test "unicode character support in instrumentation scopes" {
  // Test instrumentation scopes with Unicode names
  let chinese_scope = InstrumentationScope::{ name: "ä¸­æ–‡ç¤ºæ³¢å™¨", version: Some("1.0.0"), schema_url: None }
  let japanese_scope = InstrumentationScope::{ name: "æ—¥æœ¬èªã‚¹ã‚³ãƒ¼ãƒ—", version: Some("1.0.0"), schema_url: None }
  let korean_scope = InstrumentationScope::{ name: "í•œêµ­ì–´ ìŠ¤ì½”í”„", version: Some("1.0.0"), schema_url: None }
  let arabic_scope = InstrumentationScope::{ name: "Ù†Ø·Ø§Ù‚ Ø¹Ø±Ø¨ÙŠ", version: Some("1.0.0"), schema_url: None }
  let russian_scope = InstrumentationScope::{ name: "Ñ€ÑƒÑÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ", version: Some("1.0.0"), schema_url: None }
  let emoji_scope = InstrumentationScope::{ name: "emoji scope ğŸš€", version: Some("1.0.0"), schema_url: None }
  
  // Verify scope names
  assert_eq(chinese_scope.name, "ä¸­æ–‡ç¤ºæ³¢å™¨")
  assert_eq(japanese_scope.name, "æ—¥æœ¬èªã‚¹ã‚³ãƒ¼ãƒ—")
  assert_eq(korean_scope.name, "í•œêµ­ì–´ ìŠ¤ì½”í”„")
  assert_eq(arabic_scope.name, "Ù†Ø·Ø§Ù‚ Ø¹Ø±Ø¨ÙŠ")
  assert_eq(russian_scope.name, "Ñ€ÑƒÑÑĞºĞ°Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ")
  assert_eq(emoji_scope.name, "emoji scope ğŸš€")
  
  // Test scopes with Unicode versions
  let chinese_version_scope = InstrumentationScope::{ name: "scope", version: Some("ä¸­æ–‡ç‰ˆæœ¬1.0"), schema_url: None }
  let japanese_version_scope = InstrumentationScope::{ name: "scope", version: Some("æ—¥æœ¬èªãƒãƒ¼ã‚¸ãƒ§ãƒ³1.0"), schema_url: None }
  let korean_version_scope = InstrumentationScope::{ name: "scope", version: Some("í•œêµ­ì–´ ë²„ì „ 1.0"), schema_url: None }
  
  assert_eq(chinese_version_scope.version, Some("ä¸­æ–‡ç‰ˆæœ¬1.0"))
  assert_eq(japanese_version_scope.version, Some("æ—¥æœ¬èªãƒãƒ¼ã‚¸ãƒ§ãƒ³1.0"))
  assert_eq(korean_version_scope.version, Some("í•œêµ­ì–´ ë²„ì „ 1.0"))
  
  // Test scopes with Unicode schema URLs
  let chinese_schema_scope = InstrumentationScope::{ name: "scope", version: None, schema_url: Some("https://ä¾‹å­.com/ä¸­æ–‡æ¨¡å¼") }
  let japanese_schema_scope = InstrumentationScope::{ name: "scope", version: None, schema_url: Some("https://ä¾‹ãˆ.com/æ—¥æœ¬èªã‚¹ã‚­ãƒ¼ãƒ") }
  let korean_schema_scope = InstrumentationScope::{ name: "scope", version: None, schema_url: Some("https://ì˜ˆì‹œ.com/í•œêµ­ì–´ìŠ¤í‚¤ë§ˆ") }
  
  assert_eq(chinese_schema_scope.schema_url, Some("https://ä¾‹å­.com/ä¸­æ–‡æ¨¡å¼"))
  assert_eq(japanese_schema_scope.schema_url, Some("https://ä¾‹ãˆ.com/æ—¥æœ¬èªã‚¹ã‚­ãƒ¼ãƒ"))
  assert_eq(korean_schema_scope.schema_url, Some("https://ì˜ˆì‹œ.com/í•œêµ­ì–´ìŠ¤í‚¤ë§ˆ"))
}

// Test 8: Unicode character support in HTTP operations
test "unicode character support in http operations" {
  // Test HTTP requests with Unicode URLs and headers
  let chinese_request = HttpRequest::new("GET", "https://ä¾‹å­.com/ä¸­æ–‡è·¯å¾„", [("ä¸­æ–‡å¤´", "ä¸­æ–‡å€¼")], Some("ä¸­æ–‡æ­£æ–‡"))
  let japanese_request = HttpRequest::new("POST", "https://ä¾‹ãˆ.com/æ—¥æœ¬èªãƒ‘ã‚¹", [("æ—¥æœ¬èªãƒ˜ãƒƒãƒ€ãƒ¼", "æ—¥æœ¬èªå€¤")], Some("æ—¥æœ¬èªæœ¬æ–‡"))
  let korean_request = HttpRequest::new("PUT", "https://ì˜ˆì‹œ.com/í•œêµ­ì–´ ê²½ë¡œ", [("í•œêµ­ì–´ í—¤ë”", "í•œêµ­ì–´ ê°’")], Some("í•œêµ­ì–´ ë³¸ë¬¸"))
  let arabic_request = HttpRequest::new("DELETE", "https://Ù…Ø«Ø§Ù„.com/Ù…Ø³Ø§Ø± Ø¹Ø±Ø¨ÙŠ", [("Ø±Ø£Ø³ Ø¹Ø±Ø¨ÙŠ", "Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©")], Some("Ø¬Ø³Ù… Ø¹Ø±Ø¨ÙŠ"))
  let russian_request = HttpRequest::new("PATCH", "https://Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€.com/Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ğ¿ÑƒÑ‚ÑŒ", [("Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº", "Ñ€ÑƒÑÑĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ")], Some("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ñ‚ĞµĞ»Ğ¾"))
  let emoji_request = HttpRequest::new("GET", "https://example.com/emoji/path ğŸš€", [("emoji header ğŸ”¥", "emoji value ğŸ’¯")], Some("emoji body ğŸ‰"))
  
  // Verify request properties
  assert_eq(HttpRequest::http_method(chinese_request), "GET")
  assert_eq(HttpRequest::url(chinese_request), "https://ä¾‹å­.com/ä¸­æ–‡è·¯å¾„")
  assert_eq(HttpRequest::body(chinese_request), Some("ä¸­æ–‡æ­£æ–‡"))
  
  assert_eq(HttpRequest::http_method(japanese_request), "POST")
  assert_eq(HttpRequest::url(japanese_request), "https://ä¾‹ãˆ.com/æ—¥æœ¬èªãƒ‘ã‚¹")
  assert_eq(HttpRequest::body(japanese_request), Some("æ—¥æœ¬èªæœ¬æ–‡"))
  
  assert_eq(HttpRequest::http_method(korean_request), "PUT")
  assert_eq(HttpRequest::url(korean_request), "https://ì˜ˆì‹œ.com/í•œêµ­ì–´ ê²½ë¡œ")
  assert_eq(HttpRequest::body(korean_request), Some("í•œêµ­ì–´ ë³¸ë¬¸"))
  
  assert_eq(HttpRequest::http_method(arabic_request), "DELETE")
  assert_eq(HttpRequest::url(arabic_request), "https://Ù…Ø«Ø§Ù„.com/Ù…Ø³Ø§Ø± Ø¹Ø±Ø¨ÙŠ")
  assert_eq(HttpRequest::body(arabic_request), Some("Ø¬Ø³Ù… Ø¹Ø±Ø¨ÙŠ"))
  
  assert_eq(HttpRequest::http_method(russian_request), "PATCH")
  assert_eq(HttpRequest::url(russian_request), "https://Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€.com/Ñ€ÑƒÑÑĞºĞ¸Ğ¹ Ğ¿ÑƒÑ‚ÑŒ")
  assert_eq(HttpRequest::body(russian_request), Some("Ñ€ÑƒÑÑĞºĞ¾Ğµ Ñ‚ĞµĞ»Ğ¾"))
  
  assert_eq(HttpRequest::http_method(emoji_request), "GET")
  assert_eq(HttpRequest::url(emoji_request), "https://example.com/emoji/path ğŸš€")
  assert_eq(HttpRequest::body(emoji_request), Some("emoji body ğŸ‰"))
  
  // Test HTTP responses with Unicode bodies
  let chinese_response = HttpResponse::new(200, [("Content-Type", "application/json")], Some("{\"message\":\"ä¸­æ–‡å“åº”\"}"))
  let japanese_response = HttpResponse::new(404, [("Content-Type", "application/json")], Some("{\"error\":\"æ—¥æœ¬èªã‚¨ãƒ©ãƒ¼\"}"))
  let korean_response = HttpResponse::new(500, [("Content-Type", "application/json")], Some("{\"error\":\"í•œêµ­ì–´ ì˜¤ë¥˜\"}"))
  let arabic_response = HttpResponse::new(200, [("Content-Type", "application/json")], Some("{\"message\":\"Ø±Ø³Ø§Ù„Ø© Ø¹Ø±Ø¨ÙŠØ©\"}"))
  let russian_response = HttpResponse::new(201, [("Content-Type", "application/json")], Some("{\"message\":\"Ñ€ÑƒÑÑĞºĞ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ\"}"))
  let emoji_response = HttpResponse::new(200, [("Content-Type", "application/json")], Some("{\"message\":\"emoji response ğŸš€\"}"))
  
  // Verify response properties
  assert_eq(HttpResponse::status_code(chinese_response), 200)
  assert_eq(HttpResponse::body(chinese_response), Some("{\"message\":\"ä¸­æ–‡å“åº”\"}"))
  
  assert_eq(HttpResponse::status_code(japanese_response), 404)
  assert_eq(HttpResponse::body(japanese_response), Some("{\"error\":\"æ—¥æœ¬èªã‚¨ãƒ©ãƒ¼\"}"))
  
  assert_eq(HttpResponse::status_code(korean_response), 500)
  assert_eq(HttpResponse::body(korean_response), Some("{\"error\":\"í•œêµ­ì–´ ì˜¤ë¥˜\"}"))
  
  assert_eq(HttpResponse::status_code(arabic_response), 200)
  assert_eq(HttpResponse::body(arabic_response), Some("{\"message\":\"Ø±Ø³Ø§Ù„Ø© Ø¹Ø±Ø¨ÙŠØ©\"}"))
  
  assert_eq(HttpResponse::status_code(russian_response), 201)
  assert_eq(HttpResponse::body(russian_response), Some("{\"message\":\"Ñ€ÑƒÑÑĞºĞ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ\"}"))
  
  assert_eq(HttpResponse::status_code(emoji_response), 200)
  assert_eq(HttpResponse::body(emoji_response), Some("{\"message\":\"emoji response ğŸš€\"}"))
}

// Test 9: Unicode character support in metrics
test "unicode character support in metrics" {
  // Test metrics with Unicode names
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "å›½é™…åŒ–ä»ªè¡¨")
  
  // Create instruments with Unicode names
  let chinese_counter = Meter::create_counter(meter, "ä¸­æ–‡è®¡æ•°å™¨", Some("ä¸­æ–‡è®¡æ•°å™¨æè¿°"), Some("ä¸­æ–‡å•ä½"))
  let japanese_histogram = Meter::create_histogram(meter, "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ", Some("æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®èª¬æ˜"), Some("æ—¥æœ¬èªå˜ä½"))
  let korean_gauge = Meter::create_gauge(meter, "í•œêµ­ì–´ ê²Œì´ì§€", Some("í•œêµ­ì–´ ê²Œì´ì§€ ì„¤ëª…"), Some("í•œêµ­ì–´ ë‹¨ìœ„"))
  let arabic_updown_counter = Meter::create_updown_counter(meter, "Ø¹Ø¯Ø§Ø¯ Ø¹Ø±Ø¨ÙŠ", Some("ÙˆØµÙ Ø§Ù„Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¹Ø±Ø¨ÙŠ"), Some("ÙˆØ­Ø¯Ø© Ø¹Ø±Ø¨ÙŠØ©"))
  let russian_counter = Meter::create_counter(meter, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº", Some("Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ€ÑƒÑÑĞºĞ¾Ğ³Ğ¾ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ°"), Some("Ñ€ÑƒÑÑĞºĞ°Ñ ĞµĞ´Ğ¸Ğ½Ğ¸Ñ†Ğ°"))
  let emoji_instrument = Meter::create_histogram(meter, "emoji instrument ğŸš€", Some("emoji instrument description ğŸ”¥"), Some("emoji unit ğŸ’¯"))
  
  // Verify instrument names
  assert_eq(chinese_counter.name, "ä¸­æ–‡è®¡æ•°å™¨")
  assert_eq(japanese_histogram.name, "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ")
  assert_eq(korean_gauge.name, "í•œêµ­ì–´ ê²Œì´ì§€")
  assert_eq(arabic_updown_counter.name, "Ø¹Ø¯Ø§Ø¯ Ø¹Ø±Ø¨ÙŠ")
  assert_eq(russian_counter.name, "Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸Ğº")
  assert_eq(emoji_instrument.name, "emoji instrument ğŸš€")
  
  // Verify instrument descriptions
  assert_eq(chinese_counter.description, Some("ä¸­æ–‡è®¡æ•°å™¨æè¿°"))
  assert_eq(japanese_histogram.description, Some("æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®èª¬æ˜"))
  assert_eq(korean_gauge.description, Some("í•œêµ­ì–´ ê²Œì´ì§€ ì„¤ëª…"))
  assert_eq(arabic_updown_counter.description, Some("ÙˆØµÙ Ø§Ù„Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¹Ø±Ø¨ÙŠ"))
  assert_eq(russian_counter.description, Some("Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ€ÑƒÑÑĞºĞ¾Ğ³Ğ¾ ÑÑ‡ĞµÑ‚Ñ‡Ğ¸ĞºĞ°"))
  assert_eq(emoji_instrument.description, Some("emoji instrument description ğŸ”¥"))
  
  // Verify instrument units
  assert_eq(chinese_counter.unit, Some("ä¸­æ–‡å•ä½"))
  assert_eq(japanese_histogram.unit, Some("æ—¥æœ¬èªå˜ä½"))
  assert_eq(korean_gauge.unit, Some("í•œêµ­ì–´ ë‹¨ìœ„"))
  assert_eq(arabic_updown_counter.unit, Some("ÙˆØ­Ø¯Ø© Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq(russian_counter.unit, Some("Ñ€ÑƒÑÑĞºĞ°Ñ ĞµĞ´Ğ¸Ğ½Ğ¸Ñ†Ğ°"))
  assert_eq(emoji_instrument.unit, Some("emoji unit ğŸ’¯"))
  
  // Test metric operations with Unicode attributes
  let unicode_attrs = Attributes::new()
  Attributes::set(unicode_attrs, "ä¸­æ–‡æ ‡ç­¾", StringValue("ä¸­æ–‡å€¼"))
  Attributes::set(unicode_attrs, "æ—¥æœ¬èªã‚¿ã‚°", StringValue("æ—¥æœ¬èªå€¤"))
  Attributes::set(unicode_attrs, "í•œêµ­ì–´ íƒœê·¸", StringValue("í•œêµ­ì–´ ê°’"))
  
  Counter::add(chinese_counter, 1.0)
  Histogram::record(japanese_histogram, 2.0)
  UpDownCounter::add(arabic_updown_counter, 3.0)
}

// Test 10: Complex internationalization scenarios
test "complex internationalization scenarios" {
  // Test mixed language telemetry scenario
  let tracer_provider = TracerProvider::default()
  let meter_provider = MeterProvider::default()
  let logger_provider = LoggerProvider::default()
  
  let tracer = TracerProvider::get_tracer(tracer_provider, "æ··åˆè¯­è¨€è¿½è¸ªå™¨")
  let meter = MeterProvider::get_meter(meter_provider, "æ··åˆè¯­è¨€ä»ªè¡¨")
  let logger = LoggerProvider::get_logger(logger_provider, "æ··åˆè¯­è¨€è®°å½•å™¨")
  
  // Create span with mixed language name
  let mixed_span = Tracer::start_span(tracer, "mixed operation ä¸­æ–‡æ“ä½œ æ—¥æœ¬èªæ“ä½œ í•œêµ­ì–´ ì‘ì—…")
  
  // Add events with different languages
  Span::add_event(mixed_span, "event started", Some([
    ("ä¸­æ–‡æè¿°", StringValue("äº‹ä»¶å·²å¼€å§‹")),
    ("æ—¥æœ¬èªèª¬æ˜", StringValue("ã‚¤ãƒ™ãƒ³ãƒˆãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ")),
    ("í•œêµ­ì–´ ì„¤ëª…", StringValue("ì´ë²¤íŠ¸ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤"))
  ]))
  
  // Set status with mixed language description
  Span::set_status(mixed_span, Ok, Some("æ“ä½œå®Œæˆ Operation completed æ“ä½œå®Œäº† ì‘ì—… ì™„ë£Œ"))
  
  // Create metrics with mixed language names
  let mixed_counter = Meter::create_counter(meter, "mixed counter æ··åˆè®¡å™¨ ãƒŸãƒƒã‚¯ã‚¹ã‚«ã‚¦ãƒ³í„° í˜¼í•© ê³„ìˆ˜ê¸°")
  
  // Create log record with mixed language message
  let mixed_log = LogRecord::new(Info, "Mixed language log: ä¸­æ–‡æ—¥å¿— æ—¥æœ¬èªë¡œê·¸ í•œêµ­ì–´ ë¡œê·¸ ğŸŒ")
  
  // Create baggage with mixed language entries
  let baggage = Baggage::new()
  let mixed_baggage = Baggage::set_entry(baggage, "user.locale", "zh-CN")
  let mixed_baggage2 = Baggage::set_entry(mixed_baggage, "user.region", "ã‚¢ã‚¸ã‚¢")
  let mixed_baggage3 = Baggage::set_entry(mixed_baggage2, "user.timezone", "í•œêµ­ í‘œì¤€ì‹œ")
  
  // Create context with mixed language values
  let ctx = Context::root()
  let locale_key = ContextKey::new("locale.info")
  let mixed_ctx = Context::with_value(ctx, locale_key, "ç”¨æˆ·ä¿¡æ¯: ä¸­æ–‡ æ—¥æœ¬èª í•œêµ­ì–´")
  
  // Create resource with mixed language attributes
  let resource = Resource::new()
  let mixed_resource = Resource::with_attributes(resource, [
    ("service.name", StringValue("å›½é™…åŒ–æœåŠ¡")),
    ("service.description", StringValue("Internationalization service: å›½éš›åŒ–ã‚µãƒ¼ãƒ“ã‚¹ êµ­ì œí™” ì„œë¹„ìŠ¤")),
    ("deployment.region", StringValue("Asia-Pacific: ã‚¢ã‚¸ã‚¢å¤ªå¹³æ´‹ ì•„ì‹œì•„ íƒœí‰ì–‘"))
  ])
  
  // End span and emit log
  Span::end(mixed_span)
  Logger::emit(logger, mixed_log)
  
  // Verify all mixed language operations
  assert_eq(Span::name(mixed_span), "mixed operation ä¸­æ–‡æ“ä½œ æ—¥æœ¬èªæ“ä½œ í•œêµ­ì–´ ì‘ì—…")
  assert_eq(mixed_counter.name, "mixed counter æ··åˆè®¡å™¨ ãƒŸãƒƒã‚¯ã‚¹ã‚«ã‚¦ãƒ³í„° í˜¼í•© ê³„ìˆ˜ê¸°")
  assert_eq(LogRecord::body(mixed_log), Some("Mixed language log: ä¸­æ–‡æ—¥å¿— æ—¥æœ¬èªë¡œê·¸ í•œêµ­ì–´ ë¡œê·¸ ğŸŒ"))
  assert_eq(Baggage::get_entry(mixed_baggage3, "user.locale"), Some("zh-CN"))
  assert_eq(Baggage::get_entry(mixed_baggage3, "user.region"), Some("ã‚¢ã‚¸ã‚¢"))
  assert_eq(Baggage::get_entry(mixed_baggage3, "user.timezone"), Some("í•œêµ­ í‘œì¤€ì‹œ"))
  assert_eq(Context::get(mixed_ctx, locale_key), Some("ç”¨æˆ·ä¿¡æ¯: ä¸­æ–‡ æ—¥æœ¬èª í•œêµ­ì–´"))
  assert_eq(Resource::get_attribute(mixed_resource, "service.name"), Some(StringValue("å›½é™…åŒ–æœåŠ¡")))
}