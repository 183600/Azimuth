// Azimuth Internationalization and Localization Tests
// å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æ”¯æŒæµ‹è¯•å¥—ä»¶

// Test 1: å¤šè¯­è¨€æ¶ˆæ¯ç¿»è¯‘
test "multi-language message translation" {
  // å¤šè¯­è¨€æ¶ˆæ¯å­—å…¸
  let message_translations = {
    "en": {
      "system_status": "System Status",
      "cpu_usage": "CPU Usage",
      "memory_usage": "Memory Usage",
      "error_occurred": "An error occurred",
      "warning_threshold": "Warning threshold exceeded",
      "critical_alert": "Critical alert triggered",
      "operation_successful": "Operation completed successfully",
      "operation_failed": "Operation failed",
      "loading_data": "Loading data...",
      "no_data_available": "No data available"
    },
    "zh": {
      "system_status": "ç³»ç»ŸçŠ¶æ€",
      "cpu_usage": "CPUä½¿ç”¨ç‡",
      "memory_usage": "å†…å­˜ä½¿ç”¨ç‡",
      "error_occurred": "å‘ç”Ÿé”™è¯¯",
      "warning_threshold": "è¶…è¿‡è­¦å‘Šé˜ˆå€¼",
      "critical_alert": "è§¦å‘ä¸¥é‡å‘Šè­¦",
      "operation_successful": "æ“ä½œæˆåŠŸå®Œæˆ",
      "operation_failed": "æ“ä½œå¤±è´¥",
      "loading_data": "æ­£åœ¨åŠ è½½æ•°æ®...",
      "no_data_available": "æ— å¯ç”¨æ•°æ®"
    },
    "ja": {
      "system_status": "ã‚·ã‚¹ãƒ†ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹",
      "cpu_usage": "CPUä½¿ç”¨ç‡",
      "memory_usage": "ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡",
      "error_occurred": "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ",
      "warning_threshold": "è­¦å‘Šã—ãã„å€¤ã‚’è¶…ãˆã¾ã—ãŸ",
      "critical_alert": "é‡å¤§ãªã‚¢ãƒ©ãƒ¼ãƒˆãŒãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã¾ã—ãŸ",
      "operation_successful": "æ“ä½œãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ",
      "operation_failed": "æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ",
      "loading_data": "ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...",
      "no_data_available": "åˆ©ç”¨å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“"
    },
    "es": {
      "system_status": "Estado del Sistema",
      "cpu_usage": "Uso de CPU",
      "memory_usage": "Uso de Memoria",
      "error_occurred": "OcurriÃ³ un error",
      "warning_threshold": "Umbral de advertencia excedido",
      "critical_alert": "Alerta crÃ­tica activada",
      "operation_successful": "OperaciÃ³n completada exitosamente",
      "operation_failed": "OperaciÃ³n fallida",
      "loading_data": "Cargando datos...",
      "no_data_available": "No hay datos disponibles"
    }
  }
  
  // ç¿»è¯‘å‡½æ•°
  let translate = fn(key, language) {
    let translations = message_translations[language]
    if translations && translations[key] {
      translations[key]
    } else {
      // å›é€€åˆ°è‹±è¯­
      let english_translations = message_translations["en"]
      english_translations[key] ?? key
    }
  }
  
  // æµ‹è¯•å„ç§è¯­è¨€çš„ç¿»è¯‘
  let test_keys = ["system_status", "cpu_usage", "error_occurred", "operation_successful"]
  let test_languages = ["en", "zh", "ja", "es"]
  
  // éªŒè¯ç¿»è¯‘ç»“æœ
  for language in test_languages {
    for key in test_keys {
      let translation = translate(key, language)
      assert_true(translation.length() > 0, "ç¿»è¯‘ç»“æœä¸åº”ä¸ºç©º: " + language + "." + key)
      assert_not_eq(translation, key, "ç¿»è¯‘ç»“æœåº”è¯¥ä¸åŒäºåŸå§‹é”®: " + language + "." + key)
    }
  }
  
  // éªŒè¯ç‰¹å®šç¿»è¯‘
  assert_eq(translate("system_status", "en"), "System Status")
  assert_eq(translate("system_status", "zh"), "ç³»ç»ŸçŠ¶æ€")
  assert_eq(translate("system_status", "ja"), "ã‚·ã‚¹ãƒ†ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹")
  assert_eq(translate("system_status", "es"), "Estado del Sistema")
  
  // æµ‹è¯•å›é€€æœºåˆ¶
  let non_existent_key = "non_existent_key"
  assert_eq(translate(non_existent_key, "zh"), non_existent_key, "ä¸å­˜åœ¨çš„é”®åº”è¯¥å›é€€åˆ°åŸå§‹é”®")
  
  let non_existent_language = "fr"
  assert_eq(translate("system_status", non_existent_language), "System Status", "ä¸å­˜åœ¨çš„è¯­è¨€åº”è¯¥å›é€€åˆ°è‹±è¯­")
}

// Test 2: æ•°å­—æ ¼å¼åŒ–å’Œæœ¬åœ°åŒ–
test "number formatting and localization" {
  // æ•°å­—æ ¼å¼åŒ–é…ç½®
  let number_formats = {
    "en": {
      "decimal_separator": ".",
      "thousands_separator": ",",
      "currency_symbol": "$",
      "currency_position": "before"
    },
    "zh": {
      "decimal_separator": ".",
      "thousands_separator": ",",
      "currency_symbol": "Â¥",
      "currency_position": "before"
    },
    "de": {
      "decimal_separator": ",",
      "thousands_separator": ".",
      "currency_symbol": "â‚¬",
      "currency_position": "after"
    },
    "fr": {
      "decimal_separator": ",",
      "thousands_separator": " ",
      "currency_symbol": "â‚¬",
      "currency_position": "after"
    }
  }
  
  // æ•°å­—æ ¼å¼åŒ–å‡½æ•°
  let format_number = fn(number, decimals, locale) {
    let format = number_formats[locale] ?? number_formats["en"]
    let decimal_separator = format["decimal_separator"]
    let thousands_separator = format["thousands_separator"]
    
    // ç®€åŒ–çš„æ•°å­—æ ¼å¼åŒ–å®ç°
    let number_str = @lib.string.format(number, "." + decimals.to_string() + "f")
    let parts = number_str.split(".")
    
    let integer_part = parts[0]
    let decimal_part = parts.length() > 1 ? parts[1] : ""
    
    // æ·»åŠ åƒä½åˆ†éš”ç¬¦
    let formatted_integer = ""
    let mut digit_count = 0
    for i in integer_part.length() - 1..=0 {
      let digit = integer_part[i]
      formatted_integer = digit + formatted_integer
      digit_count = digit_count + 1
      
      if digit_count % 3 == 0 && i > 0 {
        formatted_integer = thousands_separator + formatted_integer
      }
    }
    
    // ç»„åˆæ•´æ•°å’Œå°æ•°éƒ¨åˆ†
    if decimal_part.length() > 0 {
      formatted_integer + decimal_separator + decimal_part
    } else {
      formatted_integer
    }
  }
  
  // è´§å¸æ ¼å¼åŒ–å‡½æ•°
  let format_currency = fn(amount, locale) {
    let format = number_formats[locale] ?? number_formats["en"]
    let formatted_number = format_number(amount, 2, locale)
    let currency_symbol = format["currency_symbol"]
    let currency_position = format["currency_position"]
    
    if currency_position == "before" {
      currency_symbol + formatted_number
    } else {
      formatted_number + " " + currency_symbol
    }
  }
  
  // æµ‹è¯•æ•°å­—æ ¼å¼åŒ–
  let test_number = 1234567.8912
  
  let en_formatted = format_number(test_number, 2, "en")
  let zh_formatted = format_number(test_number, 2, "zh")
  let de_formatted = format_number(test_number, 2, "de")
  let fr_formatted = format_number(test_number, 2, "fr")
  
  // éªŒè¯æ•°å­—æ ¼å¼åŒ–ç»“æœ
  assert_eq(en_formatted, "1,234,567.89", "è‹±è¯­æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(zh_formatted, "1,234,567.89", "ä¸­æ–‡æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(de_formatted, "1.234.567,89", "å¾·è¯­æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(fr_formatted, "1 234 567,89", "æ³•è¯­æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  
  // æµ‹è¯•è´§å¸æ ¼å¼åŒ–
  let test_amount = 1234.56
  
  let en_currency = format_currency(test_amount, "en")
  let zh_currency = format_currency(test_amount, "zh")
  let de_currency = format_currency(test_amount, "de")
  let fr_currency = format_currency(test_amount, "fr")
  
  // éªŒè¯è´§å¸æ ¼å¼åŒ–ç»“æœ
  assert_eq(en_currency, "$1,234.56", "è‹±è¯­è´§å¸æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(zh_currency, "Â¥1,234.56", "ä¸­æ–‡è´§å¸æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(de_currency, "1.234,56 â‚¬", "å¾·è¯­è´§å¸æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(fr_currency, "1 234,56 â‚¬", "æ³•è¯­è´§å¸æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
}

// Test 3: æ—¥æœŸå’Œæ—¶é—´æœ¬åœ°åŒ–
test "date and time localization" {
  // æ—¥æœŸæ—¶é—´æ ¼å¼é…ç½®
  let datetime_formats = {
    "en": {
      "date_format": "MM/DD/YYYY",
      "time_format": "h:mm:ss A",
      "datetime_format": "MM/DD/YYYY h:mm:ss A",
      "timezone": "UTC"
    },
    "zh": {
      "date_format": "YYYYå¹´MMæœˆDDæ—¥",
      "time_format": "HH:mm:ss",
      "datetime_format": "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss",
      "timezone": "Asia/Shanghai"
    },
    "ja": {
      "date_format": "YYYY/MM/DD",
      "time_format": "HH:mm:ss",
      "datetime_format": "YYYY/MM/DD HH:mm:ss",
      "timezone": "Asia/Tokyo"
    },
    "de": {
      "date_format": "DD.MM.YYYY",
      "time_format": "HH:mm:ss",
      "datetime_format": "DD.MM.YYYY HH:mm:ss",
      "timezone": "Europe/Berlin"
    }
  }
  
  // æ—¶åŒºåç§»é‡ï¼ˆåˆ†é’Ÿï¼‰
  let timezone_offsets = {
    "UTC": 0,
    "Asia/Shanghai": 480,  // UTC+8
    "Asia/Tokyo": 540,     // UTC+9
    "Europe/Berlin": 60    // UTC+1
  }
  
  // æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–å‡½æ•°
  let format_datetime = fn(timestamp, format_type, locale) {
    let formats = datetime_formats[locale] ?? datetime_formats["en"]
    let format_key = format_type + "_format"
    let format_string = formats[format_key]
    let timezone = formats["timezone"]
    
    // è½¬æ¢æ—¶åŒº
    let timezone_offset = timezone_offsets[timezone] ?? 0
    let adjusted_timestamp = timestamp + timezone_offset * 60
    
    // ç®€åŒ–çš„æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–ï¼ˆå®é™…å®ç°ä¼šä½¿ç”¨æ—¥æœŸæ—¶é—´åº“ï¼‰
    let date = @lib.date.from_timestamp(adjusted_timestamp)
    let year = date.year
    let month = date.month
    let day = date.day
    let hour = date.hour
    let minute = date.minute
    let second = date.second
    
    // æ ¹æ®æ ¼å¼å­—ç¬¦ä¸²æ ¼å¼åŒ–
    match locale {
      "en" => {
        if format_type == "date" {
          month.to_string() + "/" + day.to_string() + "/" + year.to_string()
        } else if format_type == "time" {
          let hour_12 = if hour > 12 { hour - 12 } else if hour == 0 { 12 } else { hour }
          let am_pm = if hour >= 12 { "PM" } else { "AM" }
          hour_12.to_string() + ":" + minute.to_string() + ":" + second.to_string() + " " + am_pm
        } else {
          month.to_string() + "/" + day.to_string() + "/" + year.to_string() + " " + 
          hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
        }
      }
      "zh" => {
        if format_type == "date" {
          year.to_string() + "å¹´" + month.to_string() + "æœˆ" + day.to_string() + "æ—¥"
        } else if format_type == "time" {
          hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
        } else {
          year.to_string() + "å¹´" + month.to_string() + "æœˆ" + day.to_string() + "æ—¥ " + 
          hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
        }
      }
      "ja" => {
        if format_type == "date" {
          year.to_string() + "/" + month.to_string() + "/" + day.to_string()
        } else if format_type == "time" {
          hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
        } else {
          year.to_string() + "/" + month.to_string() + "/" + day.to_string() + " " + 
          hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
        }
      }
      "de" => {
        if format_type == "date" {
          day.to_string() + "." + month.to_string() + "." + year.to_string()
        } else if format_type == "time" {
          hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
        } else {
          day.to_string() + "." + month.to_string() + "." + year.to_string() + " " + 
          hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
        }
      }
      _ => {
        year.to_string() + "-" + month.to_string() + "-" + day.to_string() + " " + 
        hour.to_string() + ":" + minute.to_string() + ":" + second.to_string()
      }
    }
  }
  
  // æµ‹è¯•æ—¶é—´æˆ³ï¼ˆ2022-01-01 12:00:00 UTCï¼‰
  let test_timestamp = 1640995200
  
  // æµ‹è¯•æ—¥æœŸæ ¼å¼åŒ–
  let en_date = format_datetime(test_timestamp, "date", "en")
  let zh_date = format_datetime(test_timestamp, "date", "zh")
  let ja_date = format_datetime(test_timestamp, "date", "ja")
  let de_date = format_datetime(test_timestamp, "date", "de")
  
  // éªŒè¯æ—¥æœŸæ ¼å¼åŒ–ç»“æœï¼ˆè€ƒè™‘æ—¶åŒºå·®å¼‚ï¼‰
  assert_eq(en_date, "1/1/2022", "è‹±è¯­æ—¥æœŸæ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(zh_date, "2022å¹´1æœˆ1æ—¥", "ä¸­æ–‡æ—¥æœŸæ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(ja_date, "2022/01/01", "æ—¥è¯­æ—¥æœŸæ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(de_date, "1.1.2022", "å¾·è¯­æ—¥æœŸæ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  
  // æµ‹è¯•æ—¶é—´æ ¼å¼åŒ–
  let en_time = format_datetime(test_timestamp, "time", "en")
  let zh_time = format_datetime(test_timestamp, "time", "zh")
  let ja_time = format_datetime(test_timestamp, "time", "ja")
  let de_time = format_datetime(test_timestamp, "time", "de")
  
  // éªŒè¯æ—¶é—´æ ¼å¼åŒ–ç»“æœï¼ˆè€ƒè™‘æ—¶åŒºå·®å¼‚ï¼‰
  assert_eq(en_time, "12:00:00 PM", "è‹±è¯­æ—¶é—´æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®")
  assert_eq(zh_time, "20:00:00", "ä¸­æ–‡æ—¶é—´æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®ï¼ˆUTC+8ï¼‰")
  assert_eq(ja_time, "21:00:00", "æ—¥è¯­æ—¶é—´æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®ï¼ˆUTC+9ï¼‰")
  assert_eq(de_time, "13:00:00", "å¾·è¯­æ—¶é—´æ ¼å¼åŒ–åº”è¯¥æ­£ç¡®ï¼ˆUTC+1ï¼‰")
}

// Test 4: åº¦é‡å•ä½æœ¬åœ°åŒ–
test "measurement units localization" {
  // åº¦é‡å•ä½é…ç½®
  let measurement_units = {
    "en": {
      "length": {"km": "km", "m": "m", "cm": "cm", "in": "in", "ft": "ft"},
      "weight": {"kg": "kg", "g": "g", "lb": "lb", "oz": "oz"},
      "temperature": {"celsius": "Â°C", "fahrenheit": "Â°F", "kelvin": "K"},
      "data": {"byte": "B", "kilobyte": "KB", "megabyte": "MB", "gigabyte": "GB"},
      "speed": {"kmh": "km/h", "mph": "mph", "ms": "m/s"}
    },
    "zh": {
      "length": {"km": "å…¬é‡Œ", "m": "ç±³", "cm": "å˜ç±³", "in": "è‹±å¯¸", "ft": "è‹±å°º"},
      "weight": {"kg": "å…¬æ–¤", "g": "å…‹", "lb": "ç£…", "oz": "ç›å¸"},
      "temperature": {"celsius": "æ‘„æ°åº¦", "fahrenheit": "åæ°åº¦", "kelvin": "å¼€å°”æ–‡"},
      "data": {"byte": "å­—èŠ‚", "kilobyte": "åƒå­—èŠ‚", "megabyte": "å…†å­—èŠ‚", "gigabyte": "å‰å­—èŠ‚"},
      "speed": {"kmh": "å…¬é‡Œ/å°æ—¶", "mph": "è‹±é‡Œ/å°æ—¶", "ms": "ç±³/ç§’"}
    },
    "ja": {
      "length": {"km": "km", "m": "m", "cm": "cm", "in": "ã‚¤ãƒ³ãƒ", "ft": "ãƒ•ã‚£ãƒ¼ãƒˆ"},
      "weight": {"kg": "kg", "g": "g", "lb": "ãƒãƒ³ãƒ‰", "oz": "ã‚ªãƒ³ã‚¹"},
      "temperature": {"celsius": "Â°C", "fahrenheit": "Â°F", "kelvin": "K"},
      "data": {"byte": "ãƒã‚¤ãƒˆ", "kilobyte": "KB", "megabyte": "MB", "gigabyte": "GB"},
      "speed": {"kmh": "km/h", "mph": "mph", "ms": "m/s"}
    }
  }
  
  // å•ä½è½¬æ¢å‡½æ•°
  let convert_unit = fn(value, from_unit, to_unit, unit_type) {
    match unit_type {
      "temperature" => {
        if from_unit == "celsius" && to_unit == "fahrenheit" {
          value * 9.0 / 5.0 + 32.0
        } else if from_unit == "fahrenheit" && to_unit == "celsius" {
          (value - 32.0) * 5.0 / 9.0
        } else if from_unit == "celsius" && to_unit == "kelvin" {
          value + 273.15
        } else if from_unit == "kelvin" && to_unit == "celsius" {
          value - 273.15
        } else {
          value
        }
      }
      "length" => {
        if from_unit == "km" && to_unit == "m" {
          value * 1000.0
        } else if from_unit == "m" && to_unit == "km" {
          value / 1000.0
        } else if from_unit == "m" && to_unit == "ft" {
          value * 3.28084
        } else if from_unit == "ft" && to_unit == "m" {
          value / 3.28084
        } else {
          value
        }
      }
      "data" => {
        if from_unit == "byte" && to_unit == "kilobyte" {
          value / 1024.0
        } else if from_unit == "kilobyte" && to_unit == "megabyte" {
          value / 1024.0
        } else if from_unit == "megabyte" && to_unit == "gigabyte" {
          value / 1024.0
        } else if from_unit == "gigabyte" && to_unit == "megabyte" {
          value * 1024.0
        } else {
          value
        }
      }
      _ => value
    }
  }
  
  // æœ¬åœ°åŒ–å•ä½æ ¼å¼åŒ–å‡½æ•°
  let format_unit = fn(value, unit, unit_type, locale) {
    let units = measurement_units[locale] ?? measurement_units["en"]
    let unit_symbols = units[unit_type]
    let localized_unit = unit_symbols[unit] ?? unit
    
    value.to_string() + " " + localized_unit
  }
  
  // æµ‹è¯•å•ä½è½¬æ¢å’Œæœ¬åœ°åŒ–
  let test_temperature = 25.0  // 25Â°C
  
  let celsius_en = format_unit(test_temperature, "celsius", "temperature", "en")
  let celsius_zh = format_unit(test_temperature, "celsius", "temperature", "zh")
  let celsius_ja = format_unit(test_temperature, "celsius", "temperature", "ja")
  
  // éªŒè¯æ¸©åº¦å•ä½æœ¬åœ°åŒ–
  assert_eq(celsius_en, "25.0 Â°C", "è‹±è¯­æ¸©åº¦å•ä½åº”è¯¥æ­£ç¡®")
  assert_eq(celsius_zh, "25.0 æ‘„æ°åº¦", "ä¸­æ–‡æ¸©åº¦å•ä½åº”è¯¥æ­£ç¡®")
  assert_eq(celsius_ja, "25.0 Â°C", "æ—¥è¯­æ¸©åº¦å•ä½åº”è¯¥æ­£ç¡®")
  
  // æµ‹è¯•æ¸©åº¦è½¬æ¢
  let fahrenheit_value = convert_unit(test_temperature, "celsius", "fahrenheit", "temperature")
  let fahrenheit_en = format_unit(fahrenheit_value, "fahrenheit", "temperature", "en")
  let fahrenheit_zh = format_unit(fahrenheit_value, "fahrenheit", "temperature", "zh")
  
  // éªŒè¯æ¸©åº¦è½¬æ¢å’Œæœ¬åœ°åŒ–
  assert_true(@lib.abs(fahrenheit_value - 77.0) < 0.1, "æ¸©åº¦è½¬æ¢åº”è¯¥æ­£ç¡®")
  assert_eq(fahrenheit_en, "77.0 Â°F", "è‹±è¯­åæ°åº¦å•ä½åº”è¯¥æ­£ç¡®")
  assert_eq(fahrenheit_zh, "77.0 åæ°åº¦", "ä¸­æ–‡åæ°åº¦å•ä½åº”è¯¥æ­£ç¡®")
  
  // æµ‹è¯•æ•°æ®å•ä½æœ¬åœ°åŒ–
  let test_data_size = 1048576.0  // 1MB
  
  let bytes_en = format_unit(test_data_size, "byte", "data", "en")
  let bytes_zh = format_unit(test_data_size, "byte", "data", "zh")
  let megabytes_en = format_unit(1.0, "megabyte", "data", "en")
  let megabytes_zh = format_unit(1.0, "megabyte", "data", "zh")
  
  // éªŒè¯æ•°æ®å•ä½æœ¬åœ°åŒ–
  assert_eq(bytes_en, "1048576.0 B", "è‹±è¯­å­—èŠ‚å•ä½åº”è¯¥æ­£ç¡®")
  assert_eq(bytes_zh, "1048576.0 å­—èŠ‚", "ä¸­æ–‡å­—èŠ‚å•ä½åº”è¯¥æ­£ç¡®")
  assert_eq(megabytes_en, "1.0 MB", "è‹±è¯­å…†å­—èŠ‚å•ä½åº”è¯¥æ­£ç¡®")
  assert_eq(megabytes_zh, "1.0 å…†å­—èŠ‚", "ä¸­æ–‡å…†å­—èŠ‚å•ä½åº”è¯¥æ­£ç¡®")
}

// Test 5: æ–‡æœ¬æ–¹å‘å’ŒRTLæ”¯æŒ
test "text direction and RTL support" {
  // è¯­è¨€æ–¹å‘é…ç½®
  let language_directions = {
    "en": "LTR",
    "zh": "LTR",
    "ja": "LTR",
    "ar": "RTL",
    "he": "RTL",
    "fa": "RTL"
  }
  
  // æ–‡æœ¬å¯¹é½é…ç½®
  let text_alignments = {
    "LTR": {
      "left": "left",
      "right": "right",
      "start": "left",
      "end": "right"
    },
    "RTL": {
      "left": "right",
      "right": "left",
      "start": "right",
      "end": "left"
    }
  }
  
  // å¤šæ–¹å‘æ–‡æœ¬ç¤ºä¾‹
  let multilingual_texts = {
    "en": "Hello World! System status is normal.",
    "zh": "ä½ å¥½ä¸–ç•Œï¼ç³»ç»ŸçŠ¶æ€æ­£å¸¸ã€‚",
    "ja": "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œï¼ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã¯æ­£å¸¸ã§ã™ã€‚",
    "ar": "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…! Ø­Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù… Ø·Ø¨ÙŠØ¹ÙŠØ©.",
    "he": "×©×œ×•× ×¢×•×œ×! ××¦×‘ ×”××¢×¨×›×ª ×ª×§×™×Ÿ.",
    "fa": "Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§! ÙˆØ¶Ø¹ÛŒØª Ø³ÛŒØ³ØªÙ… Ø¹Ø§Ø¯ÛŒ Ø§Ø³Øª."
  }
  
  // è·å–æ–‡æœ¬æ–¹å‘
  let get_text_direction = fn(language) {
    language_directions[language] ?? "LTR"
  }
  
  // è·å–æ–‡æœ¬å¯¹é½
  let get_text_alignment = fn(language, alignment_type) {
    let direction = get_text_direction(language)
    text_alignments[direction][alignment_type]
  }
  
  // æµ‹è¯•æ–‡æœ¬æ–¹å‘æ£€æµ‹
  assert_eq(get_text_direction("en"), "LTR", "è‹±è¯­åº”è¯¥æ˜¯ä»å·¦åˆ°å³")
  assert_eq(get_text_direction("zh"), "LTR", "ä¸­æ–‡åº”è¯¥æ˜¯ä»å·¦åˆ°å³")
  assert_eq(get_text_direction("ja"), "LTR", "æ—¥è¯­åº”è¯¥æ˜¯ä»å·¦åˆ°å³")
  assert_eq(get_text_direction("ar"), "RTL", "é˜¿æ‹‰ä¼¯è¯­åº”è¯¥æ˜¯ä»å³åˆ°å·¦")
  assert_eq(get_text_direction("he"), "RTL", "å¸Œä¼¯æ¥è¯­åº”è¯¥æ˜¯ä»å³åˆ°å·¦")
  assert_eq(get_text_direction("fa"), "RTL", "æ³¢æ–¯è¯­åº”è¯¥æ˜¯ä»å³åˆ°å·¦")
  
  // æµ‹è¯•æ–‡æœ¬å¯¹é½
  assert_eq(get_text_alignment("en", "start"), "left", "è‹±è¯­å¼€å§‹ä½ç½®åº”è¯¥æ˜¯å·¦è¾¹")
  assert_eq(get_text_alignment("en", "end"), "right", "è‹±è¯­ç»“æŸä½ç½®åº”è¯¥æ˜¯å³è¾¹")
  assert_eq(get_text_alignment("ar", "start"), "right", "é˜¿æ‹‰ä¼¯è¯­å¼€å§‹ä½ç½®åº”è¯¥æ˜¯å³è¾¹")
  assert_eq(get_text_alignment("ar", "end"), "left", "é˜¿æ‹‰ä¼¯è¯­ç»“æŸä½ç½®åº”è¯¥æ˜¯å·¦è¾¹")
  
  // æµ‹è¯•å¤šè¯­è¨€æ–‡æœ¬æ¸²æŸ“
  for language in multilingual_texts.keys() {
    let text = multilingual_texts[language]
    let direction = get_text_direction(language)
    
    // éªŒè¯æ–‡æœ¬ä¸ä¸ºç©º
    assert_true(text.length() > 0, "å¤šè¯­è¨€æ–‡æœ¬ä¸åº”ä¸ºç©º: " + language)
    
    // éªŒè¯æ–¹å‘é…ç½®å­˜åœ¨
    assert_true(direction == "LTR" || direction == "RTL", "æ–‡æœ¬æ–¹å‘åº”è¯¥æ˜¯æœ‰æ•ˆå€¼: " + language)
  }
  
  // æµ‹è¯•æ··åˆè¯­è¨€æ–‡æœ¬å¤„ç†
  let mixed_language_text = "Hello Ù…Ø±Ø­Ø¨Ø§ ã“ã‚“ã«ã¡ã¯"
  let auto_detected_direction = "LTR"  // ç®€åŒ–çš„è‡ªåŠ¨æ£€æµ‹ï¼Œå®é™…ä¼šæ›´å¤æ‚
  
  assert_eq(auto_detected_direction, "LTR", "æ··åˆè¯­è¨€æ–‡æœ¬åº”è¯¥æœ‰åˆç†çš„æ–¹å‘æ£€æµ‹")
}

// Test 6: å¤æ•°å½¢å¼å¤„ç†
test "plural forms handling" {
  // å¤æ•°è§„åˆ™é…ç½®
  let plural_rules = {
    "en": {
      "rule": "n != 1",
      "forms": ["one", "other"]
    },
    "zh": {
      "rule": "always",
      "forms": ["other"]
    },
    "ja": {
      "rule": "always",
      "forms": ["other"]
    },
    "ar": {
      "rule": "n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5",
      "forms": ["zero", "one", "two", "few", "many", "other"]
    },
    "ru": {
      "rule": "n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2",
      "forms": ["one", "few", "many"]
    }
  }
  
  // å¤æ•°å½¢å¼ç¿»è¯‘
  let plural_translations = {
    "en": {
      "items": {
        "one": "{} item",
        "other": "{} items"
      },
      "errors": {
        "one": "{} error",
        "other": "{} errors"
      },
      "minutes": {
        "one": "{} minute",
        "other": "{} minutes"
      }
    },
    "zh": {
      "items": {
        "other": "{} é¡¹"
      },
      "errors": {
        "other": "{} ä¸ªé”™è¯¯"
      },
      "minutes": {
        "other": "{} åˆ†é’Ÿ"
      }
    },
    "ja": {
      "items": {
        "other": "{} é …ç›®"
      },
      "errors": {
        "other": "{} ã‚¨ãƒ©ãƒ¼"
      },
      "minutes": {
        "other": "{} åˆ†"
      }
    },
    "ru": {
      "items": {
        "one": "{} ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚",
        "few": "{} ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°",
        "many": "{} ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²"
      },
      "errors": {
        "one": "{} Ğ¾ÑˆĞ¸Ğ±ĞºĞ°",
        "few": "{} Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸",
        "many": "{} Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº"
      }
    }
  }
  
  // ç®€åŒ–çš„å¤æ•°å½¢å¼æ£€æµ‹å‡½æ•°
  let get_plural_form = fn(count, language) {
    match language {
      "en" => {
        if count == 1 { "one" } else { "other" }
      }
      "zh" | "ja" => {
        "other"
      }
      "ru" => {
        let mod10 = count % 10
        let mod100 = count % 100
        if mod10 == 1 && mod100 != 11 {
          "one"
        } else if mod10 >= 2 && mod10 <= 4 && (mod100 < 10 || mod100 >= 20) {
          "few"
        } else {
          "many"
        }
      }
      _ => "other"
    }
  }
  
  // å¤æ•°å½¢å¼ç¿»è¯‘å‡½æ•°
  let translate_plural = fn(key, count, language) {
    let plural_form = get_plural_form(count, language)
    let translations = plural_translations[language]
    if translations {
      let key_translations = translations[key]
      if key_translations {
        let template = key_translations[plural_form] ?? key_translations["other"]
        template.replace("{}", count.to_string())
      } else {
        count.to_string() + " " + key
      }
    } else {
      count.to_string() + " " + key
    }
  }
  
  // æµ‹è¯•å¤æ•°å½¢å¼å¤„ç†
  let test_counts = [0, 1, 2, 5, 11, 21]
  let test_languages = ["en", "zh", "ja", "ru"]
  
  // éªŒè¯è‹±è¯­å¤æ•°å½¢å¼
  assert_eq(translate_plural("items", 1, "en"), "1 item", "è‹±è¯­å•æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("items", 5, "en"), "5 items", "è‹±è¯­å¤æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  
  // éªŒè¯ä¸­æ–‡å¤æ•°å½¢å¼ï¼ˆä¸­æ–‡é€šå¸¸ä¸åŒºåˆ†å•å¤æ•°ï¼‰
  assert_eq(translate_plural("items", 1, "zh"), "1 é¡¹", "ä¸­æ–‡å¤æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("items", 5, "zh"), "5 é¡¹", "ä¸­æ–‡å¤æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  
  // éªŒè¯ä¿„è¯­å¤æ•°å½¢å¼ï¼ˆä¿„è¯­æœ‰å¤æ‚çš„å¤æ•°è§„åˆ™ï¼‰
  assert_eq(translate_plural("items", 1, "ru"), "1 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚", "ä¿„è¯­å•æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("items", 2, "ru"), "2 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°", "ä¿„è¯­å°‘æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("items", 5, "ru"), "5 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²", "ä¿„è¯­å¤šæ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("items", 11, "ru"), "11 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²", "ä¿„è¯­11çš„ç‰¹æ®Šå½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("items", 21, "ru"), "21 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚", "ä¿„è¯­21çš„ç‰¹æ®Šå½¢å¼åº”è¯¥æ­£ç¡®")
  
  // æµ‹è¯•é”™è¯¯è®¡æ•°
  assert_eq(translate_plural("errors", 1, "en"), "1 error", "è‹±è¯­é”™è¯¯å•æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("errors", 3, "en"), "3 errors", "è‹±è¯­é”™è¯¯å¤æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("errors", 1, "ru"), "1 Ğ¾ÑˆĞ¸Ğ±ĞºĞ°", "ä¿„è¯­é”™è¯¯å•æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("errors", 2, "ru"), "2 Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸", "ä¿„è¯­é”™è¯¯å°‘æ•°å½¢å¼åº”è¯¥æ­£ç¡®")
  assert_eq(translate_plural("errors", 5, "ru"), "5 Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº", "ä¿„è¯­é”™è¯¯å¤šæ•°å½¢å¼åº”è¯¥æ­£ç¡®")
}

// Test 7: åŒºåŸŸç‰¹å®šæ ¼å¼å’Œçº¦å®š
test "locale-specific formats and conventions" {
  // åŒºåŸŸç‰¹å®šé…ç½®
  let locale_conventions = {
    "en-US": {
      "date_format": "MM/DD/YYYY",
      "time_format": "h:mm:ss A",
      "number_format": {"decimal": ".", "thousands": ","},
      "currency": {"symbol": "$", "position": "before"},
      "week_start": "sunday",
      "paper_size": "letter"
    },
    "en-GB": {
      "date_format": "DD/MM/YYYY",
      "time_format": "HH:mm:ss",
      "number_format": {"decimal": ".", "thousands": ","},
      "currency": {"symbol": "Â£", "position": "before"},
      "week_start": "monday",
      "paper_size": "A4"
    },
    "zh-CN": {
      "date_format": "YYYYå¹´MMæœˆDDæ—¥",
      "time_format": "HH:mm:ss",
      "number_format": {"decimal": ".", "thousands": ","},
      "currency": {"symbol": "Â¥", "position": "before"},
      "week_start": "monday",
      "paper_size": "A4"
    },
    "de-DE": {
      "date_format": "DD.MM.YYYY",
      "time_format": "HH:mm:ss",
      "number_format": {"decimal": ",", "thousands": "."},
      "currency": {"symbol": "â‚¬", "position": "after"},
      "week_start": "monday",
      "paper_size": "A4"
    },
    "ja-JP": {
      "date_format": "YYYY/MM/DD",
      "time_format": "HH:mm:ss",
      "number_format": {"decimal": ".", "thousands": ","},
      "currency": {"symbol": "Â¥", "position": "before"},
      "week_start": "sunday",
      "paper_size": "A4"
    }
  }
  
  // åœ°å€æ ¼å¼é…ç½®
  let address_formats = {
    "en-US": {
      "order": ["street", "city", "state", "zip", "country"],
      "template": "{street}\n{city}, {state} {zip}\n{country}"
    },
    "zh-CN": {
      "order": ["country", "state", "city", "street", "zip"],
      "template": "{country}{state}{city}{street}\n{zip}"
    },
    "ja-JP": {
      "order": ["country", "state", "city", "street", "zip"],
      "template": "ã€’{zip}\n{state}{city}{street}"
    },
    "de-DE": {
      "order": ["street", "zip", "city", "country"],
      "template": "{street}\n{zip} {city}\n{country}"
    }
  }
  
  // å§“åæ ¼å¼é…ç½®
  let name_formats = {
    "en-US": {"order": ["first", "middle", "last"], "template": "{first} {middle} {last}"},
    "zh-CN": {"order": ["last", "first"], "template": "{last}{first}"},
    "ja-JP": {"order": ["last", "first"], "template": "{last} {first}"},
    "hu-HU": {"order": ["last", "first", "middle"], "template": "{last} {first} {middle}"},  // åŒˆç‰™åˆ©è¯­
    "ko-KR": {"order": ["last", "first"], "template": "{last}{first}"}  // éŸ©è¯­
  }
  
  // æµ‹è¯•åŒºåŸŸç‰¹å®šæ—¥æœŸæ ¼å¼
  let test_date = {
    "year": 2022,
    "month": 1,
    "day": 15
  }
  
  // éªŒè¯ç¾å¼è‹±è¯­æ—¥æœŸæ ¼å¼
  let us_convention = locale_conventions["en-US"]
  assert_eq(us_convention["date_format"], "MM/DD/YYYY", "ç¾å¼è‹±è¯­æ—¥æœŸæ ¼å¼åº”è¯¥æ­£ç¡®")
  assert_eq(us_convention["week_start"], "sunday", "ç¾å›½ä¸€å‘¨å¼€å§‹åº”è¯¥æ˜¯å‘¨æ—¥")
  assert_eq(us_convention["paper_size"], "letter", "ç¾å›½çº¸å¼ å°ºå¯¸åº”è¯¥æ˜¯letter")
  
  // éªŒè¯è‹±å¼è‹±è¯­æ—¥æœŸæ ¼å¼
  let gb_convention = locale_conventions["en-GB"]
  assert_eq(gb_convention["date_format"], "DD/MM/YYYY", "è‹±å¼è‹±è¯­æ—¥æœŸæ ¼å¼åº”è¯¥æ­£ç¡®")
  assert_eq(gb_convention["week_start"], "monday", "è‹±å›½ä¸€å‘¨å¼€å§‹åº”è¯¥æ˜¯å‘¨ä¸€")
  assert_eq(gb_convention["paper_size"], "A4", "è‹±å›½çº¸å¼ å°ºå¯¸åº”è¯¥æ˜¯A4")
  
  // éªŒè¯ä¸­æ–‡æ—¥æœŸæ ¼å¼
  let cn_convention = locale_conventions["zh-CN"]
  assert_eq(cn_convention["date_format"], "YYYYå¹´MMæœˆDDæ—¥", "ä¸­æ–‡æ—¥æœŸæ ¼å¼åº”è¯¥æ­£ç¡®")
  assert_eq(cn_convention["currency"]["symbol"], "Â¥", "ä¸­æ–‡è´§å¸ç¬¦å·åº”è¯¥æ­£ç¡®")
  
  // éªŒè¯å¾·è¯­æ•°å­—æ ¼å¼
  let de_convention = locale_conventions["de-DE"]
  assert_eq(de_convention["number_format"]["decimal"], ",", "å¾·è¯­å°æ•°åˆ†éš”ç¬¦åº”è¯¥æ˜¯é€—å·")
  assert_eq(de_convention["number_format"]["thousands"], ".", "å¾·è¯­åƒä½åˆ†éš”ç¬¦åº”è¯¥æ˜¯ç‚¹")
  
  // æµ‹è¯•åœ°å€æ ¼å¼åŒ–
  let test_address = {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "zip": "10001",
    "country": "USA"
  }
  
  let us_address_format = address_formats["en-US"]
  assert_eq(us_address_format["order"][0], "street", "ç¾å›½åœ°å€é¡ºåºåº”è¯¥ä»¥è¡—é“å¼€å§‹")
  
  // æµ‹è¯•å§“åæ ¼å¼åŒ–
  let test_name = {
    "first": "John",
    "middle": "F.",
    "last": "Kennedy"
  }
  
  let us_name_format = name_formats["en-US"]
  assert_eq(us_name_format["order"][0], "first", "ç¾å›½å§“åé¡ºåºåº”è¯¥ä»¥åå­—å¼€å§‹")
  
  let cn_name_format = name_formats["zh-CN"]
  assert_eq(cn_name_format["order"][0], "last", "ä¸­æ–‡å§“åé¡ºåºåº”è¯¥ä»¥å§“æ°å¼€å§‹")
}

// Test 8: æ—¶åŒºå¤„ç†å’Œè½¬æ¢
test "timezone handling and conversion" {
  // æ—¶åŒºé…ç½®
  let timezones = {
    "UTC": {"offset": 0, "dst": false},
    "America/New_York": {"offset": -300, "dst": true},  // UTC-5 (æ ‡å‡†æ—¶é—´), UTC-4 (å¤ä»¤æ—¶)
    "America/Los_Angeles": {"offset": -480, "dst": true},  // UTC-8 (æ ‡å‡†æ—¶é—´), UTC-7 (å¤ä»¤æ—¶)
    "Europe/London": {"offset": 0, "dst": true},  // UTC+0 (æ ‡å‡†æ—¶é—´), UTC+1 (å¤ä»¤æ—¶)
    "Europe/Paris": {"offset": 60, "dst": true},  // UTC+1 (æ ‡å‡†æ—¶é—´), UTC+2 (å¤ä»¤æ—¶)
    "Asia/Shanghai": {"offset": 480, "dst": false},  // UTC+8
    "Asia/Tokyo": {"offset": 540, "dst": false},  // UTC+9
    "Australia/Sydney": {"offset": 660, "dst": true}  // UTC+10 (æ ‡å‡†æ—¶é—´), UTC+11 (å¤ä»¤æ—¶)
  }
  
  // å¤ä»¤æ—¶æœŸé—´é…ç½®ï¼ˆç®€åŒ–ï¼‰
  let dst_periods = {
    "2022": {
      "US": {"start": "2022-03-13", "end": "2022-11-06"},
      "EU": {"start": "2022-03-27", "end": "2022-10-30"},
      "Australia": {"start": "2022-10-02", "end": "2023-04-02"}
    }
  }
  
  // æ—¶åŒºè½¬æ¢å‡½æ•°
  let convert_timezone = fn(timestamp, from_timezone, to_timezone, date) {
    let from_offset = timezones[from_timezone]["offset"]
    let to_offset = timezones[to_timezone]["offset"]
    
    // æ£€æŸ¥å¤ä»¤æ—¶ï¼ˆç®€åŒ–å®ç°ï¼‰
    let from_dst_offset = if timezones[from_timezone]["dst"] && is_in_dst(date, from_timezone) {
      60  // å¤ä»¤æ—¶å¢åŠ 1å°æ—¶
    } else {
      0
    }
    
    let to_dst_offset = if timezones[to_timezone]["dst"] && is_in_dst(date, to_timezone) {
      60  // å¤ä»¤æ—¶å¢åŠ 1å°æ—¶
    } else {
      0
    }
    
    let total_offset_diff = (to_offset + to_dst_offset) - (from_offset + from_dst_offset)
    timestamp + total_offset_diff * 60
  }
  
  // ç®€åŒ–çš„å¤ä»¤æ—¶æ£€æŸ¥å‡½æ•°
  let is_in_dst = fn(date, timezone) {
    // ç®€åŒ–å®ç°ï¼Œå®é™…ä¼šæ›´å¤æ‚
    match timezone {
      "America/New_York" | "America/Los_Angeles" => {
        date.month >= 3 && date.month <= 11
      }
      "Europe/London" | "Europe/Paris" => {
        date.month >= 3 && date.month <= 10
      }
      "Australia/Sydney" => {
        date.month <= 4 || date.month >= 10
      }
      _ => false
    }
  }
  
  // æµ‹è¯•æ—¶åŒºè½¬æ¢
  let test_timestamp = 1640995200  // 2022-01-01 12:00:00 UTC
  let test_date = {"year": 2022, "month": 1, "day": 1}  // 1æœˆï¼Œä¸åœ¨å¤ä»¤æ—¶æœŸé—´
  
  // UTCåˆ°çº½çº¦æ—¶é—´è½¬æ¢
  let ny_time = convert_timezone(test_timestamp, "UTC", "America/New_York", test_date)
  let ny_expected = test_timestamp - 5 * 3600  // UTC-5
  assert_eq(ny_time, ny_expected, "UTCåˆ°çº½çº¦æ—¶é—´è½¬æ¢åº”è¯¥æ­£ç¡®")
  
  // UTCåˆ°ä¸œäº¬æ—¶é—´è½¬æ¢
  let tokyo_time = convert_timezone(test_timestamp, "UTC", "Asia/Tokyo", test_date)
  let tokyo_expected = test_timestamp + 9 * 3600  // UTC+9
  assert_eq(tokyo_time, tokyo_expected, "UTCåˆ°ä¸œäº¬æ—¶é—´è½¬æ¢åº”è¯¥æ­£ç¡®")
  
  // çº½çº¦åˆ°ä¸œäº¬æ—¶é—´è½¬æ¢
  let ny_to_tokyo = convert_timezone(ny_time, "America/New_York", "Asia/Tokyo", test_date)
  let ny_to_tokyo_expected = ny_time + 14 * 3600  // ä»UTC-5åˆ°UTC+9ï¼Œç›¸å·®14å°æ—¶
  assert_eq(ny_to_tokyo, ny_to_tokyo_expected, "çº½çº¦åˆ°ä¸œäº¬æ—¶é—´è½¬æ¢åº”è¯¥æ­£ç¡®")
  
  // æµ‹è¯•å¤ä»¤æ—¶æœŸé—´è½¬æ¢
  let summer_date = {"year": 2022, "month": 7, "day": 1}  // 7æœˆï¼Œåœ¨å¤ä»¤æ—¶æœŸé—´
  let summer_timestamp = 1656667200  // 2022-07-01 12:00:00 UTC
  
  // UTCåˆ°çº½çº¦å¤ä»¤æ—¶è½¬æ¢
  let ny_summer_time = convert_timezone(summer_timestamp, "UTC", "America/New_York", summer_date)
  let ny_summer_expected = summer_timestamp - 4 * 3600  // UTC-4 (å¤ä»¤æ—¶)
  assert_eq(ny_summer_time, ny_summer_expected, "UTCåˆ°çº½çº¦å¤ä»¤æ—¶è½¬æ¢åº”è¯¥æ­£ç¡®")
  
  // éªŒè¯æ—¶åŒºåç§»é‡
  assert_eq(timezones["UTC"]["offset"], 0, "UTCåç§»é‡åº”è¯¥ä¸º0")
  assert_eq(timezones["Asia/Shanghai"]["offset"], 480, "ä¸Šæµ·åç§»é‡åº”è¯¥ä¸ºUTC+8")
  assert_eq(timezones["America/New_York"]["offset"], -300, "çº½çº¦åç§»é‡åº”è¯¥ä¸ºUTC-5")
}

// Test 9: å­—ç¬¦ç¼–ç å’ŒUnicodeå¤„ç†
test "character encoding and Unicode handling" {
  // Unicodeå­—ç¬¦æµ‹è¯•
  let unicode_strings = {
    "latin": "Hello World! 123",
    "chinese": "ä½ å¥½ä¸–ç•Œï¼ä¸€äºŒä¸‰",
    "japanese": "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œï¼ä¸€äºŒä¸‰",
    "arabic": "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…! Ù¡Ù¢Ù£",
    "hebrew": "×©×œ×•× ×¢×•×œ×! Ù¡Ù¢Ù£",
    "russian": "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€! Ù¡Ù¢Ù£",
    "emoji": "ğŸŒğŸŒğŸŒ Hello! ğŸ‰ğŸŠğŸˆ",
    "mixed": "Hello ä¸–ç•Œ! ğŸŒ 123 Ù…Ø±Ø­Ø¨Ø§"
  }
  
  // å­—ç¬¦ç»Ÿè®¡å‡½æ•°
  let count_characters = fn(text) {
    text.length()  // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è€ƒè™‘Unicodeç»„åˆå­—ç¬¦
  }
  
  // å­—èŠ‚é•¿åº¦ä¼°ç®—å‡½æ•°
  let estimate_byte_length = fn(text, encoding) {
    match encoding {
      "UTF-8" => {
        // ç®€åŒ–çš„UTF-8å­—èŠ‚é•¿åº¦ä¼°ç®—
        let mut byte_count = 0
        for char in text {
          if char <= 0x7F {
            byte_count = byte_count + 1
          } else if char <= 0x7FF {
            byte_count = byte_count + 2
          } else if char <= 0xFFFF {
            byte_count = byte_count + 3
          } else {
            byte_count = byte_count + 4
          }
        }
        byte_count
      }
      "UTF-16" => {
        text.length() * 2  // ç®€åŒ–å®ç°
      }
      _ => text.length()
    }
  }
  
  // æ–‡æœ¬è§„èŒƒåŒ–å‡½æ•°
  let normalize_text = fn(text, form) {
    // ç®€åŒ–çš„è§„èŒƒåŒ–å®ç°ï¼Œå®é™…ä¼šä½¿ç”¨Unicodeè§„èŒƒåŒ–åº“
    match form {
      "NFC" => text  // è§„èŒƒåŒ–å½¢å¼C
      "NFD" => text  // è§„èŒƒåŒ–å½¢å¼D
      "NFKC" => text // è§„èŒƒåŒ–å½¢å¼KC
      "NFKD" => text // è§„èŒƒåŒ–å½¢å¼KD
      _ => text
    }
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦å¤„ç†
  for language in unicode_strings.keys() {
    let text = unicode_strings[language]
    
    // éªŒè¯å­—ç¬¦è®¡æ•°
    let char_count = count_characters(text)
    assert_true(char_count > 0, "Unicodeæ–‡æœ¬åº”è¯¥æœ‰å­—ç¬¦: " + language)
    
    // éªŒè¯å­—èŠ‚é•¿åº¦ä¼°ç®—
    let utf8_length = estimate_byte_length(text, "UTF-8")
    let utf16_length = estimate_byte_length(text, "UTF-16")
    
    assert_true(utf8_length > 0, "UTF-8å­—èŠ‚é•¿åº¦åº”è¯¥å¤§äº0: " + language)
    assert_true(utf16_length > 0, "UTF-16å­—èŠ‚é•¿åº¦åº”è¯¥å¤§äº0: " + language)
    
    // éªŒè¯æ–‡æœ¬è§„èŒƒåŒ–
    let normalized_nfc = normalize_text(text, "NFC")
    let normalized_nfd = normalize_text(text, "NFD")
    
    assert_eq(normalized_nfc, text, "NFCè§„èŒƒåŒ–åº”è¯¥ä¿æŒæ–‡æœ¬ä¸å˜: " + language)
    assert_eq(normalized_nfd, text, "NFDè§„èŒƒåŒ–åº”è¯¥ä¿æŒæ–‡æœ¬ä¸å˜: " + language)
  }
  
  // æµ‹è¯•ç‰¹å®šUnicodeå­—ç¬¦
  let latin_text = unicode_strings["latin"]
  let chinese_text = unicode_strings["chinese"]
  let emoji_text = unicode_strings["emoji"]
  let mixed_text = unicode_strings["mixed"]
  
  // éªŒè¯æ‹‰ä¸å­—ç¬¦
  assert_eq(count_characters(latin_text), 18, "æ‹‰ä¸æ–‡æœ¬å­—ç¬¦è®¡æ•°åº”è¯¥æ­£ç¡®")
  assert_eq(estimate_byte_length(latin_text, "UTF-8"), 18, "æ‹‰ä¸æ–‡æœ¬UTF-8å­—èŠ‚é•¿åº¦åº”è¯¥æ­£ç¡®")
  
  // éªŒè¯ä¸­æ–‡å­—ç¬¦
  assert_eq(count_characters(chinese_text), 8, "ä¸­æ–‡æ–‡æœ¬å­—ç¬¦è®¡æ•°åº”è¯¥æ­£ç¡®")
  assert_true(estimate_byte_length(chinese_text, "UTF-8") > 16, "ä¸­æ–‡æ–‡æœ¬UTF-8å­—èŠ‚é•¿åº¦åº”è¯¥å¤§äºå­—ç¬¦æ•°")
  
  // éªŒè¯Emojiå­—ç¬¦
  assert_eq(count_characters(emoji_text), 15, "Emojiæ–‡æœ¬å­—ç¬¦è®¡æ•°åº”è¯¥æ­£ç¡®")
  assert_true(estimate_byte_length(emoji_text, "UTF-8") > 15, "Emojiæ–‡æœ¬UTF-8å­—èŠ‚é•¿åº¦åº”è¯¥å¤§äºå­—ç¬¦æ•°")
  
  // éªŒè¯æ··åˆæ–‡æœ¬
  assert_eq(count_characters(mixed_text), 16, "æ··åˆæ–‡æœ¬å­—ç¬¦è®¡æ•°åº”è¯¥æ­£ç¡®")
}

// Test 10: å›½é™…åŒ–æ€§èƒ½å’Œç¼“å­˜
test "internationalization performance and caching" {
  // æ¨¡æ‹Ÿå¤§é‡ç¿»è¯‘æ•°æ®
  let generate_translations = fn(language_count, key_count) {
    let translations = {}
    let languages = ["en", "zh", "ja", "ko", "es", "fr", "de", "ru", "ar", "pt"]
    
    for i in 0..@lib.min(language_count, languages.length()) {
      let lang = languages[i]
      translations[lang] = {}
      
      for j in 0..key_count {
        let key = "key_" + j.to_string()
        translations[lang][key] = lang + "_" + key + "_translated"
      }
    }
    
    translations
  }
  
  // ç¿»è¯‘ç¼“å­˜
  let translation_cache = {}
  
  // å¸¦ç¼“å­˜çš„ç¿»è¯‘å‡½æ•°
  let cached_translate = fn(translations, key, language) {
    let cache_key = language + ":" + key
    
    match translation_cache[cache_key] {
      Some(cached_value) => cached_value
      None => {
        let lang_translations = translations[language]
        let translation = if lang_translations && lang_translations[key] {
          lang_translations[key]
        } else {
          key  // å›é€€åˆ°é”®
        }
        
        translation_cache[cache_key] = translation
        translation
      }
    }
  }
  
  // æ€§èƒ½æµ‹è¯•å‡½æ•°
  let performance_test = fn(test_name, translate_fn, translations, test_keys, test_languages, iterations) {
    let start_time = @lib.time.now()
    
    for i in 0..iterations {
      let key = test_keys[i % test_keys.length()]
      let language = test_languages[i % test_languages.length()]
      translate_fn(translations, key, language)
    }
    
    let end_time = @lib.time.now()
    let duration = end_time - start_time
    
    {
      "test_name": test_name,
      "iterations": iterations,
      "duration_ms": duration,
      "operations_per_second": iterations.to_decimal() / duration.to_decimal() * 1000.0
    }
  }
  
  // ç”Ÿæˆæµ‹è¯•æ•°æ®
  let translations = generate_translations(10, 1000)
  let test_keys = ["key_0", "key_1", "key_10", "key_100", "key_500"]
  let test_languages = ["en", "zh", "ja", "ko", "es"]
  
  // æ— ç¼“å­˜çš„ç¿»è¯‘å‡½æ•°
  let uncached_translate = fn(translations, key, language) {
    let lang_translations = translations[language]
    if lang_translations && lang_translations[key] {
      lang_translations[key]
    } else {
      key
    }
  }
  
  // æ‰§è¡Œæ€§èƒ½æµ‹è¯•
  let cache_test_size = 10000
  let uncached_result = performance_test("uncached", uncached_translate, translations, test_keys, test_languages, cache_test_size)
  
  // æ¸…ç©ºç¼“å­˜å¹¶æ‰§è¡Œç¼“å­˜æµ‹è¯•
  for key in translation_cache.keys() {
    @lib.object.delete(translation_cache, key)
  }
  
  let cached_result = performance_test("cached", cached_translate, translations, test_keys, test_languages, cache_test_size)
  
  // éªŒè¯æ€§èƒ½æµ‹è¯•ç»“æœ
  assert_eq(uncached_result["iterations"], cache_test_size, "æ— ç¼“å­˜æµ‹è¯•è¿­ä»£æ¬¡æ•°åº”è¯¥æ­£ç¡®")
  assert_eq(cached_result["iterations"], cache_test_size, "ç¼“å­˜æµ‹è¯•è¿­ä»£æ¬¡æ•°åº”è¯¥æ­£ç¡®")
  assert_true(uncached_result["duration_ms"] > 0, "æ— ç¼“å­˜æµ‹è¯•åº”è¯¥æœ‰æ‰§è¡Œæ—¶é—´")
  assert_true(cached_result["duration_ms"] > 0, "ç¼“å­˜æµ‹è¯•åº”è¯¥æœ‰æ‰§è¡Œæ—¶é—´")
  
  // éªŒè¯ç¼“å­˜æ€§èƒ½æå‡
  let performance_improvement = uncached_result["operations_per_second"] / cached_result["operations_per_second"]
  assert_true(performance_improvement > 1.0, "ç¼“å­˜åº”è¯¥æé«˜æ€§èƒ½")
  
  // éªŒè¯ç¼“å­˜å‘½ä¸­ç‡
  let cache_hit_count = 0
  let cache_miss_count = 0
  
  // æ¨¡æ‹Ÿç¼“å­˜ç»Ÿè®¡
  for i in 0..1000 {
    let key = test_keys[i % test_keys.length()]
    let language = test_languages[i % test_languages.length()]
    let cache_key = language + ":" + key
    
    if translation_cache[cache_key] {
      cache_hit_count = cache_hit_count + 1
    } else {
      cache_miss_count = cache_miss_count + 1
      translation_cache[cache_key] = "cached_value"
    }
  }
  
  let cache_hit_rate = cache_hit_count.to_decimal() / (cache_hit_count + cache_miss_count).to_decimal()
  assert_true(cache_hit_rate > 0.5, "ç¼“å­˜å‘½ä¸­ç‡åº”è¯¥åˆç†")
}