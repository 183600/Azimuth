// Azimuth Telemetry System - Internationalization Tests
// This file contains test cases for internationalization functionality

// Test 1: Unicode String Handling
test "unicode string handling" {
  // Test various Unicode characters
  let chinese_text = "é¥æµ‹ç³»ç»Ÿ"
  let arabic_text = "Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  let russian_text = "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ğ¸"
  let japanese_text = "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ "
  let emoji_text = "ğŸ” ğŸ“Š ğŸ“ˆ ğŸ“‰"
  let mixed_text = "Azimuth é¥æµ‹ç³»ç»Ÿ ğŸ“Š"
  
  // Test string length with Unicode
  assert_eq(chinese_text.length(), 4)
  assert_eq(arabic_text.length(), 20)
  assert_eq(russian_text.length(), 19)
  assert_eq(japanese_text.length(), 9)
  assert_eq(emoji_text.length(), 7) // Each emoji counts as one character
  assert_eq(mixed_text.length(), 12)
  
  // Test string concatenation with Unicode
  let combined = chinese_text + " " + japanese_text
  assert_eq(combined, "é¥æµ‹ç³»ç»Ÿ ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ ")
  
  // Test substring operations with Unicode
  let chinese_substring = chinese_text.substring(0, 2)
  assert_eq(chinese_substring, "é¥æµ‹")
  
  let mixed_substring = mixed_text.substring(8, 11)
  assert_eq(mixed_substring, "ğŸ“Š")
}

// Test 2: Locale-aware Date/Time Formatting
test "locale-aware date/time formatting" {
  let timestamp = 1609459200L // 2021-01-01 00:00:00 UTC
  let formatter = DateTimeFormatter::new()
  
  // Test different locales
  DateTimeFormatter::set_locale(formatter, "en-US")
  let us_format = DateTimeFormatter::format(formatter, timestamp, "YYYY-MM-DD HH:mm:ss")
  assert_eq(us_format, "2021-01-01 00:00:00")
  
  DateTimeFormatter::set_locale(formatter, "zh-CN")
  let cn_format = DateTimeFormatter::format(formatter, timestamp, "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss")
  assert_eq(cn_format, "2021å¹´01æœˆ01æ—¥ 00:00:00")
  
  DateTimeFormatter::set_locale(formatter, "ja-JP")
  let jp_format = DateTimeFormatter::format(formatter, timestamp, "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss")
  assert_eq(jp_format, "2021å¹´01æœˆ01æ—¥ 00:00:00")
  
  DateTimeFormatter::set_locale(formatter, "ar-SA")
  let ar_format = DateTimeFormatter::format(formatter, timestamp, "YYYY/MM/DD HH:mm:ss")
  assert_eq(ar_format, "2021/01/01 00:00:00")
  
  // Test timezone handling
  DateTimeFormatter::set_timezone(formatter, "Asia/Shanghai")
  let shanghai_time = DateTimeFormatter::format(formatter, timestamp, "YYYY-MM-DD HH:mm:ss ZZ")
  assert_eq(shanghai_time, "2021-01-01 08:00:00 +0800")
  
  DateTimeFormatter::set_timezone(formatter, "America/New_York")
  let ny_time = DateTimeFormatter::format(formatter, timestamp, "YYYY-MM-DD HH:mm:ss ZZ")
  assert_eq(ny_time, "2020-12-31 19:00:00 -0500")
}

// Test 3: Number Formatting with Locales
test "number formatting with locales" {
  let number_formatter = NumberFormatter::new()
  
  // Test decimal formatting
  let test_number = 1234.5678
  
  NumberFormatter::set_locale(number_formatter, "en-US")
  let us_decimal = NumberFormatter::format_decimal(number_formatter, test_number, 2)
  assert_eq(us_decimal, "1,234.57")
  
  NumberFormatter::set_locale(number_formatter, "de-DE")
  let de_decimal = NumberFormatter::format_decimal(number_formatter, test_number, 2)
  assert_eq(de_decimal, "1.234,57")
  
  NumberFormatter::set_locale(number_formatter, "zh-CN")
  let cn_decimal = NumberFormatter::format_decimal(number_formatter, test_number, 2)
  assert_eq(cn_decimal, "1,234.57")
  
  NumberFormatter::set_locale(number_formatter, "ar-SA")
  let ar_decimal = NumberFormatter::format_decimal(number_formatter, test_number, 2)
  assert_eq(ar_decimal, "1,234.57")
  
  // Test percentage formatting
  let percentage = 0.7543
  
  NumberFormatter::set_locale(number_formatter, "en-US")
  let us_percent = NumberFormatter::format_percentage(number_formatter, percentage, 1)
  assert_eq(us_percent, "75.4%")
  
  NumberFormatter::set_locale(number_formatter, "fr-FR")
  let fr_percent = NumberFormatter::format_percentage(number_formatter, percentage, 1)
  assert_eq(fr_percent, "75,4 %")
  
  // Test currency formatting
  let currency = 1234.56
  
  NumberFormatter::set_locale(number_formatter, "en-US")
  let us_currency = NumberFormatter::format_currency(number_formatter, currency, "USD")
  assert_eq(us_currency, "$1,234.56")
  
  NumberFormatter::set_locale(number_formatter, "ja-JP")
  let jp_currency = NumberFormatter::format_currency(number_formatter, currency, "JPY")
  assert_eq(jp_currency, "Â¥1,235") // Japanese yen doesn't use decimal places
  
  NumberFormatter::set_locale(number_formatter, "de-DE")
  let de_currency = NumberFormatter::format_currency(number_formatter, currency, "EUR")
  assert_eq(de_currency, "1.234,56 â‚¬")
}

// Test 4: Message Localization
test "message localization" {
  let localizer = MessageLocalizer::new()
  
  // Load message bundles for different locales
  let en_messages = {
    "telemetry.started": "Telemetry collection started",
    "telemetry.stopped": "Telemetry collection stopped",
    "telemetry.error": "Telemetry error: {0}",
    "metric.recorded": "Metric {0} recorded with value {1}",
    "span.created": "Span {0} created",
    "span.ended": "Span {0} ended"
  }
  
  let zh_messages = {
    "telemetry.started": "é¥æµ‹æ”¶é›†å·²å¯åŠ¨",
    "telemetry.stopped": "é¥æµ‹æ”¶é›†å·²åœæ­¢",
    "telemetry.error": "é¥æµ‹é”™è¯¯ï¼š{0}",
    "metric.recorded": "æŒ‡æ ‡ {0} å·²è®°å½•ï¼Œå€¼ä¸º {1}",
    "span.created": "è·¨åº¦ {0} å·²åˆ›å»º",
    "span.ended": "è·¨åº¦ {0} å·²ç»“æŸ"
  }
  
  let ja_messages = {
    "telemetry.started": "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªåé›†ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ",
    "telemetry.stopped": "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªåé›†ãŒåœæ­¢ã•ã‚Œã¾ã—ãŸ",
    "telemetry.error": "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚¨ãƒ©ãƒ¼: {0}",
    "metric.recorded": "ãƒ¡ãƒˆãƒªãƒƒã‚¯ {0} ãŒå€¤ {1} ã§è¨˜éŒ²ã•ã‚Œã¾ã—ãŸ",
    "span.created": "ã‚¹ãƒ‘ãƒ³ {0} ãŒä½œæˆã•ã‚Œã¾ã—ãŸ",
    "span.ended": "ã‚¹ãƒ‘ãƒ³ {0} ãŒçµ‚äº†ã—ã¾ã—ãŸ"
  }
  
  MessageLocalizer::load_bundle(localizer, "en", en_messages)
  MessageLocalizer::load_bundle(localizer, "zh", zh_messages)
  MessageLocalizer::load_bundle(localizer, "ja", ja_messages)
  
  // Test English localization
  MessageLocalizer::set_locale(localizer, "en")
  assert_eq(MessageLocalizer::get_message(localizer, "telemetry.started"), "Telemetry collection started")
  assert_eq(MessageLocalizer::get_message(localizer, "telemetry.stopped"), "Telemetry collection stopped")
  assert_eq(MessageLocalizer::format_message(localizer, "telemetry.error", ["connection failed"]), "Telemetry error: connection failed")
  assert_eq(MessageLocalizer::format_message(localizer, "metric.recorded", ["cpu_usage", "75.5"]), "Metric cpu_usage recorded with value 75.5")
  
  // Test Chinese localization
  MessageLocalizer::set_locale(localizer, "zh")
  assert_eq(MessageLocalizer::get_message(localizer, "telemetry.started"), "é¥æµ‹æ”¶é›†å·²å¯åŠ¨")
  assert_eq(MessageLocalizer::get_message(localizer, "telemetry.stopped"), "é¥æµ‹æ”¶é›†å·²åœæ­¢")
  assert_eq(MessageLocalizer::format_message(localizer, "telemetry.error", ["è¿æ¥å¤±è´¥"]), "é¥æµ‹é”™è¯¯ï¼šè¿æ¥å¤±è´¥")
  assert_eq(MessageLocalizer::format_message(localizer, "metric.recorded", ["cpuä½¿ç”¨ç‡", "75.5"]), "æŒ‡æ ‡ cpuä½¿ç”¨ç‡ å·²è®°å½•ï¼Œå€¼ä¸º 75.5")
  
  // Test Japanese localization
  MessageLocalizer::set_locale(localizer, "ja")
  assert_eq(MessageLocalizer::get_message(localizer, "telemetry.started"), "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªåé›†ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ")
  assert_eq(MessageLocalizer::get_message(localizer, "telemetry.stopped"), "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªåé›†ãŒåœæ­¢ã•ã‚Œã¾ã—ãŸ")
  assert_eq(MessageLocalizer::format_message(localizer, "telemetry.error", ["æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ"]), "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚¨ãƒ©ãƒ¼: æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ")
  assert_eq(MessageLocalizer::format_message(localizer, "metric.recorded", ["CPUä½¿ç”¨ç‡", "75.5"]), "ãƒ¡ãƒˆãƒªãƒƒã‚¯ CPUä½¿ç”¨ç‡ ãŒå€¤ 75.5 ã§è¨˜éŒ²ã•ã‚Œã¾ã—ãŸ")
  
  // Test fallback to default locale
  MessageLocalizer::set_locale(localizer, "fr") // French not loaded
  assert_eq(MessageLocalizer::get_message(localizer, "telemetry.started"), "Telemetry collection started") // Falls back to English
}

// Test 5: Right-to-Left Text Support
test "right-to-left text support" {
  let text_processor = TextProcessor::new()
  
  // Test Arabic text (RTL)
  let arabic_text = "Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  TextProcessor::set_direction(text_processor, "rtl")
  let processed_arabic = TextProcessor::process(text_processor, arabic_text)
  assert_eq(processed_arabic, "Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯")
  
  // Test mixed LTR/RTL text
  let mixed_text = "Azimuth Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³"
  let processed_mixed = TextProcessor::process(text_processor, mixed_text)
  // Should preserve both LTR and RTL parts correctly
  assert_true(processed_mixed.contains("Azimuth"))
  assert_true(processed_mixed.contains("Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³"))
  
  // Test Hebrew text (RTL)
  let hebrew_text = "××¢×¨×›×ª ×˜×œ××˜×¨×™×”"
  let processed_hebrew = TextProcessor::process(text_processor, hebrew_text)
  assert_eq(processed_hebrew, "××¢×¨×›×ª ×˜×œ××˜×¨×™×”")
  
  // Test text direction detection
  assert_eq(TextProcessor::detect_direction(text_processor, arabic_text), "rtl")
  assert_eq(TextProcessor::detect_direction(text_processor, hebrew_text), "rtl")
  assert_eq(TextProcessor::detect_direction(text_processor, "English text"), "ltr")
  assert_eq(TextProcessor::detect_direction(text_processor, "ä¸­æ–‡æ–‡æœ¬"), "ltr") // Chinese is LTR
}

// Test 6: Telemetry Data with International Characters
test "telemetry data with international characters" {
  // Create spans with international names
  let chinese_span_ctx = SpanContext::new("ä¸­æ–‡è¿½è¸ªID", "ä¸­æ–‡è·¨åº¦ID", true, "")
  let chinese_span = Span::new("ä¸­æ–‡è·¨åº¦åç§°", Internal, chinese_span_ctx)
  Span::add_event(chinese_span, "ä¸­æ–‡äº‹ä»¶", Some([("ä¸­æ–‡å±æ€§", StringValue("ä¸­æ–‡å€¼"))]))
  
  let arabic_span_ctx = SpanContext::new("Ù…Ø¹Ø±Ù Ø§Ù„ØªØªØ¨Ø¹", "Ù…Ø¹Ø±Ù Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯", true, "")
  let arabic_span = Span::new("Ø§Ø³Ù… Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯", Internal, arabic_span_ctx)
  Span::add_event(arabic_span, "Ø­Ø¯Ø«", Some([("Ø³Ù…Ø©", StringValue("Ù‚ÙŠÙ…Ø©"))]))
  
  let japanese_span_ctx = SpanContext::new("ãƒˆãƒ¬ãƒ¼ã‚¹ID", "ã‚¹ãƒ‘ãƒ³ID", true, "")
  let japanese_span = Span::new("ã‚¹ãƒ‘ãƒ³å", Internal, japanese_span_ctx)
  Span::add_event(japanese_span, "ã‚¤ãƒ™ãƒ³ãƒˆ", Some([("å±æ€§", StringValue("å€¤"))]))
  
  // Test that international data is preserved
  assert_eq(Span::name(chinese_span), "ä¸­æ–‡è·¨åº¦åç§°")
  assert_eq(SpanContext::trace_id(chinese_span_ctx), "ä¸­æ–‡è¿½è¸ªID")
  
  assert_eq(Span::name(arabic_span), "Ø§Ø³Ù… Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯")
  assert_eq(SpanContext::trace_id(arabic_span_ctx), "Ù…Ø¹Ø±Ù Ø§Ù„ØªØªØ¨Ø¹")
  
  assert_eq(Span::name(japanese_span), "ã‚¹ãƒ‘ãƒ³å")
  assert_eq(SpanContext::trace_id(japanese_span_ctx), "ãƒˆãƒ¬ãƒ¼ã‚¹ID")
  
  // Test serialization and deserialization with international data
  let serialized_chinese = SpanSerializer::serialize(chinese_span)
  let deserialized_chinese = SpanSerializer::deserialize(serialized_chinese)
  
  assert_eq(Span::name(deserialized_chinese), "ä¸­æ–‡è·¨åº¦åç§°")
  
  let serialized_arabic = SpanSerializer::serialize(arabic_span)
  let deserialized_arabic = SpanSerializer::deserialize(serialized_arabic)
  
  assert_eq(Span::name(deserialized_arabic), "Ø§Ø³Ù… Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯")
  
  let serialized_japanese = SpanSerializer::serialize(japanese_span)
  let deserialized_japanese = SpanSerializer::deserialize(serialized_japanese)
  
  assert_eq(Span::name(deserialized_japanese), "ã‚¹ãƒ‘ãƒ³å")
}

// Test 7: Localized Error Messages
test "localized error messages" {
  let error_localizer = ErrorLocalizer::new()
  
  // Load error messages for different locales
  let en_errors = {
    "connection.failed": "Connection failed: {0}",
    "data.invalid": "Invalid data: {0}",
    "permission.denied": "Permission denied",
    "resource.not_found": "Resource not found: {0}",
    "timeout.exceeded": "Operation timed out after {0} seconds"
  }
  
  let zh_errors = {
    "connection.failed": "è¿æ¥å¤±è´¥ï¼š{0}",
    "data.invalid": "æ— æ•ˆæ•°æ®ï¼š{0}",
    "permission.denied": "æƒé™è¢«æ‹’ç»",
    "resource.not_found": "èµ„æºæœªæ‰¾åˆ°ï¼š{0}",
    "timeout.exceeded": "æ“ä½œåœ¨ {0} ç§’åè¶…æ—¶"
  }
  
  let ja_errors = {
    "connection.failed": "æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ: {0}",
    "data.invalid": "ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿: {0}",
    "permission.denied": "ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ",
    "resource.not_found": "ãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {0}",
    "timeout.exceeded": "æ“ä½œãŒ {0} ç§’å¾Œã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ"
  }
  
  ErrorLocalizer::load_bundle(error_localizer, "en", en_errors)
  ErrorLocalizer::load_bundle(error_localizer, "zh", zh_errors)
  ErrorLocalizer::load_bundle(error_localizer, "ja", ja_errors)
  
  // Test English error messages
  ErrorLocalizer::set_locale(error_localizer, "en")
  assert_eq(ErrorLocalizer::get_error_message(error_localizer, "permission.denied"), "Permission denied")
  assert_eq(ErrorLocalizer::format_error_message(error_localizer, "connection.failed", ["network unreachable"]), "Connection failed: network unreachable")
  
  // Test Chinese error messages
  ErrorLocalizer::set_locale(error_localizer, "zh")
  assert_eq(ErrorLocalizer::get_error_message(error_localizer, "permission.denied"), "æƒé™è¢«æ‹’ç»")
  assert_eq(ErrorLocalizer::format_error_message(error_localizer, "connection.failed", ["ç½‘ç»œä¸å¯è¾¾"]), "è¿æ¥å¤±è´¥ï¼šç½‘ç»œä¸å¯è¾¾")
  
  // Test Japanese error messages
  ErrorLocalizer::set_locale(error_localizer, "ja")
  assert_eq(ErrorLocalizer::get_error_message(error_localizer, "permission.denied"), "ã‚¢ã‚¯ã‚»ã‚¹ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸ")
  assert_eq(ErrorLocalizer::format_error_message(error_localizer, "connection.failed", ["ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«åˆ°é”ã§ãã¾ã›ã‚“"]), "æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ: ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«åˆ°é”ã§ãã¾ã›ã‚“")
}

// Test 8: Localized Log Messages
test "localized log messages" {
  let log_localizer = LogLocalizer::new()
  
  // Load log messages for different locales
  let en_logs = {
    "service.started": "Service {0} started on port {1}",
    "service.stopped": "Service {0} stopped",
    "request.received": "Received {0} request from {1}",
    "response.sent": "Sent {0} response to {1}",
    "error.occurred": "Error occurred: {0}"
  }
  
  let zh_logs = {
    "service.started": "æœåŠ¡ {0} å·²åœ¨ç«¯å£ {1} ä¸Šå¯åŠ¨",
    "service.stopped": "æœåŠ¡ {0} å·²åœæ­¢",
    "request.received": "ä» {1} æ”¶åˆ° {0} è¯·æ±‚",
    "response.sent": "å‘ {1} å‘é€ {0} å“åº”",
    "error.occurred": "å‘ç”Ÿé”™è¯¯ï¼š{0}"
  }
  
  let ja_logs = {
    "service.started": "ã‚µãƒ¼ãƒ“ã‚¹ {0} ãŒãƒãƒ¼ãƒˆ {1} ã§é–‹å§‹ã•ã‚Œã¾ã—ãŸ",
    "service.stopped": "ã‚µãƒ¼ãƒ“ã‚¹ {0} ãŒåœæ­¢ã•ã‚Œã¾ã—ãŸ",
    "request.received": "{1} ã‹ã‚‰ {0} ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä¿¡ã—ã¾ã—ãŸ",
    "response.sent": "{1} ã« {0} ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’é€ä¿¡ã—ã¾ã—ãŸ",
    "error.occurred": "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {0}"
  }
  
  LogLocalizer::load_bundle(log_localizer, "en", en_logs)
  LogLocalizer::load_bundle(log_localizer, "zh", zh_logs)
  LogLocalizer::load_bundle(log_localizer, "ja", ja_logs)
  
  // Create localized log records
  LogLocalizer::set_locale(log_localizer, "en")
  let en_log = LogLocalizer::create_log(log_localizer, Info, "service.started", ["telemetry", "8080"])
  assert_eq(LogRecord::severity_number(en_log), Info)
  match LogRecord::body(en_log) {
    Some(body) => assert_eq(body, "Service telemetry started on port 8080")
    None => assert_true(false)
  }
  
  LogLocalizer::set_locale(log_localizer, "zh")
  let zh_log = LogLocalizer::create_log(log_localizer, Info, "service.started", ["é¥æµ‹", "8080"])
  match LogRecord::body(zh_log) {
    Some(body) => assert_eq(body, "æœåŠ¡ é¥æµ‹ å·²åœ¨ç«¯å£ 8080 ä¸Šå¯åŠ¨")
    None => assert_true(false)
  }
  
  LogLocalizer::set_locale(log_localizer, "ja")
  let ja_log = LogLocalizer::create_log(log_localizer, Info, "service.started", ["ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª", "8080"])
  match LogRecord::body(ja_log) {
    Some(body) => assert_eq(body, "ã‚µãƒ¼ãƒ“ã‚¹ ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª ãŒãƒãƒ¼ãƒˆ 8080 ã§é–‹å§‹ã•ã‚Œã¾ã—ãŸ")
    None => assert_true(false)
  }
}

// Test 9: Localized Metric Names and Descriptions
test "localized metric names and descriptions" {
  let metric_localizer = MetricLocalizer::new()
  
  // Load metric information for different locales
  let en_metrics = {
    "cpu.usage": {
      "name": "CPU Usage",
      "description": "Percentage of CPU utilization",
      "unit": "%"
    },
    "memory.usage": {
      "name": "Memory Usage",
      "description": "Percentage of memory utilization",
      "unit": "%"
    },
    "request.count": {
      "name": "Request Count",
      "description": "Total number of requests",
      "unit": "count"
    }
  }
  
  let zh_metrics = {
    "cpu.usage": {
      "name": "CPUä½¿ç”¨ç‡",
      "description": "CPUåˆ©ç”¨ç‡ç™¾åˆ†æ¯”",
      "unit": "%"
    },
    "memory.usage": {
      "name": "å†…å­˜ä½¿ç”¨ç‡",
      "description": "å†…å­˜åˆ©ç”¨ç‡ç™¾åˆ†æ¯”",
      "unit": "%"
    },
    "request.count": {
      "name": "è¯·æ±‚æ•°é‡",
      "description": "è¯·æ±‚æ€»æ•°",
      "unit": "è®¡æ•°"
    }
  }
  
  let ja_metrics = {
    "cpu.usage": {
      "name": "CPUä½¿ç”¨ç‡",
      "description": "CPUåˆ©ç”¨ç‡ã®ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸",
      "unit": "%"
    },
    "memory.usage": {
      "name": "ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡",
      "description": "ãƒ¡ãƒ¢ãƒªåˆ©ç”¨ç‡ã®ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸",
      "unit": "%"
    },
    "request.count": {
      "name": "ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°",
      "description": "ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ç·æ•°",
      "unit": "ã‚«ã‚¦ãƒ³ãƒˆ"
    }
  }
  
  MetricLocalizer::load_bundle(metric_localizer, "en", en_metrics)
  MetricLocalizer::load_bundle(metric_localizer, "zh", zh_metrics)
  MetricLocalizer::load_bundle(metric_localizer, "ja", ja_metrics)
  
  // Test English metric information
  MetricLocalizer::set_locale(metric_localizer, "en")
  let en_cpu_info = MetricLocalizer::get_metric_info(metric_localizer, "cpu.usage")
  assert_eq(en_cpu_info.name, "CPU Usage")
  assert_eq(en_cpu_info.description, "Percentage of CPU utilization")
  assert_eq(en_cpu_info.unit, "%")
  
  // Test Chinese metric information
  MetricLocalizer::set_locale(metric_localizer, "zh")
  let zh_cpu_info = MetricLocalizer::get_metric_info(metric_localizer, "cpu.usage")
  assert_eq(zh_cpu_info.name, "CPUä½¿ç”¨ç‡")
  assert_eq(zh_cpu_info.description, "CPUåˆ©ç”¨ç‡ç™¾åˆ†æ¯”")
  assert_eq(zh_cpu_info.unit, "%")
  
  // Test Japanese metric information
  MetricLocalizer::set_locale(metric_localizer, "ja")
  let ja_cpu_info = MetricLocalizer::get_metric_info(metric_localizer, "cpu.usage")
  assert_eq(ja_cpu_info.name, "CPUä½¿ç”¨ç‡")
  assert_eq(ja_cpu_info.description, "CPUåˆ©ç”¨ç‡ã®ãƒ‘ãƒ¼ã‚»ãƒ³ãƒ†ãƒ¼ã‚¸")
  assert_eq(ja_cpu_info.unit, "%")
}

// Test 10: Locale-aware Sorting and Comparison
test "locale-aware sorting and comparison" {
  let string_comparator = StringComparator::new()
  
  // Test strings with different locales
  let strings = ["apple", "banana", "cherry", "date", "elderberry"]
  let chinese_strings = ["è‹¹æœ", "é¦™è•‰", "æ¨±æ¡ƒ", "æ£", "æ¥éª¨æœ¨è“"]
  let japanese_strings = ["ã‚Šã‚“ã”", "ãƒãƒŠãƒŠ", "ãƒã‚§ãƒªãƒ¼", "ãƒ‡ãƒ¼ãƒˆ", "ã‚¨ãƒ«ãƒ€ãƒ™ãƒªãƒ¼"]
  
  // Test English sorting
  StringComparator::set_locale(string_comparator, "en-US")
  let sorted_en = StringComparator::sort(string_comparator, strings)
  assert_eq(sorted_en, ["apple", "banana", "cherry", "date", "elderberry"])
  
  // Test Chinese sorting
  StringComparator::set_locale(string_comparator, "zh-CN")
  let sorted_zh = StringComparator::sort(string_comparator, chinese_strings)
  // Note: Actual sorting order depends on Chinese collation rules
  assert_eq(sorted_zh.length(), 5)
  assert_true(sorted_zh.contains("è‹¹æœ"))
  assert_true(sorted_zh.contains("é¦™è•‰"))
  
  // Test Japanese sorting
  StringComparator::set_locale(string_comparator, "ja-JP")
  let sorted_ja = StringComparator::sort(string_comparator, japanese_strings)
  // Note: Actual sorting order depends on Japanese collation rules
  assert_eq(sorted_ja.length(), 5)
  assert_true(sorted_ja.contains("ã‚Šã‚“ã”"))
  assert_true(sorted_ja.contains("ãƒãƒŠãƒŠ"))
  
  // Test locale-aware comparison
  StringComparator::set_locale(string_comparator, "en-US")
  assert_eq(StringComparator::compare(string_comparator, "apple", "banana"), -1)
  assert_eq(StringComparator::compare(string_comparator, "banana", "apple"), 1)
  assert_eq(StringComparator::compare(string_comparator, "apple", "apple"), 0)
  
  // Test case-insensitive comparison
  StringComparator::set_case_sensitive(string_comparator, false)
  assert_eq(StringComparator::compare(string_comparator, "Apple", "apple"), 0)
  assert_eq(StringComparator::compare(string_comparator, "APPLE", "banana"), -1)
  
  // Test accent-sensitive comparison
  StringComparator::set_locale(string_comparator, "fr-FR")
  StringComparator::set_case_sensitive(string_comparator, false)
  assert_eq(StringComparator::compare(string_comparator, "cafÃ©", "cafe"), 1) // cafÃ© comes after cafe
}