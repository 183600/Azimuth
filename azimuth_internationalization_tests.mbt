// Azimuth Internationalization Test Suite
// å›½é™…åŒ–å’Œæœ¬åœ°åŒ–æµ‹è¯•å¥—ä»¶ - ä¸“æ³¨äºå¤šè¯­è¨€æ”¯æŒã€åœ°åŒºæ ¼å¼åŒ–å’Œæ–‡åŒ–é€‚é…

// æµ‹è¯•1: å¤šè¯­è¨€èµ„æºç®¡ç†
test "å¤šè¯­è¨€èµ„æºç®¡ç†æµ‹è¯•" {
  // åˆ›å»ºå›½é™…åŒ–èµ„æºç®¡ç†å™¨
  let i18n_manager = I18nResourceManager::new()
  I18nResourceManager::set_default_locale(i18n_manager, "en-US")
  I18nResourceManager::set_fallback_locale(i18n_manager, "en-US")
  I18nResourceManager::set_resource_path(i18n_manager, "/resources/i18n")
  
  // åˆå§‹åŒ–èµ„æºç®¡ç†å™¨
  let init_result = I18nResourceManager::initialize(i18n_manager)
  assert_true(init_result.success)
  
  // åŠ è½½è¯­è¨€èµ„æº
  let supported_locales = ["en-US", "zh-CN", "ja-JP", "fr-FR", "de-DE", "es-ES", "pt-BR", "ru-RU"]
  
  for locale in supported_locales {
    let load_result = I18nResourceManager::load_locale(i18n_manager, locale)
    assert_true(load_result.success)
  }
  
  // éªŒè¯å·²åŠ è½½çš„è¯­è¨€
  let loaded_locales = I18nResourceManager::get_loaded_locales(i18n_manager)
  assert_true(loaded_locales.length() >= supported_locales.length())
  
  for locale in supported_locales {
    assert_true(loaded_locales.contains(locale))
  }
  
  // æµ‹è¯•èµ„æºé”®å€¼è·å–
  let test_keys = [
    "telemetry.span.name",
    "telemetry.span.status.ok",
    "telemetry.span.status.error",
    "telemetry.metric.cpu.usage",
    "telemetry.error.connection.timeout",
    "telemetry.service.azimuth.name",
    "telemetry.dashboard.title",
    "telemetry.config.sampling.rate"
  ]
  
  // æµ‹è¯•è‹±æ–‡èµ„æº
  I18nResourceManager::set_current_locale(i18n_manager, "en-US")
  
  for key in test_keys {
    let get_result = I18nResourceManager::get_string(i18n_manager, key)
    assert_true(get_result.success)
    assert_true(get_result.value.length() > 0)
  }
  
  // æµ‹è¯•ä¸­æ–‡èµ„æº
  I18nResourceManager::set_current_locale(i18n_manager, "zh-CN")
  
  let zh_results = []
  for key in test_keys {
    let get_result = I18nResourceManager::get_string(i18n_manager, key)
    assert_true(get_result.success)
    zh_results.push(get_result.value)
  }
  
  // éªŒè¯ä¸­æ–‡èµ„æºåŒ…å«ä¸­æ–‡å­—ç¬¦
  for value in zh_results {
    assert_true(value.contains("é¥æµ‹") || value.contains("è·¨åº¦") || 
                 value.contains("çŠ¶æ€") || value.contains("æœåŠ¡") ||
                 value.contains("é…ç½®") || value.contains("é‡‡æ ·"))
  }
  
  // æµ‹è¯•æ—¥æ–‡èµ„æº
  I18nResourceManager::set_current_locale(i18n_manager, "ja-JP")
  
  for key in test_keys {
    let get_result = I18nResourceManager::get_string(i18n_manager, key)
    assert_true(get_result.success)
    assert_true(get_result.value.contains("ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª") || 
                 get_result.value.contains("ã‚¹ãƒ‘ãƒ³") ||
                 get_result.value.contains("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹") ||
                 get_result.value.contains("ã‚µãƒ¼ãƒ“ã‚¹"))
  }
  
  // æµ‹è¯•å‚æ•°åŒ–èµ„æº
  I18nResourceManager::set_current_locale(i18n_manager, "en-US")
  
  let param_key = "telemetry.span.duration"
  let params = [
    ("span_name", "http.request"),
    ("duration_ms", "250"),
    ("unit", "ms")
  ]
  
  let param_result = I18nResourceManager::get_formatted_string(i18n_manager, param_key, params)
  assert_true(param_result.success)
  assert_true(param_result.value.contains("http.request"))
  assert_true(param_result.value.contains("250"))
  
  // æµ‹è¯•å¤æ•°å½¢å¼
  I18nResourceManager::set_current_locale(i18n_manager, "en-US")
  
  let plural_key = "telemetry.spans.count"
  let plural_params = [("count", "1")]
  let singular_result = I18nResourceManager::get_plural_string(i18n_manager, plural_key, plural_params)
  assert_true(singular_result.success)
  assert_true(singular_result.value.contains("span"))
  
  let plural_params_plural = [("count", "5")]
  let plural_result = I18nResourceManager::get_plural_string(i18n_manager, plural_key, plural_params_plural)
  assert_true(plural_result.success)
  assert_true(plural_result.value.contains("spans"))
  
  // æµ‹è¯•ä¸­æ–‡å¤æ•°å½¢å¼ï¼ˆä¸­æ–‡æ²¡æœ‰å¤æ•°å˜åŒ–ï¼‰
  I18nResourceManager::set_current_locale(i18n_manager, "zh-CN")
  
  let zh_singular_result = I18nResourceManager::get_plural_string(i18n_manager, plural_key, plural_params)
  assert_true(zh_singular_result.success)
  
  let zh_plural_result = I18nResourceManager::get_plural_string(i18n_manager, plural_key, plural_params_plural)
  assert_true(zh_plural_result.success)
  
  // ä¸­æ–‡é€šå¸¸å•å¤æ•°å½¢å¼ç›¸åŒ
  assert_eq(zh_singular_result.value, zh_plural_result.value)
  
  // æµ‹è¯•èµ„æºå›é€€æœºåˆ¶
  I18nResourceManager::set_current_locale(i18n_manager, "unsupported-locale")
  
  // åº”è¯¥å›é€€åˆ°é»˜è®¤è¯­è¨€
  let fallback_result = I18nResourceManager::get_string(i18n_manager, "telemetry.span.name")
  assert_true(fallback_result.success)
  
  // éªŒè¯å›é€€åˆ°é»˜è®¤è¯­è¨€
  I18nResourceManager::set_current_locale(i18n_manager, "en-US")
  let default_result = I18nResourceManager::get_string(i18n_manager, "telemetry.span.name")
  assert_eq(fallback_result.value, default_result.value)
  
  // æµ‹è¯•èµ„æºçƒ­é‡è½½
  let reload_result = I18nResourceManager::reload_locale(i18n_manager, "en-US")
  assert_true(reload_result.success)
  
  // éªŒè¯é‡è½½åçš„èµ„æºä»ç„¶å¯ç”¨
  let post_reload_result = I18nResourceManager::get_string(i18n_manager, "telemetry.span.name")
  assert_true(post_reload_result.success)
  
  // æµ‹è¯•èµ„æºç¼“å­˜
  let cache_stats = I18nResourceManager::get_cache_stats(i18n_manager)
  assert_true(cache_stats.total_entries > 0)
  assert_true(cache_stats.hit_rate >= 0.0)
  assert_true(cache_stats.hit_rate <= 1.0)
  
  // æ¸…ç†èµ„æº
  let shutdown_result = I18nResourceManager::shutdown(i18n_manager)
  assert_true(shutdown_result.success)
}

// æµ‹è¯•2: æ—¥æœŸå’Œæ—¶é—´æ ¼å¼åŒ–
test "æ—¥æœŸå’Œæ—¶é—´æ ¼å¼åŒ–æµ‹è¯•" {
  // åˆ›å»ºæ—¥æœŸæ—¶é—´æ ¼å¼åŒ–å™¨
  let date_formatter = DateTimeFormatter::new()
  
  // æµ‹è¯•ä¸åŒåœ°åŒºçš„æ—¥æœŸæ ¼å¼
  let date_formats = [
    ("en-US", "MM/dd/yyyy"),      // ç¾å›½æ ¼å¼: 01/04/2026
    ("zh-CN", "yyyyå¹´MMæœˆddæ—¥"),  // ä¸­å›½æ ¼å¼: 2026å¹´01æœˆ04æ—¥
    ("ja-JP", "yyyy/MM/dd"),      // æ—¥æœ¬æ ¼å¼: 2026/01/04
    ("fr-FR", "dd/MM/yyyy"),      // æ³•å›½æ ¼å¼: 04/01/2026
    ("de-DE", "dd.MM.yyyy"),      // å¾·å›½æ ¼å¼: 04.01.2026
    ("es-ES", "dd/MM/yyyy"),      // è¥¿ç­ç‰™æ ¼å¼: 04/01/2026
    ("ru-RU", "dd.MM.yyyy"),      // ä¿„è¯­æ ¼å¼: 04.01.2026
    ("pt-BR", "dd/MM/yyyy")       // å·´è¥¿æ ¼å¼: 04/01/2026
  ]
  
  let test_timestamp = 1640995200000 // 2022-01-01 00:00:00 UTC
  
  for (locale, expected_pattern) in date_formats {
    DateTimeFormatter::set_locale(date_formatter, locale)
    
    let format_result = DateTimeFormatter::format_date(date_formatter, test_timestamp)
    assert_true(format_result.success)
    
    let formatted_date = format_result.formatted_string
    assert_true(formatted_date.length() > 0)
    
    // éªŒè¯æ ¼å¼ç¬¦åˆé¢„æœŸ
    if locale == "en-US" {
      assert_true(formatted_date.contains("01/04/2026"))
    } else if locale == "zh-CN" {
      assert_true(formatted_date.contains("2026å¹´01æœˆ04æ—¥"))
    } else if locale == "ja-JP" {
      assert_true(formatted_date.contains("2026/01/04"))
    }
  }
  
  // æµ‹è¯•æ—¶é—´æ ¼å¼
  let time_formats = [
    ("en-US", "h:mm:ss a"),        // ç¾å›½æ ¼å¼: 12:00:00 AM
    ("zh-CN", "HH:mm:ss"),         // ä¸­å›½æ ¼å¼: 00:00:00
    ("ja-JP", "HH:mm:ss"),         // æ—¥æœ¬æ ¼å¼: 00:00:00
    ("fr-FR", "HH:mm:ss"),         // æ³•å›½æ ¼å¼: 00:00:00
    ("de-DE", "HH:mm:ss"),         // å¾·å›½æ ¼å¼: 00:00:00
    ("es-ES", "HH:mm:ss"),         // è¥¿ç­ç‰™æ ¼å¼: 00:00:00
    ("ru-RU", "HH:mm:ss"),         // ä¿„è¯­æ ¼å¼: 00:00:00
    ("pt-BR", "HH:mm:ss")          // å·´è¥¿æ ¼å¼: 00:00:00
  ]
  
  for (locale, expected_pattern) in time_formats {
    DateTimeFormatter::set_locale(date_formatter, locale)
    
    let format_result = DateTimeFormatter::format_time(date_formatter, test_timestamp)
    assert_true(format_result.success)
    
    let formatted_time = format_result.formatted_string
    assert_true(formatted_time.length() > 0)
    
    // éªŒè¯æ—¶é—´æ ¼å¼
    if locale == "en-US" {
      assert_true(formatted_time.contains("12:00:00 AM") || formatted_time.contains("00:00:00"))
    } else if locale == "zh-CN" {
      assert_true(formatted_time.contains("00:00:00"))
    }
  }
  
  // æµ‹è¯•æ—¥æœŸæ—¶é—´ç»„åˆæ ¼å¼
  DateTimeFormatter::set_locale(date_formatter, "en-US")
  let datetime_result = DateTimeFormatter::format_datetime(date_formatter, test_timestamp)
  assert_true(datetime_result.success)
  assert_true(datetime_result.formatted_string.length() > 0)
  
  // æµ‹è¯•ç›¸å¯¹æ—¶é—´æ ¼å¼
  let now_timestamp = 1640995200000
  let past_timestamp = now_timestamp - 3600000 // 1å°æ—¶å‰
  
  let relative_result = DateTimeFormatter::format_relative(date_formatter, past_timestamp, now_timestamp)
  assert_true(relative_result.success)
  assert_true(relative_result.formatted_string.contains("hour") || relative_result.formatted_string.contains("å°æ—¶"))
  
  // æµ‹è¯•æ—¶åŒºå¤„ç†
  let timezones = [
    ("UTC", 0),
    ("America/New_York", -5),
    ("Europe/London", 0),
    ("Asia/Shanghai", 8),
    ("Asia/Tokyo", 9),
    ("America/Los_Angeles", -8)
  ]
  
  for (timezone_name, offset) in timezones {
    DateTimeFormatter::set_timezone(date_formatter, timezone_name)
    
    let timezone_result = DateTimeFormatter::format_datetime(date_formatter, test_timestamp)
    assert_true(timezone_result.success)
    
    // éªŒè¯æ—¶åŒºä¿¡æ¯
    let timezone_info = timezone_result.timezone_info
    assert_eq(timezone_info.name, timezone_name)
    assert_eq(timezone_info.offset, offset)
  }
  
  // æµ‹è¯•æœ¬åœ°åŒ–æœˆä»½å’Œæ˜ŸæœŸåç§°
  let month_names = [
    ("en-US", ["January", "February", "March", "April", "May", "June", 
               "July", "August", "September", "October", "November", "December"]),
    ("zh-CN", ["ä¸€æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ", "äº”æœˆ", "å…­æœˆ", 
               "ä¸ƒæœˆ", "å…«æœˆ", "ä¹æœˆ", "åæœˆ", "åä¸€æœˆ", "åäºŒæœˆ"]),
    ("ja-JP", ["1æœˆ", "2æœˆ", "3æœˆ", "4æœˆ", "5æœˆ", "6æœˆ", 
               "7æœˆ", "8æœˆ", "9æœˆ", "10æœˆ", "11æœˆ", "12æœˆ"])
  ]
  
  for (locale, expected_months) in month_names {
    DateTimeFormatter::set_locale(date_formatter, locale)
    
    for i in 0..=11 {
      let month_result = DateTimeFormatter::get_month_name(date_formatter, i)
      assert_true(month_result.success)
      assert_eq(month_result.month_name, expected_months[i])
    }
  }
  
  // æµ‹è¯•æœ¬åœ°åŒ–æ˜ŸæœŸåç§°
  let day_names = [
    ("en-US", ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]),
    ("zh-CN", ["æ˜ŸæœŸæ—¥", "æ˜ŸæœŸä¸€", "æ˜ŸæœŸäºŒ", "æ˜ŸæœŸä¸‰", "æ˜ŸæœŸå››", "æ˜ŸæœŸäº”", "æ˜ŸæœŸå…­"]),
    ("ja-JP", ["æ—¥æ›œæ—¥", "æœˆæ›œæ—¥", "ç«æ›œæ—¥", "æ°´æ›œæ—¥", "æœ¨æ›œæ—¥", "é‡‘æ›œæ—¥", "åœŸæ›œæ—¥"])
  ]
  
  for (locale, expected_days) in day_names {
    DateTimeFormatter::set_locale(date_formatter, locale)
    
    for i in 0..=6 {
      let day_result = DateTimeFormatter::get_day_name(date_formatter, i)
      assert_true(day_result.success)
      assert_eq(day_result.day_name, expected_days[i])
    }
  }
  
  // æµ‹è¯•æ—¥æœŸè§£æ
  DateTimeFormatter::set_locale(date_formatter, "en-US")
  
  let parse_result = DateTimeFormatter::parse_date(date_formatter, "01/04/2026")
  assert_true(parse_result.success)
  assert_eq(parse_result.timestamp, test_timestamp)
  
  // æµ‹è¯•æ—¥æœŸæ—¶é—´è§£æ
  let datetime_parse_result = DateTimeFormatter::parse_datetime(date_formatter, "01/04/2026 12:00:00 AM")
  assert_true(datetime_parse_result.success)
  
  // éªŒè¯è‡ªå®šä¹‰æ ¼å¼
  DateTimeFormatter::set_custom_format(date_formatter, "yyyy-MM-dd'T'HH:mm:ss")
  let custom_result = DateTimeFormatter::format_datetime(date_formatter, test_timestamp)
  assert_true(custom_result.success)
  assert_true(custom_result.formatted_string.contains("2022-01-01"))
}

// æµ‹è¯•3: æ•°å­—å’Œè´§å¸æ ¼å¼åŒ–
test "æ•°å­—å’Œè´§å¸æ ¼å¼åŒ–æµ‹è¯•" {
  // åˆ›å»ºæ•°å­—æ ¼å¼åŒ–å™¨
  let number_formatter = NumberFormatter::new()
  
  // æµ‹è¯•ä¸åŒåœ°åŒºçš„æ•°å­—æ ¼å¼
  let number_formats = [
    ("en-US", "1,234,567.89"),    // ç¾å›½æ ¼å¼: é€—å·åˆ†éš”ï¼Œç‚¹å·å°æ•°ç‚¹
    ("zh-CN", "1,234,567.89"),    // ä¸­å›½æ ¼å¼: é€—å·åˆ†éš”ï¼Œç‚¹å·å°æ•°ç‚¹
    ("de-DE", "1.234.567,89"),    // å¾·å›½æ ¼å¼: ç‚¹å·åˆ†éš”ï¼Œé€—å·å°æ•°ç‚¹
    ("fr-FR", "1 234 567,89"),    // æ³•å›½æ ¼å¼: ç©ºæ ¼åˆ†éš”ï¼Œé€—å·å°æ•°ç‚¹
    ("ja-JP", "1,234,567.89"),    // æ—¥æœ¬æ ¼å¼: é€—å·åˆ†éš”ï¼Œç‚¹å·å°æ•°ç‚¹
    ("ru-RU", "1 234 567,89"),    // ä¿„è¯­æ ¼å¼: ç©ºæ ¼åˆ†éš”ï¼Œé€—å·å°æ•°ç‚¹
    ("es-ES", "1.234.567,89"),    // è¥¿ç­ç‰™æ ¼å¼: ç‚¹å·åˆ†éš”ï¼Œé€—å·å°æ•°ç‚¹
    ("pt-BR", "1.234.567,89")     // å·´è¥¿æ ¼å¼: ç‚¹å·åˆ†éš”ï¼Œé€—å·å°æ•°ç‚¹
  ]
  
  let test_number = 1234567.89
  
  for (locale, expected_format) in number_formats {
    NumberFormatter::set_locale(number_formatter, locale)
    
    let format_result = NumberFormatter::format(number_formatter, test_number)
    assert_true(format_result.success)
    
    let formatted_number = format_result.formatted_string
    assert_true(formatted_number.length() > 0)
    
    // éªŒè¯æ ¼å¼ç¬¦åˆé¢„æœŸ
    if locale == "en-US" || locale == "zh-CN" || locale == "ja-JP" {
      assert_true(formatted_number.contains("1,234,567.89"))
    } else if locale == "de-DE" || locale == "es-ES" || locale == "pt-BR" {
      assert_true(formatted_number.contains("1.234.567,89"))
    } else if locale == "fr-FR" || locale == "ru-RU" {
      assert_true(formatted_number.contains("1 234 567,89"))
    }
  }
  
  // æµ‹è¯•ç™¾åˆ†æ¯”æ ¼å¼
  NumberFormatter::set_locale(number_formatter, "en-US")
  NumberFormatter::set_percent_style(number_formatter, true)
  
  let percent_result = NumberFormatter::format(number_formatter, 0.7543)
  assert_true(percent_result.success)
  assert_true(percent_result.formatted_string.contains("%"))
  
  // æµ‹è¯•ç§‘å­¦è®¡æ•°æ³•
  NumberFormatter::set_scientific_style(number_formatter, true)
  
  let scientific_result = NumberFormatter::format(number_formatter, 1234567.89)
  assert_true(scientific_result.success)
  assert_true(scientific_result.formatted_string.contains("E"))
  
  // æµ‹è¯•è´§å¸æ ¼å¼
  let currency_formatter = CurrencyFormatter::new()
  
  let currency_formats = [
    ("en-US", "USD", "$1,234,567.89"),      // ç¾å…ƒ
    ("zh-CN", "CNY", "Â¥1,234,567.89"),      // äººæ°‘å¸
    ("ja-JP", "JPY", "Â¥1,234,567"),          // æ—¥å…ƒï¼ˆæ— å°æ•°ï¼‰
    ("de-DE", "EUR", "1.234.567,89 â‚¬"),      // æ¬§å…ƒ
    ("fr-FR", "EUR", "1 234 567,89 â‚¬"),      // æ¬§å…ƒ
    ("ru-RU", "RUB", "1 234 567,89 â‚½"),      // å¢å¸ƒ
    ("es-ES", "EUR", "1.234.567,89 â‚¬"),      // æ¬§å…ƒ
    ("pt-BR", "BRL", "R$ 1.234.567,89")      // å·´è¥¿é›·äºšå°”
  ]
  
  for (locale, currency_code, expected_format) in currency_formats {
    CurrencyFormatter::set_locale(currency_formatter, locale)
    CurrencyFormatter::set_currency_code(currency_formatter, currency_code)
    
    let format_result = CurrencyFormatter::format(currency_formatter, test_number)
    assert_true(format_result.success)
    
    let formatted_currency = format_result.formatted_string
    assert_true(formatted_currency.length() > 0)
    
    // éªŒè¯è´§å¸ç¬¦å·
    if currency_code == "USD" {
      assert_true(formatted_currency.contains("$"))
    } else if currency_code == "CNY" {
      assert_true(formatted_currency.contains("Â¥"))
    } else if currency_code == "JPY" {
      assert_true(formatted_currency.contains("Â¥"))
    } else if currency_code == "EUR" {
      assert_true(formatted_currency.contains("â‚¬"))
    } else if currency_code == "RUB" {
      assert_true(formatted_currency.contains("â‚½"))
    } else if currency_code == "BRL" {
      assert_true(formatted_currency.contains("R$"))
    }
  }
  
  // æµ‹è¯•å•ä½æ ¼å¼åŒ–
  let unit_formatter = UnitFormatter::new()
  
  let unit_tests = [
    ("en-US", "length", "meter", 1234.5, "1,234.5 m"),
    ("zh-CN", "length", "meter", 1234.5, "1,234.5 ç±³"),
    ("ja-JP", "length", "meter", 1234.5, "1,234.5 ãƒ¡ãƒ¼ãƒˆãƒ«"),
    ("en-US", "weight", "kilogram", 75.2, "75.2 kg"),
    ("zh-CN", "weight", "kilogram", 75.2, "75.2 åƒå…‹"),
    ("ja-JP", "weight", "kilogram", 75.2, "75.2 ã‚­ãƒ­ã‚°ãƒ©ãƒ "),
    ("en-US", "temperature", "celsius", 25.5, "25.5Â°C"),
    ("zh-CN", "temperature", "celsius", 25.5, "25.5Â°C"),
    ("ja-JP", "temperature", "celsius", 25.5, "25.5Â°C")
  ]
  
  for (locale, unit_type, unit_name, value, expected_format) in unit_tests {
    UnitFormatter::set_locale(unit_formatter, locale)
    
    let format_result = UnitFormatter::format(unit_formatter, value, unit_type, unit_name)
    assert_true(format_result.success)
    
    let formatted_unit = format_result.formatted_string
    assert_true(formatted_unit.length() > 0)
    
    // éªŒè¯å•ä½ç¬¦å·
    if unit_type == "length" && unit_name == "meter" {
      if locale == "en-US" {
        assert_true(formatted_unit.contains("m"))
      } else if locale == "zh-CN" {
        assert_true(formatted_unit.contains("ç±³"))
      } else if locale == "ja-JP" {
        assert_true(formatted_unit.contains("ãƒ¡ãƒ¼ãƒˆãƒ«"))
      }
    }
  }
  
  // æµ‹è¯•æ•°å­—è§£æ
  NumberFormatter::set_locale(number_formatter, "en-US")
  NumberFormatter::set_decimal_style(number_formatter, true)
  
  let parse_result = NumberFormatter::parse(number_formatter, "1,234,567.89")
  assert_true(parse_result.success)
  assert_true(parse_result.value - test_number < 0.001)
  
  // æµ‹è¯•å¤§æ•°å­—æ ¼å¼åŒ–
  let large_number = 1234567890123456.78
  
  NumberFormatter::set_locale(number_formatter, "en-US")
  let large_result = NumberFormatter::format_large(number_formatter, large_number)
  assert_true(large_result.success)
  
  // æµ‹è¯•å°æ•°ç²¾åº¦æ§åˆ¶
  NumberFormatter::set_decimal_places(number_formatter, 2)
  
  let precision_result = NumberFormatter::format(number_formatter, 3.14159265)
  assert_true(precision_result.success)
  assert_true(precision_result.formatted_string.contains("3.14"))
  
  // æµ‹è¯•æ•°å­—åˆ†ç»„
  NumberFormatter::set_grouping_used(number_formatter, true)
  NumberFormatter::set_grouping_size(number_formatter, 3)
  
  let grouping_result = NumberFormatter::format(number_formatter, 12345678)
  assert_true(grouping_result.success)
  assert_true(grouping_result.formatted_string.contains("12,345,678"))
}

// æµ‹è¯•4: æ–‡æœ¬æ–¹å‘å’Œä¹¦å†™ç³»ç»Ÿ
test "æ–‡æœ¬æ–¹å‘å’Œä¹¦å†™ç³»ç»Ÿæµ‹è¯•" {
  // åˆ›å»ºæ–‡æœ¬æ–¹å‘å¤„ç†å™¨
  let text_direction = TextDirectionHandler::new()
  
  // æµ‹è¯•ä»å·¦åˆ°å³(LTR)æ–‡æœ¬
  let ltr_text = "Azimuth Telemetry System"
  let ltr_result = TextDirectionHandler::analyze_direction(text_direction, ltr_text)
  assert_true(ltr_result.success)
  assert_eq(ltr_result.direction, TextDirection::LTR)
  assert_eq(ltr_result.base_direction, TextDirection::LTR)
  
  // æµ‹è¯•ä»å³åˆ°å·¦(RTL)æ–‡æœ¬
  let rtl_text = "Ù†Ø¸Ø§Ù… Ù‚ÙŠØ§Ø³ Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø¹Ù† Ø¨Ø¹Ø¯"
  let rtl_result = TextDirectionHandler::analyze_direction(text_direction, rtl_text)
  assert_true(rtl_result.success)
  assert_eq(rtl_result.direction, TextDirection::RTL)
  assert_eq(rtl_result.base_direction, TextDirection::RTL)
  
  // æµ‹è¯•æ··åˆæ–¹å‘æ–‡æœ¬
  let mixed_text = "Azimuth Ù†Ø¸Ø§Ù… Ù‚ÙŠØ§Ø³ Ø§Ù„Ø£Ø¯Ø§Ø¡"
  let mixed_result = TextDirectionHandler::analyze_direction(text_direction, mixed_text)
  assert_true(mixed_result.success)
  assert_true(mixed_result.has_mixed_direction)
  
  // æµ‹è¯•é˜¿æ‹‰ä¼¯è¯­æœ¬åœ°åŒ–
  let arabic_formatter = ArabicTextFormatter::new()
  
  let arabic_numbers = [1, 2, 3, 10, 100, 1000]
  let arabic_number_result = ArabicTextFormatter::format_numbers(arabic_formatter, arabic_numbers)
  assert_true(arabic_number_result.success)
  
  // éªŒè¯é˜¿æ‹‰ä¼¯æ•°å­—
  let formatted_arabic = arabic_number_result.formatted_text
  assert_true(formatted_arabic.contains("Ù¡") || formatted_arabic.contains("Ù¢") || 
               formatted_arabic.contains("Ù£") || formatted_arabic.contains("Ù¡Ù "))
  
  // æµ‹è¯•å¸Œä¼¯æ¥è¯­æ–‡æœ¬
  let hebrew_text = "××¢×¨×›×ª ×˜×œ××˜×¨×™×” ××¨×•×—×§×ª"
  let hebrew_result = TextDirectionHandler::analyze_direction(text_direction, hebrew_text)
  assert_true(hebrew_result.success)
  assert_eq(hebrew_result.direction, TextDirection::RTL)
  
  // æµ‹è¯•åŒå‘æ–‡æœ¬æ¸²æŸ“
  let bidi_renderer = BidiTextRenderer::new()
  
  let bidi_text = "Hello Ù…Ø±Ø­Ø¨Ø§ World"
  let bidi_result = BidiTextRenderer::render(bidi_renderer, bidi_text, TextDirection::LTR)
  assert_true(bidi_result.success)
  
  let rendered_text = bidi_result.rendered_text
  assert_true(rendered_text.length() > 0)
  
  // æµ‹è¯•æ–‡æœ¬é•œåƒï¼ˆç”¨äºRTLå¸ƒå±€ï¼‰
  let mirror_result = TextDirectionHandler::mirror_text(text_direction, ltr_text, TextDirection::RTL)
  assert_true(mirror_result.success)
  assert_true(mirror_result.mirrored_text.length() > 0)
  
  // æµ‹è¯•å‚ç›´ä¹¦å†™ç³»ç»Ÿ
  let vertical_formatter = VerticalTextFormatter::new()
  
  let vertical_text = "ç¸¦æ›¸ããƒ†ã‚­ã‚¹ãƒˆ" // æ—¥æ–‡å‚ç›´æ–‡æœ¬
  let vertical_result = VerticalTextFormatter::format(vertical_formatter, vertical_text, VerticalDirection::TopToBottom)
  assert_true(vertical_result.success)
  
  // æµ‹è¯•ä¸­æ—¥éŸ©æ–‡æœ¬å¤„ç†
  let cjk_formatter = CJKTextFormatter::new()
  
  let cjk_texts = [
    ("zh-CN", "é¥æµ‹ç³»ç»Ÿæ€§èƒ½ç›‘æ§"),
    ("ja-JP", "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ æ€§èƒ½ç›£è¦–"),
    ("ko-KR", "ì›ê²© ì¸¡ì • ì‹œìŠ¤í…œ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§")
  ]
  
  for (locale, text) in cjk_texts {
    CJKTextFormatter::set_locale(cjk_formatter, locale)
    
    let format_result = CJKTextFormatter::format(cjk_formatter, text)
    assert_true(format_result.success)
    
    let formatted_cjk = format_result.formatted_text
    assert_true(formatted_cjk.length() > 0)
    
    // éªŒè¯æ–‡æœ¬å±æ€§
    let text_properties = format_result.text_properties
    assert_true(text_properties.is_cjk)
    assert_true(text_properties.line_break_rule == LineBreakRule::CJK)
  }
  
  // æµ‹è¯•æ–‡æœ¬å¯¹é½
  let alignment_formatter = TextAlignmentFormatter::new()
  
  let alignment_tests = [
    (TextDirection::LTR, TextAlignment::Left, "Left aligned LTR text"),
    (TextDirection::LTR, TextAlignment::Right, "Right aligned LTR text"),
    (TextDirection::LTR, TextAlignment::Center, "Center aligned LTR text"),
    (TextDirection::RTL, TextAlignment::Left, "Left aligned RTL text"),
    (TextDirection::RTL, TextAlignment::Right, "Right aligned RTL text"),
    (TextDirection::RTL, TextAlignment::Center, "Center aligned RTL text")
  ]
  
  for (direction, alignment, text) in alignment_tests {
    let align_result = TextAlignmentFormatter::align(alignment_formatter, text, direction, alignment)
    assert_true(align_result.success)
    
    let aligned_text = align_result.aligned_text
    assert_true(aligned_text.length() > 0)
  }
  
  // æµ‹è¯•æ–‡æœ¬æ¢è¡Œ
  let line_breaker = LineBreaker::new()
  
  LineBreaker::set_locale(line_breaker, "zh-CN")
  LineBreaker::set_max_width(line_breaker, 20)
  
  let long_cjk_text = "è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„ä¸­æ–‡æ–‡æœ¬éœ€è¦æ­£ç¡®åœ°è¿›è¡Œæ¢è¡Œå¤„ç†ä»¥ç¡®ä¿å¯è¯»æ€§"
  let break_result = LineBreaker::break_text(line_breaker, long_cjk_text)
  assert_true(break_result.success)
  
  let broken_lines = break_result.lines
  assert_true(broken_lines.length() > 1) // åº”è¯¥è¢«åˆ†æˆå¤šè¡Œ
  
  // æµ‹è¯•æ ‡ç‚¹ç¬¦å·å¤„ç†
  let punctuation_handler = PunctuationHandler::new()
  
  let punctuation_tests = [
    ("en-US", "Hello, world! How are you?"),
    ("zh-CN", "ä½ å¥½ï¼Œä¸–ç•Œï¼ä½ å¥½å—ï¼Ÿ"),
    ("ja-JP", "ã“ã‚“ã«ã¡ã¯ã€ä¸–ç•Œï¼å…ƒæ°—ã§ã™ã‹ï¼Ÿ"),
    ("ar-SA", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…! ÙƒÙŠÙ Ø­Ø§Ù„ÙƒØŸ")
  ]
  
  for (locale, text) in punctuation_tests {
    PunctuationHandler::set_locale(punctuation_handler, locale)
    
    let punct_result = PunctuationHandler::process(punctuation_handler, text)
    assert_true(punct_result.success)
    
    let processed_text = punct_result.processed_text
    assert_true(processed_text.length() > 0)
    
    // éªŒè¯æ ‡ç‚¹ç¬¦å·é—´è·
    if locale == "zh-CN" || locale == "ja-JP" {
      // ä¸­æ—¥æ–‡é€šå¸¸ä¸éœ€è¦æ ‡ç‚¹ç¬¦å·åçš„ç©ºæ ¼
      assert_true(!processed_text.contains("ï¼Œ ") || !processed_text.contains("ï¼ "))
    } else if locale == "en-US" {
      // è‹±æ–‡é€šå¸¸éœ€è¦æ ‡ç‚¹ç¬¦å·åçš„ç©ºæ ¼
      assert_true(processed_text.contains(", ") || processed_text.contains("! "))
    }
  }
}

// æµ‹è¯•5: æ–‡åŒ–ç‰¹å®šæ ¼å¼å’Œçº¦å®š
test "æ–‡åŒ–ç‰¹å®šæ ¼å¼å’Œçº¦å®šæµ‹è¯•" {
  // åˆ›å»ºæ–‡åŒ–æ ¼å¼åŒ–å™¨
  let cultural_formatter = CulturalFormatter::new()
  
  // æµ‹è¯•å§“åæ ¼å¼
  let name_formats = [
    ("en-US", "John Doe", "First Last"),
    ("zh-CN", "å¼ ä¸‰", "å§“ å"),
    ("ja-JP", "ç”°ä¸­ å¤ªéƒ", "å§“ å"),
    ("ko-KR", "ê¹€ì² ìˆ˜", "å§“ å"),
    ("hu-HU", "Nagy JÃ¡nos", "Last First"),
    ("es-ES", "Juan GarcÃ­a", "First Last")
  ]
  
  for (locale, name, expected_format) in name_formats {
    CulturalFormatter::set_locale(cultural_formatter, locale)
    
    let name_result = CulturalFormatter::format_name(cultural_formatter, name)
    assert_true(name_result.success)
    
    let formatted_name = name_result.formatted_name
    assert_true(formatted_name.length() > 0)
    
    let name_info = name_result.name_info
    assert_eq(name_info.format_type, expected_format)
  }
  
  // æµ‹è¯•åœ°å€æ ¼å¼
  let address_formatter = AddressFormatter::new()
  
  let address_data = {
    "street": "123 Main St",
    "city": "New York",
    "state": "NY",
    "postal_code": "10001",
    "country": "United States"
  }
  
  let address_formats = [
    ("en-US", "123 Main St\nNew York, NY 10001\nUnited States"),
    ("zh-CN", "ç¾å›½\nçº½çº¦å·çº½çº¦å¸‚\nä¸»è¡—123å·\né‚®ç¼–: 10001"),
    ("ja-JP", "ã€’10001\nãƒ‹ãƒ¥ãƒ¼ãƒ¨ãƒ¼ã‚¯å·ãƒ‹ãƒ¥ãƒ¼ãƒ¨ãƒ¼ã‚¯å¸‚\nãƒ¡ã‚¤ãƒ³ã‚¹ãƒˆãƒªãƒ¼ãƒˆ123ç•ªåœ°\nã‚¢ãƒ¡ãƒªã‚«åˆè¡†å›½"),
    ("de-DE", "123 Main St\n10001 New York, NY\nUnited States"),
    ("fr-FR", "123 Main St\n10001 New York, NY\nUnited States")
  ]
  
  for (locale, expected_pattern) in address_formats {
    AddressFormatter::set_locale(address_formatter, locale)
    
    let format_result = AddressFormatter::format(address_formatter, address_data)
    assert_true(format_result.success)
    
    let formatted_address = format_result.formatted_address
    assert_true(formatted_address.length() > 0)
    
    // éªŒè¯åœ°å€æ ¼å¼ç¬¦åˆåœ°åŒºä¹ æƒ¯
    if locale == "zh-CN" {
      assert_true(formatted_address.contains("ç¾å›½") && formatted_address.contains("é‚®ç¼–"))
    } else if locale == "ja-JP" {
      assert_true(formatted_address.contains("ã€’") && formatted_address.contains("ç•ªåœ°"))
    }
  }
  
  // æµ‹è¯•ç”µè¯å·ç æ ¼å¼
  let phone_formatter = PhoneFormatter::new()
  
  let phone_number = "+12125551234"
  
  let phone_formats = [
    ("en-US", "+1 (212) 555-1234"),
    ("zh-CN", "+1 212-555-1234"),
    ("ja-JP", "+1-212-555-1234"),
    ("de-DE", "+1 212 5551234"),
    ("fr-FR", "+1 212 55 12 34")
  ]
  
  for (locale, expected_format) in phone_formats {
    PhoneFormatter::set_locale(phone_formatter, locale)
    
    let format_result = PhoneFormatter::format(phone_formatter, phone_number)
    assert_true(format_result.success)
    
    let formatted_phone = format_result.formatted_phone
    assert_true(formatted_phone.length() > 0)
  }
  
  // æµ‹è¯•åº¦é‡è¡¡ç³»ç»Ÿ
  let measurement_formatter = MeasurementFormatter::new()
  
  let measurement_tests = [
    ("en-US", MeasurementSystem::Imperial, "5.5 feet", "1.68 meters"),
    ("zh-CN", MeasurementSystem::Metric, "1.68 ç±³", "5.51 feet"),
    ("ja-JP", MeasurementSystem::Metric, "1.68 ãƒ¡ãƒ¼ãƒˆãƒ«", "5.51 ãƒ•ã‚£ãƒ¼ãƒˆ"),
    ("de-DE", MeasurementSystem::Metric, "1,68 Meter", "5,51 FuÃŸ"),
    ("fr-FR", MeasurementSystem::Metric, "1,68 mÃ¨tre", "5,51 pied")
  ]
  
  let height_in_meters = 1.68
  
  for (locale, system, expected_metric, expected_imperial) in {
    MeasurementFormatter::set_locale(measurement_formatter, locale)
    MeasurementFormatter::set_system(measurement_formatter, system)
    
    let format_result = MeasurementFormatter::format_length(measurement_formatter, height_in_meters, "meter")
    assert_true(format_result.success)
    
    let formatted_length = format_result.formatted_length
    assert_true(formatted_length.length() > 0)
    
    if system == MeasurementSystem::Metric {
      assert_true(formatted_length.contains("1.68") || formatted_length.contains("1,68"))
    }
  }
  
  // æµ‹è¯•çº¸å¼ å°ºå¯¸
  let paper_formatter = PaperSizeFormatter::new()
  
  let paper_sizes = [
    ("en-US", "letter", "8.5 x 11 inches"),
    ("en-US", "legal", "8.5 x 14 inches"),
    ("zh-CN", "a4", "210 x 297 mm"),
    ("ja-JP", "a4", "210 x 297 mm"),
    ("de-DE", "a4", "210 x 297 mm"),
    ("fr-FR", "a4", "210 x 297 mm")
  ]
  
  for (locale, size_name, expected_format) in paper_sizes {
    PaperSizeFormatter::set_locale(paper_formatter, locale)
    
    let format_result = PaperSizeFormatter::format(paper_formatter, size_name)
    assert_true(format_result.success)
    
    let formatted_size = format_result.formatted_size
    assert_true(formatted_size.length() > 0)
  }
  
  // æµ‹è¯•é¢œè‰²å‘½å
  let color_formatter = ColorFormatter::new()
  
  let color_tests = [
    ("en-US", ["red", "blue", "green", "yellow", "black", "white"]),
    ("zh-CN", ["çº¢è‰²", "è“è‰²", "ç»¿è‰²", "é»„è‰²", "é»‘è‰²", "ç™½è‰²"]),
    ("ja-JP", ["èµ¤", "é’", "ç·‘", "é»„", "é»’", "ç™½"]),
    ("de-DE", ["rot", "blau", "grÃ¼n", "gelb", "schwarz", "weiÃŸ"]),
    ("fr-FR", ["rouge", "bleu", "vert", "jaune", "noir", "blanc"])
  ]
  
  for (locale, expected_colors) in color_tests {
    ColorFormatter::set_locale(color_formatter, locale)
    
    for (i, color_name) in expected_colors.enumerate() {
      let format_result = ColorFormatter::format(color_formatter, color_name)
      assert_true(format_result.success)
      
      let formatted_color = format_result.formatted_color
      assert_true(formatted_color.length() > 0)
      
      if i < 3 { // æµ‹è¯•å‰3ä¸ªé¢œè‰²
        let color_info = format_result.color_info
        assert_true(color_info.name.length() > 0)
      }
    }
  }
  
  // æµ‹è¯•é¦–å­—æ¯æ’åºè§„åˆ™
  let collation_formatter = CollationFormatter::new()
  
  let collation_tests = [
    ("en-US", ["apple", "banana", "cherry", "date"], ["apple", "banana", "cherry", "date"]),
    ("zh-CN", ["è‹¹æœ", "é¦™è•‰", "æ¨±æ¡ƒ", "æ£"], ["æ£", "è‹¹æœ", "é¦™è•‰", "æ¨±æ¡ƒ"]),
    ("ja-JP", ["ã‚Šã‚“ã”", "ã°ãªãª", "ã•ãã‚‰ã‚“ã¼", "ãªã¤ã‚"], ["ã°ãªãª", "ã•ãã‚‰ã‚“ã¼", "ãªã¤ã‚", "ã‚Šã‚“ã”"])
  ]
  
  for (locale, input_words, expected_order) in collation_tests {
    CollationFormatter::set_locale(collation_formatter, locale)
    
    let sort_result = CollationFormatter::sort_words(collation_formatter, input_words)
    assert_true(sort_result.success)
    
    let sorted_words = sort_result.sorted_words
    assert_eq(sorted_words.length(), input_words.length())
    
    // éªŒè¯æ’åºç¬¦åˆåœ°åŒºä¹ æƒ¯
    for i in 0..=expected_order.length() - 1 {
      assert_eq(sorted_words[i], expected_order[i])
    }
  }
  
  // æµ‹è¯•å§“åç§°è°“
  let title_formatter = TitleFormatter::new()
  
  let title_tests = [
    ("en-US", "male", "Mr.", "female", "Ms.", "neutral", "Mx."),
    ("zh-CN", "male", "å…ˆç”Ÿ", "female", "å¥³å£«", "neutral", "å›"),
    ("ja-JP", "male", "æ§˜", "female", "æ§˜", "neutral", "æ§˜"),
    ("de-DE", "male", "Herr", "female", "Frau", "neutral", "Mx."),
    ("fr-FR", "male", "M.", "female", "Mme", "neutral", "M.")
  ]
  
  for (locale, gender, male_title, female_title, neutral_gender, neutral_title) in title_tests {
    TitleFormatter::set_locale(title_formatter, locale)
    
    let male_result = TitleFormatter::get_title(title_formatter, gender)
    assert_true(male_result.success)
    assert_eq(male_result.title, male_title)
    
    let female_result = TitleFormatter::get_title(title_formatter, "female")
    assert_true(female_result.success)
    assert_eq(female_result.title, female_title)
    
    let neutral_result = TitleFormatter::get_title(title_formatter, neutral_gender)
    assert_true(neutral_result.success)
    assert_eq(neutral_result.title, neutral_title)
  }
}

// æµ‹è¯•6: å­—ç¬¦ç¼–ç å’Œè½¬æ¢
test "å­—ç¬¦ç¼–ç å’Œè½¬æ¢æµ‹è¯•" {
  // åˆ›å»ºå­—ç¬¦ç¼–ç è½¬æ¢å™¨
  let encoding_converter = EncodingConverter::new()
  
  // æµ‹è¯•å¤šå­—èŠ‚å­—ç¬¦ç¼–ç 
  let unicode_texts = [
    "ä¸­æ–‡æµ‹è¯•æ–‡æœ¬",
    "æ—¥æœ¬èªãƒ†ã‚¹ãƒˆãƒ†ã‚­ã‚¹ãƒˆ",
    "í•œêµ­ì–´ í…ŒìŠ¤íŠ¸ í…ìŠ¤íŠ¸",
    "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Øµ",
    "×¢×‘×¨×™×ª ×˜×§×¡×˜ ×‘×“×™×§×”",
    "Ğ¢ĞµÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼",
    "Ğ¢ĞµĞºÑÑ‚ Ğ½Ğ° Ğ±ĞµĞ»Ğ°Ñ€ÑƒÑĞºĞ°Ğ¹ Ğ¼Ğ¾Ğ²Ğµ",
    "Î•Î»Î»Î·Î½Î¹ÎºÏŒ ÎºÎµÎ¯Î¼ÎµÎ½Î¿ Î´Î¿ÎºÎ¹Î¼Î®Ï‚",
    "Ğ¢ĞµĞºÑÑ‚ ĞºĞ¸Ñ€Ğ¸Ğ»Ğ¸Ñ†Ğµ"
  ]
  
  for text in unicode_texts {
    // è½¬æ¢ä¸ºUTF-8å­—èŠ‚
    let utf8_result = EncodingConverter::to_utf8(encoding_converter, text)
    assert_true(utf8_result.success)
    
    let utf8_bytes = utf8_result.bytes
    assert_true(utf8_bytes.length() > 0)
    
    // ä»UTF-8å­—èŠ‚è½¬æ¢å›æ–‡æœ¬
    let from_utf8_result = EncodingConverter::from_utf8(encoding_converter, utf8_bytes)
    assert_true(from_utf8_result.success)
    assert_eq(from_utf8_result.text, text)
    
    // è½¬æ¢ä¸ºUTF-16
    let utf16_result = EncodingConverter::to_utf16(encoding_converter, text)
    assert_true(utf16_result.success)
    
    let utf16_bytes = utf16_result.bytes
    assert_true(utf16_bytes.length() > 0)
    
    // ä»UTF-16å­—èŠ‚è½¬æ¢å›æ–‡æœ¬
    let from_utf16_result = EncodingConverter::from_utf16(encoding_converter, utf16_bytes)
    assert_true(from_utf16_result.success)
    assert_eq(from_utf16_result.text, text)
  }
  
  // æµ‹è¯•å­—ç¬¦é›†æ£€æµ‹
  let mixed_encoding_data = "Hello ä¸–ç•Œ ã“ã‚“ã«ã¡ã¯ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚".to_bytes()
  let detect_result = EncodingConverter::detect_encoding(encoding_converter, mixed_encoding_data)
  assert_true(detect_result.success)
  
  let detected_encoding = detect_result.encoding
  assert_true(detected_encoding == "UTF-8" || detected_encoding == "UTF-16")
  
  // æµ‹è¯•å­—ç¬¦è§„èŒƒåŒ–
  let normalizer = UnicodeNormalizer::new()
  
  let test_strings = [
    ("cafÃ©", "cafÃ©"), // å¸¦é‡éŸ³ç¬¦å’Œä¸å¸¦é‡éŸ³ç¬¦çš„ç»„åˆ
    ("ä½ å¥½", "ä½ å¥½"),       // ä¸­æ–‡ï¼ˆæ— å˜åŒ–ï¼‰
    ("ğŸ‘", "ğŸ‘"),          // Emojiï¼ˆæ— å˜åŒ–ï¼‰
    ("Ã©", "Ã©")        // ç»„åˆå­—ç¬¦å’Œé¢„ç»„åˆå­—ç¬¦
  ]
  
  for (composed, decomposed) in test_strings {
    // NFCè§„èŒƒåŒ–ï¼ˆè§„èŒƒå½¢å¼Cï¼‰
    let nfc_result = UnicodeNormalizer::normalize(normalizer, composed, NormalizationForm::NFC)
    assert_true(nfc_result.success)
    
    // NFDè§„èŒƒåŒ–ï¼ˆè§„èŒƒå½¢å¼Dï¼‰
    let nfd_result = UnicodeNormalizer::normalize(normalizer, decomposed, NormalizationForm::NFD)
    assert_true(nfd_result.success)
    
    // éªŒè¯è§„èŒƒåŒ–ç»“æœ
    let nfc_normalized = nfc_result.normalized_text
    let nfd_normalized = nfd_result.normalized_text
    
    // NFCåº”è¯¥äº§ç”Ÿé¢„ç»„åˆå­—ç¬¦ï¼ŒNFDåº”è¯¥äº§ç”Ÿåˆ†è§£å­—ç¬¦
    if composed.contains("Ã©") {
      assert_true(nfc_normalized.contains("Ã©"))
    }
    
    if decomposed.contains("Ã©") {
      assert_true(nfd_normalized.contains("Ã©"))
    }
  }
  
  // æµ‹è¯•å­—ç¬¦è½¬ä¹‰
  let escape_handler = UnicodeEscapeHandler::new()
  
  let escape_tests = [
    ("Hello\nWorld", "Hello\\nWorld"),
    ("Tab\tCharacter", "Tab\\tCharacter"),
    ("Quote\"Character", "Quote\\\"Character"),
    ("Backslash\\Character", "Backslash\\\\Character"),
    ("Unicodeä¸­æ–‡", "Unicode\\u4E2D\\u6587")
  ]
  
  for (original, expected_escaped) in escape_tests {
    let escape_result = UnicodeEscapeHandler::escape(escape_handler, original)
    assert_true(escape_result.success)
    assert_eq(escape_result.escaped_text, expected_escaped)
    
    // åå‘è½¬ä¹‰
    let unescape_result = UnicodeEscapeHandler::unescape(escape_handler, expected_escaped)
    assert_true(unescape_result.success)
    assert_eq(unescape_result.unescaped_text, original)
  }
  
  // æµ‹è¯•å­—ç¬¦å¤§å°å†™è½¬æ¢
  let case_converter = CaseConverter::new()
  
  let case_tests = [
    ("en-US", "hello world", "HELLO WORLD", "Hello World"),
    ("zh-CN", "hello world", "HELLO WORLD", "Hello World"), // ä¸­æ–‡æ— å¤§å°å†™
    ("tr-TR", "istanbul", "Ä°STANBUL", "Ä°stanbul"), // åœŸè€³å…¶è¯­ç‰¹æ®Šå¤§å°å†™
    ("el-GR", "Î¬Î»Ï†Î±", "Î†Î›Î¦Î‘", "Î†Î»Ï†Î±") // å¸Œè…Šè¯­
  ]
  
  for (locale, lower, upper, title) in case_tests {
    CaseConverter::set_locale(case_converter, locale)
    
    let lower_result = CaseConverter::to_upper(case_converter, lower)
    assert_true(lower_result.success)
    
    let upper_result = CaseConverter::to_lower(case_converter, upper)
    assert_true(upper_result.success)
    
    let title_result = CaseConverter::to_title(case_converter, title)
    assert_true(title_result.success)
  }
  
  // æµ‹è¯•å­—ç¬¦å®½åº¦ï¼ˆå…¨è§’å’ŒåŠè§’ï¼‰
  let width_handler = CharacterWidthHandler::new()
  
  let width_tests = [
    ("ABC123", "ï¼¡ï¼¢ï¼£ï¼‘ï¼’ï¼“"), // åŠè§’è½¬å…¨è§’
    ("ï¼¡ï¼¢ï¼£ï¼‘ï¼’ï¼“", "ABC123"), // å…¨è§’è½¬åŠè§’
    ("hello", "ï½ˆï½…ï½Œï½Œï½"),   // åŠè§’è½¬å…¨è§’
    ("ï½ˆï½…ï½Œï½Œï½", "hello")    // å…¨è§’è½¬åŠè§’
  ]
  
  for (half_width, full_width) in width_tests {
    let to_full_result = CharacterWidthHandler::to_full_width(width_handler, half_width)
    assert_true(to_full_result.success)
    assert_eq(to_full_result.converted_text, full_width)
    
    let to_half_result = CharacterWidthHandler::to_half_width(width_handler, full_width)
    assert_true(to_half_result.success)
    assert_eq(to_half_result.converted_text, half_width)
  }
  
  // æµ‹è¯•å­—ç¬¦æ˜¾ç¤ºå®½åº¦è®¡ç®—
  let display_width_tests = [
    ("ABC", 3),          // ASCIIå­—ç¬¦ï¼Œå®½åº¦1
    ("ä¸­æ–‡", 4),          // ä¸­æ–‡å­—ç¬¦ï¼Œå®½åº¦2
    ("ğŸ‘", 2),            // Emojiï¼Œå®½åº¦2
    ("Aä¸­æ–‡BğŸ‘C", 10)     // æ··åˆå­—ç¬¦
  ]
  
  for (text, expected_width) in display_width_tests {
    let width_result = CharacterWidthHandler::get_display_width(width_handler, text)
    assert_true(width_result.success)
    assert_eq(width_result.width, expected_width)
  }
  
  // æµ‹è¯•å­—ç¬¦è¿‡æ»¤
  let character_filter = CharacterFilter::new()
  
  let filter_tests = [
    ("letters", "Hello123World", "HelloWorld"),
    ("digits", "Hello123World", "123"),
    ("alphanumeric", "Hello-123-World!", "Hello123World"),
    ("cjk", "Helloä¸­æ–‡World", "ä¸­æ–‡"),
    ("arabic", "HelloÙ…Ø±Ø­Ø¨Ø§World", "Ù…Ø±Ø­Ø¨Ø§")
  ]
  
  for (filter_type, input, expected_output) in filter_tests {
    let filter_result = CharacterFilter::filter(character_filter, input, filter_type)
    assert_true(filter_result.success)
    assert_eq(filter_result.filtered_text, expected_output)
  }
  
  // æµ‹è¯•å­—ç¬¦æ›¿æ¢
  let character_replacer = CharacterReplacer::new()
  
  let replacement_rules = [
    ("old", "new"),
    ("123", "456"),
    ("ä¸­æ–‡", "Chinese"),
    ("ãƒ†ã‚¹ãƒˆ", "test")
  ]
  
  let input_text = "old 123 ä¸­æ–‡ ãƒ†ã‚¹ãƒˆ"
  let expected_output = "new 456 Chinese test"
  
  for (old_text, new_text) in replacement_rules {
    CharacterReplacer::add_rule(character_replacer, old_text, new_text)
  }
  
  let replace_result = CharacterReplacer::replace(character_replacer, input_text)
  assert_true(replace_result.success)
  assert_eq(replace_result.replaced_text, expected_output)
  
  // æµ‹è¯•å­—ç¬¦ç»Ÿè®¡
  let character_stats = CharacterStats::new()
  
  let stats_input = "Helloä½ å¥½Worldä¸–ç•Œ123!@#"
  let stats_result = CharacterStats::analyze(character_stats, stats_input)
  assert_true(stats_result.success)
  
  let stats = stats_result.statistics
  assert_true(stats.total_characters > 0)
  assert_true(stats.ascii_characters > 0)
  assert_true(stats.cjk_characters > 0)
  assert_true(stats.digits > 0)
  assert_true(stats.symbols > 0)
}