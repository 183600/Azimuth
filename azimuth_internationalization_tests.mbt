// Azimuth Telemetry System - Internationalization Support Tests
// This file contains comprehensive internationalization support test cases

// Test 1: Multi-language Attribute Values
test "multi-language attribute values" {
  let provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(provider, "i18n_test_tracer")
  let span = Tracer::start_span(tracer, "i18n_test_span")
  
  // Set attributes with different language values
  Span::set_attribute(span, "error.message.zh", StringValue("æ“ä½œå¤±è´¥"))
  Span::set_attribute(span, "error.message.en", StringValue("Operation failed"))
  Span::set_attribute(span, "error.message.ja", StringValue("æ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ"))
  Span::set_attribute(span, "error.message.fr", StringValue("L'opÃ©ration a Ã©chouÃ©"))
  Span::set_attribute(span, "error.message.de", StringValue("Operation fehlgeschlagen"))
  Span::set_attribute(span, "error.message.es", StringValue("La operaciÃ³n fallÃ³"))
  Span::set_attribute(span, "error.message.ru", StringValue("ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ°ÑÑŒ"))
  Span::set_attribute(span, "error.message.ar", StringValue("ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©"))
  
  // Verify attributes are set correctly
  let zh_message = Span::get_attribute(span, "error.message.zh")
  match zh_message {
    Some(StringValue(v)) => assert_eq(v, "æ“ä½œå¤±è´¥")
    _ => assert_true(false)
  }
  
  let en_message = Span::get_attribute(span, "error.message.en")
  match en_message {
    Some(StringValue(v)) => assert_eq(v, "Operation failed")
    _ => assert_true(false)
  }
  
  let ja_message = Span::get_attribute(span, "error.message.ja")
  match ja_message {
    Some(StringValue(v)) => assert_eq(v, "æ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ")
    _ => assert_true(false)
  }
  
  // Test language-specific attribute retrieval
  let localized_message = I18n::get_localized_attribute(span, "error.message", "zh")
  match localized_message {
    Some(StringValue(v)) => assert_eq(v, "æ“ä½œå¤±è´¥")
    _ => assert_true(false)
  }
  
  let localized_message_en = I18n::get_localized_attribute(span, "error.message", "en")
  match localized_message_en {
    Some(StringValue(v)) => assert_eq(v, "Operation failed")
    _ => assert_true(false)
  }
  
  // Test fallback to default language when requested language is not available
  let fallback_message = I18n::get_localized_attribute_with_fallback(span, "error.message", "ko", "en")
  match fallback_message {
    Some(StringValue(v)) => assert_eq(v, "Operation failed")
    _ => assert_true(false)
  }
  
  Span::end(span)
  TracerProvider::shutdown(provider)
}

// Test 2: Locale-Aware Formatting
test "locale-aware formatting" {
  // Test number formatting with different locales
  let number = 1234567.89
  
  let formatted_en = I18n::format_number(number, "en-US")
  assert_eq(formatted_en, "1,234,567.89")
  
  let formatted_de = I18n::format_number(number, "de-DE")
  assert_eq(formatted_de, "1.234.567,89")
  
  let formatted_fr = I18n::format_number(number, "fr-FR")
  assert_eq(formatted_fr, "1 234 567,89")
  
  let formatted_zh = I18n::format_number(number, "zh-CN")
  assert_eq(formatted_zh, "1,234,567.89")
  
  let formatted_ja = I18n::format_number(number, "ja-JP")
  assert_eq(formatted_ja, "1,234,567.89")
  
  let formatted_ar = I18n::format_number(number, "ar-SA")
  assert_eq(formatted_ar, "1,234,567.89")
  
  // Test date formatting with different locales
  let timestamp = 1672574400000L // 2023-01-01 12:00:00 UTC
  
  let date_en = I18n::format_date(timestamp, "en-US", "YYYY-MM-DD HH:mm:ss")
  assert_eq(date_en, "2023-01-01 12:00:00")
  
  let date_de = I18n::format_date(timestamp, "de-DE", "DD.MM.YYYY HH:mm:ss")
  assert_eq(date_de, "01.01.2023 12:00:00")
  
  let date_fr = I18n::format_date(timestamp, "fr-FR", "DD/MM/YYYY HH:mm:ss")
  assert_eq(date_fr, "01/01/2023 12:00:00")
  
  let date_zh = I18n::format_date(timestamp, "zh-CN", "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss")
  assert_eq(date_zh, "2023å¹´01æœˆ01æ—¥ 12:00:00")
  
  let date_ja = I18n::format_date(timestamp, "ja-JP", "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss")
  assert_eq(date_ja, "2023å¹´01æœˆ01æ—¥ 12:00:00")
  
  // Test currency formatting with different locales
  let amount = 1234.56
  
  let currency_en = I18n::format_currency(amount, "en-US", "USD")
  assert_eq(currency_en, "$1,234.56")
  
  let currency_de = I18n::format_currency(amount, "de-DE", "EUR")
  assert_eq(currency_de, "1.234,56 â‚¬")
  
  let currency_fr = I18n::format_currency(amount, "fr-FR", "EUR")
  assert_eq(currency_fr, "1 234,56 â‚¬")
  
  let currency_ja = I18n::format_currency(amount, "ja-JP", "JPY")
  assert_eq(currency_ja, "ï¿¥1,235")
  
  let currency_zh = I18n::format_currency(amount, "zh-CN", "CNY")
  assert_eq(currency_zh, "Â¥1,234.56")
}

// Test 3: Right-to-Left Language Support
test "right-to-left language support" {
  let provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(provider, "rtl_test_tracer")
  let span = Tracer::start_span(tracer, "rtl_test_span")
  
  // Set Arabic attributes
  Span::set_attribute(span, "user.name.ar", StringValue("Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"))
  Span::set_attribute(span, "error.message.ar", StringValue("ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©"))
  Span::set_attribute(span, "operation.description.ar", StringValue("Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"))
  
  // Set Hebrew attributes
  Span::set_attribute(span, "user.name.he", StringValue("×“×•×“ ×›×”×Ÿ"))
  Span::set_attribute(span, "error.message.he", StringValue("×”×¤×¢×•×œ×” × ×›×©×œ×”"))
  Span::set_attribute(span, "operation.description.he", StringValue("×§×¨×™××ª × ×ª×•× ×™× ×××¡×“ ×”× ×ª×•× ×™×"))
  
  // Verify Arabic attributes
  let arabic_name = Span::get_attribute(span, "user.name.ar")
  match arabic_name {
    Some(StringValue(v)) => assert_eq(v, "Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯")
    _ => assert_true(false)
  }
  
  let arabic_error = Span::get_attribute(span, "error.message.ar")
  match arabic_error {
    Some(StringValue(v)) => assert_eq(v, "ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©")
    _ => assert_true(false)
  }
  
  // Verify Hebrew attributes
  let hebrew_name = Span::get_attribute(span, "user.name.he")
  match hebrew_name {
    Some(StringValue(v)) => assert_eq(v, "×“×•×“ ×›×”×Ÿ")
    _ => assert_true(false)
  }
  
  let hebrew_error = Span::get_attribute(span, "error.message.he")
  match hebrew_error {
    Some(StringValue(v)) => assert_eq(v, "×”×¤×¢×•×œ×” × ×›×©×œ×”")
    _ => assert_true(false)
  }
  
  // Test text direction detection
  assert_true(I18n::is_right_to_left("Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯"))
  assert_true(I18n::is_right_to_left("×”×¤×¢×•×œ×” × ×›×©×œ×”"))
  assert_false(I18n::is_right_to_left("Operation failed"))
  assert_false(I18n::is_right_to_left("æ“ä½œå¤±è´¥"))
  
  Span::end(span)
  TracerProvider::shutdown(provider)
}

// Test 4: Multi-language Log Messages
test "multi-language log messages" {
  let provider = LoggerProvider::new()
  let logger = LoggerProvider::get_logger(provider, "i18n_test_logger")
  
  // Create log records in different languages
  let log_zh = LogRecord::new(Info, "ç”¨æˆ·ç™»å½•æˆåŠŸ")
  LogRecord::add_attribute(log_zh, "language", StringValue("zh"))
  LogRecord::add_attribute(log_zh, "user.id", StringValue("user123"))
  LogRecord::add_attribute(log_zh, "login.time", StringValue("2023-01-01 12:00:00"))
  
  let log_en = LogRecord::new(Info, "User login successful")
  LogRecord::add_attribute(log_en, "language", StringValue("en"))
  LogRecord::add_attribute(log_en, "user.id", StringValue("user456"))
  LogRecord::add_attribute(log_en, "login.time", StringValue("2023-01-01 12:05:00"))
  
  let log_ja = LogRecord::new(Info, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
  LogRecord::add_attribute(log_ja, "language", StringValue("ja"))
  LogRecord::add_attribute(log_ja, "user.id", StringValue("user789"))
  LogRecord::add_attribute(log_ja, "login.time", StringValue("2023-01-01 12:10:00"))
  
  // Emit log records
  Logger::emit(logger, log_zh)
  Logger::emit(logger, log_en)
  Logger::emit(logger, log_ja)
  
  // Verify log records
  assert_eq(LogRecord::severity_number(log_zh), Info)
  match LogRecord::body(log_zh) {
    Some(body) => assert_eq(body, "ç”¨æˆ·ç™»å½•æˆåŠŸ")
    None => assert_true(false)
  }
  
  assert_eq(LogRecord::severity_number(log_en), Info)
  match LogRecord::body(log_en) {
    Some(body) => assert_eq(body, "User login successful")
    None => assert_true(false)
  }
  
  assert_eq(LogRecord::severity_number(log_ja), Info)
  match LogRecord::body(log_ja) {
    Some(body) => assert_eq(body, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
    None => assert_true(false)
  }
  
  // Test language-based log filtering
  let zh_logs = I18n::filter_logs_by_language([log_zh, log_en, log_ja], "zh")
  assert_eq(zh_logs.length(), 1)
  match LogRecord::body(zh_logs[0]) {
    Some(body) => assert_eq(body, "ç”¨æˆ·ç™»å½•æˆåŠŸ")
    None => assert_true(false)
  }
  
  let en_logs = I18n::filter_logs_by_language([log_zh, log_en, log_ja], "en")
  assert_eq(en_logs.length(), 1)
  match LogRecord::body(en_logs[0]) {
    Some(body) => assert_eq(body, "User login successful")
    None => assert_true(false)
  }
  
  LoggerProvider::shutdown(provider)
}

// Test 5: Localized Error Messages
test "localized error messages" {
  let provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(provider, "error_i18n_tracer")
  
  // Create error codes with localized messages
  let error_codes = [
    ("E001", [
      ("en", "Invalid user credentials"),
      ("zh", "ç”¨æˆ·å‡­æ®æ— æ•ˆ"),
      ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼æƒ…å ±ãŒç„¡åŠ¹ã§ã™"),
      ("fr", "Identifiants utilisateur invalides"),
      ("de", "UngÃ¼ltige Benutzeranmeldedaten"),
      ("es", "Credenciales de usuario invÃ¡lidas"),
      ("ru", "ĞĞµĞ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑƒÑ‡ĞµÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"),
      ("ar", "Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø¹ØªÙ…Ø§Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± ØµØ§Ù„Ø­Ø©")
    ]),
    ("E002", [
      ("en", "Database connection failed"),
      ("zh", "æ•°æ®åº“è¿æ¥å¤±è´¥"),
      ("ja", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ"),
      ("fr", "Ã‰chec de la connexion Ã  la base de donnÃ©es"),
      ("de", "Datenbankverbindung fehlgeschlagen"),
      ("es", "Error en la conexiÃ³n a la base de datos"),
      ("ru", "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"),
      ("ar", "ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
    ]),
    ("E003", [
      ("en", "Resource not found"),
      ("zh", "æœªæ‰¾åˆ°èµ„æº"),
      ("ja", "ãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"),
      ("fr", "Ressource introuvable"),
      ("de", "Ressource nicht gefunden"),
      ("es", "Recurso no encontrado"),
      ("ru", "Ğ ĞµÑÑƒÑ€Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½"),
      ("ar", "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ±Ø¯")
    ])
  ]
  
  // Test error message localization
  for (code, messages) in error_codes {
    for (locale, expected_message) in messages {
      let localized_message = I18n::get_error_message(code, locale)
      match localized_message {
        Some(message) => assert_eq(message, expected_message)
        None => assert_true(false)
      }
    }
  }
  
  // Test fallback to default language when locale is not supported
  let fallback_message = I18n::get_error_message_with_fallback("E001", "ko", "en")
  match fallback_message {
    Some(message) => assert_eq(message, "Invalid user credentials")
    None => assert_true(false)
  }
  
  // Create spans with localized error messages
  let span1 = Tracer::start_span(tracer, "operation_with_error")
  let localized_error1 = I18n::get_error_message("E001", "zh")
  match localized_error1 {
    Some(message) => {
      Span::set_status(span1, Error, Some(message))
      Span::add_event(span1, "error_occurred", Some([
        ("error.code", StringValue("E001")),
        ("error.message.zh", StringValue(message))
      ]))
    }
    None => assert_true(false)
  }
  
  let span2 = Tracer::start_span(tracer, "operation_with_error2")
  let localized_error2 = I18n::get_error_message("E002", "ja")
  match localized_error2 {
    Some(message) => {
      Span::set_status(span2, Error, Some(message))
      Span::add_event(span2, "error_occurred", Some([
        ("error.code", StringValue("E002")),
        ("error.message.ja", StringValue(message))
      ]))
    }
    None => assert_true(false)
  }
  
  Span::end(span2)
  Span::end(span1)
  TracerProvider::shutdown(provider)
}

// Test 6: Time Zone Support
test "time zone support" {
  let timestamp = 1672574400000L // 2023-01-01 12:00:00 UTC
  
  // Test time zone conversion
  let utc_time = I18n::convert_timezone(timestamp, "UTC", "UTC")
  assert_eq(utc_time, "2023-01-01 12:00:00 UTC")
  
  let est_time = I18n::convert_timezone(timestamp, "UTC", "America/New_York")
  assert_eq(est_time, "2023-01-01 07:00:00 EST")
  
  let pst_time = I18n::convert_timezone(timestamp, "UTC", "America/Los_Angeles")
  assert_eq(pst_time, "2023-01-01 04:00:00 PST")
  
  let cet_time = I18n::convert_timezone(timestamp, "UTC", "Europe/Paris")
  assert_eq(cet_time, "2023-01-01 13:00:00 CET")
  
  let jst_time = I18n::convert_timezone(timestamp, "UTC", "Asia/Tokyo")
  assert_eq(jst_time, "2023-01-01 21:00:00 JST")
  
  let cst_time = I18n::convert_timezone(timestamp, "UTC", "Asia/Shanghai")
  assert_eq(cst_time, "2023-01-01 20:00:00 CST")
  
  // Test time zone-aware date formatting
  let formatted_date_utc = I18n::format_date_with_timezone(timestamp, "en-US", "UTC", "YYYY-MM-DD HH:mm:ss z")
  assert_eq(formatted_date_utc, "2023-01-01 12:00:00 UTC")
  
  let formatted_date_est = I18n::format_date_with_timezone(timestamp, "en-US", "America/New_York", "YYYY-MM-DD HH:mm:ss z")
  assert_eq(formatted_date_est, "2023-01-01 07:00:00 EST")
  
  let formatted_date_jst = I18n::format_date_with_timezone(timestamp, "ja-JP", "Asia/Tokyo", "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss z")
  assert_eq(formatted_date_jst, "2023å¹´01æœˆ01æ—¥ 21:00:00 JST")
  
  // Test time zone validation
  assert_true(I18n::is_valid_timezone("UTC"))
  assert_true(I18n::is_valid_timezone("America/New_York"))
  assert_true(I18n::is_valid_timezone("Europe/Paris"))
  assert_true(I18n::is_valid_timezone("Asia/Tokyo"))
  assert_false(I18n::is_valid_timezone("Invalid/Timezone"))
  assert_false(I18n::is_valid_timezone(""))
}

// Test 7: Cultural Formatting Conventions
test "cultural formatting conventions" {
  // Test name formatting for different cultures
  let western_name = I18n::format_name("John", "Doe", "en-US")
  assert_eq(western_name, "John Doe")
  
  let eastern_name = I18n::format_name("å¼ ", "ä¸‰", "zh-CN")
  assert_eq(eastern_name, "å¼ ä¸‰")
  
  let japanese_name = I18n::format_name("ç”°ä¸­", "å¤ªéƒ", "ja-JP")
  assert_eq(japanese_name, "ç”°ä¸­å¤ªéƒ")
  
  let korean_name = I18n::format_name("ê¹€", "ì² ìˆ˜", "ko-KR")
  assert_eq(korean_name, "ê¹€ì² ìˆ˜")
  
  // Test address formatting for different cultures
  let us_address = I18n::format_address("123 Main St", "New York", "NY", "10001", "en-US")
  assert_eq(us_address, "123 Main St\nNew York, NY 10001")
  
  let jp_address = I18n::format_address("ã€’100-0001", "æ±äº¬éƒ½åƒä»£ç”°åŒºåƒä»£ç”°", "1", "1", "ja-JP")
  assert_eq(jp_address, "ã€’100-0001\næ±äº¬éƒ½åƒä»£ç”°åŒºåƒä»£ç”°1-1")
  
  let cn_address = I18n::format_address("100000", "åŒ—äº¬å¸‚", "ä¸œåŸåŒº", "é•¿å®‰è¡—1å·", "zh-CN")
  assert_eq(cn_address, "ä¸­å›½åŒ—äº¬å¸‚ä¸œåŸåŒº\né•¿å®‰è¡—1å·\n100000")
  
  // Test phone number formatting for different regions
  let us_phone = I18n::format_phone_number("+12125551234", "en-US")
  assert_eq(us_phone, "+1 (212) 555-1234")
  
  let jp_phone = I18n::format_phone_number("+81312345678", "ja-JP")
  assert_eq(jp_phone, "+81-3-1234-5678")
  
  let cn_phone = I18n::format_phone_number("+8613812345678", "zh-CN")
  assert_eq(cn_phone, "+86 138 1234 5678")
  
  let de_phone = I18n::format_phone_number("+493012345678", "de-DE")
  assert_eq(de_phone, "+49 30 12345678")
}

// Test 8: Multi-language Resource Descriptions
test "multi-language resource descriptions" {
  // Create resource with multi-language descriptions
  let resource_attrs = [
    ("service.name", StringValue("payment-service")),
    ("service.description.en", StringValue("Payment processing service")),
    ("service.description.zh", StringValue("æ”¯ä»˜å¤„ç†æœåŠ¡")),
    ("service.description.ja", StringValue("æ”¯æ‰•ã„å‡¦ç†ã‚µãƒ¼ãƒ“ã‚¹")),
    ("service.description.fr", StringValue("Service de traitement des paiements")),
    ("service.description.de", StringValue("Zahlungsverarbeitungsdienst")),
    ("service.description.es", StringValue("Servicio de procesamiento de pagos")),
    ("service.description.ru", StringValue("Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶ĞµĞ¹")),
    ("service.description.ar", StringValue("Ø®Ø¯Ù…Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¯ÙØ¹Ø§Øª")),
    
    ("service.owner.name.en", StringValue("Payment Team")),
    ("service.owner.name.zh", StringValue("æ”¯ä»˜å›¢é˜Ÿ")),
    ("service.owner.name.ja", StringValue("æ”¯æ‰•ã„ãƒãƒ¼ãƒ ")),
    ("service.owner.email", StringValue("payment@example.com")),
    
    ("service.version", StringValue("1.2.3")),
    ("service.environment", StringValue("production"))
  ]
  
  let resource = Resource::with_attributes(Resource::new(), resource_attrs)
  
  // Test retrieving localized descriptions
  let en_description = I18n::get_localized_resource_attribute(resource, "service.description", "en")
  match en_description {
    Some(StringValue(v)) => assert_eq(v, "Payment processing service")
    _ => assert_true(false)
  }
  
  let zh_description = I18n::get_localized_resource_attribute(resource, "service.description", "zh")
  match zh_description {
    Some(StringValue(v)) => assert_eq(v, "æ”¯ä»˜å¤„ç†æœåŠ¡")
    _ => assert_true(false)
  }
  
  let ja_description = I18n::get_localized_resource_attribute(resource, "service.description", "ja")
  match ja_description {
    Some(StringValue(v)) => assert_eq(v, "æ”¯æ‰•ã„å‡¦ç†ã‚µãƒ¼ãƒ“ã‚¹")
    _ => assert_true(false)
  }
  
  // Test retrieving localized owner information
  let en_owner = I18n::get_localized_resource_attribute(resource, "service.owner.name", "en")
  match en_owner {
    Some(StringValue(v)) => assert_eq(v, "Payment Team")
    _ => assert_true(false)
  }
  
  let zh_owner = I18n::get_localized_resource_attribute(resource, "service.owner.name", "zh")
  match zh_owner {
    Some(StringValue(v)) => assert_eq(v, "æ”¯ä»˜å›¢é˜Ÿ")
    _ => assert_true(false)
  }
  
  // Test fallback to non-localized attribute
  let version = Resource::get_attribute(resource, "service.version")
  match version {
    Some(StringValue(v)) => assert_eq(v, "1.2.3")
    _ => assert_true(false)
  }
  
  // Test resource description serialization with localization
  let en_resource_json = I18n::serialize_resource_with_localization(resource, "en")
  assert_true(en_resource_json.contains("Payment processing service"))
  assert_true(en_resource_json.contains("Payment Team"))
  
  let zh_resource_json = I18n::serialize_resource_with_localization(resource, "zh")
  assert_true(zh_resource_json.contains("æ”¯ä»˜å¤„ç†æœåŠ¡"))
  assert_true(zh_resource_json.contains("æ”¯ä»˜å›¢é˜Ÿ"))
}

// Test 9: Locale-Aware Metric Names and Descriptions
test "locale-aware metric names and descriptions" {
  let provider = MeterProvider::new()
  let meter = MeterProvider::get_meter(provider, "i18n_test_meter")
  
  // Create metrics with localized names and descriptions
  let counter = Meter::create_counter(meter, "user_login_count", None, None)
  I18n::set_metric_localization(counter, "name", [
    ("en", "User Login Count"),
    ("zh", "ç”¨æˆ·ç™»å½•æ¬¡æ•°"),
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æ•°"),
    ("fr", "Nombre de connexions utilisateur"),
    ("de", "Benutzeranmeldezahl"),
    ("es", "Recuento de inicios de sesiÃ³n de usuario"),
    ("ru", "ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ñ…Ğ¾Ğ´Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"),
    ("ar", "Ø¹Ø¯Ø¯ Ø¹Ù…Ù„ÙŠØ§Øª ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
  ])
  
  I18n::set_metric_localization(counter, "description", [
    ("en", "Total number of user logins"),
    ("zh", "ç”¨æˆ·ç™»å½•æ€»æ•°"),
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³ã®ç·æ•°"),
    ("fr", "Nombre total de connexions utilisateur"),
    ("de", "Gesamtzahl der Benutzeranmeldungen"),
    ("es", "NÃºmero total de inicios de sesiÃ³n de usuario"),
    ("ru", "ĞĞ±Ñ‰ĞµĞµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²Ñ…Ğ¾Ğ´Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"),
    ("ar", "Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø¹Ù…Ù„ÙŠØ§Øª ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
  ])
  
  // Test retrieving localized metric names
  let en_name = I18n::get_localized_metric_name(counter, "en")
  match en_name {
    Some(name) => assert_eq(name, "User Login Count")
    None => assert_true(false)
  }
  
  let zh_name = I18n::get_localized_metric_name(counter, "zh")
  match zh_name {
    Some(name) => assert_eq(name, "ç”¨æˆ·ç™»å½•æ¬¡æ•°")
    None => assert_true(false)
  }
  
  let ja_name = I18n::get_localized_metric_name(counter, "ja")
  match ja_name {
    Some(name) => assert_eq(name, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æ•°")
    None => assert_true(false)
  }
  
  // Test retrieving localized metric descriptions
  let en_description = I18n::get_localized_metric_description(counter, "en")
  match en_description {
    Some(desc) => assert_eq(desc, "Total number of user logins")
    None => assert_true(false)
  }
  
  let zh_description = I18n::get_localized_metric_description(counter, "zh")
  match zh_description {
    Some(desc) => assert_eq(desc, "ç”¨æˆ·ç™»å½•æ€»æ•°")
    None => assert_true(false)
  }
  
  let ja_description = I18n::get_localized_metric_description(counter, "ja")
  match ja_description {
    Some(desc) => assert_eq(desc, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³ã®ç·æ•°")
    None => assert_true(false)
  }
  
  // Test metric serialization with localization
  let en_metric_json = I18n::serialize_metric_with_localization(counter, "en")
  assert_true(en_metric_json.contains("User Login Count"))
  assert_true(en_metric_json.contains("Total number of user logins"))
  
  let zh_metric_json = I18n::serialize_metric_with_localization(counter, "zh")
  assert_true(zh_metric_json.contains("ç”¨æˆ·ç™»å½•æ¬¡æ•°"))
  assert_true(zh_metric_json.contains("ç”¨æˆ·ç™»å½•æ€»æ•°"))
  
  MeterProvider::shutdown(provider)
}

// Test 10: Unicode and Special Character Handling
test "unicode and special character handling" {
  let provider = TracerProvider::new()
  let tracer = TracerProvider::get_tracer(provider, "unicode_test_tracer")
  let span = Tracer::start_span(tracer, "unicode_test_span")
  
  // Test Unicode characters in attributes
  Span::set_attribute(span, "emoji.test", StringValue("ğŸš€ğŸ”¥ğŸ’¯"))
  Span::set_attribute(span, "chinese.test", StringValue("ä¸­æ–‡æµ‹è¯•"))
  Span::set_attribute(span, "japanese.test", StringValue("æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ"))
  Span::set_attribute(span, "korean.test", StringValue("í•œêµ­ì–´ í…ŒìŠ¤íŠ¸"))
  Span::set_attribute(span, "arabic.test", StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ"))
  Span::set_attribute(span, "hebrew.test", StringValue("×‘×“×™×§×” ×¢×‘×¨×™×ª"))
  Span::set_attribute(span, "russian.test", StringValue("Ğ ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµÑÑ‚"))
  Span::set_attribute(span, "thai.test", StringValue("à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢"))
  Span::set_attribute(span, "math.symbols", StringValue("âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚"))
  Span::set_attribute(span, "currency.symbols", StringValue("$â‚¬Â£Â¥â‚¹â‚½â‚©"))
  
  // Verify Unicode attributes
  let emoji_attr = Span::get_attribute(span, "emoji.test")
  match emoji_attr {
    Some(StringValue(v)) => assert_eq(v, "ğŸš€ğŸ”¥ğŸ’¯")
    _ => assert_true(false)
  }
  
  let chinese_attr = Span::get_attribute(span, "chinese.test")
  match chinese_attr {
    Some(StringValue(v)) => assert_eq(v, "ä¸­æ–‡æµ‹è¯•")
    _ => assert_true(false)
  }
  
  let japanese_attr = Span::get_attribute(span, "japanese.test")
  match japanese_attr {
    Some(StringValue(v)) => assert_eq(v, "æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ")
    _ => assert_true(false)
  }
  
  let korean_attr = Span::get_attribute(span, "korean.test")
  match korean_attr {
    Some(StringValue(v)) => assert_eq(v, "í•œêµ­ì–´ í…ŒìŠ¤íŠ¸")
    _ => assert_true(false)
  }
  
  let arabic_attr = Span::get_attribute(span, "arabic.test")
  match arabic_attr {
    Some(StringValue(v)) => assert_eq(v, "Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ")
    _ => assert_true(false)
  }
  
  let hebrew_attr = Span::get_attribute(span, "hebrew.test")
  match hebrew_attr {
    Some(StringValue(v)) => assert_eq(v, "×‘×“×™×§×” ×¢×‘×¨×™×ª")
    _ => assert_true(false)
  }
  
  let russian_attr = Span::get_attribute(span, "russian.test")
  match russian_attr {
    Some(StringValue(v)) => assert_eq(v, "Ğ ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµÑÑ‚")
    _ => assert_true(false)
  }
  
  let thai_attr = Span::get_attribute(span, "thai.test")
  match thai_attr {
    Some(StringValue(v)) => assert_eq(v, "à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢")
    _ => assert_true(false)
  }
  
  let math_attr = Span::get_attribute(span, "math.symbols")
  match math_attr {
    Some(StringValue(v)) => assert_eq(v, "âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚")
    _ => assert_true(false)
  }
  
  let currency_attr = Span::get_attribute(span, "currency.symbols")
  match currency_attr {
    Some(StringValue(v)) => assert_eq(v, "$â‚¬Â£Â¥â‚¹â‚½â‚©")
    _ => assert_true(false)
  }
  
  // Test Unicode string operations
  let unicode_string = "Hello ä¸–ç•Œ ğŸŒ"
  assert_eq(I18n::unicode_length(unicode_string), 9)
  assert_eq(I18n::unicode_substring(unicode_string, 6, 3), "ä¸–ç•Œ ğŸŒ")
  assert_true(I18n::contains_unicode(unicode_string))
  assert_false(I18n::contains_unicode("Hello World"))
  
  // Test Unicode normalization
  let composed = "cafÃ©"
  let decomposed = I18n::unicode_normalize(composed, "NFD")
  assert_not_eq(composed, decomposed)
  assert_eq(I18n::unicode_normalize(decomposed, "NFC"), composed)
  
  Span::end(span)
  TracerProvider::shutdown(provider)
}