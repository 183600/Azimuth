// Internationalization Tests for Azimuth
// This file contains test cases for internationalization and localization support

test "unicode string handling" {
  // Test Chinese characters
  let chinese_text = "æµ‹è¯•ä¸­æ–‡é¥æµ‹ç³»ç»Ÿ"
  assert_eq(chinese_text.length(), 8)
  assert_true(chinese_text.contains("ä¸­æ–‡"))
  
  // Test Japanese characters
  let japanese_text = "æ—¥æœ¬èªãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ "
  assert_eq(japanese_text.length(), 12)
  assert_true(japanese_text.contains("æ—¥æœ¬èª"))
  
  // Test Korean characters
  let korean_text = "í•œêµ­ì–´ ì›ê²© ì¸¡ì • ì‹œìŠ¤í…œ"
  assert_eq(korean_text.length(), 12)
  assert_true(korean_text.contains("í•œêµ­ì–´"))
  
  // Test Arabic characters
  let arabic_text = "Ù†Ø¸Ø§Ù… Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  assert_eq(arabic_text.length(), 14)
  assert_true(arabic_text.contains("Ù†Ø¸Ø§Ù…"))
  
  // Test Russian characters
  let russian_text = "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ğ¸"
  assert_eq(russian_text.length(), 17)
  assert_true(russian_text.contains("Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ğ¸"))
}

test "emoji and symbol handling" {
  // Test emoji in telemetry context
  let emoji_span_name = "ğŸ” search operation"
  assert_eq(emoji_span_name.length(), 18)
  assert_true(emoji_span_name.contains("ğŸ”"))
  
  // Test multiple emoji
  let multi_emoji_text = "ğŸš€ performance ğŸ“Š metrics ğŸ“ˆ dashboard"
  assert_eq(multi_emoji_text.length(), 35)
  assert_true(multi_emoji_text.contains("ğŸš€"))
  assert_true(multi_emoji_text.contains("ğŸ“Š"))
  assert_true(multi_emoji_text.contains("ğŸ“ˆ"))
  
  // Test special symbols
  let symbol_text = "âš¡ fast service âš™ï¸ configuration ğŸ”§ maintenance"
  assert_eq(symbol_text.length(), 43)
  assert_true(symbol_text.contains("âš¡"))
  assert_true(symbol_text.contains("âš™ï¸"))
  assert_true(symbol_text.contains("ğŸ”§"))
}

test "multilingual attribute values" {
  let attrs = Attributes::new()
  
  // Test setting multilingual attributes
  Attributes::set(attrs, "error.message.zh", StringValue("æ“ä½œå¤±è´¥"))
  Attributes::set(attrs, "error.message.ja", StringValue("æ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ"))
  Attributes::set(attrs, "error.message.ko", StringValue("ì‘ì—…ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤"))
  Attributes::set(attrs, "error.message.ar", StringValue("ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©"))
  Attributes::set(attrs, "error.message.ru", StringValue("ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ°ÑÑŒ"))
  
  // Test retrieving multilingual attributes
  match Attributes::get(attrs, "error.message.zh") {
    Some(StringValue(v)) => assert_eq(v, "æ“ä½œå¤±è´¥")
    _ => assert_true(false)
  }
  
  match Attributes::get(attrs, "error.message.ja") {
    Some(StringValue(v)) => assert_eq(v, "æ“ä½œãŒå¤±æ•—ã—ã¾ã—ãŸ")
    _ => assert_true(false)
  }
  
  match Attributes::get(attrs, "error.message.ko") {
    Some(StringValue(v)) => assert_eq(v, "ì‘ì—…ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤")
    _ => assert_true(false)
  }
  
  match Attributes::get(attrs, "error.message.ar") {
    Some(StringValue(v)) => assert_eq(v, "ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©")
    _ => assert_true(false)
  }
  
  match Attributes::get(attrs, "error.message.ru") {
    Some(StringValue(v)) => assert_eq(v, "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ°ÑÑŒ")
    _ => assert_true(false)
  }
}

test "multilingual resource attributes" {
  let resource = Resource::new()
  
  // Test multilingual resource attributes
  let multilingual_attrs = [
    ("service.name.zh", StringValue("é¥æµ‹æœåŠ¡")),
    ("service.name.ja", StringValue("ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚µãƒ¼ãƒ“ã‚¹")),
    ("service.name.ko", StringValue("ì›ê²© ì¸¡ì • ì„œë¹„ìŠ¤")),
    ("service.description.zh", StringValue("æä¾›å…¨é¢çš„é¥æµ‹åŠŸèƒ½")),
    ("service.description.ja", StringValue("åŒ…æ‹¬çš„ãªãƒ†ãƒ¬ãƒ¡ãƒˆãƒªæ©Ÿèƒ½ã‚’æä¾›")),
    ("service.description.ko", StringValue("í¬ê´„ì ì¸ ì›ê²© ì¸¡ì • ê¸°ëŠ¥ ì œê³µ"))
  ]
  let resource_with_multilingual = Resource::with_attributes(resource, multilingual_attrs)
  
  // Test retrieving multilingual resource attributes
  match Resource::get_attribute(resource_with_multilingual, "service.name.zh") {
    Some(StringValue(v)) => assert_eq(v, "é¥æµ‹æœåŠ¡")
    _ => assert_true(false)
  }
  
  match Resource::get_attribute(resource_with_multilingual, "service.name.ja") {
    Some(StringValue(v)) => assert_eq(v, "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚µãƒ¼ãƒ“ã‚¹")
    _ => assert_true(false)
  }
  
  match Resource::get_attribute(resource_with_multilingual, "service.name.ko") {
    Some(StringValue(v)) => assert_eq(v, "ì›ê²© ì¸¡ì • ì„œë¹„ìŠ¤")
    _ => assert_true(false)
  }
}

test "multilingual log messages" {
  let provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(provider, "multilingual_logger")
  
  // Test multilingual log records
  let chinese_log = LogRecord::new(Info, "ç³»ç»Ÿå¯åŠ¨æˆåŠŸ")
  let japanese_log = LogRecord::new(Info, "ã‚·ã‚¹ãƒ†ãƒ ãŒæ­£å¸¸ã«èµ·å‹•ã—ã¾ã—ãŸ")
  let korean_log = LogRecord::new(Info, "ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤")
  let arabic_log = LogRecord::new(Info, "Ø¨Ø¯Ø£ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­")
  let russian_log = LogRecord::new(Info, "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ°")
  
  // Test multilingual log message content
  assert_eq(LogRecord::body(chinese_log), Some("ç³»ç»Ÿå¯åŠ¨æˆåŠŸ"))
  assert_eq(LogRecord::body(japanese_log), Some("ã‚·ã‚¹ãƒ†ãƒ ãŒæ­£å¸¸ã«èµ·å‹•ã—ã¾ã—ãŸ"))
  assert_eq(LogRecord::body(korean_log), Some("ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤"))
  assert_eq(LogRecord::body(arabic_log), Some("Ø¨Ø¯Ø£ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­"))
  assert_eq(LogRecord::body(russian_log), Some("Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½Ğ°"))
  
  // Test emitting multilingual logs
  Logger::emit(logger, chinese_log)
  Logger::emit(logger, japanese_log)
  Logger::emit(logger, korean_log)
  Logger::emit(logger, arabic_log)
  Logger::emit(logger, russian_log)
}

test "multilingual span names" {
  let provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(provider, "multilingual_tracer")
  
  // Test multilingual span creation
  let chinese_span = Tracer::start_span(tracer, "ä¸­æ–‡æ“ä½œ")
  let japanese_span = Tracer::start_span(tracer, "æ—¥æœ¬èªæ“ä½œ")
  let korean_span = Tracer::start_span(tracer, "í•œêµ­ì–´ ì‘ì—…")
  let arabic_span = Tracer::start_span(tracer, "Ø¹Ù…Ù„ÙŠØ© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  let russian_span = Tracer::start_span(tracer, "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼")
  
  // Test multilingual span names
  assert_eq(Span::name(chinese_span), "ä¸­æ–‡æ“ä½œ")
  assert_eq(Span::name(japanese_span), "æ—¥æœ¬èªæ“ä½œ")
  assert_eq(Span::name(korean_span), "í•œêµ­ì–´ ì‘ì—…")
  assert_eq(Span::name(arabic_span), "Ø¹Ù…Ù„ÙŠØ© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
  assert_eq(Span::name(russian_span), "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼")
}

test "right-to-left text handling" {
  // Test Arabic text (right-to-left)
  let arabic_text = "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"
  assert_eq(arabic_text.length(), 11)
  assert_true(arabic_text.contains("Ø§Ù„Ø¹Ø§Ù„Ù…"))
  
  // Test Hebrew text (right-to-left)
  let hebrew_text = "×©×œ×•× ×¢×•×œ×"
  assert_eq(hebrew_text.length(), 9)
  assert_true(hebrew_text.contains("×¢×•×œ×"))
  
  // Test mixed direction text
  let mixed_text = "English Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© English"
  assert_eq(mixed_text_text.length(), 20)
  assert_true(mixed_text.contains("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_true(mixed_text.contains("English"))
}

test "locale-specific formatting" {
  // Test different locale-specific number formats
  let number = 1234.56
  
  // US English format
  let us_format = "1,234.56"
  assert_eq(us_format.contains(","), true)
  assert_eq(us_format.contains("."), true)
  
  // European format
  let eu_format = "1.234,56"
  assert_eq(eu_format.contains("."), true)
  assert_eq(eu_format.contains(","), true)
  
  // Test different date formats
  let us_date = "12/31/2023"
  assert_eq(us_date.contains("/"), true)
  
  let iso_date = "2023-12-31"
  assert_eq(iso_date.contains("-"), true)
  
  let eu_date = "31.12.2023"
  assert_eq(eu_date.contains("."), true)
}

test "currency and number localization" {
  // Test currency symbols
  let usd_currency = "$123.45"
  assert_eq(usd_currency.contains("$"), true)
  
  let eur_currency = "â‚¬123.45"
  assert_eq(eur_currency.contains("â‚¬"), true)
  
  let jpy_currency = "Â¥123"
  assert_eq(jpy_currency.contains("Â¥"), true)
  
  let gbp_currency = "Â£123.45"
  assert_eq(gbp_currency.contains("Â£"), true)
  
  let cny_currency = "Â¥123.45"
  assert_eq(cny_currency.contains("Â¥"), true)
  
  // Test number separators
  let indian_number = "12,34,567.89"
  assert_eq(indian_number.contains(","), true)
  
  let chinese_number = "123,456.78"
  assert_eq(chinese_number.contains(","), true)
}

test "multilingual baggage entries" {
  let baggage = Baggage::new()
  
  // Test multilingual baggage
  let baggage_with_chinese = Baggage::set_entry(baggage, "é”™è¯¯ä»£ç ", "ERR001")
  let baggage_with_japanese = Baggage::set_entry(baggage_with_chinese, "ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰", "ERR001")
  let baggage_with_korean = Baggage::set_entry(baggage_with_japanese, "ì˜¤ë¥˜ ì½”ë“œ", "ERR001")
  
  // Test retrieving multilingual baggage entries
  match Baggage::get_entry(baggage_with_korean, "é”™è¯¯ä»£ç ") {
    Some(v) => assert_eq(v, "ERR001")
    None => assert_true(false)
  }
  
  match Baggage::get_entry(baggage_with_korean, "ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰") {
    Some(v) => assert_eq(v, "ERR001")
    None => assert_true(false)
  }
  
  match Baggage::get_entry(baggage_with_korean, "ì˜¤ë¥˜ ì½”ë“œ") {
    Some(v) => assert_eq(v, "ERR001")
    None => assert_true(false)
  }
}

test "character encoding validation" {
  // Test UTF-8 encoded strings
  let utf8_chinese = "é¥æµ‹"
  let utf8_japanese = "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª"
  let utf8_korean = "ì›ê²© ì¸¡ì •"
  let utf8_arabic = "Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  let utf8_russian = "Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ñ"
  
  // Test string operations on UTF-8 encoded strings
  assert_eq(utf8_chinese.length(), 2)
  assert_eq(utf8_japanese.length(), 5)
  assert_eq(utf8_korean.length(), 4)
  assert_eq(utf8_arabic.length(), 9)
  assert_eq(utf8_russian.length(), 9)
  
  // Test concatenation of UTF-8 strings
  let concatenated = utf8_chinese + " " + utf8_japanese + " " + utf8_korean
  assert_eq(concatenated.length(), 14)  // 2 + 1 + 5 + 1 + 4 = 13 (plus spaces)
  assert_true(concatenated.contains("é¥æµ‹"))
  assert_true(concatenated.contains("ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª"))
  assert_true(concatenated.contains("ì›ê²© ì¸¡ì •"))
}