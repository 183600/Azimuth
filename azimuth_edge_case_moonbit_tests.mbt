// Azimuth Edge Case MoonBit Test Suite
// é’ˆå¯¹é¥æµ‹ç³»ç»Ÿè¾¹ç¼˜æƒ…å†µå’Œå¼‚å¸¸åœºæ™¯çš„æµ‹è¯•ç”¨ä¾‹

// æµ‹è¯•1: å†…å­˜å‹åŠ›ä¸‹çš„é¥æµ‹æ“ä½œ
test "å†…å­˜å‹åŠ›ä¸‹é¥æµ‹æ“ä½œæµ‹è¯•" {
  // æ¨¡æ‹Ÿé«˜å†…å­˜ä½¿ç”¨æƒ…å†µä¸‹çš„é¥æµ‹æ“ä½œ
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "memory-pressure-test")
  
  // åˆ›å»ºå¤§é‡Span
  let spans = []
  for i in 0..1000 {
    let span = Tracer::start_span(tracer, "memory-pressure-span-" + i.to_string())
    spans.push(span)
  }
  
  // ä¸ºæ¯ä¸ªSpanæ·»åŠ å¤§é‡å±æ€§
  for i in 0..spans.length() {
    let span = spans[i]
    for j in 0..10 {
      let key = "attr-" + j.to_string()
      let value = "value-" + (i * 10 + j).to_string()
      Span::set_attribute(span, key, StringValue(value))
    }
  }
  
  // ç»“æŸæ‰€æœ‰Span
  for span in spans {
    Span::end(span)
  }
  
  // éªŒè¯æ“ä½œå®Œæˆ
  assert_true(spans.length() == 1000)
}

// æµ‹è¯•2: æç«¯æ—¶é—´æˆ³å¤„ç†
test "æç«¯æ—¶é—´æˆ³å¤„ç†æµ‹è¯•" {
  let clock = Clock::system()
  
  // æµ‹è¯•æœ€å°æ—¶é—´æˆ³
  let min_timestamp = 0L
  let log_with_min_time = LogRecord::new_with_timestamp(Info, "æœ€å°æ—¶é—´æˆ³æ—¥å¿—", min_timestamp)
  assert_eq(LogRecord::timestamp(log_with_min_time), min_timestamp)
  
  // æµ‹è¯•æœ€å¤§æ—¶é—´æˆ³
  let max_timestamp = 9223372036854775807L  // Longæœ€å¤§å€¼
  let log_with_max_time = LogRecord::new_with_timestamp(Error, "æœ€å¤§æ—¶é—´æˆ³æ—¥å¿—", max_timestamp)
  assert_eq(LogRecord::timestamp(log_with_max_time), max_timestamp)
  
  // æµ‹è¯•è´Ÿæ—¶é—´æˆ³ï¼ˆç†è®ºä¸Šä¸åº”è¯¥å‡ºç°ï¼Œä½†æµ‹è¯•å®¹é”™æ€§ï¼‰
  let negative_timestamp = -1000L
  let log_with_negative_time = LogRecord::new_with_timestamp(Warn, "è´Ÿæ—¶é—´æˆ³æ—¥å¿—", negative_timestamp)
  assert_eq(LogRecord::timestamp(log_with_negative_time), negative_timestamp)
  
  // æµ‹è¯•å½“å‰ç³»ç»Ÿæ—¶é—´
  let current_time = Clock::now_unix_nanos(clock)
  let current_log = LogRecord::new_with_timestamp(Info, "å½“å‰æ—¶é—´æ—¥å¿—", current_time)
  assert_eq(LogRecord::timestamp(current_log), current_time)
  
  // éªŒè¯æ—¶é—´æˆ³æ¯”è¾ƒ
  assert_true(min_timestamp < current_time)
  assert_true(current_time < max_timestamp)
  assert_true(negative_timestamp < min_timestamp)
}

// æµ‹è¯•3: ç‰¹æ®Šå­—ç¬¦å’Œå›½é™…åŒ–å¤„ç†
test "ç‰¹æ®Šå­—ç¬¦å’Œå›½é™…åŒ–å¤„ç†æµ‹è¯•" {
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "internationalization-test")
  let span = Tracer::start_span(tracer, "å›½é™…åŒ–æµ‹è¯•Span")
  
  // æµ‹è¯•ä¸­æ–‡å±æ€§
  Span::set_attribute(span, "æœåŠ¡åç§°", StringValue("ç”¨æˆ·æœåŠ¡"))
  Span::set_attribute(span, "æ“ä½œç±»å‹", StringValue("åˆ›å»ºè®¢å•"))
  Span::set_attribute(span, "é”™è¯¯ä¿¡æ¯", StringValue("æ•°æ®åº“è¿æ¥è¶…æ—¶"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  Span::set_attribute(span, "special.chars", StringValue("!@#$%^&*()_+-=[]{}|;':\",./<>?"))
  Span::set_attribute(span, "unicode.chars", StringValue("ğŸš€ ğŸŒŸ ğŸ’» ğŸ“Š"))
  Span::set_attribute(span, "newlines", StringValue("ç¬¬ä¸€è¡Œ\nç¬¬äºŒè¡Œ\r\nç¬¬ä¸‰è¡Œ"))
  Span::set_attribute(span, "tabs", StringValue("åˆ—1\tåˆ—2\tåˆ—3"))
  
  // æµ‹è¯•ç©ºæ ¼å’Œç©ºç™½å­—ç¬¦
  Span::set_attribute(span, "spaces", StringValue("   å‰åç©ºæ ¼   "))
  Span::set_attribute(span, "empty", StringValue(""))
  
  // æµ‹è¯•éå¸¸é•¿çš„å­—ç¬¦ä¸²
  let long_string = "è¿™æ˜¯ä¸€ä¸ªå¾ˆé•¿çš„å­—ç¬¦ä¸²ï¼Œ"
  for i in 0..50 {
    long_string = long_string + "é‡å¤å†…å®¹" + i.to_string()
  }
  Span::set_attribute(span, "long.string", StringValue(long_string))
  
  // æ·»åŠ å›½é™…åŒ–äº‹ä»¶
  Span::add_event(span, "ä¸­æ–‡äº‹ä»¶", Some([("äº‹ä»¶æè¿°", StringValue("ç”¨æˆ·ç™»å½•æˆåŠŸ"))]))
  Span::add_event(span, "English Event", Some([("Event Description", StringValue("User login successful"))]))
  
  // éªŒè¯å›½é™…åŒ–å¤„ç†
  assert_true(true) // ç®€åŒ–éªŒè¯ï¼Œç¡®ä¿æ²¡æœ‰å´©æºƒ
  
  Span::end(span)
}

// æµ‹è¯•4: å¹¶å‘èµ„æºç«äº‰
test "å¹¶å‘èµ„æºç«äº‰æµ‹è¯•" {
  // åˆ›å»ºå…±äº«èµ„æº
  let shared_meter_provider = MeterProvider::default()
  let shared_meter = MeterProvider::get_meter(shared_meter_provider, "shared-meter")
  let shared_counter = Meter::create_counter(shared_meter, "shared.counter")
  
  // æ¨¡æ‹Ÿå¤šä¸ªå¹¶å‘æ“ä½œ
  let operations = []
  
  // å¹¶å‘å¢åŠ è®¡æ•°å™¨
  for i in 0..100 {
    let operation = fn() {
      for j in 0..10 {
        Counter::add(shared_counter, 1.0)
      }
    }
    operations.push(operation)
  }
  
  // æ‰§è¡Œæ‰€æœ‰æ“ä½œï¼ˆåœ¨å®é™…å®ç°ä¸­ä¼šçœŸæ­£å¹¶å‘æ‰§è¡Œï¼‰
  for operation in operations {
    operation()
  }
  
  // éªŒè¯è®¡æ•°å™¨åˆ›å»ºæˆåŠŸ
  assert_eq(shared_counter.name, "shared.counter")
  
  // æµ‹è¯•å…±äº«Tracer
  let shared_tracer_provider = TracerProvider::default()
  let shared_tracer = TracerProvider::get_tracer(shared_tracer_provider, "shared-tracer")
  
  let concurrent_spans = []
  for i in 0..50 {
    let span = Tracer::start_span(shared_tracer, "concurrent-span-" + i.to_string())
    concurrent_spans.push(span)
  }
  
  // å¹¶å‘è®¾ç½®å±æ€§
  for i in 0..concurrent_spans.length() {
    let span = concurrent_spans[i]
    Span::set_attribute(span, "thread.id", IntValue(i))
    Span::set_attribute(span, "operation.type", StringValue("concurrent"))
  }
  
  // å¹¶å‘ç»“æŸSpan
  for span in concurrent_spans {
    Span::end(span)
  }
  
  // éªŒè¯å¹¶å‘æ“ä½œ
  assert_true(concurrent_spans.length() == 50)
}

// æµ‹è¯•5: åº¦é‡æ•°æ®è¾¹ç•Œå€¼
test "åº¦é‡æ•°æ®è¾¹ç•Œå€¼æµ‹è¯•" {
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary-test-meter")
  
  // æµ‹è¯•Counterè¾¹ç•Œå€¼
  let counter = Meter::create_counter(meter, "boundary.counter")
  
  // æµ‹è¯•é›¶å€¼
  Counter::add(counter, 0.0)
  
  // æµ‹è¯•è´Ÿå€¼ï¼ˆå¯¹äºCounteråº”è¯¥å¿½ç•¥æˆ–æŠ¥é”™ï¼‰
  Counter::add(counter, -1.0)
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(counter, 1.7976931348623157e+308)  // Doubleæœ€å¤§å€¼
  
  // æµ‹è¯•æå°æ­£å€¼
  Counter::add(counter, 5e-324)  // Doubleæœ€å°æ­£å€¼
  
  // æµ‹è¯•æ— ç©·å¤§
  Counter::add(counter, 1.0 / 0.0)  // æ­£æ— ç©·
  Counter::add(counter, -1.0 / 0.0)  // è´Ÿæ— ç©·
  
  // æµ‹è¯•NaN
  Counter::add(counter, 0.0 / 0.0)  // NaN
  
  // æµ‹è¯•Histogramè¾¹ç•Œå€¼
  let histogram = Meter::create_histogram(meter, "boundary.histogram")
  
  // è®°å½•è¾¹ç•Œå€¼
  Histogram::record(histogram, 0.0)
  Histogram::record(histogram, -1.0)
  Histogram::record(histogram, 1.7976931348623157e+308)
  Histogram::record(histogram, 5e-324)
  Histogram::record(histogram, 1.0 / 0.0)
  Histogram::record(histogram, -1.0 / 0.0)
  Histogram::record(histogram, 0.0 / 0.0)
  
  // æµ‹è¯•UpDownCounterè¾¹ç•Œå€¼
  let updown_counter = Meter::create_updown_counter(meter, "boundary.updown.counter")
  
  UpDownCounter::add(updown_counter, 1.7976931348623157e+308)
  UpDownCounter::add(updown_counter, -1.7976931348623157e+308)
  
  // æµ‹è¯•Gaugeè¾¹ç•Œå€¼
  let gauge = Meter::create_gauge(meter, "boundary.gauge")
  
  // Gaugeè®°å½•è¾¹ç•Œå€¼
  Gauge::record(gauge, 0.0)
  Gauge::record(gauge, 1.7976931348623157e+308)
  Gauge::record(gauge, -1.7976931348623157e+308)
  
  // éªŒè¯åº¦é‡å·¥å…·åˆ›å»ºæˆåŠŸ
  assert_eq(counter.name, "boundary.counter")
  assert_eq(histogram.name, "boundary.histogram")
  assert_eq(updown_counter.name, "boundary.updown.counter")
  assert_eq(gauge.name, "boundary.gauge")
}

// æµ‹è¯•6: ä¸Šä¸‹æ–‡åµŒå¥—å’Œå¾ªç¯å¼•ç”¨
test "ä¸Šä¸‹æ–‡åµŒå¥—å’Œå¾ªç¯å¼•ç”¨æµ‹è¯•" {
  // åˆ›å»ºæ ¹ä¸Šä¸‹æ–‡
  let root_ctx = Context::root()
  
  // åˆ›å»ºæ·±å±‚åµŒå¥—ä¸Šä¸‹æ–‡
  let ctx1 = Context::with_value(root_ctx, ContextKey::new("level1"), "value1")
  let ctx2 = Context::with_value(ctx1, ContextKey::new("level2"), "value2")
  let ctx3 = Context::with_value(ctx2, ContextKey::new("level3"), "value3")
  let ctx4 = Context::with_value(ctx3, ContextKey::new("level4"), "value4")
  let ctx5 = Context::with_value(ctx4, ContextKey::new("level5"), "value5")
  
  // éªŒè¯æ·±å±‚åµŒå¥—
  assert_eq(Context::get(ctx5, ContextKey::new("level1")), Some("value1"))
  assert_eq(Context::get(ctx5, ContextKey::new("level2")), Some("value2"))
  assert_eq(Context::get(ctx5, ContextKey::new("level3")), Some("value3"))
  assert_eq(Context::get(ctx5, ContextKey::new("level4")), Some("value4"))
  assert_eq(Context::get(ctx5, ContextKey::new("level5")), Some("value5"))
  
  // æµ‹è¯•ç›¸åŒé”®çš„è¦†ç›–
  let ctx_override = Context::with_value(ctx5, ContextKey::new("level3"), "overridden_value3")
  assert_eq(Context::get(ctx_override, ContextKey::new("level3")), Some("overridden_value3"))
  assert_eq(Context::get(ctx_override, ContextKey::new("level1")), Some("value1"))  // å…¶ä»–å€¼ä¿æŒä¸å˜
  
  // æµ‹è¯•å¤§é‡ä¸Šä¸‹æ–‡å€¼
  let many_values_ctx = root_ctx
  for i in 0..100 {
    let key = ContextKey::new("key" + i.to_string())
    let value = "value" + i.to_string()
    many_values_ctx = Context::with_value(many_values_ctx, key, value)
  }
  
  // éªŒè¯å¤§é‡ä¸Šä¸‹æ–‡å€¼
  assert_eq(Context::get(many_values_ctx, ContextKey::new("key0")), Some("value0"))
  assert_eq(Context::get(many_values_ctx, ContextKey::new("key50")), Some("value50"))
  assert_eq(Context::get(many_values_ctx, ContextKey::new("key99")), Some("value99"))
  
  // æµ‹è¯•ç©ºé”®å’Œç©ºå€¼
  let empty_key_ctx = Context::with_value(root_ctx, ContextKey::new(""), "empty_key_value")
  let empty_value_ctx = Context::with_value(root_ctx, ContextKey::new("empty_value_key"), "")
  
  assert_eq(Context::get(empty_key_ctx, ContextKey::new("")), Some("empty_key_value"))
  assert_eq(Context::get(empty_value_ctx, ContextKey::new("empty_value_key")), Some(""))
}

// æµ‹è¯•7: èµ„æºé™åˆ¶å’Œæ¢å¤
test "èµ„æºé™åˆ¶å’Œæ¢å¤æµ‹è¯•" {
  // æ¨¡æ‹Ÿèµ„æºé™åˆ¶åœºæ™¯
  
  // æµ‹è¯•Spanæ•°é‡é™åˆ¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "resource-limit-test")
  
  let max_spans = 10000
  let spans = []
  
  // å°è¯•åˆ›å»ºå¤§é‡Span
  for i in 0..max_spans {
    let span = Tracer::start_span(tracer, "limit-test-span-" + i.to_string())
    spans.push(span)
    
    // æ¯1000ä¸ªSpanæ£€æŸ¥ä¸€æ¬¡
    if i % 1000 == 0 && i > 0 {
      // åœ¨çœŸå®å®ç°ä¸­ï¼Œè¿™é‡Œå¯èƒ½ä¼šæ£€æŸ¥èµ„æºä½¿ç”¨æƒ…å†µ
      assert_true(spans.length() == i + 1)
    }
  }
  
  // ç»“æŸæ‰€æœ‰Spanä»¥é‡Šæ”¾èµ„æº
  for span in spans {
    Span::end(span)
  }
  
  // æµ‹è¯•åº¦é‡èµ„æºé™åˆ¶
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "resource-limit-meter")
  
  let instruments = []
  
  // åˆ›å»ºå¤§é‡åº¦é‡å·¥å…·
  for i in 0..1000 {
    let counter = Meter::create_counter(meter, "counter-" + i.to_string())
    let histogram = Meter::create_histogram(meter, "histogram-" + i.to_string())
    let updown_counter = Meter::create_updown_counter(meter, "updown-" + i.to_string())
    let gauge = Meter::create_gauge(meter, "gauge-" + i.to_string())
    
    instruments.push(counter)
    instruments.push(histogram)
    instruments.push(updown_counter)
    instruments.push(gauge)
  }
  
  // éªŒè¯åº¦é‡å·¥å…·åˆ›å»º
  assert_true(instruments.length() == 4000)
  
  // æµ‹è¯•æ—¥å¿—èµ„æºé™åˆ¶
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "resource-limit-logger")
  
  let logs = []
  
  // åˆ›å»ºå¤§é‡æ—¥å¿—è®°å½•
  for i in 0..5000 {
    let log = LogRecord::new(Info, "æ—¥å¿—è®°å½• " + i.to_string())
    logs.push(log)
  }
  
  // å‘å‡ºæ‰€æœ‰æ—¥å¿—
  for log in logs {
    Logger::emit(logger, log)
  }
  
  // éªŒè¯æ—¥å¿—å¤„ç†
  assert_true(logs.length() == 5000)
}

// æµ‹è¯•8: é”™è¯¯ä¼ æ’­å’Œæ¢å¤æœºåˆ¶
test "é”™è¯¯ä¼ æ’­å’Œæ¢å¤æœºåˆ¶æµ‹è¯•" {
  // æµ‹è¯•Spané”™è¯¯å¤„ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error-recovery-test")
  
  let span = Tracer::start_span(tracer, "error-recovery-span")
  
  // è®°å½•é”™è¯¯äº‹ä»¶
  Span::add_event(span, "error.occurred", Some([
    ("error.type", StringValue("DatabaseError")),
    ("error.message", StringValue("Connection timeout")),
    ("error.code", IntValue(1001))
  ]))
  
  // è®¾ç½®é”™è¯¯çŠ¶æ€
  Span::set_status(span, Error, Some("æ“ä½œå¤±è´¥: æ•°æ®åº“è¿æ¥è¶…æ—¶"))
  
  // è®°å½•æ¢å¤äº‹ä»¶
  Span::add_event(span, "recovery.attempted", Some([
    ("recovery.action", StringValue("retry")),
    ("retry.count", IntValue(1))
  ]))
  
  // è®¾ç½®æ¢å¤çŠ¶æ€
  Span::set_status(span, Ok, Some("æ“ä½œæˆåŠŸ: é‡è¯•åå®Œæˆ"))
  
  Span::end(span)
  
  // æµ‹è¯•æ—¥å¿—é”™è¯¯å¤„ç†
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "error-recovery-logger")
  
  // è®°å½•é”™è¯¯æ—¥å¿—
  let error_log = LogRecord::new(Error, "ä¸¥é‡é”™è¯¯: ç³»ç»Ÿç»„ä»¶æ•…éšœ")
  Logger::emit(logger, error_log)
  
  // è®°å½•æ¢å¤æ—¥å¿—
  let recovery_log = LogRecord::new(Info, "æ¢å¤æˆåŠŸ: ç³»ç»Ÿç»„ä»¶å·²é‡å¯")
  Logger::emit(logger, recovery_log)
  
  // æµ‹è¯•åº¦é‡é”™è¯¯å¤„ç†
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "error-recovery-meter")
  
  let error_counter = Meter::create_counter(meter, "errors.total")
  let recovery_counter = Meter::create_counter(meter, "recoveries.total")
  
  // è®°å½•é”™è¯¯å’Œæ¢å¤åº¦é‡
  Counter::add(error_counter, 1.0)
  Counter::add(recovery_counter, 1.0)
  
  // éªŒè¯é”™è¯¯æ¢å¤æœºåˆ¶
  assert_eq(error_counter.name, "errors.total")
  assert_eq(recovery_counter.name, "recoveries.total")
}

// æµ‹è¯•9: è·¨æ—¶åŒºæ—¶é—´å¤„ç†
test "è·¨æ—¶åŒºæ—¶é—´å¤„ç†æµ‹è¯•" {
  let clock = Clock::system()
  
  // è·å–å½“å‰æ—¶é—´æˆ³
  let base_timestamp = Clock::now_unix_nanos(clock)
  
  // æ¨¡æ‹Ÿä¸åŒæ—¶åŒºçš„æ—¶é—´æˆ³åç§»
  let utc_offset = 0L
  let est_offset = -5L * 3600L * 1000000000L  // EST: UTC-5
  let pst_offset = -8L * 3600L * 1000000000L  // PST: UTC-8
  let cst_offset = 8L * 3600L * 1000000000L   // CST: UTC+8
  let jst_offset = 9L * 3600L * 1000000000L   // JST: UTC+9
  
  // åˆ›å»ºä¸åŒæ—¶åŒºçš„æ—¥å¿—è®°å½•
  let utc_log = LogRecord::new_with_timestamp(Info, "UTCæ—¶é—´æ—¥å¿—", base_timestamp + utc_offset)
  let est_log = LogRecord::new_with_timestamp(Info, "ESTæ—¶é—´æ—¥å¿—", base_timestamp + est_offset)
  let pst_log = LogRecord::new_with_timestamp(Info, "PSTæ—¶é—´æ—¥å¿—", base_timestamp + pst_offset)
  let cst_log = LogRecord::new_with_timestamp(Info, "CSTæ—¶é—´æ—¥å¿—", base_timestamp + cst_offset)
  let jst_log = LogRecord::new_with_timestamp(Info, "JSTæ—¶é—´æ—¥å¿—", base_timestamp + jst_offset)
  
  // éªŒè¯æ—¶åŒºåç§»
  assert_true(LogRecord::timestamp(est_log) < LogRecord::timestamp(utc_log))
  assert_true(LogRecord::timestamp(pst_log) < LogRecord::timestamp(est_log))
  assert_true(LogRecord::timestamp(utc_log) < LogRecord::timestamp(cst_log))
  assert_true(LogRecord::timestamp(cst_log) < LogRecord::timestamp(jst_log))
  
  // æµ‹è¯•å¤ä»¤æ—¶å˜åŒ–ï¼ˆç®€åŒ–å¤„ç†ï¼‰
  let dst_offset = 1L * 3600L * 1000000000L  // å¤ä»¤æ—¶: +1å°æ—¶
  let dst_log = LogRecord::new_with_timestamp(Info, "å¤ä»¤æ—¶æ—¥å¿—", base_timestamp + dst_offset)
  
  // éªŒè¯å¤ä»¤æ—¶å½±å“
  assert_true(LogRecord::timestamp(dst_log) > LogRecord::timestamp(utc_log))
  
  // æµ‹è¯•è·¨åº¦æ—¶é—´æˆ³
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "timezone-test")
  
  let span = Tracer::start_span(tracer, "timezone-span")
  
  // æ¨¡æ‹Ÿåœ¨ä¸åŒæ—¶åŒºè®°å½•äº‹ä»¶
  Span::add_event_with_timestamp(span, "utc.event", base_timestamp + utc_offset)
  Span::add_event_with_timestamp(span, "est.event", base_timestamp + est_offset)
  Span::add_event_with_timestamp(span, "pst.event", base_timestamp + pst_offset)
  Span::add_event_with_timestamp(span, "cst.event", base_timestamp + cst_offset)
  Span::add_event_with_timestamp(span, "jst.event", base_timestamp + jst_offset)
  
  Span::end(span)
  
  // éªŒè¯è·¨æ—¶åŒºå¤„ç†
  assert_true(true) // ç®€åŒ–éªŒè¯ï¼Œç¡®ä¿æ²¡æœ‰å´©æºƒ
}

// æµ‹è¯•10: æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–
test "æ•°æ®åºåˆ—åŒ–å’Œååºåˆ—åŒ–æµ‹è¯•" {
  // æµ‹è¯•Spanåºåˆ—åŒ–
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "serialization-test")
  
  let span = Tracer::start_span(tracer, "serialization-span")
  
  // è®¾ç½®å¤æ‚å±æ€§
  Span::set_attribute(span, "string.attr", StringValue("å­—ç¬¦ä¸²å€¼"))
  Span::set_attribute(span, "int.attr", IntValue(42))
  Span::set_attribute(span, "float.attr", FloatValue(3.14159))
  Span::set_attribute(span, "bool.attr", BoolValue(true))
  Span::set_attribute(span, "array.attr", ArrayStringValue(["å€¼1", "å€¼2", "å€¼3"]))
  
  // æ·»åŠ äº‹ä»¶
  Span::add_event(span, "serialization.event", Some([
    ("event.data", StringValue("äº‹ä»¶æ•°æ®")),
    ("event.timestamp", IntValue(1640995200))
  ]))
  
  // è®¾ç½®çŠ¶æ€
  Span::set_status(span, Ok, Some("åºåˆ—åŒ–æµ‹è¯•æˆåŠŸ"))
  
  // æ¨¡æ‹Ÿåºåˆ—åŒ–ï¼ˆåœ¨å®é™…å®ç°ä¸­ä¼šæœ‰çœŸå®çš„åºåˆ—åŒ–é€»è¾‘ï¼‰
  let serialized_span = "serialized_span_data"
  
  // æ¨¡æ‹Ÿååºåˆ—åŒ–ï¼ˆåœ¨å®é™…å®ç°ä¸­ä¼šæœ‰çœŸå®çš„ååºåˆ—åŒ–é€»è¾‘ï¼‰
  let deserialized_span = span
  
  // éªŒè¯ååºåˆ—åŒ–åçš„æ•°æ®
  assert_eq(Span::name(deserialized_span), "serialization-span")
  assert_eq(Span::status(deserialized_span), Ok)
  
  Span::end(span)
  
  // æµ‹è¯•åº¦é‡åºåˆ—åŒ–
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "serialization-meter")
  
  let counter = Meter::create_counter(meter, "serialization.counter")
  Counter::add(counter, 100.0)
  
  // æ¨¡æ‹Ÿåº¦é‡åºåˆ—åŒ–
  let serialized_metrics = "serialized_metrics_data"
  
  // æ¨¡æ‹Ÿåº¦é‡ååºåˆ—åŒ–
  let deserialized_counter = counter
  
  // éªŒè¯ååºåˆ—åŒ–åçš„åº¦é‡
  assert_eq(deserialized_counter.name, "serialization.counter")
  
  // æµ‹è¯•æ—¥å¿—åºåˆ—åŒ–
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "serialization-logger")
  
  let log = LogRecord::new_with_attributes(Info, "åºåˆ—åŒ–æµ‹è¯•æ—¥å¿—", [
    ("log.string", StringValue("æ—¥å¿—å­—ç¬¦ä¸²")),
    ("log.int", IntValue(123)),
    ("log.float", FloatValue(456.789)),
    ("log.bool", BoolValue(false))
  ])
  
  // æ¨¡æ‹Ÿæ—¥å¿—åºåˆ—åŒ–
  let serialized_log = "serialized_log_data"
  
  // æ¨¡æ‹Ÿæ—¥å¿—ååºåˆ—åŒ–
  let deserialized_log = log
  
  // éªŒè¯ååºåˆ—åŒ–åçš„æ—¥å¿—
  assert_eq(LogRecord::severity_number(deserialized_log), Info)
  assert_eq(LogRecord::body(deserialized_log), Some("åºåˆ—åŒ–æµ‹è¯•æ—¥å¿—"))
  
  // éªŒè¯åºåˆ—åŒ–è¿‡ç¨‹
  assert_true(serialized_span.length() > 0)
  assert_true(serialized_metrics.length() > 0)
  assert_true(serialized_log.length() > 0)
}