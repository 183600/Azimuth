// Azimuth Telemetry System - Premium Boundary Condition and Edge Case Tests
// This file contains comprehensive boundary condition and edge case tests for telemetry operations

// Test 1: Attribute Boundary Conditions
test "attribute boundary conditions" {
  let attrs = Attributes::new()
  
  // Test empty and null values
  let result1 = Attributes::set(attrs, "", StringValue("empty_key_test"))
  match result1 {
    Ok(_) => assert_true(true) // Should handle empty key gracefully
    Err(_) => assert_true(true) // Or return appropriate error
  }
  
  let result2 = Attributes::set(attrs, "empty_value_test", StringValue(""))
  match result2 {
    Ok(_) => assert_true(true) // Should handle empty value gracefully
    Err(_) => assert_true(true) // Or return appropriate error
  }
  
  // Test extremely long keys and values
  let max_key_length = 256
  let max_value_length = 4096
  let long_key = "a".repeat(max_key_length)
  let long_value = StringValue("b".repeat(max_value_length))
  
  let result3 = Attributes::set(attrs, long_key, long_value)
  match result3 {
    Ok(_) => assert_true(true) // Should handle long strings
    Err(_) => assert_true(true) // Or return appropriate error
  }
  
  // Test maximum number of attributes
  let max_attributes = 1000
  for i in 0..<max_attributes {
    let key = "boundary_test_key_" + i.to_string()
    let value = StringValue("boundary_test_value_" + i.to_string())
    Attributes::set(attrs, key, value)
  }
  
  let attribute_count = attrs.length()
  assert_true(attribute_count >= max_attributes - 10) // Allow some tolerance for implementation limits
  
  // Test special characters and Unicode
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let unicode_text = "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ ðŸš€ Ð¢ÐµÑÑ‚ Ñ€ÑƒÑÑÐºÐ¸Ð¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© æ—¥æœ¬èªž í•œêµ­ì–´"
  
  Attributes::set(attrs, "special_chars", StringValue(special_chars))
  Attributes::set(attrs, "unicode_text", StringValue(unicode_text))
  
  let special_result = Attributes::get(attrs, "special_chars")
  match special_result {
    Some(StringValue(value)) => assert_eq(value, special_chars)
    None => assert_true(false)
  }
  
  let unicode_result = Attributes::get(attrs, "unicode_text")
  match unicode_result {
    Some(StringValue(value)) => assert_eq(value, unicode_text)
    None => assert_true(false)
  }
  
  // Test numeric boundaries
  let max_int = Int::max_value()
  let min_int = Int::min_value()
  let max_float = Float::max_value()
  let min_float = Float::min_value()
  
  Attributes::set(attrs, "max_int", IntValue(max_int))
  Attributes::set(attrs, "min_int", IntValue(min_int))
  Attributes::set(attrs, "max_float", FloatValue(max_float))
  Attributes::set(attrs, "min_float", FloatValue(min_float))
  
  // Test infinity and NaN
  Attributes::set(attrs, "positive_infinity", FloatValue(Float::infinity()))
  Attributes::set(attrs, "negative_infinity", FloatValue(Float::neg_infinity()))
  Attributes::set(attrs, "nan_value", FloatValue(Float::nan()))
  
  // Test boolean edge cases
  Attributes::set(attrs, "true_value", BoolValue(true))
  Attributes::set(attrs, "false_value", BoolValue(false))
}

// Test 2: Span Boundary Conditions
test "span boundary conditions" {
  let trace_id = "0".repeat(32) // Valid but all zeros
  let span_id = "0".repeat(16)   // Valid but all zeros
  let span_ctx = SpanContext::new(trace_id, span_id, true, "")
  
  // Test zero trace/span IDs
  assert_false(SpanContext::is_valid(span_ctx)) // All zeros should be invalid
  
  // Test maximum length trace/span IDs
  let max_trace_id = "f".repeat(32)
  let max_span_id = "f".repeat(16)
  let max_ctx = SpanContext::new(max_trace_id, max_span_id, true, "")
  assert_true(SpanContext::is_valid(max_ctx)) // All fs should be valid
  
  // Test invalid hex characters
  let invalid_trace = "0af7651916cd43dd8448eb211c80319z" // Contains 'z'
  let invalid_span = "b7ad6b716920333z" // Contains 'z'
  let invalid_ctx = SpanContext::new(invalid_trace, invalid_span, true, "")
  assert_false(SpanContext::is_valid(invalid_ctx))
  
  // Test span name boundaries
  let empty_span = Span::new("", Internal, span_ctx)
  assert_eq(Span::name(empty_span), "")
  
  let very_long_name = "a".repeat(1000)
  let long_name_span = Span::new(very_long_name, Internal, span_ctx)
  assert_eq(Span::name(long_name_span).length(), 1000)
  
  // Test span kind boundaries
  let internal_span = Span::new("test", Internal, span_ctx)
  let server_span = Span::new("test", Server, span_ctx)
  let client_span = Span::new("test", Client, span_ctx)
  let producer_span = Span::new("test", Producer, span_ctx)
  let consumer_span = Span::new("test", Consumer, span_ctx)
  
  assert_eq(Span::kind(internal_span), Internal)
  assert_eq(Span::kind(server_span), Server)
  assert_eq(Span::kind(client_span), Client)
  assert_eq(Span::kind(producer_span), Producer)
  assert_eq(Span::kind(consumer_span), Consumer)
  
  // Test span status boundaries
  Span::set_status(internal_span, Unset, None)
  Span::set_status(server_span, Ok, Some("Success"))
  Span::set_status(client_span, Error, Some("Error occurred"))
  
  assert_eq(Span::status(internal_span), Unset)
  assert_eq(Span::status(server_span), Ok)
  assert_eq(Span::status(client_span), Error)
  
  // Test operations on ended spans
  Span::end(internal_span)
  assert_false(Span::is_recording(internal_span))
  
  // Operations after end should be handled gracefully
  Span::add_event(internal_span, "post_end_event", None)
  Span::set_status(internal_span, Error, Some("Post end error"))
  
  // Test maximum number of events
  let max_events = 1000
  for i in 0..<max_events {
    Span::add_event(server_span, "event_" + i.to_string(), Some([
      ("event_index", IntValue(i))
    ]))
  }
  
  // Test maximum number of attributes
  let max_span_attrs = 500
  for i in 0..<max_span_attrs {
    Span::set_attribute(server_span, "attr_" + i.to_string(), StringValue("value_" + i.to_string()))
  }
}

// Test 3: Metrics Boundary Conditions
test "metrics boundary conditions" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "boundary_test_meter")
  
  // Test instrument name boundaries
  let empty_name_counter = Meter::create_counter(meter, "", Some("Empty name"), Some("count"))
  match empty_name_counter {
    Ok(_) => assert_true(true) // Should handle empty name
    Err(_) => assert_true(true) // Or return appropriate error
  }
  
  let very_long_name = "a".repeat(1000)
  let long_name_counter = Meter::create_counter(meter, very_long_name, Some("Long name"), Some("count"))
  match long_name_counter {
    Ok(_) => assert_true(true) // Should handle long name
    Err(_) => assert_true(true) // Or return appropriate error
  }
  
  // Test special characters in instrument names
  let special_name = "counter.with.special@chars#and$symbols"
  let special_counter = Meter::create_counter(meter, special_name, Some("Special chars"), Some("count"))
  match special_counter {
    Ok(_) => assert_true(true) // Should handle special characters
    Err(_) => assert_true(true) // Or return appropriate error
  }
  
  // Test numeric boundary values
  let counter = match Meter::create_counter(meter, "boundary_counter", Some("Boundary test"), Some("count")) {
    Ok(counter) => counter
    Err(_) => {
      assert_true(false) // Should not fail
      return
    }
  }
  
  // Test extreme values
  Counter::add(counter, Float::max_value())
  Counter::add(counter, Float::min_value())
  Counter::add(counter, 0.0)
  Counter::add(counter, Float::infinity())
  Counter::add(counter, Float::neg_infinity())
  Counter::add(counter, Float::nan())
  
  // Test histogram with boundary values
  let histogram = match Meter::create_histogram(meter, "boundary_histogram", Some("Boundary test"), Some("ms")) {
    Ok(histogram) => histogram
    Err(_) => {
      assert_true(false) // Should not fail
      return
    }
  }
  
  Histogram::record(histogram, Float::max_value())
  Histogram::record(histogram, Float::min_value())
  Histogram::record(histogram, 0.0)
  Histogram::record(histogram, Float::infinity())
  Histogram::record(histogram, Float::neg_infinity())
  Histogram::record(histogram, Float::nan())
  
  // Test updown counter with boundary values
  let updown_counter = match Meter::create_updown_counter(meter, "boundary_updown", Some("Boundary test"), Some("value")) {
    Ok(updown) => updown
    Err(_) => {
      assert_true(false) // Should not fail
      return
    }
  }
  
  UpDownCounter::add(updown_counter, Float::max_value())
  UpDownCounter::add(updown_counter, Float::min_value())
  UpDownCounter::add(updown_counter, 0.0)
  
  // Test gauge with boundary values
  let gauge = match Meter::create_gauge(meter, "boundary_gauge", Some("Boundary test"), Some("value")) {
    Ok(gauge) => gauge
    Err(_) => {
      assert_true(false) // Should not fail
      return
    }
  }
  
  Gauge::set(gauge, Float::max_value())
  Gauge::set(gauge, Float::min_value())
  Gauge::set(gauge, 0.0)
  Gauge::set(gauge, Float::infinity())
  Gauge::set(gauge, Float::neg_infinity())
  Gauge::set(gauge, Float::nan())
  
  // Test maximum number of metric instruments
  let max_instruments = 100
  let instruments = []
  
  for i in 0..<max_instruments {
    let counter_name = "counter_" + i.to_string()
    match Meter::create_counter(meter, counter_name, Some("Test counter"), Some("count")) {
      Ok(counter) => instruments.push(counter)
      Err(_) => assert_true(true) // May hit limits
    }
  }
  
  assert_true(instruments.length() > 0) // At least some should be created
}

// Test 4: Log Boundary Conditions
test "log boundary conditions" {
  let provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(provider, "boundary_test_logger")
  
  // Test severity boundary conditions
  let min_severity = Byte::min_value().to_int()
  let max_severity = Byte::max_value().to_int()
  
  let min_log = LogRecord::new(min_severity, "Min severity test")
  let max_log = LogRecord::new(max_severity, "Max severity test")
  
  assert_eq(LogRecord::severity_number(min_log), min_severity)
  assert_eq(LogRecord::severity_number(max_log), max_severity)
  
  // Test message boundary conditions
  let empty_message_log = LogRecord::new(Info, "")
  match LogRecord::body(empty_message_log) {
    Some(body) => assert_eq(body, "")
    None => assert_true(true) // May handle empty body as None
  }
  
  let very_long_message = "a".repeat(100000)
  let long_message_log = LogRecord::new(Info, very_long_message)
  match LogRecord::body(long_message_log) {
    Some(body) => assert_eq(body.length(), 100000)
    None => assert_true(false)
  }
  
  // Test timestamp boundary conditions
  let min_timestamp = -9223372036854775808L // Long min value
  let max_timestamp = 9223372036854775807L  // Long max value
  
  let min_timestamp_log = LogRecord::new_with_context(
    Info,
    Some("Min timestamp test"),
    None,
    Some(min_timestamp),
    None,
    None,
    None,
    None
  )
  
  let max_timestamp_log = LogRecord::new_with_context(
    Info,
    Some("Max timestamp test"),
    None,
    Some(max_timestamp),
    None,
    None,
    None,
    None
  )
  
  assert_eq(LogRecord::timestamp(min_timestamp_log), Some(min_timestamp))
  assert_eq(LogRecord::timestamp(max_timestamp_log), Some(max_timestamp))
  
  // Test trace ID and span ID boundary conditions
  let empty_trace_log = LogRecord::new_with_context(
    Info,
    Some("Empty trace ID test"),
    None,
    None,
    None,
    Some(""),
    Some("valid_span_id"),
    None
  )
  
  let empty_span_log = LogRecord::new_with_context(
    Info,
    Some("Empty span ID test"),
    None,
    None,
    None,
    Some("valid_trace_id"),
    Some(""),
    None
  )
  
  assert_eq(LogRecord::trace_id(empty_trace_log), Some(""))
  assert_eq(LogRecord::span_id(empty_span_log), Some(""))
  
  // Test maximum number of log records
  let max_logs = 10000
  for i in 0..<max_logs {
    let log = LogRecord::new(Info, "Boundary test log " + i.to_string())
    Logger::emit(logger, log)
  }
  
  // Test log with maximum number of attributes
  let max_log_attrs = 1000
  let mut attrs = Attributes::new()
  
  for i in 0..<max_log_attrs {
    Attributes::set(attrs, "log_attr_" + i.to_string(), StringValue("log_value_" + i.to_string()))
  }
  
  let complex_log = LogRecord::new_with_context(
    Error,
    Some("Complex log with many attributes"),
    Some(attrs),
    Some(Clock::monotonic()),
    None,
    None,
    None,
    None
  )
  
  Logger::emit(logger, complex_log)
}

// Test 5: Context Boundary Conditions
test "context boundary conditions" {
  let root_ctx = Context::root()
  
  // Test context key boundary conditions
  let empty_key = ContextKey::new("")
  let ctx_with_empty_key = Context::with_value(root_ctx, empty_key, "empty_key_value")
  
  match Context::get(ctx_with_empty_key, empty_key) {
    Some(value) => assert_eq(value, "empty_key_value")
    None => assert_true(true) // May handle empty key gracefully
  }
  
  let very_long_key = ContextKey::new("a".repeat(1000))
  let ctx_with_long_key = Context::with_value(ctx_with_empty_key, very_long_key, "long_key_value")
  
  match Context::get(ctx_with_long_key, very_long_key) {
    Some(value) => assert_eq(value, "long_key_value")
    None => assert_true(false)
  }
  
  // Test context value boundary conditions
  let empty_value = ""
  let ctx_with_empty_value = Context::with_value(ctx_with_long_key, ContextKey::new("empty_value"), empty_value)
  
  match Context::get(ctx_with_empty_value, ContextKey::new("empty_value")) {
    Some(value) => assert_eq(value, "")
    None => assert_true(true) // May handle empty value gracefully
  }
  
  let very_long_value = "a".repeat(1000000)
  let ctx_with_long_value = Context::with_value(ctx_with_empty_value, ContextKey::new("long_value"), very_long_value)
  
  match Context::get(ctx_with_long_value, ContextKey::new("long_value")) {
    Some(value) => assert_eq(value, very_long_value)
    None => assert_true(false)
  }
  
  // Test maximum context depth
  let mut deep_ctx = root_ctx
  let max_depth = 10000
  
  for i in 0..<max_depth {
    let key = ContextKey::new("depth_" + i.to_string())
    let value = "value_" + i.to_string()
    deep_ctx = Context::with_value(deep_ctx, key, value)
  }
  
  // Verify deep context still works
  let deep_key = ContextKey::new("depth_9999")
  match Context::get(deep_ctx, deep_key) {
    Some(value) => assert_eq(value, "value_9999")
    None => assert_true(false)
  }
  
  // Test context serialization with large data
  let large_serialized = Context::serialize(deep_ctx)
  assert_true(large_serialized.length() > 0)
  
  let deserialized_deep_ctx = Context::deserialize(large_serialized)
  match Context::get(deserialized_deep_ctx, deep_key) {
    Some(value) => assert_eq(value, "value_9999")
    None => assert_true(false)
  }
}

// Test 6: Resource Boundary Conditions
test "resource boundary conditions" {
  let resource = Resource::new()
  
  // Test resource attribute boundary conditions
  let empty_key_attrs = [("", StringValue("empty_key_value"))]
  let resource_with_empty_key = Resource::with_attributes(resource, empty_key_attrs)
  
  // Should handle empty key gracefully
  let empty_key_value = Resource::get_attribute(resource_with_empty_key, "")
  match empty_key_value {
    Some(value) => assert_eq(value, StringValue("empty_key_value"))
    None => assert_true(true) // May handle empty key gracefully
  }
  
  let empty_value_attrs = [("empty_value", StringValue(""))]
  let resource_with_empty_value = Resource::with_attributes(resource_with_empty_key, empty_value_attrs)
  
  let empty_value_result = Resource::get_attribute(resource_with_empty_value, "empty_value")
  match empty_value_result {
    Some(value) => assert_eq(value, StringValue(""))
    None => assert_true(true) // May handle empty value gracefully
  }
  
  // Test very long attribute keys and values
  let long_key = "a".repeat(1000)
  let long_value = StringValue("b".repeat(10000))
  let long_attrs = [(long_key, long_value)]
  
  let resource_with_long_attrs = Resource::with_attributes(resource_with_empty_value, long_attrs)
  let long_attr_result = Resource::get_attribute(resource_with_long_attrs, long_key)
  
  match long_attr_result {
    Some(value) => assert_eq(value, long_value)
    None => assert_true(false)
  }
  
  // Test maximum number of resource attributes
  let max_resource_attrs = 1000
  let many_attrs = []
  
  for i in 0..<max_resource_attrs {
    many_attrs.push(("resource_attr_" + i.to_string(), StringValue("resource_value_" + i.to_string())))
  }
  
  let resource_with_many_attrs = Resource::with_attributes(resource_with_long_attrs, many_attrs)
  
  // Verify some attributes exist
  let first_attr = Resource::get_attribute(resource_with_many_attrs, "resource_attr_0")
  match first_attr {
    Some(value) => assert_eq(value, StringValue("resource_value_0"))
    None => assert_true(false)
  }
  
  let last_attr = Resource::get_attribute(resource_with_many_attrs, "resource_attr_999")
  match last_attr {
    Some(value) => assert_eq(value, StringValue("resource_value_999"))
    None => assert_true(true) // May hit limits
  }
  
  // Test resource merging with many attributes
  let override_attrs = []
  for i in 0..<max_resource_attrs {
    override_attrs.push(("override_attr_" + i.to_string(), StringValue("override_value_" + i.to_string())))
  }
  
  let override_resource = Resource::with_attributes(Resource::new(), override_attrs)
  let merged_resource = Resource::merge(resource_with_many_attrs, override_resource)
  
  // Verify merged resource contains both sets of attributes
  let merged_original = Resource::get_attribute(merged_resource, "resource_attr_0")
  match merged_original {
    Some(value) => assert_eq(value, StringValue("resource_value_0"))
    None => assert_true(false)
  }
  
  let merged_override = Resource::get_attribute(merged_resource, "override_attr_0")
  match merged_override {
    Some(value) => assert_eq(value, StringValue("override_value_0"))
    None => assert_true(false)
  }
}

// Test 7: HTTP Client Boundary Conditions
test "http client boundary conditions" {
  // Test HTTP method boundary conditions
  let empty_method_request = HttpRequest::new("", "https://example.com", [], None)
  assert_eq(HttpRequest::http_method(empty_method_request), "")
  
  let very_long_method = "a".repeat(1000)
  let long_method_request = HttpRequest::new(very_long_method, "https://example.com", [], None)
  assert_eq(HttpRequest::http_method(long_method_request), very_long_method)
  
  // Test URL boundary conditions
  let empty_url_request = HttpRequest::new("GET", "", [], None)
  assert_eq(HttpRequest::url(empty_url_request), "")
  
  let very_long_url = "https://example.com/" + "a".repeat(10000)
  let long_url_request = HttpRequest::new("GET", very_long_url, [], None)
  assert_eq(HttpRequest::url(long_url_request), very_long_url)
  
  // Test header boundary conditions
  let empty_header_name = ("", "empty_header_value")
  let empty_header_value = ("empty_header_name", "")
  let very_long_header_name = ("a".repeat(1000), "header_value")
  let very_long_header_value = ("header_name", "b".repeat(10000))
  
  let boundary_headers = [
    empty_header_name,
    empty_header_value,
    very_long_header_name,
    very_long_header_value
  ]
  
  let boundary_headers_request = HttpRequest::new("GET", "https://example.com", boundary_headers, None)
  
  // Test body boundary conditions
  let empty_body_request = HttpRequest::new("POST", "https://example.com", [], Some(""))
  match HttpRequest::body(empty_body_request) {
    Some(body) => assert_eq(body, "")
    None => assert_true(true) // May handle empty body as None
  }
  
  let very_large_body = "a".repeat(10000000) // 10MB
  let large_body_request = HttpRequest::new("POST", "https://example.com", [], Some(very_large_body))
  match HttpRequest::body(large_body_request) {
    Some(body) => assert_eq(body.length(), 10000000)
    None => assert_true(false)
  }
  
  // Test response status code boundary conditions
  let min_status_response = HttpResponse::new(-999, [], None)
  let max_status_response = HttpResponse::new(999, [], None)
  
  assert_eq(HttpResponse::status_code(min_status_response), -999)
  assert_eq(HttpResponse::status_code(max_status_response), 999)
  
  // Test response header boundary conditions
  let boundary_response_headers = [
    empty_header_name,
    empty_header_value,
    very_long_header_name,
    very_long_header_value
  ]
  
  let boundary_headers_response = HttpResponse::new(200, boundary_response_headers, None)
  
  // Test response body boundary conditions
  let empty_body_response = HttpResponse::new(200, [], Some(""))
  match HttpResponse::body(empty_body_response) {
    Some(body) => assert_eq(body, "")
    None => assert_true(true) // May handle empty body as None
  }
  
  let large_body_response = HttpResponse::new(200, [], Some(very_large_body))
  match HttpResponse::body(large_body_response) {
    Some(body) => assert_eq(body.length(), 10000000)
    None => assert_true(false)
  }
}

// Test 8: Baggage Boundary Conditions
test "baggage boundary conditions" {
  let baggage = Baggage::new()
  
  // Test baggage entry boundary conditions
  let empty_key_baggage = Baggage::set_entry(baggage, "", "empty_key_value")
  let empty_key_result = Baggage::get_entry(empty_key_baggage, "")
  match empty_key_result {
    Some(value) => assert_eq(value, "empty_key_value")
    None => assert_true(true) // May handle empty key gracefully
  }
  
  let empty_value_baggage = Baggage::set_entry(empty_key_baggage, "empty_value", "")
  let empty_value_result = Baggage::get_entry(empty_value_baggage, "empty_value")
  match empty_value_result {
    Some(value) => assert_eq(value, "")
    None => assert_true(true) // May handle empty value gracefully
  }
  
  // Test very long baggage keys and values
  let very_long_key = "a".repeat(1000)
  let very_long_value = "b".repeat(10000)
  
  let long_key_baggage = Baggage::set_entry(empty_value_baggage, very_long_key, very_long_value)
  let long_key_result = Baggage::get_entry(long_key_baggage, very_long_key)
  
  match long_key_result {
    Some(value) => assert_eq(value, very_long_value)
    None => assert_true(false)
  }
  
  // Test maximum number of baggage entries
  let max_baggage_entries = 1000
  let mut current_baggage = long_key_baggage
  
  for i in 0..<max_baggage_entries {
    let key = "baggage_entry_" + i.to_string()
    let value = "baggage_value_" + i.to_string()
    current_baggage = Baggage::set_entry(current_baggage, key, value)
  }
  
  // Verify some entries exist
  let first_entry = Baggage::get_entry(current_baggage, "baggage_entry_0")
  match first_entry {
    Some(value) => assert_eq(value, "baggage_value_0")
    None => assert_true(false)
  }
  
  let middle_entry = Baggage::get_entry(current_baggage, "baggage_entry_500")
  match middle_entry {
    Some(value) => assert_eq(value, "baggage_value_500")
    None => assert_true(true) // May hit limits
  }
  
  // Test baggage removal boundary conditions
  let non_existent_removal = Baggage::remove_entry(current_baggage, "non_existent_key")
  // Should handle gracefully without error
  
  let empty_key_removal = Baggage::remove_entry(current_baggage, "")
  // Should handle gracefully without error
  
  // Test baggage with special characters and Unicode
  let special_key = "special.key.with@chars#and$symbols"
  let unicode_value = "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ ðŸš€ Ð¢ÐµÑÑ‚ Ñ€ÑƒÑÑÐºÐ¸Ð¹ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© æ—¥æœ¬èªž í•œêµ­ì–´"
  
  let special_baggage = Baggage::set_entry(current_baggage, special_key, unicode_value)
  let special_result = Baggage::get_entry(special_baggage, special_key)
  
  match special_result {
    Some(value) => assert_eq(value, unicode_value)
    None => assert_true(false)
  }
}