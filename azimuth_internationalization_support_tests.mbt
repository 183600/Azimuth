// Azimuth Internationalization Support Tests
// This file contains high-quality test cases for internationalization support

// Test 1: Multi-language Attribute Value Handling
test "multi-language attribute value handling" {
  let attrs = Attributes::new()
  
  // Test case 1: Chinese characters
  let chinese_text = "é¥æµ‹ç³»ç»Ÿæµ‹è¯•æ•°æ®"
  Attributes::set(attrs, "chinese_message", StringValue(chinese_text))
  
  let retrieved_chinese = Attributes::get(attrs, "chinese_message")
  match retrieved_chinese {
    Some(StringValue(value)) => {
      assert_eq(value, chinese_text)
      assert_eq(value.length(), 7) // 7 Chinese characters
    }
    _ => assert_true(false)
  }
  
  // Test case 2: Japanese characters
  let japanese_text = "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ"
  Attributes::set(attrs, "japanese_message", StringValue(japanese_text))
  
  let retrieved_japanese = Attributes::get(attrs, "japanese_message")
  match retrieved_japanese {
    Some(StringValue(value)) => {
      assert_eq(value, japanese_text)
      assert_eq(value.length(), 12) // 12 Japanese characters
    }
    _ => assert_true(false)
  }
  
  // Test case 3: Arabic characters
  let arabic_text = "Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  Attributes::set(attrs, "arabic_message", StringValue(arabic_text))
  
  let retrieved_arabic = Attributes::get(attrs, "arabic_message")
  match retrieved_arabic {
    Some(StringValue(value)) => {
      assert_eq(value, arabic_text)
      assert_eq(value.length(), 20) // 20 Arabic characters
    }
    _ => assert_true(false)
  }
  
  // Test case 4: Russian characters
  let russian_text = "Ğ¢ĞµÑÑ‚ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ğ¸"
  Attributes::set(attrs, "russian_message", StringValue(russian_text))
  
  let retrieved_russian = Attributes::get(attrs, "russian_message")
  match retrieved_russian {
    Some(StringValue(value)) => {
      assert_eq(value, russian_text)
      assert_eq(value.length(), 18) // 18 Russian characters
    }
    _ => assert_true(false)
  }
  
  // Test case 5: Emoji and special characters
  let emoji_text = "ğŸ” ğŸ“Š ğŸ“ˆ ğŸ“‰ ğŸŒ ğŸš€"
  Attributes::set(attrs, "emoji_message", StringValue(emoji_text))
  
  let retrieved_emoji = Attributes::get(attrs, "emoji_message")
  match retrieved_emoji {
    Some(StringValue(value)) => {
      assert_eq(value, emoji_text)
      assert_eq(value.length(), 11) // 11 characters (including spaces and emojis)
    }
    _ => assert_true(false)
  }
  
  // Test case 6: Mixed language text
  let mixed_text = "English + ä¸­æ–‡ + æ—¥æœ¬èª + Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© + Ğ ÑƒÑÑĞºĞ¸Ğ¹"
  Attributes::set(attrs, "mixed_language_message", StringValue(mixed_text))
  
  let retrieved_mixed = Attributes::get(attrs, "mixed_language_message")
  match retrieved_mixed {
    Some(StringValue(value)) => {
      assert_eq(value, mixed_text)
      assert_true(value.length() > 30)
    }
    _ => assert_true(false)
  }
}

// Test 2: Localized Error Messages
test "localized error messages" {
  // Test error messages in different locales
  
  // Test case 1: English error messages
  let english_locale = Locale::new("en-US")
  let english_error = ErrorMessage::new("validation_failed", "Input validation failed", english_locale)
  
  assert_eq(ErrorMessage::code(english_error), "validation_failed")
  assert_eq(ErrorMessage::message(english_error), "Input validation failed")
  assert_eq(ErrorMessage::locale(english_error), "en-US")
  
  // Test case 2: Chinese error messages
  let chinese_locale = Locale::new("zh-CN")
  let chinese_error = ErrorMessage::new("validation_failed", "è¾“å…¥éªŒè¯å¤±è´¥", chinese_locale)
  
  assert_eq(ErrorMessage::code(chinese_error), "validation_failed")
  assert_eq(ErrorMessage::message(chinese_error), "è¾“å…¥éªŒè¯å¤±è´¥")
  assert_eq(ErrorMessage::locale(chinese_error), "zh-CN")
  
  // Test case 3: Japanese error messages
  let japanese_locale = Locale::new("ja-JP")
  let japanese_error = ErrorMessage::new("validation_failed", "å…¥åŠ›æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ", japanese_locale)
  
  assert_eq(ErrorMessage::code(japanese_error), "validation_failed")
  assert_eq(ErrorMessage::message(japanese_error), "å…¥åŠ›æ¤œè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ")
  assert_eq(ErrorMessage::locale(japanese_error), "ja-JP")
  
  // Test case 4: Arabic error messages
  let arabic_locale = Locale::new("ar-SA")
  let arabic_error = ErrorMessage::new("validation_failed", "ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„", arabic_locale)
  
  assert_eq(ErrorMessage::code(arabic_error), "validation_failed")
  assert_eq(ErrorMessage::message(arabic_error), "ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„")
  assert_eq(ErrorMessage::locale(arabic_error), "ar-SA")
  
  // Test case 5: Error message with parameters
  let localized_error = LocalizedError::new("invalid_range", english_locale)
  LocalizedError::add_parameter(localized_error, "min", 0)
  LocalizedError::add_parameter(localized_error, "max", 100)
  LocalizedError::add_parameter(localized_error, "value", 150)
  
  let formatted_message = LocalizedError::format_message(localized_error)
  assert_eq(formatted_message, "Value 150 is outside valid range [0, 100]")
  
  // Test case 6: Same error code in different locales
  let error_codes = ["validation_failed", "connection_timeout", "resource_exhausted"]
  let locales = ["en-US", "zh-CN", "ja-JP", "ar-SA", "ru-RU"]
  
  for error_code in error_codes {
    for locale_str in locales {
      let locale = Locale::new(locale_str)
      let error = ErrorMessage::new(error_code, "", locale)
      
      // Should be able to format message for each locale
      let formatted = ErrorMessage::format(error)
      assert_true(formatted.length() > 0)
      assert_eq(ErrorMessage::code(error), error_code)
      assert_eq(ErrorMessage::locale(error), locale_str)
    }
  }
}

// Test 3: Localized Log Messages
test "localized log messages" {
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "internationalization_test_logger")
  
  // Test case 1: English log messages
  let english_locale = Locale::new("en-US")
  let english_log = LogRecord::new_with_locale(
    Info,
    "Processing completed successfully",
    english_locale,
    Some(Attributes::with([
      ("operation", StringValue("data_processing")),
      ("duration_ms", IntValue(1234))
    ]))
  )
  
  assert_eq(LogRecord::severity_number(english_log), Info)
  assert_eq(LogRecord::locale(english_log), "en-US")
  
  // Test case 2: Chinese log messages
  let chinese_locale = Locale::new("zh-CN")
  let chinese_log = LogRecord::new_with_locale(
    Warning,
    "å¤„ç†è¿‡ç¨‹ä¸­å‡ºç°è­¦å‘Š",
    chinese_locale,
    Some(Attributes::with([
      ("operation", StringValue("æ•°æ®å¤„ç†")),
      ("duration_ms", IntValue(1234))
    ]))
  )
  
  assert_eq(LogRecord::severity_number(chinese_log), Warning)
  assert_eq(LogRecord::locale(chinese_log), "zh-CN")
  
  // Test case 3: Japanese log messages
  let japanese_locale = Locale::new("ja-JP")
  let japanese_log = LogRecord::new_with_locale(
    Error,
    "å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ",
    japanese_locale,
    Some(Attributes::with([
      ("operation", StringValue("ãƒ‡ãƒ¼ã‚¿å‡¦ç†")),
      ("duration_ms", IntValue(1234))
    ]))
  )
  
  assert_eq(LogRecord::severity_number(japanese_log), Error)
  assert_eq(LogRecord::locale(japanese_log), "ja-JP")
  
  // Test case 4: Emit localized log messages
  Logger::emit(logger, english_log)
  Logger::emit(logger, chinese_log)
  Logger::emit(logger, japanese_log)
  
  // Test case 5: Localized log templates with parameters
  let log_template = LogTemplate::new("operation_completed", english_locale)
  LogTemplate::add_parameter(log_template, "operation", "data_processing")
  LogTemplate::add_parameter(log_template, "duration", 1234)
  
  let formatted_log = LogTemplate::format(log_template)
  assert_eq(formatted_log, "Operation 'data_processing' completed in 1234ms")
  
  // Test case 6: Same template in different locales
  let locales = ["en-US", "zh-CN", "ja-JP", "ar-SA"]
  
  for locale_str in locales {
    let locale = Locale::new(locale_str)
    let localized_template = LogTemplate::new("operation_completed", locale)
    LogTemplate::add_parameter(localized_template, "operation", "data_processing")
    LogTemplate::add_parameter(localized_template, "duration", 1234)
    
    let formatted = LogTemplate::format(localized_template)
    assert_true(formatted.length() > 0)
    assert_true(String::contains(formatted, "data_processing"))
    assert_true(String::contains(formatted, "1234"))
  }
}

// Test 4: Number and Date Formatting by Locale
test "number and date formatting by locale" {
  let test_number = 1234.5678
  let test_timestamp = 1640995200L // 2022-01-01 00:00:00 UTC
  
  // Test case 1: Number formatting in different locales
  let locales = ["en-US", "zh-CN", "ja-JP", "ar-SA", "de-DE", "fr-FR"]
  
  for locale_str in locales {
    let locale = Locale::new(locale_str)
    
    // Format number
    let formatted_number = Locale::format_number(locale, test_number, 2)
    assert_true(formatted_number.length() > 0)
    
    // Format currency
    let formatted_currency = Locale::format_currency(locale, test_number, "USD")
    assert_true(formatted_currency.length() > 0)
    
    // Format percentage
    let formatted_percentage = Locale::format_percentage(locale, test_number / 10000.0)
    assert_true(formatted_percentage.length() > 0)
  }
  
  // Test case 2: Date and time formatting in different locales
  for locale_str in locales {
    let locale = Locale::new(locale_str)
    
    // Format date
    let formatted_date = Locale::format_date(locale, test_timestamp)
    assert_true(formatted_date.length() > 0)
    
    // Format time
    let formatted_time = Locale::format_time(locale, test_timestamp)
    assert_true(formatted_time.length() > 0)
    
    // Format date and time
    let formatted_datetime = Locale::format_datetime(locale, test_timestamp)
    assert_true(formatted_datetime.length() > 0)
  }
  
  // Test case 3: Verify specific locale formats
  let us_locale = Locale::new("en-US")
  let us_number = Locale::format_number(us_locale, test_number, 2)
  assert_eq(us_number, "1,234.57")
  
  let german_locale = Locale::new("de-DE")
  let german_number = Locale::format_number(german_locale, test_number, 2)
  assert_eq(german_number, "1.234,57")
  
  let french_locale = Locale::new("fr-FR")
  let french_number = Locale::format_number(french_locale, test_number, 2)
  assert_eq(french_number, "1 234,57")
  
  // Test case 4: Relative time formatting
  let now = Time::now()
  let past = now - 3600 // 1 hour ago
  let future = now + 7200 // 2 hours from now
  
  for locale_str in locales {
    let locale = Locale::new(locale_str)
    
    let past_relative = Locale::format_relative_time(locale, past, now)
    assert_true(past_relative.length() > 0)
    
    let future_relative = Locale::format_relative_time(locale, future, now)
    assert_true(future_relative.length() > 0)
  }
}

// Test 5: Right-to-Left Language Support
test "right-to-left language support" {
  // Test case 1: Arabic text handling
  let arabic_text = "Ø§Ø®ØªØ¨Ø§Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  let arabic_locale = Locale::new("ar-SA")
  
  // Test text direction detection
  assert_eq(Locale::text_direction(arabic_locale), "rtl")
  
  // Test case 2: Hebrew text handling
  let hebrew_text = "×‘×“×™×§×ª ××¢×¨×›×ª ×˜×œ××˜×¨×™×”"
  let hebrew_locale = Locale::new("he-IL")
  
  assert_eq(Locale::text_direction(hebrew_locale), "rtl")
  
  // Test case 3: Mixed LTR/RTL text
  let mixed_text = "English + Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© + English"
  let mixed_locale = Locale::new("ar-SA")
  
  let formatted_mixed = Locale::format_text(mixed_locale, mixed_text)
  assert_true(formatted_mixed.length() > 0)
  
  // Test case 4: RTL log messages
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "rtl_test_logger")
  
  let rtl_log = LogRecord::new_with_locale(
    Info,
    "ØªÙ…Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­",
    arabic_locale,
    Some(Attributes::with([
      ("operation", StringValue("Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")),
      ("duration_ms", IntValue(1234))
    ]))
  )
  
  assert_eq(LogRecord::locale(rtl_log), "ar-SA")
  Logger::emit(logger, rtl_log)
  
  // Test case 5: RTL error messages
  let rtl_error = ErrorMessage::new(
    "validation_failed",
    "ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„",
    arabic_locale
  )
  
  assert_eq(ErrorMessage::locale(rtl_error), "ar-SA")
  assert_eq(ErrorMessage::message(rtl_error), "ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„")
  
  // Test case 6: RTL span names and events
  let span_ctx = SpanContext::new("trace_123", "span_456", true, "test_state")
  let span = Span::new("Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø·Ø§Ù‚", Internal, span_ctx)
  
  assert_eq(Span::name(span), "Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø·Ø§Ù‚")
  
  let rtl_attrs = Attributes::with([
    ("message", StringValue("Ø±Ø³Ø§Ù„Ø© Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")),
    ("direction", StringValue("rtl"))
  ])
  
  Span::add_event(span, "Ø­Ø¯Ø« Ø§Ø®ØªØ¨Ø§Ø±", Some(rtl_attrs))
  Span::end(span)
}