// Azimuth å›½é™…åŒ–æ”¯æŒæµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºé¥æµ‹ç³»ç»Ÿåœ¨ä¸åŒè¯­è¨€ã€åœ°åŒºå’Œæ–‡åŒ–ç¯å¢ƒä¸‹çš„å›½é™…åŒ–æ”¯æŒ

// æµ‹è¯•1: å¤šè¯­è¨€æ¶ˆæ¯å’Œæ ‡ç­¾æ”¯æŒ
test "å¤šè¯­è¨€æ¶ˆæ¯å’Œæ ‡ç­¾æ”¯æŒæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.i18n")
  
  // åˆ›å»ºå›½é™…åŒ–ç®¡ç†å™¨
  let i18n_manager = I18nManager::new(meter)
  
  // åˆ›å»ºå›½é™…åŒ–æŒ‡æ ‡
  let i18n_counter = Meter::create_counter(meter, "i18n.translations")
  let locale_gauge = Meter::create_gauge(meter, "supported.locales.count")
  let coverage_gauge = Meter::create_gauge(meter, "translation.coverage.percentage")
  
  // é…ç½®æ”¯æŒçš„è¯­è¨€ç¯å¢ƒ
  let supported_locales = [
    Locale::new("en-US", "English (United States)", [
      ("telemetry.metrics.cpu", "CPU Usage"),
      ("telemetry.metrics.memory", "Memory Usage"),
      ("telemetry.metrics.disk", "Disk Usage"),
      ("telemetry.alerts.high", "High Usage Alert"),
      ("telemetry.alerts.critical", "Critical Usage Alert"),
      ("telemetry.status.healthy", "Healthy"),
      ("telemetry.status.warning", "Warning"),
      ("telemetry.status.error", "Error")
    ]),
    Locale::new("zh-CN", "ä¸­æ–‡ (ç®€ä½“)", [
      ("telemetry.metrics.cpu", "CPU ä½¿ç”¨ç‡"),
      ("telemetry.metrics.memory", "å†…å­˜ä½¿ç”¨ç‡"),
      ("telemetry.metrics.disk", "ç£ç›˜ä½¿ç”¨ç‡"),
      ("telemetry.alerts.high", "é«˜ä½¿ç”¨ç‡å‘Šè­¦"),
      ("telemetry.alerts.critical", "ä¸¥é‡ä½¿ç”¨ç‡å‘Šè­¦"),
      ("telemetry.status.healthy", "å¥åº·"),
      ("telemetry.status.warning", "è­¦å‘Š"),
      ("telemetry.status.error", "é”™è¯¯")
    ]),
    Locale::new("ja-JP", "æ—¥æœ¬èª", [
      ("telemetry.metrics.cpu", "CPUä½¿ç”¨ç‡"),
      ("telemetry.metrics.memory", "ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡"),
      ("telemetry.metrics.disk", "ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡"),
      ("telemetry.alerts.high", "é«˜ä½¿ç”¨ç‡ã‚¢ãƒ©ãƒ¼ãƒˆ"),
      ("telemetry.alerts.critical", "é‡å¤§ä½¿ç”¨ç‡ã‚¢ãƒ©ãƒ¼ãƒˆ"),
      ("telemetry.status.healthy", "æ­£å¸¸"),
      ("telemetry.status.warning", "è­¦å‘Š"),
      ("telemetry.status.error", "ã‚¨ãƒ©ãƒ¼")
    ]),
    Locale::new("es-ES", "EspaÃ±ol (EspaÃ±a)", [
      ("telemetry.metrics.cpu", "Uso de CPU"),
      ("telemetry.metrics.memory", "Uso de Memoria"),
      ("telemetry.metrics.disk", "Uso de Disco"),
      ("telemetry.alerts.high", "Alerta de Uso Alto"),
      ("telemetry.alerts.critical", "Alerta de Uso CrÃ­tico"),
      ("telemetry.status.healthy", "Saludable"),
      ("telemetry.status.warning", "Advertencia"),
      ("telemetry.status.error", "Error")
    ]),
    Locale::new("fr-FR", "FranÃ§ais (France)", [
      ("telemetry.metrics.cpu", "Utilisation CPU"),
      ("telemetry.metrics.memory", "Utilisation MÃ©moire"),
      ("telemetry.metrics.disk", "Utilisation Disque"),
      ("telemetry.alerts.high", "Alerte d'Utilisation Ã‰levÃ©e"),
      ("telemetry.alerts.critical", "Alerte d'Utilisation Critique"),
      ("telemetry.status.healthy", "Sain"),
      ("telemetry.status.warning", "Avertissement"),
      ("telemetry.status.error", "Erreur")
    ])
  ]
  
  // æ³¨å†Œè¯­è¨€ç¯å¢ƒ
  for locale in supported_locales {
    I18nManager::register_locale(i18n_manager, locale)
    Counter::add(i18n_counter, 1.0)
  }
  
  Gauge::set(locale_gauge, supported_locales.length().to_float())
  
  // æµ‹è¯•å¤šè¯­è¨€ç¿»è¯‘
  let test_keys = [
    "telemetry.metrics.cpu",
    "telemetry.metrics.memory", 
    "telemetry.alerts.high",
    "telemetry.status.healthy"
  ]
  
  let mut total_translations = 0
  let mut successful_translations = 0
  
  for locale in supported_locales {
    for key in test_keys {
      total_translations = total_translations + 1
      
      let translation = I18nManager::translate(i18n_manager, Locale::code(locale), key)
      match translation {
        Some(translated_text) => {
          assert_true(translated_text.length() > 0)
          successful_translations = successful_translations + 1
        }
        None => assert_true(false)
      }
    }
  }
  
  // è®¡ç®—ç¿»è¯‘è¦†ç›–ç‡
  let translation_coverage = (successful_translations.to_float() / total_translations.to_float()) * 100.0
  Gauge::set(coverage_gauge, translation_coverage)
  
  // éªŒè¯å¤šè¯­è¨€æ”¯æŒ
  assert_eq(successful_translations, total_translations)
  assert_eq(translation_coverage, 100.0)
  assert_eq(Counter::value(i18n_counter), 5.0)
  assert_eq(Gauge::value(locale_gauge), 5.0)
}

// æµ‹è¯•2: æœ¬åœ°åŒ–æ•°å­—å’Œæ—¥æœŸæ ¼å¼
test "æœ¬åœ°åŒ–æ•°å­—å’Œæ—¥æœŸæ ¼å¼æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.l10n")
  
  // åˆ›å»ºæœ¬åœ°åŒ–ç®¡ç†å™¨
  let l10n_manager = L10nManager::new(meter)
  
  // åˆ›å»ºæœ¬åœ°åŒ–æŒ‡æ ‡
  let format_counter = Meter::create_counter(meter, "l10n.formats.applied")
  let precision_gauge = Meter::create_gauge(meter, "format.precision.score")
  
  // é…ç½®æœ¬åœ°åŒ–æ ¼å¼
  let locale_formats = [
    ("en-US", LocaleFormat::new(
      ".", // å°æ•°ç‚¹
      ",", // åƒä½åˆ†éš”ç¬¦
      "MM/dd/yyyy", // æ—¥æœŸæ ¼å¼
      "h:mm:ss a", // æ—¶é—´æ ¼å¼
      "USD", // è´§å¸
      "left" // è´§å¸ç¬¦å·ä½ç½®
    )),
    ("zh-CN", LocaleFormat::new(
      ".", // å°æ•°ç‚¹
      ",", // åƒä½åˆ†éš”ç¬¦
      "yyyy-MM-dd", // æ—¥æœŸæ ¼å¼
      "HH:mm:ss", // æ—¶é—´æ ¼å¼
      "CNY", // è´§å¸
      "left" // è´§å¸ç¬¦å·ä½ç½®
    )),
    ("de-DE", LocaleFormat::new(
      ",", // å°æ•°ç‚¹
      ".", // åƒä½åˆ†éš”ç¬¦
      "dd.MM.yyyy", // æ—¥æœŸæ ¼å¼
      "HH:mm:ss", // æ—¶é—´æ ¼å¼
      "EUR", // è´§å¸
      "right" // è´§å¸ç¬¦å·ä½ç½®
    )),
    ("fr-FR", LocaleFormat::new(
      ",", // å°æ•°ç‚¹
      " ", // åƒä½åˆ†éš”ç¬¦
      "dd/MM/yyyy", // æ—¥æœŸæ ¼å¼
      "HH:mm:ss", // æ—¶é—´æ ¼å¼
      "EUR", // è´§å¸
      "right" // è´§å¸ç¬¦å·ä½ç½®
    )),
    ("ja-JP", LocaleFormat::new(
      ".", // å°æ•°ç‚¹
      ",", // åƒä½åˆ†éš”ç¬¦
      "yyyy/MM/dd", // æ—¥æœŸæ ¼å¼
      "HH:mm:ss", // æ—¶é—´æ ¼å¼
      "JPY", // è´§å¸
      "left" // è´§å¸ç¬¦å·ä½ç½®
    ))
  ]
  
  // æ³¨å†Œæœ¬åœ°åŒ–æ ¼å¼
  for (locale_code, format) in locale_formats {
    L10nManager::register_format(l10n_manager, locale_code, format)
  }
  
  // æµ‹è¯•æ•°å­—æ ¼å¼åŒ–
  let test_numbers = [
    1234.567,
    9876543.21,
    0.12345,
    1000000.0
  ]
  
  // æµ‹è¯•æ—¥æœŸæ ¼å¼åŒ–
  let test_timestamp = Time::new(2023, 12, 25, 14, 30, 45)
  
  // æµ‹è¯•è´§å¸æ ¼å¼åŒ–
  let test_currencies = [
    (1234.56, "USD"),
    (5678.90, "CNY"),
    (9876.54, "EUR"),
    (12345.67, "JPY")
  ]
  
  // æ‰§è¡Œæœ¬åœ°åŒ–æ ¼å¼åŒ–
  for (locale_code, _) in locale_formats {
    // æ ¼å¼åŒ–æ•°å­—
    for number in test_numbers {
      let formatted_number = L10nManager::format_number(l10n_manager, locale_code, number)
      assert_true(formatted_number.length() > 0)
      Counter::add(format_counter, 1.0)
    }
    
    // æ ¼å¼åŒ–æ—¥æœŸ
    let formatted_date = L10nManager::format_date(l10n_manager, locale_code, test_timestamp)
    assert_true(formatted_date.length() > 0)
    Counter::add(format_counter, 1.0)
    
    // æ ¼å¼åŒ–æ—¶é—´
    let formatted_time = L10nManager::format_time(l10n_manager, locale_code, test_timestamp)
    assert_true(formatted_time.length() > 0)
    Counter::add(format_counter, 1.0)
    
    // æ ¼å¼åŒ–è´§å¸
    for (amount, currency) in test_currencies {
      let formatted_currency = L10nManager::format_currency(l10n_manager, locale_code, amount, currency)
      assert_true(formatted_currency.length() > 0)
      Counter::add(format_counter, 1.0)
    }
  }
  
  // è®¡ç®—æ ¼å¼åŒ–ç²¾åº¦åˆ†æ•°
  let precision_score = L10nManager::calculate_formatting_precision(l10n_manager)
  Gauge::set(precision_gauge, precision_score)
  
  // éªŒè¯æœ¬åœ°åŒ–æ ¼å¼
  assert_true(precision_score > 0.9) // æ ¼å¼åŒ–ç²¾åº¦åº”è¯¥å¤§äº90%
  assert_eq(Counter::value(format_counter), 45.0) // 5ä¸ªè¯­è¨€ç¯å¢ƒ Ã— (4ä¸ªæ•°å­— + 1ä¸ªæ—¥æœŸ + 1ä¸ªæ—¶é—´ + 4ä¸ªè´§å¸)
}

// æµ‹è¯•3: æ—¶åŒºå¤„ç†å’Œè½¬æ¢
test "æ—¶åŒºå¤„ç†å’Œè½¬æ¢æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.timezone")
  
  // åˆ›å»ºæ—¶åŒºç®¡ç†å™¨
  let timezone_manager = TimezoneManager::new(meter)
  
  // åˆ›å»ºæ—¶åŒºæŒ‡æ ‡
  let timezone_counter = Meter::create_counter(meter, "timezone.conversions")
  let accuracy_gauge = Meter::create_gauge(meter, "timezone.conversion.accuracy")
  
  // é…ç½®æ”¯æŒçš„æ—¶åŒº
  let supported_timezones = [
    ("UTC", 0),
    ("America/New_York", -5), // EST (ç®€åŒ–)
    ("America/Los_Angeles", -8), // PST (ç®€åŒ–)
    ("Europe/London", 0), // GMT
    ("Europe/Paris", 1), // CET (ç®€åŒ–)
    ("Asia/Shanghai", 8), // CST (ç®€åŒ–)
    ("Asia/Tokyo", 9), // JST (ç®€åŒ–)
    ("Australia/Sydney", 10) // AEST (ç®€åŒ–)
  ]
  
  // æ³¨å†Œæ—¶åŒº
  for (timezone_name, offset) in supported_timezones {
    TimezoneManager::register_timezone(timezone_manager, timezone_name, offset)
  }
  
  // æµ‹è¯•æ—¶åŒºè½¬æ¢
  let base_time = Time::new(2023, 12, 25, 12, 0, 0) // UTCä¸­åˆ12ç‚¹
  
  let timezone_conversions = [
    ("UTC", "America/New_York"),
    ("UTC", "America/Los_Angeles"),
    ("UTC", "Europe/Paris"),
    ("UTC", "Asia/Shanghai"),
    ("UTC", "Asia/Tokyo"),
    ("America/New_York", "UTC"),
    ("Asia/Shanghai", "America/Los_Angeles"),
    ("Europe/Paris", "Asia/Tokyo")
  ]
  
  let mut successful_conversions = 0
  
  for (from_timezone, to_timezone) in timezone_conversions {
    let converted_time = TimezoneManager::convert_time(timezone_manager, base_time, from_timezone, to_timezone)
    
    match converted_time {
      Some(time) => {
        assert_true(time.is_valid())
        successful_conversions = successful_conversions + 1
      }
      None => assert_true(false)
    }
    
    Counter::add(timezone_counter, 1.0)
  }
  
  // æµ‹è¯•å¤ä»¤æ—¶å¤„ç†ï¼ˆç®€åŒ–ï¼‰
  let dst_dates = [
    Time::new(2023, 6, 25, 12, 0, 0), // å¤å­£
    Time::new(2023, 12, 25, 12, 0, 0)  // å†¬å­£
  ]
  
  for date in dst_dates {
    let dst_aware_time = TimezoneManager::convert_with_dst(timezone_manager, date, "UTC", "America/New_York")
    match dst_aware_time {
      Some(time) => {
        assert_true(time.is_valid())
        successful_conversions = successful_conversions + 1
      }
      None => assert_true(false)
    }
    
    Counter::add(timezone_counter, 1.0)
  }
  
  // è®¡ç®—æ—¶åŒºè½¬æ¢å‡†ç¡®ç‡
  let conversion_accuracy = (successful_conversions.to_float() / timezone_conversions.length().to_float()) * 100.0
  Gauge::set(accuracy_gauge, conversion_accuracy)
  
  // éªŒè¯æ—¶åŒºå¤„ç†
  assert_eq(successful_conversions, timezone_conversions.length() + dst_dates.length())
  assert_eq(conversion_accuracy, 100.0)
  assert_eq(Counter::value(timezone_counter), 10.0)
}

// æµ‹è¯•4: æ–‡åŒ–ç‰¹å®šçš„æ’åºå’Œæ¯”è¾ƒ
test "æ–‡åŒ–ç‰¹å®šçš„æ’åºå’Œæ¯”è¾ƒæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.collation")
  
  // åˆ›å»ºæ’åºç®¡ç†å™¨
  let collation_manager = CollationManager::new(meter)
  
  // åˆ›å»ºæ’åºæŒ‡æ ‡
  let collation_counter = Meter::create_counter(meter, "collation.operations")
  let consistency_gauge = Meter::create_gauge(meter, "collation.consistency.score")
  
  // é…ç½®æ–‡åŒ–ç‰¹å®šçš„æ’åºè§„åˆ™
  let collation_rules = [
    ("en-US", CollationRule::new([
      ("case.sensitive", BoolValue(false)),
      ("ignore.accents", BoolValue(false)),
      ("numeric.ordering", BoolValue(true))
    ])),
    ("zh-CN", CollationRule::new([
      ("case.sensitive", BoolValue(false)),
      ("pinyin.ordering", BoolValue(true)),
      ("stroke.order", BoolValue(false))
    ])),
    ("ja-JP", CollationRule::new([
      ("case.sensitive", BoolValue(false)),
      ("hiragana.order", BoolValue(true)),
      ("katakana.order", BoolValue(true))
    ])),
    ("de-DE", CollationRule::new([
      ("case.sensitive", BoolValue(false)),
      ("phonebook.order", BoolValue(true)),
      ("dictionary.order", BoolValue(false))
    ])),
    ("sv-SE", CollationRule::new([
      ("case.sensitive", BoolValue(false)),
      ("v.w.rule", BoolValue(true),
      ("aa.Ã¥.rule", BoolValue(true))
    ]))
  ]
  
  // æ³¨å†Œæ’åºè§„åˆ™
  for (locale_code, rule) in collation_rules {
    CollationManager::register_rule(collation_manager, locale_code, rule)
  }
  
  // æµ‹è¯•æ•°æ®é›†
  let test_datasets = [
    ("en-US", [
      "apple", "Banana", "cherry", "Date", "elderberry", "Fig", "grape"
    ]),
    ("zh-CN", [
      "åŒ—äº¬", "ä¸Šæµ·", "å¹¿å·", "æ·±åœ³", "æ­å·", "å—äº¬", "æˆéƒ½"
    ]),
    ("ja-JP", [
      "ã‚ãŠã„", "ã‹ãã", "ã•ã—ã™", "ãŸã¡ã¤", "ãªã«ã¬", "ã¯ã²ãµ", "ã¾ã¿ã‚€"
    ]),
    ("de-DE", [
      "Ã„pfel", "Bananen", "Kirschen", "Datteln", "Erdbeeren", "Feigen", "Trauben"
    ]),
    ("sv-SE", [
      "Ã¤pple", "bananer", "kÃ¶rsbÃ¤r", "dadel", "jordgubbar", "fikon", "druvor"
    ])
  ]
  
  // æ‰§è¡Œæ–‡åŒ–ç‰¹å®šæ’åº
  let mut sorting_results = []
  
  for (locale_code, unsorted_data) in test_datasets {
    let sorted_data = CollationManager::sort(collation_manager, locale_code, unsorted_data)
    
    // éªŒè¯æ’åºç»“æœ
    assert_eq(sorted_data.length(), unsorted_data.length())
    
    // éªŒè¯æ’åºé¡ºåºï¼ˆæ ¹æ®ç‰¹å®šè¯­è¨€çš„æ’åºè§„åˆ™ï¼‰
    let is_correctly_sorted = CollationManager::verify_sort_order(collation_manager, locale_code, sorted_data)
    assert_true(is_correctly_sorted)
    
    sorting_results = sorting_results.push((locale_code, is_correctly_sorted))
    Counter::add(collation_counter, 1.0)
  }
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ¯”è¾ƒ
  let comparison_tests = [
    ("en-US", "apple", "Banana"),
    ("zh-CN", "åŒ—äº¬", "ä¸Šæµ·"),
    ("ja-JP", "ã‚ãŠã„", "ã‹ãã"),
    ("de-DE", "Ã„pfel", "Bananen"),
    ("sv-SE", "Ã¤pple", "bananer")
  ]
  
  for (locale_code, string1, string2) in comparison_tests {
    let comparison_result = CollationManager::compare(collation_manager, locale_code, string1, string2)
    assert_true(comparison_result != 0) // åº”è¯¥æœ‰æ˜ç¡®çš„æ¯”è¾ƒç»“æœ
    Counter::add(collation_counter, 1.0)
  }
  
  // è®¡ç®—æ’åºä¸€è‡´æ€§åˆ†æ•°
  let consistency_score = CollationManager::calculate_consistency_score(collation_manager, sorting_results)
  Gauge::set(consistency_gauge, consistency_score)
  
  // éªŒè¯æ–‡åŒ–ç‰¹å®šæ’åº
  assert_true(consistency_score > 0.9) // ä¸€è‡´æ€§åˆ†æ•°åº”è¯¥å¤§äº90%
  assert_eq(Counter::value(collation_counter), 10.0) // 5æ¬¡æ’åº + 5æ¬¡æ¯”è¾ƒ
}

// æµ‹è¯•5: åŒå‘æ–‡æœ¬å’ŒRTLæ”¯æŒ
test "åŒå‘æ–‡æœ¬å’ŒRTLæ”¯æŒæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.bidi")
  
  // åˆ›å»ºåŒå‘æ–‡æœ¬ç®¡ç†å™¨
  let bidi_manager = BidiManager::new(meter)
  
  // åˆ›å»ºåŒå‘æ–‡æœ¬æŒ‡æ ‡
  let bidi_counter = Meter::create_counter(meter, "bidi.operations")
  let rendering_gauge = Meter::create_gauge(meter, "bidi.rendering.quality")
  
  // é…ç½®åŒå‘æ–‡æœ¬æ”¯æŒ
  let bidi_locales = [
    ("en-US", TextDirection::LTR),
    ("ar-SA", TextDirection::RTL),
    ("he-IL", TextDirection::RTL),
    ("fa-IR", TextDirection::RTL),
    ("zh-CN", TextDirection::LTR),
    ("ja-JP", TextDirection::LTR)
  ]
  
  // æ³¨å†Œæ–‡æœ¬æ–¹å‘
  for (locale_code, direction) in bidi_locales {
    BidiManager::register_text_direction(bidi_manager, locale_code, direction)
  }
  
  // æµ‹è¯•æ•°æ®
  let test_texts = [
    ("en-US", "System metrics dashboard"),
    ("ar-SA", "Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª"),
    ("he-IL", "×œ×•×— ××“×“×™×"),
    ("fa-IR", "Ø¯Ø§Ø´board Ù…ØªØ±ÛŒÚ©"),
    ("zh-CN", "ç³»ç»ŸæŒ‡æ ‡ä»ªè¡¨æ¿"),
    ("ja-JP", "ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰")
  ]
  
  // æµ‹è¯•æ··åˆæ–¹å‘æ–‡æœ¬
  let mixed_direction_texts = [
    ("en-US", "System metrics Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª dashboard"),
    ("ar-SA", "Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª System metrics Ù„ÙˆØ­Ø©"),
    ("he-IL", "×œ×•×— ××“×“×™× System metrics ×œ×•×—"),
    ("fa-IR", "Ø¯Ø§Ø´board Ù…ØªØ±ÛŒÚ© System metrics dashboard")
  ]
  
  // æ‰§è¡ŒåŒå‘æ–‡æœ¬å¤„ç†
  for (locale_code, text) in test_texts {
    let processed_text = BidiManager::process_text(bidi_manager, locale_code, text)
    assert_true(processed_text.length() > 0)
    
    // éªŒè¯æ–‡æœ¬æ–¹å‘æ£€æµ‹
    let detected_direction = BidiManager::detect_text_direction(bidi_manager, text)
    let expected_direction = BidiManager::get_locale_direction(bidi_manager, locale_code)
    assert_eq(detected_direction, expected_direction)
    
    Counter::add(bidi_counter, 1.0)
  }
  
  // å¤„ç†æ··åˆæ–¹å‘æ–‡æœ¬
  for (locale_code, mixed_text) in mixed_direction_texts {
    let processed_mixed_text = BidiManager::process_mixed_text(bidi_manager, locale_code, mixed_text)
    assert_true(processed_mixed_text.length() > 0)
    
    // éªŒè¯æ··åˆæ–‡æœ¬å¤„ç†
    let segments = BidiManager::segment_text(bidi_manager, mixed_text)
    assert_true(segments.length() > 1) // åº”è¯¥æœ‰å¤šä¸ªæ–¹å‘æ®µè½
    
    Counter::add(bidi_counter, 1.0)
  }
  
  // æµ‹è¯•æ•°å­—å’Œæ‹‰ä¸æ–‡æœ¬åœ¨RTLç¯å¢ƒä¸­çš„å¤„ç†
  let rtl_number_tests = [
    ("ar-SA", "CPU: 75.5%, Memory: 60.2%"),
    ("he-IL", "CPU: 75.5%, Memory: 60.2%"),
    ("fa-IR", "CPU: 75.5%, Memory: 60.2%")
  ]
  
  for (locale_code, rtl_text) in rtl_number_tests {
    let processed_rtl_text = BidiManager::process_rtl_numbers(bidi_manager, locale_code, rtl_text)
    assert_true(processed_rtl_text.length() > 0)
    
    // éªŒè¯æ•°å­—åœ¨RTLæ–‡æœ¬ä¸­çš„æ­£ç¡®æ–¹å‘
    let number_directions = BidiManager::extract_number_directions(bidi_manager, processed_rtl_text)
    assert_true(number_directions.length() > 0)
    
    Counter::add(bidi_counter, 1.0)
  }
  
  // è®¡ç®—åŒå‘æ–‡æœ¬æ¸²æŸ“è´¨é‡
  let rendering_quality = BidiManager::calculate_rendering_quality(bidi_manager)
  Gauge::set(rendering_gauge, rendering_quality)
  
  // éªŒè¯åŒå‘æ–‡æœ¬æ”¯æŒ
  assert_true(rendering_quality > 0.9) // æ¸²æŸ“è´¨é‡åº”è¯¥å¤§äº90%
  assert_eq(Counter::value(bidi_counter), 13.0) // 6 + 4 + 3æ¬¡æ“ä½œ
}

// æµ‹è¯•6: å­—ç¬¦ç¼–ç å’ŒUnicodeæ”¯æŒ
test "å­—ç¬¦ç¼–ç å’ŒUnicodeæ”¯æŒæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.unicode")
  
  // åˆ›å»ºUnicodeç®¡ç†å™¨
  let unicode_manager = UnicodeManager::new(meter)
  
  // åˆ›å»ºUnicodeæŒ‡æ ‡
  let unicode_counter = Meter::create_counter(meter, "unicode.operations")
  let normalization_gauge = Meter::create_gauge(meter, "unicode.normalization.consistency")
  
  // é…ç½®Unicodeæ”¯æŒ
  let supported_encodings = [
    ("UTF-8", EncodingConfig::new([
      ("byte.order.mark", BoolValue(false)),
      ("replacement.character", StringValue("ï¿½"))
    ])),
    ("UTF-16", EncodingConfig::new([
      ("byte.order", StringValue("LE")),
      ("byte.order.mark", BoolValue(true))
    ])),
    ("UTF-32", EncodingConfig::new([
      ("byte.order", StringValue("LE")),
      ("byte.order.mark", BoolValue(true))
    ]))
  ]
  
  // æ³¨å†Œç¼–ç æ”¯æŒ
  for (encoding_name, config) in supported_encodings {
    UnicodeManager::register_encoding(unicode_manager, encoding_name, config)
  }
  
  // æµ‹è¯•å¤šè¯­è¨€å­—ç¬¦é›†
  let unicode_test_strings = [
    ("Latin", "Hello World 123"),
    ("Chinese", "ä½ å¥½ä¸–ç•Œ 123"),
    ("Japanese", "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ 123"),
    ("Arabic", "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù… 123"),
    ("Hebrew", "×©×œ×•× ×¢×•×œ× 123"),
    ("Russian", "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€ 123"),
    ("Emoji", "ğŸŒğŸ“ŠğŸ“ˆğŸ’»ğŸ”§"),
    ("Math", "âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚âˆšÂ±â‰¤â‰¥â‰ "),
    ("Currency", "$Â¥â‚¬Â£Â¢â‚¹â‚½â‚©"),
    ("Mixed", "Hello ä¸–ç•Œ ã“ã‚“ã«ã¡ã¯ ğŸŒ âˆ‘Ï€â‰ˆ")
  ]
  
  // æ‰§è¡ŒUnicodeå¤„ç†
  for (script_name, test_string) in unicode_test_strings {
    // æµ‹è¯•å­—ç¬¦æ£€æµ‹
    let detected_scripts = UnicodeManager::detect_scripts(unicode_manager, test_string)
    assert_true(detected_scripts.length() > 0)
    
    // æµ‹è¯•Unicodeè§„èŒƒåŒ–
    let normalized_nfc = UnicodeManager::normalize(unicode_manager, test_string, "NFC")
    let normalized_nfd = UnicodeManager::normalize(unicode_manager, test_string, "NFD")
    let normalized_nfc_again = UnicodeManager::normalize(unicode_manager, normalized_nfd, "NFC")
    
    // NFCè§„èŒƒåŒ–åº”è¯¥æ˜¯å¹‚ç­‰çš„
    assert_eq(normalized_nfc, normalized_nfc_again)
    
    // æµ‹è¯•å­—ç¬¦ç¼–ç è½¬æ¢
    for (encoding_name, _) in supported_encodings {
      let encoded_bytes = UnicodeManager::encode(unicode_manager, test_string, encoding_name)
      let decoded_string = UnicodeManager::decode(unicode_manager, encoded_bytes, encoding_name)
      
      assert_eq(decoded_string, test_string)
    }
    
    // æµ‹è¯•å­—ç¬¦å±æ€§
    let char_properties = UnicodeManager::get_character_properties(unicode_manager, test_string)
    assert_true(char_properties.length() > 0)
    
    Counter::add(unicode_counter, 1.0)
  }
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ¯”è¾ƒå’Œæ’åº
  let comparison_strings = [
    ("cafÃ©", "cafe"),
    ("naÃ¯ve", "naive"),
    ("resume", "rÃ©sumÃ©"),
    ("cooperate", "coÃ¶perate"),
    ("ä½ å¥½", "ni hao")
  ]
  
  for (string1, string2) in comparison_strings {
    // åŸºç¡€æ¯”è¾ƒ
    let basic_comparison = UnicodeManager::compare_strings(unicode_manager, string1, string2, false)
    
    // è§„èŒƒåŒ–æ¯”è¾ƒ
    let normalized_comparison = UnicodeManager::compare_strings(unicode_manager, string1, string2, true)
    
    // è§„èŒƒåŒ–æ¯”è¾ƒåº”è¯¥æ›´å‡†ç¡®
    assert_true(normalized_comparison != basic_comparison || normalized_comparison == basic_comparison)
    
    Counter::add(unicode_counter, 1.0)
  }
  
  // è®¡ç®—Unicodeè§„èŒƒåŒ–ä¸€è‡´æ€§
  let normalization_consistency = UnicodeManager::calculate_normalization_consistency(unicode_manager)
  Gauge::set(normalization_gauge, normalization_consistency)
  
  // éªŒè¯Unicodeæ”¯æŒ
  assert_true(normalization_consistency > 0.9) // è§„èŒƒåŒ–ä¸€è‡´æ€§åº”è¯¥å¤§äº90%
  assert_eq(Counter::value(unicode_counter), 15.0) // 10ä¸ªæµ‹è¯•å­—ç¬¦ä¸² + 5ä¸ªæ¯”è¾ƒå­—ç¬¦ä¸²
}

// æµ‹è¯•7: è´§å¸å’Œé‡‘èæ ¼å¼æœ¬åœ°åŒ–
test "è´§å¸å’Œé‡‘èæ ¼å¼æœ¬åœ°åŒ–æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.currency")
  
  // åˆ›å»ºè´§å¸ç®¡ç†å™¨
  let currency_manager = CurrencyManager::new(meter)
  
  // åˆ›å»ºè´§å¸æŒ‡æ ‡
  let currency_counter = Meter::create_counter(meter, "currency.formattings")
  let precision_gauge = Meter::create_gauge(meter, "currency.formatting.precision")
  
  // é…ç½®è´§å¸æ ¼å¼
  let currency_formats = [
    ("en-US", CurrencyFormat::new(
      "USD", "$", ".", ",", 2, "left"
    )),
    ("zh-CN", CurrencyFormat::new(
      "CNY", "Â¥", ".", ",", 2, "left"
    )),
    ("ja-JP", CurrencyFormat::new(
      "JPY", "Â¥", ".", ",", 0, "left"
    )),
    ("de-DE", CurrencyFormat::new(
      "EUR", "â‚¬", ",", ".", 2, "right"
    )),
    ("fr-FR", CurrencyFormat::new(
      "EUR", "â‚¬", ",", " ", 2, "right"
    )),
    ("en-GB", CurrencyFormat::new(
      "GBP", "Â£", ".", ",", 2, "left"
    )),
    ("ko-KR", CurrencyFormat::new(
      "KRW", "â‚©", ",", ".", 0, "left"
    )),
    ("ar-SA", CurrencyFormat::new(
      "SAR", "Ø±.Ø³", "Ù«", "Ù¬", 2, "left"
    ))
  ]
  
  // æ³¨å†Œè´§å¸æ ¼å¼
  for (locale_code, format) in currency_formats {
    CurrencyManager::register_format(currency_manager, locale_code, format)
  }
  
  // æµ‹è¯•è´§å¸æ ¼å¼åŒ–
  let test_amounts = [
    1234.56,
    9876543.21,
    0.99,
    1000000.0,
    -123.45
  ]
  
  for (locale_code, _) in currency_formats {
    for amount in test_amounts {
      let formatted_currency = CurrencyManager::format_currency(currency_manager, locale_code, amount)
      assert_true(formatted_currency.length() > 0)
      
      // éªŒè¯è´§å¸ç¬¦å·å­˜åœ¨
      let format = CurrencyManager::get_format(currency_manager, locale_code)
      assert_true(formatted_currency.contains(CurrencyFormat::symbol(format)))
      
      Counter::add(currency_counter, 1.0)
    }
  }
  
  // æµ‹è¯•è´§å¸è½¬æ¢
  let currency_conversions = [
    ("USD", "CNY", 123.45, 6.9), // 1 USD = 6.9 CNY
    ("EUR", "USD", 100.0, 1.1),   // 1 EUR = 1.1 USD
    ("JPY", "KRW", 10000.0, 9.5), // 1 JPY = 9.5 KRW
    ("GBP", "EUR", 50.0, 1.15)    // 1 GBP = 1.15 EUR
  ]
  
  for (from_currency, to_currency, amount, exchange_rate) in currency_conversions {
    let converted_amount = CurrencyManager::convert_currency(currency_manager, from_currency, to_currency, amount, exchange_rate)
    assert_true(converted_amount > 0.0)
    
    // éªŒè¯è½¬æ¢ç²¾åº¦
    let expected_amount = amount * exchange_rate
    let precision_diff = (converted_amount - expected_amount).abs()
    assert_true(precision_diff < 0.01) // ç²¾åº¦åº”è¯¥åœ¨0.01ä»¥å†…
    
    Counter::add(currency_counter, 1.0)
  }
  
  // æµ‹è¯•é‡‘èæ•°å­—æ ¼å¼ï¼ˆç‰¹æ®Šç²¾åº¦è¦æ±‚ï¼‰
  let financial_numbers = [
    1234567.890123,
    0.00123456,
    987654321.0,
    0.00000001
  ]
  
  for number in financial_numbers {
    // é«˜ç²¾åº¦æ ¼å¼åŒ–
    let high_precision = CurrencyManager::format_financial_high_precision(currency_manager, "en-US", number)
    assert_true(high_precision.length() > 0)
    
    // ä¼šè®¡æ ¼å¼
    let accounting_format = CurrencyManager::format_accounting(currency_manager, "en-US", number)
    assert_true(accounting_format.length() > 0)
    
    Counter::add(currency_counter, 2.0)
  }
  
  // è®¡ç®—è´§å¸æ ¼å¼åŒ–ç²¾åº¦
  let formatting_precision = CurrencyManager::calculate_formatting_precision(currency_manager)
  Gauge::set(precision_gauge, formatting_precision)
  
  // éªŒè¯è´§å¸æ ¼å¼åŒ–
  assert_true(formatting_precision > 0.95) // æ ¼å¼åŒ–ç²¾åº¦åº”è¯¥å¤§äº95%
  assert_eq(Counter::value(currency_counter), 56.0) // 8Ã—5 + 4 + 4Ã—2
}

// æµ‹è¯•8: å¤æ•°å½¢å¼å’Œæ€§åˆ«åŒ–è¯­è¨€æ”¯æŒ
test "å¤æ•°å½¢å¼å’Œæ€§åˆ«åŒ–è¯­è¨€æ”¯æŒæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.pluralization")
  
  // åˆ›å»ºå¤æ•°å½¢å¼ç®¡ç†å™¨
  let pluralization_manager = PluralizationManager::new(meter)
  
  // åˆ›å»ºå¤æ•°å½¢å¼æŒ‡æ ‡
  let plural_counter = Meter::create_counter(meter, "pluralization.operations")
  let accuracy_gauge = Meter::create_gauge(meter, "pluralization.accuracy.score")
  
  // é…ç½®å¤æ•°å½¢å¼è§„åˆ™
  let plural_rules = [
    ("en", PluralRule::new([
      (1, "one"),   // 1 item
      (2, "other")  // 2+ items
    ])),
    ("zh", PluralRule::new([
      (0, "other"), // ä¸­æ–‡æ²¡æœ‰å¤æ•°å½¢å¼
      (1, "other"),
      (2, "other")
    ])),
    ("ar", PluralRule::new([
      (0, "zero"),  // 0 items
      (1, "one"),   // 1 item
      (2, "two"),   // 2 items
      (3, "few"),   // 3-10 items
      (11, "many"), // 11+ items
      (100, "other")
    ])),
    ("ru", PluralRule::new([
      (1, "one"),   // 1, 21, 31, ...
      (2, "few"),   // 2-4, 22-24, ...
      (5, "many"),  // 5-20, 25-30, ...
      (21, "one"),  // 21, 31, 41, ...
      (0, "many")   // 0
    ])),
    ("ja", PluralRule::new([
      (0, "other"), // æ—¥æ–‡æ²¡æœ‰å¤æ•°å½¢å¼
      (1, "other"),
      (2, "other")
    ]))
  ]
  
  // æ³¨å†Œå¤æ•°å½¢å¼è§„åˆ™
  for (language_code, rule) in plural_rules {
    PluralizationManager::register_rule(pluralization_manager, language_code, rule)
  }
  
  // é…ç½®æ€§åˆ«åŒ–è¯­è¨€è§„åˆ™
  let gender_rules = [
    ("ar", GenderRule::new([
      ("masc", "Ø§Ù„Ø·Ø§Ù„Ø¨"), // é˜³æ€§
      ("fem", "Ø§Ù„Ø·Ø§Ù„Ø¨Ø©"), // é˜´æ€§
      ("neutral", "Ø§Ù„Ø´Ø®Øµ") // ä¸­æ€§
    ])),
    ("fr", GenderRule::new([
      ("masc", "le Ã©tudiant"), // é˜³æ€§
      ("fem", "l'Ã©tudiante"),   // é˜´æ€§
      ("neutral", "la personne") // ä¸­æ€§
    ])),
    ("de", GenderRule::new([
      ("masc", "der Student"),  // é˜³æ€§
      ("fem", "die Studentin"), // é˜´æ€§
      ("neutral", "die Person") // ä¸­æ€§
    ])),
    ("es", GenderRule::new([
      ("masc", "el estudiante"), // é˜³æ€§
      ("fem", "la estudiante"), // é˜´æ€§
      ("neutral", "la persona") // ä¸­æ€§
    ]))
  ]
  
  // æ³¨å†Œæ€§åˆ«åŒ–è¯­è¨€è§„åˆ™
  for (language_code, rule) in gender_rules {
    PluralizationManager::register_gender_rule(pluralization_manager, language_code, rule)
  }
  
  // æµ‹è¯•å¤æ•°å½¢å¼
  let plural_tests = [
    ("en", 0, "items"),
    ("en", 1, "item"),
    ("en", 2, "items"),
    ("en", 5, "items"),
    ("zh", 0, "é¡¹"),
    ("zh", 1, "é¡¹"),
    ("zh", 2, "é¡¹"),
    ("ar", 0, "Ø¹Ù†Ø§ØµØ±"),
    ("ar", 1, "Ø¹Ù†ØµØ±"),
    ("ar", 2, "Ø¹Ù†ØµØ±Ø§Ù†"),
    ("ar", 5, "Ø¨Ø¹Ø¶ Ø§Ù„Ø¹Ù†Ø§ØµØ±"),
    ("ar", 15, "Ø§Ù„Ø¹Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ø¹Ù†Ø§ØµØ±"),
    ("ru", 1, "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚"),
    ("ru", 2, "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°"),
    ("ru", 5, "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²"),
    ("ru", 21, "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚"),
    ("ru", 0, "ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²")
  ]
  
  for (language_code, count, expected_form) in plural_tests {
    let plural_form = PluralizationManager::get_plural_form(pluralization_manager, language_code, count)
    assert_true(plural_form.length() > 0)
    
    Counter::add(plural_counter, 1.0)
  }
  
  // æµ‹è¯•æ€§åˆ«åŒ–è¯­è¨€
  let gender_tests = [
    ("ar", "masc", "student"),
    ("ar", "fem", "student"),
    ("ar", "neutral", "person"),
    ("fr", "masc", "student"),
    ("fr", "fem", "student"),
    ("fr", "neutral", "person"),
    ("de", "masc", "student"),
    ("de", "fem", "student"),
    ("de", "neutral", "person"),
    ("es", "masc", "student"),
    ("es", "fem", "student"),
    ("es", "neutral", "person")
  ]
  
  for (language_code, gender, word) in gender_tests {
    let gendered_word = PluralizationManager::get_gendered_word(pluralization_manager, language_code, gender, word)
    assert_true(gendered_word.length() > 0)
    assert_ne(gendered_word, word) // åº”è¯¥æœ‰ä¸åŒçš„æ€§åˆ«å½¢å¼
    
    Counter::add(plural_counter, 1.0)
  }
  
  // æµ‹è¯•å¤æ•°å’Œæ€§åˆ«ç»„åˆ
  let combined_tests = [
    ("ar", 1, "masc", "Ø·Ø§Ù„Ø¨"),
    ("ar", 2, "masc", "Ø·Ø§Ù„Ø¨Ø§Ù†"),
    ("ar", 5, "masc", "Ø·Ù„Ø§Ø¨"),
    ("ar", 1, "fem", "Ø·Ø§Ù„Ø¨Ø©"),
    ("ar", 2, "fem", "Ø·Ø§Ù„Ø¨ØªØ§Ù†"),
    ("ar", 5, "fem", "Ø·Ø§Ù„Ø¨Ø§Øª"),
    ("fr", 1, "masc", "Ã©tudiant"),
    ("fr", 2, "masc", "Ã©tudiants"),
    ("fr", 1, "fem", "Ã©tudiante"),
    ("fr", 2, "fem", "Ã©tudiantes")
  ]
  
  for (language_code, count, gender, expected_word) in combined_tests {
    let combined_word = PluralizationManager::get_plural_gendered_word(pluralization_manager, language_code, count, gender, "student")
    assert_true(combined_word.length() > 0)
    
    Counter::add(plural_counter, 1.0)
  }
  
  // è®¡ç®—å¤æ•°å½¢å¼å‡†ç¡®ç‡
  let accuracy_score = PluralizationManager::calculate_accuracy_score(pluralization_manager)
  Gauge::set(accuracy_gauge, accuracy_score)
  
  // éªŒè¯å¤æ•°å½¢å¼å’Œæ€§åˆ«åŒ–è¯­è¨€æ”¯æŒ
  assert_true(accuracy_score > 0.9) // å‡†ç¡®ç‡åº”è¯¥å¤§äº90%
  assert_eq(Counter::value(plural_counter), 38.0) // 16 + 12 + 10æ¬¡æ“ä½œ
}

// æµ‹è¯•9: æ–‡åŒ–ç‰¹å®šçš„å•ä½å’Œåº¦é‡
test "æ–‡åŒ–ç‰¹å®šçš„å•ä½å’Œåº¦é‡æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.units")
  
  // åˆ›å»ºå•ä½ç®¡ç†å™¨
  let unit_manager = UnitManager::new(meter)
  
  // åˆ›å»ºå•ä½æŒ‡æ ‡
  let unit_counter = Meter::create_counter(meter, "unit.conversions")
  let accuracy_gauge = Meter::create_gauge(meter, "unit.conversion.accuracy")
  
  // é…ç½®å•ä½ç³»ç»Ÿ
  let unit_systems = [
    ("metric", UnitSystem::new([
      ("length", "meters"),
      ("weight", "kilograms"),
      ("temperature", "celsius"),
      ("volume", "liters"),
      ("speed", "km/h")
    ])),
    ("imperial", UnitSystem::new([
      ("length", "feet"),
      ("weight", "pounds"),
      ("temperature", "fahrenheit"),
      ("volume", "gallons"),
      ("speed", "mph")
    ])),
    ("us_customary", UnitSystem::new([
      ("length", "feet"),
      ("weight", "pounds"),
      ("temperature", "fahrenheit"),
      ("volume", "gallons"),
      ("speed", "mph")
    ]))
  ]
  
  // æ³¨å†Œå•ä½ç³»ç»Ÿ
  for (system_name, system) in unit_systems {
    UnitManager::register_system(unit_manager, system_name, system)
  }
  
  // é…ç½®åœ°åŒºå•ä½åå¥½
  let locale_preferences = [
    ("en-US", "imperial"),
    ("en-GB", "imperial"),
    ("en-CA", "metric"),
    ("zh-CN", "metric"),
    ("ja-JP", "metric"),
    ("de-DE", "metric"),
    ("fr-FR", "metric"),
    ("es-ES", "metric")
  ]
  
  // æ³¨å†Œåœ°åŒºå•ä½åå¥½
  for (locale_code, system_name) in locale_preferences {
    UnitManager::set_locale_preference(unit_manager, locale_code, system_name)
  }
  
  // é…ç½®å•ä½è½¬æ¢è§„åˆ™
  let conversion_rules = [
    ("meters", "feet", 3.28084),
    ("kilometers", "miles", 0.621371),
    ("kilograms", "pounds", 2.20462),
    ("celsius", "fahrenheit", fn(c) { c * 9.0 / 5.0 + 32.0 }),
    ("liters", "gallons", 0.264172),
    ("km/h", "mph", 0.621371)
  ]
  
  // æ³¨å†Œå•ä½è½¬æ¢è§„åˆ™
  for (from_unit, to_unit, conversion) in conversion_rules {
    UnitManager::register_conversion_rule(unit_manager, from_unit, to_unit, conversion)
  }
  
  // æµ‹è¯•å•ä½è½¬æ¢
  let conversion_tests = [
    ("meters", "feet", 10.0),
    ("kilometers", "miles", 5.0),
    ("kilograms", "pounds", 70.0),
    ("celsius", "fahrenheit", 25.0),
    ("liters", "gallons", 20.0),
    ("km/h", "mph", 100.0)
  ]
  
  for (from_unit, to_unit, value) in conversion_tests {
    let converted_value = UnitManager::convert(unit_manager, from_unit, to_unit, value)
    assert_true(converted_value > 0.0)
    
    Counter::add(unit_counter, 1.0)
  }
  
  // æµ‹è¯•åœ°åŒºç‰¹å®šå•ä½æ ¼å¼åŒ–
  let locale_format_tests = [
    ("en-US", "length", 100.0, "feet"),
    ("zh-CN", "length", 100.0, "meters"),
    ("de-DE", "weight", 75.0, "kilograms"),
    ("en-GB", "weight", 75.0, "pounds"),
    ("ja-JP", "temperature", 20.0, "celsius"),
    ("en-US", "temperature", 20.0, "fahrenheit")
  ]
  
  for (locale_code, unit_type, value, expected_unit) in locale_format_tests {
    let formatted_unit = UnitManager::format_for_locale(unit_manager, locale_code, unit_type, value)
    assert_true(formatted_unit.length() > 0)
    
    // éªŒè¯ä½¿ç”¨äº†æ­£ç¡®çš„å•ä½
    let preferred_system = UnitManager::get_locale_preference(unit_manager, locale_code)
    let system_unit = UnitSystem::get_unit(UnitManager::get_system(unit_manager, preferred_system), unit_type)
    assert_eq(system_unit, expected_unit)
    
    Counter::add(unit_counter, 1.0)
  }
  
  // æµ‹è¯•å¤åˆå•ä½
  let compound_unit_tests = [
    ("km/h", "mph", 120.0),
    ("m/s", "ft/s", 10.0),
    ("kg/mÂ²", "lb/ftÂ²", 5.0),
    ("l/100km", "mpg", 8.0)
  ]
  
  for (from_unit, to_unit, value) in compound_unit_tests {
    let converted_value = UnitManager::convert_compound(unit_manager, from_unit, to_unit, value)
    assert_true(converted_value > 0.0)
    
    Counter::add(unit_counter, 1.0)
  }
  
  // è®¡ç®—å•ä½è½¬æ¢å‡†ç¡®ç‡
  let conversion_accuracy = UnitManager::calculate_conversion_accuracy(unit_manager)
  Gauge::set(accuracy_gauge, conversion_accuracy)
  
  // éªŒè¯å•ä½å’Œåº¦é‡æ”¯æŒ
  assert_true(conversion_accuracy > 0.95) // è½¬æ¢å‡†ç¡®ç‡åº”è¯¥å¤§äº95%
  assert_eq(Counter::value(unit_counter), 18.0) // 6 + 6 + 6æ¬¡æ“ä½œ
}

// æµ‹è¯•10: å¯è®¿é—®æ€§å’Œæœ¬åœ°åŒ–UIæ”¯æŒ
test "å¯è®¿é—®æ€§å’Œæœ¬åœ°åŒ–UIæ”¯æŒæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "internationalization.accessibility")
  
  // åˆ›å»ºå¯è®¿é—®æ€§ç®¡ç†å™¨
  let accessibility_manager = AccessibilityManager::new(meter)
  
  // åˆ›å»ºå¯è®¿é—®æ€§æŒ‡æ ‡
  let a11y_counter = Meter::create_counter(meter, "accessibility.operations")
  let compliance_gauge = Meter::create_gauge(meter, "accessibility.compliance.score")
  
  // é…ç½®å¯è®¿é—®æ€§è§„åˆ™
  let accessibility_rules = [
    ("screen.reader", AccessibilityRule::new([
      ("aria.labels.required", BoolValue(true)),
      ("alt.text.required", BoolValue(true)),
      ("semantic.html", BoolValue(true))
    ])),
    ("keyboard.navigation", AccessibilityRule::new([
      ("tab.index.logical", BoolValue(true)),
      ("focus.visible", BoolValue(true)),
      ("skip.links", BoolValue(true))
    ])),
    ("color.contrast", AccessibilityRule::new([
      ("wcag.aa.minimum", FloatValue(4.5)),
      ("wcag.aaa.enhanced", FloatValue(7.0)),
      ("color.blind.friendly", BoolValue(true))
    ])),
    ("text.sizing", AccessibilityRule::new([
      ("minimum.font.size", IntValue(14)),
      ("scalable.to.200", BoolValue(true)),
      ("line.height.minimum", FloatValue(1.5))
    ]))
  ]
  
  // æ³¨å†Œå¯è®¿é—®æ€§è§„åˆ™
  for (rule_name, rule) in accessibility_rules {
    AccessibilityManager::register_rule(accessibility_manager, rule_name, rule)
  }
  
  // é…ç½®æœ¬åœ°åŒ–UIç»„ä»¶
  let localized_components = [
    ("en-US", UIComponent::new("dashboard", [
      ("title", "System Metrics Dashboard"),
      ("description", "Real-time monitoring of system performance"),
      ("aria.label", "System metrics dashboard with charts and alerts"),
      ("keyboard.shortcut", "Alt+D")
    ])),
    ("zh-CN", UIComponent::new("dashboard", [
      ("title", "ç³»ç»ŸæŒ‡æ ‡ä»ªè¡¨æ¿"),
      ("description", "ç³»ç»Ÿæ€§èƒ½çš„å®æ—¶ç›‘æ§"),
      ("aria.label", "åŒ…å«å›¾è¡¨å’Œå‘Šè­¦çš„ç³»ç»ŸæŒ‡æ ‡ä»ªè¡¨æ¿"),
      ("keyboard.shortcut", "Alt+D")
    ])),
    ("ja-JP", UIComponent::new("dashboard", [
      ("title", "ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰"),
      ("description", "ã‚·ã‚¹ãƒ†ãƒ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–"),
      ("aria.label", "ãƒãƒ£ãƒ¼ãƒˆã¨ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å«ã‚€ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰"),
      ("keyboard.shortcut", "Alt+D")
    ])),
    ("ar-SA", UIComponent::new("dashboard", [
      ("title", "Ù„ÙˆØ­Ø© Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù†Ø¸Ø§Ù…"),
      ("description", "Ù…Ø±Ø§Ù‚Ø¨Ø© Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ"),
      ("aria.label", "Ù„ÙˆØ­Ø© Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù†Ø¸Ø§Ù… Ù…Ø¹ Ø§Ù„Ù…Ø®Ø·Ø·Ø§Øª ÙˆØ§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª"),
      ("keyboard.shortcut", "Alt+D")
    ]))
  ]
  
  // æ³¨å†Œæœ¬åœ°åŒ–UIç»„ä»¶
  for (locale_code, component) in localized_components {
    AccessibilityManager::register_component(accessibility_manager, locale_code, component)
  }
  
  // æµ‹è¯•å¯è®¿é—®æ€§éªŒè¯
  for (locale_code, component) in localized_components {
    // éªŒè¯å±å¹•é˜…è¯»å™¨æ”¯æŒ
    let screen_reader_result = AccessibilityManager::validate_screen_reader(accessibility_manager, component)
    assert_true(screen_reader_result.compliant)
    
    // éªŒè¯é”®ç›˜å¯¼èˆª
    let keyboard_nav_result = AccessibilityManager::validate_keyboard_navigation(accessibility_manager, component)
    assert_true(keyboard_nav_result.compliant)
    
    // éªŒè¯é¢œè‰²å¯¹æ¯”åº¦
    let color_contrast_result = AccessibilityManager::validate_color_contrast(accessibility_manager, component)
    assert_true(color_contrast_result.compliant)
    
    // éªŒè¯æ–‡æœ¬å¤§å°
    let text_sizing_result = AccessibilityManager::validate_text_sizing(accessibility_manager, component)
    assert_true(text_sizing_result.compliant)
    
    Counter::add(a11y_counter, 4.0)
  }
  
  // æµ‹è¯•RTLè¯­è¨€çš„å¯è®¿é—®æ€§
  let rtl_components = [
    ("ar-SA", UIComponent::new("dashboard", [
      ("title", "Ù„ÙˆØ­Ø© Ù…Ù‚Ø§ÙŠÙŠØ³ Ø§Ù„Ù†Ø¸Ø§Ù…"),
      ("text.direction", "rtl"),
      ("layout.mirrored", "true")
    ])),
    ("he-IL", UIComponent::new("dashboard", [
      ("title", "×œ×•×— ××“×“×™×"),
      ("text.direction", "rtl"),
      ("layout.mirrored", "true")
    ]))
  ]
  
  for (locale_code, component) in rtl_components {
    let rtl_accessibility_result = AccessibilityManager::validate_rtl_accessibility(accessibility_manager, component)
    assert_true(rtl_accessibility_result.compliant)
    
    Counter::add(a11y_counter, 1.0)
  }
  
  // æµ‹è¯•é«˜å¯¹æ¯”åº¦æ¨¡å¼
  let high_contrast_tests = [
    ("en-US", "high.contrast"),
    ("zh-CN", "high.contrast"),
    ("ja-JP", "high.contrast")
  ]
  
  for (locale_code, mode) in high_contrast_tests {
    let high_contrast_result = AccessibilityManager::validate_high_contrast(accessibility_manager, locale_code, mode)
    assert_true(high_contrast_result.compliant)
    
    Counter::add(a11y_counter, 1.0)
  }
  
  // æµ‹è¯•å­—ä½“ç¼©æ”¾
  let font_scaling_tests = [
    ("en-US", 150), // 150% ç¼©æ”¾
    ("zh-CN", 200), // 200% ç¼©æ”¾
    ("ja-JP", 125)  // 125% ç¼©æ”¾
  ]
  
  for (locale_code, scale_percentage) in font_scaling_tests {
    let font_scaling_result = AccessibilityManager::validate_font_scaling(accessibility_manager, locale_code, scale_percentage)
    assert_true(font_scaling_result.compliant)
    
    Counter::add(a11y_counter, 1.0)
  }
  
  // è®¡ç®—å¯è®¿é—®æ€§åˆè§„åˆ†æ•°
  let compliance_score = AccessibilityManager::calculate_compliance_score(accessibility_manager)
  Gauge::set(compliance_gauge, compliance_score)
  
  // éªŒè¯å¯è®¿é—®æ€§å’Œæœ¬åœ°åŒ–UIæ”¯æŒ
  assert_true(compliance_score > 0.9) // åˆè§„åˆ†æ•°åº”è¯¥å¤§äº90%
  assert_eq(Counter::value(a11y_counter), 23.0) // 4Ã—4 + 2 + 3 + 3æ¬¡æ“ä½œ
}