// Azimuth Internationalization Support Tests
// å›½é™…åŒ–æ”¯æŒæµ‹è¯•ï¼ŒéªŒè¯å¤šè¯­è¨€æ–‡æœ¬å¤„ç†å’Œæœ¬åœ°åŒ–åŠŸèƒ½

// æµ‹è¯•1: å¤šè¯­è¨€æ–‡æœ¬å¤„ç†
test "multilingual text processing" {
  // æµ‹è¯•ä¸­æ–‡æ–‡æœ¬
  let chinese_text = "é¥æµ‹ç³»ç»Ÿæ•°æ®å¤„ç†"
  let chinese_error = "æ“ä½œå¤±è´¥ï¼šæ— æ³•è¿æ¥åˆ°æ•°æ®åº“"
  let chinese_success = "æ“ä½œæˆåŠŸå®Œæˆ"
  
  // æµ‹è¯•æ—¥æ–‡æ–‡æœ¬
  let japanese_text = "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ ãƒ‡ãƒ¼ã‚¿å‡¦ç†"
  let japanese_error = "æ“ä½œå¤±æ•—ï¼šãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«æ¥ç¶šã§ãã¾ã›ã‚“"
  let japanese_success = "æ“ä½œãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ"
  
  // æµ‹è¯•éŸ©æ–‡æ–‡æœ¬
  let korean_text = "ì›ê²© ì¸¡ì • ì‹œìŠ¤í…œ ë°ì´í„° ì²˜ë¦¬"
  let korean_error = "ì‘ì—… ì‹¤íŒ¨: ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
  let korean_success = "ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"
  
  // æµ‹è¯•é˜¿æ‹‰ä¼¯æ–‡æ–‡æœ¬
  let arabic_text = "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  let arabic_error = "ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"
  let arabic_success = "ØªÙ…Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­"
  
  // æµ‹è¯•ä¿„æ–‡æ–‡æœ¬
  let russian_text = "ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ğ¸"
  let russian_error = "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ°ÑÑŒ: Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"
  let russian_success = "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°"
  
  // æµ‹è¯•å¸Œä¼¯æ¥æ–‡æ–‡æœ¬
  let hebrew_text = "×¢×™×‘×•×“ × ×ª×•× ×™× ×©×œ ××¢×¨×›×ª ×˜×œ××˜×¨×™×”"
  let hebrew_error = "×”×¤×¢×•×œ×” × ×›×©×œ×”: ×œ× × ×™×ª×Ÿ ×œ×”×ª×—×‘×¨ ×œ××¡×“ ×”× ×ª×•× ×™×"
  let hebrew_success = "×”×¤×¢×•×œ×” ×”×¡×ª×™×™××” ×‘×”×¦×œ×—×”"
  
  // éªŒè¯å¤šè¯­è¨€æ–‡æœ¬é•¿åº¦
  assert_eq(chinese_text.length(), 8)
  assert_eq(japanese_text.length(), 14)
  assert_eq(korean_text.length(), 14)
  assert_eq(arabic_text.length(), 31)
  assert_eq(russian_text.length(), 35)
  assert_eq(hebrew_text.length(), 29)
  
  // éªŒè¯å¤šè¯­è¨€æ–‡æœ¬åŒ…å«ç‰¹å®šå­—ç¬¦
  assert_true(chinese_text.contains("é¥"))
  assert_true(japanese_text.contains("ãƒ†"))
  assert_true(korean_text.contains("ì›"))
  assert_true(arabic_text.contains("Ù†"))
  assert_true(russian_text.contains("Ğ¢"))
  assert_true(hebrew_text.contains("×¢"))
  
  // åˆ›å»ºå¤šè¯­è¨€å±æ€§
  let multilingual_attributes = [
    ("error.message.zh", StringValue(chinese_error)),
    ("error.message.ja", StringValue(japanese_error)),
    ("error.message.ko", StringValue(korean_error)),
    ("error.message.ar", StringValue(arabic_error)),
    ("error.message.ru", StringValue(russian_error)),
    ("error.message.he", StringValue(hebrew_error)),
    ("success.message.zh", StringValue(chinese_success)),
    ("success.message.ja", StringValue(japanese_success)),
    ("success.message.ko", StringValue(korean_success)),
    ("success.message.ar", StringValue(arabic_success)),
    ("success.message.ru", StringValue(russian_success)),
    ("success.message.he", StringValue(hebrew_success))
  ]
  
  // éªŒè¯å¤šè¯­è¨€å±æ€§
  assert_eq(multilingual_attributes.length(), 12)
  
  // åˆ›å»ºå¤šè¯­è¨€èµ„æº
  let multilingual_resource = Resource({
    attributes: multilingual_attributes,
    schema_url: Some("https://opentelemetry.io/schemas/1.20.0")
  })
  
  // éªŒè¯å¤šè¯­è¨€èµ„æº
  assert_eq(multilingual_resource.attributes.length(), 12)
}

// æµ‹è¯•2: Unicodeå­—ç¬¦å¤„ç†
test "unicode character processing" {
  // æµ‹è¯•å„ç§Unicodeå­—ç¬¦
  let emoji_text = "ğŸŒğŸ“ŠğŸ“ˆğŸ”ğŸš€"
  let mathematical_symbols = "âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚âˆ‚âˆ‡âˆ†âˆ«âˆâˆ‘"
  let currency_symbols = "$â‚¬Â£Â¥â‚¹â‚½â‚©â‚ªâ‚«â‚¡â‚¦â‚¨â‚±â‚²â‚´â‚¸â‚¼â‚½"
  let arrows_symbols = "â†â†’â†‘â†“â†–â†—â†˜â†™â‡â‡’â‡‘â‡“â‡”â‡•â‡–â‡—â‡˜â‡™"
  let punctuation_symbols = "ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼š""''ï¼ˆï¼‰ã€ã€‘ã€Šã€‹"
  
  // éªŒè¯Unicodeæ–‡æœ¬é•¿åº¦
  assert_eq(emoji_text.length(), 5)
  assert_eq(mathematical_symbols.length(), 14)
  assert_eq(currency_symbols.length(), 20)
  assert_eq(arrows_symbols.length(), 20)
  assert_eq(punctuation_symbols.length(), 14)
  
  // éªŒè¯Unicodeå­—ç¬¦åŒ…å«
  assert_true(emoji_text.contains("ğŸŒ"))
  assert_true(mathematical_symbols.contains("âˆ‘"))
  assert_true(currency_symbols.contains("â‚¬"))
  assert_true(arrows_symbols.contains("â†"))
  assert_true(punctuation_symbols.contains("ï¼Œ"))
  
  // æµ‹è¯•ç»„åˆå­—ç¬¦
  let combining_characters = "e\u0301" // e + acute accent
  let combining_characters2 = "o\u0308" // o + diaeresis
  
  assert_eq(combining_characters.length(), 2)
  assert_eq(combining_characters2.length(), 2)
  
  // æµ‹è¯•é›¶å®½å­—ç¬¦
  let zero_width_space = "\u200B"
  let zero_width_non_joiner = "\u200C"
  let zero_width_joiner = "\u200D"
  
  assert_eq(zero_width_space.length(), 1)
  assert_eq(zero_width_non_joiner.length(), 1)
  assert_eq(zero_width_joiner.length(), 1)
  
  // æµ‹è¯•æ§åˆ¶å­—ç¬¦
  let control_characters = "\n\t\r"
  assert_eq(control_characters.length(), 3)
  
  // åˆ›å»ºåŒ…å«Unicodeå­—ç¬¦çš„å±æ€§
  let unicode_attributes = [
    ("emoji.status", StringValue(emoji_text)),
    ("math.formula", StringValue(mathematical_symbols)),
    ("currency.info", StringValue(currency_symbols)),
    ("navigation.directions", StringValue(arrows_symbols)),
    ("punctuation.marks", StringValue(punctuation_symbols))
  ]
  
  // éªŒè¯Unicodeå±æ€§
  assert_eq(unicode_attributes.length(), 5)
  
  // åˆ›å»ºåŒ…å«Unicodeå­—ç¬¦çš„æ—¥å¿—è®°å½•
  let unicode_log_record = LogRecord({
    timestamp: 1704067200000000000L,
    observed_timestamp: None,
    severity_number: Info,
    severity_text: Some("INFO"),
    body: Some("Unicode test: " + emoji_text + " " + mathematical_symbols),
    attributes: unicode_attributes,
    trace_id: Some("1234567890abcdef1234567890abcdef"),
    span_id: Some("1234567890abcdef"),
    trace_flags: Some(1),
    resource: None,
    instrumentation_scope: None
  })
  
  // éªŒè¯Unicodeæ—¥å¿—è®°å½•
  match unicode_log_record.body {
    Some(body) => {
      assert_true(body.contains("ğŸŒ"))
      assert_true(body.contains("âˆ‘"))
    }
    None => assert_true(false)
  }
  
  assert_eq(unicode_log_record.attributes.length(), 5)
}

// æµ‹è¯•3: æ–‡æœ¬æ–¹å‘å’ŒåŒå‘å¤„ç†
test "text direction and bidirectional processing" {
  // æµ‹è¯•ä»å·¦åˆ°å³çš„æ–‡æœ¬ï¼ˆLTRï¼‰
  let ltr_text = "Hello World"
  let ltr_arabic_mixed = "Hello Ù…Ø±Ø­Ø¨Ø§ World"
  
  // æµ‹è¯•ä»å³åˆ°å·¦çš„æ–‡æœ¬ï¼ˆRTLï¼‰
  let rtl_text = "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"
  let rtl_english_mixed = "Ù…Ø±Ø­Ø¨Ø§ Hello Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"
  
  // æµ‹è¯•åŒå‘æ–‡æœ¬
  let bidi_text = "Hello Ù…Ø±Ø­Ø¨Ø§ World Ø§Ù„Ø¹Ø§Ù„Ù…"
  
  // éªŒè¯æ–‡æœ¬æ–¹å‘æ ‡è®°
  let ltr_mark = "\u200E" // Left-to-Right Mark
  let rtl_mark = "\u200F" // Right-to-Left Mark
  
  let marked_ltr_text = ltr_mark + ltr_text
  let marked_rtl_text = rtl_mark + rtl_text
  
  assert_eq(marked_ltr_text.length(), ltr_text.length() + 1)
  assert_eq(marked_rtl_text.length(), rtl_text.length() + 1)
  
  // æµ‹è¯•åŒå‘åµŒå…¥
  let lre = "\u202A" // Left-to-Right Embedding
  let rle = "\u202B" // Right-to-Left Embedding
  let pdf = "\u202C" // Pop Directional Formatting
  
  let embedded_ltr = lre + "English text" + pdf
  let embedded_rtl = rle + "Ù†Øµ Ø¹Ø±Ø¨ÙŠ" + pdf
  
  assert_eq(embedded_ltr.length(), "English text".length() + 2)
  assert_eq(embedded_rtl.length(), "Ù†Øµ Ø¹Ø±Ø¨ÙŠ".length() + 2)
  
  // åˆ›å»ºåŒ…å«ä¸åŒæ–¹å‘æ–‡æœ¬çš„å±æ€§
  let directional_attributes = [
    ("text.ltr", StringValue(ltr_text)),
    ("text.rtl", StringValue(rtl_text)),
    ("text.bidi", StringValue(bidi_text)),
    ("text.ltr.arabic.mixed", StringValue(ltr_arabic_mixed)),
    ("text.rtl.english.mixed", StringValue(rtl_english_mixed)),
    ("text.marked.ltr", StringValue(marked_ltr_text)),
    ("text.marked.rtl", StringValue(marked_rtl_text))
  ]
  
  // éªŒè¯æ–¹å‘æ€§å±æ€§
  assert_eq(directional_attributes.length(), 7)
  
  // åˆ›å»ºåŒ…å«ä¸åŒæ–¹å‘æ–‡æœ¬çš„èµ„æº
  let directional_resource = Resource({
    attributes: directional_attributes,
    schema_url: Some("https://opentelemetry.io/schemas/1.20.0")
  })
  
  // éªŒè¯æ–¹å‘æ€§èµ„æº
  assert_eq(directional_resource.attributes.length(), 7)
}

// æµ‹è¯•4: åŒºåŸŸè®¾ç½®å’Œæœ¬åœ°åŒ–
test "locale and localization" {
  // æµ‹è¯•ä¸åŒåŒºåŸŸçš„æ—¥æœŸæ ¼å¼
  let us_date_format = "MM/DD/YYYY"
  let eu_date_format = "DD/MM/YYYY"
  let iso_date_format = "YYYY-MM-DD"
  let chinese_date_format = "YYYYå¹´MMæœˆDDæ—¥"
  let japanese_date_format = "YYYYå¹´MMæœˆDDæ—¥"
  
  // æµ‹è¯•ä¸åŒåŒºåŸŸçš„æ•°å­—æ ¼å¼
  let us_number_format = "1,234.56"
  let eu_number_format = "1.234,56"
  let indian_number_format = "1,23,456.78"
  
  // æµ‹è¯•ä¸åŒåŒºåŸŸçš„è´§å¸æ ¼å¼
  let us_currency = "$1,234.56"
  let eu_currency = "â‚¬1.234,56"
  let japanese_currency = "Â¥1,234"
  let chinese_currency = "Â¥1,234.56"
  
  // åˆ›å»ºåŒºåŸŸè®¾ç½®å±æ€§
  let locale_attributes = [
    ("locale.date.format.us", StringValue(us_date_format)),
    ("locale.date.format.eu", StringValue(eu_date_format)),
    ("locale.date.format.iso", StringValue(iso_date_format)),
    ("locale.date.format.zh", StringValue(chinese_date_format)),
    ("locale.date.format.ja", StringValue(japanese_date_format)),
    ("locale.number.format.us", StringValue(us_number_format)),
    ("locale.number.format.eu", StringValue(eu_number_format)),
    ("locale.number.format.in", StringValue(indian_number_format)),
    ("locale.currency.us", StringValue(us_currency)),
    ("locale.currency.eu", StringValue(eu_currency)),
    ("locale.currency.ja", StringValue(japanese_currency)),
    ("locale.currency.zh", StringValue(chinese_currency))
  ]
  
  // éªŒè¯åŒºåŸŸè®¾ç½®å±æ€§
  assert_eq(locale_attributes.length(), 12)
  
  // æµ‹è¯•åŒºåŸŸè®¾ç½®æ ‡è¯†ç¬¦
  let locale_en_us = "en-US"
  let locale_en_gb = "en-GB"
  let locale_zh_cn = "zh-CN"
  let locale_zh_tw = "zh-TW"
  let locale_ja_jp = "ja-JP"
  let locale_ko_kr = "ko-KR"
  let locale_ar_sa = "ar-SA"
  let locale_ru_ru = "ru-RU"
  
  // åˆ›å»ºåŒºåŸŸè®¾ç½®æ ‡è¯†ç¬¦å±æ€§
  let locale_id_attributes = [
    ("locale.id.en.us", StringValue(locale_en_us)),
    ("locale.id.en.gb", StringValue(locale_en_gb)),
    ("locale.id.zh.cn", StringValue(locale_zh_cn)),
    ("locale.id.zh.tw", StringValue(locale_zh_tw)),
    ("locale.id.ja.jp", StringValue(locale_ja_jp)),
    ("locale.id.ko.kr", StringValue(locale_ko_kr)),
    ("locale.id.ar.sa", StringValue(locale_ar_sa)),
    ("locale.id.ru.ru", StringValue(locale_ru_ru))
  ]
  
  // éªŒè¯åŒºåŸŸè®¾ç½®æ ‡è¯†ç¬¦å±æ€§
  assert_eq(locale_id_attributes.length(), 8)
  
  // åˆ›å»ºæœ¬åœ°åŒ–èµ„æº
  let localized_resource = Resource({
    attributes: locale_attributes + locale_id_attributes,
    schema_url: Some("https://opentelemetry.io/schemas/1.20.0")
  })
  
  // éªŒè¯æœ¬åœ°åŒ–èµ„æº
  assert_eq(localized_resource.attributes.length(), 20)
}

// æµ‹è¯•5: å­—ç¬¦ç¼–ç è½¬æ¢
test "character encoding conversion" {
  // æµ‹è¯•UTF-8ç¼–ç çš„æ–‡æœ¬
  let utf8_chinese = "é¥æµ‹ç³»ç»Ÿ"
  let utf8_japanese = "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª"
  let utf8_korean = "ì›ê²© ì¸¡ì •"
  let utf8_arabic = "Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  let utf8_russian = "Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ñ"
  let utf8_emoji = "ğŸŒğŸ“Š"
  
  // éªŒè¯UTF-8æ–‡æœ¬
  assert_eq(utf8_chinese.length(), 4)
  assert_eq(utf8_japanese.length(), 5)
  assert_eq(utf8_korean.length(), 4)
  assert_eq(utf8_arabic.length(), 13)
  assert_eq(utf8_russian.length(), 9)
  assert_eq(utf8_emoji.length(), 2)
  
  // æµ‹è¯•ç¼–ç è½¬æ¢ï¼ˆæ¨¡æ‹Ÿï¼‰
  let encode_to_base64 = fn(text : String) -> String {
    // ç®€åŒ–çš„Base64ç¼–ç æ¨¡æ‹Ÿ
    if text == "é¥æµ‹ç³»ç»Ÿ" { "5Yqo5L2c5YaF5a65" }
    else if text == "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª" { "44OG44K/44OX44Oz" }
    else if text == "ì›ê²© ì¸¡ì •" { "66mV65Oc7J2A" }
    else if text == "Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯" { "2KfZhNi02LHZiNiv2YUg2KfZhNmE" }
    else if text == "Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ñ" { "0YLRgNC10LrRgtC+0YfQvdC10L3Rgg==" }
    else if text == "ğŸŒğŸ“Š" { "8J+MjvCfmJE=" }
    else { "base64:" + text }
  }
  
  let decode_from_base64 = fn(encoded : String) -> String {
    // ç®€åŒ–çš„Base64è§£ç æ¨¡æ‹Ÿ
    if encoded == "5Yqo5L2c5YaF5a65" { "é¥æµ‹ç³»ç»Ÿ" }
    else if encoded == "44OG44K/44OX44Oz" { "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒª" }
    else if encoded == "66mV65Oc7J2A" { "ì›ê²© ì¸¡ì •" }
    else if encoded == "2KfZhNi02LHZiNiv2YUg2KfZhNmE" { "Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯" }
    else if encoded == "0YLRgNC10LrRgtC+0YfQvdC10L3Rgg==" { "Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ñ" }
    else if encoded == "8J+MjvCfmJE=" { "ğŸŒğŸ“Š" }
    else if encoded.starts_with("base64:") { encoded.substring(7) }
    else { "unknown" }
  }
  
  // æµ‹è¯•ç¼–ç 
  let encoded_chinese = encode_to_base64(utf8_chinese)
  let encoded_japanese = encode_to_base64(utf8_japanese)
  let encoded_korean = encode_to_base64(utf8_korean)
  let encoded_arabic = encode_to_base64(utf8_arabic)
  let encoded_russian = encode_to_base64(utf8_russian)
  let encoded_emoji = encode_to_base64(utf8_emoji)
  
  // éªŒè¯ç¼–ç ç»“æœ
  assert_eq(encoded_chinese, "5Yqo5L2c5YaF5a65")
  assert_eq(encoded_japanese, "44OG44K/44OX44Oz")
  assert_eq(encoded_korean, "66mV65Oc7J2A")
  assert_eq(encoded_arabic, "2KfZhNi02LHZiNiv2YUg2KfZhNmE")
  assert_eq(encoded_russian, "0YLRgNC10LrRgtC+0YfQvdC10L3Rgg==")
  assert_eq(encoded_emoji, "8J+MjvCfmJE=")
  
  // æµ‹è¯•è§£ç 
  let decoded_chinese = decode_from_base64(encoded_chinese)
  let decoded_japanese = decode_from_base64(encoded_japanese)
  let decoded_korean = decode_from_base64(encoded_korean)
  let decoded_arabic = decode_from_base64(encoded_arabic)
  let decoded_russian = decode_from_base64(encoded_russian)
  let decoded_emoji = decode_from_base64(encoded_emoji)
  
  // éªŒè¯è§£ç ç»“æœ
  assert_eq(decoded_chinese, utf8_chinese)
  assert_eq(decoded_japanese, utf8_japanese)
  assert_eq(decoded_korean, utf8_korean)
  assert_eq(decoded_arabic, utf8_arabic)
  assert_eq(decoded_russian, utf8_russian)
  assert_eq(decoded_emoji, utf8_emoji)
  
  // åˆ›å»ºç¼–ç è½¬æ¢å±æ€§
  let encoding_attributes = [
    ("original.utf8.zh", StringValue(utf8_chinese)),
    ("encoded.base64.zh", StringValue(encoded_chinese)),
    ("decoded.utf8.zh", StringValue(decoded_chinese)),
    ("original.utf8.ja", StringValue(utf8_japanese)),
    ("encoded.base64.ja", StringValue(encoded_japanese)),
    ("decoded.utf8.ja", StringValue(decoded_japanese)),
    ("original.utf8.ko", StringValue(utf8_korean)),
    ("encoded.base64.ko", StringValue(encoded_korean)),
    ("decoded.utf8.ko", StringValue(decoded_korean))
  ]
  
  // éªŒè¯ç¼–ç è½¬æ¢å±æ€§
  assert_eq(encoding_attributes.length(), 9)
  
  // åˆ›å»ºç¼–ç è½¬æ¢èµ„æº
  let encoding_resource = Resource({
    attributes: encoding_attributes,
    schema_url: Some("https://opentelemetry.io/schemas/1.20.0")
  })
  
  // éªŒè¯ç¼–ç è½¬æ¢èµ„æº
  assert_eq(encoding_resource.attributes.length(), 9)
}

// æµ‹è¯•6: å¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯å¤„ç†
test "multilingual error message handling" {
  // åˆ›å»ºå¤šè¯­è¨€é”™è¯¯æ¶ˆæ¯
  let error_messages = [
    ("en", "Database connection failed"),
    ("zh", "æ•°æ®åº“è¿æ¥å¤±è´¥"),
    ("ja", "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸ"),
    ("ko", "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤"),
    ("ar", "ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"),
    ("ru", "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğº Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"),
    ("es", "Error de conexiÃ³n a la base de datos"),
    ("fr", "Ã‰chec de la connexion Ã  la base de donnÃ©es"),
    ("de", "Datenbankverbindung fehlgeschlagen"),
    ("pt", "Falha na conexÃ£o com o banco de dados")
  ]
  
  // éªŒè¯é”™è¯¯æ¶ˆæ¯
  assert_eq(error_messages.length(), 10)
  
  // åˆ›å»ºå¤šè¯­è¨€é”™è¯¯ä»£ç 
  let error_codes = [
    ("en", "DB_CONN_ERROR"),
    ("zh", "æ•°æ®åº“è¿æ¥é”™è¯¯"),
    ("ja", "DBæ¥ç¶šã‚¨ãƒ©ãƒ¼"),
    ("ko", "DBì—°ê²°ì˜¤ë¥˜"),
    ("ar", "Ø®Ø·Ø£ ÙÙŠ Ø§ØªØµØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª"),
    ("ru", "ĞĞ¨Ğ˜Ğ‘ĞšĞ_ĞŸĞĞ”ĞšĞ›Ğ®Ğ§Ğ•ĞĞ˜Ğ¯_Ğ‘Ğ”"),
    ("es", "ERROR_CONEXION_BD"),
    ("fr", "ERREUR_CONNEXION_BD"),
    ("de", "DB_VERBINDUNGSFEHLER"),
    ("pt", "ERRO_CONEXAO_BD")
  ]
  
  // éªŒè¯é”™è¯¯ä»£ç 
  assert_eq(error_codes.length(), 10)
  
  // åˆ›å»ºå¤šè¯­è¨€Spanäº‹ä»¶
  let multilingual_error_events = []
  
  for i = 0; i < error_messages.length(); i = i + 1 {
    let (locale, message) = error_messages[i]
    let (_, code) = error_codes[i]
    
    let error_event = Event({
      name: "database.error",
      timestamp: 1704067200000000000L + i.to_long(),
      attributes: [
        ("error.locale", StringValue(locale)),
        ("error.message", StringValue(message)),
        ("error.code", StringValue(code)),
        ("error.type", StringValue("database")),
        ("error.severity", StringValue("high"))
      ]
    })
    
    multilingual_error_events = multilingual_error_events + [error_event]
  }
  
  // éªŒè¯å¤šè¯­è¨€é”™è¯¯äº‹ä»¶
  assert_eq(multilingual_error_events.length(), 10)
  
  // åˆ›å»ºåŒ…å«å¤šè¯­è¨€é”™è¯¯äº‹ä»¶çš„Span
  let multilingual_error_span = Span({
    name: "database.operation.error",
    kind: Client,
    recording: true,
    span_context: SpanContext({
      trace_id: "1234567890abcdef1234567890abcdef",
      span_id: "1234567890abcdef",
      sampled: true,
      trace_state: ""
    }),
    parent_span_id: Some("parent1234567890"),
    attributes: [
      ("operation.type", StringValue("database.query")),
      ("operation.status", StringValue("failed"))
    ],
    events: multilingual_error_events,
    links: [],
    status: Error,
    start_time: 1704067200000000000L,
    end_time: Some(1704067200000000010L),
    duration: Some(10000000L) // 10ms
  })
  
  // éªŒè¯å¤šè¯­è¨€é”™è¯¯Span
  assert_eq(multilingual_error_span.name, "database.operation.error")
  assert_eq(multilingual_error_span.events.length(), 10)
  match multilingual_error_span.status {
    Error => assert_true(true)
    _ => assert_true(false)
  }
  
  // éªŒè¯ç‰¹å®šè¯­è¨€çš„é”™è¯¯äº‹ä»¶
  let chinese_error_event = multilingual_error_events[1]
  assert_eq(chinese_error_event.name, "database.error")
  
  let mut found_locale = false
  let mut found_message = false
  let mut found_code = false
  
  for (key, value) in chinese_error_event.attributes {
    match key {
      "error.locale" => {
        match value {
          StringValue(locale) => {
            assert_eq(locale, "zh")
            found_locale = true
          }
          _ => assert_true(false)
        }
      }
      "error.message" => {
        match value {
          StringValue(message) => {
            assert_eq(message, "æ•°æ®åº“è¿æ¥å¤±è´¥")
            found_message = true
          }
          _ => assert_true(false)
        }
      }
      "error.code" => {
        match value {
          StringValue(code) => {
            assert_eq(code, "æ•°æ®åº“è¿æ¥é”™è¯¯")
            found_code = true
          }
          _ => assert_true(false)
        }
      }
      _ => assert_true(false) // æ„å¤–çš„é”®
    }
  }
  
  assert_true(found_locale)
  assert_true(found_message)
  assert_true(found_code)
}

// æµ‹è¯•7: æ—¶åŒºå’Œæœ¬åœ°åŒ–æ—¶é—´å¤„ç†
test "timezone and localized time handling" {
  // æµ‹è¯•ä¸åŒæ—¶åŒºçš„æ—¶é—´æ ¼å¼
  let utc_time = "2023-01-01T00:00:00Z"
  let est_time = "2022-12-31T19:00:00-05:00"
  let pst_time = "2022-12-31T16:00:00-08:00"
  let jst_time = "2023-01-01T09:00:00+09:00"
  let cet_time = "2023-01-01T01:00:00+01:00"
  
  // éªŒè¯æ—¶åŒºæ—¶é—´æ ¼å¼
  assert_eq(utc_time.length(), 20)
  assert_eq(est_time.length(), 25)
  assert_eq(pst_time.length(), 25)
  assert_eq(jst_time.length(), 25)
  assert_eq(cet_time.length(), 25)
  
  // æµ‹è¯•ä¸åŒåŒºåŸŸçš„æ—¥æœŸæ—¶é—´æ ¼å¼
  let us_datetime = "01/01/2023 12:00:00 AM"
  let eu_datetime = "01/01/2023 00:00:00"
  let iso_datetime = "2023-01-01T00:00:00"
  let chinese_datetime = "2023å¹´01æœˆ01æ—¥ 00:00:00"
  let japanese_datetime = "2023å¹´01æœˆ01æ—¥ 00æ™‚00åˆ†00ç§’"
  
  // éªŒè¯åŒºåŸŸæ—¥æœŸæ—¶é—´æ ¼å¼
  assert_eq(us_datetime.length(), 22)
  assert_eq(eu_datetime.length(), 19)
  assert_eq(iso_datetime.length(), 19)
  assert_eq(chinese_datetime.length(), 20)
  assert_eq(japanese_datetime.length(), 23)
  
  // åˆ›å»ºæ—¶åŒºå’Œæœ¬åœ°åŒ–æ—¶é—´å±æ€§
  let timezone_attributes = [
    ("time.utc", StringValue(utc_time)),
    ("time.est", StringValue(est_time)),
    ("time.pst", StringValue(pst_time)),
    ("time.jst", StringValue(jst_time)),
    ("time.cet", StringValue(cet_time)),
    ("datetime.us", StringValue(us_datetime)),
    ("datetime.eu", StringValue(eu_datetime)),
    ("datetime.iso", StringValue(iso_datetime)),
    ("datetime.zh", StringValue(chinese_datetime)),
    ("datetime.ja", StringValue(japanese_datetime))
  ]
  
  // éªŒè¯æ—¶åŒºå±æ€§
  assert_eq(timezone_attributes.length(), 10)
  
  // åˆ›å»ºåŒ…å«æ—¶åŒºä¿¡æ¯çš„Span
  let timezone_span = Span({
    name: "timezone.aware.operation",
    kind: Internal,
    recording: true,
    span_context: SpanContext({
      trace_id: "1234567890abcdef1234567890abcdef",
      span_id: "1234567890abcdef",
      sampled: true,
      trace_state: ""
    }),
    parent_span_id: None,
    attributes: timezone_attributes,
    events: [
      Event({
        name: "operation.started",
        timestamp: 1672531200000000000L, // 2023-01-01 00:00:00 UTC
        attributes: [
          ("timezone", StringValue("UTC")),
          ("local.time", StringValue(utc_time))
        ]
      }),
      Event({
        name: "operation.completed",
        timestamp: 1672531260000000000L, // 2023-01-01 00:01:00 UTC
        attributes: [
          ("timezone", StringValue("UTC")),
          ("local.time", StringValue("2023-01-01T00:01:00Z"))
        ]
      })
    ],
    links: [],
    status: Ok,
    start_time: 1672531200000000000L,
    end_time: Some(1672531260000000000L),
    duration: Some(60000000000L) // 60 seconds
  })
  
  // éªŒè¯æ—¶åŒºæ„ŸçŸ¥Span
  assert_eq(timezone_span.name, "timezone.aware.operation")
  assert_eq(timezone_span.attributes.length(), 10)
  assert_eq(timezone_span.events.length(), 2)
  match timezone_span.status {
    Ok => assert_true(true)
    _ => assert_true(false)
  }
  
  // éªŒè¯SpanæŒç»­æ—¶é—´
  match timezone_span.duration {
    Some(duration) => assert_eq(duration, 60000000000L)
    None => assert_true(false)
  }
}