// Azimuth Premium Telemetry Data Integrity Tests
// é«˜è´¨é‡é¥æµ‹æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºæµ‹è¯•é¥æµ‹ç³»ç»Ÿä¸­æ•°æ®çš„å®Œæ•´æ€§ã€ä¸€è‡´æ€§å’Œå¯é æ€§

// æµ‹è¯•1: SpanContextæ•°æ®å®Œæ•´æ€§éªŒè¯
test "SpanContextæ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // 1. åˆ›å»ºæœ‰æ•ˆçš„SpanContext
  let span_context = SpanContext({
    trace_id: "12345678901234567890123456789012",
    span_id: "1234567890123456",
    sampled: true,
    trace_state: "key1=value1,key2=value2"
  })
  
  // 2. éªŒè¯trace_idæ ¼å¼å’Œé•¿åº¦
  assert_eq(span_context.trace_id.length(), 32)
  assert_true(span_context.trace_id.chars().all(fn(c) { 
    (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')
  }))
  
  // 3. éªŒè¯span_idæ ¼å¼å’Œé•¿åº¦
  assert_eq(span_context.span_id.length(), 16)
  assert_true(span_context.span_id.chars().all(fn(c) { 
    (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')
  }))
  
  // 4. éªŒè¯é‡‡æ ·æ ‡å¿—
  assert_true(span_context.sampled)
  
  // 5. éªŒè¯trace_stateæ ¼å¼
  assert_true(span_context.trace_state.contains("key1=value1"))
  assert_true(span_context.trace_state.contains("key2=value2"))
  
  // 6. åˆ›å»ºå¦ä¸€ä¸ªSpanContextè¿›è¡Œå¯¹æ¯”
  let span_context2 = SpanContext({
    trace_id: "12345678901234567890123456789012",
    span_id: "1234567890123457",
    sampled: true,
    trace_state: "key1=value1,key2=value2"
  })
  
  // 7. éªŒè¯ç›¸åŒtrace_idçš„ä¸åŒspan
  assert_eq(span_context.trace_id, span_context2.trace_id)
  assert_true(span_context.span_id != span_context2.span_id)
  
  // 8. åˆ›å»ºæœªé‡‡æ ·çš„SpanContext
  let unsampled_context = SpanContext({
    trace_id: "abcdef0123456789abcdef0123456789",
    span_id: "abcdef0123456789",
    sampled: false,
    trace_state: ""
  })
  
  // 9. éªŒè¯æœªé‡‡æ ·çš„SpanContext
  assert_false(unsampled_context.sampled)
  assert_eq(unsampled_context.trace_state, "")
}

// æµ‹è¯•2: Baggageæ•°æ®å®Œæ•´æ€§éªŒè¯
test "Baggageæ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // 1. åˆ›å»ºåŒ…å«å¤šä¸ªæ¡ç›®çš„Baggage
  let baggage = Baggage({
    entries: [
      ("user.id", "user123"),
      ("request.id", "req456"),
      ("session.id", "sess789"),
      ("tenant.id", "tenant001"),
      ("correlation.id", "corr123")
    ]
  })
  
  // 2. éªŒè¯Baggageæ¡ç›®æ•°é‡
  assert_eq(baggage.entries.length(), 5)
  
  // 3. éªŒè¯æ‰€æœ‰å¿…éœ€çš„æ¡ç›®å­˜åœ¨
  let mut user_id_found = false
  let mut request_id_found = false
  let mut session_id_found = false
  let mut tenant_id_found = false
  let mut correlation_id_found = false
  
  for (key, value) in baggage.entries {
    match key {
      "user.id" => {
        assert_eq(value, "user123")
        user_id_found = true
      }
      "request.id" => {
        assert_eq(value, "req456")
        request_id_found = true
      }
      "session.id" => {
        assert_eq(value, "sess789")
        session_id_found = true
      }
      "tenant.id" => {
        assert_eq(value, "tenant001")
        tenant_id_found = true
      }
      "correlation.id" => {
        assert_eq(value, "corr123")
        correlation_id_found = true
      }
      _ => assert_true(false, "æœªçŸ¥çš„Baggageæ¡ç›®: " + key)
    }
  }
  
  // 4. éªŒè¯æ‰€æœ‰æ¡ç›®éƒ½è¢«æ‰¾åˆ°
  assert_true(user_id_found, "user.idæ¡ç›®æœªæ‰¾åˆ°")
  assert_true(request_id_found, "request.idæ¡ç›®æœªæ‰¾åˆ°")
  assert_true(session_id_found, "session.idæ¡ç›®æœªæ‰¾åˆ°")
  assert_true(tenant_id_found, "tenant.idæ¡ç›®æœªæ‰¾åˆ°")
  assert_true(correlation_id_found, "correlation.idæ¡ç›®æœªæ‰¾åˆ°")
  
  // 5. åˆ›å»ºç©ºBaggageå¹¶éªŒè¯
  let empty_baggage = Baggage({ entries: [] })
  assert_eq(empty_baggage.entries.length(), 0)
  
  // 6. åˆ›å»ºåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„Baggage
  let special_baggage = Baggage({
    entries: [
      ("special.key", "value-with-special-chars!@#$%"),
      ("unicode.key", "å€¼åŒ…å«ä¸­æ–‡å’Œç‰¹æ®Šå­—ç¬¦ğŸŒŸ"),
      ("empty.value", ""),
      ("numeric.value", "12345")
    ]
  })
  
  // 7. éªŒè¯ç‰¹æ®Šå­—ç¬¦Baggage
  assert_eq(special_baggage.entries.length(), 4)
  for (key, value) in special_baggage.entries {
    match key {
      "special.key" => {
        assert_true(value.contains("!@#$%"))
      }
      "unicode.key" => {
        assert_true(value.contains("ä¸­æ–‡"))
        assert_true(value.contains("ğŸŒŸ"))
      }
      "empty.value" => {
        assert_eq(value, "")
      }
      "numeric.value" => {
        assert_eq(value, "12345")
      }
      _ => assert_true(false, "æœªçŸ¥çš„ç‰¹æ®ŠBaggageæ¡ç›®: " + key)
    }
  }
}

// æµ‹è¯•3: InstrumentationScopeæ•°æ®å®Œæ•´æ€§éªŒè¯
test "InstrumentationScopeæ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // 1. åˆ›å»ºå®Œæ•´çš„InstrumentationScope
  let scope = InstrumentationScope({
    name: "azimuth.telemetry",
    version: Some("1.0.0"),
    schema_url: Some("https://opentelemetry.io/schemas/v1.20.0")
  })
  
  // 2. éªŒè¯scopeåç§°
  assert_eq(scope.name, "azimuth.telemetry")
  assert_true(scope.name.length() > 0)
  assert_true(scope.name.contains("."))
  
  // 3. éªŒè¯ç‰ˆæœ¬ä¿¡æ¯
  match scope.version {
    Some(v) => {
      assert_eq(v, "1.0.0")
      assert_true(v.contains("."))
    }
    None => assert_true(false, "ç‰ˆæœ¬ä¿¡æ¯ä¸åº”ä¸ºNone")
  }
  
  // 4. éªŒè¯schema URL
  match scope.schema_url {
    Some(url) => {
      assert_true(url.contains("https://"))
      assert_true(url.contains("opentelemetry.io"))
      assert_true(url.contains("schemas"))
    }
    None => assert_true(false, "Schema URLä¸åº”ä¸ºNone")
  }
  
  // 5. åˆ›å»ºæœ€å°åŒ–çš„InstrumentationScope
  let minimal_scope = InstrumentationScope({
    name: "minimal.scope",
    version: None,
    schema_url: None
  })
  
  // 6. éªŒè¯æœ€å°åŒ–scope
  assert_eq(minimal_scope.name, "minimal.scope")
  match minimal_scope.version {
    None => assert_true(true)
    Some(_) => assert_true(false, "ç‰ˆæœ¬åº”ä¸ºNone")
  }
  match minimal_scope.schema_url {
    None => assert_true(true)
    Some(_) => assert_true(false, "Schema URLåº”ä¸ºNone")
  }
  
  // 7. åˆ›å»ºåªæœ‰ç‰ˆæœ¬ä¿¡æ¯çš„scope
  let version_only_scope = InstrumentationScope({
    name: "version.only.scope",
    version: Some("2.1.0"),
    schema_url: None
  })
  
  // 8. éªŒè¯åªæœ‰ç‰ˆæœ¬ä¿¡æ¯çš„scope
  assert_eq(version_only_scope.name, "version.only.scope")
  match version_only_scope.version {
    Some(v) => assert_eq(v, "2.1.0")
    None => assert_true(false, "ç‰ˆæœ¬ä¸åº”ä¸ºNone")
  }
  match version_only_scope.schema_url {
    None => assert_true(true)
    Some(_) => assert_true(false, "Schema URLåº”ä¸ºNone")
  }
}

// æµ‹è¯•4: Contextæ•°æ®å®Œæ•´æ€§éªŒè¯
test "Contextæ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // 1. åˆ›å»ºæœ‰æ•°æ®çš„Context
  let context_with_data = Context({
    data: Some(("key1", "value1"))
  })
  
  // 2. éªŒè¯æœ‰æ•°æ®çš„Context
  match context_with_data.data {
    Some((key, value)) => {
      assert_eq(key, "key1")
      assert_eq(value, "value1")
    }
    None => assert_true(false, "Contextæ•°æ®ä¸åº”ä¸ºNone")
  }
  
  // 3. åˆ›å»ºç©ºContext
  let empty_context = Context({ data: None })
  
  // 4. éªŒè¯ç©ºContext
  match empty_context.data {
    None => assert_true(true)
    Some(_) => assert_true(false, "Contextæ•°æ®åº”ä¸ºNone")
  }
  
  // 5. åˆ›å»ºåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„Context
  let special_context = Context({
    data: Some(("special-key!@#$%", "ç‰¹æ®Šå€¼-åŒ…å«ä¸­æ–‡å’Œç¬¦å·ğŸŒŸ"))
  })
  
  // 6. éªŒè¯ç‰¹æ®Šå­—ç¬¦Context
  match special_context.data {
    Some((key, value)) => {
      assert_true(key.contains("!@#$%"))
      assert_true(value.contains("ä¸­æ–‡"))
      assert_true(value.contains("ğŸŒŸ"))
    }
    None => assert_true(false, "ç‰¹æ®ŠContextæ•°æ®ä¸åº”ä¸ºNone")
  }
  
  // 7. åˆ›å»ºåŒ…å«é•¿å­—ç¬¦ä¸²çš„Context
  let long_key = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„é”®ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹é•¿é”®çš„å¤„ç†èƒ½åŠ›"
  let long_value = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å€¼ï¼Œç”¨äºæµ‹è¯•ç³»ç»Ÿå¯¹é•¿å€¼çš„å¤„ç†èƒ½åŠ›ã€‚"
                   + "å®ƒåŒ…å«äº†å¤šä¸ªå­—ç¬¦å’Œç‰¹æ®Šç¬¦å·ï¼Œä»¥åŠå„ç§è¾¹ç•Œæ¡ä»¶æµ‹è¯•ã€‚"
  let long_context = Context({
    data: Some((long_key, long_value))
  })
  
  // 8. éªŒè¯é•¿å­—ç¬¦ä¸²Context
  match long_context.data {
    Some((key, value)) => {
      assert_eq(key.length(), 27)
      assert_eq(value.length(), 58)
      assert_true(key.contains("é•¿é”®"))
      assert_true(value.contains("é•¿å€¼"))
    }
    None => assert_true(false, "é•¿å­—ç¬¦ä¸²Contextæ•°æ®ä¸åº”ä¸ºNone")
  }
}

// æµ‹è¯•5: TextMapCarrieræ•°æ®å®Œæ•´æ€§éªŒè¯
test "TextMapCarrieræ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•" {
  // 1. åˆ›å»ºåŒ…å«å¤šä¸ªheaderçš„TextMapCarrier
  let carrier = TextMapCarrier({
    headers: [
      ("traceparent", "00-12345678901234567890123456789012-1234567890123456-01"),
      ("tracestate", "key1=value1,key2=value2"),
      ("baggage", "user.id=user123,request.id=req456"),
      ("x-request-id", "req-123456"),
      ("x-correlation-id", "corr-789012"),
      ("content-type", "application/json"),
      ("user-agent", "azimuth-telemetry/1.0.0")
    ]
  })
  
  // 2. éªŒè¯headeræ•°é‡
  assert_eq(carrier.headers.length(), 7)
  
  // 3. éªŒè¯å…³é”®headerçš„å­˜åœ¨å’Œæ ¼å¼
  let mut traceparent_found = false
  let mut tracestate_found = false
  let mut baggage_found = false
  let mut request_id_found = false
  let mut correlation_id_found = false
  
  for (key, value) in carrier.headers {
    match key {
      "traceparent" => {
        assert_true(value.contains("00-"))
        assert_true(value.contains("-01"))
        traceparent_found = true
      }
      "tracestate" => {
        assert_true(value.contains("key1=value1"))
        assert_true(value.contains("key2=value2"))
        tracestate_found = true
      }
      "baggage" => {
        assert_true(value.contains("user.id=user123"))
        assert_true(value.contains("request.id=req456"))
        baggage_found = true
      }
      "x-request-id" => {
        assert_eq(value, "req-123456")
        request_id_found = true
      }
      "x-correlation-id" => {
        assert_eq(value, "corr-789012")
        correlation_id_found = true
      }
      "content-type" => {
        assert_eq(value, "application/json")
      }
      "user-agent" => {
        assert_eq(value, "azimuth-telemetry/1.0.0")
      }
      _ => assert_true(false, "æœªçŸ¥çš„header: " + key)
    }
  }
  
  // 4. éªŒè¯å…³é”®headeréƒ½è¢«æ‰¾åˆ°
  assert_true(traceparent_found, "traceparent headeræœªæ‰¾åˆ°")
  assert_true(tracestate_found, "tracestate headeræœªæ‰¾åˆ°")
  assert_true(baggage_found, "baggage headeræœªæ‰¾åˆ°")
  assert_true(request_id_found, "x-request-id headeræœªæ‰¾åˆ°")
  assert_true(correlation_id_found, "x-correlation-id headeræœªæ‰¾åˆ°")
  
  // 5. åˆ›å»ºç©ºçš„TextMapCarrier
  let empty_carrier = TextMapCarrier({ headers: [] })
  assert_eq(empty_carrier.headers.length(), 0)
  
  // 6. åˆ›å»ºåŒ…å«ç‰¹æ®Šå­—ç¬¦çš„TextMapCarrier
  let special_carrier = TextMapCarrier({
    headers: [
      ("x-special-header", "ç‰¹æ®Šå€¼-åŒ…å«ä¸­æ–‡å’Œç¬¦å·ğŸŒŸ"),
      ("x-empty-value", ""),
      ("x-numeric-value", "12345"),
      ("x-url-encoded", "key%20value%20with%20spaces")
    ]
  })
  
  // 7. éªŒè¯ç‰¹æ®Šå­—ç¬¦TextMapCarrier
  assert_eq(special_carrier.headers.length(), 4)
  for (key, value) in special_carrier.headers {
    match key {
      "x-special-header" => {
        assert_true(value.contains("ä¸­æ–‡"))
        assert_true(value.contains("ğŸŒŸ"))
      }
      "x-empty-value" => {
        assert_eq(value, "")
      }
      "x-numeric-value" => {
        assert_eq(value, "12345")
      }
      "x-url-encoded" => {
        assert_true(value.contains("%20"))
      }
      _ => assert_true(false, "æœªçŸ¥çš„ç‰¹æ®Šheader: " + key)
    }
  }
}

// æµ‹è¯•6: è·¨ç»„ä»¶æ•°æ®ä¸€è‡´æ€§éªŒè¯
test "è·¨ç»„ä»¶æ•°æ®ä¸€è‡´æ€§éªŒè¯æµ‹è¯•" {
  // 1. åˆ›å»ºSpanContext
  let span_context = SpanContext({
    trace_id: "abcdef0123456789abcdef0123456789",
    span_id: "abcdef0123456789",
    sampled: true,
    trace_state: "tenant=prod,env=production"
  })
  
  // 2. åˆ›å»ºBaggage
  let baggage = Baggage({
    entries: [
      ("user.id", "user123"),
      ("request.id", "req456"),
      ("tenant.id", "prod")
    ]
  })
  
  // 3. åˆ›å»ºTextMapCarrierå¹¶æ³¨å…¥æ•°æ®
  let carrier = TextMapCarrier({
    headers: [
      ("traceparent", "00-abcdef0123456789abcdef0123456789-abcdef0123456789-01"),
      ("tracestate", "tenant=prod,env=production"),
      ("baggage", "user.id=user123,request.id=req456,tenant.id=prod"),
      ("x-request-id", "req456"),
      ("x-tenant-id", "prod")
    ]
  })
  
  // 4. éªŒè¯trace_idä¸€è‡´æ€§
  assert_eq(span_context.trace_id, "abcdef0123456789abcdef0123456789")
  
  // 5. éªŒè¯carrierä¸­çš„traceparentåŒ…å«æ­£ç¡®çš„trace_idå’Œspan_id
  for (key, value) in carrier.headers {
    match key {
      "traceparent" => {
        assert_true(value.contains("abcdef0123456789abcdef0123456789"))
        assert_true(value.contains("abcdef0123456789"))
      }
      "tracestate" => {
        assert_true(value.contains("tenant=prod"))
        assert_true(value.contains("env=production"))
      }
      "baggage" => {
        assert_true(value.contains("user.id=user123"))
        assert_true(value.contains("request.id=req456"))
        assert_true(value.contains("tenant.id=prod"))
      }
      "x-request-id" => {
        assert_eq(value, "req456")
      }
      "x-tenant-id" => {
        assert_eq(value, "prod")
      }
      _ => () // å¿½ç•¥å…¶ä»–header
    }
  }
  
  // 6. éªŒè¯Baggageæ¡ç›®ä¸carrierä¸­baggage headerçš„ä¸€è‡´æ€§
  let mut baggage_user_id = ""
  let mut baggage_request_id = ""
  let mut baggage_tenant_id = ""
  
  for (key, value) in baggage.entries {
    match key {
      "user.id" => baggage_user_id = value
      "request.id" => baggage_request_id = value
      "tenant.id" => baggage_tenant_id = value
      _ => assert_true(false, "æœªçŸ¥çš„Baggageæ¡ç›®: " + key)
    }
  }
  
  assert_eq(baggage_user_id, "user123")
  assert_eq(baggage_request_id, "req456")
  assert_eq(baggage_tenant_id, "prod")
  
  // 7. éªŒè¯é‡‡æ ·æ ‡å¿—ä¸€è‡´æ€§
  assert_true(span_context.sampled)
  
  // 8. åˆ›å»ºInstrumentationScopeå¹¶éªŒè¯å‘½åä¸€è‡´æ€§
  let scope = InstrumentationScope({
    name: "azimuth.telemetry",
    version: Some("1.0.0"),
    schema_url: Some("https://opentelemetry.io/schemas/v1.20.0")
  })
  
  // 9. éªŒè¯scopeåç§°çš„ä¸€è‡´æ€§
  assert_true(scope.name.contains("azimuth"))
  assert_true(scope.name.contains("telemetry"))
  
  // 10. åˆ›å»ºContextå¹¶éªŒè¯æ•°æ®å…³è”æ€§
  let context = Context({
    data: Some(("operation.name", "telemetry.processing"))
  })
  
  // 11. éªŒè¯Contextæ•°æ®çš„å…³è”æ€§
  match context.data {
    Some((key, value)) => {
      assert_eq(key, "operation.name")
      assert_eq(value, "telemetry.processing")
      assert_true(value.contains("telemetry"))
    }
    None => assert_true(false, "Contextæ•°æ®ä¸åº”ä¸ºNone")
  }
}