// è¾¹ç•Œæ¡ä»¶å’Œé”™è¯¯å¤„ç†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Azimuthé¥æµ‹ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸º

test "ç©ºå€¼å’Œnullå±æ€§å¤„ç†" {
  // æµ‹è¯•ç©ºå€¼å’Œnullå±æ€§çš„å¤„ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.null.test")
  
  let span = Tracer::start_span(tracer, "null.attribute.test")
  
  // æµ‹è¯•è®¾ç½®ç©ºå­—ç¬¦ä¸²å±æ€§
  Span::set_attribute(span, "empty.string", "")
  
  // æµ‹è¯•è®¾ç½®nullå±æ€§ï¼ˆä½¿ç”¨å¯é€‰ç±»å‹ï¼‰
  Span::set_attribute(span, "optional.none", "")
  
  // æµ‹è¯•è®¾ç½®ç‰¹æ®Šå­—ç¬¦å±æ€§
  Span::set_attribute(span, "special.chars", "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  Span::set_attribute(span, "unicode.chars", "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ğŸš€emoji")
  Span::set_attribute(span, "newlines", "line1\nline2\rline3")
  
  // æµ‹è¯•è®¾ç½®éå¸¸é•¿çš„å±æ€§å€¼
  let long_string = String::repeat("a", 10000)
  Span::set_attribute(span, "long.string", long_string)
  
  // æµ‹è¯•æ·»åŠ ç©ºäº‹ä»¶
  Span::add_event(span, "", [])
  
  // æµ‹è¯•æ·»åŠ åŒ…å«ç©ºå€¼çš„äº‹ä»¶
  Span::add_event(span, "event.with.empty.attrs", [
    ("empty.value", ""),
    ("null.value", "")
  ])
  
  // éªŒè¯spanä»ç„¶æœ‰æ•ˆ
  let span_ctx = Span::span_context(span)
  assert_true(SpanContext::is_valid(span_ctx))
  
  Span::end(span)
  assert_true(true)
}

test "æå€¼å’Œè¾¹ç•Œå€¼å¤„ç†" {
  // æµ‹è¯•æå€¼å’Œè¾¹ç•Œå€¼çš„å¤„ç†
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary.extreme.test")
  
  // åˆ›å»ºè®¡æ•°å™¨å¹¶æµ‹è¯•æå€¼
  let counter = Meter::create_counter(meter, "extreme.counter", Some("Extreme counter"), Some("count"))
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(counter, Float::max_value())
  Counter::add(counter, 1.7976931348623157e+308)  // æ¥è¿‘æµ®ç‚¹æ•°æœ€å¤§å€¼
  
  // æµ‹è¯•æå°å€¼
  Counter::add(counter, Float::min_value())
  Counter::add(counter, 2.2250738585072014e-308)  // æ¥è¿‘æµ®ç‚¹æ•°æœ€å°æ­£å€¼
  
  // æµ‹è¯•é›¶å€¼
  Counter::add(counter, 0.0)
  
  // æµ‹è¯•è´Ÿå€¼
  Counter::add(counter, -1.0)
  Counter::add(counter, -Float::max_value())
  
  // æµ‹è¯•æ— ç©·å¤§å’ŒNaN
  Counter::add(counter, Float::infinity())
  Counter::add(counter, Float::neg_infinity())
  Counter::add(counter, Float::nan())
  
  // åˆ›å»ºç›´æ–¹å›¾å¹¶æµ‹è¯•æå€¼
  let histogram = Meter::create_histogram(
    meter, 
    "extreme.histogram", 
    Some("Extreme histogram"), 
    Some("ms")
  )
  
  // æµ‹è¯•æå€¼è®°å½•
  Histogram::record(histogram, Float::max_value())
  Histogram::record(histogram, Float::min_value())
  Histogram::record(histogram, 0.0)
  Histogram::record(histogram, -1.0)
  Histogram::record(histogram, Float::infinity())
  Histogram::record(histogram, Float::nan())
  
  // æµ‹è¯•æå€¼æ•´æ•°å±æ€§
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.integer.test")
  
  let span = Tracer::start_span(tracer, "extreme.integer.test")
  
  // æµ‹è¯•æå¤§æ•´æ•°
  Span::set_attribute(span, "max.int", Int::max_value())
  
  // æµ‹è¯•æå°æ•´æ•°
  Span::set_attribute(span, "min.int", Int::min_value())
  
  // æµ‹è¯•é›¶
  Span::set_attribute(span, "zero.int", 0)
  
  Span::end(span)
  assert_true(true)
}

test "èµ„æºé™åˆ¶æµ‹è¯•" {
  // æµ‹è¯•èµ„æºé™åˆ¶æƒ…å†µä¸‹çš„è¡Œä¸º
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.resource.test")
  
  // æµ‹è¯•åˆ›å»ºå¤§é‡span
  let max_spans = 100000
  let spans = []
  
  for i = 0; i < max_spans; i = i + 1 {
    let span = Tracer::start_span(tracer, "resource.test.span." + Int::to_string(i))
    Span::set_attribute(span, "index", Int::to_string(i))
    Array::push(spans, span)
    
    // æ¯1000ä¸ªspanæ£€æŸ¥ä¸€æ¬¡å†…å­˜ä½¿ç”¨
    if i % 1000 == 0 {
      let memory_usage = Memory::used()
      // å¦‚æœå†…å­˜ä½¿ç”¨è¿‡é«˜ï¼Œæå‰ç»“æŸæµ‹è¯•
      if memory_usage > 100 * 1024 * 1024 {  // 100MB
        break
      }
    }
  }
  
  // æ¸…ç†æ‰€æœ‰span
  for span in spans {
    Span::end(span)
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let span_with_many_attrs = Tracer::start_span(tracer, "many.attributes.test")
  
  // æ·»åŠ å¤§é‡å±æ€§
  for i = 0; i < 10000; i = i + 1 {
    Span::set_attribute(span_with_many_attrs, "attr." + Int::to_string(i), "value." + Int::to_string(i))
  }
  
  // æ·»åŠ å¤§é‡äº‹ä»¶
  for i = 0; i < 1000; i = i + 1 {
    Span::add_event(span_with_many_attrs, "event." + Int::to_string(i), [
      ("event.index", Int::to_string(i)),
      ("timestamp", Int::to_string(Time::now()))
    ])
  }
  
  Span::end(span_with_many_attrs)
  assert_true(true)
}

test "å¹¶å‘è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•å¹¶å‘æƒ…å†µä¸‹çš„è¾¹ç•Œæ¡ä»¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.concurrent.test")
  
  // æµ‹è¯•å¤§é‡å¹¶å‘spanåˆ›å»º
  let concurrent_count = 1000
  let spans = []
  
  for i = 0; i < concurrent_count; i = i + 1 {
    let span = Tracer::start_span(tracer, "concurrent.boundary.test." + Int::to_string(i))
    Span::set_attribute(span, "concurrent.index", Int::to_string(i))
    Array::push(spans, span)
  }
  
  // æµ‹è¯•å¹¶å‘å±æ€§è®¾ç½®
  for i = 0; i < concurrent_count; i = i + 1 {
    let span = Array::get(spans, i)
    Span::set_attribute(span, "concurrent.attr", "value." + Int::to_string(i))
  }
  
  // æµ‹è¯•å¹¶å‘äº‹ä»¶æ·»åŠ 
  for i = 0; i < concurrent_count; i = i + 1 {
    let span = Array::get(spans, i)
    Span::add_event(span, "concurrent.event", [
      ("event.index", Int::to_string(i)),
      ("concurrent.id", Int::to_string(i))
    ])
  }
  
  // æµ‹è¯•å¹¶å‘spanç»“æŸ
  for span in spans {
    Span::end(span)
  }
  
  assert_true(true)
}

test "é”™è¯¯æ¢å¤å’Œå¼‚å¸¸å¤„ç†" {
  // æµ‹è¯•é”™è¯¯æ¢å¤å’Œå¼‚å¸¸å¤„ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.error.recovery.test")
  
  // æµ‹è¯•åœ¨é”™è¯¯æƒ…å†µä¸‹åˆ›å»ºspan
  let error_span = Tracer::start_span(tracer, "error.recovery.test")
  
  // æ¨¡æ‹Ÿå„ç§é”™è¯¯æƒ…å†µ
  Span::set_status(error_span, Error, Some("Simulated error for testing"))
  
  // æ·»åŠ é”™è¯¯äº‹ä»¶
  Span::add_event(error_span, "error.occurred", [
    ("error.type", "TestError"),
    ("error.message", "This is a test error"),
    ("error.code", "TEST_001"),
    ("error.severity", "high")
  ])
  
  // æ·»åŠ æ¢å¤äº‹ä»¶
  Span::add_event(error_span, "recovery.started", [
    ("recovery.strategy", "retry"),
    ("max.retries", "3")
  ])
  
  Span::add_event(error_span, "recovery.completed", [
    ("recovery.result", "success"),
    ("retry.count", "2")
  ])
  
  // è®¾ç½®æˆåŠŸçŠ¶æ€è¡¨ç¤ºæ¢å¤
  Span::set_status(error_span, Ok, Some("Recovered from error"))
  
  Span::end(error_span)
  
  // æµ‹è¯•æ—¥å¿—é”™è¯¯å¤„ç†
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "boundary.error.logging")
  
  // åˆ›å»ºåŒ…å«é”™è¯¯ä¿¡æ¯çš„æ—¥å¿—
  let error_log = LogRecord::new(Error, "Error occurred and recovered")
  LogRecord::add_attribute(error_log, "error.type", "RecoverableError")
  LogRecord::add_attribute(error_log, "error.recovered", "true")
  LogRecord::add_attribute(error_log, "error.duration", "1500")
  
  Logger::emit(logger, error_log)
  
  assert_true(true)
}

test "æ•°æ®å®Œæ•´æ€§è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•æ•°æ®å®Œæ•´æ€§çš„è¾¹ç•Œæƒ…å†µ
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.integrity.test")
  
  // æµ‹è¯•æˆªæ–­çš„å­—ç¬¦ä¸²
  let truncated_span = Tracer::start_span(tracer, "truncated.test")
  let very_long_string = String::repeat("This is a very long string that might be truncated. ", 1000)
  Span::set_attribute(truncated_span, "truncated.value", very_long_string)
  
  // æµ‹è¯•ç‰¹æ®Šç¼–ç çš„å­—ç¬¦ä¸²
  let encoded_span = Tracer::start_span(tracer, "encoding.test")
  Span::set_attribute(encoded_span, "base64.value", "VGhpcyBpcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZw==")
  Span::set_attribute(encoded_span, "url.encoded", "This%20is%20URL%20encoded%20string")
  Span::set_attribute(encoded_span, "html.escaped", "&lt;script&gt;alert('test')&lt;/script&gt;")
  
  // æµ‹è¯•äºŒè¿›åˆ¶æ•°æ®
  let binary_span = Tracer::start_span(tracer, "binary.test")
  let binary_data = "\x00\x01\x02\x03\x04\x05\xFF\xFE\xFD"
  Span::set_attribute(binary_span, "binary.data", binary_data)
  
  // æµ‹è¯•JSONå­—ç¬¦ä¸²
  let json_span = Tracer::start_span(tracer, "json.test")
  let json_data = "{\"key\":\"value\",\"nested\":{\"array\":[1,2,3]},\"null\":null}"
  Span::set_attribute(json_span, "json.data", json_data)
  
  Span::end(truncated_span)
  Span::end(encoded_span)
  Span::end(binary_span)
  Span::end(json_span)
  
  // æµ‹è¯•åº¦é‡æ•°æ®å®Œæ•´æ€§
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary.integrity.metrics")
  
  // æµ‹è¯•ç²¾åº¦è¾¹ç•Œ
  let precision_counter = Meter::create_counter(meter, "precision.test", Some("Precision test"), Some("count"))
  Counter::add(precision_counter, 0.1)
  Counter::add(precision_counter, 0.01)
  Counter::add(precision_counter, 0.001)
  Counter::add(precision_counter, 0.0001)
  
  // æµ‹è¯•ç´¯åŠ ç²¾åº¦
  let accumulated_value = 0.0
  for i = 0; i < 10000; i = i + 1 {
    Counter::add(precision_counter, 0.0001)
  }
  
  assert_true(true)
}

test "æ—¶é—´ç›¸å…³è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•æ—¶é—´ç›¸å…³çš„è¾¹ç•Œæ¡ä»¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.time.test")
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let time_span = Tracer::start_span(tracer, "time.boundary.test")
  
  // æµ‹è¯•Unixçºªå…ƒæ—¶é—´
  let epoch_time = 0L
  Span::add_event(time_span, "epoch.time", [("timestamp", Int::to_string(epoch_time))])
  
  // æµ‹è¯•æå¤§æ—¶é—´æˆ³
  let max_time = 9223372036854775807L  // Int64æœ€å¤§å€¼
  Span::add_event(time_span, "max.time", [("timestamp", Int::to_string(max_time))])
  
  // æµ‹è¯•è´Ÿæ—¶é—´æˆ³
  let negative_time = -1000000L
  Span::add_event(time_span, "negative.time", [("timestamp", Int::to_string(negative_time))])
  
  // æµ‹è¯•å½“å‰æ—¶é—´
  let current_time = Time::now()
  Span::add_event(time_span, "current.time", [("timestamp", Int::to_string(current_time))])
  
  // æµ‹è¯•æœªæ¥æ—¶é—´
  let future_time = current_time + 86400000000000L  // 24å°æ—¶å
  Span::add_event(time_span, "future.time", [("timestamp", Int::to_string(future_time))])
  
  Span::end(time_span)
  
  // æµ‹è¯•æ—¥å¿—æ—¶é—´æˆ³è¾¹ç•Œ
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "boundary.time.logging")
  
  // åˆ›å»ºå¸¦æœ‰ä¸åŒæ—¶é—´æˆ³çš„æ—¥å¿—
  let epoch_log = LogRecord::new_with_timestamp(Info, "Epoch time log", epoch_time)
  let max_log = LogRecord::new_with_timestamp(Error, "Max time log", max_time)
  let negative_log = LogRecord::new_with_timestamp(Warn, "Negative time log", negative_time)
  let future_log = LogRecord::new_with_timestamp(Info, "Future time log", future_time)
  
  Logger::emit(logger, epoch_log)
  Logger::emit(logger, max_log)
  Logger::emit(logger, negative_log)
  Logger::emit(logger, future_log)
  
  assert_true(true)
}