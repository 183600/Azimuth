// é”™è¯¯è¾¹ç•Œæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸ºå’Œæ¢å¤èƒ½åŠ›

test "error_boundary_handling" {
  // 1. æµ‹è¯•ç©ºå€¼å’ŒNoneå€¼çš„å¤„ç†
  let meter_provider = metrics::NoopMeterProvider::{}
  let logger_provider = logs::NoopLoggerProvider::{}
  let tracer_provider = trace::NoopTracerProvider::{}
  
  let meter = meter_provider.get_meter("", None, None)  // ç©ºåç§°å’Œå¯é€‰å‚æ•°
  let logger = logger_provider.get_logger("test-logger", None, None)
  let tracer = tracer_provider.get_tracer("test-tracer", None)
  
  // éªŒè¯ç©ºå‚æ•°ä¸ä¼šå¯¼è‡´å´©æºƒ
  let counter = meter.create_counter("", None, None)
  let histogram = meter.create_histogram("test-histogram", "", "")
  
  // 2. æµ‹è¯•å¼‚å¸¸å±æ€§å€¼çš„å¤„ç†
  counter.add(
    1L,
    [
      ("empty-string", common::AttributeValue::string("")),
      ("zero-int", common::AttributeValue::int(0L)),
      ("negative-int", common::AttributeValue::int(-1L)),
      ("zero-float", common::AttributeValue::float(0.0)),
      ("negative-float", common::AttributeValue::float(-1.0)),
      ("false-bool", common::AttributeValue::bool(false)),
      ("empty-array", common::AttributeValue::array_string([]))
    ]
  )
  
  histogram.record(
    0.0,
    [
      ("infinity", common::AttributeValue::float(1.0 / 0.0)),  // æ— ç©·å¤§
      ("negative-infinity", common::AttributeValue::float(-1.0 / 0.0)),
      ("nan", common::AttributeValue::float(0.0 / 0.0))  // NaN
    ]
  )
  
  // 3. æµ‹è¯•å¼‚å¸¸å­—ç¬¦ä¸²å€¼çš„å¤„ç†
  let special_strings = [
    "",  // ç©ºå­—ç¬¦ä¸²
    " ",  // ç©ºæ ¼å­—ç¬¦ä¸²
    "\t\n\r",  // æ§åˆ¶å­—ç¬¦
    "null",  // nullå­—ç¬¦ä¸²
    "undefined",  // undefinedå­—ç¬¦ä¸²
    "very_long_string_" + "x" * 10000,  // æé•¿å­—ç¬¦ä¸²
    "unicode_æµ‹è¯•_ğŸš€_ç‰¹æ®Šå­—ç¬¦",  // Unicodeå­—ç¬¦
    "quotes\"'and\\backslashes",  // ç‰¹æ®Šå­—ç¬¦
    "html<script>alert('xss')</script>",  // HTML/JSæ³¨å…¥
    "path/../../../etc/passwd"  // è·¯å¾„éå†
  ]
  
  let mut str_index = 0
  while str_index < special_strings.length() {
    let test_string = special_strings[str_index]
    let string_attr = common::AttributeValue::string(test_string)
    
    // éªŒè¯ç‰¹æ®Šå­—ç¬¦ä¸²ä¸ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ
    match string_attr {
      common::StringValue(s) => @assertion.assert_eq(s, test_string)
      _ => @test.expect_failure("Expected string attribute")
    }
    
    str_index = str_index + 1
  }
  
  // 4. æµ‹è¯•å¼‚å¸¸æ•°å€¼çš„å¤„ç†
  let extreme_numbers = [
    9223372036854775807L,  // Int64æœ€å¤§å€¼
    -9223372036854775808L,  // Int64æœ€å°å€¼
    1.7976931348623157e+308,  // Doubleæœ€å¤§å€¼
    -1.7976931348623157e+308,  // Doubleæœ€å°å€¼
    4.9406564584124654e-324,  // Doubleæœ€å°æ­£å€¼
    0.0,  // é›¶
    -0.0,  // è´Ÿé›¶
    1.0 / 0.0,  // æ­£æ— ç©·
    -1.0 / 0.0,  // è´Ÿæ— ç©·
    0.0 / 0.0  // NaN
  ]
  
  let mut num_index = 0
  while num_index < extreme_numbers.length() {
    let test_number = extreme_numbers[num_index]
    let int_attr = common::AttributeValue::int(@int64.to_string(test_number))
    let float_attr = common::AttributeValue::float(test_number)
    
    // éªŒè¯æå€¼ä¸ä¼šå¯¼è‡´ç³»ç»Ÿå´©æºƒ
    match int_attr {
      common::IntValue(i) => @assertion.assert_eq(i, @int64.to_string(test_number))
      _ => @test.expect_failure("Expected int attribute")
    }
    
    match float_attr {
      common::FloatValue(f) => {
        if @test.is_nan(test_number) {
          @assertion.assert_true(@test.is_nan(f))
        } else {
          @assertion.assert_eq(f, test_number)
        }
      }
      _ => @test.expect_failure("Expected float attribute")
    }
    
    num_index = num_index + 1
  }
  
  // 5. æµ‹è¯•å¼‚å¸¸æ•°ç»„å€¼çš„å¤„ç†
  let empty_arrays = [
    common::AttributeValue::array_string([]),
    common::AttributeValue::array_int([]),
    common::AttributeValue::array_float([]),
    common::AttributeValue::array_bool([])
  ]
  
  let mut arr_index = 0
  while arr_index < empty_arrays.length() {
    let empty_array = empty_arrays[arr_index]
    
    match empty_array {
      common::ArrayStringValue(arr) => @assertion.assert_eq(arr.length(), 0)
      common::ArrayIntValue(arr) => @assertion.assert_eq(arr.length(), 0)
      common::ArrayFloatValue(arr) => @assertion.assert_eq(arr.length(), 0)
      common::ArrayBoolValue(arr) => @assertion.assert_eq(arr.length(), 0)
      _ => {}
    }
    
    arr_index = arr_index + 1
  }
  
  // 6. æµ‹è¯•å¤§æ•°ç»„çš„å¤„ç†
  let large_string_array = []
  let mut i = 0
  while i < 1000 {
    large_string_array.push("item-" + @int64.to_string(i))
    i = i + 1
  }
  
  let large_array_attr = common::AttributeValue::array_string(large_string_array)
  match large_array_attr {
    common::ArrayStringValue(arr) => {
      @assertion.assert_eq(arr.length(), 1000)
      @assertion.assert_eq(arr[0], "item-0")
      @assertion.assert_eq(arr[999], "item-999")
    }
    _ => @test.expect_failure("Expected array string attribute")
  }
  
  // 7. æµ‹è¯•ä¸Šä¸‹æ–‡çš„è¾¹ç•Œæƒ…å†µ
  let empty_context = context::Context::empty()
  let non_existent_key = context::create_key("non-existent-key")
  
  // éªŒè¯è·å–ä¸å­˜åœ¨çš„é”®è¿”å›None
  let non_existent_value = empty_context.get(non_existent_key)
  @assertion.assert_eq(non_existent_value, None)
  
  // æµ‹è¯•ç©ºé”®åçš„å¤„ç†
  let empty_key = context::create_key("")
  let context_with_empty_key = empty_context.with_value(empty_key, "empty-key-value")
  let empty_key_value = context_with_empty_key.get(empty_key)
  @assertion.assert_eq(empty_key_value?, "empty-key-value")
  
  // 8. æµ‹è¯•baggageçš„è¾¹ç•Œæƒ…å†µ
  let empty_baggage = context::Baggage::empty()
  let non_existent_entry = empty_baggage.get("non-existent-entry")
  @assertion.assert_eq(non_existent_entry, None)
  
  // æµ‹è¯•ç©ºé”®å’Œå€¼çš„å¤„ç†
  let baggage_with_empty = empty_baggage
    .with_entry("", "empty-key-value")
    .with_entry("empty-value-key", "")
    .with_entry("", "")
  
  let empty_key_value = baggage_with_empty.get("")
  let empty_value = baggage_with_empty.get("empty-value-key")
  
  @assertion.assert_eq(empty_key_value?, "")
  @assertion.assert_eq(empty_value?, "")
  
  // 9. æµ‹è¯•æ—¥å¿—è®°å½•çš„è¾¹ç•Œæƒ…å†µ
  let edge_case_log = logs::LogRecord::builder()
    .timestamp(0L)  // é›¶æ—¶é—´æˆ³
    .severity(logs::Trace)  // æœ€ä½ä¸¥é‡çº§åˆ«
    .body("")  // ç©ºæ¶ˆæ¯ä½“
    .with_attribute("", common::AttributeValue::string(""))  // ç©ºé”®å€¼å¯¹
    .build()
  
  logger.emit(edge_case_log)
  
  // æµ‹è¯•æå€¼æ—¶é—´æˆ³
  let max_timestamp_log = logs::LogRecord::builder()
    .timestamp(9223372036854775807L)  // Int64æœ€å¤§å€¼
    .severity(logs::Fatal)  // æœ€é«˜ä¸¥é‡çº§åˆ«
    .body("Maximum timestamp log")
    .build()
  
  logger.emit(max_timestamp_log)
  
  // 10. æµ‹è¯•é“¾è·¯è¿½è¸ªçš„è¾¹ç•Œæƒ…å†µ
  let ctx = context::Context::empty()
  
  // æµ‹è¯•ç©ºspanåç§°
  let (empty_span_ctx, empty_span) = tracer.start_span(
    ctx,
    "",
    trace::Internal,
    [],
    0L
  )
  
  @assertion.assert_eq(empty_span.name, "")
  @assertion.assert_eq(empty_span.kind, trace::Internal)
  @assertion.assert_eq(empty_span.start_time_unix_nanos, 0L)
  
  // æµ‹è¯•æé•¿spanåç§°
  let very_long_name = "very_long_span_name_" + "x" * 10000
  let (long_span_ctx, long_span) = tracer.start_span(
    ctx,
    very_long_name,
    trace::Server,
    [("long-name", common::AttributeValue::string(very_long_name))],
    9223372036854775807L
  )
  
  @assertion.assert_eq(long_span.name, very_long_name)
  @assertion.assert_eq(long_span.kind, trace::Server)
  @assertion.assert_eq(long_span.start_time_unix_nanos, 9223372036854775807L)
  
  // 11. æµ‹è¯•èµ„æºåˆ›å»ºçš„è¾¹ç•Œæƒ…å†µ
  let empty_resource = common::Resource::default("")
  @assertion.assert_eq(empty_resource.service_name, "")
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æœåŠ¡å
  let special_resource = common::Resource::default("service_withç‰¹æ®Š_chars_and spaces")
  @assertion.assert_eq(special_resource.service_name, "service_withç‰¹æ®Š_chars_and spaces")
  
  // 12. æµ‹è¯•ä»ªå™¨ä½œç”¨åŸŸçš„è¾¹ç•Œæƒ…å†µ
  let empty_scope = common::InstrumentationScope::{
    name: "",
    version: None,
    schema_url: None
  }
  
  let special_scope = common::InstrumentationScope::{
    name: "scope_withç‰¹æ®Š_chars",
    version: Some(""),
    schema_url: Some("")
  }
  
  @assertion.assert_eq(empty_scope.name, "")
  @assertion.assert_eq(empty_scope.version, None)
  @assertion.assert_eq(empty_scope.schema_url, None)
  
  @assertion.assert_eq(special_scope.name, "scope_withç‰¹æ®Š_chars")
  @assertion.assert_eq(special_scope.version?, "")
  @assertion.assert_eq(special_scope.schema_url?, "")
}

test "error_recovery_and_resilience" {
  // æµ‹è¯•é”™è¯¯æ¢å¤å’Œç³»ç»Ÿå¼¹æ€§
  
  // 1. æµ‹è¯•éƒ¨åˆ†å¤±è´¥æƒ…å†µä¸‹çš„ç³»ç»Ÿè¡Œä¸º
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("resilience-test")
  
  let counter = meter.create_counter("resilience-counter", "count", "Resilience test counter")
  
  // æ¨¡æ‹Ÿéƒ¨åˆ†æ“ä½œå¤±è´¥çš„æƒ…å†µ
  let mut successful_operations = 0
  let mut failed_operations = 0
  let total_operations = 100
  
  let mut i = 0
  while i < total_operations {
    // æ¨¡æ‹Ÿéšæœºå¤±è´¥ï¼ˆè¿™é‡Œç”¨ç®€å•çš„æ¨¡è¿ç®—æ¨¡æ‹Ÿï¼‰
    if i % 10 == 0 {
      // æ¨¡æ‹Ÿå¤±è´¥çš„æ“ä½œ
      failed_operations = failed_operations + 1
    } else {
      // æˆåŠŸçš„æ“ä½œ
      counter.add(1L, [("operation", common::AttributeValue::int(@int64.to_string(i)))])
      successful_operations = successful_operations + 1
    }
    i = i + 1
  }
  
  // éªŒè¯ç³»ç»Ÿåœ¨éƒ¨åˆ†å¤±è´¥æƒ…å†µä¸‹ä»ç„¶èƒ½å¤Ÿç»§ç»­å·¥ä½œ
  @assertion.assert_true(successful_operations > 0, "System should have successful operations")
  @assertion.assert_true(failed_operations < total_operations, "System should not fail completely")
  
  // 2. æµ‹è¯•å†…å­˜å‹åŠ›ä¸‹çš„ç³»ç»Ÿè¡Œä¸º
  let memory_pressure_operations = 1000
  
  let mut j = 0
  while j < memory_pressure_operations {
    // åˆ›å»ºå¤§é‡å¯¹è±¡ä»¥å¢åŠ å†…å­˜å‹åŠ›
    let large_attribute_array = []
    let mut k = 0
    while k < 100 {
      large_attribute_array.push((
        "large-attr-" + @int64.to_string(k),
        common::AttributeValue::string("large-value-" + @int64.to_string(j) + "-" + @int64.to_string(k))
      ))
      k = k + 1
    }
    
    // åœ¨å†…å­˜å‹åŠ›ä¸‹æ‰§è¡Œæ“ä½œ
    counter.add(
      1L,
      large_attribute_array
    )
    
    j = j + 1
  }
  
  // 3. æµ‹è¯•å¿«é€Ÿè¿ç»­æ“ä½œçš„ç¨³å®šæ€§
  let rapid_operations = 5000
  let rapid_start = @system.current_time_millis()
  
  let mut l = 0
  while l < rapid_operations {
    counter.add(1L, [("rapid", common::AttributeValue::int(@int64.to_string(l)))])
    l = l + 1
  }
  
  let rapid_end = @system.current_time_millis()
  let rapid_duration = rapid_end - rapid_start
  
  // éªŒè¯å¿«é€Ÿæ“ä½œä¸ä¼šå¯¼è‡´ç³»ç»Ÿä¸ç¨³å®š
  @assertion.assert_true(rapid_duration < 10000, "Rapid operations should complete quickly")
  
  // 4. æµ‹è¯•èµ„æºè€—å°½æƒ…å†µä¸‹çš„è¡Œä¸º
  let resource_exhaustion_test = true
  
  if resource_exhaustion_test {
    // åˆ›å»ºå¤§é‡ä¸Šä¸‹æ–‡å¯¹è±¡
    let mut contexts = []
    let mut m = 0
    while m < 100 {
      let ctx = context::Context::empty()
      let key = context::create_key("resource-test-" + @int64.to_string(m))
      let ctx_with_value = ctx.with_value(key, "value-" + @int64.to_string(m))
      contexts.push(ctx_with_value)
      m = m + 1
    }
    
    // éªŒè¯åœ¨èµ„æºå‹åŠ›ä¸‹ç³»ç»Ÿä»ç„¶èƒ½å¤Ÿåˆ›å»ºæ–°å¯¹è±¡
    let emergency_ctx = context::Context::empty()
    let emergency_key = context::create_key("emergency")
    let emergency_ctx_with_value = emergency_ctx.with_value(emergency_key, "emergency-value")
    
    let emergency_value = emergency_ctx_with_value.get(emergency_key)
    @assertion.assert_eq(emergency_value?, "emergency-value")
  }
  
  // 5. æµ‹è¯•å¼‚å¸¸è¾“å…¥çš„è¿‡æ»¤å’Œæ¸…ç†
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("resilience-logger")
  
  // æµ‹è¯•åŒ…å«æ½œåœ¨æ¶æ„å†…å®¹çš„æ—¥å¿—
  let malicious_inputs = [
    "<script>alert('xss')</script>",
    "'; DROP TABLE users; --",
    "../../../etc/passwd",
    "\x00\x01\x02\x03",  // äºŒè¿›åˆ¶æ•°æ®
    "null",
    "undefined",
    String.from_char_code(0) + "control chars",  // æ§åˆ¶å­—ç¬¦
    "ğŸš€ğŸ”¥ğŸ’¯âš¡ï¸"  // Emoji
  ]
  
  let mut input_index = 0
  while input_index < malicious_inputs.length() {
    let malicious_input = malicious_inputs[input_index]
    
    let sanitized_log = logs::LogRecord::builder()
      .timestamp(@system.current_time_millis() * 1000000L)
      .severity(logs::Warn)
      .body("Sanitized input: " + malicious_input)
      .with_attribute("original-length", common::AttributeValue::int(malicious_input.length().to_string()))
      .build()
    
    logger.emit(sanitized_log)
    input_index = input_index + 1
  }
  
  // 6. æµ‹è¯•ç³»ç»ŸçŠ¶æ€çš„ä¸€è‡´æ€§ç»´æŠ¤
  let consistency_check = true
  
  if consistency_check {
    // éªŒè¯ç³»ç»ŸçŠ¶æ€åœ¨å¼‚å¸¸æƒ…å†µä¸‹ä¿æŒä¸€è‡´
    let meter2 = meter_provider.get_meter("consistency-check")
    let counter2 = meter2.create_counter("consistency-counter", "count", "Consistency check counter")
    
    // æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œ
    counter2.add(1L, [("step", common::AttributeValue::string("1"))])
    counter2.add(1L, [("step", common::AttributeValue::string("2"))])
    counter2.add(1L, [("step", common::AttributeValue::string("3"))])
    
    // éªŒè¯ç³»ç»ŸçŠ¶æ€ä»ç„¶å¯ç”¨
    let final_counter = meter2.create_counter("final-counter", "count", "Final counter")
    final_counter.add(1L, [("status", common::AttributeValue::string("consistent"))])
  }
  
  // 7. éªŒè¯é”™è¯¯æ¢å¤åçš„æ­£å¸¸åŠŸèƒ½
  let recovery_counter = meter.create_counter("recovery-counter", "count", "Recovery test counter")
  recovery_counter.add(1L, [("recovered", common::AttributeValue::bool(true))])
  
  // ç³»ç»Ÿåº”è¯¥èƒ½å¤Ÿåœ¨å¼‚å¸¸æƒ…å†µåæ¢å¤æ­£å¸¸åŠŸèƒ½
  @assertion.assert_true(true, "System should recover from errors gracefully")
}

test "graceful_degradation" {
  // æµ‹è¯•ä¼˜é›…é™çº§åŠŸèƒ½
  
  // 1. æµ‹è¯•åœ¨èµ„æºå—é™æƒ…å†µä¸‹çš„é™çº§è¡Œä¸º
  let meter_provider = metrics::NoopMeterProvider::{}
  let meter = meter_provider.get_meter("degradation-test")
  
  // æ¨¡æ‹Ÿé«˜è´Ÿè½½æƒ…å†µ
  let high_load_operations = 10000
  
  // åœ¨é«˜è´Ÿè½½ä¸‹ï¼Œç³»ç»Ÿåº”è¯¥é™çº§è€Œä¸æ˜¯å´©æºƒ
  let mut successful_degraded_operations = 0
  let mut i = 0
  while i < high_load_operations {
    // ç®€åŒ–æ“ä½œä»¥å®ç°é™çº§
    let simple_counter = meter.create_counter("simple-counter", "count", "Simple counter")
    simple_counter.add(1L, [])
    successful_degraded_operations = successful_degraded_operations + 1
    
    // æ¯1000æ¬¡æ“ä½œæ£€æŸ¥ä¸€æ¬¡ç³»ç»ŸçŠ¶æ€
    if i % 1000 == 0 and i > 0 {
      // ç³»ç»Ÿåº”è¯¥ä»ç„¶å“åº”
      let status_counter = meter.create_counter("status-counter", "count", "Status counter")
      status_counter.add(1L, [("status", common::AttributeValue::string("degraded-but-functional"))])
    }
    
    i = i + 1
  }
  
  // éªŒè¯é™çº§æ¨¡å¼ä¸‹ç³»ç»Ÿä»ç„¶èƒ½å¤Ÿå¤„ç†è¯·æ±‚
  @assertion.assert_true(successful_degraded_operations > high_load_operations * 0.95, "System should handle most operations in degraded mode")
  
  // 2. æµ‹è¯•åŠŸèƒ½é™çº§
  let logger_provider = logs::NoopLoggerProvider::{}
  let logger = logger_provider.get_logger("degradation-logger")
  
  // åœ¨é™çº§æ¨¡å¼ä¸‹ï¼Œç®€åŒ–æ—¥å¿—åŠŸèƒ½
  let simplified_log = logs::LogRecord::builder()
    .timestamp(@system.current_time_millis() * 1000000L)
    .severity(logs::Info)
    .body("Simplified log in degraded mode")
    // å‡å°‘å±æ€§æ•°é‡ä»¥é™ä½è´Ÿè½½
    .with_attribute("mode", common::AttributeValue::string("degraded"))
    .build()
  
  logger.emit(simplified_log)
  
  // 3. éªŒè¯é™çº§åçš„æ¢å¤èƒ½åŠ›
  let recovery_counter = meter.create_counter("recovery-counter", "count", "Recovery counter")
  
  // æ¨¡æ‹Ÿä»é™çº§çŠ¶æ€æ¢å¤
  let mut recovery_operations = 0
  let mut j = 0
  while j < 1000 {
    recovery_counter.add(1L, [("recovery", common::AttributeValue::int(@int64.to_string(j)))])
    recovery_operations = recovery_operations + 1
    j = j + 1
  }
  
  @assertion.assert_eq(recovery_operations, 1000, "System should recover full functionality")
  
  // 4. éªŒè¯é™çº§æœŸé—´çš„æ•°æ®å®Œæ•´æ€§
  let integrity_counter = meter.create_counter("integrity-counter", "count", "Integrity counter")
  integrity_counter.add(1L, [("integrity", common::AttributeValue::string("maintained"))])
  
  // å³ä½¿åœ¨é™çº§æ¨¡å¼ä¸‹ï¼Œæ•°æ®å®Œæ•´æ€§ä¹Ÿåº”è¯¥å¾—åˆ°ä¿è¯
  @assertion.assert_true(true, "Data integrity should be maintained during degradation")
}