// é”™è¯¯å¤„ç†å’Œè¾¹ç•Œæ¡ä»¶æµ‹è¯•
// æµ‹è¯•é¥æµ‹ç³»ç»Ÿåœ¨å„ç§è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º

use azimuth.telemetry.api.trace
use azimuth.telemetry.api.context
use azimuth.telemetry.api.common

test "empty_string_handling" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å¤„ç†
  let empty_name = ""
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("test-tracer", "1.0.0")
  let ctx = context::Context::current()
  
  let (_, span) = tracer.start_span(ctx, empty_name, trace::Internal)
  assert_eq(span.name, "")
  
  // æµ‹è¯•ç©ºå±æ€§å€¼
  let empty_attr = common::AttributeValue::string("")
  match empty_attr {
    common::StringValue(s) => assert_eq(s, "")
    _ => assert_eq(false, true, "Expected empty string")
  }
}

test "null_and_none_handling" {
  // æµ‹è¯•Noneå€¼å¤„ç†
  let resource = common::Resource::default("test")
  assert_eq(resource.service_version, None)
  
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("test", None)
  let ctx = context::Context::current()
  
  let (_, span) = tracer.start_span(ctx, "test", None, None, None)
  assert_eq(span.parent_span_id, None)
  assert_eq(span.end_time_unix_nanos, None)
  assert_eq(span.status_description, None)
}

test "maximum_limits_test" {
  // æµ‹è¯•æœ€å¤§é™åˆ¶
  let long_string = "a" * 1000  // åˆ›å»º1000å­—ç¬¦çš„å­—ç¬¦ä¸²
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer(long_string, "1.0.0")
  let ctx = context::Context::current()
  
  let (_, span) = tracer.start_span(ctx, long_string, trace::Internal)
  assert_eq(span.name.length(), 1000)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let mut large_attrs : Array[(String, common::AttributeValue)] = []
  for i = 0; i < 100; i = i + 1 {
    large_attrs = large_attrs.push(("key-" + i.to_string(), common::AttributeValue::int(i.to_int64())))
  }
  
  let (_, span_with_attrs) = tracer.start_span(ctx, "large-attrs", trace::Internal, large_attrs)
  assert_eq(span_with_attrs.attributes.length(), 100)
}

test "numeric_boundary_test" {
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œ
  let max_int64 = 9223372036854775807L
  let min_int64 = -9223372036854775808L
  let max_double = 1.7976931348623157e+308
  let min_double = -1.7976931348623157e+308
  
  let max_attr = common::AttributeValue::int(max_int64)
  let min_attr = common::AttributeValue::int(min_int64)
  let max_float_attr = common::AttributeValue::float(max_double)
  let min_float_attr = common::AttributeValue::float(min_double)
  
  match max_attr {
    common::IntValue(i) => assert_eq(i, max_int64)
    _ => assert_eq(false, true, "Expected max int64")
  }
  
  match min_attr {
    common::IntValue(i) => assert_eq(i, min_int64)
    _ => assert_eq(false, true, "Expected min int64")
  }
  
  match max_float_attr {
    common::FloatValue(f) => assert_eq(f, max_double)
    _ => assert_eq(false, true, "Expected max double")
  }
  
  match min_float_attr {
    common::FloatValue(f) => assert_eq(f, min_double)
    _ => assert_eq(false, true, "Expected min double")
  }
}

test "invalid_data_handling" {
  // æµ‹è¯•æ— æ•ˆæ•°æ®å¤„ç†
  let tracer_provider = trace::NoopTracerProvider::{}
  let tracer = tracer_provider.get_tracer("test", "1.0.0")
  let ctx = context::Context::current()
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let (_, span) = tracer.start_span(ctx, special_chars, trace::Internal)
  assert_eq(span.name, special_chars)
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•ğŸš€emoji"
  let (_, unicode_span) = tracer.start_span(ctx, unicode_string, trace::Internal)
  assert_eq(unicode_span.name, unicode_string)
  
  // æµ‹è¯•æ··åˆç±»å‹æ•°ç»„
  let mixed_attrs = [
    ("string", common::AttributeValue::string("value")),
    ("int", common::AttributeValue::int(42L)),
    ("float", common::AttributeValue::float(3.14)),
    ("bool", common::AttributeValue::bool(true))
  ]
  
  let (_, mixed_span) = tracer.start_span(ctx, "mixed", trace::Internal, mixed_attrs)
  assert_eq(mixed_span.attributes.length(), 4)
}