// Azimuth Premium Internationalization Tests
// This file contains high-quality test cases for internationalization support

// Test 1: Unicode Character Handling
test "unicode character handling" {
  // Test different Unicode character categories
  let ascii_text = "Hello World"
  let latin_text = "HÃ©llo WÃ¶rld"
  let chinese_text = "ä½ å¥½ä¸–ç•Œ"
  let japanese_text = "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ"
  let arabic_text = "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"
  let russian_text = "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€"
  let emoji_text = "Hello ğŸŒ World! ğŸ‰"
  let mixed_text = "Hello ä½ å¥½ ã“ã‚“ã«ã¡ã¯ Ù…Ø±Ø­Ø¨Ø§ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ ğŸŒ"
  
  // Test string length with Unicode characters
  assert_eq(ascii_text.length(), 11)
  assert_eq(latin_text.length(), 11) // Accented characters count as single units
  assert_eq(chinese_text.length(), 4)
  assert_eq(japanese_text.length(), 7)
  assert_eq(arabic_text.length(), 12)
  assert_eq(russian_text.length(), 11)
  assert_eq(emoji_text.length(), 15) // Emoji count as single units
  assert_eq(mixed_text.length(), 23)
  
  // Test Unicode character code points
  let get_code_point = fn(text : String, index : Int) -> Int {
    let chars = text.to_char_array()
    if index >= 0 && index < chars.length() {
      chars[index].to_int()
    } else {
      0
    }
  }
  
  // ASCII characters
  assert_eq(get_code_point(ascii_text, 0), 72) // 'H'
  assert_eq(get_code_point(ascii_text, 10), 100) // 'd'
  
  // Latin extended characters
  assert_eq(get_code_point(latin_text, 1), 233) // 'Ã©'
  assert_eq(get_code_point(latin_text, 7), 246) // 'Ã¶'
  
  // Chinese characters
  assert_eq(get_code_point(chinese_text, 0), 20320) // 'ä½ '
  assert_eq(get_code_point(chinese_text, 1), 22909) // 'å¥½'
  assert_eq(get_code_point(chinese_text, 2), 19990) // 'ä¸–'
  assert_eq(get_code_point(chinese_text, 3), 30028) // 'ç•Œ'
  
  // Emoji characters
  assert_eq(get_code_point(emoji_text, 6), 127757) // ğŸŒ
  assert_eq(get_code_point(emoji_text, 13), 127881) // ğŸ‰
  
  // Test Unicode normalization
  let normalize_nfc = fn(text : String) -> String {
    // Simplified NFC normalization (would use proper Unicode library in real implementation)
    text
  }
  
  let normalize_nfd = fn(text : String) -> String {
    // Simplified NFD normalization (would use proper Unicode library in real implementation)
    text
  }
  
  let composed = "Ã©"
  let decomposed = "e\u0301" // e + combining acute accent
  
  let nfc_composed = normalize_nfc(composed)
  let nfc_decomposed = normalize_nfc(decomposed)
  
  // Both should normalize to the same form
  assert_eq(nfc_composed, nfc_decomposed)
}

// Test 2: Text Direction and RTL Support
test "text direction and rtl support" {
  // Test text direction detection
  type TextDirection {
    LeftToRight
    RightToLeft
    Auto
  }
  
  let detect_text_direction = fn(text : String) -> TextDirection {
    let chars = text.to_char_array()
    let mut rtl_count = 0
    let mut ltr_count = 0
    
    for char in chars {
      let code_point = char.to_int()
      
      // Simplified RTL character ranges (Arabic, Hebrew)
      if (code_point >= 1536 && code_point <= 1791) || // Arabic
         (code_point >= 1424 && code_point <= 1535) || // Hebrew
         (code_point >= 1792 && code_point <= 1871) {  // Arabic extended
        rtl_count = rtl_count + 1
      }
      
      // Simplified LTR character ranges (Latin, Cyrillic)
      if (code_point >= 65 && code_point <= 90) ||    // Latin uppercase
         (code_point >= 97 && code_point <= 122) ||   // Latin lowercase
         (code_point >= 1024 && code_point <= 1279) {  // Cyrillic
        ltr_count = ltr_count + 1
      }
    }
    
    if rtl_count > ltr_count {
      RightToLeft
    } else if ltr_count > rtl_count {
      LeftToRight
    } else {
      Auto
    }
  }
  
  // Test direction detection
  assert_eq(detect_text_direction("Hello World"), LeftToRight)
  assert_eq(detect_text_direction("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"), RightToLeft)
  assert_eq(detect_text_direction("ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€"), LeftToRight)
  assert_eq(detect_text_direction("12345"), Auto) // Numbers are neutral
  
  // Test bidirectional text
  let mixed_ltr_rtl = "Hello Ù…Ø±Ø­Ø¨Ø§ World"
  assert_eq(detect_text_direction(mixed_ltr_rtl), LeftToRight) // More LTR characters
  
  let mixed_rtl_ltr = "Ù…Ø±Ø­Ø¨Ø§ Hello Ø§Ù„Ø¹Ø§Ù„Ù…"
  assert_eq(detect_text_direction(mixed_rtl_ltr), RightToLeft) // More RTL characters
  
  // Test directional formatting characters
  let lrm = "\u200E" // Left-to-Right Mark
  let rlm = "\u200F" // Right-to-Left Mark
  let lre = "\u202A" // Left-to-Right Embedding
  let rle = "\u202B" // Right-to-Left Embedding
  let pdf = "\u202C" // Pop Directional Formatting
  
  // Test with directional marks
  let rtl_with_lrm = rlm + "Ù…Ø±Ø­Ø¨Ø§" + lrm + "Hello"
  assert_eq(detect_text_direction(rtl_with_lrm), RightToLeft)
  
  let ltr_with_rlm = lrm + "Hello" + rlm + "Ù…Ø±Ø­Ø¨Ø§"
  assert_eq(detect_text_direction(ltr_with_rlm), LeftToRight)
}

// Test 3: Locale-Aware Operations
test "locale-aware operations" {
  // Locale definition
  type Locale {
    language : String
    region : String
    script : String
  }
  
  let create_locale = fn(language : String, region : String, script : String) -> Locale {
    Locale { 
      language: language, 
      region: region, 
      script: script 
    }
  }
  
  let locale_to_string = fn(locale : Locale) -> String {
    let mut result = locale.language
    
    if locale.script.length() > 0 {
      result = result + "-" + locale.script
    }
    
    if locale.region.length() > 0 {
      result = result + "-" + locale.region
    }
    
    result
  }
  
  // Test locale creation and string representation
  let us_english = create_locale("en", "US", "")
  assert_eq(locale_to_string(us_english), "en-US")
  
  let chinese_simplified = create_locale("zh", "CN", "Hans")
  assert_eq(locale_to_string(chinese_simplified), "zh-Hans-CN")
  
  let japanese = create_locale("ja", "JP", "")
  assert_eq(locale_to_string(japanese), "ja-JP")
  
  let arabic_egypt = create_locale("ar", "EG", "")
  assert_eq(locale_to_string(arabic_egypt), "ar-EG")
  
  // Test locale-aware string comparison
  let locale_compare = fn(str1 : String, str2 : String, locale : Locale) -> Int {
    // Simplified locale-aware comparison (would use proper collation in real implementation)
    match locale.language {
      "en" => {
        // English comparison
        if str1 < str2 { -1 } else if str1 > str2 { 1 } else { 0 }
      }
      "zh" => {
        // Chinese comparison (simplified - would use proper pinyin/radical ordering)
        if str1 < str2 { -1 } else if str1 > str2 { 1 } else { 0 }
      }
      "ar" => {
        // Arabic comparison (right-to-left aware)
        if str1 < str2 { -1 } else if str1 > str2 { 1 } else { 0 }
      }
      _ => {
        // Default comparison
        if str1 < str2 { -1 } else if str1 > str2 { 1 } else { 0 }
      }
    }
  }
  
  // Test locale-aware comparison
  assert_eq(locale_compare("apple", "banana", us_english), -1)
  assert_eq(locale_compare("banana", "apple", us_english), 1)
  assert_eq(locale_compare("apple", "apple", us_english), 0)
  
  assert_eq(locale_compare("è‹¹æœ", "é¦™è•‰", chinese_simplified), -1)
  assert_eq(locale_compare("é¦™è•‰", "è‹¹æœ", chinese_simplified), 1)
  
  assert_eq(locale_compare("ØªÙØ§Ø­Ø©", "Ù…ÙˆØ²", arabic_egypt), -1)
  assert_eq(locale_compare("Ù…ÙˆØ²", "ØªÙØ§Ø­Ø©", arabic_egypt), 1)
  
  // Test locale-aware case conversion
  let locale_to_upper = fn(text : String, locale : Locale) -> String {
    match locale.language {
      "en" => text.to_uppercase(),
      "tr" => {
        // Turkish has special case rules (i â†’ Ä°, Ä± â†’ I)
        let chars = text.to_char_array()
        let mut result = ""
        
        for char in chars {
          let code = char.to_int()
          if code == 105 { // 'i'
            result = result + "Ä°"
          } else if code == 305 { // 'Ä±'
            result = result + "I"
          } else {
            result = result + char.to_uppercase().to_string()
          }
        }
        
        result
      }
      _ => text.to_uppercase()
    }
  }
  
  let locale_to_lower = fn(text : String, locale : Locale) -> String {
    match locale.language {
      "en" => text.to_lowercase(),
      "tr" => {
        // Turkish has special case rules (I â†’ Ä±, Ä° â†’ i)
        let chars = text.to_char_array()
        let mut result = ""
        
        for char in chars {
          let code = char.to_int()
          if code == 73 { // 'I'
            result = result + "Ä±"
          } else if code == 304 { // 'Ä°'
            result = result + "i"
          } else {
            result = result + char.to_lowercase().to_string()
          }
        }
        
        result
      }
      _ => text.to_lowercase()
    }
  }
  
  // Test Turkish special case rules
  let turkish = create_locale("tr", "TR", "")
  let test_text = "LIÄ°iÄ±"
  
  let turkish_upper = locale_to_upper(test_text, turkish)
  let turkish_lower = locale_to_lower(test_text, turkish)
  
  assert_eq(turkish_upper, "LIÄ°IÄ°")
  assert_eq(turkish_lower, "liÄ±iÄ±")
  
  // Compare with English case conversion
  let english = create_locale("en", "US", "")
  let english_upper = locale_to_upper(test_text, english)
  let english_lower = locale_to_lower(test_text, english)
  
  assert_eq(english_upper, "LIÄ°II")
  assert_eq(english_lower, "liiii")
}

// Test 4: Date and Time Formatting
test "date and time formatting" {
  // Date/time components
  type DateTime {
    year : Int
    month : Int
    day : Int
    hour : Int
    minute : Int
    second : Int
  }
  
  let create_datetime = fn(year : Int, month : Int, day : Int, hour : Int, minute : Int, second : Int) -> DateTime {
    DateTime { 
      year: year, 
      month: month, 
      day: day, 
      hour: hour, 
      minute: minute, 
      second: second 
    }
  }
  
  // Locale-aware date formatting
  let format_date = fn(date : DateTime, locale : Locale) -> String {
    match locale.language {
      "en" => {
        // English format: MM/DD/YYYY
        let month_str = if date.month < 10 { "0" + date.month.to_string() } else { date.month.to_string() }
        let day_str = if date.day < 10 { "0" + date.day.to_string() } else { date.day.to_string() }
        month_str + "/" + day_str + "/" + date.year.to_string()
      }
      "zh" => {
        // Chinese format: YYYYå¹´MMæœˆDDæ—¥
        date.year.to_string() + "å¹´" + date.month.to_string() + "æœˆ" + date.day.to_string() + "æ—¥"
      }
      "ja" => {
        // Japanese format: YYYYå¹´MMæœˆDDæ—¥
        date.year.to_string() + "å¹´" + date.month.to_string() + "æœˆ" + date.day.to_string() + "æ—¥"
      }
      "ar" => {
        // Arabic format: DD/MM/YYYY
        let day_str = if date.day < 10 { "0" + date.day.to_string() } else { date.day.to_string() }
        let month_str = if date.month < 10 { "0" + date.month.to_string() } else { date.month.to_string() }
        day_str + "/" + month_str + "/" + date.year.to_string()
      }
      _ => {
        // Default format: YYYY-MM-DD
        let month_str = if date.month < 10 { "0" + date.month.to_string() } else { date.month.to_string() }
        let day_str = if date.day < 10 { "0" + date.day.to_string() } else { date.day.to_string() }
        date.year.to_string() + "-" + month_str + "-" + day_str
      }
    }
  }
  
  // Locale-aware time formatting
  let format_time = fn(time : DateTime, locale : Locale) -> String {
    match locale.language {
      "en" => {
        // 12-hour format with AM/PM
        let hour_12 = if time.hour == 0 { 12 } else if time.hour > 12 { time.hour - 12 } else { time.hour }
        let period = if time.hour < 12 { "AM" } else { "PM" }
        let hour_str = if hour_12 < 10 { "0" + hour_12.to_string() } else { hour_12.to_string() }
        let minute_str = if time.minute < 10 { "0" + time.minute.to_string() } else { time.minute.to_string() }
        hour_str + ":" + minute_str + " " + period
      }
      "zh" | "ja" => {
        // 24-hour format
        let hour_str = if time.hour < 10 { "0" + time.hour.to_string() } else { time.hour.to_string() }
        let minute_str = if time.minute < 10 { "0" + time.minute.to_string() } else { time.minute.to_string() }
        hour_str + ":" + minute_str
      }
      "ar" => {
        // 24-hour format
        let hour_str = if time.hour < 10 { "0" + time.hour.to_string() } else { time.hour.to_string() }
        let minute_str = if time.minute < 10 { "0" + time.minute.to_string() } else { time.minute.to_string() }
        hour_str + ":" + minute_str
      }
      _ => {
        // Default 24-hour format
        let hour_str = if time.hour < 10 { "0" + time.hour.to_string() } else { time.hour.to_string() }
        let minute_str = if time.minute < 10 { "0" + time.minute.to_string() } else { time.minute.to_string() }
        hour_str + ":" + minute_str
      }
    }
  }
  
  // Test date formatting
  let test_date = create_datetime(2023, 12, 25, 14, 30, 45)
  
  assert_eq(format_date(test_date, create_locale("en", "US", "")), "12/25/2023")
  assert_eq(format_date(test_date, create_locale("zh", "CN", "")), "2023å¹´12æœˆ25æ—¥")
  assert_eq(format_date(test_date, create_locale("ja", "JP", "")), "2023å¹´12æœˆ25æ—¥")
  assert_eq(format_date(test_date, create_locale("ar", "EG", "")), "25/12/2023")
  assert_eq(format_date(test_date, create_locale("de", "DE", "")), "2023-12-25")
  
  // Test time formatting
  assert_eq(format_time(test_date, create_locale("en", "US", "")), "02:30 PM")
  assert_eq(format_time(test_date, create_locale("zh", "CN", "")), "14:30")
  assert_eq(format_time(test_date, create_locale("ja", "JP", "")), "14:30")
  assert_eq(format_time(test_date, create_locale("ar", "EG", "")), "14:30")
  
  // Test edge cases
  let midnight = create_datetime(2023, 12, 25, 0, 0, 0)
  assert_eq(format_time(midnight, create_locale("en", "US", "")), "12:00 AM")
  
  let noon = create_datetime(2023, 12, 25, 12, 0, 0)
  assert_eq(format_time(noon, create_locale("en", "US", "")), "12:00 PM")
  
  let late_night = create_datetime(2023, 12, 25, 23, 59, 59)
  assert_eq(format_time(late_night, create_locale("en", "US", "")), "11:59 PM")
}

// Test 5: Number Formatting
test "number formatting" {
  // Locale-aware number formatting
  let format_number = fn(number : Float, locale : Locale) -> String {
    match locale.language {
      "en" => {
        // English format: 1,234.56
        let int_part = number.to_int().to_string()
        let mut formatted_int = ""
        let mut count = 0
        
        // Add commas every three digits from right
        for i = int_part.length() - 1; i >= 0; i = i - 1 {
          formatted_int = int_part[i].to_string() + formatted_int
          count = count + 1
          
          if count == 3 && i > 0 {
            formatted_int = "," + formatted_int
            count = 0
          }
        }
        
        // Add decimal part
        let decimal_part = (number - number.to_int().to_float()).to_string()
        if decimal_part.length() > 2 {
          formatted_int + decimal_part.substring(1, 3) // Keep 2 decimal places
        } else {
          formatted_int
        }
      }
      "de" => {
        // German format: 1.234,56
        let int_part = number.to_int().to_string()
        let mut formatted_int = ""
        let mut count = 0
        
        // Add periods every three digits from right
        for i = int_part.length() - 1; i >= 0; i = i - 1 {
          formatted_int = int_part[i].to_string() + formatted_int
          count = count + 1
          
          if count == 3 && i > 0 {
            formatted_int = "." + formatted_int
            count = 0
          }
        }
        
        // Add decimal part with comma
        let decimal_part = (number - number.to_int().to_float()).to_string()
        if decimal_part.length() > 2 {
          formatted_int + "," + decimal_part.substring(1, 3)
        } else {
          formatted_int
        }
      }
      "ar" => {
        // Arabic format: Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦ (using Arabic numerals)
        let int_part = number.to_int().to_string()
        let mut formatted_int = ""
        let mut count = 0
        
        // Add Arabic comma every three digits from right
        for i = int_part.length() - 1; i >= 0; i = i - 1 {
          // Convert to Arabic numerals
          let digit = int_part[i].to_int()
          let arabic_digit = match digit {
            0 => "Ù "
            1 => "Ù¡"
            2 => "Ù¢"
            3 => "Ù£"
            4 => "Ù¤"
            5 => "Ù¥"
            6 => "Ù¦"
            7 => "Ù§"
            8 => "Ù¨"
            9 => "Ù©"
            _ => digit.to_string()
          }
          formatted_int = arabic_digit + formatted_int
          count = count + 1
          
          if count == 3 && i > 0 {
            formatted_int = "Ù¬" + formatted_int // Arabic comma
            count = 0
          }
        }
        
        // Add decimal part with Arabic decimal point
        let decimal_part = (number - number.to_int().to_float()).to_string()
        if decimal_part.length() > 2 {
          formatted_int + "Ù«" + decimal_part.substring(1, 3) // Arabic decimal point
        } else {
          formatted_int
        }
      }
      _ => {
        // Default format: 1234.56
        number.to_string()
      }
    }
  }
  
  // Test number formatting
  let test_number = 1234.56
  
  assert_eq(format_number(test_number, create_locale("en", "US", "")), "1,234.56")
  assert_eq(format_number(test_number, create_locale("de", "DE", "")), "1.234,56")
  assert_eq(format_number(test_number, create_locale("ar", "EG", "")), "Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦")
  assert_eq(format_number(test_number, create_locale("fr", "FR", "")), "1234.56") // Uses default
  
  // Test edge cases
  assert_eq(format_number(0.0, create_locale("en", "US", "")), "0")
  assert_eq(format_number(1000000.0, create_locale("en", "US", "")), "1,000,000")
  assert_eq(format_number(999.99, create_locale("de", "DE", "")), "999,99")
  
  // Test currency formatting (simplified)
  let format_currency = fn(amount : Float, locale : Locale) -> String {
    match locale.language {
      "en" => "$" + format_number(amount, locale)
      "de" => format_number(amount, locale) + " â‚¬"
      "ja" => "Â¥" + format_number(amount, locale)
      "ar" => format_number(amount, locale) + " Ø±.Ø³"
      _ => format_number(amount, locale) + " units"
    }
  }
  
  assert_eq(format_currency(1234.56, create_locale("en", "US", "")), "$1,234.56")
  assert_eq(format_currency(1234.56, create_locale("de", "DE", "")), "1.234,56 â‚¬")
  assert_eq(format_currency(1234.56, create_locale("ja", "JP", "")), "Â¥1234.56")
  assert_eq(format_currency(1234.56, create_locale("ar", "SA", "")), "Ù¡Ù¬Ù¢Ù£Ù¤Ù«Ù¥Ù¦ Ø±.Ø³")
}

// Test 6: Message Formatting and Pluralization
test "message formatting and pluralization" {
  // Plural rules
  type PluralCategory {
    Zero
    One
    Two
    Few
    Many
    Other
  }
  
  let get_plural_category = fn(count : Int, locale : Locale) -> PluralCategory {
    match locale.language {
      "en" => {
        if count == 0 { Zero }
        else if count == 1 { One }
        else { Other }
      }
      "ar" => {
        // Arabic has complex plural rules
        if count == 0 { Zero }
        else if count == 1 { One }
        else if count == 2 { Two }
        else if count >= 3 && count <= 10 { Few }
        else if count >= 11 && count <= 99 { Many }
        else { Other }
      }
      "zh" => {
        // Chinese doesn't have plural forms
        Other
      }
      _ => {
        if count == 1 { One }
        else { Other }
      }
    }
  }
  
  // Test plural categories
  assert_eq(get_plural_category(0, create_locale("en", "US", "")), Zero)
  assert_eq(get_plural_category(1, create_locale("en", "US", "")), One)
  assert_eq(get_plural_category(2, create_locale("en", "US", "")), Other)
  assert_eq(get_plural_category(5, create_locale("en", "US", "")), Other)
  
  assert_eq(get_plural_category(0, create_locale("ar", "EG", "")), Zero)
  assert_eq(get_plural_category(1, create_locale("ar", "EG", "")), One)
  assert_eq(get_plural_category(2, create_locale("ar", "EG", "")), Two)
  assert_eq(get_plural_category(5, create_locale("ar", "EG", "")), Few)
  assert_eq(get_plural_category(25, create_locale("ar", "EG", "")), Many)
  assert_eq(get_plural_category(150, create_locale("ar", "EG", "")), Other)
  
  assert_eq(get_plural_category(1, create_locale("zh", "CN", "")), Other)
  assert_eq(get_plural_category(5, create_locale("zh", "CN", "")), Other)
  
  // Message formatting with pluralization
  let format_message = fn(count : Int, locale : Locale) -> String {
    let category = get_plural_category(count, locale)
    
    match (locale.language, category) {
      ("en", Zero) => "You have no messages"
      ("en", One) => "You have one message"
      ("en", Other) => "You have " + count.to_string() + " messages"
      
      ("ar", Zero) => "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ø¦Ù„"
      ("ar", One) => "Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©"
      ("ar", Two) => "Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ù„ØªØ§Ù†"
      ("ar", Few) => "Ù„Ø¯ÙŠÙƒ " + count.to_string() + " Ø±Ø³Ø§Ø¦Ù„"
      ("ar", Many) => "Ù„Ø¯ÙŠÙƒ " + count.to_string() + " Ø±Ø³Ø§Ù„Ø©"
      ("ar", Other) => "Ù„Ø¯ÙŠÙƒ " + count.to_string() + " Ø±Ø³Ø§Ù„Ø©"
      
      ("zh", Other) => "æ‚¨æœ‰ " + count.to_string() + " æ¡æ¶ˆæ¯"
      
      _ => "You have " + count.to_string() + " messages"
    }
  }
  
  // Test message formatting
  assert_eq(format_message(0, create_locale("en", "US", "")), "You have no messages")
  assert_eq(format_message(1, create_locale("en", "US", "")), "You have one message")
  assert_eq(format_message(5, create_locale("en", "US", "")), "You have 5 messages")
  
  assert_eq(format_message(0, create_locale("ar", "EG", "")), "Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ø¦Ù„")
  assert_eq(format_message(1, create_locale("ar", "EG", "")), "Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ù„Ø© ÙˆØ§Ø­Ø¯Ø©")
  assert_eq(format_message(2, create_locale("ar", "EG", "")), "Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ù„ØªØ§Ù†")
  assert_eq(format_message(5, create_locale("ar", "EG", "")), "Ù„Ø¯ÙŠÙƒ 5 Ø±Ø³Ø§Ø¦Ù„")
  assert_eq(format_message(25, create_locale("ar", "EG", "")), "Ù„Ø¯ÙŠÙƒ 25 Ø±Ø³Ø§Ù„Ø©")
  assert_eq(format_message(150, create_locale("ar", "EG", "")), "Ù„Ø¯ÙŠÙƒ 150 Ø±Ø³Ø§Ù„Ø©")
  
  assert_eq(format_message(1, create_locale("zh", "CN", "")), "æ‚¨æœ‰ 1 æ¡æ¶ˆæ¯")
  assert_eq(format_message(5, create_locale("zh", "CN", "")), "æ‚¨æœ‰ 5 æ¡æ¶ˆæ¯")
  
  // Test parameterized messages
  let format_greeting = fn(name : String, time_of_day : String, locale : Locale) -> String {
    match locale.language {
      "en" => "Hello " + name + ", good " + time_of_day + "!"
      "zh" => name + "ï¼Œ" + time_of_day + "å¥½ï¼"
      "ja" => name + "ã•ã‚“ã€" + time_of_day + "ã”ã–ã„ã¾ã™ã€‚"
      "ar" => time_of_day + " Ø§Ù„Ø®ÙŠØ± ÙŠØ§ " + name
      _ => "Hello " + name + "!"
    }
  }
  
  assert_eq(format_greeting("John", "morning", create_locale("en", "US", "")), "Hello John, good morning!")
  assert_eq(format_greeting("å¼ ä¸‰", "æ—©ä¸Š", create_locale("zh", "CN", "")), "å¼ ä¸‰ï¼Œæ—©ä¸Šå¥½ï¼")
  assert_eq(format_greeting("ç”°ä¸­", "ãŠã¯ã‚ˆã†", create_locale("ja", "JP", "")), "ç”°ä¸­ã•ã‚“ã€ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã€‚")
  assert_eq(format_greeting("Ù…Ø­Ù…Ø¯", "ØµØ¨Ø§Ø­", create_locale("ar", "EG", "")), "ØµØ¨Ø§Ø­ Ø§Ù„Ø®ÙŠØ± ÙŠØ§ Ù…Ø­Ù…Ø¯")
}