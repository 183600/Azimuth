// è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸å¤„ç†ç»¼åˆæµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Azimuthé¥æµ‹ç³»ç»Ÿåœ¨å„ç§è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸º

test "ç©ºå€¼å’ŒNoneç±»å‹å¤„ç†" {
  // æµ‹è¯•å¯¹ç©ºå€¼å’ŒNoneç±»å‹çš„å¤„ç†
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.test")
  
  // åˆ›å»ºspanå¹¶æµ‹è¯•ç©ºå±æ€§å€¼
  let span = Tracer::start_span(tracer, "empty.values.test")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å±æ€§
  Span::set_attribute(span, "empty.string", "")
  Span::set_attribute(span, "null.value", "")
  
  // æµ‹è¯•Noneç±»å‹çš„å¯é€‰å€¼
  let optional_attr = None
  match optional_attr {
    Some(value) => Span::set_attribute(span, "optional.value", value)
    None => Span::set_attribute(span, "optional.value", "default")
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„å±æ€§
  let empty_list = []
  Span::set_attribute(span, "empty.list.length", empty_list.length())
  
  // éªŒè¯spanä»ç„¶æœ‰æ•ˆ
  let span_ctx = Span::span_context(span)
  assert_true(SpanContext::is_valid(span_ctx))
  Span::end(span)
}

test "æ•°å€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æ•°å€¼è¾¹ç•Œæ¡ä»¶
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "boundary.numeric.test")
  
  // åˆ›å»ºè®¡æ•°å™¨å¹¶æµ‹è¯•è¾¹ç•Œå€¼
  let counter = Meter::create_counter(meter, "boundary.counter", Some("Boundary test counter"), Some("count"))
  
  // æµ‹è¯•é›¶å€¼
  Counter::add(counter, 0.0)
  
  // æµ‹è¯•è´Ÿå€¼
  Counter::add(counter, -1.0)
  
  // æµ‹è¯•æå¤§å€¼
  Counter::add(counter, 999999.999)
  
  // æµ‹è¯•æå°æ­£å€¼
  Counter::add(counter, 0.001)
  
  // æµ‹è¯•å¸¦å±æ€§çš„è¾¹ç•Œå€¼
  Counter::add_with_attributes(counter, -100.0, [("boundary.type", "negative")])
  Counter::add_with_attributes(counter, 0.0, [("boundary.type", "zero")])
  Counter::add_with_attributes(counter, 1000000.0, [("boundary.type", "maximum")])
  
  // éªŒè¯è®¡æ•°å™¨å±æ€§
  assert_eq(counter.name, "boundary.counter")
  assert_eq(counter.unit, Some("count"))
}

test "å­—ç¬¦ä¸²é•¿åº¦å’Œç‰¹æ®Šå­—ç¬¦å¤„ç†" {
  // æµ‹è¯•å­—ç¬¦ä¸²é•¿åº¦è¾¹ç•Œå’Œç‰¹æ®Šå­—ç¬¦
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "boundary.string.test")
  
  let span = Tracer::start_span(tracer, "string.boundary.test")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  Span::set_attribute(span, "empty.string", "")
  
  // æµ‹è¯•å•å­—ç¬¦å­—ç¬¦ä¸²
  Span::set_attribute(span, "single.char", "a")
  
  // æµ‹è¯•é•¿å­—ç¬¦ä¸²
  let long_string = "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„å­—ç¬¦ä¸²ï¼Œç”¨äºæµ‹è¯•è¾¹ç•Œæ¡ä»¶å¤„ç†èƒ½åŠ›ï¼ŒåŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦ï¼š!@#$%^&*()_+-=[]{}|;':\",./<>?"
  Span::set_attribute(span, "long.string", long_string)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  Span::set_attribute(span, "special.chars", "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  Span::set_attribute(span, "unicode.chars", "æµ‹è¯•ä¸­æ–‡å­—ç¬¦ğŸš€ğŸ‰")
  
  // æµ‹è¯•æ¢è¡Œç¬¦å’Œåˆ¶è¡¨ç¬¦
  Span::set_attribute(span, "whitespace.chars", "line1\nline2\tindented")
  
  // éªŒè¯spanä»ç„¶æœ‰æ•ˆ
  let span_name = Span::name(span)
  assert_eq(span_name, "string.boundary.test")
  Span::end(span)
}

test "æ—¶é—´å’Œæ—¶é—´æˆ³è¾¹ç•Œå¤„ç†" {
  // æµ‹è¯•æ—¶é—´å’Œæ—¶é—´æˆ³è¾¹ç•Œæ¡ä»¶
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "boundary.time.test")
  
  // æµ‹è¯•é›¶æ—¶é—´æˆ³
  let zero_time_log = LogRecord::new_with_timestamp(Info, "Zero timestamp test", 0L)
  LogRecord::add_attribute(zero_time_log, "timestamp.type", "zero")
  
  // æµ‹è¯•è´Ÿæ—¶é—´æˆ³
  let negative_time_log = LogRecord::new_with_timestamp(Warn, "Negative timestamp test", -1000000L)
  LogRecord::add_attribute(negative_time_log, "timestamp.type", "negative")
  
  // æµ‹è¯•æå¤§æ—¶é—´æˆ³
  let max_time_log = LogRecord::new_with_timestamp(Error, "Max timestamp test", 9223372036854775807L)
  LogRecord::add_attribute(max_time_log, "timestamp.type", "maximum")
  
  // æµ‹è¯•å½“å‰æ—¶é—´æˆ³
  let current_time = 1735689600000000000L
  let current_time_log = LogRecord::new_with_timestamp(Info, "Current timestamp test", current_time)
  LogRecord::add_attribute(current_time_log, "timestamp.type", "current")
  
  // å‘å°„æ‰€æœ‰æ—¥å¿—è®°å½•
  Logger::emit(logger, zero_time_log)
  Logger::emit(logger, negative_time_log)
  Logger::emit(logger, max_time_log)
  Logger::emit(logger, current_time_log)
  
  // éªŒè¯æ—¥å¿—è®°å½•å±æ€§
  assert_eq(LogRecord::severity_number(zero_time_log), Info)
  assert_eq(LogRecord::severity_number(negative_time_log), Warn)
  assert_eq(LogRecord::severity_number(max_time_log), Error)
  assert_eq(LogRecord::severity_number(current_time_log), Info)
}

test "èµ„æºå±æ€§è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•èµ„æºå±æ€§çš„è¾¹ç•Œæ¡ä»¶
  let base_resource = Resource::new()
  
  // æµ‹è¯•ç©ºå±æ€§åˆ—è¡¨
  let empty_attrs = []
  let resource_with_empty = Resource::with_attributes(base_resource, empty_attrs)
  
  // æµ‹è¯•å•å±æ€§
  let single_attr = [("single.attribute", StringValue("single.value"))]
  let resource_with_single = Resource::with_attributes(base_resource, single_attr)
  
  // æµ‹è¯•å¤§é‡å±æ€§
  let many_attrs = [
    ("attr1", StringValue("value1")),
    ("attr2", StringValue("value2")),
    ("attr3", StringValue("value3")),
    ("attr4", StringValue("value4")),
    ("attr5", StringValue("value5")),
    ("attr6", StringValue("value6")),
    ("attr7", StringValue("value7")),
    ("attr8", StringValue("value8")),
    ("attr9", StringValue("value9")),
    ("attr10", StringValue("value10"))
  ]
  let resource_with_many = Resource::with_attributes(base_resource, many_attrs)
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å±æ€§
  let special_attrs = [
    ("special.chars", StringValue("!@#$%^&*()")),
    ("unicode.chars", StringValue("æµ‹è¯•ä¸­æ–‡ğŸš€")),
    ("empty.value", StringValue(""))
  ]
  let resource_with_special = Resource::with_attributes(base_resource, special_attrs)
  
  // æµ‹è¯•èµ„æºåˆå¹¶è¾¹ç•Œæ¡ä»¶
  let merged_resource = Resource::merge(resource_with_empty, resource_with_single)
  let final_resource = Resource::merge(merged_resource, resource_with_many)
  
  // éªŒè¯èµ„æºæ“ä½œå®Œæˆ
  assert_true(true)
}

test "ä¸Šä¸‹æ–‡ä¼ æ’­è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•ä¸Šä¸‹æ–‡ä¼ æ’­çš„è¾¹ç•Œæ¡ä»¶
  let root_ctx = Context::root()
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_key = ContextKey::new("empty.key")
  let empty_value = Context::get(root_ctx, empty_key)
  assert_eq(empty_value, None)
  
  // æµ‹è¯•åµŒå¥—ä¸Šä¸‹æ–‡
  let key1 = ContextKey::new("key1")
  let key2 = ContextKey::new("key2")
  let key3 = ContextKey::new("key3")
  
  let ctx1 = Context::with_value(root_ctx, key1, "value1")
  let ctx2 = Context::with_value(ctx1, key2, "value2")
  let ctx3 = Context::with_value(ctx2, key3, "value3")
  
  // éªŒè¯æ‰€æœ‰å€¼éƒ½å­˜åœ¨
  let value1 = Context::get(ctx3, key1)
  let value2 = Context::get(ctx3, key2)
  let value3 = Context::get(ctx3, key3)
  
  assert_eq(value1, Some("value1"))
  assert_eq(value2, Some("value2"))
  assert_eq(value3, Some("value3"))
  
  // æµ‹è¯•è¦†ç›–å€¼
  let ctx_override = Context::with_value(ctx3, key1, "overridden.value1")
  let overridden_value = Context::get(ctx_override, key1)
  assert_eq(overridden_value, Some("overridden.value1"))
  
  // ç¡®ä¿å…¶ä»–å€¼ä»ç„¶å­˜åœ¨
  let unchanged_value2 = Context::get(ctx_override, key2)
  let unchanged_value3 = Context::get(ctx_override, key3)
  assert_eq(unchanged_value2, Some("value2"))
  assert_eq(unchanged_value3, Some("value3"))
}

test "åº¦é‡èšåˆè¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•åº¦é‡èšåˆçš„è¾¹ç•Œæ¡ä»¶
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "aggregation.boundary.test")
  
  // åˆ›å»ºç›´æ–¹å›¾å¹¶æµ‹è¯•è¾¹ç•Œå€¼
  let histogram = Meter::create_histogram(
    meter, 
    "boundary.histogram", 
    Some("Boundary test histogram"), 
    Some("unit")
  )
  
  // æµ‹è¯•é›¶å€¼è®°å½•
  Histogram::record(histogram, 0.0)
  
  // æµ‹è¯•è´Ÿå€¼è®°å½•
  Histogram::record(histogram, -1.0)
  
  // æµ‹è¯•æå°æ­£å€¼
  Histogram::record(histogram, 0.000001)
  
  // æµ‹è¯•æå¤§å€¼
  Histogram::record(histogram, 999999999.0)
  
  // æµ‹è¯•ç›¸åŒå€¼å¤šæ¬¡è®°å½•
  for i in 0..=9 {
    Histogram::record(histogram, 42.0)
  }
  
  // æµ‹è¯•å¸¦å±æ€§çš„è¾¹ç•Œå€¼
  Histogram::record_with_attributes(histogram, -100.0, [("boundary", "negative")])
  Histogram::record_with_attributes(histogram, 0.0, [("boundary", "zero")])
  Histogram::record_with_attributes(histogram, 100.0, [("boundary", "positive")])
  
  // éªŒè¯ç›´æ–¹å›¾å±æ€§
  assert_eq(histogram.name, "boundary.histogram")
  assert_eq(histogram.description, Some("Boundary test histogram"))
  assert_eq(histogram.unit, Some("unit"))
}

test "é”™è¯¯å¤„ç†è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•é”™è¯¯å¤„ç†çš„è¾¹ç•Œæ¡ä»¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "error.boundary.test")
  
  // åˆ›å»ºå¤šä¸ªé”™è¯¯span
  let error_span1 = Tracer::start_span(tracer, "error.boundary.1")
  let error_span2 = Tracer::start_span(tracer, "error.boundary.2")
  
  // è®¾ç½®å„ç§é”™è¯¯çŠ¶æ€
  Span::set_status(error_span1, Error, Some(""))
  Span::set_status(error_span2, Error, None)
  
  // æ·»åŠ ç©ºé”™è¯¯æ¶ˆæ¯
  Span::add_event(error_span1, "error.empty", [])
  
  // æ·»åŠ ç‰¹æ®Šå­—ç¬¦é”™è¯¯æ¶ˆæ¯
  Span::add_event(error_span2, "error.special", [
    ("error.message", StringValue("é”™è¯¯ä¿¡æ¯åŒ…å«ç‰¹æ®Šå­—ç¬¦!@#$%^&*()")),
    ("error.code", StringValue("")),
    ("error.details", StringValue("ğŸš€ é”™è¯¯è¯¦æƒ…"))
  ])
  
  // æµ‹è¯•æ—¥å¿—é”™è¯¯è¾¹ç•Œæ¡ä»¶
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "error.boundary.logger")
  
  // åˆ›å»ºå„ç§é”™è¯¯æ—¥å¿—
  let empty_error_log = LogRecord::new(Error, "")
  let long_error_log = LogRecord::new(Error, "è¿™æ˜¯ä¸€ä¸ªéå¸¸é•¿çš„é”™è¯¯æ¶ˆæ¯ï¼Œç”¨äºæµ‹è¯•è¾¹ç•Œæ¡ä»¶å¤„ç†èƒ½åŠ›ï¼ŒåŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦å’ŒUnicodeå­—ç¬¦ï¼šæµ‹è¯•ä¸­æ–‡ğŸš€Error!")
  let special_error_log = LogRecord::new(Error, "!@#$%^&*()_+-=[]{}|;':\",./<>?")
  
  // æ·»åŠ è¾¹ç•Œæ¡ä»¶å±æ€§
  LogRecord::add_attribute(empty_error_log, "error.type", "")
  LogRecord::add_attribute(long_error_log, "error.type", "very.long.type.name.that.exceeds.normal.expectations")
  LogRecord::add_attribute(special_error_log, "error.type", "!@#$%^&*()")
  
  // å‘å°„é”™è¯¯æ—¥å¿—
  Logger::emit(logger, empty_error_log)
  Logger::emit(logger, long_error_log)
  Logger::emit(logger, special_error_log)
  
  // ç»“æŸspan
  Span::end(error_span1)
  Span::end(error_span2)
  
  // éªŒè¯é”™è¯¯å¤„ç†å®Œæˆ
  assert_true(true)
}

test "å†…å­˜å’Œæ€§èƒ½è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•å†…å­˜å’Œæ€§èƒ½è¾¹ç•Œæ¡ä»¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "performance.boundary.test")
  
  // åˆ›å»ºå¤§é‡span
  let spans = []
  for i in 0..=99 {
    let span = Tracer::start_span(tracer, "performance.span." + i.to_string())
    spans = spans.push(span)
  }
  
  // ä¸ºæ¯ä¸ªspanæ·»åŠ å±æ€§
  for i in 0..=99 {
    let span = spans[i]
    Span::set_attribute(span, "span.index", i)
    Span::set_attribute(span, "span.data", "data.for.span." + i.to_string())
  }
  
  // æµ‹è¯•å¤§é‡åº¦é‡æ“ä½œ
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "performance.boundary.metrics")
  
  let counter = Meter::create_counter(meter, "performance.counter", Some("Performance test counter"), Some("count"))
  
  // æ‰§è¡Œå¤§é‡è®¡æ•°æ“ä½œ
  for i in 0..=999 {
    Counter::add_with_attributes(counter, 1.0, [
      ("batch.id", i / 100),
      ("item.id", i),
      ("operation.type", "performance.test")
    ])
  }
  
  // æµ‹è¯•å¤§é‡æ—¥å¿—è®°å½•
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "performance.boundary.logger")
  
  // åˆ›å»ºå¹¶å‘å°„å¤§é‡æ—¥å¿—
  for i in 0..=99 {
    let log = LogRecord::new(Info, "Performance test log " + i.to_string())
    LogRecord::add_attribute(log, "log.index", i)
    LogRecord::add_attribute(log, "log.batch", i / 10)
    Logger::emit(logger, log)
  }
  
  // ç»“æŸæ‰€æœ‰span
  for span in spans {
    Span::end(span)
  }
  
  // éªŒè¯æ€§èƒ½æµ‹è¯•å®Œæˆ
  assert_true(true)
}