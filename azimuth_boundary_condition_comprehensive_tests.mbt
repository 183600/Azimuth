// Azimuth è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸å¤„ç†æµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºæµ‹è¯•ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸º

// æµ‹è¯•1: ç©ºå€¼å’Œnullå¤„ç†æµ‹è¯•
test "ç©ºå€¼å’Œnullå¤„ç†æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "boundary.test")
  
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å±æ€§
  let counter = Meter::create_counter(meter, "empty.string.test")
  Counter::add(counter, 1.0, [("empty.key", StringValue(""))])
  
  // æµ‹è¯•ç©ºçš„å±æ€§æ•°ç»„
  let empty_attrs = []
  Counter::add(counter, 2.0, empty_attrs)
  
  // æµ‹è¯•ç©ºä¸Šä¸‹æ–‡
  let empty_ctx = Context::root()
  let span = Tracer::start_span_with_context(tracer, "empty.context", empty_ctx)
  
  // æµ‹è¯•ç©ºæ—¥å¿—æ¶ˆæ¯
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "boundary.logger")
  let empty_log = LogRecord::new(Info, "")
  Logger::emit(logger, empty_log)
  
  // éªŒè¯æ‰€æœ‰æ“ä½œéƒ½èƒ½æ­£ç¡®å¤„ç†ç©ºå€¼
  assert_eq(Counter::value(counter), 3.0)
  assert_eq(Span::name(span), "empty.context")
  assert_eq(LogRecord::body(empty_log), Some(""))
}

// æµ‹è¯•2: æå€¼å¤„ç†æµ‹è¯•
test "æå€¼å¤„ç†æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "extreme.value.test")
  
  // æµ‹è¯•æœ€å¤§æµ®ç‚¹æ•°å€¼
  let max_counter = Meter::create_counter(meter, "max.value")
  let max_float = 3.402823466e+38  // æ¥è¿‘f32æœ€å¤§å€¼
  Counter::add(max_counter, max_float)
  
  // æµ‹è¯•æœ€å°æµ®ç‚¹æ•°å€¼
  let min_counter = Meter::create_counter(meter, "min.value")
  let min_float = 1.175494351e-38  // æ¥è¿‘f32æœ€å°æ­£å€¼
  Counter::add(min_counter, min_float)
  
  // æµ‹è¯•é›¶å€¼
  let zero_counter = Meter::create_counter(meter, "zero.value")
  Counter::add(zero_counter, 0.0)
  
  // æµ‹è¯•è´Ÿå€¼
  let negative_counter = Meter::create_updown_counter(meter, "negative.value")
  Counter::add(negative_counter, -1000.0)
  
  // æµ‹è¯•æå¤§æ•´æ•°
  let large_int_attr = IntValue(2147483647)  // i32æœ€å¤§å€¼
  let resource = Resource::with_attributes(Resource::new(), [("large.int", large_int_attr)])
  
  // éªŒè¯æå€¼å¤„ç†
  assert_eq(Counter::value(max_counter), max_float)
  assert_eq(Counter::value(min_counter), min_float)
  assert_eq(Counter::value(zero_counter), 0.0)
  assert_eq(Counter::value(negative_counter), -1000.0)
  assert_eq(Resource::get_attribute(resource, "large.int"), Some(large_int_attr))
}

// æµ‹è¯•3: è¶…é•¿å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
test "è¶…é•¿å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "long.string.test")
  
  // åˆ›å»ºè¶…é•¿å­—ç¬¦ä¸² (1000ä¸ªå­—ç¬¦)
  let long_string = "a".repeat(1000)
  let very_long_string = "b".repeat(10000)  // 10000ä¸ªå­—ç¬¦
  
  // æµ‹è¯•è¶…é•¿å±æ€§é”®
  let long_key = "c".repeat(256)  // å‡è®¾é”®é•¿åº¦é™åˆ¶ä¸º255
  let counter = Meter::create_counter(meter, "long.key.test")
  Counter::add(counter, 1.0, [(long_key, StringValue("test"))])
  
  // æµ‹è¯•è¶…é•¿å±æ€§å€¼
  let long_value = "d".repeat(1000)
  Counter::add(counter, 1.0, [("long.value", StringValue(long_value))])
  
  // æµ‹è¯•è¶…é•¿spanåç§°
  let long_span_name = "e".repeat(500)
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "long.string.test")
  let span = Tracer::start_span(tracer, long_span_name)
  
  // æµ‹è¯•è¶…é•¿æ—¥å¿—æ¶ˆæ¯
  let logger = LoggerProvider::get_logger(LoggerProvider::default(), "long.string.logger")
  let long_log = LogRecord::new(Info, very_long_string)
  Logger::emit(logger, long_log)
  
  // éªŒè¯è¶…é•¿å­—ç¬¦ä¸²å¤„ç†
  assert_eq(Span::name(span), long_span_name)
  assert_eq(LogRecord::body(long_log), Some(very_long_string))
}

// æµ‹è¯•4: å†…å­˜é™åˆ¶è¾¹ç•Œæµ‹è¯•
test "å†…å­˜é™åˆ¶è¾¹ç•Œæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "memory.limit.test")
  
  // åˆ›å»ºå¤§é‡å±æ€§
  let many_attrs = []
  for i = 0; i < 1000; i = i + 1 {
    many_attrs.push(("attr." + i.to_string(), StringValue("value." + i.to_string())))
  }
  
  // æµ‹è¯•å¤§é‡å±æ€§çš„span
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "memory.limit.test")
  let span = Tracer::start_span(tracer, "many.attrs")
  
  // é€ä¸ªæ·»åŠ å±æ€§ä»¥é¿å…å†…å­˜é—®é¢˜
  for (key, value) in many_attrs {
    Span::set_attribute(span, key, value)
  }
  
  // åˆ›å»ºå¤§é‡span
  let spans = []
  for i = 0; i < 100; i = i + 1 {
    spans.push(Tracer::start_span(tracer, "span." + i.to_string()))
  }
  
  // éªŒè¯æ‰€æœ‰spanéƒ½å·²åˆ›å»º
  assert_eq(spans.length(), 100)
  
  // æ¸…ç†æ‰€æœ‰span
  for span in spans {
    Span::end(span)
  }
  Span::end(span)
}

// æµ‹è¯•5: æ— æ•ˆè¾“å…¥å¤„ç†æµ‹è¯•
test "æ— æ•ˆè¾“å…¥å¤„ç†æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "invalid.input.test")
  
  // æµ‹è¯•æ— æ•ˆçš„ç‰¹æ®Šå­—ç¬¦
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let counter = Meter::create_counter(meter, "special.chars")
  Counter::add(counter, 1.0, [("special.chars", StringValue(special_chars))])
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_chars = "æµ‹è¯•ä¸­æ–‡ğŸš€emoji"
  Counter::add(counter, 1.0, [("unicode.chars", StringValue(unicode_chars))])
  
  // æµ‹è¯•æ§åˆ¶å­—ç¬¦
  let control_chars = "\n\r\t\u{0000}\u{0001}"
  Counter::add(counter, 1.0, [("control.chars", StringValue(control_chars))])
  
  // æµ‹è¯•æ— æ•ˆçš„æ—¶é—´æˆ³
  let invalid_timestamp = -1L
  let log_record = LogRecord::new_with_context(
    Info,
    Some("Invalid timestamp test"),
    None,
    Some(invalid_timestamp),
    None,
    None,
    None,
    Some(Context::root())
  )
  
  // æµ‹è¯•æ— æ•ˆçš„trace IDå’Œspan ID
  let invalid_trace_id = ""
  let invalid_span_id = ""
  let span_with_invalid_ids = Span::new(
    "invalid.ids",
    Internal,
    SpanContext::new(invalid_trace_id, invalid_span_id, true, "")
  )
  
  // éªŒè¯æ— æ•ˆè¾“å…¥å¤„ç†
  assert_eq(Counter::value(counter), 3.0)
  assert_eq(Span::name(span_with_invalid_ids), "invalid.ids")
  assert_eq(LogRecord::severity_number(log_record), Info)
}

// æµ‹è¯•6: èµ„æºè€—å°½æ¢å¤æµ‹è¯•
test "èµ„æºè€—å°½æ¢å¤æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "resource.exhaustion.test")
  
  // æ¨¡æ‹Ÿèµ„æºè€—å°½æƒ…å†µ
  let counter = Meter::create_counter(meter, "resource.test")
  
  // å¿«é€Ÿåˆ›å»ºå¤§é‡å¯¹è±¡
  let objects = []
  for i = 0; i < 10000; i = i + 1 {
    objects.push(Counter::add(counter, 1.0))
  }
  
  // éªŒè¯å³ä½¿åœ¨é«˜è´Ÿè½½ä¸‹ä¹Ÿèƒ½æ­£å¸¸å·¥ä½œ
  assert_eq(Counter::value(counter), 10000.0)
  
  // æ¸…ç†å¯¹è±¡
  objects.clear()
  
  // éªŒè¯èµ„æºé‡Šæ”¾åç³»ç»Ÿä»èƒ½æ­£å¸¸å·¥ä½œ
  Counter::add(counter, 1.0)
  assert_eq(Counter::value(counter), 10001.0)
}

// æµ‹è¯•7: å¹¶å‘è¾¹ç•Œæ¡ä»¶æµ‹è¯•
test "å¹¶å‘è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "concurrent.boundary.test")
  
  // åˆ›å»ºå…±äº«èµ„æº
  let shared_counter = Meter::create_counter(meter, "shared.counter")
  let shared_span = Tracer::start_span(TracerProvider::get_tracer(TracerProvider::default(), "concurrent.test"), "shared.span")
  
  // æ¨¡æ‹Ÿå¹¶å‘è®¿é—®
  for i = 0; i < 100; i = i + 1 {
    // å¹¶å‘æ›´æ–°è®¡æ•°å™¨
    Counter::add(shared_counter, i.to_float())
    
    // å¹¶å‘è®¾ç½®spanå±æ€§
    Span::set_attribute(shared_span, "attr." + i.to_string(), IntValue(i))
  }
  
  // éªŒè¯å¹¶å‘æ“ä½œç»“æœ
  assert_eq(Counter::value(shared_counter), 4950.0)  // 0+1+2+...+99
  
  // éªŒè¯spanå±æ€§è®¾ç½®
  let attr_99 = Span::get_attribute(shared_span, "attr.99")
  match attr_99 {
    Some(IntValue(v)) => assert_eq(v, 99)
    _ => assert_true(false)
  }
  
  Span::end(shared_span)
}

// æµ‹è¯•8: æ•°æ®ç±»å‹è¾¹ç•Œæµ‹è¯•
test "æ•°æ®ç±»å‹è¾¹ç•Œæµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "type.boundary.test")
  
  // æµ‹è¯•æ‰€æœ‰æ”¯æŒçš„å±æ€§ç±»å‹
  let counter = Meter::create_counter(meter, "type.test")
  
  // å­—ç¬¦ä¸²ç±»å‹
  Counter::add(counter, 1.0, [("string.attr", StringValue("test"))])
  
  // æ•´æ•°ç±»å‹
  Counter::add(counter, 1.0, [("int.attr", IntValue(42))])
  
  // æµ®ç‚¹ç±»å‹
  Counter::add(counter, 1.0, [("float.attr", FloatValue(3.14))])
  
  // å¸ƒå°”ç±»å‹
  Counter::add(counter, 1.0, [("bool.attr", BoolValue(true))])
  
  // æ•°ç»„ç±»å‹
  let array_attr = ArrayValue([StringValue("a"), StringValue("b"), StringValue("c")])
  Counter::add(counter, 1.0, [("array.attr", array_attr)])
  
  // éªŒè¯æ‰€æœ‰ç±»å‹éƒ½èƒ½æ­£ç¡®å¤„ç†
  assert_eq(Counter::value(counter), 5.0)
}

// æµ‹è¯•9: æ—¶é—´è¾¹ç•Œæ¡ä»¶æµ‹è¯•
test "æ—¶é—´è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "time.boundary.test")
  
  // æµ‹è¯•Unixçºªå…ƒæ—¶é—´
  let epoch_time = 0L
  let epoch_log = LogRecord::new_with_context(
    Info,
    Some("Epoch time test"),
    None,
    Some(epoch_time),
    None,
    None,
    None,
    Some(Context::root())
  )
  
  // æµ‹è¯•æœ€å¤§æ—¶é—´æˆ³
  let max_time = 9223372036854775807L  // i64æœ€å¤§å€¼
  let max_time_log = LogRecord::new_with_context(
    Info,
    Some("Max time test"),
    None,
    Some(max_time),
    None,
    None,
    None,
    Some(Context::root())
  )
  
  // æµ‹è¯•è´Ÿæ—¶é—´æˆ³
  let negative_time = -1000000L
  let negative_time_log = LogRecord::new_with_context(
    Info,
    Some("Negative time test"),
    None,
    Some(negative_time),
    None,
    None,
    None,
    Some(Context::root())
  )
  
  // éªŒè¯æ—¶é—´è¾¹ç•Œæ¡ä»¶å¤„ç†
  assert_eq(LogRecord::timestamp(epoch_log), Some(epoch_time))
  assert_eq(LogRecord::timestamp(max_time_log), Some(max_time))
  assert_eq(LogRecord::timestamp(negative_time_log), Some(negative_time))
}

// æµ‹è¯•10: å¼‚å¸¸æ¢å¤å’Œå®¹é”™æµ‹è¯•
test "å¼‚å¸¸æ¢å¤å’Œå®¹é”™æµ‹è¯•" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "fault.tolerance.test")
  
  // æ¨¡æ‹Ÿå¼‚å¸¸æƒ…å†µä¸‹çš„æ“ä½œ
  let counter = Meter::create_counter(meter, "fault.tolerance")
  
  // åœ¨å¼‚å¸¸æƒ…å†µä¸‹ç»§ç»­æ“ä½œ
  try {
    // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
    Counter::add(counter, 1.0, [("normal.attr", StringValue("normal"))])
  } catch {
    _ => {
      // å¼‚å¸¸æƒ…å†µä¸‹ç»§ç»­æ‰§è¡Œ
      Counter::add(counter, 1.0, [("fallback.attr", StringValue("fallback"))])
    }
  }
  
  // éªŒè¯ç³»ç»Ÿåœ¨å¼‚å¸¸æƒ…å†µä¸‹ä»èƒ½æ­£å¸¸å·¥ä½œ
  assert_true(Counter::value(counter) >= 1.0)
  
  // æµ‹è¯•éƒ¨åˆ†å¤±è´¥æƒ…å†µ
  let tracer = TracerProvider::get_tracer(TracerProvider::default(), "fault.tolerance")
  let span = Tracer::start_span(tracer, "fault.tolerance.span")
  
  // å³ä½¿éƒ¨åˆ†æ“ä½œå¤±è´¥ï¼Œä¹Ÿè¦ç¡®ä¿spanèƒ½æ­£å¸¸ç»“æŸ
  try {
    Span::set_attribute(span, "valid.attr", StringValue("valid"))
    // æ¨¡æ‹Ÿå¯èƒ½å¤±è´¥çš„æ“ä½œ
    Span::set_attribute(span, "invalid.attr", StringValue(""))
  } catch {
    _ => {
      // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œ
    }
  }
  
  // ç¡®ä¿spanèƒ½æ­£å¸¸ç»“æŸ
  Span::end(span)
  assert_eq(Span::name(span), "fault.tolerance.span")
}