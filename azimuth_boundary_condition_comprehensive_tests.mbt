// è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸å¤„ç†æµ‹è¯•ç”¨ä¾‹
// æµ‹è¯•Azimuthé¥æµ‹ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸º

test "ç©ºå€¼å’Œnullå¤„ç†è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²å¤„ç†
  let empty_string = ""
  assert_eq(empty_string.length(), 0)
  assert_true(empty_string.is_empty())
  assert_false(empty_string.contains("anything"))
  
  // æµ‹è¯•None/Nullå€¼å¤„ç†
  let none_option = None
  match none_option {
    Some(_) => assert_true(false)
    None => assert_true(true)
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„å¤„ç†
  let empty_array = []
  assert_eq(empty_array.length(), 0)
  assert_true(empty_array.is_empty())
  assert_false(empty_array.contains(0))
  
  // æµ‹è¯•ç©ºæ•°ç»„ä¸Šçš„æ“ä½œ
  let mapped_empty = empty_array.map(fn(x) { x * 2 })
  assert_eq(mapped_empty, [])
  
  let filtered_empty = empty_array.filter(fn(x) { x > 0 })
  assert_eq(filtered_empty, [])
  
  let sum_empty = empty_array.reduce(fn(acc, x) { acc + x }, 0)
  assert_eq(sum_empty, 0)
}

test "æ•°å€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æœ€å¤§å€¼å’Œæœ€å°å€¼è¾¹ç•Œ
  let max_int = 2147483647
  let min_int = -2147483648
  
  assert_eq(max_int + 1, -2147483648)  // æ•´æ•°æº¢å‡º
  assert_eq(min_int - 1, 2147483647)  // æ•´æ•°ä¸‹æº¢
  
  // æµ‹è¯•é›¶å€¼è¾¹ç•Œ
  let zero = 0
  assert_eq(zero * 10, 0)
  assert_eq(zero / 1, 0)
  assert_eq(zero - 5, -5)
  assert_eq(zero + 5, 5)
  
  // æµ‹è¯•æµ®ç‚¹æ•°è¾¹ç•Œ
  let small_float = 0.0000001
  let large_float = 999999999.9
  
  assert_true(small_float > 0.0)
  assert_true(large_float < 1000000000.0)
  
  // æµ‹è¯•é™¤é›¶è¾¹ç•Œæ¡ä»¶
  let positive = 10.0
  let negative = -10.0
  
  // æ³¨æ„ï¼šå®é™…å®ç°ä¸­éœ€è¦å¤„ç†é™¤é›¶é”™è¯¯
  // assert_eq(positive / 0.0, Infinity)  // æµ®ç‚¹æ•°é™¤é›¶
  // assert_eq(negative / 0.0, -Infinity)
}

test "å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let long_string = "a" * 10000
  assert_eq(long_string.length(), 10000)
  assert_true(long_string.contains("a"))
  assert_false(long_string.contains("b"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  assert_eq(special_chars.length(), 29)
  assert_true(special_chars.contains("@"))
  assert_true(special_chars.contains("<"))
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•å­—ç¬¦ä¸²ğŸš€"
  assert_eq(unicode_string.length(), 6)
  assert_true(unicode_string.contains("æµ‹è¯•"))
  assert_true(unicode_string.contains("ğŸš€"))
  
  // æµ‹è¯•å­—ç¬¦ä¸²ç´¢å¼•è¾¹ç•Œ
  let test_str = "hello"
  assert_eq(test_str.substring(0, 5), "hello")
  assert_eq(test_str.substring(0, 0), "")
  assert_eq(test_str.substring(5, 5), "")
  assert_eq(test_str.substring(2, 5), "llo")
}

test "é›†åˆå’Œå®¹å™¨è¾¹ç•Œæ¡ä»¶" {
  // æµ‹è¯•å•å…ƒç´ é›†åˆ
  let single_element = [42]
  assert_eq(single_element.length(), 1)
  assert_true(single_element.contains(42))
  assert_false(single_element.contains(0))
  
  // æµ‹è¯•é›†åˆè¾¹ç•Œæ“ä½œ
  let numbers = [1, 2, 3, 4, 5]
  
  // æµ‹è¯•è¾¹ç•Œç´¢å¼•
  assert_eq(numbers.get(0), Some(1))
  assert_eq(numbers.get(4), Some(5))
  assert_eq(numbers.get(5), None)  // è¶…å‡ºè¾¹ç•Œ
  assert_eq(numbers.get(-1), None)  // è´Ÿç´¢å¼•
  
  // æµ‹è¯•è¾¹ç•Œåˆ‡ç‰‡
  assert_eq(numbers.slice(0, 5), [1, 2, 3, 4, 5])
  assert_eq(numbers.slice(0, 0), [])
  assert_eq(numbers.slice(5, 5), [])
  assert_eq(numbers.slice(2, 5), [3, 4, 5])
  
  // æµ‹è¯•åµŒå¥—é›†åˆè¾¹ç•Œ
  let nested = [[1, 2], [3, 4], [5, 6]]
  assert_eq(nested.length(), 3)
  assert_eq(nested.get(0), Some([1, 2]))
  assert_eq(nested.get(2), Some([5, 6]))
  assert_eq(nested.get(3), None)
}

test "é¥æµ‹ç³»ç»Ÿå¼‚å¸¸æ¢å¤æµ‹è¯•" {
  // æµ‹è¯•traceråœ¨å¼‚å¸¸æ¡ä»¶ä¸‹çš„è¡Œä¸º
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "exception.recovery.test")
  
  // åˆ›å»ºspanå¹¶æ¨¡æ‹Ÿå¼‚å¸¸
  let span = Tracer::start_span(tracer, "exception.prone.operation")
  
  // æ·»åŠ å¼‚å¸¸å±æ€§
  Span::set_attribute(span, "error.type", "NullPointerError")
  Span::set_attribute(span, "error.message", "Attempted to access null reference")
  Span::set_attribute(span, "error.stack_trace", "at line 42 in module.test")
  
  // æ·»åŠ å¼‚å¸¸äº‹ä»¶
  Span::add_event(span, "exception.thrown", [
    ("exception.type", "NullPointerError"),
    ("exception.message", "Null reference access"),
    ("timestamp", "2025-01-02T10:30:45Z")
  ])
  
  // æµ‹è¯•å¼‚å¸¸æ¢å¤
  Span::add_event(span, "recovery.attempt", [
    ("retry.count", IntValue(1)),
    ("recovery.strategy", "circuit_breaker")
  ])
  
  // è®¾ç½®æ¢å¤çŠ¶æ€
  Span::set_status(span, Error, Some("Operation failed but recovery initiated"))
  
  // æµ‹è¯•spanåœ¨å¼‚å¸¸åä»ç„¶å¯ç”¨
  let span_ctx = Span::span_context(span)
  assert_true(SpanContext::is_valid(span_ctx))
  
  Span::end(span)
  
  // æµ‹è¯•æ—¥å¿—å¼‚å¸¸è®°å½•
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "exception.logger")
  
  let exception_log = LogRecord::new(Error, "Unhandled exception in telemetry system")
  LogRecord::add_attribute(exception_log, "exception.category", "system")
  LogRecord::add_attribute(exception_log, "exception.severity", "high")
  LogRecord::add_attribute(exception_log, "exception.recoverable", true)
  
  Logger::emit(logger, exception_log)
  
  assert_true(true)
}

test "èµ„æºè€—å°½è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•å†…å­˜èµ„æºè€—å°½åœºæ™¯
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "resource.exhaustion.test")
  
  // åˆ›å»ºå¤§é‡spanæ¨¡æ‹Ÿèµ„æºè€—å°½
  let spans = []
  for i in 0..=100 {
    let span = Tracer::start_span(tracer, "resource.intensive.operation." + i.to_string())
    Span::set_attribute(span, "operation.id", i.to_string())
    Span::set_attribute(span, "memory.usage", "high")
    spans = spans.push(span)
  }
  
  // æµ‹è¯•åº¦é‡èµ„æºè€—å°½
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "resource.metrics")
  
  let memory_gauge = Meter::create_gauge(meter, "memory.usage", Some("Memory usage"), Some("bytes"))
  
  // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨ç‡ä¸Šå‡
  Gauge::record(memory_gauge, 1024.0 * 1024.0 * 100.0)  // 100MB
  Gauge::record(memory_gauge, 1024.0 * 1024.0 * 200.0)  // 200MB
  Gauge::record(memory_gauge, 1024.0 * 1024.0 * 400.0)  // 400MB
  
  // æµ‹è¯•èµ„æºè€—å°½æ—¶çš„åº¦é‡
  let resource_counter = Meter::create_counter(meter, "resource.exhaustion.events", Some("Resource exhaustion events"), Some("count"))
  Counter::add_with_attributes(resource_counter, 1.0, [
    ("resource.type", "memory"),
    ("exhaustion.level", "critical"),
    ("recovery.action", "garbage_collection")
  ])
  
  // æ¸…ç†èµ„æº
  for span in spans {
    Span::end(span)
  }
  
  assert_true(true)
}

test "ç½‘ç»œè¿æ¥å¼‚å¸¸è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•ç½‘ç»œè¿æ¥å¼‚å¸¸åœºæ™¯
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "network.exception.test")
  
  let network_span = Tracer::start_span(tracer, "network.operation")
  
  // æ¨¡æ‹Ÿç½‘ç»œè¿æ¥å¼‚å¸¸
  Span::add_event(network_span, "connection.attempt", [
    ("target.host", "api.example.com"),
    ("target.port", IntValue(443)),
    ("protocol", "https")
  ])
  
  // æ¨¡æ‹Ÿè¿æ¥è¶…æ—¶
  Span::add_event(network_span, "connection.timeout", [
    ("timeout.duration", IntValue(30000)),
    ("timeout.reason", "connection_refused"),
    ("retry.attempt", IntValue(1))
  ])
  
  // æ¨¡æ‹Ÿè¿æ¥æ¢å¤
  Span::add_event(network_span, "connection.recovered", [
    ("recovery.time", "2025-01-02T10:35:00Z"),
    ("recovery.method", "circuit_breaker_reset"),
    ("total.downtime", IntValue(45000))
  ])
  
  // è®¾ç½®ç½‘ç»œè¿æ¥çŠ¶æ€
  Span::set_status(network_span, Ok, Some("Network connection recovered after timeout"))
  
  // æµ‹è¯•ç½‘ç»œåº¦é‡å¼‚å¸¸
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "network.metrics")
  
  let connection_counter = Meter::create_counter(meter, "network.connections", Some("Network connections"), Some("count"))
  Counter::add_with_attributes(connection_counter, 1.0, [
    ("connection.status", "failed"),
    ("error.type", "timeout"),
    ("retry.count", IntValue(1))
  ])
  
  Counter::add_with_attributes(connection_counter, 1.0, [
    ("connection.status", "success"),
    ("recovery.time", IntValue(45000))
  ])
  
  // æµ‹è¯•ç½‘ç»œé”™è¯¯æ—¥å¿—
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "network.logger")
  
  let error_log = LogRecord::new(Error, "Network connection timeout occurred")
  LogRecord::add_attribute(error_log, "network.endpoint", "api.example.com:443")
  LogRecord::add_attribute(error_log, "network.error", "ECONNREFUSED")
  LogRecord::add_attribute(error_log, "network.recovery", "successful")
  
  Logger::emit(logger, error_log)
  
  Span::end(network_span)
  assert_true(true)
}

test "å¹¶å‘å’Œç«æ€æ¡ä»¶è¾¹ç•Œæµ‹è¯•" {
  // æµ‹è¯•å¹¶å‘æ“ä½œä¸­çš„ç«æ€æ¡ä»¶
  let tracer_provider = TracerProvider::default()
  let tracer = TracerProvider::get_tracer(tracer_provider, "concurrency.race.test")
  
  // åˆ›å»ºå¹¶å‘spanæ¨¡æ‹Ÿç«æ€æ¡ä»¶
  let concurrent_spans = []
  for i in 0..=10 {
    let span = Tracer::start_span(tracer, "concurrent.race.operation." + i.to_string())
    Span::set_attribute(span, "thread.id", i.to_string())
    Span::set_attribute(span, "race.condition", "shared_resource_access")
    concurrent_spans = concurrent_spans.push(span)
  }
  
  // æ¨¡æ‹Ÿå…±äº«èµ„æºè®¿é—®
  for (i, span) in concurrent_spans.enumerate() {
    Span::add_event(span, "resource.access", [
      ("resource.id", "shared_counter"),
      ("access.type", "write"),
      ("thread.id", i.to_string()),
      ("timestamp", (1735689600000 + i * 100).to_string())
    ])
  }
  
  // æµ‹è¯•å¹¶å‘åº¦é‡ä¸€è‡´æ€§
  let meter_provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(meter_provider, "concurrency.metrics")
  
  let race_counter = Meter::create_counter(meter, "race.conditions.detected", Some("Race conditions detected"), Some("count"))
  
  // æ¨¡æ‹Ÿç«æ€æ¡ä»¶æ£€æµ‹
  for i in 0..=10 {
    Counter::add_with_attributes(race_counter, 1.0, [
      ("race.type", "data_race"),
      ("detection.method", "thread_sanitizer"),
      ("severity", i > 5 ? "high" : "medium")
    ])
  }
  
  // æµ‹è¯•å¹¶å‘æ—¥å¿—è®°å½•
  let logger_provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(logger_provider, "concurrency.logger")
  
  let race_log = LogRecord::new(Warn, "Potential race condition detected in shared resource access")
  LogRecord::add_attribute(race_log, "concurrency.issue", "race_condition")
  LogRecord::add_attribute(race_log, "affected.resource", "shared_counter")
  LogRecord::add_attribute(race_log, "mitigation.strategy", "mutex_protection")
  
  Logger::emit(logger, race_log)
  
  // æ¸…ç†å¹¶å‘span
  for span in concurrent_spans {
    Span::end(span)
  }
  
  assert_true(true)
}