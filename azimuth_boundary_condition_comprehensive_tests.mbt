// Azimuth è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µæµ‹è¯•
// ä¸“æ³¨äºç³»ç»Ÿåœ¨å„ç§è¾¹ç•Œæ¡ä»¶å’Œå¼‚å¸¸æƒ…å†µä¸‹çš„è¡Œä¸º

// æµ‹è¯•1: ç©ºå€¼å’ŒNoneç±»å‹å¤„ç†
test "ç©ºå€¼å’ŒNoneç±»å‹å¤„ç†æµ‹è¯•" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_string = ""
  assert_eq(empty_string.length(), 0)
  assert_true(empty_string.is_empty())
  assert_false(empty_string.contains("anything"))
  
  // æµ‹è¯•Noneç±»å‹å¤„ç†
  let none_value : Option[Int] = None
  match none_value {
    None => assert_true(true)
    Some(_) => assert_true(false)  // ä¸åº”è¯¥æ‰§è¡Œåˆ°è¿™é‡Œ
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_array : Array[Int] = []
  assert_eq(empty_array.length(), 0)
  assert_true(empty_array.is_empty())
  
  // æµ‹è¯•ç©ºæ˜ å°„
  let empty_map : Map[String, Int] = Map::new()
  assert_eq(empty_map.size(), 0)
  assert_true(empty_map.is_empty())
}

// æµ‹è¯•2: æ•°å€¼è¾¹ç•Œæ¡ä»¶
test "æ•°å€¼è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•æœ€å¤§å€¼å’Œæœ€å°å€¼
  let max_int = 2147483647  // 32ä½æœ‰ç¬¦å·æ•´æ•°æœ€å¤§å€¼
  let min_int = -2147483648  // 32ä½æœ‰ç¬¦å·æ•´æ•°æœ€å°å€¼
  
  assert_eq(max_int + 0, max_int)
  assert_eq(min_int + 0, min_int)
  assert_eq(max_int - 1, 2147483646)
  assert_eq(min_int + 1, -2147483647)
  
  // æµ‹è¯•é›¶å€¼æ“ä½œ
  assert_eq(0 * max_int, 0)
  assert_eq(0 * min_int, 0)
  assert_eq(0 / 1, 0)
  
  // æµ‹è¯•é™¤é›¶é”™è¯¯å¤„ç†
  let result = try {
    10 / 0
  } catch {
    DivisionByZero => -1  // è¿”å›ç‰¹æ®Šå€¼è¡¨ç¤ºé”™è¯¯
  }
  assert_eq(result, -1)
}

// æµ‹è¯•3: å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶
test "å­—ç¬¦ä¸²è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•è¶…é•¿å­—ç¬¦ä¸²
  let long_string = "a" * 10000
  assert_eq(long_string.length(), 10000)
  assert_true(long_string.contains("a"))
  assert_false(long_string.contains("b"))
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  for i in 0..<special_chars.length() {
    let char = special_chars.substring(i, 1)
    assert_true(special_chars.contains(char))
  }
  
  // æµ‹è¯•Unicodeå­—ç¬¦
  let unicode_string = "æµ‹è¯•å­—ç¬¦ä¸²ğŸš€ğŸŒŸ"
  assert_eq(unicode_string.length(), 8)  // æ³¨æ„ï¼šä¸­æ–‡å­—ç¬¦åœ¨UTF-8ä¸­å 3ä¸ªå­—èŠ‚
  assert_true(unicode_string.contains("æµ‹è¯•"))
  assert_true(unicode_string.contains("ğŸš€"))
}

// æµ‹è¯•4: æ•°ç»„å’Œé›†åˆè¾¹ç•Œæ¡ä»¶
test "æ•°ç»„å’Œé›†åˆè¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•å•å…ƒç´ æ•°ç»„
  let single_element = [42]
  assert_eq(single_element.length(), 1)
  assert_eq(single_element[0], 42)
  
  // æµ‹è¯•æ•°ç»„è¾¹ç•Œè®¿é—®
  let test_array = [1, 2, 3, 4, 5]
  assert_eq(test_array[0], 1)  // ç¬¬ä¸€ä¸ªå…ƒç´ 
  assert_eq(test_array[test_array.length() - 1], 5)  // æœ€åä¸€ä¸ªå…ƒç´ 
  
  // æµ‹è¯•è¶…å‡ºè¾¹ç•Œè®¿é—®ï¼ˆåº”è¿”å›Noneæˆ–æŠ›å‡ºå¼‚å¸¸ï¼‰
  let out_of_bounds_result = try {
    test_array[100]  // è¶…å‡ºæ•°ç»„é•¿åº¦
  } catch {
    IndexOutOfBounds => -1
  }
  assert_eq(out_of_bounds_result, -1)
  
  // æµ‹è¯•å¤§å‹æ•°ç»„
  let large_array = Array::new(10000, 0)
  assert_eq(large_array.length(), 10000)
  large_array[9999] = 42
  assert_eq(large_array[9999], 42)
}

// æµ‹è¯•5: é€’å½’æ·±åº¦é™åˆ¶
test "é€’å½’æ·±åº¦é™åˆ¶æµ‹è¯•" {
  // å°¾é€’å½’å‡½æ•°
  fn tail_recursive_sum(n : Int, acc : Int) -> Int {
    if n <= 0 {
      acc
    } else {
      tail_recursive_sum(n - 1, acc + n)
    }
  }
  
  // æµ‹è¯•æ­£å¸¸é€’å½’æ·±åº¦
  assert_eq(tail_recursive_sum(100, 0), 5050)
  
  // æµ‹è¯•è¾ƒæ·±çš„é€’å½’ï¼ˆä½†ä¸ä¼šå¯¼è‡´æ ˆæº¢å‡ºï¼‰
  assert_eq(tail_recursive_sum(1000, 0), 500500)
  
  // éå°¾é€’å½’å‡½æ•°ï¼ˆå¯èƒ½å¯¼è‡´æ ˆæº¢å‡ºï¼‰
  fn factorial(n : Int) -> Int {
    if n <= 1 {
      1
    } else {
      n * factorial(n - 1)
    }
  }
  
  // æµ‹è¯•è¾ƒå°çš„é€’å½’æ·±åº¦
  assert_eq(factorial(5), 120)
  assert_eq(factorial(10), 3628800)
}

// æµ‹è¯•6: å†…å­˜åˆ†é…é™åˆ¶
test "å†…å­˜åˆ†é…é™åˆ¶æµ‹è¯•" {
  // æµ‹è¯•å¤§é‡å°å¯¹è±¡åˆ†é…
  let small_objects = Array::new(1000, "")
  for i in 0..<small_objects.length() {
    small_objects[i] = "object_" + i.to_string()
  }
  assert_eq(small_objects.length(), 1000)
  assert_eq(small_objects[0], "object_0")
  assert_eq(small_objects[999], "object_999")
  
  // æµ‹è¯•å¤§å¯¹è±¡åˆ†é…
  let large_string = "x" * 1000000  // 1MBå­—ç¬¦ä¸²
  assert_eq(large_string.length(), 1000000)
  
  // æµ‹è¯•æ•°ç»„æ‰©å®¹
  let dynamic_array = [] : Array[Int]
  for i in 0..<1000 {
    dynamic_array.push(i)
  }
  assert_eq(dynamic_array.length(), 1000)
  assert_eq(dynamic_array[0], 0)
  assert_eq(dynamic_array[999], 999)
}

// æµ‹è¯•7: å¹¶å‘è¾¹ç•Œæ¡ä»¶
test "å¹¶å‘è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•ç©ºå¹¶å‘é˜Ÿåˆ—
  let empty_queue = ConcurrentQueue::new()
  assert_true(empty_queue.is_empty())
  assert_eq(empty_queue.size(), 0)
  
  // æµ‹è¯•å•å…ƒç´ å¹¶å‘é˜Ÿåˆ—
  let single_queue = ConcurrentQueue::new()
  single_queue.enqueue(42)
  assert_false(single_queue.is_empty())
  assert_eq(single_queue.size(), 1)
  
  let dequeued = single_queue.dequeue()
  match dequeued {
    Some(value) => assert_eq(value, 42)
    None => assert_true(false)  // ä¸åº”è¯¥æ‰§è¡Œåˆ°è¿™é‡Œ
  }
  
  assert_true(single_queue.is_empty())
  assert_eq(single_queue.size(), 0)
  
  // æµ‹è¯•ç©ºå¹¶å‘é˜Ÿåˆ—çš„å‡ºé˜Ÿæ“ä½œ
  let empty_dequeue = empty_queue.dequeue()
  match empty_dequeue {
    Some(_) => assert_true(false)  // ä¸åº”è¯¥æ‰§è¡Œåˆ°è¿™é‡Œ
    None => assert_true(true)
  }
}

// æµ‹è¯•8: å¼‚å¸¸å¤„ç†è¾¹ç•Œæ¡ä»¶
test "å¼‚å¸¸å¤„ç†è¾¹ç•Œæ¡ä»¶æµ‹è¯•" {
  // æµ‹è¯•è‡ªå®šä¹‰å¼‚å¸¸
  enum CustomError {
    InvalidInput(String)
    OutOfRange(Int, Int)
    NetworkError(String)
  }
  
  fn validate_value(value : Int) -> Result[Unit, CustomError] {
    if value < 0 {
      Err(InvalidInput("Value cannot be negative"))
    } else if value > 100 {
      Err(OutOfRange(value, 100))
    } else {
      Ok(())
    }
  }
  
  // æµ‹è¯•æ­£å¸¸æƒ…å†µ
  let valid_result = validate_value(50)
  match valid_result {
    Ok(_) => assert_true(true)
    Err(_) => assert_true(false)
  }
  
  // æµ‹è¯•è´Ÿå€¼
  let negative_result = validate_value(-10)
  match negative_result {
    Ok(_) => assert_true(false)
    Err(InvalidInput(msg)) => assert_eq(msg, "Value cannot be negative")
    Err(_) => assert_true(false)
  }
  
  // æµ‹è¯•è¶…å‡ºèŒƒå›´
  let out_of_range_result = validate_value(150)
  match out_of_range_result {
    Ok(_) => assert_true(false)
    Err(OutOfRange(value, max)) => {
      assert_eq(value, 150)
      assert_eq(max, 100)
    }
    Err(_) => assert_true(false)
  }
}