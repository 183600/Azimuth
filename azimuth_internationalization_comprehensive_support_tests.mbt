// Azimuth å›½é™…åŒ–ç»¼åˆæ”¯æŒæµ‹è¯•ç”¨ä¾‹
// ä¸“æ³¨äºé¥æµ‹ç³»ç»Ÿçš„å›½é™…åŒ–åŠŸèƒ½ï¼ŒåŒ…æ‹¬å¤šè¯­è¨€æ”¯æŒã€æœ¬åœ°åŒ–ã€å­—ç¬¦ç¼–ç å¤„ç†ç­‰

// æµ‹è¯•1: å¤šè¯­è¨€æ–‡æœ¬å¤„ç†
test "å¤šè¯­è¨€æ–‡æœ¬å¤„ç†æµ‹è¯•" {
  // åˆ›å»ºå›½é™…åŒ–ç®¡ç†å™¨
  let i18n_manager = I18nManager::new()
  
  // é…ç½®æ”¯æŒçš„è¯­è¨€
  let supported_locales = ["zh-CN", "en-US", "ja-JP", "ko-KR", "fr-FR", "de-DE", "es-ES", "ru-RU"]
  for locale in supported_locales {
    i18n_manager.add_locale(locale)
  }
  
  // æ·»åŠ å¤šè¯­è¨€èµ„æº
  i18n_manager.add_translation("zh-CN", "span.name.default", "é»˜è®¤æ“ä½œ")
  i18n_manager.add_translation("en-US", "span.name.default", "Default Operation")
  i18n_manager.add_translation("ja-JP", "span.name.default", "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ“ä½œ")
  i18n_manager.add_translation("ko-KR", "span.name.default", "ê¸°ë³¸ ì‘ì—…")
  i18n_manager.add_translation("fr-FR", "span.name.default", "OpÃ©ration par dÃ©faut")
  i18n_manager.add_translation("de-DE", "span.name.default", "Standardoperation")
  i18n_manager.add_translation("es-ES", "span.name.default", "OperaciÃ³n predeterminada")
  i18n_manager.add_translation("ru-RU", "span.name.default", "ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ")
  
  i18n_manager.add_translation("zh-CN", "error.message.timeout", "æ“ä½œè¶…æ—¶")
  i18n_manager.add_translation("en-US", "error.message.timeout", "Operation timeout")
  i18n_manager.add_translation("ja-JP", "error.message.timeout", "æ“ä½œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
  i18n_manager.add_translation("ko-KR", "error.message.timeout", "ì‘ì—… ì‹œê°„ ì´ˆê³¼")
  
  // æµ‹è¯•å¤šè¯­è¨€spanåç§°
  let test_locales = ["zh-CN", "en-US", "ja-JP", "ko-KR"]
  let localized_spans = []
  
  for locale in test_locales {
    i18n_manager.set_current_locale(locale)
    let localized_name = i18n_manager.translate("span.name.default")
    
    let span = Span::new(localized_name, Server, TraceContext::new("i18n-trace", "i18n-span", true, ""))
    Span::set_attribute(span, "locale", StringValue(locale))
    Span::set_attribute(span, "localized.name", StringValue(localized_name))
    
    localized_spans = localized_spans.push(span)
  }
  
  // éªŒè¯å¤šè¯­è¨€å¤„ç†
  assert_eq(localized_spans.length(), test_locales.length())
  
  let chinese_span = localized_spans.find(fn(s) { 
    match Span::get_attribute(s, "locale") {
      Some(StringValue(locale)) => locale == "zh-CN"
      _ => false
    }
  })
  assert_true(chinese_span != None)
  
  match chinese_span {
    Some(span) => {
      assert_eq(span.name, "é»˜è®¤æ“ä½œ")
      let localized_name = Span::get_attribute(span, "localized.name")
      assert_eq(localized_name, Some(StringValue("é»˜è®¤æ“ä½œ")))
    }
    None => assert_true(false)
  }
  
  let english_span = localized_spans.find(fn(s) { 
    match Span::get_attribute(s, "locale") {
      Some(StringValue(locale)) => locale == "en-US"
      _ => false
    }
  })
  assert_true(english_span != None)
  
  match english_span {
    Some(span) => {
      assert_eq(span.name, "Default Operation")
      let localized_name = Span::get_attribute(span, "localized.name")
      assert_eq(localized_name, Some(StringValue("Default Operation")))
    }
    None => assert_true(false)
  }
  
  // æµ‹è¯•é”™è¯¯æ¶ˆæ¯æœ¬åœ°åŒ–
  for locale in ["zh-CN", "en-US", "ja-JP", "ko-KR"] {
    i18n_manager.set_current_locale(locale)
    let localized_error = i18n_manager.translate("error.message.timeout")
    
    if locale == "zh-CN" {
      assert_eq(localized_error, "æ“ä½œè¶…æ—¶")
    } else if locale == "en-US" {
      assert_eq(localized_error, "Operation timeout")
    } else if locale == "ja-JP" {
      assert_eq(localized_error, "æ“ä½œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
    } else if locale == "ko-KR" {
      assert_eq(localized_error, "ì‘ì—… ì‹œê°„ ì´ˆê³¼")
    }
  }
  
  // æµ‹è¯•å›é€€æœºåˆ¶
  i18n_manager.set_current_locale("pt-BR")  // æœªé…ç½®çš„è¯­è¨€
  let fallback_text = i18n_manager.translate("span.name.default")
  assert_eq(fallback_text, "span.name.default")  // åº”è¯¥è¿”å›åŸå§‹é”®
}

// æµ‹è¯•2: å­—ç¬¦ç¼–ç å¤„ç†
test "å­—ç¬¦ç¼–ç å¤„ç†æµ‹è¯•" {
  // åˆ›å»ºç¼–ç å¤„ç†å™¨
  let encoding_handler = EncodingHandler::new()
  
  // æµ‹è¯•å¤šç§å­—ç¬¦ç¼–ç 
  let test_strings = [
    { text: "ä¸­æ–‡æµ‹è¯•", encoding: "UTF-8", language: "zh" },
    { text: "English Test", encoding: "UTF-8", language: "en" },
    { text: "æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ", encoding: "UTF-8", language: "ja" },
    { text: "í•œêµ­ì–´ í…ŒìŠ¤íŠ¸", encoding: "UTF-8", language: "ko" },
    { text: "Ğ¢ĞµÑÑ‚ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼", encoding: "UTF-8", language: "ru" },
    { text: "Test en franÃ§ais", encoding: "UTF-8", language: "fr" },
    { text: "Test auf Deutsch", encoding: "UTF-8", language: "de" },
    { text: "Prueba en espaÃ±ol", encoding: "UTF-8", language: "es" },
    { text: "Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", encoding: "UTF-8", language: "ar" },
    { text: "×¢×‘×¨×™×ª ×‘×“×™×§×”", encoding: "UTF-8", language: "he" },
    { text: "à¤¹à¤¿à¤‚à¤¦à¥€ à¤ªà¤°à¥€à¤•à¥à¤·à¤£", encoding: "UTF-8", language: "hi" },
    { text: "à¹„à¸—à¸¢à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸š", encoding: "UTF-8", language: "th" }
  ]
  
  // æµ‹è¯•ç¼–ç è½¬æ¢
  for test_string in test_strings {
    // åŸå§‹UTF-8ç¼–ç 
    let utf8_bytes = encoding_handler.encode(test_string.text, "UTF-8")
    assert_true(utf8_bytes.length() > 0)
    
    // è§£ç éªŒè¯
    let decoded_text = encoding_handler.decode(utf8_bytes, "UTF-8")
    assert_eq(decoded_text, test_string.text)
    
    // åˆ›å»ºåŒ…å«å¤šè¯­è¨€æ–‡æœ¬çš„span
    let span = Span::new("encoding.test", Server, TraceContext::new("encoding-trace", "encoding-span", true, ""))
    Span::set_attribute(span, "multilingual.text", StringValue(test_string.text))
    Span::set_attribute(span, "language", StringValue(test_string.language))
    Span::set_attribute(span, "encoding", StringValue(test_string.encoding))
    
    // åºåˆ—åŒ–æµ‹è¯•
    let serialized = JsonSerializer::serialize_span(span)
    assert_true(serialized.contains(test_string.text))
    
    // ååºåˆ—åŒ–æµ‹è¯•
    let deserialized = JsonSerializer::deserialize_span(serialized)
    let multilingual_attr = Span::get_attribute(deserialized, "multilingual.text")
    assert_eq(multilingual_attr, Some(StringValue(test_string.text)))
  }
  
  // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†
  let special_characters = [
    "emoji: ğŸ˜ŠğŸ˜¢ğŸ‰ğŸš€",
    "math: âˆ‘âˆâˆ«âˆ†âˆ‡âˆ‚",
    "currency: $â‚¬Â£Â¥â‚¹â‚½",
    "symbols: Â©Â®â„¢Â§Â¶â€ â€¡â€¢â€¦â€°",
    "quotes: ""''""""ã€Œã€ã€ã€ã€ã€‘",
    "punctuation: ï¼Œã€‚ï¼›ï¼šï¼Ÿï¼""''ï¼ˆï¼‰ã€ã€‘ã€Šã€‹",
    "arrows: â†â†’â†‘â†“â†–â†—â†˜â†™â‡â‡’â‡‘â‡“",
    "mixed: Hello ä¸–ç•Œ! ğŸŒ ã“ã‚“ã«ã¡ã¯ test 123"
  ]
  
  for special_text in special_characters {
    // æµ‹è¯•ç‰¹æ®Šå­—ç¬¦çš„ç¼–ç å¤„ç†
    let encoded = encoding_handler.encode(special_text, "UTF-8")
    let decoded = encoding_handler.decode(encoded, "UTF-8")
    assert_eq(decoded, special_text)
    
    // æµ‹è¯•åœ¨spanå±æ€§ä¸­çš„ä½¿ç”¨
    let span = Span::new("special.char.test", Server, TraceContext::new("special-trace", "special-span", true, ""))
    Span::set_attribute(span, "special.text", StringValue(special_text))
    
    let attr_value = Span::get_attribute(span, "special.text")
    assert_eq(attr_value, Some(StringValue(special_text)))
  }
  
  // æµ‹è¯•ç¼–ç é”™è¯¯å¤„ç†
  let invalid_utf8 = [0xFF, 0xFE, 0xFD]  // æ— æ•ˆçš„UTF-8åºåˆ—
  let error_handling_result = encoding_handler.safe_decode(invalid_utf8, "UTF-8")
  
  match error_handling_result {
    Ok(text) => assert_true(false)  // ä¸åº”è¯¥æˆåŠŸ
    Err(error) => {
      assert_eq(error.error_type, "encoding_error")
      assert_true(error.message.contains("invalid UTF-8"))
    }
  }
  
  // æµ‹è¯•BOMå¤„ç†
  let text_with_bom = "\uFEFFä¸­æ–‡æµ‹è¯•"  // å¸¦BOMçš„æ–‡æœ¬
  let bom_encoded = encoding_handler.encode(text_with_bom, "UTF-8")
  let bom_removed = encoding_handler.remove_bom(bom_encoded)
  let bom_decoded = encoding_handler.decode(bom_removed, "UTF-8")
  assert_eq(bom_decoded, "ä¸­æ–‡æµ‹è¯•")  // BOMåº”è¯¥è¢«ç§»é™¤
}

// æµ‹è¯•3: æ—¶åŒºå’Œæ—¥æœŸæ—¶é—´æœ¬åœ°åŒ–
test "æ—¶åŒºå’Œæ—¥æœŸæ—¶é—´æœ¬åœ°åŒ–æµ‹è¯•" {
  // åˆ›å»ºæ—¶åŒºç®¡ç†å™¨
  let timezone_manager = TimezoneManager::new()
  
  // é…ç½®å¸¸ç”¨æ—¶åŒº
  let timezones = [
    "UTC", "Asia/Shanghai", "Asia/Tokyo", "Asia/Seoul", "America/New_York", 
    "America/Los_Angeles", "Europe/London", "Europe/Paris", "Europe/Berlin",
    "Australia/Sydney", "Asia/Dubai", "Asia/Kolkata"
  ]
  
  for timezone in timezones {
    timezone_manager.add_timezone(timezone)
  }
  
  // åˆ›å»ºæµ‹è¯•æ—¶é—´æˆ³
  let test_timestamp = 1640995200  // 2022-01-01 00:00:00 UTC
  
  // æµ‹è¯•æ—¶åŒºè½¬æ¢
  let timezone_results = []
  for timezone in timezones {
    let localized_time = timezone_manager.convert_timezone(test_timestamp, "UTC", timezone)
    let formatted_time = timezone_manager.format(localized_time, timezone, "YYYY-MM-DD HH:mm:ss Z")
    
    timezone_results = timezone_results.push({
      timezone: timezone,
      timestamp: localized_time,
      formatted: formatted_time
    })
  }
  
  // éªŒè¯æ—¶åŒºè½¬æ¢ç»“æœ
  let utc_result = timezone_results.find(fn(r) { r.timezone == "UTC" })
  assert_true(utc_result != None)
  match utc_result {
    Some(result) => {
      assert_eq(result.formatted, "2022-01-01 00:00:00 +0000")
    }
    None => assert_true(false)
  }
  
  let shanghai_result = timezone_results.find(fn(r) { r.timezone == "Asia/Shanghai" })
  assert_true(shanghai_result != None)
  match shanghai_result {
    Some(result) => {
      assert_eq(result.formatted, "2022-01-01 08:00:00 +0800")
    }
    None => assert_true(false)
  }
  
  let tokyo_result = timezone_results.find(fn(r) { r.timezone == "Asia/Tokyo" })
  assert_true(tokyo_result != None)
  match tokyo_result {
    Some(result) => {
      assert_eq(result.formatted, "2022-01-01 09:00:00 +0900")
    }
    None => assert_true(false)
  }
  
  let new_york_result = timezone_results.find(fn(r) { r.timezone == "America/New_York" })
  assert_true(new_york_result != None)
  match new_york_result {
    Some(result) => {
      assert_eq(result.formatted, "2021-12-31 19:00:00 -0500")
    }
    None => assert_true(false)
  }
  
  // æµ‹è¯•æ—¥æœŸæ ¼å¼æœ¬åœ°åŒ–
  let date_formatter = DateFormatter::new()
  
  let locale_formats = [
    { locale: "zh-CN", format: "YYYYå¹´MMæœˆDDæ—¥ HH:mm:ss", expected: "2022å¹´01æœˆ01æ—¥ 08:00:00" },
    { locale: "en-US", format: "MM/DD/YYYY hh:mm:ss A", expected: "01/01/2022 08:00:00 AM" },
    { locale: "ja-JP", format: "YYYYå¹´MMæœˆDDæ—¥ HHæ™‚mmåˆ†ssç§’", expected: "2022å¹´01æœˆ01æ—¥ 08æ™‚00åˆ†00ç§’" },
    { locale: "ko-KR", format: "YYYYë…„ MMì›” DDì¼ HH:mm:ss", expected: "2022ë…„ 01ì›” 01ì¼ 08:00:00" },
    { locale: "de-DE", format: "DD.MM.YYYY HH:mm:ss", expected: "01.01.2022 08:00:00" },
    { locale: "fr-FR", format: "DD/MM/YYYY HH:mm:ss", expected: "01/01/2022 08:00:00" }
  ]
  
  for format_info in locale_formats {
    date_formatter.set_locale(format_info.locale)
    let localized_date = date_formatter.format(test_timestamp, "Asia/Shanghai", format_info.format)
    assert_eq(localized_date, format_info.expected)
  }
  
  // æµ‹è¯•æ—¶åŒºæ„ŸçŸ¥çš„spanåˆ›å»º
  let timezone_spans = []
  for timezone in ["UTC", "Asia/Shanghai", "America/New_York", "Europe/London"] {
    let span = Span::new("timezone.test", Server, TraceContext::new("timezone-trace", "timezone-span", true, ""))
    
    let local_time = timezone_manager.convert_timezone(test_timestamp, "UTC", timezone)
    let formatted_time = timezone_manager.format(local_time, timezone, "YYYY-MM-DD HH:mm:ss Z")
    
    Span::set_attribute(span, "timezone", StringValue(timezone))
    Span::set_attribute(span, "local.timestamp", StringValue(formatted_time))
    Span::set_attribute(span, "utc.timestamp", StringValue(timezone_manager.format(test_timestamp, "UTC", "YYYY-MM-DD HH:mm:ss Z")))
    
    timezone_spans = timezone_spans.push(span)
  }
  
  // éªŒè¯æ—¶åŒºæ„ŸçŸ¥çš„span
  let shanghai_span = timezone_spans.find(fn(s) { 
    match Span::get_attribute(s, "timezone") {
      Some(StringValue(tz)) => tz == "Asia/Shanghai"
      _ => false
    }
  })
  assert_true(shanghai_span != None)
  
  match shanghai_span {
    Some(span) => {
      let local_time = Span::get_attribute(span, "local.timestamp")
      assert_eq(local_time, Some(StringValue("2022-01-01 08:00:00 +0800")))
      
      let utc_time = Span::get_attribute(span, "utc.timestamp")
      assert_eq(utc_time, Some(StringValue("2022-01-01 00:00:00 +0000")))
    }
    None => assert_true(false)
  }
}

// æµ‹è¯•4: æ•°å­—å’Œè´§å¸æ ¼å¼æœ¬åœ°åŒ–
test "æ•°å­—å’Œè´§å¸æ ¼å¼æœ¬åœ°åŒ–æµ‹è¯•" {
  // åˆ›å»ºæ•°å­—æ ¼å¼åŒ–å™¨
  let number_formatter = NumberFormatter::new()
  
  // æµ‹è¯•æ•°å­—æ ¼å¼æœ¬åœ°åŒ–
  let test_number = 1234567.89
  let expected_formats = [
    { locale: "zh-CN", expected: "1,234,567.89" },
    { locale: "en-US", expected: "1,234,567.89" },
    { locale: "de-DE", expected: "1.234.567,89" },
    { locale: "fr-FR", expected: "1 234 567,89" },
    { locale: "ja-JP", expected: "1,234,567.89" },
    { locale: "ko-KR", expected: "1,234,567.89" },
    { locale: "ru-RU", expected: "1 234 567,89" },
    { locale: "es-ES", expected: "1.234.567,89" }
  ]
  
  for format_info in expected_formats {
    number_formatter.set_locale(format_info.locale)
    let formatted_number = number_formatter.format(test_number)
    assert_eq(formatted_number, format_info.expected)
  }
  
  // æµ‹è¯•è´§å¸æ ¼å¼æœ¬åœ°åŒ–
  let currency_formatter = CurrencyFormatter::new()
  let test_amount = 1234.56
  
  let currency_formats = [
    { locale: "zh-CN", currency: "CNY", expected: "Â¥1,234.56" },
    { locale: "en-US", currency: "USD", expected: "$1,234.56" },
    { locale: "de-DE", currency: "EUR", expected: "1.234,56 â‚¬" },
    { locale: "fr-FR", currency: "EUR", expected: "1 234,56 â‚¬" },
    { locale: "ja-JP", currency: "JPY", expected: "ï¿¥1,235" },
    { locale: "ko-KR", currency: "KRW", expected: "â‚©1,235" },
    { locale: "ru-RU", currency: "RUB", expected: "1 234,56 â‚½" },
    { locale: "es-ES", currency: "EUR", expected: "1.234,56 â‚¬" }
  ]
  
  for currency_info in currency_formats {
    currency_formatter.set_locale(currency_info.locale)
    let formatted_currency = currency_formatter.format(test_amount, currency_info.currency)
    assert_eq(formatted_currency, currency_info.expected)
  }
  
  // æµ‹è¯•ç™¾åˆ†æ¯”æ ¼å¼æœ¬åœ°åŒ–
  let percentage_formatter = PercentageFormatter::new()
  let test_percentage = 0.1234
  
  let percentage_formats = [
    { locale: "zh-CN", expected: "12.34%" },
    { locale: "en-US", expected: "12.34%" },
    { locale: "de-DE", expected: "12,34 %" },
    { locale: "fr-FR", expected: "12,34 %" },
    { locale: "ja-JP", expected: "12.34%" },
    { locale: "ko-KR", expected: "12.34%" },
    { locale: "ru-RU", expected: "12,34 %" },
    { locale: "es-ES", expected: "12,34 %" }
  ]
  
  for percentage_info in percentage_formats {
    percentage_formatter.set_locale(percentage_info.locale)
    let formatted_percentage = percentage_formatter.format(test_percentage)
    assert_eq(formatted_percentage, percentage_info.expected)
  }
  
  // æµ‹è¯•åœ¨spanå±æ€§ä¸­çš„æœ¬åœ°åŒ–æ•°å­—
  let metric_spans = []
  for locale in ["zh-CN", "en-US", "de-DE", "ja-JP"] {
    let span = Span::new("metric.test", Server, TraceContext::new("metric-trace", "metric-span", true, ""))
    
    number_formatter.set_locale(locale)
    currency_formatter.set_locale(locale)
    percentage_formatter.set_locale(locale)
    
    Span::set_attribute(span, "locale", StringValue(locale))
    Span::set_attribute(span, "formatted.number", StringValue(number_formatter.format(test_number)))
    Span::set_attribute(span, "raw.number", FloatValue(test_number))
    
    let currency_code = if locale == "zh-CN" { "CNY" }
                       else if locale == "en-US" { "USD" }
                       else if locale == "de-DE" { "EUR" }
                       else { "JPY" }
    
    Span::set_attribute(span, "formatted.currency", StringValue(currency_formatter.format(test_amount, currency_code)))
    Span::set_attribute(span, "raw.amount", FloatValue(test_amount))
    
    Span::set_attribute(span, "formatted.percentage", StringValue(percentage_formatter.format(test_percentage)))
    Span::set_attribute(span, "raw.percentage", FloatValue(test_percentage))
    
    metric_spans = metric_spans.push(span)
  }
  
  // éªŒè¯æœ¬åœ°åŒ–æ•°å­—åœ¨spanä¸­çš„æ­£ç¡®æ€§
  let german_span = metric_spans.find(fn(s) { 
    match Span::get_attribute(s, "locale") {
      Some(StringValue(locale)) => locale == "de-DE"
      _ => false
    }
  })
  assert_true(german_span != None)
  
  match german_span {
    Some(span) => {
      let formatted_number = Span::get_attribute(span, "formatted.number")
      assert_eq(formatted_number, Some(StringValue("1.234.567,89")))
      
      let formatted_currency = Span::get_attribute(span, "formatted.currency")
      assert_eq(formatted_currency, Some(StringValue("1.234,56 â‚¬")))
      
      let formatted_percentage = Span::get_attribute(span, "formatted.percentage")
      assert_eq(formatted_percentage, Some(StringValue("12,34 %")))
    }
    None => assert_true(false)
  }
}

// æµ‹è¯•5: æ–‡åŒ–ç‰¹å®šçš„æ ¼å¼å¤„ç†
test "æ–‡åŒ–ç‰¹å®šçš„æ ¼å¼å¤„ç†æµ‹è¯•" {
  // åˆ›å»ºæ–‡åŒ–æ ¼å¼ç®¡ç†å™¨
  let cultural_formatter = CulturalFormatter::new()
  
  // æµ‹è¯•å§“åæ ¼å¼
  let name_test_cases = [
    { 
      locale: "zh-CN", 
      first_name: "å°æ˜", 
      last_name: "å¼ ", 
      expected_formats: [
        { style: "full", expected: "å¼ å°æ˜" },
        { style: "formal", expected: "å¼ å…ˆç”Ÿ" },
        { style: "informal", expected: "å°æ˜" }
      ]
    },
    { 
      locale: "en-US", 
      first_name: "John", 
      last_name: "Smith", 
      expected_formats: [
        { style: "full", expected: "John Smith" },
        { style: "formal", expected: "Mr. Smith" },
        { style: "informal", expected: "John" }
      ]
    },
    { 
      locale: "ja-JP", 
      first_name: "å¤ªéƒ", 
      last_name: "ç”°ä¸­", 
      expected_formats: [
        { style: "full", expected: "ç”°ä¸­å¤ªéƒ" },
        { style: "formal", expected: "ç”°ä¸­ã•ã‚“" },
        { style: "informal", expected: "å¤ªéƒ" }
      ]
    },
    { 
      locale: "ko-KR", 
      first_name: "ë¯¼ì¤€", 
      last_name: "ê¹€", 
      expected_formats: [
        { style: "full", expected: "ê¹€ë¯¼ì¤€" },
        { style: "formal", expected: "ê¹€ì”¨" },
        { style: "informal", expected: "ë¯¼ì¤€" }
      ]
    }
  ]
  
  for test_case in name_test_cases {
    cultural_formatter.set_locale(test_case.locale)
    
    for format_info in test_case.expected_formats {
      let formatted_name = cultural_formatter.format_name(
        test_case.first_name, 
        test_case.last_name, 
        format_info.style
      )
      assert_eq(formatted_name, format_info.expected)
    }
  }
  
  // æµ‹è¯•åœ°å€æ ¼å¼
  let address_test_cases = [
    {
      locale: "zh-CN",
      components: {
        country: "ä¸­å›½",
        province: "åŒ—äº¬å¸‚",
        city: "åŒ—äº¬å¸‚",
        district: "æœé˜³åŒº",
        street: "å»ºå›½é—¨å¤–å¤§è¡—1å·",
        postal_code: "100020"
      },
      expected: "ä¸­å›½åŒ—äº¬å¸‚æœé˜³åŒºå»ºå›½é—¨å¤–å¤§è¡—1å· 100020"
    },
    {
      locale: "en-US",
      components: {
        street: "123 Main Street",
        city: "New York",
        state: "NY",
        postal_code: "10001",
        country: "USA"
      },
      expected: "123 Main Street\nNew York, NY 10001\nUSA"
    },
    {
      locale: "ja-JP",
      components: {
        postal_code: "100-0001",
        prefecture: "æ±äº¬éƒ½",
        city: "åƒä»£ç”°åŒº",
        ward: "åƒä»£ç”°",
        street: "ä¸¸ã®å†…1-1-1"
      },
      expected: "ã€’100-0001 æ±äº¬éƒ½åƒä»£ç”°åŒºä¸¸ã®å†…1-1-1"
    }
  ]
  
  for test_case in address_test_cases {
    cultural_formatter.set_locale(test_case.locale)
    let formatted_address = cultural_formatter.format_address(test_case.components)
    assert_eq(formatted_address, test_case.expected)
  }
  
  // æµ‹è¯•ç”µè¯å·ç æ ¼å¼
  let phone_test_cases = [
    { locale: "zh-CN", number: "+8613812345678", expected: "138-1234-5678" },
    { locale: "en-US", number: "+12125551234", expected: "(212) 555-1234" },
    { locale: "ja-JP", number: "+81312345678", expected: "03-1234-5678" },
    { locale: "ko-KR", number: "+8212345678", expected: "010-1234-5678" },
    { locale: "de-DE", number: "+4912345678", expected: "01234 5678" },
    { locale: "fr-FR", number: "+3312345678", expected: "01 23 45 67 89" }
  ]
  
  for test_case in phone_test_cases {
    cultural_formatter.set_locale(test_case.locale)
    let formatted_phone = cultural_formatter.format_phone_number(test_case.number)
    assert_eq(formatted_phone, test_case.expected)
  }
  
  // æµ‹è¯•åº¦é‡å•ä½æ ¼å¼
  let measurement_test_cases = [
    { 
      locale: "zh-CN", 
      value: 175.5, 
      unit: "height", 
      expected: "175.5å˜ç±³" 
    },
    { 
      locale: "en-US", 
      value: 175.5, 
      unit: "height", 
      expected: "5'9\"" 
    },
    { 
      locale: "zh-CN", 
      value: 70.5, 
      unit: "weight", 
      expected: "70.5å…¬æ–¤" 
    },
    { 
      locale: "en-US", 
      value: 70.5, 
      unit: "weight", 
      expected: "155.4 lbs" 
    },
    { 
      locale: "zh-CN", 
      value: 100.0, 
      unit: "temperature", 
      expected: "100.0Â°C" 
    },
    { 
      locale: "en-US", 
      value: 100.0, 
      unit: "temperature", 
      expected: "212.0Â°F" 
    }
  ]
  
  for test_case in measurement_test_cases {
    cultural_formatter.set_locale(test_case.locale)
    let formatted_measurement = cultural_formatter.format_measurement(test_case.value, test_case.unit)
    assert_eq(formatted_measurement, test_case.expected)
  }
  
  // æµ‹è¯•æ–‡åŒ–ç‰¹å®šçš„spanå±æ€§
  let cultural_spans = []
  for locale in ["zh-CN", "en-US", "ja-JP"] {
    let span = Span::new("cultural.test", Server, TraceContext::new("cultural-trace", "cultural-span", true, ""))
    
    cultural_formatter.set_locale(locale)
    
    if locale == "zh-CN" {
      Span::set_attribute(span, "user.name", StringValue(cultural_formatter.format_name("å°æ˜", "å¼ ", "full")))
      Span::set_attribute(span, "user.address", StringValue(cultural_formatter.format_address({
        country: "ä¸­å›½",
        province: "åŒ—äº¬å¸‚",
        city: "åŒ—äº¬å¸‚",
        district: "æœé˜³åŒº",
        street: "å»ºå›½é—¨å¤–å¤§è¡—1å·",
        postal_code: "100020"
      })))
      Span::set_attribute(span, "user.phone", StringValue(cultural_formatter.format_phone_number("+8613812345678")))
      Span::set_attribute(span, "user.height", StringValue(cultural_formatter.format_measurement(175.5, "height")))
    } else if locale == "en-US" {
      Span::set_attribute(span, "user.name", StringValue(cultural_formatter.format_name("John", "Smith", "full")))
      Span::set_attribute(span, "user.address", StringValue(cultural_formatter.format_address({
        street: "123 Main Street",
        city: "New York",
        state: "NY",
        postal_code: "10001",
        country: "USA"
      })))
      Span::set_attribute(span, "user.phone", StringValue(cultural_formatter.format_phone_number("+12125551234")))
      Span::set_attribute(span, "user.height", StringValue(cultural_formatter.format_measurement(175.5, "height")))
    } else if locale == "ja-JP" {
      Span::set_attribute(span, "user.name", StringValue(cultural_formatter.format_name("å¤ªéƒ", "ç”°ä¸­", "full")))
      Span::set_attribute(span, "user.address", StringValue(cultural_formatter.format_address({
        postal_code: "100-0001",
        prefecture: "æ±äº¬éƒ½",
        city: "åƒä»£ç”°åŒº",
        ward: "åƒä»£ç”°",
        street: "ä¸¸ã®å†…1-1-1"
      })))
      Span::set_attribute(span, "user.phone", StringValue(cultural_formatter.format_phone_number("+81312345678")))
      Span::set_attribute(span, "user.height", StringValue(cultural_formatter.format_measurement(175.5, "height")))
    }
    
    Span::set_attribute(span, "locale", StringValue(locale))
    cultural_spans = cultural_spans.push(span)
  }
  
  // éªŒè¯æ–‡åŒ–ç‰¹å®šçš„spanå±æ€§
  let chinese_span = cultural_spans.find(fn(s) { 
    match Span::get_attribute(s, "locale") {
      Some(StringValue(locale)) => locale == "zh-CN"
      _ => false
    }
  })
  assert_true(chinese_span != None)
  
  match chinese_span {
    Some(span) => {
      let user_name = Span::get_attribute(span, "user.name")
      assert_eq(user_name, Some(StringValue("å¼ å°æ˜")))
      
      let user_phone = Span::get_attribute(span, "user.phone")
      assert_eq(user_phone, Some(StringValue("138-1234-5678")))
      
      let user_height = Span::get_attribute(span, "user.height")
      assert_eq(user_height, Some(StringValue("175.5å˜ç±³")))
    }
    None => assert_true(false)
  }
}

// æµ‹è¯•6: å³åˆ°å·¦è¯­è¨€æ”¯æŒ
test "å³åˆ°å·¦è¯­è¨€æ”¯æŒæµ‹è¯•" {
  // åˆ›å»ºåŒå‘æ–‡æœ¬å¤„ç†å™¨
  let bidi_processor = BidiProcessor::new()
  
  // æµ‹è¯•RTLè¯­è¨€
  let rtl_test_cases = [
    { 
      language: "ar", 
      text: "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", 
      direction: "rtl",
      expected_visual: "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"
    },
    { 
      language: "he", 
      text: "×©×œ×•× ×¢×•×œ×", 
      direction: "rtl",
      expected_visual: "×©×œ×•× ×¢×•×œ×"
    },
    { 
      language: "fa", 
      text: "Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§", 
      direction: "rtl",
      expected_visual: "Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§"
    },
    { 
      language: "ur", 
      text: "ÛÛŒÙ„Ùˆ Ø¯Ù†ÛŒØ§", 
      direction: "rtl",
      expected_visual: "ÛÛŒÙ„Ùˆ Ø¯Ù†ÛŒØ§"
    }
  ]
  
  for test_case in rtl_test_cases {
    bidi_processor.set_direction(test_case.direction)
    
    // æ£€æµ‹æ–‡æœ¬æ–¹å‘
    let detected_direction = bidi_processor.detect_direction(test_case.text)
    assert_eq(detected_direction, test_case.direction)
    
    // å¤„ç†åŒå‘æ–‡æœ¬
    let processed_text = bidi_processor.process(test_case.text)
    assert_eq(processed_text, test_case.expected_visual)
    
    // åˆ›å»ºåŒ…å«RTLæ–‡æœ¬çš„span
    let span = Span::new("rtl.test", Server, TraceContext::new("rtl-trace", "rtl-span", true, ""))
    Span::set_attribute(span, "language", StringValue(test_case.language))
    Span::set_attribute(span, "text.direction", StringValue(test_case.direction))
    Span::set_attribute(span, "rtl.text", StringValue(test_case.text))
    Span::set_attribute(span, "processed.text", StringValue(processed_text))
    
    // éªŒè¯RTLæ–‡æœ¬åœ¨spanä¸­çš„å¤„ç†
    let rtl_attr = Span::get_attribute(span, "rtl.text")
    assert_eq(rtl_attr, Some(StringValue(test_case.text)))
    
    let processed_attr = Span::get_attribute(span, "processed.text")
    assert_eq(processed_attr, Some(StringValue(processed_text)))
  }
  
  // æµ‹è¯•æ··åˆLTRå’ŒRTLæ–‡æœ¬
  let mixed_text_cases = [
    { 
      text: "Hello Ù…Ø±Ø­Ø¨Ø§ World", 
      expected: "Hello Ù…Ø±Ø­Ø¨Ø§ World",
      base_direction: "ltr"
    },
    { 
      text: "Ù…Ø±Ø­Ø¨Ø§ Hello Ø§Ù„Ø¹Ø§Ù„Ù…", 
      expected: "Ù…Ø±Ø­Ø¨Ø§ Hello Ø§Ù„Ø¹Ø§Ù„Ù…",
      base_direction: "rtl"
    },
    { 
      text: "123 Ù…Ø±Ø­Ø¨Ø§ 456", 
      expected: "123 Ù…Ø±Ø­Ø¨Ø§ 456",
      base_direction: "ltr"
    },
    { 
      text: "Ù…Ø±Ø­Ø¨Ø§ (123) test", 
      expected: "Ù…Ø±Ø­Ø¨Ø§ (123) test",
      base_direction: "rtl"
    }
  ]
  
  for mixed_case in mixed_text_cases {
    bidi_processor.set_base_direction(mixed_case.base_direction)
    let processed_mixed = bidi_processor.process(mixed_case.text)
    assert_eq(processed_mixed, mixed_case.expected)
  }
  
  // æµ‹è¯•RTLæ•°å­—å’Œæ ‡ç‚¹ç¬¦å·å¤„ç†
  let rtl_numbers_test = [
    { text: "Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©", expected: "Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©" },  // é˜¿æ‹‰ä¼¯æ•°å­—
    { text: "Û±Û²Û³Û´ÛµÛ¶Û·Û¸Û¹", expected: "Û±Û²Û³Û´ÛµÛ¶Û·Û¸Û¹" },  // æ³¢æ–¯æ•°å­—
    { text: "Ù…Ø±Ø­Ø¨Ø§! ÙƒÙŠÙ Ø­Ø§Ù„ÙƒØŸ", expected: "Ù…Ø±Ø­Ø¨Ø§! ÙƒÙŠÙ Ø­Ø§Ù„ÙƒØŸ" },  // RTLæ ‡ç‚¹
    { text: "(Ù…Ø±Ø­Ø¨Ø§) [test]", expected: "(Ù…Ø±Ø­Ø¨Ø§) [test]" }  // æ··åˆæ‹¬å·
  ]
  
  for number_test in rtl_numbers_test {
    let processed_numbers = bidi_processor.process(number_test.text)
    assert_eq(processed_numbers, number_test.expected)
  }
  
  // æµ‹è¯•RTLæ–‡æœ¬çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–
  let rtl_span = Span::new("rtl.serialization.test", Server, TraceContext::new("rtl-serialization-trace", "rtl-serialization-span", true, ""))
  Span::set_attribute(span, "arabic.text", StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"))
  Span::set_attribute(span, "hebrew.text", StringValue("×©×œ×•× ×¢×•×œ×"))
  Span::set_attribute(span, "mixed.text", StringValue("Hello Ù…Ø±Ø­Ø¨Ø§ World"))
  
  // åºåˆ—åŒ–
  let serialized = JsonSerializer::serialize_span(rtl_span)
  assert_true(serialized.contains("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…"))
  assert_true(serialized.contains("×©×œ×•× ×¢×•×œ×"))
  assert_true(serialized.contains("Hello Ù…Ø±Ø­Ø¨Ø§ World"))
  
  // ååºåˆ—åŒ–
  let deserialized = JsonSerializer::deserialize_span(serialized)
  let arabic_attr = Span::get_attribute(deserialized, "arabic.text")
  let hebrew_attr = Span::get_attribute(deserialized, "hebrew.text")
  let mixed_attr = Span::get_attribute(deserialized, "mixed.text")
  
  assert_eq(arabic_attr, Some(StringValue("Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…")))
  assert_eq(hebrew_attr, Some(StringValue("×©×œ×•× ×¢×•×œ×")))
  assert_eq(mixed_attr, Some(StringValue("Hello Ù…Ø±Ø­Ø¨Ø§ World")))
}

// æµ‹è¯•7: å¤åˆè„šæœ¬å’Œå¤šè¯­è¨€æ··åˆ
test "å¤åˆè„šæœ¬å’Œå¤šè¯­è¨€æ··åˆæµ‹è¯•" {
  // åˆ›å»ºå¤åˆè„šæœ¬å¤„ç†å™¨
  let complex_script_processor = ComplexScriptProcessor::new()
  
  // æµ‹è¯•å¤åˆè„šæœ¬è¯­è¨€
  let complex_script_cases = [
    { 
      language: "hi", 
      text: "à¤¨à¤®à¤¸à¥à¤¤à¥‡ à¤¦à¥à¤¨à¤¿à¤¯à¤¾", 
      script: "Devanagari"
    },
    { 
      language: "th", 
      text: "à¸ªà¸§à¸±à¸ªà¸”à¸µà¸Šà¸²à¸§à¹‚à¸¥à¸", 
      script: "Thai"
    },
    { 
      language: "ko", 
      text: "ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„", 
      script: "Hangul"
    },
    { 
      language: "zh", 
      text: "ä½ å¥½ä¸–ç•Œ", 
      script: "Han"
    },
    { 
      language: "ja", 
      text: "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ", 
      script: "Han+Kana"
    }
  ]
  
  for test_case in complex_script_cases {
    // æ£€æµ‹è„šæœ¬
    let detected_script = complex_script_processor.detect_script(test_case.text)
    assert_eq(detected_script, test_case.script)
    
    // å¤„ç†å¤åˆè„šæœ¬
    let processed_text = complex_script_processor.process(test_case.text)
    assert_eq(processed_text, test_case.text)
    
    // åˆ›å»ºåŒ…å«å¤åˆè„šæœ¬çš„span
    let span = Span::new("complex.script.test", Server, TraceContext::new("complex-script-trace", "complex-script-span", true, ""))
    Span::set_attribute(span, "language", StringValue(test_case.language))
    Span::set_attribute(span, "script", StringValue(test_case.script))
    Span::set_attribute(span, "complex.text", StringValue(test_case.text))
    
    // éªŒè¯å¤åˆè„šæœ¬åœ¨spanä¸­çš„å¤„ç†
    let script_attr = Span::get_attribute(span, "script")
    assert_eq(script_attr, Some(StringValue(test_case.script)))
    
    let text_attr = Span::get_attribute(span, "complex.text")
    assert_eq(text_attr, Some(StringValue(test_case.text)))
  }
  
  // æµ‹è¯•å¤šè¯­è¨€æ··åˆæ–‡æœ¬
  let multilingual_mixed_cases = [
    { 
      text: "Hello ä½ å¥½ ã“ã‚“ã«ã¡ã¯ ì•ˆë…•í•˜ì„¸ìš”", 
      languages: ["en", "zh", "ja", "ko"],
      expected_segments: [
        { text: "Hello", language: "en" },
        { text: "ä½ å¥½", language: "zh" },
        { text: "ã“ã‚“ã«ã¡ã¯", language: "ja" },
        { text: "ì•ˆë…•í•˜ì„¸ìš”", language: "ko" }
      ]
    },
    { 
      text: "Ù…Ø±Ø­Ø¨Ø§ Hello ×©×œ×•×", 
      languages: ["ar", "en", "he"],
      expected_segments: [
        { text: "Ù…Ø±Ø­Ø¨Ø§", language: "ar" },
        { text: "Hello", language: "en" },
        { text: "×©×œ×•×", language: "he" }
      ]
    },
    { 
      text: "à¤¨à¤®à¤¸à¥à¤¤à¥‡ ã“ã‚“ã«ã¡ã¯ à¸ªà¸§à¸±à¸ªà¸”à¸µ", 
      languages: ["hi", "ja", "th"],
      expected_segments: [
        { text: "à¤¨à¤®à¤¸à¥à¤¤à¥‡", language: "hi" },
        { text: "ã“ã‚“ã«ã¡ã¯", language: "ja" },
        { text: "à¸ªà¸§à¸±à¸ªà¸”à¸µ", language: "th" }
      ]
    }
  ]
  
  for mixed_case in multilingual_mixed_cases {
    // åˆ†æ®µå¤šè¯­è¨€æ–‡æœ¬
    let segments = complex_script_processor.segment_multilingual(mixed_case.text)
    assert_eq(segments.length(), mixed_case.expected_segments.length())
    
    for i in 0..=segments.length() - 1 {
      assert_eq(segments[i].text, mixed_case.expected_segments[i].text)
      assert_eq(segments[i].language, mixed_case.expected_segments[i].language)
    }
    
    // åˆ›å»ºåŒ…å«å¤šè¯­è¨€æ··åˆçš„span
    let span = Span::new("multilingual.mixed.test", Server, TraceContext::new("multilingual-mixed-trace", "multilingual-mixed-span", true, ""))
    Span::set_attribute(span, "mixed.text", StringValue(mixed_case.text))
    Span::set_attribute(span, "language.count", IntValue(mixed_case.languages.length()))
    
    // æ·»åŠ è¯­è¨€åˆ†æ®µä¿¡æ¯
    for segment in segments {
      Span::set_attribute(span, "segment." + segment.language, StringValue(segment.text))
    }
    
    // éªŒè¯å¤šè¯­è¨€æ··åˆåœ¨spanä¸­çš„å¤„ç†
    let mixed_attr = Span::get_attribute(span, "mixed.text")
    assert_eq(mixed_attr, Some(StringValue(mixed_case.text)))
    
    let lang_count_attr = Span::get_attribute(span, "language.count")
    assert_eq(lang_count_attr, Some(IntValue(mixed_case.languages.length())))
  }
  
  // æµ‹è¯•éŸ³è¯‘å’Œè½¬å†™
  let transliteration_test_cases = [
    { 
      from: "zh", 
      to: "en", 
      text: "ä½ å¥½", 
      expected: "ni hao"
    },
    { 
      from: "ja", 
      to: "en", 
      text: "ã“ã‚“ã«ã¡ã¯", 
      expected: "konnichiwa"
    },
    { 
      from: "ru", 
      to: "en", 
      text: "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚", 
      expected: "Privet"
    },
    { 
      from: "ar", 
      to: "en", 
      text: "Ù…Ø±Ø­Ø¨Ø§", 
      expected: "marhaban"
    }
  ]
  
  for transliteration_case in transliteration_test_cases {
    let transliterated = complex_script_processor.transliterate(
      transliteration_case.text, 
      transliteration_case.from, 
      transliteration_case.to
    )
    assert_eq(transliterated, transliteration_case.expected)
    
    // åˆ›å»ºåŒ…å«éŸ³è¯‘çš„span
    let span = Span::new("transliteration.test", Server, TraceContext::new("transliteration-trace", "transliteration-span", true, ""))
    Span::set_attribute(span, "original.language", StringValue(transliteration_case.from))
    Span::set_attribute(span, "target.language", StringValue(transliteration_case.to))
    Span::set_attribute(span, "original.text", StringValue(transliteration_case.text))
    Span::set_attribute(span, "transliterated.text", StringValue(transliterated))
    
    // éªŒè¯éŸ³è¯‘åœ¨spanä¸­çš„å¤„ç†
    let original_attr = Span::get_attribute(span, "original.text")
    assert_eq(original_attr, Some(StringValue(transliteration_case.text)))
    
    let transliterated_attr = Span::get_attribute(span, "transliterated.text")
    assert_eq(transliterated_attr, Some(StringValue(transliterated)))
  }
}

// æµ‹è¯•8: å›½é™…åŒ–é…ç½®å’Œå›é€€æœºåˆ¶
test "å›½é™…åŒ–é…ç½®å’Œå›é€€æœºåˆ¶æµ‹è¯•" {
  // åˆ›å»ºå›½é™…åŒ–é…ç½®ç®¡ç†å™¨
  let i18n_config_manager = I18nConfigManager::new()
  
  // é…ç½®é»˜è®¤è¯­è¨€å’Œå›é€€è¯­è¨€
  i18n_config_manager.set_default_locale("en-US")
  i18n_config_manager.set_fallback_locale("en-US")
  i18n_config_manager.set_preferred_locales(["zh-CN", "ja-JP", "ko-KR", "en-US"])
  
  // æ·»åŠ ç¿»è¯‘èµ„æº
  i18n_config_manager.add_translation_bundle("zh-CN", {
    "span.name.default": "é»˜è®¤æ“ä½œ",
    "error.message.timeout": "æ“ä½œè¶…æ—¶",
    "status.success": "æˆåŠŸ",
    "status.failed": "å¤±è´¥"
  })
  
  i18n_config_manager.add_translation_bundle("ja-JP", {
    "span.name.default": "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ“ä½œ",
    "error.message.timeout": "æ“ä½œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ",
    "status.success": "æˆåŠŸ"
    // æ•…æ„ç¼ºå°‘ "status.failed" ç¿»è¯‘
  })
  
  i18n_config_manager.add_translation_bundle("en-US", {
    "span.name.default": "Default Operation",
    "error.message.timeout": "Operation timeout",
    "status.success": "Success",
    "status.failed": "Failed"
  })
  
  // æµ‹è¯•è¯­è¨€åå•†
  let negotiation_test_cases = [
    { 
      accepted_locales: ["zh-CN", "en-US"], 
      expected: "zh-CN" 
    },
    { 
      accepted_locales: ["ja-JP", "ko-KR"], 
      expected: "ja-JP" 
    },
    { 
      accepted_locales: ["fr-FR", "de-DE"], 
      expected: "en-US"  // å›é€€åˆ°é»˜è®¤è¯­è¨€
    },
    { 
      accepted_locales: ["ko-KR"], 
      expected: "en-US"  // ko-KRæœªé…ç½®ï¼Œå›é€€åˆ°é»˜è®¤è¯­è¨€
    }
  ]
  
  for negotiation_case in negotiation_test_cases {
    let negotiated_locale = i18n_config_manager.negotiate_locale(negotiation_case.accepted_locales)
    assert_eq(negotiated_locale, negotiation_case.expected)
  }
  
  // æµ‹è¯•ç¿»è¯‘å›é€€æœºåˆ¶
  let fallback_test_cases = [
    { 
      locale: "zh-CN", 
      key: "span.name.default", 
      expected: "é»˜è®¤æ“ä½œ",
      fallback_used: false
    },
    { 
      locale: "ja-JP", 
      key: "status.failed", 
      expected: "Failed",
      fallback_used: true  // ja-JPç¼ºå°‘æ­¤ç¿»è¯‘ï¼Œå›é€€åˆ°en-US
    },
    { 
      locale: "fr-FR", 
      key: "error.message.timeout", 
      expected: "Operation timeout",
      fallback_used: true  // fr-FRæœªé…ç½®ï¼Œå›é€€åˆ°en-US
    },
    { 
      locale: "ko-KR", 
      key: "nonexistent.key", 
      expected: "nonexistent.key",
      fallback_used: true  // é”®ä¸å­˜åœ¨ï¼Œè¿”å›åŸå§‹é”®
    }
  ]
  
  for fallback_case in fallback_test_cases {
    let translation_result = i18n_config_manager.translate_with_fallback(
      fallback_case.locale, 
      fallback_case.key
    )
    
    assert_eq(translation_result.text, fallback_case.expected)
    assert_eq(translation_result.fallback_used, fallback_case.fallback_used)
    
    if fallback_case.fallback_used {
      assert_true(translation_result.fallback_locale.length() > 0)
    }
  }
  
  // æµ‹è¯•åŠ¨æ€è¯­è¨€åˆ‡æ¢
  let dynamic_test_spans = []
  
  // åˆå§‹ä½¿ç”¨ä¸­æ–‡
  i18n_config_manager.set_current_locale("zh-CN")
  let zh_name = i18n_config_manager.translate("span.name.default")
  let zh_span = Span::new(zh_name, Server, TraceContext::new("dynamic-trace", "dynamic-span-1", true, ""))
  Span::set_attribute(span, "locale", StringValue("zh-CN"))
  dynamic_test_spans = dynamic_test_spans.push(zh_span)
  
  // åˆ‡æ¢åˆ°æ—¥è¯­
  i18n_config_manager.set_current_locale("ja-JP")
  let ja_name = i18n_config_manager.translate("span.name.default")
  let ja_span = Span::new(ja_name, Server, TraceContext::new("dynamic-trace", "dynamic-span-2", true, ""))
  Span::set_attribute(span, "locale", StringValue("ja-JP"))
  dynamic_test_spans = dynamic_test_spans.push(ja_span)
  
  // åˆ‡æ¢åˆ°è‹±è¯­
  i18n_config_manager.set_current_locale("en-US")
  let en_name = i18n_config_manager.translate("span.name.default")
  let en_span = Span::new(en_name, Server, TraceContext::new("dynamic-trace", "dynamic-span-3", true, ""))
  Span::set_attribute(span, "locale", StringValue("en-US"))
  dynamic_test_spans = dynamic_test_spans.push(en_span)
  
  // éªŒè¯åŠ¨æ€è¯­è¨€åˆ‡æ¢
  assert_eq(dynamic_test_spans.length(), 3)
  assert_eq(dynamic_test_spans[0].name, "é»˜è®¤æ“ä½œ")
  assert_eq(dynamic_test_spans[1].name, "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ“ä½œ")
  assert_eq(dynamic_test_spans[2].name, "Default Operation")
  
  // æµ‹è¯•é…ç½®çƒ­æ›´æ–°
  let hot_update_test = fn() {
    // æ·»åŠ æ–°çš„ç¿»è¯‘
    i18n_config_manager.add_translation("zh-CN", "new.key", "æ–°çš„é”®")
    
    // éªŒè¯æ–°ç¿»è¯‘ç«‹å³å¯ç”¨
    let new_translation = i18n_config_manager.translate("new.key")
    assert_eq(new_translation, "æ–°çš„é”®")
    
    // æ›´æ–°ç°æœ‰ç¿»è¯‘
    i18n_config_manager.update_translation("zh-CN", "span.name.default", "æ›´æ–°çš„é»˜è®¤æ“ä½œ")
    
    // éªŒè¯æ›´æ–°ç”Ÿæ•ˆ
    let updated_translation = i18n_config_manager.translate("span.name.default")
    assert_eq(updated_translation, "æ›´æ–°çš„é»˜è®¤æ“ä½œ")
  }
  
  hot_update_test()
  
  // æµ‹è¯•é…ç½®æŒä¹…åŒ–
  let config_serialized = i18n_config_manager.serialize_config()
  assert_true(config_serialized.length() > 0)
  
  let new_config_manager = I18nConfigManager::new()
  new_config_manager.deserialize_config(config_serialized)
  
  // éªŒè¯é…ç½®æ¢å¤
  let restored_translation = new_config_manager.translate("span.name.default")
  assert_eq(restored_translation, "æ›´æ–°çš„é»˜è®¤æ“ä½œ")
  
  let restored_default = new_config_manager.get_default_locale()
  assert_eq(restored_default, "en-US")
}

// æµ‹è¯•9: æ— éšœç¢å’Œæœ¬åœ°åŒ–è´¨é‡
test "æ— éšœç¢å’Œæœ¬åœ°åŒ–è´¨é‡æµ‹è¯•" {
  // åˆ›å»ºæ— éšœç¢å’Œæœ¬åœ°åŒ–è´¨é‡ç®¡ç†å™¨
  let accessibility_i18n_manager = AccessibilityI18nManager::new()
  
  // æµ‹è¯•æ–‡æœ¬æ–¹å‘æ— éšœç¢
  let accessibility_direction_tests = [
    { 
      text: "Hello World", 
      expected_direction: "ltr",
      accessibility_attributes: ["dir=\"ltr\""]
    },
    { 
      text: "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", 
      expected_direction: "rtl",
      accessibility_attributes: ["dir=\"rtl\""]
    },
    { 
      text: "Hello Ù…Ø±Ø­Ø¨Ø§ World", 
      expected_direction: "auto",
      accessibility_attributes: ["dir=\"auto\""]
    }
  ]
  
  for test_case in accessibility_direction_tests {
    let direction_result = accessibility_i18n_manager.determine_direction(test_case.text)
    assert_eq(direction_result.direction, test_case.expected_direction)
    
    let accessibility_attrs = accessibility_i18n_manager.generate_accessibility_attributes(test_case.text)
    for attr in test_case.accessibility_attributes {
      assert_true(accessibility_attrs.contains(attr))
    }
  }
  
  // æµ‹è¯•è¯­è¨€æ ‡ç­¾æ— éšœç¢
  let accessibility_language_tests = [
    { 
      text: "Hello World", 
      expected_lang: "en",
      accessibility_attributes: ["lang=\"en\""]
    },
    { 
      text: "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", 
      expected_lang: "ar",
      accessibility_attributes: ["lang=\"ar\""]
    },
    { 
      text: "ä½ å¥½ä¸–ç•Œ", 
      expected_lang: "zh",
      accessibility_attributes: ["lang=\"zh\""]
    }
  ]
  
  for test_case in accessibility_language_tests {
    let language_result = accessibility_i18n_manager.detect_language(test_case.text)
    assert_eq(language_result.language, test_case.expected_lang)
    
    let accessibility_attrs = accessibility_i18n_manager.generate_accessibility_attributes(test_case.text)
    for attr in test_case.accessibility_attributes {
      assert_true(accessibility_attrs.contains(attr))
    }
  }
  
  // æµ‹è¯•æœ¬åœ°åŒ–è´¨é‡è¯„ä¼°
  let quality_assessor = LocalizationQualityAssessor::new()
  
  let quality_test_cases = [
    {
      locale: "zh-CN",
      translations: [
        { key: "span.name.default", translation: "é»˜è®¤æ“ä½œ" },
        { key: "error.message.timeout", translation: "æ“ä½œè¶…æ—¶" },
        { key: "status.success", translation: "æˆåŠŸ" }
      ],
      expected_quality_score: 0.9
    },
    {
      locale: "ja-JP",
      translations: [
        { key: "span.name.default", translation: "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ“ä½œ" },
        { key: "error.message.timeout", translation: "æ“ä½œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ" },
        { key: "status.success", translation: "æˆåŠŸ" }
      ],
      expected_quality_score: 0.85
    },
    {
      locale: "ko-KR",
      translations: [
        { key: "span.name.default", translation: "ê¸°ë³¸ ì‘ì—…" },
        { key: "error.message.timeout", translation: "ì‘ì—… ì‹œê°„ ì´ˆê³¼" },
        { key: "status.success", translation: "ì„±ê³µ" }
      ],
      expected_quality_score: 0.8
    }
  ]
  
  for quality_case in quality_test_cases {
    let quality_result = quality_assessor.assess_quality(quality_case.locale, quality_case.translations)
    assert_true(quality_result.overall_score >= quality_case.expected_quality_score)
    
    // éªŒè¯è´¨é‡æŒ‡æ ‡
    assert_true(quality_result.completeness_score > 0.8)  // å®Œæ•´æ€§
    assert_true(quality_result.consistency_score > 0.7)   // ä¸€è‡´æ€§
    assert_true(quality_result.accuracy_score > 0.8)     // å‡†ç¡®æ€§
  }
  
  // æµ‹è¯•æ— éšœç¢spanåˆ›å»º
  let accessibility_spans = []
  let accessibility_test_texts = [
    { text: "Hello World", locale: "en-US" },
    { text: "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…", locale: "ar-SA" },
    { text: "ä½ å¥½ä¸–ç•Œ", locale: "zh-CN" },
    { text: "ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ", locale: "ja-JP" }
  ]
  
  for test_text in accessibility_test_texts {
    let span = accessibility_i18n_manager.create_accessible_span(
      "accessibility.test", 
      Server, 
      TraceContext::new("accessibility-trace", "accessibility-span", true, ""),
      test_text.text,
      test_text.locale
    )
    
    // éªŒè¯æ— éšœç¢å±æ€§
    let accessibility_attrs = Span::get_attribute(span, "accessibility.attributes")
    assert_true(accessibility_attrs != None)
    
    match accessibility_attrs {
      Some(StringValue(attrs)) => {
        assert_true(attrs.contains("lang=") or attrs.contains("dir="))
      }
      _ => assert_true(false)
    }
    
    accessibility_spans = accessibility_spans.push(span)
  }
  
  // éªŒè¯æ— éšœç¢span
  assert_eq(accessibility_spans.length(), accessibility_test_texts.length())
  
  // æµ‹è¯•å±å¹•é˜…è¯»å™¨å‹å¥½æ ¼å¼
  let screen_reader_tests = [
    { 
      text: "Error: Operation timeout", 
      locale: "en-US",
      expected_screen_reader: "Error: Operation timeout"
    },
    { 
      text: "é”™è¯¯ï¼šæ“ä½œè¶…æ—¶", 
      locale: "zh-CN",
      expected_screen_reader: "é”™è¯¯ï¼Œæ“ä½œè¶…æ—¶"
    },
    { 
      text: "ã‚¨ãƒ©ãƒ¼ï¼šæ“ä½œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ", 
      locale: "ja-JP",
      expected_screen_reader: "ã‚¨ãƒ©ãƒ¼ã€æ“ä½œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"
    }
  ]
  
  for screen_reader_test in screen_reader_tests {
    let screen_reader_format = accessibility_i18n_manager.format_for_screen_reader(
      screen_reader_test.text, 
      screen_reader_test.locale
    )
    assert_eq(screen_reader_format, screen_reader_test.expected_screen_reader)
  }
  
  // æµ‹è¯•é«˜å¯¹æ¯”åº¦æ¨¡å¼æ”¯æŒ
  let high_contrast_tests = [
    { 
      status: "success", 
      expected_high_contrast: "âœ“ æˆåŠŸ",
      expected_color: "#00FF00"
    },
    { 
      status: "error", 
      expected_high_contrast: "âœ— é”™è¯¯",
      expected_color: "#FF0000"
    },
    { 
      status: "warning", 
      expected_high_contrast: "âš  è­¦å‘Š",
      expected_color: "#FFFF00"
    }
  ]
  
  for high_contrast_test in high_contrast_tests {
    let high_contrast_format = accessibility_i18n_manager.format_for_high_contrast(
      high_contrast_test.status, 
      "zh-CN"
    )
    assert_eq(high_contrast_format.text, high_contrast_test.expected_high_contrast)
    assert_eq(high_contrast_format.color, high_contrast_test.expected_color)
  }
}

// æµ‹è¯•10: æ€§èƒ½å’Œèµ„æºä¼˜åŒ–
test "æ€§èƒ½å’Œèµ„æºä¼˜åŒ–æµ‹è¯•" {
  // åˆ›å»ºå›½é™…åŒ–æ€§èƒ½ä¼˜åŒ–ç®¡ç†å™¨
  let i18n_performance_manager = I18nPerformanceManager::new()
  
  // é…ç½®æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
  i18n_performance_manager.enable_lazy_loading(true)
  i18n_performance_manager.enable_translation_caching(true)
  i18n_performance_manager.set_cache_size(1000)
  i18n_performance_manager.enable_preloading(true)
  
  // æ·»åŠ å¤§é‡ç¿»è¯‘èµ„æº
  let large_translation_set = []
  for i in 0..=10000 {
    large_translation_set = large_translation_set.push({
      key: "test.key." + i.to_string(),
      translations: [
        { locale: "zh-CN", text: "æµ‹è¯•æ–‡æœ¬ " + i.to_string() },
        { locale: "en-US", text: "Test text " + i.to_string() },
        { locale: "ja-JP", text: "ãƒ†ã‚¹ãƒˆãƒ†ã‚­ã‚¹ãƒˆ " + i.to_string() },
        { locale: "ko-KR", text: "í…ŒìŠ¤íŠ¸ í…ìŠ¤íŠ¸ " + i.to_string() }
      ]
    })
  }
  
  // æµ‹è¯•æ‡’åŠ è½½æ€§èƒ½
  let lazy_load_start = Time::now()
  i18n_performance_manager.add_translation_set(large_translation_set)
  let lazy_load_end = Time::now()
  let lazy_load_duration = lazy_load_end - lazy_load_start
  
  // éªŒè¯æ‡’åŠ è½½ä¸ä¼šé˜»å¡åˆå§‹åŒ–
  assert_true(lazy_load_duration < 100)  // åº”è¯¥åœ¨100mså†…å®Œæˆ
  
  // æµ‹è¯•ç¿»è¯‘ç¼“å­˜æ€§èƒ½
  let cache_test_start = Time::now()
  
  // ç¬¬ä¸€æ¬¡è®¿é—®ï¼ˆç¼“å­˜æœªå‘½ä¸­ï¼‰
  let first_translation = i18n_performance_manager.translate("test.key.100", "zh-CN")
  
  let cache_test_mid = Time::now()
  
  // ç¬¬äºŒæ¬¡è®¿é—®ï¼ˆç¼“å­˜å‘½ä¸­ï¼‰
  let second_translation = i18n_performance_manager.translate("test.key.100", "zh-CN")
  
  let cache_test_end = Time::now()
  
  let first_access_duration = cache_test_mid - cache_test_start
  let second_access_duration = cache_test_end - cache_test_mid
  
  // éªŒè¯ç¼“å­˜æ•ˆæœ
  assert_eq(first_translation, second_translation)
  assert_true(second_access_duration < first_access_duration)  // ç¼“å­˜è®¿é—®åº”è¯¥æ›´å¿«
  
  // æµ‹è¯•æ‰¹é‡ç¿»è¯‘æ€§èƒ½
  let batch_keys = []
  for i in 0..=100 {
    batch_keys = batch_keys.push("test.key." + i.to_string())
  }
  
  let batch_start = Time::now()
  let batch_translations = i18n_performance_manager.translate_batch(batch_keys, "zh-CN")
  let batch_end = Time::now()
  let batch_duration = batch_end - batch_start
  
  // éªŒè¯æ‰¹é‡ç¿»è¯‘æ€§èƒ½
  assert_eq(batch_translations.length(), batch_keys.length())
  assert_true(batch_duration < 50)  // æ‰¹é‡ç¿»è¯‘åº”è¯¥åœ¨50mså†…å®Œæˆ
  
  // æµ‹è¯•é¢„åŠ è½½æ€§èƒ½
  let preload_locales = ["zh-CN", "en-US", "ja-JP", "ko-KR"]
  let preload_keys = ["test.key.1", "test.key.2", "test.key.3"]
  
  let preload_start = Time::now()
  i18n_performance_manager.preload_translations(preload_locales, preload_keys)
  let preload_end = Time::now()
  let preload_duration = preload_end - preload_start
  
  // éªŒè¯é¢„åŠ è½½æ€§èƒ½
  assert_true(preload_duration < 200)  // é¢„åŠ è½½åº”è¯¥åœ¨200mså†…å®Œæˆ
  
  // éªŒè¯é¢„åŠ è½½æ•ˆæœ
  for locale in preload_locales {
    for key in preload_keys {
      let preloaded_translation = i18n_performance_manager.translate(key, locale)
      assert_true(preloaded_translation.length() > 0)
    }
  }
  
  // æµ‹è¯•å†…å­˜ä½¿ç”¨ä¼˜åŒ–
  let initial_memory = MemoryManager::get_usage()
  
  // åˆ›å»ºå¤§é‡å›½é™…åŒ–span
  let i18n_spans = []
  for i in 0..=1000 {
    let span = Span::new("i18n.performance.test", Server, 
                        TraceContext::new("i18n-perf-trace", "i18n-perf-span-" + i.to_string(), true, ""))
    
    // æ·»åŠ å¤šè¯­è¨€å±æ€§
    Span::set_attribute(span, "zh-CN.name", StringValue(i18n_performance_manager.translate("test.key." + i.to_string(), "zh-CN")))
    Span::set_attribute(span, "en-US.name", StringValue(i18n_performance_manager.translate("test.key." + i.to_string(), "en-US")))
    Span::set_attribute(span, "ja-JP.name", StringValue(i18n_performance_manager.translate("test.key." + i.to_string(), "ja-JP")))
    
    i18n_spans = i18n_spans.push(span)
  }
  
  let peak_memory = MemoryManager::get_usage()
  let memory_increase = peak_memory - initial_memory
  let memory_per_span = memory_increase.to_float() / i18n_spans.length().to_float()
  
  // éªŒè¯å†…å­˜ä½¿ç”¨ä¼˜åŒ–
  assert_true(memory_per_span < 2048)  // æ¯ä¸ªspanå†…å­˜ä½¿ç”¨åº”è¯¥å°äº2KB
  
  // æµ‹è¯•ç¼“å­˜æ¸…ç†
  i18n_performance_manager.clear_cache()
  let cache_cleared_memory = MemoryManager::get_usage()
  let memory_reduced = peak_memory - cache_cleared_memory
  
  // éªŒè¯ç¼“å­˜æ¸…ç†æ•ˆæœ
  assert_true(memory_reduced > 0)  // æ¸…ç†ç¼“å­˜åº”è¯¥é‡Šæ”¾å†…å­˜
  
  // æµ‹è¯•å¹¶å‘æ€§èƒ½
  let thread_pool = ThreadPool::new(10)
  let concurrent_operations = []
  
  for i in 0..=100 {
    let future = thread_pool.spawn(fn() {
      let locale = ["zh-CN", "en-US", "ja-JP", "ko-KR"][i % 4]
      let key = "test.key." + (i % 1000).to_string()
      i18n_performance_manager.translate(key, locale)
    })
    concurrent_operations = concurrent_operations.push(future)
  }
  
  let concurrent_start = Time::now()
  
  // ç­‰å¾…æ‰€æœ‰å¹¶å‘æ“ä½œå®Œæˆ
  let concurrent_results = []
  for future in concurrent_operations {
    let result = future.wait()
    concurrent_results = concurrent_results.push(result)
  }
  
  let concurrent_end = Time::now()
  let concurrent_duration = concurrent_end - concurrent_start
  let concurrent_throughput = concurrent_results.length().to_float() / concurrent_duration.to_float() * 1000.0
  
  // éªŒè¯å¹¶å‘æ€§èƒ½
  assert_eq(concurrent_results.length(), 101)
  assert_true(concurrent_throughput > 1000)  // è‡³å°‘1000æ¬¡ç¿»è¯‘/ç§’
  
  // æµ‹è¯•èµ„æºå‹ç¼©
  let resource_compression_start = Time::now()
  let compressed_resources = i18n_performance_manager.compress_resources()
  let resource_compression_end = Time::now()
  let resource_compression_duration = resource_compression_end - resource_compression_start
  
  // éªŒè¯èµ„æºå‹ç¼©
  assert_true(compressed_resources.compressed_size < compressed_resources.original_size)
  let compression_ratio = 1.0 - (compressed_resources.compressed_size.to_float() / compressed_resources.original_size.to_float())
  assert_true(compression_ratio > 0.3)  // è‡³å°‘30%å‹ç¼©ç‡
  assert_true(resource_compression_duration < 1000)  // å‹ç¼©åº”è¯¥åœ¨1ç§’å†…å®Œæˆ
}