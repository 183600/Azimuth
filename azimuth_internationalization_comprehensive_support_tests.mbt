// Azimuth Telemetry System - Internationalization Comprehensive Support Tests
// This file contains comprehensive test cases for internationalization support

// Test 1: Multi-Language String Handling
test "multi-language string handling" {
  // Test various language strings
  let english_text = "Operation completed successfully"
  let chinese_text = "æ“ä½œæˆåŠŸå®Œæˆ"
  let japanese_text = "æ“ä½œãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ"
  let arabic_text = "Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­"
  let russian_text = "ÐžÐ¿ÐµÑ€Ð°Ñ†Ð¸Ñ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð°"
  let french_text = "OpÃ©ration terminÃ©e avec succÃ¨s"
  let spanish_text = "OperaciÃ³n completada con Ã©xito"
  let german_text = "Operation erfolgreich abgeschlossen"
  
  // Create attributes with multi-language text
  let attrs = Attributes::new()
  Attributes::set(attrs, "message.en", StringValue(english_text))
  Attributes::set(attrs, "message.zh", StringValue(chinese_text))
  Attributes::set(attrs, "message.ja", StringValue(japanese_text))
  Attributes::set(attrs, "message.ar", StringValue(arabic_text))
  Attributes::set(attrs, "message.ru", StringValue(russian_text))
  Attributes::set(attrs, "message.fr", StringValue(french_text))
  Attributes::set(attrs, "message.es", StringValue(spanish_text))
  Attributes::set(attrs, "message.de", StringValue(german_text))
  
  // Verify all language attributes are stored correctly
  let en_result = Attributes::get(attrs, "message.en")
  match en_result {
    Some(StringValue(v)) => assert_eq(v, english_text)
    _ => assert_true(false)
  }
  
  let zh_result = Attributes::get(attrs, "message.zh")
  match zh_result {
    Some(StringValue(v)) => assert_eq(v, chinese_text)
    _ => assert_true(false)
  }
  
  let ja_result = Attributes::get(attrs, "message.ja")
  match ja_result {
    Some(StringValue(v)) => assert_eq(v, japanese_text)
    _ => assert_true(false)
  }
  
  let ar_result = Attributes::get(attrs, "message.ar")
  match ar_result {
    Some(StringValue(v)) => assert_eq(v, arabic_text)
    _ => assert_true(false)
  }
  
  let ru_result = Attributes::get(attrs, "message.ru")
  match ru_result {
    Some(StringValue(v)) => assert_eq(v, russian_text)
    _ => assert_true(false)
  }
  
  let fr_result = Attributes::get(attrs, "message.fr")
  match fr_result {
    Some(StringValue(v)) => assert_eq(v, french_text)
    _ => assert_true(false)
  }
  
  let es_result = Attributes::get(attrs, "message.es")
  match es_result {
    Some(StringValue(v)) => assert_eq(v, spanish_text)
    _ => assert_true(false)
  }
  
  let de_result = Attributes::get(attrs, "message.de")
  match de_result {
    Some(StringValue(v)) => assert_eq(v, german_text)
    _ => assert_true(false)
  }
}

// Test 2: Locale-Aware Formatting
test "locale-aware formatting" {
  // Test locale-aware number formatting
  let number = 1234.56
  
  let en_formatted = LocaleFormatter::format_number(number, "en-US")
  assert_eq(en_formatted, "1,234.56")
  
  let de_formatted = LocaleFormatter::format_number(number, "de-DE")
  assert_eq(de_formatted, "1.234,56")
  
  let fr_formatted = LocaleFormatter::format_number(number, "fr-FR")
  assert_eq(fr_formatted, "1 234,56")
  
  let zh_formatted = LocaleFormatter::format_number(number, "zh-CN")
  assert_eq(zh_formatted, "1,234.56")
  
  // Test locale-aware date formatting
  let timestamp = 1609459200000L  // 2021-01-01 00:00:00 UTC
  
  let en_date = LocaleFormatter::format_date(timestamp, "en-US")
  assert_eq(en_date, "1/1/2021")
  
  let de_date = LocaleFormatter::format_date(timestamp, "de-DE")
  assert_eq(de_date, "1.1.2021")
  
  let fr_date = LocaleFormatter::format_date(timestamp, "fr-FR")
  assert_eq(fr_date, "01/01/2021")
  
  let zh_date = LocaleFormatter::format_date(timestamp, "zh-CN")
  assert_eq(zh_date, "2021/1/1")
  
  // Test locale-aware currency formatting
  let currency = 1234.56
  
  let en_currency = LocaleFormatter::format_currency(currency, "en-US", "USD")
  assert_eq(en_currency, "$1,234.56")
  
  let de_currency = LocaleFormatter::format_currency(currency, "de-DE", "EUR")
  assert_eq(de_currency, "1.234,56 â‚¬")
  
  let fr_currency = LocaleFormatter::format_currency(currency, "fr-FR", "EUR")
  assert_eq(fr_currency, "1 234,56 â‚¬")
  
  let zh_currency = LocaleFormatter::format_currency(currency, "zh-CN", "CNY")
  assert_eq(zh_currency, "Â¥1,234.56")
}

// Test 3: Right-to-Left Language Support
test "right-to-left language support" {
  // Test RTL language strings
  let arabic_message = "Ø±Ø³Ø§Ù„Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"
  let hebrew_message = "×”×•×“×¢×” ×‘×¢×‘×¨×™×ª"
  let persian_message = "Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ø²Ø¨Ø§Ù† ÙØ§Ø±Ø³ÛŒ"
  let urdu_message = "Ø§Ø±Ø¯Ùˆ Ù…ÛŒÚº Ù¾ÛŒØºØ§Ù…"
  
  // Create span with RTL language attributes
  let span_ctx = SpanContext::new("rtl_trace", "rtl_span", true, "")
  let span = Span::new("rtl_operation", Internal, span_ctx)
  
  // Add RTL language events
  Span::add_event(span, "arabic_event", Some([
    ("message", StringValue(arabic_message)),
    ("language", StringValue("ar"))
  ]))
  
  Span::add_event(span, "hebrew_event", Some([
    ("message", StringValue(hebrew_message)),
    ("language", StringValue("he"))
  ]))
  
  Span::add_event(span, "persian_event", Some([
    ("message", StringValue(persian_message)),
    ("language", StringValue("fa"))
  ]))
  
  Span::add_event(span, "urdu_event", Some([
    ("message", StringValue(urdu_message)),
    ("language", StringValue("ur"))
  ]))
  
  // Verify RTL text direction detection
  assert_true(TextDirection::is_rtl(arabic_message))
  assert_true(TextDirection::is_rtl(hebrew_message))
  assert_true(TextDirection::is_rtl(persian_message))
  assert_true(TextDirection::is_rtl(urdu_message))
  
  // Verify LTR text direction detection
  assert_false(TextDirection::is_rtl("English text"))
  assert_false(TextDirection::is_rtl("Texte franÃ§ais"))
  assert_false(TextDirection::is_rtl("Deutscher Text"))
  
  Span::end(span)
}

// Test 4: Multi-Language Error Messages
test "multi-language error messages" {
  // Create error messages in multiple languages
  let error_messages = [
    ("en", "Connection timeout occurred"),
    ("zh", "å‘ç”Ÿè¿žæŽ¥è¶…æ—¶"),
    ("ja", "æŽ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒç™ºç”Ÿã—ã¾ã—ãŸ"),
    ("ar", "Ø­Ø¯Ø« Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù‡Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„"),
    ("ru", "ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð¾ Ð¸ÑÑ‚ÐµÑ‡ÐµÐ½Ð¸Ðµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ"),
    ("fr", "Un dÃ©lai d'attente de connexion s'est produit"),
    ("es", "Se produjo un tiempo de espera de conexiÃ³n"),
    ("de", "Verbindungs-Timeout aufgetreten")
  ]
  
  // Create error spans with localized messages
  for (locale, message) in error_messages {
    let trace_id = "error_trace_" + locale
    let span_id = "error_span_" + locale
    let span_ctx = SpanContext::new(trace_id, span_id, true, "")
    let span = Span::new("error_operation", Internal, span_ctx)
    
    // Set localized error status
    Span::set_status(span, Error, Some(message))
    
    // Add localized error attributes
    let attrs = [
      ("error.locale", StringValue(locale)),
      ("error.message", StringValue(message))
    ]
    
    for (key, value) in attrs {
      Span::add_event(span, "error_details", Some([(key, value)]))
    }
    
    // Verify error status is set correctly
    assert_eq(Span::status(span), Error)
    
    Span::end(span)
  }
}

// Test 5: Unicode Character Handling
test "unicode character handling" {
  // Test various Unicode characters
  let emoji_text = "Operation completed âœ…ðŸŽ‰"
  let math_symbols = "Calculation result: âˆ‘(i=1â†’n) = Ï€ Ã— âˆš2"
  let currency_symbols = "Price: $100.50 â‚¬85.75 Â£75.25 Â¥10000"
  let mixed_unicode = "Mixed text: ä½ å¥½ ðŸŒ Bonjour ðŸ—¼ Ð—Ð´Ñ€Ð°Ð²ÑÑ‚Ð²ÑƒÐ¹Ñ‚Ðµ ðŸ°"
  
  // Create attributes with Unicode text
  let attrs = Attributes::new()
  Attributes::set(attrs, "emoji.message", StringValue(emoji_text))
  Attributes::set(attrs, "math.symbols", StringValue(math_symbols))
  Attributes::set(attrs, "currency.symbols", StringValue(currency_symbols))
  Attributes::set(attrs, "mixed.unicode", StringValue(mixed_unicode))
  
  // Verify Unicode text is handled correctly
  let emoji_result = Attributes::get(attrs, "emoji.message")
  match emoji_result {
    Some(StringValue(v)) => assert_eq(v, emoji_text)
    _ => assert_true(false)
  }
  
  let math_result = Attributes::get(attrs, "math.symbols")
  match math_result {
    Some(StringValue(v)) => assert_eq(v, math_symbols)
    _ => assert_true(false)
  }
  
  let currency_result = Attributes::get(attrs, "currency.symbols")
  match currency_result {
    Some(StringValue(v)) => assert_eq(v, currency_symbols)
    _ => assert_true(false)
  }
  
  let mixed_result = Attributes::get(attrs, "mixed.unicode")
  match mixed_result {
    Some(StringValue(v)) => assert_eq(v, mixed_unicode)
    _ => assert_true(false)
  }
  
  // Test Unicode string length calculations
  assert_eq(UnicodeUtils::length(emoji_text), 24)  // Characters, not bytes
  assert_eq(UnicodeUtils::length(math_symbols), 28)
  assert_eq(UnicodeUtils::length(currency_symbols), 31)
  assert_eq(UnicodeUtils::length(mixed_unicode), 28)
}

// Test 6: Locale-Specific Resource Information
test "locale-specific resource information" {
  // Create resources with locale-specific information
  let base_resource = Resource::new()
  
  // Add locale-specific attributes
  let en_attrs = [
    ("service.name", StringValue("User Authentication Service")),
    ("service.description", StringValue("Handles user authentication and authorization")),
    ("service.owner", StringValue("Platform Team")),
    ("service.region", StringValue("us-west-2"))
  ]
  
  let zh_attrs = [
    ("service.name", StringValue("ç”¨æˆ·è®¤è¯æœåŠ¡")),
    ("service.description", StringValue("å¤„ç†ç”¨æˆ·è®¤è¯å’ŒæŽˆæƒ")),
    ("service.owner", StringValue("å¹³å°å›¢é˜Ÿ")),
    ("service.region", StringValue("ç¾Žå›½è¥¿éƒ¨-2"))
  ]
  
  let ja_attrs = [
    ("service.name", StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹")),
    ("service.description", StringValue("ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã¨èªå¯ã‚’å‡¦ç†ã—ã¾ã™")),
    ("service.owner", StringValue("ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ãƒãƒ¼ãƒ ")),
    ("service.region", StringValue("us-west-2"))
  ]
  
  // Create locale-specific resources
  let en_resource = Resource::with_attributes(base_resource, en_attrs)
  let zh_resource = Resource::with_attributes(base_resource, zh_attrs)
  let ja_resource = Resource::with_attributes(base_resource, ja_attrs)
  
  // Verify English resource attributes
  let en_service_name = Resource::get_attribute(en_resource, "service.name")
  match en_service_name {
    Some(StringValue(v)) => assert_eq(v, "User Authentication Service")
    _ => assert_true(false)
  }
  
  // Verify Chinese resource attributes
  let zh_service_name = Resource::get_attribute(zh_resource, "service.name")
  match zh_service_name {
    Some(StringValue(v)) => assert_eq(v, "ç”¨æˆ·è®¤è¯æœåŠ¡")
    _ => assert_true(false)
  }
  
  // Verify Japanese resource attributes
  let ja_service_name = Resource::get_attribute(ja_resource, "service.name")
  match ja_service_name {
    Some(StringValue(v)) => assert_eq(v, "ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹")
    _ => assert_true(false)
  }
}

// Test 7: Internationalized Log Messages
test "internationalized log messages" {
  let provider = LoggerProvider::default()
  let logger = LoggerProvider::get_logger(provider, "i18n_logger")
  
  // Create log records in multiple languages
  let log_messages = [
    ("en", Info, "User login successful"),
    ("zh", Info, "ç”¨æˆ·ç™»å½•æˆåŠŸ"),
    ("ja", Info, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ"),
    ("ar", Info, "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­"),
    ("ru", Info, "Ð’Ñ…Ð¾Ð´ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾"),
    ("fr", Info, "Connexion utilisateur rÃ©ussie"),
    ("es", Info, "Inicio de sesiÃ³n de usuario exitoso"),
    ("de", Info, "Benutzeranmeldung erfolgreich")
  ]
  
  for (locale, severity, message) in log_messages {
    let attrs = Attributes::new()
    Attributes::set(attrs, "locale", StringValue(locale))
    Attributes::set(attrs, "user_id", StringValue("user_" + locale))
    
    let log_record = LogRecord::new_with_context(
      severity,
      Some(message),
      Some(attrs),
      Some(Time::now()),
      Some(Time::now()),
      Some("trace_" + locale),
      Some("span_" + locale),
      Some(Context::root())
    )
    
    Logger::emit(logger, log_record)
    
    // Verify log record severity
    assert_eq(LogRecord::severity_number(log_record), severity)
    
    // Verify log record body
    match LogRecord::body(log_record) {
      Some(body) => assert_eq(body, message)
      None => assert_true(false)
    }
  }
}

// Test 8: Multi-Language Metric Names and Descriptions
test "multi-language metric names and descriptions" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "i18n_meter")
  
  // Create metrics with localized names and descriptions
  let metric_localizations = [
    ("en", "user_logins", "Number of user logins", "count"),
    ("zh", "ç”¨æˆ·ç™»å½•æ•°", "ç”¨æˆ·ç™»å½•æ¬¡æ•°", "æ¬¡"),
    ("ja", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æ•°", "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³å›žæ•°", "å›ž"),
    ("fr", "connexions_utilisateur", "Nombre de connexions utilisateur", "fois"),
    ("es", "inicios_sesion_usuario", "NÃºmero de inicios de sesiÃ³n de usuario", "veces"),
    ("de", "benutzer_anmeldungen", "Anzahl der Benutzeranmeldungen", "mal")
  ]
  
  for (locale, name, description, unit) in metric_localizations {
    let counter = Meter::create_counter(
      meter, 
      name + "_" + locale, 
      Some(description), 
      Some(unit)
    )
    
    // Add some measurements
    Counter::add(counter, 1.0)
    Counter::add(counter, 2.0)
    
    // Verify instrument properties
    let instrument = Counter::as_instrument(counter)
    assert_eq(Instrument::name(instrument), name + "_" + locale)
    assert_eq(Instrument::description(instrument), Some(description))
    assert_eq(Instrument::unit(instrument), Some(unit))
  }
}

// Test 9: Locale-Aware Time Zone Handling
test "locale-aware time zone handling" {
  let timestamp = 1609459200000L  // 2021-01-01 00:00:00 UTC
  
  // Test time zone formatting for different locales
  let utc_time = TimeZoneFormatter::format(timestamp, "UTC", "en-US")
  assert_eq(utc_time, "1/1/2021, 12:00:00 AM")
  
  let pst_time = TimeZoneFormatter::format(timestamp, "America/Los_Angeles", "en-US")
  assert_eq(pst_time, "12/31/2020, 4:00:00 PM")
  
  let jst_time = TimeZoneFormatter::format(timestamp, "Asia/Tokyo", "ja-JP")
  assert_eq(jst_time, "2021/1/1 9:00:00")
  
  let cet_time = TimeZoneFormatter::format(timestamp, "Europe/Paris", "fr-FR")
  assert_eq(cet_time, "01/01/2021 01:00:00")
  
  let cst_time = TimeZoneFormatter::format(timestamp, "Asia/Shanghai", "zh-CN")
  assert_eq(cst_time, "2021/1/1 8:00:00")
  
  // Test time zone conversion
  let pst_timestamp = TimeZoneConverter::convert(timestamp, "UTC", "America/Los_Angeles")
  let pst_converted = TimeZoneFormatter::format(pst_timestamp, "America/Los_Angeles", "en-US")
  assert_eq(pst_converted, "12/31/2020, 4:00:00 PM")
  
  let jst_timestamp = TimeZoneConverter::convert(timestamp, "UTC", "Asia/Tokyo")
  let jst_converted = TimeZoneFormatter::format(jst_timestamp, "Asia/Tokyo", "ja-JP")
  assert_eq(jst_converted, "2021/1/1 9:00:00")
}

// Test 10: Cultural Formatting Conventions
test "cultural formatting conventions" {
  // Test personal name formatting
  let personal_names = [
    ("en", "John Doe", "Doe, John"),
    ("zh", "å¼ ä¸‰", "å¼ ä¸‰"),
    ("ja", "ç”°ä¸­å¤ªéƒŽ", "ç”°ä¸­ å¤ªéƒŽ"),
    ("ko", "ê¹€ì² ìˆ˜", "ê¹€ì² ìˆ˜"),
    ("hu", "Nagy JÃ¡nos", "Nagy JÃ¡nos"),
    ("vi", "Nguyá»…n VÄƒn An", "Nguyá»…n VÄƒn An")
  ]
  
  for (locale, display_name, formal_name) in personal_names {
    let formatted_display = NameFormatter::format_display(display_name, locale)
    assert_eq(formatted_display, display_name)
    
    let formatted_formal = NameFormatter::format_formal(display_name, locale)
    assert_eq(formatted_formal, formal_name)
  }
  
  // Test address formatting
  let address_components = [
    ("street", "123 Main St"),
    ("city", "New York"),
    ("state", "NY"),
    ("postal", "10001"),
    ("country", "USA")
  ]
  
  let en_address = AddressFormatter::format(address_components, "en-US")
  assert_eq(en_address, "123 Main St\nNew York, NY 10001\nUSA")
  
  let zh_address = AddressFormatter::format(address_components, "zh-CN")
  assert_eq(zh_address, "ç¾Žå›½\nNY çº½çº¦\nMain St 123\n10001")
  
  let ja_address = AddressFormatter::format(address_components, "ja-JP")
  assert_eq(ja_address, "ã€’10001\nNYå·žãƒ‹ãƒ¥ãƒ¼ãƒ¨ãƒ¼ã‚¯\nMain St 123\nUSA")
  
  // Test phone number formatting
  let phone_number = "+12125551234"
  
  let en_phone = PhoneFormatter::format(phone_number, "en-US")
  assert_eq(en_phone, "+1 (212) 555-1234")
  
  let fr_phone = PhoneFormatter::format(phone_number, "fr-FR")
  assert_eq(fr_phone, "+1 212 555 1234")
  
  let de_phone = PhoneFormatter::format(phone_number, "de-DE")
  assert_eq(de_phone, "+1 212 555 1234")
  
  let jp_phone = PhoneFormatter::format(phone_number, "ja-JP")
  assert_eq(jp_phone, "+1-212-555-1234")
}