// Azimuth Telemetry System - Comprehensive Internationalization Support Tests
// This file contains comprehensive test cases for internationalization and multilingual support

// Test 1: Unicode Character Support in Attributes
test "unicode character support in attributes" {
  let attrs = Attributes::new()
  
  // Test Chinese characters
  Attributes::set(attrs, "chinese.key", StringValue("ä¸­æ–‡æµ‹è¯•"))
  let chinese_result = Attributes::get(attrs, "chinese.key")
  match chinese_result {
    Some(StringValue(value)) => assert_eq(value, "ä¸­æ–‡æµ‹è¯•")
    _ => assert_true(false)
  }
  
  // Test Japanese characters
  Attributes::set(attrs, "japanese.key", StringValue("æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ"))
  let japanese_result = Attributes::get(attrs, "japanese.key")
  match japanese_result {
    Some(StringValue(value)) => assert_eq(value, "æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ")
    _ => assert_true(false)
  }
  
  // Test Korean characters
  Attributes::set(attrs, "korean.key", StringValue("í•œêµ­ì–´ í…ŒìŠ¤íŠ¸"))
  let korean_result = Attributes::get(attrs, "korean.key")
  match korean_result {
    Some(StringValue(value)) => assert_eq(value, "í•œêµ­ì–´ í…ŒìŠ¤íŠ¸")
    _ => assert_true(false)
  }
  
  // Test Arabic characters
  Attributes::set(attrs, "arabic.key", StringValue("Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ"))
  let arabic_result = Attributes::get(attrs, "arabic.key")
  match arabic_result {
    Some(StringValue(value)) => assert_eq(value, "Ø§Ø®ØªØ¨Ø§Ø± Ø¹Ø±Ø¨ÙŠ")
    _ => assert_true(false)
  }
  
  // Test Russian characters
  Attributes::set(attrs, "russian.key", StringValue("Ğ¢ĞµÑÑ‚ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼"))
  let russian_result = Attributes::get(attrs, "russian.key")
  match russian_result {
    Some(StringValue(value)) => assert_eq(value, "Ğ¢ĞµÑÑ‚ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼")
    _ => assert_true(false)
  }
  
  // Test Hebrew characters
  Attributes::set(attrs, "hebrew.key", StringValue("×‘×“×™×§×” ×¢×‘×¨×™×ª"))
  let hebrew_result = Attributes::get(attrs, "hebrew.key")
  match hebrew_result {
    Some(StringValue(value)) => assert_eq(value, "×‘×“×™×§×” ×¢×‘×¨×™×ª")
    _ => assert_true(false)
  }
  
  // Test Thai characters
  Attributes::set(attrs, "thai.key", StringValue("à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢"))
  let thai_result = Attributes::get(attrs, "thai.key")
  match thai_result {
    Some(StringValue(value)) => assert_eq(value, "à¸à¸²à¸£à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢")
    _ => assert_true(false)
  }
  
  // Test Emoji characters
  Attributes::set(attrs, "emoji.key", StringValue("ğŸš€ğŸŒğŸ’»ğŸ“Š"))
  let emoji_result = Attributes::get(attrs, "emoji.key")
  match emoji_result {
    Some(StringValue(value)) => assert_eq(value, "ğŸš€ğŸŒğŸ’»ğŸ“Š")
    _ => assert_true(false)
  }
  
  // Test mixed Unicode characters
  Attributes::set(attrs, "mixed.key", StringValue("ä¸­æ–‡ ğŸš€ English æ—¥æœ¬èª ğŸŒ í•œêµ­ì–´"))
  let mixed_result = Attributes::get(attrs, "mixed.key")
  match mixed_result {
    Some(StringValue(value)) => assert_eq(value, "ä¸­æ–‡ ğŸš€ English æ—¥æœ¬èª ğŸŒ í•œêµ­ì–´")
    _ => assert_true(false)
  }
}

// Test 2: Unicode Support in Span Names and Events
test "unicode support in span names and events" {
  let trace_ctx = SpanContext::new("unicode_trace", "unicode_root", true, "")
  
  // Test span name with Chinese characters
  let chinese_span = Span::new("ä¸­æ–‡æ“ä½œ", Internal, trace_ctx)
  Span::add_attribute(chinese_span, "æ“ä½œç±»å‹", StringValue("æ•°æ®å¤„ç†"))
  Span::add_event(chinese_span, "æ“ä½œå¼€å§‹", Some([
    ("æ—¶é—´æˆ³", IntValue(1234567890)),
    ("ç”¨æˆ·", StringValue("å¼ ä¸‰"))
  ]))
  Span::end(chinese_span)
  
  assert_eq(Span::name(chinese_span), "ä¸­æ–‡æ“ä½œ")
  
  // Test span name with Japanese characters
  let japanese_span = Span::new("æ—¥æœ¬èªæ“ä½œ", Internal, trace_ctx)
  Span::add_attribute(japanese_span, "æ“ä½œã‚¿ã‚¤ãƒ—", StringValue("ãƒ‡ãƒ¼ã‚¿å‡¦ç†"))
  Span::add_event(japanese_span, "æ“ä½œé–‹å§‹", Some([
    ("ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—", IntValue(1234567891)),
    ("ãƒ¦ãƒ¼ã‚¶ãƒ¼", StringValue("ç”°ä¸­"))
  ]))
  Span::end(japanese_span)
  
  assert_eq(Span::name(japanese_span), "æ—¥æœ¬èªæ“ä½œ")
  
  // Test span name with Korean characters
  let korean_span = Span::new("í•œêµ­ì–´ ì‘ì—…", Internal, trace_ctx)
  Span::add_attribute(korean_span, "ì‘ì—… ìœ í˜•", StringValue("ë°ì´í„° ì²˜ë¦¬"))
  Span::add_event(korean_span, "ì‘ì—… ì‹œì‘", Some([
    ("íƒ€ì„ìŠ¤íƒ¬í”„", IntValue(1234567892)),
    ("ì‚¬ìš©ì", StringValue("ê¹€ì² ìˆ˜"))
  ]))
  Span::end(korean_span)
  
  assert_eq(Span::name(korean_span), "í•œêµ­ì–´ ì‘ì—…")
  
  // Test span name with Emoji
  let emoji_span = Span::new("ğŸš€ Rocket Operation ğŸŒ", Internal, trace_ctx)
  Span::add_attribute(emoji_span, "operation.type", StringValue("rocket_launch"))
  Span::add_event(emoji_span, "ğŸ¯ Launch Started", Some([
    ("ğŸ“ Location", StringValue("ğŸš€ Space Station")),
    ("ğŸ‘¨â€ğŸš€ Astronaut", StringValue("Neil Armstrong"))
  ]))
  Span::end(emoji_span)
  
  assert_eq(Span::name(emoji_span), "ğŸš€ Rocket Operation ğŸŒ")
  
  // Verify events are preserved correctly
  let chinese_events = Span::events(chinese_span)
  assert_eq(chinese_events.length(), 1)
  
  let chinese_event = chinese_events[0]
  let chinese_user = Event::get_attribute(chinese_event, "ç”¨æˆ·")
  match chinese_user {
    Some(StringValue(user)) => assert_eq(user, "å¼ ä¸‰")
    None => assert_true(false)
  }
}

// Test 3: Unicode Support in Log Records
test "unicode support in log records" {
  // Test log record with Chinese characters
  let chinese_log = LogRecord::new(Info, "ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯ï¼šæ•°æ®å¤„ç†æ“ä½œå·²å®Œæˆ")
  assert_eq(LogRecord::severity_number(chinese_log), Info)
  match LogRecord::body(chinese_log) {
    Some(body) => assert_eq(body, "ä¸­æ–‡æ—¥å¿—æ¶ˆæ¯ï¼šæ•°æ®å¤„ç†æ“ä½œå·²å®Œæˆ")
    None => assert_true(false)
  }
  
  // Test log record with Japanese characters
  let japanese_log = LogRecord::new(Warning, "æ—¥æœ¬èªãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼šãƒ‡ãƒ¼ã‚¿å‡¦ç†æ“ä½œãŒå®Œäº†ã—ã¾ã—ãŸ")
  assert_eq(LogRecord::severity_number(japanese_log), Warning)
  match LogRecord::body(japanese_log) {
    Some(body) => assert_eq(body, "æ—¥æœ¬èªãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼šãƒ‡ãƒ¼ã‚¿å‡¦ç†æ“ä½œãŒå®Œäº†ã—ã¾ã—ãŸ")
    None => assert_true(false)
  }
  
  // Test log record with Korean characters
  let korean_log = LogRecord::new(Error, "í•œêµ­ì–´ ë¡œê·¸ ë©”ì‹œì§€: ë°ì´í„° ì²˜ë¦¬ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
  assert_eq(LogRecord::severity_number(korean_log), Error)
  match LogRecord::body(korean_log) {
    Some(body) => assert_eq(body, "í•œêµ­ì–´ ë¡œê·¸ ë©”ì‹œì§€: ë°ì´í„° ì²˜ë¦¬ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
    None => assert_true(false)
  }
  
  // Test log record with Arabic characters
  let arabic_log = LogRecord::new(Debug, "Ø±Ø³Ø§Ù„Ø© Ø³Ø¬Ù„ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©: Ø§ÙƒØªÙ…Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
  assert_eq(LogRecord::severity_number(arabic_log), Debug)
  match LogRecord::body(arabic_log) {
    Some(body) => assert_eq(body, "Ø±Ø³Ø§Ù„Ø© Ø³Ø¬Ù„ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©: Ø§ÙƒØªÙ…Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
    None => assert_true(false)
  }
  
  // Test log record with mixed Unicode and attributes
  let unicode_attrs = Attributes::new()
  Attributes::set(unicode_attrs, "ç”¨æˆ·å", StringValue("å¼ ä¸‰"))
  Attributes::set(unicode_attrs, "æ“ä½œ", StringValue("ãƒ‡ãƒ¼ã‚¿å‡¦ç†"))
  Attributes::set(unicode_attrs, "ìƒíƒœ", StringValue("ì™„ë£Œ"))
  
  let mixed_log = LogRecord::new_with_context(
    Info,
    Some("Mixed Unicode log: ä¸­æ–‡ ğŸš€ English æ—¥æœ¬èª ğŸŒ í•œêµ­ì–´"),
    Some(unicode_attrs),
    Some(1234567890L),
    Some(1234567891L),
    Some("mixed_unicode_trace"),
    Some("mixed_unicode_span"),
    Some(Context::root())
  )
  
  assert_eq(LogRecord::severity_number(mixed_log), Info)
  match LogRecord::body(mixed_log) {
    Some(body) => assert_eq(body, "Mixed Unicode log: ä¸­æ–‡ ğŸš€ English æ—¥æœ¬èª ğŸŒ í•œêµ­ì–´")
    None => assert_true(false)
  }
  
  // Verify Unicode attributes are preserved
  let log_attrs = LogRecord::attributes(mixed_log)
  let username = Attributes::get(log_attrs, "ç”¨æˆ·å")
  match username {
    Some(StringValue(name)) => assert_eq(name, "å¼ ä¸‰")
    None => assert_true(false)
  }
}

// Test 4: Unicode Support in Resource Attributes
test "unicode support in resource attributes" {
  // Test resource with Chinese attributes
  let chinese_attrs = [
    ("æœåŠ¡åç§°", StringValue("ä¸­æ–‡æœåŠ¡")),
    ("æœåŠ¡ç‰ˆæœ¬", StringValue("1.0.0")),
    ("ç¯å¢ƒ", StringValue("ç”Ÿäº§ç¯å¢ƒ")),
    ("æè¿°", StringValue("è¿™æ˜¯ä¸€ä¸ªä¸­æ–‡æœåŠ¡çš„æè¿°"))
  ]
  let chinese_resource = Resource::with_attributes(Resource::new(), chinese_attrs)
  
  let service_name = Resource::get_attribute(chinese_resource, "æœåŠ¡åç§°")
  match service_name {
    Some(StringValue(name)) => assert_eq(name, "ä¸­æ–‡æœåŠ¡")
    None => assert_true(false)
  }
  
  let description = Resource::get_attribute(chinese_resource, "æè¿°")
  match description {
    Some(StringValue(desc)) => assert_eq(desc, "è¿™æ˜¯ä¸€ä¸ªä¸­æ–‡æœåŠ¡çš„æè¿°")
    None => assert_true(false)
  }
  
  // Test resource with Japanese attributes
  let japanese_attrs = [
    ("ã‚µãƒ¼ãƒ“ã‚¹å", StringValue("æ—¥æœ¬èªã‚µãƒ¼ãƒ“ã‚¹")),
    ("ã‚µãƒ¼ãƒ“ã‚¹ãƒãƒ¼ã‚¸ãƒ§ãƒ³", StringValue("1.0.0")),
    ("ç’°å¢ƒ", StringValue("æœ¬ç•ªç’°å¢ƒ")),
    ("èª¬æ˜", StringValue("ã“ã‚Œã¯æ—¥æœ¬èªã‚µãƒ¼ãƒ“ã‚¹ã®èª¬æ˜ã§ã™"))
  ]
  let japanese_resource = Resource::with_attributes(Resource::new(), japanese_attrs)
  
  let service_name_ja = Resource::get_attribute(japanese_resource, "ã‚µãƒ¼ãƒ“ã‚¹å")
  match service_name_ja {
    Some(StringValue(name)) => assert_eq(name, "æ—¥æœ¬èªã‚µãƒ¼ãƒ“ã‚¹")
    None => assert_true(false)
  }
  
  let description_ja = Resource::get_attribute(japanese_resource, "èª¬æ˜")
  match description_ja {
    Some(StringValue(desc)) => assert_eq(desc, "ã“ã‚Œã¯æ—¥æœ¬èªã‚µãƒ¼ãƒ“ã‚¹ã®èª¬æ˜ã§ã™")
    None => assert_true(false)
  }
  
  // Test resource with mixed Unicode attributes
  let mixed_attrs = [
    ("service.name", StringValue("multilingual-service")),
    ("æœåŠ¡åç§°", StringValue("å¤šè¯­è¨€æœåŠ¡")),
    ("ã‚µãƒ¼ãƒ“ã‚¹å", StringValue("å¤šè¨€èªã‚µãƒ¼ãƒ“ã‚¹")),
    ("ì„œë¹„ìŠ¤ëª…", StringValue("ë‹¤êµ­ì–´ ì„œë¹„ìŠ¤")),
    ("emoji.tag", StringValue("ğŸŒğŸš€ğŸ’»"))
  ]
  let mixed_resource = Resource::with_attributes(Resource::new(), mixed_attrs)
  
  let emoji_tag = Resource::get_attribute(mixed_resource, "emoji.tag")
  match emoji_tag {
    Some(StringValue(tag)) => assert_eq(tag, "ğŸŒğŸš€ğŸ’»")
    None => assert_true(false)
  }
}

// Test 5: Unicode Support in Baggage
test "unicode support in baggage" {
  let baggage = Baggage::new()
  
  // Test baggage with Chinese entries
  let baggage_with_chinese = Baggage::set_entry(baggage, "ç”¨æˆ·ID", "ç”¨æˆ·123")
  let baggage_with_japanese = Baggage::set_entry(baggage_with_chinese, "ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ID", "ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³456")
  let baggage_with_korean = Baggage::set_entry(baggage_with_japanese, "ì„¸ì…˜ID", "ì„¸ì…˜789")
  let baggage_with_emoji = Baggage::set_entry(baggage_with_korean, "ğŸ¯ç‰¹æ®Šæ ‡è®°", "ç‰¹æ®Šå€¼")
  
  // Verify Chinese entry
  let user_id = Baggage::get_entry(baggage_with_emoji, "ç”¨æˆ·ID")
  match user_id {
    Some(value) => assert_eq(value, "ç”¨æˆ·123")
    None => assert_true(false)
  }
  
  // Verify Japanese entry
  let transaction_id = Baggage::get_entry(baggage_with_emoji, "ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ID")
  match transaction_id {
    Some(value) => assert_eq(value, "ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³456")
    None => assert_true(false)
  }
  
  // Verify Korean entry
  let session_id = Baggage::get_entry(baggage_with_emoji, "ì„¸ì…˜ID")
  match session_id {
    Some(value) => assert_eq(value, "ì„¸ì…˜789")
    None => assert_true(false)
  }
  
  // Verify Emoji entry
  let special_tag = Baggage::get_entry(baggage_with_emoji, "ğŸ¯ç‰¹æ®Šæ ‡è®°")
  match special_tag {
    Some(value) => assert_eq(value, "ç‰¹æ®Šå€¼")
    None => assert_true(false)
  }
}

// Test 6: Unicode Support in HTTP Headers and Bodies
test "unicode support in http headers and bodies" {
  // Test HTTP request with Unicode headers and body
  let unicode_headers = [
    ("Content-Type", "application/json; charset=utf-8"),
    ("X-User-Name", "å¼ ä¸‰"),
    ("X-Operation", "ãƒ‡ãƒ¼ã‚¿å‡¦ç†"),
    ("X-Status", "ì™„ë£Œ"),
    ("X-Special", "ğŸš€ Rocket Launch")
  ]
  
  let unicode_body = "{\"message\": \"ä¸­æ–‡æµ‹è¯•æ¶ˆæ¯\", \"data\": \"ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿\", \"status\": \"í…ŒìŠ¤íŠ¸ ì™„ë£Œ\", \"emoji\": \"ğŸŒ\"}"
  let unicode_request = HttpRequest::new("POST", "https://unicode.example.com/api", unicode_headers, Some(unicode_body))
  
  assert_eq(HttpRequest::http_method(unicode_request), "POST")
  assert_eq(HttpRequest::url(unicode_request), "https://unicode.example.com/api")
  match HttpRequest::body(unicode_request) {
    Some(body) => assert_eq(body, unicode_body)
    None => assert_true(false)
  }
  
  // Test HTTP response with Unicode headers and body
  let unicode_response_headers = [
    ("Content-Type", "application/json; charset=utf-8"),
    ("X-Response-Message", "å‡¦ç†å®Œäº†"),
    ("X-Result", "ì„±ê³µ"),
    ("X-Unicode", "âœ… æˆåŠŸ")
  ]
  
  let unicode_response_body = "{\"result\": \"æˆåŠŸ\", \"message\": \"æ“ä½œæˆåŠŸå®Œæˆ\", \"details\": \"è©³ç´°æƒ…å ±\", \"emoji\": \"ğŸ‰\"}"
  let unicode_response = HttpResponse::new(200, unicode_response_headers, Some(unicode_response_body))
  
  assert_eq(HttpResponse::status_code(unicode_response), 200)
  match HttpResponse::body(unicode_response) {
    Some(body) => assert_eq(body, unicode_response_body)
    None => assert_true(false)
  }
}

// Test 7: Unicode Support in Context Propagation
test "unicode support in context propagation" {
  // Create context with Unicode trace state
  let unicode_trace_state = "ä¸­æ–‡çŠ¶æ€=æµ‹è¯•å€¼,æ—¥æœ¬èªçŠ¶æ…‹=ãƒ†ã‚¹ãƒˆå€¤,í•œêµ­ì–´ìƒíƒœ=í…ŒìŠ¤íŠ¸ê°’"
  let unicode_ctx = SpanContext::new("unicode_trace_123", "unicode_span_456", true, unicode_trace_state)
  
  assert_eq(SpanContext::trace_id(unicode_ctx), "unicode_trace_123")
  assert_eq(SpanContext::span_id(unicode_ctx), "unicode_span_456")
  assert_true(SpanContext::is_sampled(unicode_ctx))
  
  // Test context with Unicode baggage
  let unicode_baggage = Baggage::new()
  let baggage_with_unicode = Baggage::set_entry(unicode_baggage, "ç”¨æˆ·ä¿¡æ¯", "å¼ ä¸‰,25å²,åŒ—äº¬")
  let baggage_with_more_unicode = Baggage::set_entry(baggage_with_unicode, "æ“ä½œæƒ…å ±", "ãƒ‡ãƒ¼ã‚¿å‡¦ç†,é‡è¦")
  
  // Verify Unicode baggage entries
  let user_info = Baggage::get_entry(baggage_with_more_unicode, "ç”¨æˆ·ä¿¡æ¯")
  match user_info {
    Some(value) => assert_eq(value, "å¼ ä¸‰,25å²,åŒ—äº¬")
    None => assert_true(false)
  }
  
  let operation_info = Baggage::get_entry(baggage_with_more_unicode, "æ“ä½œæƒ…å ±")
  match operation_info {
    Some(value) => assert_eq(value, "ãƒ‡ãƒ¼ã‚¿å‡¦ç†,é‡è¦")
    None => assert_true(false)
  }
}

// Test 8: Unicode Support in Metrics
test "unicode support in metrics" {
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "unicode_meter")
  
  // Create instruments with Unicode names and descriptions
  let chinese_counter = Meter::create_counter(meter, "ä¸­æ–‡è®¡æ•°å™¨", Some("ä¸­æ–‡è®¡æ•°å™¨æè¿°"), Some("ä¸ª"))
  let japanese_histogram = Meter::create_histogram(meter, "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ", Some("æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®èª¬æ˜"), Some("ãƒŸãƒªç§’"))
  let korean_updown = Meter::create_updown_counter(meter, "í•œêµ­ì–´ ì—…ë‹¤ìš´ì¹´ìš´í„°", Some("í•œêµ­ì–´ ì—…ë‹¤ìš´ì¹´ìš´í„° ì„¤ëª…"), Some("ê°’"))
  
  // Record metrics with Unicode attributes
  Counter::add(chinese_counter, 1.0, Some([
    ("æ“ä½œç±»å‹", StringValue("æ•°æ®å¤„ç†")),
    ("ç”¨æˆ·", StringValue("å¼ ä¸‰")),
    ("çŠ¶æ€", StringValue("æˆåŠŸ"))
  ]))
  
  Histogram::record(japanese_histogram, 100.5, Some([
    ("æ“ä½œã‚¿ã‚¤ãƒ—", StringValue("ãƒ‡ãƒ¼ã‚¿å‡¦ç†")),
    ("ãƒ¦ãƒ¼ã‚¶ãƒ¼", StringValue("ç”°ä¸­")),
    ("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", StringValue("æˆåŠŸ"))
  ]))
  
  UpDownCounter::add(korean_updown, 10.0, Some([
    ("ì‘ì—… ìœ í˜•", StringValue("ë°ì´í„° ì²˜ë¦¬")),
    ("ì‚¬ìš©ì", StringValue("ê¹€ì² ìˆ˜")),
    ("ìƒíƒœ", StringValue("ì„±ê³µ"))
  ]))
  
  // Collect and verify metrics
  let metric_data = Meter::collect(meter)
  let metrics = MetricData::metrics(metric_data)
  
  assert_true(metrics.length() >= 3)
  
  // Verify metric names and descriptions
  for metric in metrics {
    let name = Metric::name(metric)
    let description = Metric::description(metric)
    
    if name == "ä¸­æ–‡è®¡æ•°å™¨" {
      match description {
        Some(desc) => assert_eq(desc, "ä¸­æ–‡è®¡æ•°å™¨æè¿°")
        None => assert_true(false)
      }
    } else if name == "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ " {
      match description {
        Some(desc) => assert_eq(desc, "æ—¥æœ¬èªãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã®èª¬æ˜")
        None => assert_true(false)
      }
    } else if name == "í•œêµ­ì–´ ì—…ë‹¤ìš´ì¹´ìš´í„°" {
      match description {
        Some(desc) => assert_eq(desc, "í•œêµ­ì–´ ì—…ë‹¤ìš´ì¹´ìš´í„° ì„¤ëª…")
        None => assert_true(false)
      }
    }
  }
}

// Test 9: Unicode Serialization and Deserialization
test "unicode serialization and deserialization" {
  // Create attributes with various Unicode characters
  let unicode_attrs = Attributes::new()
  Attributes::set(unicode_attrs, "ä¸­æ–‡é”®", StringValue("ä¸­æ–‡å€¼"))
  Attributes::set(unicode_attrs, "æ—¥æœ¬èªã‚­ãƒ¼", StringValue("æ—¥æœ¬èªå€¤"))
  Attributes::set(unicode_attrs, "í•œêµ­ì–´ í‚¤", StringValue("í•œêµ­ì–´ ê°’"))
  Attributes::set(unicode_attrs, "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©", StringValue("Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©"))
  Attributes::set(unicode_attrs, "emoji", StringValue("ğŸš€ğŸŒğŸ’»ğŸ“Š"))
  
  // Serialize attributes
  let serialized = Attributes::serialize(unicode_attrs)
  assert_true(serialized.length() > 0)
  
  // Deserialize attributes
  let deserialized = Attributes::deserialize(serialized)
  
  match deserialized {
    Some(attrs) => {
      // Verify Chinese characters
      let chinese_value = Attributes::get(attrs, "ä¸­æ–‡é”®")
      match chinese_value {
        Some(StringValue(value)) => assert_eq(value, "ä¸­æ–‡å€¼")
        None => assert_true(false)
      }
      
      // Verify Japanese characters
      let japanese_value = Attributes::get(attrs, "æ—¥æœ¬èªã‚­ãƒ¼")
      match japanese_value {
        Some(StringValue(value)) => assert_eq(value, "æ—¥æœ¬èªå€¤")
        None => assert_true(false)
      }
      
      // Verify Korean characters
      let korean_value = Attributes::get(attrs, "í•œêµ­ì–´ í‚¤")
      match korean_value {
        Some(StringValue(value)) => assert_eq(value, "í•œêµ­ì–´ ê°’")
        None => assert_true(false)
      }
      
      // Verify Arabic characters
      let arabic_value = Attributes::get(attrs, "Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©")
      match arabic_value {
        Some(StringValue(value)) => assert_eq(value, "Ù‚ÙŠÙ…Ø© Ø¹Ø±Ø¨ÙŠØ©")
        None => assert_true(false)
      }
      
      // Verify Emoji
      let emoji_value = Attributes::get(attrs, "emoji")
      match emoji_value {
        Some(StringValue(value)) => assert_eq(value, "ğŸš€ğŸŒğŸ’»ğŸ“Š")
        None => assert_true(false)
      }
    }
    None => assert_true(false)
  }
  
  // Test span serialization with Unicode
  let unicode_span_ctx = SpanContext::new("unicode_trace", "unicode_span", true, "unicode_state")
  let unicode_span = Span::new("Unicodeæ“ä½œ ğŸš€", Internal, unicode_span_ctx)
  Span::add_attribute(unicode_span, "æ“ä½œç±»å‹", StringValue("æ•°æ®å¤„ç†"))
  Span::add_event(unicode_span, "æ“ä½œå¼€å§‹", Some([
    ("ç”¨æˆ·", StringValue("å¼ ä¸‰")),
    ("ä½ç½®", StringValue("ğŸ“ åŒ—äº¬"))
  ]))
  
  // Serialize span
  let serialized_span = Span::serialize(unicode_span)
  assert_true(serialized_span.length() > 0)
  
  // Deserialize span
  let deserialized_span = Span::deserialize(serialized_span)
  
  match deserialized_span {
    Some(span) => {
      assert_eq(Span::name(span), "Unicodeæ“ä½œ ğŸš€")
      
      let operation_type = Span::get_attribute(span, "æ“ä½œç±»å‹")
      match operation_type {
        Some(StringValue(value)) => assert_eq(value, "æ•°æ®å¤„ç†")
        None => assert_true(false)
      }
    }
    None => assert_true(false)
  }
}

// Test 10: Comprehensive Unicode Integration Test
test "comprehensive unicode integration test" {
  // Create a comprehensive multilingual telemetry scenario
  
  // 1. Create Unicode context
  let unicode_trace_state = "ä¸­æ–‡çŠ¶æ€=è¿è¡Œä¸­,æ—¥æœ¬èªçŠ¶æ…‹=å®Ÿè¡Œä¸­,í•œêµ­ì–´ìƒíƒœ=ì‹¤í–‰ì¤‘"
  let unicode_ctx = SpanContext::new("unicode_integration_trace", "unicode_integration_span", true, unicode_trace_state)
  
  // 2. Create Unicode resource
  let unicode_resource_attrs = [
    ("service.name", StringValue("å¤šè¯­è¨€æœåŠ¡")),
    ("ã‚µãƒ¼ãƒ“ã‚¹å", StringValue("å¤šè¨€èªã‚µãƒ¼ãƒ“ã‚¹")),
    ("ì„œë¹„ìŠ¤ëª…", StringValue("ë‹¤êµ­ì–´ ì„œë¹„ìŠ¤")),
    ("service.version", StringValue("1.0.0")),
    ("ç¯å¢ƒ", StringValue("ç”Ÿäº§ç¯å¢ƒ")),
    ("ç’°å¢ƒ", StringValue("æœ¬ç•ªç’°å¢ƒ")),
    ("í™˜ê²½", StringValue("í”„ë¡œë•ì…˜"))
  ]
  let unicode_resource = Resource::with_attributes(Resource::new(), unicode_resource_attrs)
  
  // 3. Create Unicode span
  let unicode_span = Span::new("å¤šè¯­è¨€é›†æˆæµ‹è¯• ğŸŒ", Server, unicode_ctx)
  Span::add_attribute(unicode_span, "æ“ä½œç±»å‹", StringValue("é›†æˆæµ‹è¯•"))
  Span::add_attribute(unicode_span, "æ“ä½œã‚¿ã‚¤ãƒ—", StringValue("çµ±åˆãƒ†ã‚¹ãƒˆ"))
  Span::add_attribute(unicode_span, "ì‘ì—… ìœ í˜•", StringValue("í†µí•© í…ŒìŠ¤íŠ¸"))
  
  // 4. Add Unicode events
  Span::add_event(unicode_span, "æµ‹è¯•å¼€å§‹", Some([
    ("å¼€å§‹æ—¶é—´", StringValue("2023-01-01 00:00:00")),
    ("æµ‹è¯•äººå‘˜", StringValue("å¼ ä¸‰")),
    ("ãƒ†ã‚¹ãƒˆæ‹…å½“è€…", StringValue("ç”°ä¸­")),
    ("í…ŒìŠ¤í„°", StringValue("ê¹€ì² ìˆ˜"))
  ]))
  
  Span::add_event(unicode_span, "æ•°æ®å¤„ç†ä¸­", Some([
    ("å¤„ç†æ•°æ®é‡", IntValue(1000)),
    ("å‡¦ç†ãƒ‡ãƒ¼ã‚¿é‡", IntValue(1000)),
    ("ì²˜ë¦¬ ë°ì´í„°ëŸ‰", IntValue(1000))
  ]))
  
  // 5. Create Unicode metrics
  let provider = MeterProvider::default()
  let meter = MeterProvider::get_meter(provider, "å¤šè¯­è¨€ä»ªè¡¨")
  let unicode_counter = Meter::create_counter(meter, "æ“ä½œè®¡æ•°å™¨", Some("æ“ä½œè®¡æ•°å™¨æè¿°"), Some("æ¬¡"))
  
  Counter::add(unicode_counter, 1.0, Some([
    ("æ“ä½œç±»å‹", StringValue("é›†æˆæµ‹è¯•")),
    ("ãƒ¦ãƒ¼ã‚¶ãƒ¼", StringValue("ç”°ä¸­")),
    ("ì‚¬ìš©ì", StringValue("ê¹€ì² ìˆ˜")),
    ("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹", StringValue("æˆåŠŸ")),
    ("ìƒíƒœ", StringValue("ì„±ê³µ"))
  ]))
  
  // 6. Create Unicode log records
  let unicode_log_attrs = Attributes::new()
  Attributes::set(unicode_log_attrs, "æ—¥å¿—çº§åˆ«", StringValue("ä¿¡æ¯"))
  Attributes::set(unicode_log_attrs, "ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«", StringValue("æƒ…å ±"))
  Attributes::set(unicode_log_attrs, "ë¡œê·¸ ë ˆë²¨", StringValue("ì •ë³´"))
  
  let unicode_log = LogRecord::new_with_context(
    Info,
    Some("å¤šè¯­è¨€é›†æˆæµ‹è¯•æ—¥å¿—ï¼šé›†æˆæµ‹è¯•æ“ä½œå·²æˆåŠŸå®Œæˆ ğŸ‰"),
    Some(unicode_log_attrs),
    Some(1234567890L),
    Some(1234567891L),
    Some("unicode_integration_trace"),
    Some("unicode_integration_span"),
    Some(Context::root())
  )
  
  // 7. Create Unicode baggage
  let unicode_baggage = Baggage::new()
  let final_baggage = Baggage::set_entry(unicode_baggage, "ç”¨æˆ·ä¼šè¯", "ç”¨æˆ·123_ä¸­æ–‡ä¼šè¯")
  let final_baggage_ja = Baggage::set_entry(final_baggage, "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚»ãƒƒã‚·ãƒ§ãƒ³", "ãƒ¦ãƒ¼ã‚¶ãƒ¼456_æ—¥æœ¬èªã‚»ãƒƒã‚·ãƒ§ãƒ³")
  let final_baggage_ko = Baggage::set_entry(final_baggage_ja, "ì‚¬ìš©ì ì„¸ì…˜", "ì‚¬ìš©ì789_í•œêµ­ì–´ ì„¸ì…˜")
  
  // 8. Complete the span
  Span::set_status(unicode_span, Ok, Some("æ“ä½œæˆåŠŸå®Œæˆ"))
  Span::add_event(unicode_span, "æµ‹è¯•å®Œæˆ", Some([
    ("å®Œæˆæ—¶é—´", StringValue("2023-01-01 01:00:00")),
    ("çµæœ", StringValue("æˆåŠŸ")),
    ("ê²°ê³¼", StringValue("ì„±ê³µ"))
  ]))
  Span::end(unicode_span)
  
  // Verify all components work correctly with Unicode
  
  // Verify span
  assert_eq(Span::name(unicode_span), "å¤šè¯­è¨€é›†æˆæµ‹è¯• ğŸŒ")
  assert_eq(Span::status(unicode_span), Ok)
  
  let operation_type = Span::get_attribute(unicode_span, "æ“ä½œç±»å‹")
  match operation_type {
    Some(StringValue(value)) => assert_eq(value, "é›†æˆæµ‹è¯•")
    None => assert_true(false)
  }
  
  // Verify log
  assert_eq(LogRecord::severity_number(unicode_log), Info)
  match LogRecord::body(unicode_log) {
    Some(body) => assert_eq(body, "å¤šè¯­è¨€é›†æˆæµ‹è¯•æ—¥å¿—ï¼šé›†æˆæµ‹è¯•æ“ä½œå·²æˆåŠŸå®Œæˆ ğŸ‰")
    None => assert_true(false)
  }
  
  // Verify baggage
  let user_session = Baggage::get_entry(final_baggage_ko, "ç”¨æˆ·ä¼šè¯")
  match user_session {
    Some(value) => assert_eq(value, "ç”¨æˆ·123_ä¸­æ–‡ä¼šè¯")
    None => assert_true(false)
  }
  
  let user_session_ko = Baggage::get_entry(final_baggage_ko, "ì‚¬ìš©ì ì„¸ì…˜")
  match user_session_ko {
    Some(value) => assert_eq(value, "ì‚¬ìš©ì789_í•œêµ­ì–´ ì„¸ì…˜")
    None => assert_true(false)
  }
  
  // Verify metrics
  let metric_data = Meter::collect(meter)
  let metrics = MetricData::metrics(metric_data)
  assert_true(metrics.length() >= 1)
  
  // Verify resource
  let service_name = Resource::get_attribute(unicode_resource, "service.name")
  match service_name {
    Some(StringValue(name)) => assert_eq(name, "å¤šè¯­è¨€æœåŠ¡")
    None => assert_true(false)
  }
  
  let service_name_ja = Resource::get_attribute(unicode_resource, "ã‚µãƒ¼ãƒ“ã‚¹å")
  match service_name_ja {
    Some(StringValue(name)) => assert_eq(name, "å¤šè¨€èªã‚µãƒ¼ãƒ“ã‚¹")
    None => assert_true(false)
  }
}