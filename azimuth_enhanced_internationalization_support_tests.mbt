// Azimuth å›½é™…åŒ–æ”¯æŒå¢å¼ºæµ‹è¯•
// ä¸“æ³¨äºå¤šè¯­è¨€æ”¯æŒã€æœ¬åœ°åŒ–ã€å­—ç¬¦ç¼–ç ã€æ—¶åŒºå¤„ç†å’Œæ–‡åŒ–é€‚é…

// æµ‹è¯•1: å¤šè¯­è¨€æ–‡æœ¬å¤„ç†
test "å¤šè¯­è¨€æ–‡æœ¬å¤„ç†æµ‹è¯•" {
  // åˆ›å»ºå›½é™…åŒ–ç®¡ç†å™¨
  let i18n_manager = I18nManager::new()
  
  // é…ç½®æ”¯æŒçš„è¯­è¨€
  let supported_locales = [
    "en-US",    // è‹±è¯­ï¼ˆç¾å›½ï¼‰
    "zh-CN",    // ç®€ä½“ä¸­æ–‡
    "zh-TW",    // ç¹ä½“ä¸­æ–‡
    "ja-JP",    // æ—¥è¯­
    "ko-KR",    // éŸ©è¯­
    "fr-FR",    // æ³•è¯­
    "de-DE",    // å¾·è¯­
    "es-ES",    // è¥¿ç­ç‰™è¯­
    "ru-RU",    // ä¿„è¯­
    "ar-SA"     // é˜¿æ‹‰ä¼¯è¯­
  ]
  
  // æ³¨å†Œæ”¯æŒçš„è¯­è¨€
  for locale in supported_locales {
    I18nManager::register_locale(i18n_manager, locale)
  }
  
  // å®šä¹‰å¤šè¯­è¨€èµ„æº
  let message_resources = {
    "en-US": {
      "welcome": "Welcome to Azimuth",
      "goodbye": "Goodbye",
      "error_occurred": "An error occurred: {error}",
      "items_count": "{count, plural, one{# item} other{# items}}",
      "date_format": "MM/DD/YYYY",
      "time_format": "h:mm:ss A"
    },
    "zh-CN": {
      "welcome": "æ¬¢è¿ä½¿ç”¨ Azimuth",
      "goodbye": "å†è§",
      "error_occurred": "å‘ç”Ÿé”™è¯¯ï¼š{error}",
      "items_count": "{count, plural, other{# é¡¹}}",
      "date_format": "YYYYå¹´MMæœˆDDæ—¥",
      "time_format": "AHH:mm:ss"
    },
    "zh-TW": {
      "welcome": "æ­¡è¿ä½¿ç”¨ Azimuth",
      "goodbye": "å†è¦‹",
      "error_occurred": "ç™¼ç”ŸéŒ¯èª¤ï¼š{error}",
      "items_count": "{count, plural, other{# é …}}",
      "date_format": "YYYYå¹´MMæœˆDDæ—¥",
      "time_format": "AHH:mm:ss"
    },
    "ja-JP": {
      "welcome": "Azimuthã¸ã‚ˆã†ã“ã",
      "goodbye": "ã•ã‚ˆã†ãªã‚‰",
      "error_occurred": "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸï¼š{error}",
      "items_count": "{count, plural, other{# é …ç›®}}",
      "date_format": "YYYY/MM/DD",
      "time_format": "AHH:mm:ss"
    },
    "ko-KR": {
      "welcome": "Azimuthì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤",
      "goodbye": "ì•ˆë…•íˆ ê°€ì„¸ìš”",
      "error_occurred": "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error}",
      "items_count": "{count, plural, other{# í•­ëª©}}",
      "date_format": "YYYY. MM. DD.",
      "time_format": "A HH:mm:ss"
    },
    "fr-FR": {
      "welcome": "Bienvenue sur Azimuth",
      "goodbye": "Au revoir",
      "error_occurred": "Une erreur s'est produite : {error}",
      "items_count": "{count, plural, one{# Ã©lÃ©ment} other{# Ã©lÃ©ments}}",
      "date_format": "DD/MM/YYYY",
      "time_format": "HH:mm:ss"
    },
    "de-DE": {
      "welcome": "Willkommen bei Azimuth",
      "goodbye": "Auf Wiedersehen",
      "error_occurred": "Ein Fehler ist aufgetreten: {error}",
      "items_count": "{count, plural, one{# Element} other{# Elemente}}",
      "date_format": "DD.MM.YYYY",
      "time_format": "HH:mm:ss"
    },
    "es-ES": {
      "welcome": "Bienvenido a Azimuth",
      "goodbye": "AdiÃ³s",
      "error_occurred": "OcurriÃ³ un error: {error}",
      "items_count": "{count, plural, one{# elemento} other{# elementos}}",
      "date_format": "DD/MM/YYYY",
      "time_format": "H:mm:ss"
    },
    "ru-RU": {
      "welcome": "Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Azimuth",
      "goodbye": "Ğ”Ğ¾ ÑĞ²Ğ¸Ğ´Ğ°Ğ½Ğ¸Ñ",
      "error_occurred": "ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: {error}",
      "items_count": "{count, plural, one{# ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚} few{# ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°} many{# ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²} other{# ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²}}",
      "date_format": "DD.MM.YYYY",
      "time_format": "H:mm:ss"
    },
    "ar-SA": {
      "welcome": "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Azimuth",
      "goodbye": "ÙˆØ¯Ø§Ø¹Ø§",
      "error_occurred": "Ø­Ø¯Ø« Ø®Ø·Ø£: {error}",
      "items_count": "{count, plural, one{# Ø¹Ù†ØµØ±} other{# Ø¹Ù†Ø§ØµØ±}}",
      "date_format": "DD/MM/YYYY",
      "time_format": "H:mm:ss"
    }
  }
  
  // åŠ è½½å¤šè¯­è¨€èµ„æº
  for (locale, resources) in message_resources.entries() {
    I18nManager::load_resources(i18n_manager, locale, resources)
  }
  
  // è®¾ç½®å½“å‰è¯­è¨€
  I18nManager::set_locale(i18n_manager, "en-US")
  
  // æµ‹è¯•åŸºæœ¬æ¶ˆæ¯ç¿»è¯‘
  let welcome_en = I18nManager::translate(i18n_manager, "welcome")
  assert_eq(welcome_en, "Welcome to Azimuth")
  
  let goodbye_en = I18nManager::translate(i18n_manager, "goodbye")
  assert_eq(goodbye_en, "Goodbye")
  
  // æµ‹è¯•ä¸­æ–‡ç¿»è¯‘
  I18nManager::set_locale(i18n_manager, "zh-CN")
  
  let welcome_zh = I18nManager::translate(i18n_manager, "welcome")
  assert_eq(welcome_zh, "æ¬¢è¿ä½¿ç”¨ Azimuth")
  
  let goodbye_zh = I18nManager::translate(i18n_manager, "goodbye")
  assert_eq(goodbye_zh, "å†è§")
  
  // æµ‹è¯•æ—¥è¯­ç¿»è¯‘
  I18nManager::set_locale(i18n_manager, "ja-JP")
  
  let welcome_ja = I18nManager::translate(i18n_manager, "welcome")
  assert_eq(welcome_ja, "Azimuthã¸ã‚ˆã†ã“ã")
  
  // æµ‹è¯•éŸ©è¯­ç¿»è¯‘
  I18nManager::set_locale(i18n_manager, "ko-KR")
  
  let welcome_ko = I18nManager::translate(i18n_manager, "welcome")
  assert_eq(welcome_ko, "Azimuthì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤")
  
  // æµ‹è¯•å‚æ•°åŒ–æ¶ˆæ¯
  I18nManager::set_locale(i18n_manager, "en-US")
  
  let error_en = I18nManager::translate_with_params(i18n_manager, "error_occurred", [("error", "Connection timeout")])
  assert_eq(error_en, "An error occurred: Connection timeout")
  
  // æµ‹è¯•å¤æ•°å½¢å¼
  let items_one_en = I18nManager::translate_with_params(i18n_manager, "items_count", [("count", 1)])
  assert_eq(items_one_en, "1 item")
  
  let items_many_en = I18nManager::translate_with_params(i18n_manager, "items_count", [("count", 5)])
  assert_eq(items_many_en, "5 items")
  
  // æµ‹è¯•ä¸­æ–‡å¤æ•°å½¢å¼
  I18nManager::set_locale(i18n_manager, "zh-CN")
  
  let items_zh = I18nManager::translate_with_params(i18n_manager, "items_count", [("count", 5)])
  assert_eq(items_zh, "5 é¡¹")
  
  // æµ‹è¯•ä¿„è¯­å¤æ•°å½¢å¼
  I18nManager::set_locale(i18n_manager, "ru-RU")
  
  let items_one_ru = I18nManager::translate_with_params(i18n_manager, "items_count", [("count", 1)])
  assert_eq(items_one_ru, "1 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚")
  
  let items_few_ru = I18nManager::translate_with_params(i18n_manager, "items_count", [("count", 3)])
  assert_eq(items_few_ru, "3 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°")
  
  let items_many_ru = I18nManager::translate_with_params(i18n_manager, "items_count", [("count", 7)])
  assert_eq(items_many_ru, "7 ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ğ¾Ğ²")
  
  // æµ‹è¯•å›é€€æœºåˆ¶
  I18nManager::set_locale(i18n_manager, "en-GB")  // ä¸æ”¯æŒçš„è¯­è¨€
  
  // åº”è¯¥å›é€€åˆ°åŸºç¡€è¯­è¨€ï¼ˆenï¼‰
  let welcome_fallback = I18nManager::translate(i18n_manager, "welcome")
  assert_eq(welcome_fallback, "Welcome to Azimuth")
  
  // æµ‹è¯•ç¼ºå¤±é”®çš„å›é€€
  I18nManager::set_locale(i18n_manager, "en-US")
  
  let missing_key = I18nManager::translate(i18n_manager, "nonexistent_key")
  assert_eq(missing_key, "nonexistent_key")  // åº”è¯¥è¿”å›é”®å
  
  // æµ‹è¯•RTLè¯­è¨€æ”¯æŒ
  I18nManager::set_locale(i18n_manager, "ar-SA")
  
  let is_rtl = I18nManager::is_rtl_locale(i18n_manager)
  assert_true(is_rtl)
  
  let welcome_ar = I18nManager::translate(i18n_manager, "welcome")
  assert_eq(welcome_ar, "Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Azimuth")
  
  // æµ‹è¯•LTRè¯­è¨€
  I18nManager::set_locale(i18n_manager, "en-US")
  
  let is_ltr = I18nManager::is_ltr_locale(i18n_manager)
  assert_true(is_ltr)
  
  // è·å–è¯­è¨€ä¿¡æ¯
  let locale_info = I18nManager::get_locale_info(i18n_manager, "zh-CN")
  assert_eq(locale_info.language, "zh")
  assert_eq(locale_info.country, "CN")
  assert_eq(locale_info.display_name, "Chinese (Simplified)")
  assert_true(locale_info.rtl == false)
}

// æµ‹è¯•2: å­—ç¬¦ç¼–ç å’Œè½¬æ¢
test "å­—ç¬¦ç¼–ç å’Œè½¬æ¢æµ‹è¯•" {
  // åˆ›å»ºç¼–ç ç®¡ç†å™¨
  let encoding_manager = EncodingManager::new()
  
  // æµ‹è¯•UTF-8ç¼–ç 
  let utf8_text = "Hello ä¸–ç•Œ ğŸŒ Azimuth"
  let utf8_bytes = EncodingManager::encode_utf8(encoding_manager, utf8_text)
  
  // éªŒè¯UTF-8ç¼–ç 
  assert_true(utf8_bytes.length() > utf8_text.length())  // UTF-8å­—èŠ‚åº”è¯¥æ¯”å­—ç¬¦å¤š
  
  // æµ‹è¯•UTF-8è§£ç 
  let decoded_text = EncodingManager::decode_utf8(encoding_manager, utf8_bytes)
  assert_eq(decoded_text, utf8_text)
  
  // æµ‹è¯•ä¸åŒè¯­è¨€çš„UTF-8ç¼–ç 
  let multilingual_texts = [
    "English text with Ã©mojis ğŸ‰",
    "ä¸­æ–‡æ–‡æœ¬åŒ…å«è¡¨æƒ…ç¬¦å· ğŸŠ",
    "æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã¨çµµæ–‡å­— ğŸŒ",
    "í•œêµ­ì–´ í…ìŠ¤íŠ¸ì™€ ì´ëª¨ì§€ ğŸ‹",
    "Texte franÃ§ais avec des Ã©mojis ğŸˆ",
    "Deutscher Text mit Emojis ğŸ€",
    "Texto espaÃ±ol con emojis ğŸ",
    "Ğ ÑƒÑÑĞºĞ¸Ğ¹ Ñ‚ĞµĞºÑÑ‚ Ñ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ ğŸ‚",
    "Ù†Øµ Ø¹Ø±Ø¨ÙŠ Ù…Ø¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„ØªØ¹Ø¨ÙŠØ±ÙŠØ© ğŸƒ"
  ]
  
  for text in multilingual_texts {
    let encoded = EncodingManager::encode_utf8(encoding_manager, text)
    let decoded = EncodingManager::decode_utf8(encoding_manager, encoded)
    assert_eq(decoded, text)
  }
  
  // æµ‹è¯•UTF-16ç¼–ç 
  let utf16_bytes = EncodingManager::encode_utf16(encoding_manager, utf8_text)
  let utf16_decoded = EncodingManager::decode_utf16(encoding_manager, utf16_bytes)
  assert_eq(utf16_decoded, utf8_text)
  
  // æµ‹è¯•UTF-32ç¼–ç 
  let utf32_bytes = EncodingManager::encode_utf32(encoding_manager, utf8_text)
  let utf32_decoded = EncodingManager::decode_utf32(encoding_manager, utf32_bytes)
  assert_eq(utf32_decoded, utf8_text)
  
  // æµ‹è¯•ASCIIç¼–ç ï¼ˆä»…é€‚ç”¨äºASCIIå­—ç¬¦ï¼‰
  let ascii_text = "Hello Azimuth"
  let ascii_bytes = EncodingManager::encode_ascii(encoding_manager, ascii_text)
  let ascii_decoded = EncodingManager::decode_ascii(encoding_manager, ascii_bytes)
  assert_eq(ascii_decoded, ascii_text)
  
  // æµ‹è¯•éASCIIå­—ç¬¦çš„ASCIIç¼–ç ï¼ˆåº”è¯¥å¤±è´¥æˆ–æ›¿æ¢ï¼‰
  let non_ascii_text = "Hello ä¸–ç•Œ"
  let ascii_encode_result = EncodingManager::encode_ascii_safe(encoding_manager, non_ascii_text)
  assert_true(ascii_encode_result.is_ok())
  
  let safe_ascii_bytes = ascii_encode_result.unwrap()
  let safe_ascii_decoded = EncodingManager::decode_ascii(encoding_manager, safe_ascii_bytes)
  assert_eq(safe_ascii_decoded, "Hello ??")  // éASCIIå­—ç¬¦è¢«æ›¿æ¢
  
  // æµ‹è¯•ç¼–ç æ£€æµ‹
  let test_bytes = EncodingManager::encode_utf8(encoding_manager, "Hello ä¸–ç•Œ")
  let detected_encoding = EncodingManager::detect_encoding(encoding_manager, test_bytes)
  assert_eq(detected_encoding, "utf-8")
  
  // æµ‹è¯•ç¼–ç è½¬æ¢
  let conversion_result = EncodingManager::convert_encoding(
    encoding_manager,
    test_bytes,
    "utf-8",
    "utf-16"
  )
  assert_true(conversion_result.is_ok())
  
  let converted_bytes = conversion_result.unwrap()
  let back_converted = EncodingManager::convert_encoding(
    encoding_manager,
    converted_bytes,
    "utf-16",
    "utf-8"
  )
  assert_true(back_converted.is_ok())
  
  let back_converted_bytes = back_converted.unwrap()
  let final_text = EncodingManager::decode_utf8(encoding_manager, back_converted_bytes)
  assert_eq(final_text, "Hello ä¸–ç•Œ")
  
  // æµ‹è¯•BOMï¼ˆå­—èŠ‚é¡ºåºæ ‡è®°ï¼‰å¤„ç†
  let utf8_with_bom = EncodingManager::add_bom_utf8(encoding_manager, test_bytes)
  let has_bom = EncodingManager::has_bom(encoding_manager, utf8_with_bom)
  assert_true(has_bom)
  
  let bom_removed = EncodingManager::remove_bom(encoding_manager, utf8_with_bom)
  let bom_removed_decoded = EncodingManager::decode_utf8(encoding_manager, bom_removed)
  assert_eq(bom_removed_decoded, "Hello ä¸–ç•Œ")
  
  // æµ‹è¯•Unicodeè§„èŒƒåŒ–
  let unicode_text = "cafÃ©"  // åŒ…å«ç»„åˆå­—ç¬¦
  let normalized_nfc = EncodingManager::normalize_unicode(encoding_manager, unicode_text, "NFC")
  let normalized_nfd = EncodingManager::normalize_unicode(encoding_manager, unicode_text, "NFD")
  
  // NFCå’ŒNFDåº”è¯¥çœ‹èµ·æ¥ä¸åŒä½†è¯­ä¹‰ç›¸åŒ
  assert_eq(normalized_nfc, "cafÃ©")
  assert_true(normalized_nfd.length() >= normalized_nfc.length())
  
  // æµ‹è¯•å¤§å°å†™è½¬æ¢ï¼ˆè€ƒè™‘è¯­è¨€ç‰¹å®šè§„åˆ™ï¼‰
  let case_tests = [
    ("hello", "en-US", "Hello"),
    ("hello", "tr-TR", "Hello"),  // åœŸè€³å…¶è¯­æœ‰ç‰¹æ®Šçš„å¤§å°å†™è§„åˆ™
    ("i", "tr-TR", "Ä°"),         // åœŸè€³å…¶è¯­çš„å°å†™iåˆ°å¤§å†™æ˜¯Ä°
    ("Ä°", "tr-TR", "i"),         // åœŸè€³å…¶è¯­çš„å¤§å†™Ä°åˆ°å°å†™æ˜¯i
    ("ÃŸ", "de-DE", "SS")          // å¾·è¯­çš„ÃŸåˆ°å¤§å†™æ˜¯SS
  ]
  
  for (text, locale, expected) in case_tests {
    let upper_result = EncodingManager::uppercase(encoding_manager, text, locale)
    assert_eq(upper_result, expected)
  }
  
  // æµ‹è¯•å­—ç¬¦ä¸²æ¯”è¾ƒï¼ˆè€ƒè™‘è¯­è¨€ç‰¹å®šè§„åˆ™ï¼‰
  let comparison_tests = [
    ("cafÃ©", "cafe", "en-US", false),   // åœ¨è‹±è¯­ä¸­ä¸åŒ
    ("cafÃ©", "cafe", "fr-FR", false),   // åœ¨æ³•è¯­ä¸­ä¹Ÿä¸åŒ
    ("Ã…", "A", "sv-SE", true),          // åœ¨ç‘å…¸è¯­ä¸­ç›¸åŒ
    ("ÃŸ", "ss", "de-DE", true)          // åœ¨å¾·è¯­ä¸­ç›¸åŒ
  ]
  
  for (text1, text2, locale, expected) in comparison_tests {
    let is_equal = EncodingManager::locale_compare(encoding_manager, text1, text2, locale)
    assert_eq(is_equal, expected)
  }
  
  // è·å–ç¼–ç ç»Ÿè®¡
  let encoding_stats = EncodingManager::get_statistics(encoding_manager)
  assert_true(encoding_stats.total_encodings > 0)
  assert_true(encoding_stats.total_decodings > 0)
  assert_true(encoding_stats.encoding_conversions > 0)
  assert_true(encoding_stats.avg_encoding_time_ms > 0)
}

// æµ‹è¯•3: æ—¥æœŸå’Œæ—¶é—´æœ¬åœ°åŒ–
test "æ—¥æœŸå’Œæ—¶é—´æœ¬åœ°åŒ–æµ‹è¯•" {
  // åˆ›å»ºæ—¥æœŸæ—¶é—´æœ¬åœ°åŒ–å™¨
  let datetime_localizer = DateTimeLocalizer::new()
  
  // å®šä¹‰æµ‹è¯•æ—¶é—´æˆ³
  let test_timestamp = 1640995200000  // 2022-01-01 00:00:00 UTC
  
  // æµ‹è¯•ä¸åŒæ—¶åŒº
  let timezones = [
    "UTC",           // åè°ƒä¸–ç•Œæ—¶
    "America/New_York",  // ç¾å›½ä¸œéƒ¨æ—¶é—´
    "America/Los_Angeles",  // ç¾å›½è¥¿éƒ¨æ—¶é—´
    "Europe/London",  // ä¼¦æ•¦æ—¶é—´
    "Europe/Paris",   // å·´é»æ—¶é—´
    "Asia/Tokyo",     // ä¸œäº¬æ—¶é—´
    "Asia/Shanghai",  // ä¸Šæµ·æ—¶é—´
    "Asia/Seoul",     // é¦–å°”æ—¶é—´
    "Australia/Sydney",  // æ‚‰å°¼æ—¶é—´
  ]
  
  // æµ‹è¯•æ—¶åŒºè½¬æ¢
  for timezone in timezones {
    let localized_time = DateTimeLocalizer::convert_timezone(datetime_localizer, test_timestamp, "UTC", timezone)
    assert_true(localized_time.year >= 2021 and localized_time.year <= 2022)
    assert_true(localized_time.month >= 1 and localized_time.month <= 12)
    assert_true(localized_time.day >= 1 and localized_time.day <= 31)
  }
  
  // æµ‹è¯•æ—¥æœŸæ ¼å¼åŒ–
  let date_formats = [
    ("en-US", "MM/DD/YYYY"),
    ("en-GB", "DD/MM/YYYY"),
    ("zh-CN", "YYYYå¹´MMæœˆDDæ—¥"),
    ("ja-JP", "YYYY/MM/DD"),
    ("de-DE", "DD.MM.YYYY"),
    ("fr-FR", "DD/MM/YYYY"),
    ("ko-KR", "YYYY. MM. DD."),
    ("ru-RU", "DD.MM.YYYY"),
    ("ar-SA", "DD/MM/YYYY")
  ]
  
  for (locale, format) in date_formats {
    let formatted_date = DateTimeLocalizer::format_date(datetime_localizer, test_timestamp, locale, format)
    assert_true(formatted_date.length() > 0)
    
    // éªŒè¯å¹´ä»½åœ¨æ ¼å¼åŒ–æ—¥æœŸä¸­
    assert_true(formatted_date.contains("2022"))
  }
  
  // æµ‹è¯•æ—¶é—´æ ¼å¼åŒ–
  let time_formats = [
    ("en-US", "h:mm:ss A"),
    ("en-GB", "HH:mm:ss"),
    ("zh-CN", "AHH:mm:ss"),
    ("ja-JP", "AHH:mm:ss"),
    ("de-DE", "HH:mm:ss"),
    ("fr-FR", "HH:mm:ss"),
    ("ko-KR", "A HH:mm:ss"),
    ("ru-RU", "H:mm:ss"),
    ("ar-SA", "H:mm:ss")
  ]
  
  for (locale, format) in time_formats {
    let formatted_time = DateTimeLocalizer::format_time(datetime_localizer, test_timestamp, locale, format)
    assert_true(formatted_time.length() > 0)
  }
  
  // æµ‹è¯•æ—¥æœŸæ—¶é—´ç»„åˆæ ¼å¼åŒ–
  let datetime_formats = [
    ("en-US", "MM/DD/YYYY h:mm:ss A"),
    ("zh-CN", "YYYYå¹´MMæœˆDDæ—¥ AHH:mm:ss"),
    ("ja-JP", "YYYY/MM/DD AHH:mm:ss"),
    ("de-DE", "DD.MM.YYYY HH:mm:ss"),
    ("ko-KR", "YYYY. MM. DD. A HH:mm:ss")
  ]
  
  for (locale, format) in datetime_formats {
    let formatted_datetime = DateTimeLocalizer::format_datetime(datetime_localizer, test_timestamp, locale, format)
    assert_true(formatted_datetime.length() > 0)
    assert_true(formatted_datetime.contains("2022"))
  }
  
  // æµ‹è¯•ç›¸å¯¹æ—¶é—´æ ¼å¼åŒ–
  let now_timestamp = test_timestamp
  let past_timestamp = test_timestamp - 3600000  // 1å°æ—¶å‰
  let future_timestamp = test_timestamp + 3600000  // 1å°æ—¶å
  
  // æµ‹è¯•è‹±è¯­ç›¸å¯¹æ—¶é—´
  let relative_past_en = DateTimeLocalizer::format_relative_time(datetime_localizer, past_timestamp, now_timestamp, "en-US")
  assert_eq(relative_past_en, "1 hour ago")
  
  let relative_future_en = DateTimeLocalizer::format_relative_time(datetime_localizer, future_timestamp, now_timestamp, "en-US")
  assert_eq(relative_future_en, "in 1 hour")
  
  // æµ‹è¯•ä¸­æ–‡ç›¸å¯¹æ—¶é—´
  let relative_past_zh = DateTimeLocalizer::format_relative_time(datetime_localizer, past_timestamp, now_timestamp, "zh-CN")
  assert_eq(relative_past_zh, "1å°æ—¶å‰")
  
  let relative_future_zh = DateTimeLocalizer::format_relative_time(datetime_localizer, future_timestamp, now_timestamp, "zh-CN")
  assert_eq(relative_future_zh, "1å°æ—¶å")
  
  // æµ‹è¯•æ—¥è¯­ç›¸å¯¹æ—¶é—´
  let relative_past_ja = DateTimeLocalizer::format_relative_time(datetime_localizer, past_timestamp, now_timestamp, "ja-JP")
  assert_eq(relative_past_ja, "1æ™‚é–“å‰")
  
  // æµ‹è¯•éŸ©è¯­ç›¸å¯¹æ—¶é—´
  let relative_past_ko = DateTimeLocalizer::format_relative_time(datetime_localizer, past_timestamp, now_timestamp, "ko-KR")
  assert_eq(relative_past_ko, "1ì‹œê°„ ì „")
  
  // æµ‹è¯•æœˆä»½å’Œæ˜ŸæœŸåç§°æœ¬åœ°åŒ–
  let month_names_en = DateTimeLocalizer::get_month_names(datetime_localizer, "en-US")
  assert_eq(month_names_en[0], "January")
  assert_eq(month_names_en[6], "July")
  assert_eq(month_names_en[11], "December")
  
  let month_names_zh = DateTimeLocalizer::get_month_names(datetime_localizer, "zh-CN")
  assert_eq(month_names_zh[0], "ä¸€æœˆ")
  assert_eq(month_names_zh[6], "ä¸ƒæœˆ")
  assert_eq(month_names_zh[11], "åäºŒæœˆ")
  
  let weekday_names_en = DateTimeLocalizer::get_weekday_names(datetime_localizer, "en-US")
  assert_eq(weekday_names_en[0], "Sunday")
  assert_eq(weekday_names_en[6], "Saturday")
  
  let weekday_names_zh = DateTimeLocalizer::get_weekday_names(datetime_localizer, "zh-CN")
  assert_eq(weekday_names_zh[0], "æ˜ŸæœŸæ—¥")
  assert_eq(weekday_names_zh[6], "æ˜ŸæœŸå…­")
  
  // æµ‹è¯•æ—¥å†ç³»ç»Ÿ
  let calendar_tests = [
    ("en-US", "gregorian"),
    ("zh-CN", "gregorian"),
    ("ja-JP", "gregorian"),
    ("ar-SA", "gregorian"),
    ("th-TH", "buddhist")  // æ³°å›½ä½¿ç”¨ä½›å†
  ]
  
  for (locale, expected_calendar) in calendar_tests {
    let calendar = DateTimeLocalizer::get_calendar_system(datetime_localizer, locale)
    assert_eq(calendar, expected_calendar)
  }
  
  // æµ‹è¯•ä½›å†å¹´ä»½
  let buddhist_year = DateTimeLocalizer::get_year_in_calendar(datetime_localizer, test_timestamp, "th-TH")
  assert_eq(buddhist_year, 2022 + 543)  // ä½›å† = å…¬å† + 543
  
  // æµ‹è¯•æ•°å­—å’Œæ—¥æœŸæœ¬åœ°åŒ–
  let number_localizer = NumberLocalizer::new()
  
  // æµ‹è¯•æ•°å­—æ ¼å¼åŒ–
  let number_tests = [
    (1234.567, "en-US", "1,234.567"),
    (1234.567, "de-DE", "1.234,567"),
    (1234.567, "fr-FR", "1 234,567"),
    (1234.567, "zh-CN", "1,234.567"),
    (1234.567, "ja-JP", "1,234.567")
  ]
  
  for (number, locale, expected) in number_tests {
    let formatted_number = NumberLocalizer::format_number(number_localizer, number, locale)
    assert_eq(formatted_number, expected)
  }
  
  // æµ‹è¯•è´§å¸æ ¼å¼åŒ–
  let currency_tests = [
    (1234.56, "en-US", "USD", "$1,234.56"),
    (1234.56, "de-DE", "EUR", "1.234,56 â‚¬"),
    (1234.56, "fr-FR", "EUR", "1 234,56 â‚¬"),
    (1234.56, "ja-JP", "JPY", "ï¿¥1,235"),
    (1234.56, "zh-CN", "CNY", "Â¥1,234.56")
  ]
  
  for (amount, locale, currency, expected) in currency_tests {
    let formatted_currency = NumberLocalizer::format_currency(number_localizer, amount, locale, currency)
    assert_eq(formatted_currency, expected)
  }
  
  // è·å–æ—¥æœŸæ—¶é—´æœ¬åœ°åŒ–ç»Ÿè®¡
  let datetime_stats = DateTimeLocalizer::get_statistics(datetime_localizer)
  assert_true(datetime_stats.total_formatting_operations > 0)
  assert_true(datetime_stats.total_timezone_conversions > 0)
  assert_true(datetime_stats.total_relative_time_formats > 0)
  assert_true(datetime_stats.avg_formatting_time_ms > 0)
}

// æµ‹è¯•4: æ–‡åŒ–é€‚é…å’Œæœ¬åœ°åŒ–è§„åˆ™
test "æ–‡åŒ–é€‚é…å’Œæœ¬åœ°åŒ–è§„åˆ™æµ‹è¯•" {
  // åˆ›å»ºæ–‡åŒ–é€‚é…ç®¡ç†å™¨
  let culture_adapter = CultureAdapter::new()
  
  // å®šä¹‰æ–‡åŒ–è§„åˆ™
  let culture_rules = {
    "en-US": {
      date_format: "MM/DD/YYYY",
      time_format: "h:mm A",
      number_format: {
        decimal_separator: ".",
        thousands_separator: ",",
        currency_symbol: "$",
        currency_position: "prefix"
      },
      address_format: "{street}\n{city}, {state} {zipcode}",
      name_format: "{given_name} {family_name}",
      reading_direction: "ltr",
      weekend_days: [6, 0]  // å‘¨å…­ã€å‘¨æ—¥
      first_day_of_week: 0   // å‘¨æ—¥
    },
    "zh-CN": {
      date_format: "YYYYå¹´MMæœˆDDæ—¥",
      time_format: "AHH:mm",
      number_format: {
        decimal_separator: ".",
        thousands_separator: ",",
        currency_symbol: "Â¥",
        currency_position: "prefix"
      },
      address_format: "{zipcode} {state}{city}{street}",
      name_format: "{family_name}{given_name}",
      reading_direction: "ltr",
      weekend_days: [5, 6],  // å‘¨å…­ã€å‘¨æ—¥
      first_day_of_week: 1    // å‘¨ä¸€
    },
    "ja-JP": {
      date_format: "YYYY/MM/DD",
      time_format: "AHH:mm",
      number_format: {
        decimal_separator: ".",
        thousands_separator: ",",
        currency_symbol: "ï¿¥",
        currency_position: "prefix"
      },
      address_format: "ã€’{zipcode}\n{state}{city}{street}",
      name_format: "{family_name} {given_name}",
      reading_direction: "ltr",
      weekend_days: [5, 6],  // å‘¨å…­ã€å‘¨æ—¥
      first_day_of_week: 0    // å‘¨æ—¥
    },
    "ar-SA": {
      date_format: "DD/MM/YYYY",
      time_format: "H:mm",
      number_format: {
        decimal_separator: ".",
        thousands_separator: ",",
        currency_symbol: "Ø±.Ø³",
        currency_position: "suffix"
      },
      address_format: "{street}\n{city} {zipcode}\n{state}",
      name_format: "{given_name} {family_name}",
      reading_direction: "rtl",
      weekend_days: [4, 5],  // å‘¨äº”ã€å‘¨å…­
      first_day_of_week: 6    // å‘¨å…­
    },
    "de-DE": {
      date_format: "DD.MM.YYYY",
      time_format: "HH:mm",
      number_format: {
        decimal_separator: ",",
        thousands_separator: ".",
        currency_symbol: "â‚¬",
        currency_position: "suffix"
      },
      address_format: "{street}\n{zipcode} {city}\n{state}",
      name_format: "{given_name} {family_name}",
      reading_direction: "ltr",
      weekend_days: [5, 6],  // å‘¨å…­ã€å‘¨æ—¥
      first_day_of_week: 1    // å‘¨ä¸€
    }
  }
  
  // åŠ è½½æ–‡åŒ–è§„åˆ™
  for (locale, rules) in culture_rules.entries() {
    CultureAdapter::load_culture_rules(culture_adapter, locale, rules)
  }
  
  // æµ‹è¯•åœ°å€æ ¼å¼åŒ–
  let address_data = {
    street: "123 Main St",
    city: "New York",
    state: "NY",
    zipcode: "10001"
  }
  
  // æµ‹è¯•è‹±è¯­åœ°å€æ ¼å¼
  let address_en = CultureAdapter::format_address(culture_adapter, "en-US", address_data)
  assert_eq(address_en, "123 Main St\nNew York, NY 10001")
  
  // æµ‹è¯•ä¸­æ–‡åœ°å€æ ¼å¼
  let address_zh = CultureAdapter::format_address(culture_adapter, "zh-CN", address_data)
  assert_eq(address_zh, "10001 NYNew York123 Main St")
  
  // æµ‹è¯•æ—¥è¯­åœ°å€æ ¼å¼
  let address_ja = CultureAdapter::format_address(culture_adapter, "ja-JP", address_data)
  assert_eq(address_ja, "ã€’10001\nNYNew York123 Main St")
  
  // æµ‹è¯•é˜¿æ‹‰ä¼¯è¯­åœ°å€æ ¼å¼
  let address_ar = CultureAdapter::format_address(culture_adapter, "ar-SA", address_data)
  assert_eq(address_ar, "123 Main St\nNew York 10001\nNY")
  
  // æµ‹è¯•å§“åæ ¼å¼åŒ–
  let name_data = {
    given_name: "John",
    family_name: "Doe"
  }
  
  // æµ‹è¯•è‹±è¯­å§“åæ ¼å¼
  let name_en = CultureAdapter::format_name(culture_adapter, "en-US", name_data)
  assert_eq(name_en, "John Doe")
  
  // æµ‹è¯•ä¸­æ–‡å§“åæ ¼å¼
  let name_zh = CultureAdapter::format_name(culture_adapter, "zh-CN", name_data)
  assert_eq(name_zh, "DoeJohn")
  
  // æµ‹è¯•æ—¥è¯­å§“åæ ¼å¼
  let name_ja = CultureAdapter::format_name(culture_adapter, "ja-JP", name_data)
  assert_eq(name_ja, "Doe John")
  
  // æµ‹è¯•è´§å¸ä½ç½®
  let currency_tests = [
    ("en-US", 1234.56, "$1,234.56"),
    ("de-DE", 1234.56, "1.234,56 â‚¬"),
    ("ar-SA", 1234.56, "1,234.56 Ø±.Ø³")
  ]
  
  for (locale, amount, expected) in currency_tests {
    let formatted_currency = CultureAdapter::format_currency(culture_adapter, locale, amount)
    assert_eq(formatted_currency, expected)
  }
  
  // æµ‹è¯•æ•°å­—æ ¼å¼
  let number_tests = [
    ("en-US", 1234567.89, "1,234,567.89"),
    ("de-DE", 1234567.89, "1.234.567,89"),
    ("zh-CN", 1234567.89, "1,234,567.89")
  ]
  
  for (locale, number, expected) in number_tests {
    let formatted_number = CultureAdapter::format_number(culture_adapter, locale, number)
    assert_eq(formatted_number, expected)
  }
  
  // æµ‹è¯•å‘¨æœ«å’Œå·¥ä½œæ—¥åˆ¤æ–­
  let weekend_tests = [
    ("en-US", 6, true),   // å‘¨å…­æ˜¯å‘¨æœ«
    ("en-US", 0, true),   // å‘¨æ—¥æ˜¯å‘¨æœ«
    ("en-US", 3, false),  // å‘¨ä¸‰ä¸æ˜¯å‘¨æœ«
    ("zh-CN", 5, true),   // å‘¨å…­æ˜¯å‘¨æœ«
    ("zh-CN", 6, true),   // å‘¨æ—¥æ˜¯å‘¨æœ«
    ("zh-CN", 3, false),  // å‘¨ä¸‰ä¸æ˜¯å‘¨æœ«
    ("ar-SA", 4, true),   // å‘¨äº”æ˜¯å‘¨æœ«
    ("ar-SA", 5, true),   // å‘¨å…­æ˜¯å‘¨æœ«
    ("ar-SA", 3, false)   // å‘¨ä¸‰ä¸æ˜¯å‘¨æœ«
  ]
  
  for (locale, day, expected) in weekend_tests {
    let is_weekend = CultureAdapter::is_weekend(culture_adapter, locale, day)
    assert_eq(is_weekend, expected)
  }
  
  // æµ‹è¯•å·¥ä½œæ—¥åˆ¤æ–­
  let workday_tests = [
    ("en-US", 1, true),   // å‘¨ä¸€æ˜¯å·¥ä½œæ—¥
    ("en-US", 6, false),  // å‘¨å…­ä¸æ˜¯å·¥ä½œæ—¥
    ("zh-CN", 1, true),   // å‘¨ä¸€æ˜¯å·¥ä½œæ—¥
    ("zh-CN", 6, false),  // å‘¨å…­ä¸æ˜¯å·¥ä½œæ—¥
    ("ar-SA", 1, true),   // å‘¨ä¸€æ˜¯å·¥ä½œæ—¥
    ("ar-SA", 5, false)   // å‘¨äº”ä¸æ˜¯å·¥ä½œæ—¥
  ]
  
  for (locale, day, expected) in workday_tests {
    let is_workday = CultureAdapter::is_workday(culture_adapter, locale, day)
    assert_eq(is_workday, expected)
  }
  
  // æµ‹è¯•é˜…è¯»æ–¹å‘
  let direction_tests = [
    ("en-US", "ltr"),
    ("zh-CN", "ltr"),
    ("ja-JP", "ltr"),
    ("ar-SA", "rtl"),
    ("he-IL", "rtl")
  ]
  
  for (locale, expected) in direction_tests {
    let direction = CultureAdapter::get_reading_direction(culture_adapter, locale)
    assert_eq(direction, expected)
  }
  
  // æµ‹è¯•æ–‡æœ¬å¯¹é½
  let alignment_tests = [
    ("en-US", "left"),
    ("zh-CN", "left"),
    ("ja-JP", "left"),
    ("ar-SA", "right"),
    ("he-IL", "right")
  ]
  
  for (locale, expected) in alignment_tests {
    let alignment = CultureAdapter::get_text_alignment(culture_adapter, locale)
    assert_eq(alignment, expected)
  }
  
  // æµ‹è¯•æ–‡åŒ–ç‰¹å®šæ’åº
  let sorting_tests = [
    (["apple", "banana", "cherry"], "en-US"),
    (["è‹¹æœ", "é¦™è•‰", "æ¨±æ¡ƒ"], "zh-CN"),
    (["ã‚Šã‚“ã”", "ã°ãªãª", "ã•ãã‚‰ã‚“ã¼"], "ja-JP")
  ]
  
  for (items, locale) in sorting_tests {
    let sorted = CultureAdapter::sort_strings(culture_adapter, items, locale)
    assert_eq(sorted.length(), items.length())
    
    // éªŒè¯æ’åºæ˜¯å¦æ­£ç¡®ï¼ˆå…·ä½“é¡ºåºå–å†³äºè¯­è¨€çš„æ’åºè§„åˆ™ï¼‰
    for i in 0..=sorted.length() - 2 {
      assert_true(CultureAdapter::compare_strings(culture_adapter, sorted[i], sorted[i + 1], locale) <= 0)
    }
  }
  
  // æµ‹è¯•æ–‡åŒ–ç‰¹å®šæœç´¢
  let search_tests = [
    ("cafÃ©", "cafe", "en-US", false),  // åœ¨è‹±è¯­ä¸­ä¸åŒ
    ("cafÃ©", "cafe", "fr-FR", false),  // åœ¨æ³•è¯­ä¸­ä¹Ÿä¸åŒ
    ("Ã…", "A", "sv-SE", true),         // åœ¨ç‘å…¸è¯­ä¸­ç›¸åŒ
    ("ÃŸ", "ss", "de-DE", true)         // åœ¨å¾·è¯­ä¸­ç›¸åŒ
  ]
  
  for (text, pattern, locale, expected) in search_tests {
    let matches = CultureAdapter::locale_search(culture_adapter, text, pattern, locale)
    assert_eq(matches, expected)
  }
  
  // è·å–æ–‡åŒ–é€‚é…ç»Ÿè®¡
  let culture_stats = CultureAdapter::get_statistics(culture_adapter)
  assert_true(culture_stats.total_formatting_operations > 0)
  assert_true(culture_stats.total_validations > 0)
  assert_true(culture_stats.total_sorting_operations > 0)
  assert_true(culture_stats.avg_formatting_time_ms > 0)
}

// æµ‹è¯•5: å›½é™…åŒ–æ€§èƒ½å’Œä¼˜åŒ–
test "å›½é™…åŒ–æ€§èƒ½å’Œä¼˜åŒ–æµ‹è¯•" {
  // åˆ›å»ºå›½é™…åŒ–æ€§èƒ½æµ‹è¯•å™¨
  let i18n_performance = I18nPerformance::new()
  
  // é…ç½®æ€§èƒ½æµ‹è¯•å‚æ•°
  I18nPerformance::configure(i18n_performance, {
    test_iterations: 10000,
    concurrent_threads: 4,
    memory_tracking: true,
    cache_analysis: true
  })
  
  // åˆ›å»ºå›½é™…åŒ–ç®¡ç†å™¨
  let i18n_manager = I18nManager::new()
  
  // æ³¨å†Œå¤§é‡è¯­è¨€
  let large_locale_list = []
  for i in 0..=50 {
    large_locale_list.push("test-locale-" + i.to_string())
  }
  
  for locale in large_locale_list {
    I18nManager::register_locale(i18n_manager, locale)
  }
  
  // åŠ è½½å¤§é‡èµ„æº
  let large_resources = {}
  for locale in large_locale_list {
    let locale_resources = {}
    for j in 0..=100 {
      locale_resources["key_" + j.to_string()] = "value_" + j.to_string() + "_in_" + locale
    }
    large_resources[locale] = locale_resources
  }
  
  for (locale, resources) in large_resources.entries() {
    I18nManager::load_resources(i18n_manager, locale, resources)
  }
  
  // æµ‹è¯•ç¿»è¯‘æ€§èƒ½
  let translation_start = Time::now()
  
  for i in 0..=10000 {
    let locale = large_locale_list[i % large_locale_list.length()]
    let key = "key_" + (i % 100).to_string()
    I18nManager::set_locale(i18n_manager, locale)
    I18nManager::translate(i18n_manager, key)
  }
  
  let translation_end = Time::now()
  let translation_time = translation_end - translation_start
  
  // éªŒè¯ç¿»è¯‘æ€§èƒ½
  assert_true(translation_time < 5000)  // 10000æ¬¡ç¿»è¯‘åº”åœ¨5ç§’å†…å®Œæˆ
  
  // æµ‹è¯•å‚æ•°åŒ–ç¿»è¯‘æ€§èƒ½
  let param_translation_start = Time::now()
  
  for i in 0..=5000 {
    let locale = large_locale_list[i % large_locale_list.length()]
    let key = "key_" + (i % 100).to_string()
    let params = [("param1", "value1"), ("param2", "value2")]
    I18nManager::set_locale(i18n_manager, locale)
    I18nManager::translate_with_params(i18n_manager, key, params)
  }
  
  let param_translation_end = Time::now()
  let param_translation_time = param_translation_end - param_translation_start
  
  // éªŒè¯å‚æ•°åŒ–ç¿»è¯‘æ€§èƒ½
  assert_true(param_translation_time < 3000)  // 5000æ¬¡å‚æ•°åŒ–ç¿»è¯‘åº”åœ¨3ç§’å†…å®Œæˆ
  
  // æµ‹è¯•ç¼“å­˜æ•ˆæœ
  let cache_test_start = Time::now()
  
  // ç¬¬ä¸€æ¬¡ç¿»è¯‘ï¼ˆç¼“å­˜æœªå‘½ä¸­ï¼‰
  I18nManager::set_locale(i18n_manager, "test-locale-0")
  let first_translation = I18nManager::translate(i18n_manager, "key_0")
  
  // ç¬¬äºŒæ¬¡ç›¸åŒç¿»è¯‘ï¼ˆç¼“å­˜å‘½ä¸­ï¼‰
  let second_translation = I18nManager::translate(i18n_manager, "key_0")
  
  let cache_test_end = Time::now()
  let cache_test_time = cache_test_end - cache_test_start
  
  // éªŒè¯ç¼“å­˜æ•ˆæœ
  assert_eq(first_translation, second_translation)
  assert_true(cache_test_time < 10)  // ç¼“å­˜å‘½ä¸­åº”è¯¥éå¸¸å¿«
  
  // æµ‹è¯•å†…å­˜ä½¿ç”¨
  let memory_before = I18nPerformance::get_memory_usage(i18n_performance)
  
  // æ‰§è¡Œå¤§é‡æ“ä½œ
  for i in 0..=1000 {
    let locale = large_locale_list[i % large_locale_list.length()]
    I18nManager::set_locale(i18n_manager, locale)
    
    for j in 0..=100 {
      let key = "key_" + j.to_string()
      I18nManager::translate(i18n_manager, key)
    }
  }
  
  let memory_after = I18nPerformance::get_memory_usage(i18n_performance)
  
  // éªŒè¯å†…å­˜ä½¿ç”¨åˆç†
  assert_true(memory_after.heap_used_mb > memory_before.heap_used_mb)
  assert_true(memory_after.heap_used_mb < memory_before.heap_used_mb + 100)  // å†…å­˜å¢é•¿åº”å°äº100MB
  
  // æµ‹è¯•å¹¶å‘æ€§èƒ½
  let concurrent_start = Time::now()
  
  let concurrent_tasks = []
  for thread_id in 0..=4 {
    let task = fn() {
      for i in 0..=2000 {
        let locale = large_locale_list[i % large_locale_list.length()]
        let key = "key_" + (i % 100).to_string()
        I18nManager::set_locale(i18n_manager, locale)
        I18nManager::translate(i18n_manager, key)
      }
      thread_id
    }
    concurrent_tasks.push(task)
  }
  
  // æ‰§è¡Œå¹¶å‘ä»»åŠ¡
  let concurrent_results = []
  for task in concurrent_tasks {
    let result = task()
    concurrent_results.push(result)
  }
  
  let concurrent_end = Time::now()
  let concurrent_time = concurrent_end - concurrent_start
  
  // éªŒè¯å¹¶å‘æ€§èƒ½
  assert_eq(concurrent_results.length(), 5)
  assert_true(concurrent_time < 3000)  // å¹¶å‘æ‰§è¡Œåº”è¯¥æ›´å¿«
  
  // æµ‹è¯•èµ„æºé¢„åŠ è½½æ€§èƒ½
  let preload_start = Time::now()
  
  I18nManager::preload_resources(i18n_manager, large_locale_list)
  
  let preload_end = Time::now()
  let preload_time = preload_end - preload_start
  
  // éªŒè¯é¢„åŠ è½½æ€§èƒ½
  assert_true(preload_time < 1000)  // é¢„åŠ è½½åº”åœ¨1ç§’å†…å®Œæˆ
  
  // æµ‹è¯•çƒ­åˆ‡æ¢æ€§èƒ½
  let hot_swap_start = Time::now()
  
  for i in 0..=1000 {
    let locale = large_locale_list[i % large_locale_list.length()]
    I18nManager::set_locale(i18n_manager, locale)
  }
  
  let hot_swap_end = Time::now()
  let hot_swap_time = hot_swap_end - hot_swap_start
  
  // éªŒè¯çƒ­åˆ‡æ¢æ€§èƒ½
  assert_true(hot_swap_time < 500)  // 1000æ¬¡è¯­è¨€åˆ‡æ¢åº”åœ¨500mså†…å®Œæˆ
  
  // æµ‹è¯•èµ„æºå‹ç¼©æ•ˆæœ
  let original_size = I18nPerformance::calculate_resource_size(i18n_performance, large_resources)
  
  I18nManager::enable_compression(i18n_manager, true)
  let compressed_size = I18nPerformance::get_compressed_size(i18n_performance)
  
  // éªŒè¯å‹ç¼©æ•ˆæœ
  assert_true(compressed_size < original_size)
  let compression_ratio = compressed_size.to_float() / original_size.to_float()
  assert_true(compression_ratio < 0.8)  // å‹ç¼©ç‡åº”è‡³å°‘è¾¾åˆ°20%
  
  // è·å–æ€§èƒ½æŠ¥å‘Š
  let performance_report = I18nPerformance::generate_report(i18n_performance, {
    include_translation_metrics: true,
    include_memory_metrics: true,
    include_cache_metrics: true,
    include_recommendations: true
  })
  
  // éªŒè¯æ€§èƒ½æŠ¥å‘Š
  assert_true(performance_report.translation_metrics.total_translations > 0)
  assert_true(performance_report.translation_metrics.avg_translation_time_ms > 0)
  assert_true(performance_report.memory_metrics.peak_heap_used_mb > 0)
  assert_true(performance_report.cache_metrics.cache_hit_rate > 0)
  assert_true(performance_report.recommendations.length() > 0)
}