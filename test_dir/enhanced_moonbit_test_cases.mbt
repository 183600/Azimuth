// å¢å¼ºçš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¿™äº›æµ‹è¯•ç”¨ä¾‹ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•ï¼Œè¦†ç›– azimuth æ¨¡å—çš„æ ¸å¿ƒåŠŸèƒ½

// å¯¼å…¥ä¸»æ¨¡å—ä¸­çš„å‡½æ•°
use azimuth

test "divide_with_ceil_basic_functionality" {
  // æµ‹è¯•åŸºæœ¬çš„å‘ä¸Šå–æ•´é™¤æ³•åŠŸèƒ½
  assert_eq(3, divide_with_ceil(10, 3))
  assert_eq(4, divide_with_ceil(11, 3))
  assert_eq(5, divide_with_ceil(15, 3))
  assert_eq(2, divide_with_ceil(4, 2))
  assert_eq(1, divide_with_ceil(1, 1))
}

test "divide_with_ceil_edge_cases" {
  // æµ‹è¯•å‘ä¸Šå–æ•´é™¤æ³•çš„è¾¹ç•Œæƒ…å†µ
  assert_eq(0, divide_with_ceil(0, 5))
  assert_eq(1, divide_with_ceil(1, 5))
  assert_eq(5, divide_with_ceil(25, 5))
  assert_eq(6, divide_with_ceil(26, 5))
  
  // æµ‹è¯•è´Ÿæ•°æƒ…å†µ
  assert_eq(-2, divide_with_ceil(-10, 5))
  assert_eq(-1, divide_with_ceil(-1, 5))
}

test "complex_arithmetic_combinations" {
  // æµ‹è¯•å¤æ‚çš„ç®—æœ¯ç»„åˆ
  let a = 12
  let b = 8
  let c = 5
  
  // (a + b) * c - (a - b)
  let result = add(multiply(add(a, b), c), add(a, -b))
  assert_eq(92, result)
  
  // a * b + b * c - a * c
  let result2 = add(add(multiply(a, b), multiply(b, c)), multiply(-a, c))
  assert_eq(76, result2)
}

test "string_processing_advanced" {
  // æµ‹è¯•é«˜çº§å­—ç¬¦ä¸²å¤„ç†
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()"
  assert_eq_string("Hello, !@#$%^&*()!", greet(special_chars))
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_chars = "ğŸŒŸâœ¨ğŸ‰ğŸš€"
  assert_eq_string("Hello, ğŸŒŸâœ¨ğŸ‰ğŸš€!", greet(unicode_chars))
  
  // æµ‹è¯•åŒ…å«å¤šç§è¯­è¨€çš„å­—ç¬¦ä¸²
  let multilingual = "Helloä¸–ç•Œã“ã‚“ã«ã¡ã¯ì•ˆë…•í•˜ì„¸ìš”"
  assert_eq_string("Hello, Helloä¸–ç•Œã“ã‚“ã«ã¡ã¯ì•ˆë…•í•˜ì„¸ìš”!", greet(multilingual))
}

test "mathematical_series_and_sequences" {
  // æµ‹è¯•æ•°å­¦çº§æ•°å’Œåºåˆ—
  // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å‰å‡ é¡¹å’Œï¼š1, 1, 2, 3, 5, 8
  let fib1 = 1
  let fib2 = 1
  let fib3 = add(fib1, fib2)  // 2
  let fib4 = add(fib2, fib3)  // 3
  let fib5 = add(fib3, fib4)  // 5
  let fib6 = add(fib4, fib5)  // 8
  
  let sum_fib = add(add(add(add(add(fib1, fib2), fib3), fib4), fib5), fib6)
  assert_eq(20, sum_fib)
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„å’Œï¼š2 + 4 + 8 + 16 = 30
  let geo1 = 2
  let geo2 = multiply(geo1, 2)  // 4
  let geo3 = multiply(geo2, 2)  // 8
  let geo4 = multiply(geo3, 2)  // 16
  
  let sum_geo = add(add(add(geo1, geo2), geo3), geo4)
  assert_eq(30, sum_geo)
}

test "real_world_financial_calculations" {
  // æµ‹è¯•å®é™…é‡‘èè®¡ç®—åœºæ™¯
  // è®¡ç®—è´·æ¬¾æœˆä¾›ï¼ˆç®€åŒ–ç‰ˆï¼‰ï¼šæœ¬é‡‘ / æœŸæ•° + åˆ©æ¯
  let principal = 12000
  let months = 12
  let monthly_rate = 1  // 1%
  
  let monthly_principal = principal / months
  let first_month_interest = multiply(principal, monthly_rate) / 100
  let first_month_payment = add(monthly_principal, first_month_interest)
  
  assert_eq(1100, first_month_payment)
  
  // è®¡ç®—å¤åˆ©ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let initial = 1000
  let rate = 5
  let years = 3
  
  let yearly_growth = multiply(initial, rate) / 100
  let total = add(initial, multiply(yearly_growth, years))
  assert_eq(1150, total)
}

test "geometry_calculations" {
  // æµ‹è¯•å‡ ä½•è®¡ç®—
  // è®¡ç®—ç›´è§’ä¸‰è§’å½¢çš„æ–œè¾¹ï¼ˆå‹¾è‚¡å®šç†ç®€åŒ–ç‰ˆï¼‰
  let base = 3
  let height = 4
  
  // cÂ² = aÂ² + bÂ²
  let base_squared = multiply(base, base)
  let height_squared = multiply(height, height)
  let hypotenuse_squared = add(base_squared, height_squared)
  
  // ç®€åŒ–è®¡ç®—ï¼šâˆš25 â‰ˆ 5
  assert_eq(25, hypotenuse_squared)
  
  // è®¡ç®—æ¢¯å½¢é¢ç§¯ï¼š(ä¸Šåº• + ä¸‹åº•) Ã— é«˜ Ã· 2
  let top_base = 6
  let bottom_base = 10
  let trapezoid_height = 4
  
  let area = multiply(add(top_base, bottom_base), trapezoid_height) / 2
  assert_eq(32, area)
}

test "algorithmic_problem_solving" {
  // æµ‹è¯•ç®—æ³•é—®é¢˜æ±‚è§£
  // è®¡ç®—æœ€å¤§å…¬çº¦æ•°ï¼ˆæ¬§å‡ é‡Œå¾—ç®—æ³•ç®€åŒ–ç‰ˆï¼‰
  let a = 48
  let b = 18
  
  // ç®€åŒ–çš„GCDè®¡ç®—ï¼šé€šè¿‡è¿ç»­å‡æ³•
  let diff = add(a, -b)  // 30
  let diff2 = add(diff, -b)  // 12
  let diff3 = add(b, -diff2)  // 6
  let diff4 = add(diff2, multiply(-2, diff3))  // 0
  
  // å½“ä½™æ•°ä¸º0æ—¶ï¼Œé™¤æ•°å°±æ˜¯GCD
  assert_eq(6, diff3)
  
  // è®¡ç®—æœ€å°å…¬å€æ•°ï¼šLCM(a,b) = |a Ã— b| / GCD(a,b)
  let lcm = multiply(a, b) / diff3
  assert_eq(144, lcm)
}

test "data_structure_operations_simulation" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špush, push, pop, push
  let stack_size = 0
  
  // push 10
  stack_size = add(stack_size, 1)
  // push 20
  stack_size = add(stack_size, 1)
  // pop
  stack_size = add(stack_size, -1)
  // push 30
  stack_size = add(stack_size, 1)
  
  assert_eq(2, stack_size)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼šenqueue, enqueue, dequeue, enqueue
  let queue_front = 0
  let queue_rear = 0
  
  // enqueue 10
  queue_rear = add(queue_rear, 1)
  // enqueue 20
  queue_rear = add(queue_rear, 1)
  // dequeue
  queue_front = add(queue_front, 1)
  // enqueue 30
  queue_rear = add(queue_rear, 1)
  
  let queue_size = add(queue_rear, -queue_front)
  assert_eq(2, queue_size)
}

test "comprehensive_boundary_testing" {
  // ç»¼åˆè¾¹ç•Œå€¼æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•åŠ æ³•çš„å„ç§è¾¹ç•Œç»„åˆ
  assert_eq(max_val, add(max_val, 0))
  assert_eq(max_val, add(0, max_val))
  assert_eq(max_val, add(max_val, 1))
  assert_eq(max_val, add(1, max_val))
  
  assert_eq(min_val, add(min_val, 0))
  assert_eq(min_val, add(0, min_val))
  assert_eq(min_val, add(min_val, -1))
  assert_eq(min_val, add(-1, min_val))
  
  assert_eq(-1, add(max_val, min_val))
  assert_eq(-1, add(min_val, max_val))
  
  // æµ‹è¯•ä¹˜æ³•çš„å„ç§è¾¹ç•Œç»„åˆ
  assert_eq(0, multiply(max_val, 0))
  assert_eq(0, multiply(0, max_val))
  assert_eq(0, multiply(min_val, 0))
  assert_eq(0, multiply(0, min_val))
  
  assert_eq(max_val, multiply(max_val, 1))
  assert_eq(max_val, multiply(1, max_val))
  assert_eq(min_val, multiply(min_val, 1))
  assert_eq(min_val, multiply(1, min_val))
  
  assert_eq(min_val, multiply(min_val, -1))
  assert_eq(min_val, multiply(-1, min_val))
  assert_eq(min_val, multiply(max_val, -1))
  assert_eq(min_val, multiply(-1, max_val))
  
  // æµ‹è¯•å¤æ‚çš„è¾¹ç•Œè¿ç®—ç»„åˆ
  let complex_boundary = add(multiply(add(max_val, min_val), 1), max_val)
  assert_eq(max_val, complex_boundary)
}