// å¢å¼ºçš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¿™äº›æµ‹è¯•ç”¨ä¾‹æ¶µç›–äº†æ›´å¤šå®é™…åº”ç”¨åœºæ™¯å’Œå¤æ‚çš„è®¡ç®—é€»è¾‘

// å¯¼å…¥ä¸»æ¨¡å—ä¸­çš„å‡½æ•°
use azimuth

test "prime_number_calculation" {
  // è´¨æ•°æ£€æµ‹ç›¸å…³çš„è®¡ç®—
  // æ£€æŸ¥ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºè´¨æ•°çš„ç®€å•ç®—æ³•ï¼ˆä½¿ç”¨è¯•é™¤æ³•ï¼‰
  let num = 17
  
  // æ£€æŸ¥17æ˜¯å¦èƒ½è¢«2åˆ°4ä¹‹é—´çš„æ•°æ•´é™¤
  let divisible_by_2 = num % 2 == 0
  let divisible_by_3 = num % 3 == 0
  let divisible_by_4 = num % 4 == 0
  
  // 17æ˜¯è´¨æ•°ï¼Œæ‰€ä»¥ä¸åº”è¯¥è¢«è¿™äº›æ•°æ•´é™¤
  assert_false(divisible_by_2)
  assert_false(divisible_by_3)
  assert_false(divisible_by_4)
  
  // æµ‹è¯•éè´¨æ•°
  let non_prime = 15
  let divisible_by_3_15 = non_prime % 3 == 0
  let divisible_by_5_15 = non_prime % 5 == 0
  
  assert_true(divisible_by_3_15)
  assert_true(divisible_by_5_15)
}

test "fibonacci_sequence" {
  // æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
  // F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)
  
  let f0 = 0
  let f1 = 1
  let f2 = add(f1, f0)  // 1
  let f3 = add(f2, f1)  // 2
  let f4 = add(f3, f2)  // 3
  let f5 = add(f4, f3)  // 5
  let f6 = add(f5, f4)  // 8
  let f7 = add(f6, f5)  // 13
  let f8 = add(f7, f6)  // 21
  let f9 = add(f8, f7)  // 34
  
  assert_eq(0, f0)
  assert_eq(1, f1)
  assert_eq(1, f2)
  assert_eq(2, f3)
  assert_eq(3, f4)
  assert_eq(5, f5)
  assert_eq(8, f6)
  assert_eq(13, f7)
  assert_eq(21, f8)
  assert_eq(34, f9)
}

test "string_unicode_processing" {
  // Unicode å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•
  let chinese_text = "ä½ å¥½ä¸–ç•Œ"
  let japanese_text = "ã“ã‚“ã«ã¡ã¯"
  let emoji_text = "ğŸŒğŸš€ğŸ’»"
  let mixed_text = "Helloä¸–ç•ŒğŸŒ"
  
  // æµ‹è¯•åŒ…å«ä¸åŒè¯­è¨€å­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, ä½ å¥½ä¸–ç•Œ!", greet(chinese_text))
  assert_eq_string("Hello, ã“ã‚“ã«ã¡ã¯!", greet(japanese_text))
  assert_eq_string("Hello, ğŸŒğŸš€ğŸ’»!", greet(emoji_text))
  assert_eq_string("Hello, Helloä¸–ç•ŒğŸŒ!", greet(mixed_text))
  
  // æµ‹è¯•åŒ…å«ç‰¹æ®Šç¬¦å·çš„å­—ç¬¦ä¸²
  let symbols = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", greet(symbols))
}

test "physics_kinematics" {
  // ç‰©ç†è¿åŠ¨å­¦è®¡ç®—
  // è·ç¦» = åˆé€Ÿåº¦ Ã— æ—¶é—´ + 0.5 Ã— åŠ é€Ÿåº¦ Ã— æ—¶é—´Â²
  
  let initial_velocity = 10  // m/s
  let acceleration = 2       // m/sÂ²
  let time = 5               // s
  
  // è®¡ç®—è·ç¦»ï¼š10 Ã— 5 + 0.5 Ã— 2 Ã— 5Â² = 50 + 0.5 Ã— 2 Ã— 25 = 50 + 25 = 75
  let distance_part1 = multiply(initial_velocity, time)
  let distance_part2 = multiply(multiply(2, multiply(time, time)), 1) / 4  // ç®€åŒ–0.5 Ã— 2 Ã— 25
  let total_distance = add(distance_part1, distance_part2)
  
  assert_eq(75, total_distance)
  
  // è®¡ç®—æœ«é€Ÿåº¦ï¼šåˆé€Ÿåº¦ + åŠ é€Ÿåº¦ Ã— æ—¶é—´
  let final_velocity = add(initial_velocity, multiply(acceleration, time))
  assert_eq(20, final_velocity)  // 10 + 2 Ã— 5 = 20
}

test "statistical_variance" {
  // ç»Ÿè®¡å­¦æ–¹å·®è®¡ç®—
  // æ–¹å·® = Î£(xi - Î¼)Â² / nï¼Œå…¶ä¸­Î¼æ˜¯å¹³å‡å€¼
  
  let values = [10, 15, 20, 25, 30]
  let n = 5
  
  // è®¡ç®—å¹³å‡å€¼ï¼š(10 + 15 + 20 + 25 + 30) / 5 = 100 / 5 = 20
  let sum = add(add(add(add(10, 15), 20), 25), 30)
  let mean = sum / n
  assert_eq(20, mean)
  
  // è®¡ç®—æ–¹å·®ï¼š((10-20)Â² + (15-20)Â² + (20-20)Â² + (25-20)Â² + (30-20)Â²) / 5
  // = (100 + 25 + 0 + 25 + 100) / 5 = 250 / 5 = 50
  let diff1 = add(10, -20)  // -10
  let diff2 = add(15, -20)  // -5
  let diff3 = add(20, -20)  // 0
  let diff4 = add(25, -20)  // 5
  let diff5 = add(30, -20)  // 10
  
  let squared_diff1 = multiply(diff1, diff1)  // 100
  let squared_diff2 = multiply(diff2, diff2)  // 25
  let squared_diff3 = multiply(diff3, diff3)  // 0
  let squared_diff4 = multiply(diff4, diff4)  // 25
  let squared_diff5 = multiply(diff5, diff5)  // 100
  
  let variance_sum = add(add(add(add(squared_diff1, squared_diff2), squared_diff3), squared_diff4), squared_diff5)
  let variance = variance_sum / n
  
  assert_eq(50, variance)
}

test "game_damage_calculation" {
  // æ¸¸æˆä¼¤å®³è®¡ç®—
  let base_damage = 100
  let weapon_multiplier = 150  // 1.5å€ï¼Œç”¨150è¡¨ç¤º
  let critical_chance = 20     // 20%æš´å‡»ç‡
  let defense = 30
  
  // åŸºç¡€ä¼¤å®³è®¡ç®—ï¼š100 Ã— 1.5 = 150
  let weapon_damage = multiply(base_damage, weapon_multiplier) / 100
  assert_eq(150, weapon_damage)
  
  // æš´å‡»ä¼¤å®³ï¼ˆç®€åŒ–è®¡ç®—ï¼‰ï¼š150 Ã— 2 = 300
  let critical_damage = multiply(weapon_damage, 200) / 100
  assert_eq(300, critical_damage)
  
  // æœ€ç»ˆä¼¤å®³ï¼šä¼¤å®³ - é˜²å¾¡
  let final_damage = add(weapon_damage, -defense)
  assert_eq(120, final_damage)
  
  // æš´å‡»æœ€ç»ˆä¼¤å®³
  let critical_final_damage = add(critical_damage, -defense)
  assert_eq(270, critical_final_damage)
}

test "financial_depreciation" {
  // é‡‘èæŠ˜æ—§è®¡ç®—ï¼ˆç›´çº¿æŠ˜æ—§æ³•ï¼‰
  let asset_cost = 10000
  let salvage_value = 1000
  let useful_life = 5  // å¹´
  
  // å¹´æŠ˜æ—§é¢ = (åŸå€¼ - æ®‹å€¼) / ä½¿ç”¨å¹´é™
  let depreciation_per_year = add(asset_cost, -salvage_value) / useful_life
  assert_eq(1800, depreciation_per_year)  // (10000 - 1000) / 5 = 1800
  
  // 3å¹´åçš„ç´¯è®¡æŠ˜æ—§
  let accumulated_depreciation = multiply(depreciation_per_year, 3)
  assert_eq(5400, accumulated_depreciation)
  
  // 3å¹´åçš„è´¦é¢ä»·å€¼
  let book_value = add(asset_cost, -accumulated_depreciation)
  assert_eq(4600, book_value)
}

test "data_structure_hash_simulation" {
  // æ•°æ®ç»“æ„å“ˆå¸Œè®¡ç®—æ¨¡æ‹Ÿ
  let key1 = "user123"
  let key2 = "admin456"
  
  // ç®€å•çš„å“ˆå¸Œå‡½æ•°æ¨¡æ‹Ÿï¼šå°†å­—ç¬¦çš„ASCIIå€¼ç›¸åŠ 
  // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨å­—ç¬¦ä¸²é•¿åº¦ä½œä¸ºç®€åŒ–çš„å“ˆå¸Œå€¼
  let hash1 = 7  // "user123" çš„é•¿åº¦
  let hash2 = 8  // "admin456" çš„é•¿åº¦
  
  // æµ‹è¯•å“ˆå¸Œå€¼çš„ä¸åŒ
  assert_true(hash1 != hash2)
  
  // æµ‹è¯•ç›¸åŒå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ç›¸åŒ
  let hash1_duplicate = 7
  assert_eq(hash1, hash1_duplicate)
  
  // æ¨¡æ‹Ÿå“ˆå¸Œè¡¨ç´¢å¼•è®¡ç®—ï¼šhash % table_size
  let table_size = 10
  let index1 = hash1 % table_size
  let index2 = hash2 % table_size
  
  assert_eq(7, index1)
  assert_eq(8, index2)
}

test "date_time_calculations" {
  // æ—¥æœŸæ—¶é—´è®¡ç®—
  let base_year = 2023
  let days_in_year = 365
  let days_in_leap_year = 366
  
  // è®¡ç®—ä»2023å¹´å¼€å§‹çš„å¤©æ•°
  let year_offset = 5
  let total_days = multiply(days_in_year, year_offset)
  assert_eq(1825, total_days)  // 365 Ã— 5 = 1825
  
  // è€ƒè™‘é—°å¹´ï¼ˆç®€åŒ–ï¼šæ¯4å¹´ä¸€ä¸ªé—°å¹´ï¼‰
  let leap_years = year_offset / 4
  let leap_days = multiply(leap_years, 1)
  let total_days_with_leap = add(total_days, leap_days)
  assert_eq(1826, total_days_with_leap)  // 1825 + 1 = 1826
  
  // è®¡ç®—æ˜ŸæœŸå‡ ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
  let start_day = 0  // 0è¡¨ç¤ºå‘¨æ—¥
  let day_offset = 100
  let current_day = add(start_day, day_offset) % 7
  assert_eq(2, current_day)  // 100 % 7 = 2ï¼Œè¡¨ç¤ºå‘¨äºŒ
}

test "encryption_caesar_cipher" {
  // å‡¯æ’’å¯†ç åŠ å¯†æ¨¡æ‹Ÿ
  let plaintext = "HELLO"
  let shift = 3
  
  // ç®€åŒ–çš„å‡¯æ’’å¯†ç ï¼šåªå¤„ç†å¤§å†™å­—æ¯
  // H(7) + 3 = K(10), E(4) + 3 = H(7), L(11) + 3 = O(14), L(11) + 3 = O(14), O(14) + 3 = R(17)
  // è¿™é‡Œæˆ‘ä»¬ç”¨æ•°å­—è¡¨ç¤ºå­—æ¯ä½ç½®
  let h_pos = 7
  let e_pos = 4
  let l_pos = 11
  let o_pos = 14
  
  let h_encrypted = add(h_pos, shift)
  let e_encrypted = add(e_pos, shift)
  let l_encrypted = add(l_pos, shift)
  let o_encrypted = add(o_pos, shift)
  
  assert_eq(10, h_encrypted)  // K
  assert_eq(7, e_encrypted)   // H
  assert_eq(14, l_encrypted)  // O
  assert_eq(17, o_encrypted)  // R
  
  // æµ‹è¯•è§£å¯†ï¼ˆåå‘ç§»ä½ï¼‰
  let k_pos = 10
  let k_decrypted = add(k_pos, -shift)
  assert_eq(7, k_decrypted)  // å›åˆ°H
}