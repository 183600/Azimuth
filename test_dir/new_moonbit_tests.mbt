// æ–°å¢çš„ MoonBit æµ‹è¯•ç”¨ä¾‹
// è¿™äº›æµ‹è¯•ç”¨ä¾‹ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•ï¼Œè¦†ç›– azimuth æ¨¡å—çš„æ–°åœºæ™¯

// å¯¼å…¥ä¸»æ¨¡å—ä¸­çš„å‡½æ•°
use azimuth

test "string_with_unicode_characters" {
  // æµ‹è¯•åŒ…å«å„ç§ Unicode å­—ç¬¦çš„å­—ç¬¦ä¸²
  assert_eq_string("Hello, ğŸŒŸ!", greet("ğŸŒŸ"))
  assert_eq_string("Hello, ğŸ‰!", greet("ğŸ‰"))
  assert_eq_string("Hello, ğŸ’»!", greet("ğŸ’»"))
  assert_eq_string("Hello, ğŸš€!", greet("ğŸš€"))
  assert_eq_string("Hello, ä¸­æ–‡æµ‹è¯•!", greet("ä¸­æ–‡æµ‹è¯•"))
  assert_eq_string("Hello, æ—¥æœ¬èª!", greet("æ—¥æœ¬èª"))
  assert_eq_string("Hello, Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©!", greet("Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"))
  assert_eq_string("Hello, Ñ€ÑƒÑÑĞºĞ¸Ğ¹!", greet("Ñ€ÑƒÑÑĞºĞ¸Ğ¹"))
}

test "arithmetic_progression_sum" {
  // è®¡ç®—ç­‰å·®æ•°åˆ—çš„å’Œï¼š2 + 5 + 8 + 11 + 14
  // ä½¿ç”¨å…¬å¼ï¼šn Ã— (é¦–é¡¹ + æœ«é¡¹) / 2
  let n = 5
  let first = 2
  let last = 14
  let common_diff = 3
  
  // éªŒè¯ç­‰å·®æ•°åˆ—çš„æ€§è´¨
  assert_eq(5, add(first, multiply(common_diff, n - 1)))
  
  // è®¡ç®—æ€»å’Œ
  let sum = multiply(n, add(first, last)) / 2
  assert_eq(40, sum)
  
  // æ‰‹åŠ¨éªŒè¯
  let manual_sum = add(add(add(add(2, 5), 8), 11), 14)
  assert_eq(sum, manual_sum)
}

test "geometric_progression_product" {
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—çš„ç§¯ï¼š2 Ã— 4 Ã— 8 Ã— 16
  let first = 2
  let ratio = 2
  let n = 4
  
  // æ‰‹åŠ¨è®¡ç®—
  let term1 = first
  let term2 = multiply(term1, ratio)
  let term3 = multiply(term2, ratio)
  let term4 = multiply(term3, ratio)
  
  let product = multiply(multiply(multiply(term1, term2), term3), term4)
  assert_eq(1024, product)
  
  // éªŒè¯æ¯ä¸€é¡¹
  assert_eq(2, term1)
  assert_eq(4, term2)
  assert_eq(8, term3)
  assert_eq(16, term4)
}

test "complex_nested_calculations" {
  // å¤æ‚åµŒå¥—è®¡ç®—æµ‹è¯•
  let a = 10
  let b = 20
  let c = 5
  let d = 3
  
  // è®¡ç®—ï¼š(a + b) Ã— (c - d) + a Ã— b - c Ã— d
  let sum_ab = add(a, b)
  let diff_cd = add(c, -d)
  let product_ab_cd = multiply(sum_ab, diff_cd)
  let product_ab = multiply(a, b)
  let product_cd = multiply(c, d)
  
  let result = add(add(product_ab_cd, product_ab), -product_cd)
  assert_eq(265, result)
}

test "price_calculation_with_discounts" {
  // å¸¦æŠ˜æ‰£çš„ä»·æ ¼è®¡ç®—
  let original_price = 1000
  let discount1 = 10  // ç¬¬ä¸€çº§æŠ˜æ‰£ 10%
  let discount2 = 5   // ç¬¬äºŒçº§æŠ˜æ‰£ 5%
  let tax_rate = 8    // ç¨ç‡ 8%
  
  // è®¡ç®—ç¬¬ä¸€çº§æŠ˜æ‰£åçš„ä»·æ ¼
  let discount1_amount = multiply(original_price, discount1) / 100
  let price_after_discount1 = add(original_price, -discount1_amount)
  
  // è®¡ç®—ç¬¬äºŒçº§æŠ˜æ‰£åçš„ä»·æ ¼
  let discount2_amount = multiply(price_after_discount1, discount2) / 100
  let final_price_before_tax = add(price_after_discount1, -discount2_amount)
  
  // è®¡ç®—å«ç¨ä»·æ ¼
  let tax_amount = multiply(final_price_before_tax, tax_rate) / 100
  let final_price_with_tax = add(final_price_before_tax, tax_amount)
  
  assert_eq(864, final_price_with_tax)
}

test "temperature_conversion_extended" {
  // æ‰©å±•çš„æ¸©åº¦è½¬æ¢æµ‹è¯•
  // æ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C Ã— 9/5 + 32
  // ç”±äºåªæœ‰æ•´æ•°è¿ç®—ï¼Œä½¿ç”¨è¿‘ä¼¼å€¼ï¼šF = C Ã— 2 - C Ã— 0.2 + 30
  // è¿›ä¸€æ­¥ç®€åŒ–ä¸ºï¼šF = C Ã— 2 + 30 - C/5
  
  let celsius_temps = [(-40), 0, 10, 20, 37, 100]
  let expected_fahrenheit = [-40, 30, 50, 70, 104, 230]
  
  // æµ‹è¯•-40Â°Cï¼ˆå”¯ä¸€ä¸€ä¸ªæ‘„æ°åº¦å’Œåæ°åº¦ç›¸ç­‰çš„æ¸©åº¦ï¼‰
  let temp1 = -40
  let fahrenheit1 = add(add(multiply(temp1, 2), 30), add(temp1, -temp1 / 5))
  assert_eq(-40, fahrenheit1)
  
  // æµ‹è¯•0Â°Cï¼ˆå†°ç‚¹ï¼‰
  let temp2 = 0
  let fahrenheit2 = add(multiply(temp2, 2), 30)
  assert_eq(30, fahrenheit2)
  
  // æµ‹è¯•100Â°Cï¼ˆæ²¸ç‚¹ï¼‰
  let temp3 = 100
  let fahrenheit3 = add(add(multiply(temp3, 2), 30), add(temp3, -temp3 / 5))
  assert_eq(210, fahrenheit3)
}

test "speed_distance_time_calculations" {
  // é€Ÿåº¦ã€è·ç¦»ã€æ—¶é—´è®¡ç®—
  let speed1 = 60  // km/h
  let time1 = 2    // hours
  let distance1 = multiply(speed1, time1)
  assert_eq(120, distance1)
  
  let speed2 = 80  // km/h
  let distance2 = 200  // km
  let time2 = distance2 / speed2
  assert_eq(2, time2)
  
  let distance3 = 150  // km
  let time3 = 3    // hours
  let speed3 = distance3 / time3
  assert_eq(50, speed3)
  
  // å¤åˆè®¡ç®—ï¼šè®¡ç®—å¹³å‡é€Ÿåº¦
  let total_distance = add(distance1, distance2)
  let total_time = add(time1, time2)
  let average_speed = total_distance / total_time
  assert_eq(80, average_speed)
}

test "simple_interest_calculation" {
  // å•åˆ©è®¡ç®—æµ‹è¯•
  let principal = 10000
  let rate = 5  // 5% å¹´åˆ©ç‡
  let time = 3  // 3å¹´
  
  // è®¡ç®—åˆ©æ¯ï¼šæœ¬é‡‘ Ã— åˆ©ç‡ Ã— æ—¶é—´
  let interest = multiply(principal, multiply(rate, time))
  let total_amount = add(principal, interest)
  
  assert_eq(160000, total_amount)
  
  // æµ‹è¯•ä¸åŒæœŸé™
  let time2 = 5  // 5å¹´
  let interest2 = multiply(principal, multiply(rate, time2))
  let total_amount2 = add(principal, interest2)
  
  assert_eq(260000, total_amount2)
}

test "array_manipulation_simulation" {
  // æ•°ç»„æ“ä½œæ¨¡æ‹Ÿï¼ˆä½¿ç”¨åŸºæœ¬è¿ç®—ï¼‰
  // æ¨¡æ‹Ÿæ•°ç»„å…ƒç´ æ±‚å’Œ
  let element1 = 15
  let element2 = 25
  let element3 = 35
  let element4 = 45
  let element5 = 55
  
  let sum = add(add(add(add(element1, element2), element3), element4), element5)
  assert_eq(175, sum)
  
  // æ¨¡æ‹ŸæŸ¥æ‰¾æœ€å¤§å€¼
  let max1 = if element1 > element2 { element1 } else { element2 }
  let max2 = if max1 > element3 { max1 } else { element3 }
  let max3 = if max2 > element4 { max2 } else { element4 }
  let max4 = if max3 > element5 { max3 } else { element5 }
  
  assert_eq(55, max4)
  
  // æ¨¡æ‹ŸæŸ¥æ‰¾æœ€å°å€¼
  let min1 = if element1 < element2 { element1 } else { element2 }
  let min2 = if min1 < element3 { min1 } else { element3 }
  let min3 = if min2 < element4 { min2 } else { element4 }
  let min4 = if min3 < element5 { min3 } else { element5 }
  
  assert_eq(15, min4)
}

test "logical_expression_evaluation" {
  // é€»è¾‘è¡¨è¾¾å¼è¯„ä¼°æµ‹è¯•
  let x = 10
  let y = 20
  let z = 30
  
  // æµ‹è¯•ä¸è¿ç®—
  let condition1 = x < y && y < z
  let result1 = if condition1 { 1 } else { 0 }
  assert_eq(1, result1)
  
  // æµ‹è¯•æˆ–è¿ç®—
  let condition2 = x > y || y < z
  let result2 = if condition2 { 1 } else { 0 }
  assert_eq(1, result2)
  
  // æµ‹è¯•éè¿ç®—
  let condition3 = !(x > y)
  let result3 = if condition3 { 1 } else { 0 }
  assert_eq(1, result3)
  
  // å¤åˆé€»è¾‘è¡¨è¾¾å¼
  let complex_condition = (x < y && y < z) || (x > y && y > z)
  let complex_result = if complex_condition { 100 } else { 200 }
  assert_eq(100, complex_result)
}