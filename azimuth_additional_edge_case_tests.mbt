// é¢å¤–çš„ MoonBit æµ‹è¯•ç”¨ä¾‹ - é’ˆå¯¹ç‰¹æ®Šè¾¹ç•Œæƒ…å†µå’Œé«˜çº§åœºæ™¯
// è¿™äº›æµ‹è¯•ç”¨ä¾‹è¡¥å……äº†ç°æœ‰çš„æµ‹è¯•è¦†ç›–ï¼Œç¡®ä¿ä»£ç çš„å¥å£®æ€§

test "extreme_boundary_values" {
  // æµ‹è¯•æç«¯è¾¹ç•Œå€¼
  assert_eq(2147483647, add(2147483646, 1))  // æ¥è¿‘Intæœ€å¤§å€¼
  assert_eq(-2147483648, add(-2147483647, -1))  // æ¥è¿‘Intæœ€å°å€¼
  assert_eq(0, add(2147483647, -2147483647))  // æœ€å¤§å€¼ä¸ç›¸åæ•°ç›¸åŠ 
}

test "divide_with_ceil_precision_edge" {
  // æµ‹è¯•é™¤æ³•å‘ä¸Šå–æ•´çš„ç²¾åº¦è¾¹ç•Œ
  assert_eq(1, divide_with_ceil(1, 1))  // å®Œå…¨ç›¸ç­‰
  assert_eq(2, divide_with_ceil(3, 2))  // 1.5 -> 2
  assert_eq(100, divide_with_ceil(9999, 100))  // 99.99 -> 100
  assert_eq(-333334, divide_with_ceil(-1000000, 3))  // å¤§è´Ÿæ•°é™¤æ³•
}

test "string_greeting_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²é—®å€™çš„è¾¹ç•Œæƒ…å†µ
  assert_eq_string("Hello, ğŸŒğŸŒğŸŒ!", greet("ğŸŒğŸŒğŸŒ"))  // å¤šä¸ªemoji
  assert_eq_string("Hello, \n\t\r!", greet("\n\t\r"))  // æ§åˆ¶å­—ç¬¦
  assert_eq_string("Hello, ğŸš€ğŸŒŸâœ¨!", greet("ğŸš€ğŸŒŸâœ¨"))  // å¤šä¸ªç‰¹æ®Šç¬¦å·
}

test "complex_nested_calculations" {
  // æµ‹è¯•å¤æ‚åµŒå¥—è®¡ç®—
  let x = 10
  let y = 20
  let z = 5
  
  // æµ‹è¯•è¡¨è¾¾å¼ï¼š(x + y) * z - x / y
  let result = add(multiply(add(x, y), z), -divide_with_ceil(x, y))
  assert_eq(149, result)  // (10 + 20) * 5 - ceil(10/20) = 30*5 - 1 = 150 - 1 = 149
  
  // æµ‹è¯•åµŒå¥—è¡¨è¾¾å¼
  let nested = divide_with_ceil(multiply(add(x, multiply(y, z)), 2), 3)
  assert_eq(67, nested)  // ceil((10 + 20*5) * 2 / 3) = ceil(110 * 2 / 3) = ceil(220/3) = 74
}

test "mathematical_identities" {
  // æµ‹è¯•æ•°å­¦æ’ç­‰å¼
  let a = 15
  let b = 25
  
  // æµ‹è¯•åˆ†é…å¾‹: a * (b + b) = a * b + a * b
  let distributive_left = multiply(a, add(b, b))
  let distributive_right = add(multiply(a, b), multiply(a, b))
  assert_eq(distributive_left, distributive_right)
  
  // æµ‹è¯•ç»“åˆå¾‹: (a + b) + b = a + (b + b)
  let associative_left = add(add(a, b), b)
  let associative_right = add(a, add(b, b))
  assert_eq(associative_left, associative_right)
}

test "performance_simulation" {
  // æ¨¡æ‹Ÿæ€§èƒ½è®¡ç®—åœºæ™¯
  let base_operations = 1000
  let optimization_factor = 3
  let overhead_percentage = 15
  
  // è®¡ç®—ä¼˜åŒ–åçš„æ“ä½œæ•°
  let optimized_operations = multiply(base_operations, optimization_factor)
  
  // è®¡ç®—å¼€é”€
  let overhead = divide_with_ceil(multiply(optimized_operations, overhead_percentage), 100)
  
  // è®¡ç®—å®é™…æ€§èƒ½
  let actual_performance = add(optimized_operations, -overhead)
  
  assert_eq(3000, optimized_operations)
  assert_eq(450, overhead)
  assert_eq(2550, actual_performance)
}

test "financial_calculation_advanced" {
  // é«˜çº§é‡‘èè®¡ç®—åœºæ™¯
  let principal = 10000
  let rate_percent = 5
  let years = 3
  
  // ç®€åŒ–çš„å¤åˆ©è®¡ç®—ï¼ˆæ¯å¹´è®¡ç®—ä¸€æ¬¡ï¼‰
  let amount_after_year1 = add(principal, divide_with_ceil(multiply(principal, rate_percent), 100))
  let amount_after_year2 = add(amount_after_year1, divide_with_ceil(multiply(amount_after_year1, rate_percent), 100))
  let amount_after_year3 = add(amount_after_year2, divide_with_ceil(multiply(amount_after_year2, rate_percent), 100))
  
  // éªŒè¯ç»“æœï¼ˆç”±äºä½¿ç”¨å‘ä¸Šå–æ•´ï¼Œç»“æœä¼šç•¥é«˜äºæ ‡å‡†å¤åˆ©è®¡ç®—ï¼‰
  assert_eq(10500, amount_after_year1)
  assert_eq(11025, amount_after_year2)
  assert_eq(11576, amount_after_year3)
}

test "resource_allocation_optimization" {
  // èµ„æºåˆ†é…ä¼˜åŒ–æµ‹è¯•
  let total_budget = 5000
  let project_a_cost = 1200
  let project_b_cost = 1800
  let project_c_cost = 900
  
  // è®¡ç®—å‰©ä½™é¢„ç®—
  let allocated_budget = add(add(project_a_cost, project_b_cost), project_c_cost)
  let remaining_budget = add(total_budget, -allocated_budget)
  
  // è®¡ç®—å¯ä»¥æ”¯æŒçš„å°é¡¹ç›®æ•°é‡ï¼ˆæ¯ä¸ªå°é¡¹ç›®æˆæœ¬200ï¼‰
  let small_projects = divide_with_ceil(remaining_budget, 200)
  
  assert_eq(3900, allocated_budget)
  assert_eq(1100, remaining_budget)
  assert_eq(6, small_projects)
}

test "error_handling_robustness" {
  // é”™è¯¯å¤„ç†å¥å£®æ€§æµ‹è¯•
  // æµ‹è¯•é™¤æ•°ä¸ºé›¶çš„æƒ…å†µ
  assert_eq(0, divide_with_ceil(100, 0))
  assert_eq(0, divide_with_ceil(-100, 0))
  assert_eq(0, divide_with_ceil(0, 0))
  
  // æµ‹è¯•æå€¼è¿ç®—
  let extreme_positive = 1000000
  let extreme_negative = -1000000
  assert_eq(0, add(extreme_positive, extreme_negative))
  assert_eq(2000000, add(extreme_positive, -extreme_negative))
}

test "algorithm_complexity_simulation" {
  // ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿæµ‹è¯•
  let input_size = 100
  let linear_factor = 2
  let quadratic_factor = 3
  
  // æ¨¡æ‹Ÿ O(n) ç®—æ³•
  let linear_complexity = multiply(input_size, linear_factor)
  
  // æ¨¡æ‹Ÿ O(nÂ²) ç®—æ³•
  let quadratic_complexity = multiply(multiply(input_size, input_size), quadratic_factor)
  
  // è®¡ç®—æ€»å¤æ‚åº¦
  let total_complexity = add(linear_complexity, quadratic_complexity)
  
  assert_eq(200, linear_complexity)
  assert_eq(30000, quadratic_complexity)
  assert_eq(30200, total_complexity)
}