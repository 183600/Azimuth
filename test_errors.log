Build profile: -w ghc-9.14.1 -O1
In order, the following will be built (use -v for more details):
 - azimuth-0.1.0 (test:azimuth-test) (first run)
Preprocessing test suite 'azimuth-test' for azimuth-0.1.0...
Building test suite 'azimuth-test' for azimuth-0.1.0...
[14 of 46] Compiling BoundaryConditionCabalSpec ( test/BoundaryConditionCabalSpec.hs, dist-newstyle/build/x86_64-linux/ghc-9.14.1/azimuth-0.1.0/t/azimuth-test/build/azimuth-test/azimuth-test-tmp/BoundaryConditionCabalSpec.o )
test/BoundaryConditionCabalSpec.hs:368:11: error: [GHC-58481]
    parse error (possibly incorrect indentation or mismatched brackets)
    |
368 |           ]
    |           ^

[17 of 46] Compiling ConcurrentCabalTestSpec ( test/ConcurrentCabalTestSpec.hs, dist-newstyle/build/x86_64-linux/ghc-9.14.1/azimuth-0.1.0/t/azimuth-test/build/azimuth-test/azimuth-test-tmp/ConcurrentCabalTestSpec.o )
test/ConcurrentCabalTestSpec.hs:38:13: error: [GHC-83865]
    • Couldn't match type ‘[Metric]’ with ‘()’
      Expected: IO ()
        Actual: IO [Metric]
    • In a stmt of a 'do' block:
        sequence
          $ replicate metricsPerThread
              $ do createMetric "concurrent-creation" "count"
      In the second argument of ‘($)’, namely
        ‘do sequence
              $ replicate metricsPerThread
                  $ do createMetric "concurrent-creation" "count"’
      In the expression:
        forkIO
          $ do sequence
                 $ replicate metricsPerThread
                     $ do createMetric "concurrent-creation" "count"
   |
38 |             sequence $ replicate metricsPerThread $ do
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...

test/ConcurrentCabalTestSpec.hs:88:13: error: [GHC-83865]
    • Couldn't match type ‘[Text.Text]’ with ‘()’
      Expected: IO ()
        Actual: IO [Text.Text]
    • In a stmt of a 'do' block:
        sequence
          $ replicate spansPerThread
              $ do span <- createSpan
                             (pack $ "concurrent-span-" ++ show threadId)
                   return (spanSpanId span)
      In the second argument of ‘($)’, namely
        ‘do sequence
              $ replicate spansPerThread
                  $ do span <- createSpan
                                 (pack $ "concurrent-span-" ++ show threadId)
                       return (spanSpanId span)’
      In the expression:
        forkIO
          $ do sequence
                 $ replicate spansPerThread
                     $ do span <- createSpan
                                    (pack $ "concurrent-span-" ++ show threadId)
                          return (spanSpanId span)
   |
88 |             sequence $ replicate spansPerThread $ do
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...

test/ConcurrentCabalTestSpec.hs:161:23: error: [GHC-83865]
    • Couldn't match type ‘()’ with ‘IO a0’
      Expected: IO (IO a0)
        Actual: IO ()
    • In the second argument of ‘($)’, namely
        ‘killThread metricThreads’
      In a stmt of a 'do' block: sequence_ $ killThread metricThreads
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            metricThreads <- mapM
                               (\ threadId
                                  -> forkIO
                                       $ do metric <- createMetric
                                                        (pack $ "mixed-metric-" ++ show threadId)
                                                        "count"
                                            ....)
                               [1 .. actualThreads]
            loggerThreads <- mapM
                               (\ threadId
                                  -> forkIO
                                       $ do logger <- createLogger
                                                        (pack $ "mixed-logger-" ++ show threadId)
                                                        Info
                                            ....)
                               [1 .. actualThreads]
            spanThreads <- mapM
                             (\ threadId
                                -> forkIO $ do sequence_ $ replicate operationsPerType $ ...)
                             [1 .. actualThreads]
            ....’
    |
161 |           sequence_ $ killThread metricThreads
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:161:34: error: [GHC-83865]
    • Couldn't match expected type ‘ghc-internal-9.1401.0:GHC.Internal.Conc.Sync.ThreadId’
                  with actual type ‘[ghc-internal-9.1401.0:GHC.Internal.Conc.Sync.ThreadId]’
    • In the first argument of ‘killThread’, namely ‘metricThreads’
      In the second argument of ‘($)’, namely ‘killThread metricThreads’
      In a stmt of a 'do' block: sequence_ $ killThread metricThreads
    |
161 |           sequence_ $ killThread metricThreads
    |                                  ^^^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:162:23: error: [GHC-83865]
    • Couldn't match type ‘()’ with ‘IO a1’
      Expected: IO (IO a1)
        Actual: IO ()
    • In the second argument of ‘($)’, namely
        ‘killThread loggerThreads’
      In a stmt of a 'do' block: sequence_ $ killThread loggerThreads
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            metricThreads <- mapM
                               (\ threadId
                                  -> forkIO
                                       $ do metric <- createMetric
                                                        (pack $ "mixed-metric-" ++ show threadId)
                                                        "count"
                                            ....)
                               [1 .. actualThreads]
            loggerThreads <- mapM
                               (\ threadId
                                  -> forkIO
                                       $ do logger <- createLogger
                                                        (pack $ "mixed-logger-" ++ show threadId)
                                                        Info
                                            ....)
                               [1 .. actualThreads]
            spanThreads <- mapM
                             (\ threadId
                                -> forkIO $ do sequence_ $ replicate operationsPerType $ ...)
                             [1 .. actualThreads]
            ....’
    |
162 |           sequence_ $ killThread loggerThreads
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:162:34: error: [GHC-83865]
    • Couldn't match expected type ‘ghc-internal-9.1401.0:GHC.Internal.Conc.Sync.ThreadId’
                  with actual type ‘[ghc-internal-9.1401.0:GHC.Internal.Conc.Sync.ThreadId]’
    • In the first argument of ‘killThread’, namely ‘loggerThreads’
      In the second argument of ‘($)’, namely ‘killThread loggerThreads’
      In a stmt of a 'do' block: sequence_ $ killThread loggerThreads
    |
162 |           sequence_ $ killThread loggerThreads
    |                                  ^^^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:163:23: error: [GHC-83865]
    • Couldn't match type ‘()’ with ‘IO a2’
      Expected: IO (IO a2)
        Actual: IO ()
    • In the second argument of ‘($)’, namely ‘killThread spanThreads’
      In a stmt of a 'do' block: sequence_ $ killThread spanThreads
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            metricThreads <- mapM
                               (\ threadId
                                  -> forkIO
                                       $ do metric <- createMetric
                                                        (pack $ "mixed-metric-" ++ show threadId)
                                                        "count"
                                            ....)
                               [1 .. actualThreads]
            loggerThreads <- mapM
                               (\ threadId
                                  -> forkIO
                                       $ do logger <- createLogger
                                                        (pack $ "mixed-logger-" ++ show threadId)
                                                        Info
                                            ....)
                               [1 .. actualThreads]
            spanThreads <- mapM
                             (\ threadId
                                -> forkIO $ do sequence_ $ replicate operationsPerType $ ...)
                             [1 .. actualThreads]
            ....’
    |
163 |           sequence_ $ killThread spanThreads
    |                       ^^^^^^^^^^^^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:163:34: error: [GHC-83865]
    • Couldn't match expected type ‘ghc-internal-9.1401.0:GHC.Internal.Conc.Sync.ThreadId’
                  with actual type ‘[ghc-internal-9.1401.0:GHC.Internal.Conc.Sync.ThreadId]’
    • In the first argument of ‘killThread’, namely ‘spanThreads’
      In the second argument of ‘($)’, namely ‘killThread spanThreads’
      In a stmt of a 'do' block: sequence_ $ killThread spanThreads
    |
163 |           sequence_ $ killThread spanThreads
    |                                  ^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:180:13: error: [GHC-83865]
    • Couldn't match type ‘Double’ with ‘()’
      Expected: IO ()
        Actual: IO Double
    • In a stmt of a 'do' block: metricValue metric
      In the second argument of ‘($)’, namely
        ‘do metric <- createMetric "race-condition" "count"
            recordMetric metric 1.0
            metricValue metric’
      In the expression:
        forkIO
          $ do metric <- createMetric "race-condition" "count"
               recordMetric metric 1.0
               metricValue metric
    |
180 |             metricValue metric
    |             ^^^^^^^^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:203:20: error: [GHC-83865]
    • Couldn't match expected type ‘()’
                  with actual type ‘(Text.Text, Text.Text)’
    • In the first argument of ‘return’, namely ‘(traceId, spanId)’
      In a stmt of a 'do' block: return (traceId, spanId)
      In the second argument of ‘($)’, namely
        ‘do span <- createSpan (pack $ "race-span-" ++ show threadId)
            let traceId = spanTraceId span
                spanId = spanSpanId span
            return (traceId, spanId)’
    |
203 |             return (traceId, spanId)
    |                    ^^^^^^^^^^^^^^^^^

test/ConcurrentCabalTestSpec.hs:308:25: error: [GHC-83865]
    • Couldn't match type: [()]
                     with: IO a3
      Expected: IO (IO a3)
        Actual: IO [()]
    • In the second argument of ‘($)’, namely
        ‘zipWithM
           (\ metric index
              -> do recordMetric metric (fromIntegral (threadId + index)))
           metrics [0 .. ]’
      In a stmt of a 'do' block:
        sequence_
          $ zipWithM
              (\ metric index
                 -> do recordMetric metric (fromIntegral (threadId + index)))
              metrics [0 .. ]
      In the second argument of ‘($)’, namely
        ‘do sequence_
              $ zipWithM
                  (\ metric index
                     -> do recordMetric metric (fromIntegral (threadId + index)))
                  metrics [0 .. ]’
    |
308 |             sequence_ $ zipWithM (\metric index -> do
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...

[20 of 46] Compiling DomainCabalTestSpec ( test/DomainCabalTestSpec.hs, dist-newstyle/build/x86_64-linux/ghc-9.14.1/azimuth-0.1.0/t/azimuth-test/build/azimuth-test/azimuth-test-tmp/DomainCabalTestSpec.o )
test/DomainCabalTestSpec.hs:77:23: error: [GHC-83865]
    • Couldn't match type: [()]
                     with: IO a0
      Expected: IO (IO a0)
        Actual: IO [()]
    • In the second argument of ‘($)’, namely
        ‘zipWithM
           (\ revenueValue customerCount
              -> do recordMetric revenue revenueValue
                    recordMetric orders 1.0
                    recordMetric customers (fromIntegral customerCount))
           businessValues [1 .. ]’
      In a stmt of a 'do' block:
        sequence_
          $ zipWithM
              (\ revenueValue customerCount
                 -> do recordMetric revenue revenueValue
                       recordMetric orders 1.0
                       recordMetric customers (fromIntegral customerCount))
              businessValues [1 .. ]
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            revenue <- createMetric "revenue_total" "dollars"
            orders <- createMetric "orders_total" "count"
            customers <- createMetric "customers_total" "count"
            ....’
   |
77 |           sequence_ $ zipWithM (\revenueValue customerCount -> do
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...

test/DomainCabalTestSpec.hs:145:28: error: [GHC-83865]
    • Couldn't match expected type ‘IO Text.Text’
                  with actual type ‘Text.Text’
    • In the first argument of ‘mapM’, namely ‘spanTraceId’
      In a stmt of a 'do' block:
        traceIds <- mapM spanTraceId serviceSpans
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            entrySpan <- createSpan "entry_point"
            let entryTraceId = spanTraceId entrySpan
            serviceSpans <- sequence
                              $ replicate actualServices $ do createSpan "service_call"
            ....’
    |
145 |           traceIds <- mapM spanTraceId serviceSpans
    |                            ^^^^^^^^^^^

test/DomainCabalTestSpec.hs:261:54: error: [GHC-83865]
    • Couldn't match expected type: IO a1
                  with actual type: a12 -> IO ()
    • The lambda expression ‘\ i -> ...’ has one visible argument,
        but its type ‘IO a1’ has none
      In the second argument of ‘($)’, namely
        ‘\ i
           -> do let ...
                 recordMetric transactions 1.0
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate actualTransactions
           $ \ i
               -> do let ...
                     recordMetric transactions 1.0
                     ....’
    |
261 |           sequence_ $ replicate actualTransactions $ \i -> do
    |                                                      ^^^^^^^^...

test/DomainCabalTestSpec.hs:344:50: error: [GHC-83865]
    • Couldn't match expected type: IO a2
                  with actual type: a13 -> IO ()
    • The lambda expression ‘\ i -> ...’ has one visible argument,
        but its type ‘IO a2’ has none
      In the second argument of ‘($)’, namely
        ‘\ i
           -> do let ...
                 recordMetric responseTime responseTimeValue
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate actualRequests
           $ \ i
               -> do let ...
                     recordMetric responseTime responseTimeValue
                     ....’
    |
344 |           sequence_ $ replicate actualRequests $ \i -> do
    |                                                  ^^^^^^^^...

test/DomainCabalTestSpec.hs:420:48: error: [GHC-83865]
    • Couldn't match expected type: IO a3
                  with actual type: a15 -> IO ()
    • The lambda expression ‘\ i -> ...’ has one visible argument,
        but its type ‘IO a3’ has none
      In the second argument of ‘($)’, namely
        ‘\ i
           -> do let ...
                 recordMetric dataAccess 1.0
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate actualEvents
           $ \ i
               -> do let ...
                     recordMetric dataAccess 1.0
                     ....’
    |
420 |           sequence_ $ replicate actualEvents $ \i -> do
    |                                                ^^^^^^^^...

test/DomainCabalTestSpec.hs:467:49: error: [GHC-83865]
    • Couldn't match expected type: IO a4
                  with actual type: a16 -> IO ()
    • The lambda expression ‘\ deviceId -> ...’
      has one visible argument,
        but its type ‘IO a4’ has none
      In the second argument of ‘($)’, namely
        ‘\ deviceId
           -> do let ...
                 recordMetric deviceMessages 10.0
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate actualDevices
           $ \ deviceId
               -> do let ...
                     recordMetric deviceMessages 10.0
                     ....’
    |
467 |           sequence_ $ replicate actualDevices $ \deviceId -> do
    |                                                 ^^^^^^^^^^^^^^^...

test/DomainCabalTestSpec.hs:515:49: error: [GHC-83865]
    • Couldn't match expected type: IO a5
                  with actual type: a17 -> IO ()
    • The lambda expression ‘\ playerId -> ...’
      has one visible argument,
        but its type ‘IO a5’ has none
      In the second argument of ‘($)’, namely
        ‘\ playerId
           -> do let ...
                 recordMetric activePlayers 1.0
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate actualPlayers
           $ \ playerId
               -> do let ...
                     recordMetric activePlayers 1.0
                     ....’
    |
515 |           sequence_ $ replicate actualPlayers $ \playerId -> do
    |                                                 ^^^^^^^^^^^^^^^...

test/DomainCabalTestSpec.hs:602:50: error: [GHC-83865]
    • Couldn't match expected type: IO a6
                  with actual type: a18 -> IO ()
    • The lambda expression ‘\ studentId -> ...’
      has one visible argument,
        but its type ‘IO a6’ has none
      In the second argument of ‘($)’, namely
        ‘\ studentId
           -> do let ...
                 recordMetric courseEnrollments 1.0
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate actualStudents
           $ \ studentId
               -> do let ...
                     recordMetric courseEnrollments 1.0
                     ....’
    |
602 |           sequence_ $ replicate actualStudents $ \studentId -> do
    |                                                  ^^^^^^^^^^^^^^^^...

[21 of 46] Compiling EdgeCaseCabalTestSpec ( test/EdgeCaseCabalTestSpec.hs, dist-newstyle/build/x86_64-linux/ghc-9.14.1/azimuth-0.1.0/t/azimuth-test/build/azimuth-test/azimuth-test-tmp/EdgeCaseCabalTestSpec.o )
test/EdgeCaseCabalTestSpec.hs:476:46: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance (Arbitrary a, Arbitrary b) => Arbitrary (Either a b)
          -- Defined in ‘Test.QuickCheck.Arbitrary’
        instance Arbitrary Ordering
          -- Defined in ‘Test.QuickCheck.Arbitrary’
        ...plus 21 others
        ...plus 94 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ loadFactor
               -> let actualLoad = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle extreme system load"
          $ property
              $ \ loadFactor
                  -> let actualLoad = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
476 |     it "should handle extreme system load" $ property $
    |                                              ^^^^^^^^

test/EdgeCaseCabalTestSpec.hs:478:26: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a0)’ from being solved.
      Relevant bindings include
        actualLoad :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:478:13)
        loadFactor :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:477:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Ord LogLevel -- Defined in ‘Azimuth.Telemetry’
        instance (Ord a, Ord b) => Ord (Either a b)
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Data.Either’
        ...plus 26 others
        ...plus 68 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 1 (abs loadFactor `mod` 10 + 1)
      In an equation for ‘actualLoad’:
          actualLoad = max 1 (abs loadFactor `mod` 10 + 1)
      In the expression:
        let actualLoad = max 1 (abs loadFactor `mod` 10 + 1)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 metric <- createMetric "extreme-load" "count"
                 threads <- mapM (\ threadId -> forkIO $ do ...) [1 .. actualLoad]
                 ....
    |
478 |         let actualLoad = max 1 (abs loadFactor `mod` 10 + 1)
    |                          ^^^

test/EdgeCaseCabalTestSpec.hs:478:30: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from the literal ‘1’
      prevents the constraint ‘(Num a0)’ from being solved.
      Relevant bindings include
        actualLoad :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:478:13)
        loadFactor :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:477:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Num Integer
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Num’
        instance Num Double
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Float’
        ...plus three others
        ...plus 16 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘1’
      In the expression: max 1 (abs loadFactor `mod` 10 + 1)
      In an equation for ‘actualLoad’:
          actualLoad = max 1 (abs loadFactor `mod` 10 + 1)
    |
478 |         let actualLoad = max 1 (abs loadFactor `mod` 10 + 1)
    |                              ^

test/EdgeCaseCabalTestSpec.hs:478:48: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a0)’ from being solved.
      Relevant bindings include
        actualLoad :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:478:13)
        loadFactor :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:477:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Integral Integer
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Real’
        instance Integral Int
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Real’
        ...plus one other
        ...plus 9 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely ‘abs loadFactor `mod` 10’
      In the second argument of ‘max’, namely
        ‘(abs loadFactor `mod` 10 + 1)’
      In the expression: max 1 (abs loadFactor `mod` 10 + 1)
    |
478 |         let actualLoad = max 1 (abs loadFactor `mod` 10 + 1)
    |                                                ^^^^^

test/EdgeCaseCabalTestSpec.hs:491:48: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from the arithmetic sequence ‘1 .. actualLoad’
      prevents the constraint ‘(Enum a0)’ from being solved.
      Relevant bindings include
        actualLoad :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:478:13)
        loadFactor :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:477:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Enum LogLevel -- Defined in ‘Azimuth.Telemetry’
        instance Enum Ordering
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Enum’
        ...plus 9 others
        ...plus 28 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘mapM’, namely ‘[1 .. actualLoad]’
      In a stmt of a 'do' block:
        threads <- mapM
                     (\ threadId
                        -> forkIO
                             $ do sequence_
                                    $ replicate 10000
                                        $ do recordMetric metric 1.0
                                             ....)
                     [1 .. actualLoad]
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            metric <- createMetric "extreme-load" "count"
            threads <- mapM
                         (\ threadId -> forkIO $ do sequence_ $ replicate 10000 $ ...)
                         [1 .. actualLoad]
            threadDelay 2000000
            ....’
    |
491 |                         return ()            ) [1..actualLoad]
    |                                                ^^^^^^^^^^^^^^^

test/EdgeCaseCabalTestSpec.hs:491:49: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from the literal ‘1’
      prevents the constraint ‘(Num a0)’ from being solved.
      Relevant bindings include
        actualLoad :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:478:13)
        loadFactor :: a0 (bound at test/EdgeCaseCabalTestSpec.hs:477:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Num Integer
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Num’
        instance Num Double
          -- Defined in ‘ghc-internal-9.1401.0:GHC.Internal.Float’
        ...plus three others
        ...plus 16 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: 1
      In the second argument of ‘mapM’, namely ‘[1 .. actualLoad]’
      In a stmt of a 'do' block:
        threads <- mapM
                     (\ threadId
                        -> forkIO
                             $ do sequence_
                                    $ replicate 10000
                                        $ do recordMetric metric 1.0
                                             ....)
                     [1 .. actualLoad]
    |
491 |                         return ()            ) [1..actualLoad]
    |                                                 ^

[28 of 46] Compiling IntegrationCabalTestSpec ( test/IntegrationCabalTestSpec.hs, dist-newstyle/build/x86_64-linux/ghc-9.14.1/azimuth-0.1.0/t/azimuth-test/build/azimuth-test/azimuth-test-tmp/IntegrationCabalTestSpec.o )
test/IntegrationCabalTestSpec.hs:412:25: error: [GHC-83865]
    • Couldn't match expected type ‘Metric -> IO a3’
                  with actual type ‘Double’
    • The function ‘metricValue’ is applied to one visible argument,
        but its type ‘Double’ has none
      In a stmt of a 'do' block: newMetricValue <- metricValue newMetric
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            metric <- createMetric "lifecycle" "count"
            logger <- createLogger "lifecycle" Info
            span <- createSpan "lifecycle"
            ....’
    |
412 |       newMetricValue <- metricValue newMetric
    |                         ^^^^^^^^^^^^^^^^^^^^^

test/IntegrationCabalTestSpec.hs:592:34: error: [GHC-83865]
    • Couldn't match expected type: IO a0
                  with actual type: a2 -> IO ()
    • The lambda expression ‘\ requestId -> ...’
      has one visible argument,
        but its type ‘IO a0’ has none
      In the second argument of ‘($)’, namely
        ‘\ requestId
           -> do recordMetric activeConnections 1.0
                 requestSpan <- createSpan
                                  (pack $ "http_request_" ++ show requestId)
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate 10
           $ \ requestId
               -> do recordMetric activeConnections 1.0
                     requestSpan <- createSpan
                                      (pack $ "http_request_" ++ show requestId)
                     ....’
    |
592 |       sequence_ $ replicate 10 $ \requestId -> do
    |                                  ^^^^^^^^^^^^^^^^...

test/IntegrationCabalTestSpec.hs:638:59: error: [GHC-83865]
    • Couldn't match expected type: IO a1
                  with actual type: Int -> IO ()
    • The lambda expression ‘\ step -> ...’ has one visible argument,
        but its type ‘IO a1’ has none
      In the second argument of ‘($)’, namely
        ‘\ step
           -> do let ...
                 recordMetric (metrics !! metricIndex) 1.0
                 ....’
      In the second argument of ‘($)’, namely
        ‘replicate (actualComplexity * 10)
           $ \ step
               -> do let ...
                     recordMetric (metrics !! metricIndex) 1.0
                     ....’
    |
638 |           sequence_ $ replicate (actualComplexity * 10) $ \step -> do
    |                                                           ^^^^^^^^^^^...

[38 of 46] Compiling PerformanceCabalTestSpec ( test/PerformanceCabalTestSpec.hs, dist-newstyle/build/x86_64-linux/ghc-9.14.1/azimuth-0.1.0/t/azimuth-test/build/azimuth-test/azimuth-test-tmp/PerformanceCabalTestSpec.o )
test/PerformanceCabalTestSpec.hs:216:62: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ threadCount
               -> let
                    actualThreads = ...
                    ....
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should maintain performance under concurrent load"
          $ property
              $ \ threadCount
                  -> let
                       actualThreads = ...
                       ....
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
216 |     it "should maintain performance under concurrent load" $ property $
    |                                                              ^^^^^^^^

test/PerformanceCabalTestSpec.hs:218:29: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a0)’ from being solved.
      Relevant bindings include
        actualThreads :: a0
          (bound at test/PerformanceCabalTestSpec.hs:218:13)
        threadCount :: a0 (bound at test/PerformanceCabalTestSpec.hs:217:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 47 others
        ...plus 126 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 1 (abs threadCount `mod` 20 + 1)
      In an equation for ‘actualThreads’:
          actualThreads = max 1 (abs threadCount `mod` 20 + 1)
      In the expression:
        let
          actualThreads = max 1 (abs threadCount `mod` 20 + 1)
          operationsPerThread = 500
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 metric <- createMetric "concurrent-performance" "ops"
                 startTime <- getCurrentTime
                 ....
    |
218 |         let actualThreads = max 1 (abs threadCount `mod` 20 + 1)
    |                             ^^^

test/PerformanceCabalTestSpec.hs:218:33: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from the literal ‘1’
      prevents the constraint ‘(Num a0)’ from being solved.
      Relevant bindings include
        actualThreads :: a0
          (bound at test/PerformanceCabalTestSpec.hs:218:13)
        threadCount :: a0 (bound at test/PerformanceCabalTestSpec.hs:217:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 10 others
        ...plus 50 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘1’
      In the expression: max 1 (abs threadCount `mod` 20 + 1)
      In an equation for ‘actualThreads’:
          actualThreads = max 1 (abs threadCount `mod` 20 + 1)
    |
218 |         let actualThreads = max 1 (abs threadCount `mod` 20 + 1)
    |                                 ^

test/PerformanceCabalTestSpec.hs:218:52: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a0)’ from being solved.
      Relevant bindings include
        actualThreads :: a0
          (bound at test/PerformanceCabalTestSpec.hs:218:13)
        threadCount :: a0 (bound at test/PerformanceCabalTestSpec.hs:217:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely ‘abs threadCount `mod` 20’
      In the second argument of ‘max’, namely
        ‘(abs threadCount `mod` 20 + 1)’
      In the expression: max 1 (abs threadCount `mod` 20 + 1)
    |
218 |         let actualThreads = max 1 (abs threadCount `mod` 20 + 1)
    |                                                    ^^^^^

test/PerformanceCabalTestSpec.hs:231:15: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from the arithmetic sequence ‘1 .. actualThreads’
      prevents the constraint ‘(Enum a0)’ from being solved.
      Relevant bindings include
        actualThreads :: a0
          (bound at test/PerformanceCabalTestSpec.hs:218:13)
        threadCount :: a0 (bound at test/PerformanceCabalTestSpec.hs:217:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 21 others
        ...plus 69 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘mapM’, namely ‘[1 .. actualThreads]’
      In a stmt of a 'do' block:
        threads <- mapM
                     (\ threadId
                        -> forkIO
                             $ do sequence_
                                    $ replicate operationsPerThread $ do recordMetric metric 1.0)
                     [1 .. actualThreads]
      In the second argument of ‘($)’, namely
        ‘do initTelemetry productionConfig
            metric <- createMetric "concurrent-performance" "ops"
            startTime <- getCurrentTime
            threads <- mapM
                         (\ threadId
                            -> forkIO $ do sequence_ $ replicate operationsPerThread $ ...)
                         [1 .. actualThreads]
            ....’
    |
231 |             ) [1..actualThreads]
    |               ^^^^^^^^^^^^^^^^^^

test/PerformanceCabalTestSpec.hs:231:16: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from the literal ‘1’
      prevents the constraint ‘(Num a0)’ from being solved.
      Relevant bindings include
        actualThreads :: a0
          (bound at test/PerformanceCabalTestSpec.hs:218:13)
        threadCount :: a0 (bound at test/PerformanceCabalTestSpec.hs:217:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 10 others
        ...plus 50 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: 1
      In the second argument of ‘mapM’, namely ‘[1 .. actualThreads]’
      In a stmt of a 'do' block:
        threads <- mapM
                     (\ threadId
                        -> forkIO
                             $ do sequence_
                                    $ replicate operationsPerThread $ do recordMetric metric 1.0)
                     [1 .. actualThreads]
    |
231 |             ) [1..actualThreads]
    |                ^

test/PerformanceCabalTestSpec.hs:238:33: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a0)’ from being solved.
      Relevant bindings include
        actualThreads :: a0
          (bound at test/PerformanceCabalTestSpec.hs:218:13)
        threadCount :: a0 (bound at test/PerformanceCabalTestSpec.hs:217:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(*)’, namely
        ‘fromIntegral actualThreads’
      In the expression:
        fromIntegral actualThreads * fromIntegral operationsPerThread
      In an equation for ‘totalOperations’:
          totalOperations
            = fromIntegral actualThreads * fromIntegral operationsPerThread
    |
238 |               totalOperations = fromIntegral actualThreads * fromIntegral operationsPerThread
    |                                 ^^^^^^^^^^^^

[40 of 46] Compiling RealWorldCabalTestSpec ( test/RealWorldCabalTestSpec.hs, dist-newstyle/build/x86_64-linux/ghc-9.14.1/azimuth-0.1.0/t/azimuth-test/build/azimuth-test/azimuth-test-tmp/RealWorldCabalTestSpec.o )
test/RealWorldCabalTestSpec.hs:74:48: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ sessionCount
               -> let actualSessions = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle user session tracking"
          $ property
              $ \ sessionCount
                  -> let actualSessions = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
   |
74 |     it "should handle user session tracking" $ property $
   |                                                ^^^^^^^^

test/RealWorldCabalTestSpec.hs:76:30: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a0)’ from being solved.
      Relevant bindings include
        actualSessions :: a0
          (bound at test/RealWorldCabalTestSpec.hs:76:13)
        sessionCount :: a0 (bound at test/RealWorldCabalTestSpec.hs:75:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 43 others
        ...plus 130 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 1 (abs sessionCount `mod` 100 + 1)
      In an equation for ‘actualSessions’:
          actualSessions = max 1 (abs sessionCount `mod` 100 + 1)
      In the expression:
        let actualSessions = max 1 (abs sessionCount `mod` 100 + 1)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 activeSessions <- createMetric "active_sessions" "count"
                 sessionDuration <- createMetric
                                      "session_duration_seconds" "seconds"
                 ....
   |
76 |         let actualSessions = max 1 (abs sessionCount `mod` 100 + 1)
   |                              ^^^

test/RealWorldCabalTestSpec.hs:76:34: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from the literal ‘1’
      prevents the constraint ‘(Num a0)’ from being solved.
      Relevant bindings include
        actualSessions :: a0
          (bound at test/RealWorldCabalTestSpec.hs:76:13)
        sessionCount :: a0 (bound at test/RealWorldCabalTestSpec.hs:75:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘1’
      In the expression: max 1 (abs sessionCount `mod` 100 + 1)
      In an equation for ‘actualSessions’:
          actualSessions = max 1 (abs sessionCount `mod` 100 + 1)
   |
76 |         let actualSessions = max 1 (abs sessionCount `mod` 100 + 1)
   |                                  ^

test/RealWorldCabalTestSpec.hs:76:54: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a0)’ from being solved.
      Relevant bindings include
        actualSessions :: a0
          (bound at test/RealWorldCabalTestSpec.hs:76:13)
        sessionCount :: a0 (bound at test/RealWorldCabalTestSpec.hs:75:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely
        ‘abs sessionCount `mod` 100’
      In the second argument of ‘max’, namely
        ‘(abs sessionCount `mod` 100 + 1)’
      In the expression: max 1 (abs sessionCount `mod` 100 + 1)
   |
76 |         let actualSessions = max 1 (abs sessionCount `mod` 100 + 1)
   |                                                      ^^^^^

test/RealWorldCabalTestSpec.hs:87:21: error: [GHC-39999]
    • Ambiguous type variable ‘a0’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a0)’ from being solved.
      Relevant bindings include
        actualSessions :: a0
          (bound at test/RealWorldCabalTestSpec.hs:76:13)
        sessionCount :: a0 (bound at test/RealWorldCabalTestSpec.hs:75:8)
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualSessions
      In the first argument of ‘forM_’, namely
        ‘[1 .. fromIntegral actualSessions]’
      In the first argument of ‘($)’, namely
        ‘forM_ [1 .. fromIntegral actualSessions]’
   |
87 |           forM_ [1..fromIntegral actualSessions] $ \sessionId -> do
   |                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:162:53: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a1)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ serviceCount
               -> let actualServices = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle service mesh communication"
          $ property
              $ \ serviceCount
                  -> let actualServices = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
162 |     it "should handle service mesh communication" $ property $
    |                                                     ^^^^^^^^

test/RealWorldCabalTestSpec.hs:164:30: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 43 others
        ...plus 130 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 2 (abs serviceCount `mod` 5 + 2)
      In an equation for ‘actualServices’:
          actualServices = max 2 (abs serviceCount `mod` 5 + 2)
      In the expression:
        let actualServices = max 2 (abs serviceCount `mod` 5 + 2)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 interServiceCalls <- createMetric "inter_service_calls" "count"
                 serviceLatency <- createMetric "service_latency_ms" "ms"
                 ....
    |
164 |         let actualServices = max 2 (abs serviceCount `mod` 5 + 2)
    |                              ^^^

test/RealWorldCabalTestSpec.hs:164:34: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from the literal ‘2’
      prevents the constraint ‘(Num a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘2’
      In the expression: max 2 (abs serviceCount `mod` 5 + 2)
      In an equation for ‘actualServices’:
          actualServices = max 2 (abs serviceCount `mod` 5 + 2)
    |
164 |         let actualServices = max 2 (abs serviceCount `mod` 5 + 2)
    |                                  ^

test/RealWorldCabalTestSpec.hs:164:54: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely ‘abs serviceCount `mod` 5’
      In the second argument of ‘max’, namely
        ‘(abs serviceCount `mod` 5 + 2)’
      In the expression: max 2 (abs serviceCount `mod` 5 + 2)
    |
164 |         let actualServices = max 2 (abs serviceCount `mod` 5 + 2)
    |                                                      ^^^^^

test/RealWorldCabalTestSpec.hs:176:21: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualServices
      In the first argument of ‘forM_’, namely
        ‘[1 .. fromIntegral actualServices]’
      In the first argument of ‘($)’, namely
        ‘forM_ [1 .. fromIntegral actualServices]’
    |
176 |           forM_ [1..fromIntegral actualServices] $ \serviceId -> do
    |                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:200:31: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(*)’, namely
        ‘fromIntegral actualServices’
      In the expression: fromIntegral actualServices * 3
      In an equation for ‘expectedCalls’:
          expectedCalls = fromIntegral actualServices * 3
    |
200 |           let expectedCalls = fromIntegral actualServices * 3
    |                               ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:202:41: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from the arithmetic sequence ‘1 .. actualServices’
      prevents the constraint ‘(Enum a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [1 .. actualServices]
      In a stmt of a list comprehension: _ <- [1 .. actualServices]
      In the first argument of ‘sum’, namely
        ‘[50.0 + fromIntegral callId * 10.0 |
            _ <- [1 .. actualServices], callId <- [0 .. 2]]’
    |
202 |                                    _ <- [1..actualServices], callId <- [0..2]]
    |                                         ^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:202:42: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from the literal ‘1’
      prevents the constraint ‘(Num a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: 1
      In the expression: [1 .. actualServices]
      In a stmt of a list comprehension: _ <- [1 .. actualServices]
    |
202 |                                    _ <- [1..actualServices], callId <- [0..2]]
    |                                          ^

test/RealWorldCabalTestSpec.hs:203:31: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral (actualServices `div` 3)
      In an equation for ‘expectedTrips’:
          expectedTrips = fromIntegral (actualServices `div` 3)
      In a stmt of a 'do' block:
        let expectedCalls = fromIntegral actualServices * 3
            expectedLatency
              = sum
                  [50.0 + fromIntegral callId * 10.0 |
                     _ <- [1 .. actualServices], callId <- [0 .. 2]]
            expectedTrips = fromIntegral (actualServices `div` 3)
    |
203 |               expectedTrips = fromIntegral (actualServices `div` 3)
    |                               ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:203:66: error: [GHC-39999]
    • Ambiguous type variable ‘a1’ arising from the literal ‘3’
      prevents the constraint ‘(Num a1)’ from being solved.
      Relevant bindings include
        actualServices :: a1
          (bound at test/RealWorldCabalTestSpec.hs:164:13)
        serviceCount :: a1 (bound at test/RealWorldCabalTestSpec.hs:163:8)
      Probable fix: use a type annotation to specify what ‘a1’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘div’, namely ‘3’
      In the first argument of ‘fromIntegral’, namely
        ‘(actualServices `div` 3)’
      In the expression: fromIntegral (actualServices `div` 3)
    |
203 |               expectedTrips = fromIntegral (actualServices `div` 3)
    |                                                                  ^

test/RealWorldCabalTestSpec.hs:263:49: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a2)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ requestCount
               -> let actualRequests = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle cache hit/miss metrics"
          $ property
              $ \ requestCount
                  -> let actualRequests = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
263 |     it "should handle cache hit/miss metrics" $ property $
    |                                                 ^^^^^^^^

test/RealWorldCabalTestSpec.hs:265:30: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 43 others
        ...plus 130 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 10 (abs requestCount `mod` 1000 + 10)
      In an equation for ‘actualRequests’:
          actualRequests = max 10 (abs requestCount `mod` 1000 + 10)
      In the expression:
        let actualRequests = max 10 (abs requestCount `mod` 1000 + 10)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 cacheHits <- createMetric "cache_hits" "count"
                 cacheMisses <- createMetric "cache_misses" "count"
                 ....
    |
265 |         let actualRequests = max 10 (abs requestCount `mod` 1000 + 10)
    |                              ^^^

test/RealWorldCabalTestSpec.hs:265:34: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from the literal ‘10’
      prevents the constraint ‘(Num a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘10’
      In the expression: max 10 (abs requestCount `mod` 1000 + 10)
      In an equation for ‘actualRequests’:
          actualRequests = max 10 (abs requestCount `mod` 1000 + 10)
    |
265 |         let actualRequests = max 10 (abs requestCount `mod` 1000 + 10)
    |                                  ^^

test/RealWorldCabalTestSpec.hs:265:55: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely
        ‘abs requestCount `mod` 1000’
      In the second argument of ‘max’, namely
        ‘(abs requestCount `mod` 1000 + 10)’
      In the expression: max 10 (abs requestCount `mod` 1000 + 10)
    |
265 |         let actualRequests = max 10 (abs requestCount `mod` 1000 + 10)
    |                                                       ^^^^^

test/RealWorldCabalTestSpec.hs:277:21: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualRequests
      In the first argument of ‘forM_’, namely
        ‘[1 .. fromIntegral actualRequests]’
      In the first argument of ‘($)’, namely
        ‘forM_ [1 .. fromIntegral actualRequests]’
    |
277 |           forM_ [1..fromIntegral actualRequests] $ \requestId -> do
    |                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:304:30: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression:
        fromIntegral (actualRequests - actualRequests `div` 3)
      In an equation for ‘expectedHits’:
          expectedHits
            = fromIntegral (actualRequests - actualRequests `div` 3)
      In a stmt of a 'do' block:
        let expectedHits
              = fromIntegral (actualRequests - actualRequests `div` 3)
            expectedMisses = fromIntegral (actualRequests `div` 3)
            expectedEvictions = fromIntegral (actualRequests `div` 20)
            expectedCacheSize = (expectedMisses - expectedEvictions) * 1024.0
    |
304 |           let expectedHits = fromIntegral (actualRequests - actualRequests `div` 3)
    |                              ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:304:59: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘-’
      prevents the constraint ‘(Num a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘fromIntegral’, namely
        ‘(actualRequests - actualRequests `div` 3)’
      In the expression:
        fromIntegral (actualRequests - actualRequests `div` 3)
      In an equation for ‘expectedHits’:
          expectedHits
            = fromIntegral (actualRequests - actualRequests `div` 3)
    |
304 |           let expectedHits = fromIntegral (actualRequests - actualRequests `div` 3)
    |                                                           ^

test/RealWorldCabalTestSpec.hs:305:32: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral (actualRequests `div` 3)
      In an equation for ‘expectedMisses’:
          expectedMisses = fromIntegral (actualRequests `div` 3)
      In a stmt of a 'do' block:
        let expectedHits
              = fromIntegral (actualRequests - actualRequests `div` 3)
            expectedMisses = fromIntegral (actualRequests `div` 3)
            expectedEvictions = fromIntegral (actualRequests `div` 20)
            expectedCacheSize = (expectedMisses - expectedEvictions) * 1024.0
    |
305 |               expectedMisses = fromIntegral (actualRequests `div` 3)
    |                                ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:305:67: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from the literal ‘3’
      prevents the constraint ‘(Num a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘div’, namely ‘3’
      In the first argument of ‘fromIntegral’, namely
        ‘(actualRequests `div` 3)’
      In the expression: fromIntegral (actualRequests `div` 3)
    |
305 |               expectedMisses = fromIntegral (actualRequests `div` 3)
    |                                                                   ^

test/RealWorldCabalTestSpec.hs:306:35: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral (actualRequests `div` 20)
      In an equation for ‘expectedEvictions’:
          expectedEvictions = fromIntegral (actualRequests `div` 20)
      In a stmt of a 'do' block:
        let expectedHits
              = fromIntegral (actualRequests - actualRequests `div` 3)
            expectedMisses = fromIntegral (actualRequests `div` 3)
            expectedEvictions = fromIntegral (actualRequests `div` 20)
            expectedCacheSize = (expectedMisses - expectedEvictions) * 1024.0
    |
306 |               expectedEvictions = fromIntegral (actualRequests `div` 20)
    |                                   ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:306:70: error: [GHC-39999]
    • Ambiguous type variable ‘a2’ arising from the literal ‘20’
      prevents the constraint ‘(Num a2)’ from being solved.
      Relevant bindings include
        actualRequests :: a2
          (bound at test/RealWorldCabalTestSpec.hs:265:13)
        requestCount :: a2 (bound at test/RealWorldCabalTestSpec.hs:264:8)
      Probable fix: use a type annotation to specify what ‘a2’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘div’, namely ‘20’
      In the first argument of ‘fromIntegral’, namely
        ‘(actualRequests `div` 20)’
      In the expression: fromIntegral (actualRequests `div` 20)
    |
306 |               expectedEvictions = fromIntegral (actualRequests `div` 20)
    |                                                                      ^^

test/RealWorldCabalTestSpec.hs:413:53: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a3)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ containerCount
               -> let actualContainers = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle container resource metrics"
          $ property
              $ \ containerCount
                  -> let actualContainers = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
413 |     it "should handle container resource metrics" $ property $
    |                                                     ^^^^^^^^

test/RealWorldCabalTestSpec.hs:415:32: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 43 others
        ...plus 130 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 1 (abs containerCount `mod` 10 + 1)
      In an equation for ‘actualContainers’:
          actualContainers = max 1 (abs containerCount `mod` 10 + 1)
      In the expression:
        let actualContainers = max 1 (abs containerCount `mod` 10 + 1)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 cpuUsage <- createMetric "container_cpu_usage_percent" "percent"
                 memoryUsage <- createMetric "container_memory_usage_mb" "mb"
                 ....
    |
415 |         let actualContainers = max 1 (abs containerCount `mod` 10 + 1)
    |                                ^^^

test/RealWorldCabalTestSpec.hs:415:36: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the literal ‘1’
      prevents the constraint ‘(Num a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘1’
      In the expression: max 1 (abs containerCount `mod` 10 + 1)
      In an equation for ‘actualContainers’:
          actualContainers = max 1 (abs containerCount `mod` 10 + 1)
    |
415 |         let actualContainers = max 1 (abs containerCount `mod` 10 + 1)
    |                                    ^

test/RealWorldCabalTestSpec.hs:415:58: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely
        ‘abs containerCount `mod` 10’
      In the second argument of ‘max’, namely
        ‘(abs containerCount `mod` 10 + 1)’
      In the expression: max 1 (abs containerCount `mod` 10 + 1)
    |
415 |         let actualContainers = max 1 (abs containerCount `mod` 10 + 1)
    |                                                          ^^^^^

test/RealWorldCabalTestSpec.hs:428:21: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualContainers
      In the first argument of ‘forM_’, namely
        ‘[1 .. fromIntegral actualContainers]’
      In the first argument of ‘($)’, namely
        ‘forM_ [1 .. fromIntegral actualContainers]’
    |
428 |           forM_ [1..fromIntegral actualContainers] $ \containerId -> do
    |                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:451:41: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:451:69)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘(+)’, namely
        ‘fromIntegral (i `mod` 75)’
      In the expression: 25.0 + fromIntegral (i `mod` 75)
      In the first argument of ‘sum’, namely
        ‘[25.0 + fromIntegral (i `mod` 75) |
            i <- [0 .. actualContainers - 1]]’
    |
451 |           let expectedCpu = sum [25.0 + fromIntegral (i `mod` 75) | i <- [0..actualContainers-1]]
    |                                         ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:451:63: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the literal ‘75’
      prevents the constraint ‘(Num a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:451:69)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘mod’, namely ‘75’
      In the first argument of ‘fromIntegral’, namely ‘(i `mod` 75)’
      In the second argument of ‘(+)’, namely ‘fromIntegral (i `mod` 75)’
    |
451 |           let expectedCpu = sum [25.0 + fromIntegral (i `mod` 75) | i <- [0..actualContainers-1]]
    |                                                               ^^

test/RealWorldCabalTestSpec.hs:451:74: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the arithmetic sequence ‘0 .. actualContainers
                                                                                - 1’
      prevents the constraint ‘(Enum a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [0 .. actualContainers - 1]
      In a stmt of a list comprehension: i <- [0 .. actualContainers - 1]
      In the first argument of ‘sum’, namely
        ‘[25.0 + fromIntegral (i `mod` 75) |
            i <- [0 .. actualContainers - 1]]’
    |
451 |           let expectedCpu = sum [25.0 + fromIntegral (i `mod` 75) | i <- [0..actualContainers-1]]
    |                                                                          ^^^^^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:452:45: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:452:74)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘(+)’, namely
        ‘fromIntegral (i `mod` 512)’
      In the expression: 128.0 + fromIntegral (i `mod` 512)
      In the first argument of ‘sum’, namely
        ‘[128.0 + fromIntegral (i `mod` 512) |
            i <- [0 .. actualContainers - 1]]’
    |
452 |               expectedMemory = sum [128.0 + fromIntegral (i `mod` 512) | i <- [0..actualContainers-1]]
    |                                             ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:452:67: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the literal ‘512’
      prevents the constraint ‘(Num a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:452:74)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘mod’, namely ‘512’
      In the first argument of ‘fromIntegral’, namely ‘(i `mod` 512)’
      In the second argument of ‘(+)’, namely
        ‘fromIntegral (i `mod` 512)’
    |
452 |               expectedMemory = sum [128.0 + fromIntegral (i `mod` 512) | i <- [0..actualContainers-1]]
    |                                                                   ^^^

test/RealWorldCabalTestSpec.hs:452:79: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the arithmetic sequence ‘0 .. actualContainers
                                                                                - 1’
      prevents the constraint ‘(Enum a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [0 .. actualContainers - 1]
      In a stmt of a list comprehension: i <- [0 .. actualContainers - 1]
      In the first argument of ‘sum’, namely
        ‘[128.0 + fromIntegral (i `mod` 512) |
            i <- [0 .. actualContainers - 1]]’
    |
452 |               expectedMemory = sum [128.0 + fromIntegral (i `mod` 512) | i <- [0..actualContainers-1]]
    |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:453:45: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:453:74)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘(+)’, namely
        ‘fromIntegral (i `mod` 100)’
      In the expression: 10.0 + fromIntegral (i `mod` 100)
      In the first argument of ‘sum’, namely
        ‘[10.0 + fromIntegral (i `mod` 100) |
            i <- [0 .. actualContainers - 1]]’
    |
453 |               expectedNetwork = sum [10.0 + fromIntegral (i `mod` 100) | i <- [0..actualContainers-1]]
    |                                             ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:453:67: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the literal ‘100’
      prevents the constraint ‘(Num a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:453:74)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘mod’, namely ‘100’
      In the first argument of ‘fromIntegral’, namely ‘(i `mod` 100)’
      In the second argument of ‘(+)’, namely
        ‘fromIntegral (i `mod` 100)’
    |
453 |               expectedNetwork = sum [10.0 + fromIntegral (i `mod` 100) | i <- [0..actualContainers-1]]
    |                                                                   ^^^

test/RealWorldCabalTestSpec.hs:453:79: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the arithmetic sequence ‘0 .. actualContainers
                                                                                - 1’
      prevents the constraint ‘(Enum a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [0 .. actualContainers - 1]
      In a stmt of a list comprehension: i <- [0 .. actualContainers - 1]
      In the first argument of ‘sum’, namely
        ‘[10.0 + fromIntegral (i `mod` 100) |
            i <- [0 .. actualContainers - 1]]’
    |
453 |               expectedNetwork = sum [10.0 + fromIntegral (i `mod` 100) | i <- [0..actualContainers-1]]
    |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:454:41: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:454:69)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘(+)’, namely
        ‘fromIntegral (i `mod` 50)’
      In the expression: 5.0 + fromIntegral (i `mod` 50)
      In the first argument of ‘sum’, namely
        ‘[5.0 + fromIntegral (i `mod` 50) |
            i <- [0 .. actualContainers - 1]]’
    |
454 |               expectedDisk = sum [5.0 + fromIntegral (i `mod` 50) | i <- [0..actualContainers-1]]
    |                                         ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:454:63: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the literal ‘50’
      prevents the constraint ‘(Num a3)’ from being solved.
      Relevant bindings include
        i :: a3 (bound at test/RealWorldCabalTestSpec.hs:454:69)
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘mod’, namely ‘50’
      In the first argument of ‘fromIntegral’, namely ‘(i `mod` 50)’
      In the second argument of ‘(+)’, namely ‘fromIntegral (i `mod` 50)’
    |
454 |               expectedDisk = sum [5.0 + fromIntegral (i `mod` 50) | i <- [0..actualContainers-1]]
    |                                                               ^^

test/RealWorldCabalTestSpec.hs:454:74: error: [GHC-39999]
    • Ambiguous type variable ‘a3’ arising from the arithmetic sequence ‘0 .. actualContainers
                                                                                - 1’
      prevents the constraint ‘(Enum a3)’ from being solved.
      Relevant bindings include
        actualContainers :: a3
          (bound at test/RealWorldCabalTestSpec.hs:415:13)
        containerCount :: a3
          (bound at test/RealWorldCabalTestSpec.hs:414:8)
      Probable fix: use a type annotation to specify what ‘a3’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [0 .. actualContainers - 1]
      In a stmt of a list comprehension: i <- [0 .. actualContainers - 1]
      In the first argument of ‘sum’, namely
        ‘[5.0 + fromIntegral (i `mod` 50) |
            i <- [0 .. actualContainers - 1]]’
    |
454 |               expectedDisk = sum [5.0 + fromIntegral (i `mod` 50) | i <- [0..actualContainers-1]]
    |                                                                          ^^^^^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:463:45: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a4)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ userCount
               -> let actualUsers = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle mobile app metrics"
          $ property
              $ \ userCount
                  -> let actualUsers = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
463 |     it "should handle mobile app metrics" $ property $
    |                                             ^^^^^^^^

test/RealWorldCabalTestSpec.hs:465:27: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 43 others
        ...plus 130 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 1 (abs userCount `mod` 100 + 1)
      In an equation for ‘actualUsers’:
          actualUsers = max 1 (abs userCount `mod` 100 + 1)
      In the expression:
        let actualUsers = max 1 (abs userCount `mod` 100 + 1)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 appLaunches <- createMetric "app_launches" "count"
                 screenViews <- createMetric "screen_views" "count"
                 ....
    |
465 |         let actualUsers = max 1 (abs userCount `mod` 100 + 1)
    |                           ^^^

test/RealWorldCabalTestSpec.hs:465:31: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from the literal ‘1’
      prevents the constraint ‘(Num a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘1’
      In the expression: max 1 (abs userCount `mod` 100 + 1)
      In an equation for ‘actualUsers’:
          actualUsers = max 1 (abs userCount `mod` 100 + 1)
    |
465 |         let actualUsers = max 1 (abs userCount `mod` 100 + 1)
    |                               ^

test/RealWorldCabalTestSpec.hs:465:48: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely ‘abs userCount `mod` 100’
      In the second argument of ‘max’, namely
        ‘(abs userCount `mod` 100 + 1)’
      In the expression: max 1 (abs userCount `mod` 100 + 1)
    |
465 |         let actualUsers = max 1 (abs userCount `mod` 100 + 1)
    |                                                ^^^^^

test/RealWorldCabalTestSpec.hs:478:21: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualUsers
      In the first argument of ‘forM_’, namely
        ‘[1 .. fromIntegral actualUsers]’
      In the first argument of ‘($)’, namely
        ‘forM_ [1 .. fromIntegral actualUsers]’
    |
478 |           forM_ [1..fromIntegral actualUsers] $ \userId -> do
    |                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:505:34: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualUsers
      In an equation for ‘expectedLaunches’:
          expectedLaunches = fromIntegral actualUsers
      In a stmt of a 'do' block:
        let expectedLaunches = fromIntegral actualUsers
            expectedScreenViews = fromIntegral actualUsers * 5
            expectedActions = fromIntegral actualUsers * 10
            expectedCrashes = fromIntegral (actualUsers `div` 20)
    |
505 |           let expectedLaunches = fromIntegral actualUsers
    |                                  ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:506:37: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(*)’, namely ‘fromIntegral actualUsers’
      In the expression: fromIntegral actualUsers * 5
      In an equation for ‘expectedScreenViews’:
          expectedScreenViews = fromIntegral actualUsers * 5
    |
506 |               expectedScreenViews = fromIntegral actualUsers * 5
    |                                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:507:33: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(*)’, namely ‘fromIntegral actualUsers’
      In the expression: fromIntegral actualUsers * 10
      In an equation for ‘expectedActions’:
          expectedActions = fromIntegral actualUsers * 10
    |
507 |               expectedActions = fromIntegral actualUsers * 10
    |                                 ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:508:33: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral (actualUsers `div` 20)
      In an equation for ‘expectedCrashes’:
          expectedCrashes = fromIntegral (actualUsers `div` 20)
      In a stmt of a 'do' block:
        let expectedLaunches = fromIntegral actualUsers
            expectedScreenViews = fromIntegral actualUsers * 5
            expectedActions = fromIntegral actualUsers * 10
            expectedCrashes = fromIntegral (actualUsers `div` 20)
    |
508 |               expectedCrashes = fromIntegral (actualUsers `div` 20)
    |                                 ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:508:65: error: [GHC-39999]
    • Ambiguous type variable ‘a4’ arising from the literal ‘20’
      prevents the constraint ‘(Num a4)’ from being solved.
      Relevant bindings include
        actualUsers :: a4 (bound at test/RealWorldCabalTestSpec.hs:465:13)
        userCount :: a4 (bound at test/RealWorldCabalTestSpec.hs:464:8)
      Probable fix: use a type annotation to specify what ‘a4’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘div’, namely ‘20’
      In the first argument of ‘fromIntegral’, namely
        ‘(actualUsers `div` 20)’
      In the expression: fromIntegral (actualUsers `div` 20)
    |
508 |               expectedCrashes = fromIntegral (actualUsers `div` 20)
    |                                                                 ^^

test/RealWorldCabalTestSpec.hs:517:47: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a5)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ deviceCount
               -> let actualDevices = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle IoT device telemetry"
          $ property
              $ \ deviceCount
                  -> let actualDevices = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
517 |     it "should handle IoT device telemetry" $ property $
    |                                               ^^^^^^^^

test/RealWorldCabalTestSpec.hs:519:29: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 43 others
        ...plus 130 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 1 (abs deviceCount `mod` 50 + 1)
      In an equation for ‘actualDevices’:
          actualDevices = max 1 (abs deviceCount `mod` 50 + 1)
      In the expression:
        let actualDevices = max 1 (abs deviceCount `mod` 50 + 1)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 deviceMessages <- createMetric "device_messages" "count"
                 sensorReadings <- createMetric "sensor_readings" "count"
                 ....
    |
519 |         let actualDevices = max 1 (abs deviceCount `mod` 50 + 1)
    |                             ^^^

test/RealWorldCabalTestSpec.hs:519:33: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the literal ‘1’
      prevents the constraint ‘(Num a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘1’
      In the expression: max 1 (abs deviceCount `mod` 50 + 1)
      In an equation for ‘actualDevices’:
          actualDevices = max 1 (abs deviceCount `mod` 50 + 1)
    |
519 |         let actualDevices = max 1 (abs deviceCount `mod` 50 + 1)
    |                                 ^

test/RealWorldCabalTestSpec.hs:519:52: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely ‘abs deviceCount `mod` 50’
      In the second argument of ‘max’, namely
        ‘(abs deviceCount `mod` 50 + 1)’
      In the expression: max 1 (abs deviceCount `mod` 50 + 1)
    |
519 |         let actualDevices = max 1 (abs deviceCount `mod` 50 + 1)
    |                                                    ^^^^^

test/RealWorldCabalTestSpec.hs:532:21: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualDevices
      In the first argument of ‘forM_’, namely
        ‘[1 .. fromIntegral actualDevices]’
      In the first argument of ‘($)’, namely
        ‘forM_ [1 .. fromIntegral actualDevices]’
    |
532 |           forM_ [1..fromIntegral actualDevices] $ \deviceId -> do
    |                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:559:39: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a5)’ from being solved.
      Relevant bindings include
        i :: a5 (bound at test/RealWorldCabalTestSpec.hs:559:72)
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral (10 + i `mod` 20)
      In the first argument of ‘sum’, namely
        ‘[fromIntegral (10 + i `mod` 20) | i <- [0 .. actualDevices - 1]]’
      In the expression:
        sum
          [fromIntegral (10 + i `mod` 20) | i <- [0 .. actualDevices - 1]]
    |
559 |           let expectedMessages = sum [fromIntegral (10 + i `mod` 20) | i <- [0..actualDevices-1]]
    |                                       ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:559:53: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the literal ‘10’
      prevents the constraint ‘(Num a5)’ from being solved.
      Relevant bindings include
        i :: a5 (bound at test/RealWorldCabalTestSpec.hs:559:72)
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely ‘10’
      In the first argument of ‘fromIntegral’, namely ‘(10 + i `mod` 20)’
      In the expression: fromIntegral (10 + i `mod` 20)
    |
559 |           let expectedMessages = sum [fromIntegral (10 + i `mod` 20) | i <- [0..actualDevices-1]]
    |                                                     ^^

test/RealWorldCabalTestSpec.hs:559:77: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the arithmetic sequence ‘0 .. actualDevices
                                                                                - 1’
      prevents the constraint ‘(Enum a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [0 .. actualDevices - 1]
      In a stmt of a list comprehension: i <- [0 .. actualDevices - 1]
      In the first argument of ‘sum’, namely
        ‘[fromIntegral (10 + i `mod` 20) | i <- [0 .. actualDevices - 1]]’
    |
559 |           let expectedMessages = sum [fromIntegral (10 + i `mod` 20) | i <- [0..actualDevices-1]]
    |                                                                             ^^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:560:39: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a5)’ from being solved.
      Relevant bindings include
        i :: a5 (bound at test/RealWorldCabalTestSpec.hs:560:73)
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral (50 + i `mod` 100)
      In the first argument of ‘sum’, namely
        ‘[fromIntegral (50 + i `mod` 100) | i <- [0 .. actualDevices - 1]]’
      In the expression:
        sum
          [fromIntegral (50 + i `mod` 100) | i <- [0 .. actualDevices - 1]]
    |
560 |               expectedReadings = sum [fromIntegral (50 + i `mod` 100) | i <- [0..actualDevices-1]]
    |                                       ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:560:53: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the literal ‘50’
      prevents the constraint ‘(Num a5)’ from being solved.
      Relevant bindings include
        i :: a5 (bound at test/RealWorldCabalTestSpec.hs:560:73)
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely ‘50’
      In the first argument of ‘fromIntegral’, namely
        ‘(50 + i `mod` 100)’
      In the expression: fromIntegral (50 + i `mod` 100)
    |
560 |               expectedReadings = sum [fromIntegral (50 + i `mod` 100) | i <- [0..actualDevices-1]]
    |                                                     ^^

test/RealWorldCabalTestSpec.hs:560:78: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the arithmetic sequence ‘0 .. actualDevices
                                                                                - 1’
      prevents the constraint ‘(Enum a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [0 .. actualDevices - 1]
      In a stmt of a list comprehension: i <- [0 .. actualDevices - 1]
      In the first argument of ‘sum’, namely
        ‘[fromIntegral (50 + i `mod` 100) | i <- [0 .. actualDevices - 1]]’
    |
560 |               expectedReadings = sum [fromIntegral (50 + i `mod` 100) | i <- [0..actualDevices-1]]
    |                                                                              ^^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:561:32: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral (actualDevices `div` 10)
      In an equation for ‘expectedErrors’:
          expectedErrors = fromIntegral (actualDevices `div` 10)
      In a stmt of a 'do' block:
        let expectedMessages
              = sum
                  [fromIntegral (10 + i `mod` 20) | i <- [0 .. actualDevices - 1]]
            expectedReadings
              = sum
                  [fromIntegral (50 + i `mod` 100) | i <- [0 .. actualDevices - 1]]
            expectedErrors = fromIntegral (actualDevices `div` 10)
            expectedBattery
              = sum
                  [100.0 - fromIntegral (i `mod` 50) | i <- [0 .. actualDevices - 1]]
    |
561 |               expectedErrors = fromIntegral (actualDevices `div` 10)
    |                                ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:561:66: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the literal ‘10’
      prevents the constraint ‘(Num a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘div’, namely ‘10’
      In the first argument of ‘fromIntegral’, namely
        ‘(actualDevices `div` 10)’
      In the expression: fromIntegral (actualDevices `div` 10)
    |
561 |               expectedErrors = fromIntegral (actualDevices `div` 10)
    |                                                                  ^^

test/RealWorldCabalTestSpec.hs:562:46: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a5)’ from being solved.
      Relevant bindings include
        i :: a5 (bound at test/RealWorldCabalTestSpec.hs:562:74)
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘(-)’, namely
        ‘fromIntegral (i `mod` 50)’
      In the expression: 100.0 - fromIntegral (i `mod` 50)
      In the first argument of ‘sum’, namely
        ‘[100.0 - fromIntegral (i `mod` 50) |
            i <- [0 .. actualDevices - 1]]’
    |
562 |               expectedBattery = sum [100.0 - fromIntegral (i `mod` 50) | i <- [0..actualDevices-1]]
    |                                              ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:562:68: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the literal ‘50’
      prevents the constraint ‘(Num a5)’ from being solved.
      Relevant bindings include
        i :: a5 (bound at test/RealWorldCabalTestSpec.hs:562:74)
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘mod’, namely ‘50’
      In the first argument of ‘fromIntegral’, namely ‘(i `mod` 50)’
      In the second argument of ‘(-)’, namely ‘fromIntegral (i `mod` 50)’
    |
562 |               expectedBattery = sum [100.0 - fromIntegral (i `mod` 50) | i <- [0..actualDevices-1]]
    |                                                                    ^^

test/RealWorldCabalTestSpec.hs:562:79: error: [GHC-39999]
    • Ambiguous type variable ‘a5’ arising from the arithmetic sequence ‘0 .. actualDevices
                                                                                - 1’
      prevents the constraint ‘(Enum a5)’ from being solved.
      Relevant bindings include
        actualDevices :: a5
          (bound at test/RealWorldCabalTestSpec.hs:519:13)
        deviceCount :: a5 (bound at test/RealWorldCabalTestSpec.hs:518:8)
      Probable fix: use a type annotation to specify what ‘a5’ should be.
      Potentially matching instances:
        instance Enum a => Enum (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Enum a => Enum (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 19 others
        ...plus 71 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: [0 .. actualDevices - 1]
      In a stmt of a list comprehension: i <- [0 .. actualDevices - 1]
      In the first argument of ‘sum’, namely
        ‘[100.0 - fromIntegral (i `mod` 50) |
            i <- [0 .. actualDevices - 1]]’
    |
562 |               expectedBattery = sum [100.0 - fromIntegral (i `mod` 50) | i <- [0..actualDevices-1]]
    |                                                                               ^^^^^^^^^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:571:46: error: [GHC-39999]
    • Ambiguous type variable ‘a6’ arising from a use of ‘property’
      prevents the constraint ‘(Arbitrary a6)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a6’ should be.
      Potentially matching instances:
        instance Arbitrary ASCIIString
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Arbitrary a => Arbitrary (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 40 others
        ...plus 96 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘($)’, namely ‘property’
      In the second argument of ‘($)’, namely
        ‘property
           $ \ playerCount
               -> let actualPlayers = ...
                  in
                    unsafePerformIO
                      $ do initTelemetry productionConfig
                           ....’
      In a stmt of a 'do' block:
        it "should handle game server metrics"
          $ property
              $ \ playerCount
                  -> let actualPlayers = ...
                     in
                       unsafePerformIO
                         $ do initTelemetry productionConfig
                              ....
    |
571 |     it "should handle game server metrics" $ property $
    |                                              ^^^^^^^^

test/RealWorldCabalTestSpec.hs:573:29: error: [GHC-39999]
    • Ambiguous type variable ‘a6’ arising from a use of ‘max’
      prevents the constraint ‘(Ord a6)’ from being solved.
      Relevant bindings include
        actualPlayers :: a6
          (bound at test/RealWorldCabalTestSpec.hs:573:13)
        playerCount :: a6 (bound at test/RealWorldCabalTestSpec.hs:572:8)
      Probable fix: use a type annotation to specify what ‘a6’ should be.
      Potentially matching instances:
        instance Ord ASCIIString -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Ord a => Ord (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 43 others
        ...plus 130 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: max 1 (abs playerCount `mod` 100 + 1)
      In an equation for ‘actualPlayers’:
          actualPlayers = max 1 (abs playerCount `mod` 100 + 1)
      In the expression:
        let actualPlayers = max 1 (abs playerCount `mod` 100 + 1)
        in
          unsafePerformIO
            $ do initTelemetry productionConfig
                 activePlayers <- createMetric "active_players" "count"
                 gameSessions <- createMetric "game_sessions" "count"
                 ....
    |
573 |         let actualPlayers = max 1 (abs playerCount `mod` 100 + 1)
    |                             ^^^

test/RealWorldCabalTestSpec.hs:573:33: error: [GHC-39999]
    • Ambiguous type variable ‘a6’ arising from the literal ‘1’
      prevents the constraint ‘(Num a6)’ from being solved.
      Relevant bindings include
        actualPlayers :: a6
          (bound at test/RealWorldCabalTestSpec.hs:573:13)
        playerCount :: a6 (bound at test/RealWorldCabalTestSpec.hs:572:8)
      Probable fix: use a type annotation to specify what ‘a6’ should be.
      Potentially matching instances:
        instance Num a => Num (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Num a => Num (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus 8 others
        ...plus 52 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘max’, namely ‘1’
      In the expression: max 1 (abs playerCount `mod` 100 + 1)
      In an equation for ‘actualPlayers’:
          actualPlayers = max 1 (abs playerCount `mod` 100 + 1)
    |
573 |         let actualPlayers = max 1 (abs playerCount `mod` 100 + 1)
    |                                 ^

test/RealWorldCabalTestSpec.hs:573:52: error: [GHC-39999]
    • Ambiguous type variable ‘a6’ arising from a use of ‘mod’
      prevents the constraint ‘(Integral a6)’ from being solved.
      Relevant bindings include
        actualPlayers :: a6
          (bound at test/RealWorldCabalTestSpec.hs:573:13)
        playerCount :: a6 (bound at test/RealWorldCabalTestSpec.hs:572:8)
      Probable fix: use a type annotation to specify what ‘a6’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the first argument of ‘(+)’, namely
        ‘abs playerCount `mod` 100’
      In the second argument of ‘max’, namely
        ‘(abs playerCount `mod` 100 + 1)’
      In the expression: max 1 (abs playerCount `mod` 100 + 1)
    |
573 |         let actualPlayers = max 1 (abs playerCount `mod` 100 + 1)
    |                                                    ^^^^^

test/RealWorldCabalTestSpec.hs:586:21: error: [GHC-39999]
    • Ambiguous type variable ‘a6’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a6)’ from being solved.
      Relevant bindings include
        actualPlayers :: a6
          (bound at test/RealWorldCabalTestSpec.hs:573:13)
        playerCount :: a6 (bound at test/RealWorldCabalTestSpec.hs:572:8)
      Probable fix: use a type annotation to specify what ‘a6’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualPlayers
      In the first argument of ‘forM_’, namely
        ‘[1 .. fromIntegral actualPlayers]’
      In the first argument of ‘($)’, namely
        ‘forM_ [1 .. fromIntegral actualPlayers]’
    |
586 |           forM_ [1..fromIntegral actualPlayers] $ \playerId -> do
    |                     ^^^^^^^^^^^^

test/RealWorldCabalTestSpec.hs:613:45: error: [GHC-39999]
    • Ambiguous type variable ‘a6’ arising from a use of ‘fromIntegral’
      prevents the constraint ‘(Integral a6)’ from being solved.
      Relevant bindings include
        actualPlayers :: a6
          (bound at test/RealWorldCabalTestSpec.hs:573:13)
        playerCount :: a6 (bound at test/RealWorldCabalTestSpec.hs:572:8)
      Probable fix: use a type annotation to specify what ‘a6’ should be.
      Potentially matching instances:
        instance Integral a => Integral (Blind a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        instance Integral a => Integral (Fixed a)
          -- Defined in ‘Test.QuickCheck.Modifiers’
        ...plus six others
        ...plus 33 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the expression: fromIntegral actualPlayers
      In the expression: [1 .. fromIntegral actualPlayers]
      In a stmt of a list comprehension:
        _ <- [1 .. fromIntegral actualPlayers]
    |
613 |                                    _ <- [1..fromIntegral actualPlayers], i <- [1..20]]
    |                                             ^^^^^^^^^^^^

