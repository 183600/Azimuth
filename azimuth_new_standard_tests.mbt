// Azimuth é¡¹ç›®æ–°çš„æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// åŒ…å«10ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•

test "addition_chain_calculation" {
  // æµ‹è¯•é“¾å¼åŠ æ³•è®¡ç®—
  let base = 100
  let increment1 = 25
  let increment2 = 30
  let increment3 = 45
  
  // é“¾å¼åŠ æ³•
  let result1 = add(add(add(base, increment1), increment2), increment3)
  assert_eq(200, result1)
  
  // æµ‹è¯•è´Ÿæ•°é“¾å¼åŠ æ³•
  let base2 = 500
  let decrement1 = 100
  let decrement2 = 150
  let decrement3 = 50
  
  let result2 = add(add(add(base2, -decrement1), -decrement2), -decrement3)
  assert_eq(200, result2)
}

test "multiplication_power_simulation" {
  // æµ‹è¯•é€šè¿‡ä¹˜æ³•æ¨¡æ‹Ÿå¹‚è¿ç®—
  let base = 3
  let exponent = 4
  
  // è®¡ç®— 3^4 = 3 Ã— 3 Ã— 3 Ã— 3 = 81
  let power_result = multiply(multiply(multiply(base, base), base), base)
  assert_eq(81, power_result)
  
  // æµ‹è¯•è´Ÿæ•°çš„å¹‚
  let neg_base = -2
  let even_exponent = 3
  
  // è®¡ç®— (-2)^3 = -2 Ã— -2 Ã— -2 = -8
  let neg_power_result = multiply(multiply(neg_base, neg_base), neg_base)
  assert_eq(-8, neg_power_result)
}

test "string_unicode_handling" {
  // æµ‹è¯•å­—ç¬¦ä¸²Unicodeå¤„ç†
  // æµ‹è¯•ä¸­æ–‡å­—ç¬¦
  let chinese_name = "å¼ ä¸‰"
  let chinese_result = greet(chinese_name)
  assert_eq_string("Hello, å¼ ä¸‰!", chinese_result)
  
  // æµ‹è¯•emojiå­—ç¬¦
  let emoji_name = "ğŸš€"
  let emoji_result = greet(emoji_name)
  assert_eq_string("Hello, ğŸš€!", emoji_result)
  
  // æµ‹è¯•æ··åˆUnicodeå­—ç¬¦
  let mixed_name = "æµ‹è¯•123ğŸŒŸ"
  let mixed_result = greet(mixed_name)
  assert_eq_string("Hello, æµ‹è¯•123ğŸŒŸ!", mixed_result)
}

test "mathematical_series_fibonacci" {
  // æµ‹è¯•æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  // è®¡ç®—å‰å‡ é¡¹ï¼š1, 1, 2, 3, 5, 8, 13, 21
  
  let f1 = 1
  let f2 = 1
  let f3 = add(f1, f2)  // 2
  let f4 = add(f2, f3)  // 3
  let f5 = add(f3, f4)  // 5
  let f6 = add(f4, f5)  // 8
  let f7 = add(f5, f6)  // 13
  let f8 = add(f6, f7)  // 21
  
  assert_eq(2, f3)
  assert_eq(3, f4)
  assert_eq(5, f5)
  assert_eq(8, f6)
  assert_eq(13, f7)
  assert_eq(21, f8)
  
  // è®¡ç®—å‰8é¡¹çš„å’Œ
  let sum = add(add(add(add(add(add(add(f1, f2), f3), f4), f5), f6), f7), f8)
  assert_eq(54, sum)
}

test "business_profit_calculation" {
  // æµ‹è¯•å•†ä¸šåˆ©æ¶¦è®¡ç®—
  let revenue = 50000
  let cost1 = 20000
  let cost2 = 15000
  let cost3 = 8000
  let tax_rate = 10  // 10%
  
  // è®¡ç®—æ€»æˆæœ¬
  let total_cost = add(add(cost1, cost2), cost3)
  assert_eq(43000, total_cost)
  
  // è®¡ç®—ç¨å‰åˆ©æ¶¦
  let profit_before_tax = add(revenue, -total_cost)
  assert_eq(7000, profit_before_tax)
  
  // è®¡ç®—ç¨è´¹
  let tax = multiply(profit_before_tax, tax_rate) / 100
  assert_eq(700, tax)
  
  // è®¡ç®—å‡€åˆ©æ¶¦
  let net_profit = add(profit_before_tax, -tax)
  assert_eq(6300, net_profit)
}

test "geometry_volume_calculations" {
  // æµ‹è¯•å‡ ä½•ä½“ç§¯è®¡ç®—
  let length = 10
  let width = 5
  let height = 3
  
  // è®¡ç®—é•¿æ–¹ä½“ä½“ç§¯
  let volume = multiply(multiply(length, width), height)
  assert_eq(150, volume)
  
  // è®¡ç®—è¡¨é¢ç§¯ï¼ˆç®€åŒ–ï¼‰ï¼š2 Ã— (é•¿Ã—å®½ + é•¿Ã—é«˜ + å®½Ã—é«˜)
  let area1 = multiply(length, width)   // 50
  let area2 = multiply(length, height)  // 30
  let area3 = multiply(width, height)   // 15
  let surface_area = multiply(2, add(add(area1, area2), area3))
  assert_eq(190, surface_area)
  
  // è®¡ç®—ç«‹æ–¹ä½“ä½“ç§¯ï¼ˆè¾¹é•¿ä¸º4ï¼‰
  let cube_side = 4
  let cube_volume = multiply(multiply(cube_side, cube_side), cube_side)
  assert_eq(64, cube_volume)
}

test "digital_clock_conversion" {
  // æµ‹è¯•æ•°å­—æ—¶é’Ÿè½¬æ¢
  let total_hours = 38
  
  // è½¬æ¢ä¸ºå¤©å’Œå°æ—¶
  let days = total_hours / 24
  let remaining_hours = total_hours % 24
  
  assert_eq(1, days)
  assert_eq(14, remaining_hours)
  
  // æµ‹è¯•åˆ†é’Ÿè½¬æ¢
  let total_minutes = 150
  
  // è½¬æ¢ä¸ºå°æ—¶å’Œåˆ†é’Ÿ
  let hours = total_minutes / 60
  let minutes = total_minutes % 60
  
  assert_eq(2, hours)
  assert_eq(30, minutes)
  
  // è®¡ç®—æ€»ç§’æ•°
  let total_seconds = multiply(total_minutes, 60)
  assert_eq(9000, total_seconds)
}

test "array_sum_simulation" {
  // æ¨¡æ‹Ÿæ•°ç»„æ±‚å’Œï¼ˆé€šè¿‡æ‰‹åŠ¨å±•å¼€ï¼‰
  // æ¨¡æ‹Ÿæ•°ç»„ [10, 20, 30, 40, 50]
  let elem1 = 10
  let elem2 = 20
  let elem3 = 30
  let elem4 = 40
  let elem5 = 50
  
  // è®¡ç®—æ€»å’Œ
  let sum = add(add(add(add(elem1, elem2), elem3), elem4), elem5)
  assert_eq(150, sum)
  
  // è®¡ç®—å¹³å‡å€¼
  let count = 5
  let average = sum / count
  assert_eq(30, average)
  
  // è®¡ç®—åŠ æƒå¹³å‡ï¼ˆæƒé‡åˆ†åˆ«ä¸º1, 2, 3, 4, 5ï¼‰
  let weighted_sum = add(add(add(add(multiply(elem1, 1), multiply(elem2, 2)), 
                               multiply(elem3, 3)), multiply(elem4, 4)), multiply(elem5, 5))
  let total_weight = add(add(add(add(1, 2), 3), 4), 5)
  let weighted_average = weighted_sum / total_weight
  assert_eq(36, weighted_average)
}

test "conditional_arithmetic_operations" {
  // æµ‹è¯•æ¡ä»¶ç®—æœ¯è¿ç®—
  let a = 15
  let b = 20
  let c = 25
  
  // æ¡ä»¶1ï¼šå¦‚æœ a < bï¼Œåˆ™è®¡ç®— a + bï¼Œå¦åˆ™è®¡ç®— a * b
  let condition1 = a < b
  let result1 = if condition1 { add(a, b) } else { multiply(a, b) }
  assert_eq(35, result1)
  
  // æ¡ä»¶2ï¼šå¦‚æœ b > cï¼Œåˆ™è®¡ç®— b - cï¼Œå¦åˆ™è®¡ç®— c - b
  let condition2 = b > c
  let result2 = if condition2 { add(b, -c) } else { add(c, -b) }
  assert_eq(5, result2)
  
  // æ¡ä»¶3ï¼šå¦‚æœ a + b > cï¼Œåˆ™è®¡ç®— (a + b) * 2ï¼Œå¦åˆ™è®¡ç®— (a + b) / 2
  let sum_ab = add(a, b)
  let condition3 = sum_ab > c
  let result3 = if condition3 { multiply(sum_ab, 2) } else { sum_ab / 2 }
  assert_eq(70, result3)
}

test "boundary_value_extreme_combinations" {
  // æµ‹è¯•è¾¹ç•Œå€¼çš„æç«¯ç»„åˆ
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼çš„å¹³æ–¹ï¼ˆåº”è¯¥æº¢å‡ºï¼‰
  let max_squared = multiply(max_val, max_val)
  assert_eq(max_val, max_squared)
  
  // æµ‹è¯•æœ€å°å€¼çš„å¹³æ–¹ï¼ˆåº”è¯¥æº¢å‡ºï¼‰
  let min_squared = multiply(min_val, min_val)
  assert_eq(max_val, min_squared)
  
  // æµ‹è¯•æœ€å¤§å€¼ä¸æœ€å°å€¼çš„ä¹˜ç§¯
  let max_min_product = multiply(max_val, min_val)
  assert_eq(min_val, max_min_product)
  
  // æµ‹è¯•è¿ç»­è¾¹ç•Œå€¼è¿ç®—
  let chain1 = add(add(max_val, min_val), max_val)
  assert_eq(max_val, chain1)
  
  let chain2 = multiply(multiply(min_val, -1), -1)
  assert_eq(min_val, chain2)
  
  // æµ‹è¯•è¾¹ç•Œå€¼çš„ç®—æœ¯åºåˆ—
  let sequence_sum = add(add(add(add(min_val, 1), 2), 4), 8)
  assert_eq(-2147483633, sequence_sum)
}