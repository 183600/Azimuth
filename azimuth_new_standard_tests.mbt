// Azimuth é¡¹ç›®æ–°å¢æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡†çš„ MoonBit æµ‹è¯•è¯­æ³•ï¼Œè¦†ç›–æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

test "complex_arithmetic_sequence" {
  // æµ‹è¯•å¤æ‚ç®—æœ¯åºåˆ—è®¡ç®—
  // è®¡ç®— (a + b) * (c - d) + e * f
  let a = 10
  let b = 5
  let c = 20
  let d = 8
  let e = 3
  let f = 7
  
  let sum_ab = add(a, b)  // 15
  let diff_cd = add(c, -d)  // 12
  let product_ef = multiply(e, f)  // 21
  let product_ab_cd = multiply(sum_ab, diff_cd)  // 180
  let result = add(product_ab_cd, product_ef)  // 201
  
  assert_eq(201, result)
}

test "string_processing_edge_cases" {
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„è¾¹ç•Œæƒ…å†µ
  // æµ‹è¯•åŒ…å«å„ç§ç‰¹æ®Šå­—ç¬¦çš„å­—ç¬¦ä¸²
  let special_chars = "!@#$%^&*()_+-=[]{}|;':\",./<>?"
  let result_special = greet(special_chars)
  assert_eq_string("Hello, !@#$%^&*()_+-=[]{}|;':\",./<>?!", result_special)
  
  // æµ‹è¯•åŒ…å«Unicodeå­—ç¬¦çš„å­—ç¬¦ä¸²
  let unicode_chars = "ğŸŒŸMoonBitğŸš€"
  let result_unicode = greet(unicode_chars)
  assert_eq_string("Hello, ğŸŒŸMoonBitğŸš€!", result_unicode)
  
  // æµ‹è¯•åŒ…å«æ•°å­—å’Œå­—æ¯æ··åˆçš„å­—ç¬¦ä¸²
  let mixed_alphanumeric = "Test123ABC456"
  let result_mixed = greet(mixed_alphanumeric)
  assert_eq_string("Hello, Test123ABC456!", result_mixed)
}

test "mathematical_series_calculations" {
  // æµ‹è¯•æ•°å­¦çº§æ•°è®¡ç®—
  // è®¡ç®—ç­‰å·®æ•°åˆ—å‰né¡¹å’Œï¼š1 + 4 + 7 + 10 + 13 (å…¬å·®ä¸º3ï¼Œå‰5é¡¹)
  let n = 5
  let first_term = 1
  let common_diff = 3
  
  // ä½¿ç”¨å…¬å¼ï¼šS_n = n/2 * (2*a_1 + (n-1)*d)
  let sum_n = multiply(n, add(multiply(2, first_term), multiply(n - 1, common_diff))) / 2
  assert_eq(35, sum_n)  // 1 + 4 + 7 + 10 + 13 = 35
  
  // è®¡ç®—ç­‰æ¯”æ•°åˆ—å‰né¡¹ç§¯ï¼š2 * 4 * 8 * 16 (å…¬æ¯”ä¸º2ï¼Œå‰4é¡¹)
  let ratio = 2
  let geo_product = multiply(multiply(multiply(2, multiply(2, ratio)), multiply(4, ratio)), multiply(8, ratio))
  assert_eq(1024, geo_product)  // 2 * 4 * 8 * 16 = 1024
}

test "real_world_financial_calculations" {
  // æµ‹è¯•å®é™…é‡‘èè®¡ç®—åœºæ™¯
  // é“¶è¡Œå­˜æ¬¾å¤åˆ©è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let principal = 10000  // æœ¬é‡‘
  let annual_rate = 5  // å¹´åˆ©ç‡5%
  let years = 3  // å­˜æ¬¾å¹´é™
  
  // ç®€åŒ–å¤åˆ©è®¡ç®—ï¼šæœ¬æ¯å’Œ = æœ¬é‡‘ * (1 + å¹´åˆ©ç‡ * å¹´æ•°)
  let growth_factor = add(1, multiply(annual_rate, years))
  let total_amount = multiply(principal, growth_factor)
  assert_eq(160000, total_amount)  // 10000 * (1 + 5*3) = 10000 * 16 = 160000
  
  // è´·æ¬¾æœˆä¾›è®¡ç®—ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let loan_amount = 120000  // è´·æ¬¾æ€»é¢
  let monthly_rate = 1  // æœˆåˆ©ç‡1%
  let months = 12  // è´·æ¬¾æœŸæ•°
  
  // ç®€åŒ–æœˆä¾›è®¡ç®—ï¼šæœˆä¾› = (è´·æ¬¾æ€»é¢ + è´·æ¬¾æ€»é¢ * æœˆåˆ©ç‡ * æœŸæ•°) / æœŸæ•°
  let total_interest = multiply(loan_amount, multiply(monthly_rate, months))
  let total_repayment = add(loan_amount, total_interest)
  let monthly_payment = total_repayment / months
  assert_eq(11000, monthly_payment)  // (120000 + 120000*1*12) / 12 = 264000 / 12 = 22000
}

test "extreme_boundary_conditions" {
  // æµ‹è¯•æç«¯è¾¹ç•Œæ¡ä»¶
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•è¿ç»­æº¢å‡ºè¿ç®—
  let overflow_chain_1 = add(add(max_val, 100), add(200, 300))
  assert_eq(max_val, overflow_chain_1)
  
  let overflow_chain_2 = multiply(multiply(max_val, 2), multiply(3, 4))
  assert_eq(max_val, overflow_chain_2)
  
  // æµ‹è¯•è¿ç»­ä¸‹æº¢è¿ç®—
  let underflow_chain_1 = add(add(min_val, -100), add(-200, -300))
  assert_eq(min_val, underflow_chain_1)
  
  let underflow_chain_2 = multiply(multiply(min_val, 2), multiply(3, 4))
  assert_eq(min_val, underflow_chain_2)
  
  // æµ‹è¯•æ··åˆè¾¹ç•Œè¿ç®—
  let mixed_boundary = add(multiply(max_val, -1), multiply(min_val, -1))
  assert_eq(0, mixed_boundary)
}

test "algorithmic_complexity_simulation" {
  // æµ‹è¯•ç®—æ³•å¤æ‚åº¦æ¨¡æ‹Ÿ
  // æ¨¡æ‹ŸO(nÂ²)ç®—æ³•çš„è®¡ç®—é‡
  let n = 100
  let o_n_squared = multiply(n, n)
  assert_eq(10000, o_n_squared)
  
  // æ¨¡æ‹ŸO(nÂ³)ç®—æ³•çš„è®¡ç®—é‡
  let o_n_cubed = multiply(multiply(n, n), n)
  assert_eq(1000000, o_n_cubed)
  
  // æ¨¡æ‹ŸO(log n)ç®—æ³•çš„è®¡ç®—é‡ï¼ˆç®€åŒ–ä¸ºæ•´æ•°é™¤æ³•ï¼‰
  let o_log_n = n / 2  // ç®€åŒ–è¡¨ç¤º
  assert_eq(50, o_log_n)
  
  // æ¨¡æ‹ŸO(n log n)ç®—æ³•çš„è®¡ç®—é‡
  let o_n_log_n = multiply(n, n / 2)
  assert_eq(5000, o_n_log_n)
}

test "data_structure_operations_simulation" {
  // æµ‹è¯•æ•°æ®ç»“æ„æ“ä½œæ¨¡æ‹Ÿ
  // æ¨¡æ‹Ÿæ•°ç»„ç´¢å¼•è®¡ç®—ï¼šäºŒç»´æ•°ç»„è½¬ä¸€ç»´æ•°ç»„çš„ç´¢å¼•
  let row = 5
  let col = 3
  let width = 10
  
  let index_1d = add(multiply(row, width), col)
  assert_eq(53, index_1d)  // 5 * 10 + 3 = 53
  
  // æ¨¡æ‹Ÿæ ˆæ“ä½œï¼špushå’Œpop
  let stack_top = 100
  let push_value = 200
  let new_top = add(stack_top, push_value)
  assert_eq(300, new_top)
  
  let pop_value = 150
  let popped_top = add(new_top, -pop_value)
  assert_eq(150, popped_top)
  
  // æ¨¡æ‹Ÿé˜Ÿåˆ—æ“ä½œï¼šenqueueå’Œdequeue
  let queue_front = 10
  let queue_rear = 20
  let queue_size = add(queue_rear, -queue_front)
  assert_eq(10, queue_size)
}

test "scientific_calculations" {
  // æµ‹è¯•ç§‘å­¦è®¡ç®—
  // æ¨¡æ‹Ÿæ¸©åº¦è½¬æ¢ï¼šæ‘„æ°åº¦è½¬åæ°åº¦ F = C * 9/5 + 32
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼šF = C * 2 + 32
  let celsius = 25
  let fahrenheit = add(multiply(celsius, 2), 32)
  assert_eq(82, fahrenheit)  // 25 * 2 + 32 = 82
  
  // æ¨¡æ‹Ÿè·ç¦»è½¬æ¢ï¼šå…¬é‡Œè½¬è‹±é‡Œ 1å…¬é‡Œ â‰ˆ 0.62è‹±é‡Œ
  // ç®€åŒ–ä¸ºæ•´æ•°è®¡ç®—ï¼šè‹±é‡Œ = å…¬é‡Œ * 62 / 100
  let kilometers = 100
  let miles = multiply(kilometers, 62) / 100
  assert_eq(62, miles)  // 100 * 62 / 100 = 62
  
  // æ¨¡æ‹Ÿèƒ½é‡è®¡ç®—ï¼šE = mcÂ²ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let mass = 10
  let speed_of_light_squared = multiply(300000, 300000)  // ç®€åŒ–å…‰é€Ÿå€¼
  let energy = multiply(mass, speed_of_light_squared)
  assert_eq(900000000000, energy)  // 10 * 300000Â²
}

test "error_handling_and_validation" {
  // æµ‹è¯•é”™è¯¯å¤„ç†å’ŒéªŒè¯
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æ–­è¨€å‡½æ•°çš„è¾¹ç•Œæƒ…å†µ
  assert_true(add(1000000, 2000000) > 0)
  assert_true(add(-1000000, -2000000) < 0)
  assert_true(multiply(1000, 1000) > 0)
  assert_true(multiply(-1000, 1000) < 0)
  
  // æµ‹è¯•æº¢å‡ºä¿æŠ¤çš„æ­£ç¡®æ€§
  assert_true(add(max_val, 1) == max_val)
  assert_true(add(min_val, -1) == min_val)
  assert_true(multiply(max_val, 2) == max_val)
  assert_true(multiply(min_val, 2) == min_val)
  
  // æµ‹è¯•å­—ç¬¦ä¸²å¤„ç†çš„æ­£ç¡®æ€§
  assert_true(greet("Test") == "Hello, Test!")
  assert_true(greet("") == "Hello, !")
  assert_true(greet("123") == "Hello, 123!")
}

test "comprehensive_integration_test" {
  // ç»¼åˆé›†æˆæµ‹è¯•
  // æ¨¡æ‹Ÿä¸€ä¸ªå¤æ‚çš„ä¸šåŠ¡åœºæ™¯ï¼šç”µå•†è®¢å•å¤„ç†
  
  // å•†å“ä¿¡æ¯
  let product_a_price = 299
  let product_a_quantity = 2
  let product_b_price = 199
  let product_b_quantity = 3
  
  // è®¡ç®—å•†å“æ€»ä»·
  let total_a = multiply(product_a_price, product_a_quantity)  // 598
  let total_b = multiply(product_b_price, product_b_quantity)  // 597
  let subtotal = add(total_a, total_b)  // 1195
  
  // æŠ˜æ‰£è®¡ç®—ï¼šæ»¡1000å‡100
  let discount = if (subtotal >= 1000) { 100 } else { 0 }
  let discounted_total = add(subtotal, -discount)  // 1095
  
  // è¿è´¹è®¡ç®—ï¼šæ»¡500å…è¿è´¹ï¼Œå¦åˆ™è¿è´¹20
  let shipping = if (discounted_total >= 500) { 0 } else { 20 }
  let total_with_shipping = add(discounted_total, shipping)  // 1095
  
  // ç¨è´¹è®¡ç®—ï¼š8%ç¨ç‡
  let tax = multiply(total_with_shipping, 8) / 100  // 87
  let final_total = add(total_with_shipping, tax)  // 1182
  
  assert_eq(1182, final_total)
  
  // ç”Ÿæˆè®¢å•ç¡®è®¤æ¶ˆæ¯ï¼ˆç®€åŒ–ç‰ˆï¼‰
  let order_id = "ORD-2023-001"
  let customer_name = "å¼ ä¸‰"
  let base_confirmation = greet(customer_name) + " æ‚¨çš„è®¢å• " + order_id + " å·²ç¡®è®¤"
  
  // éªŒè¯ç¡®è®¤æ¶ˆæ¯åŒ…å«å¿…è¦ä¿¡æ¯
  let expected_confirmation = "Hello, å¼ ä¸‰! æ‚¨çš„è®¢å• ORD-2023-001 å·²ç¡®è®¤"
  assert_eq_string(expected_confirmation, base_confirmation)
  
  // éªŒè¯æ€»é‡‘é¢è®¡ç®—æ­£ç¡®
  assert_eq(1182, final_total)
}