// Azimuth é¡¹ç›®æ–°å¢æ ‡å‡† MoonBit æµ‹è¯•ç”¨ä¾‹
// ä½¿ç”¨æ ‡å‡† MoonBit æµ‹è¯•è¯­æ³•ï¼Œæä¾›å¤šæ ·åŒ–çš„æµ‹è¯•åœºæ™¯

// å¯¼å…¥å¿…è¦çš„æ¨¡å—
use azimuth

test "mathematical_operations_precision" {
  // æ•°å­¦è¿ç®—ç²¾åº¦æµ‹è¯•
  let a = 123456
  let b = 654321
  
  // æµ‹è¯•å¤§æ•°åŠ æ³•
  let sum_result = azimuth.add(a, b)
  @assertion.assert_eq(777777, sum_result)?
  
  // æµ‹è¯•å¤§æ•°ä¹˜æ³•
  let product_result = azimuth.multiply(123, 456)
  @assertion.assert_eq(56088, product_result)?
  
  // æµ‹è¯•è´Ÿæ•°è¿ç®—
  let negative_result = azimuth.add(-500, 300)
  @assertion.assert_eq(-200, negative_result)?
}

test "boundary_value_comprehensive" {
  // è¾¹ç•Œå€¼ç»¼åˆæµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // æµ‹è¯•æœ€å¤§å€¼çš„å„ç§è¿ç®—
  @assertion.assert_eq(max_val, azimuth.add(max_val, 0))?
  @assertion.assert_eq(max_val, azimuth.add(max_val, -100))?
  @assertion.assert_eq(max_val, azimuth.multiply(max_val, 1))?
  
  // æµ‹è¯•æœ€å°å€¼çš„å„ç§è¿ç®—
  @assertion.assert_eq(min_val, azimuth.add(min_val, 0))?
  @assertion.assert_eq(min_val, azimuth.add(min_val, 100))?
  @assertion.assert_eq(min_val, azimuth.multiply(min_val, 1))?
  
  // æµ‹è¯•æå€¼ç›¸åŠ 
  @assertion.assert_eq(-1, azimuth.add(max_val, min_val))?
}

test "string_processing_variations" {
  // å­—ç¬¦ä¸²å¤„ç†å˜åŒ–æµ‹è¯•
  let normal_string = "MoonBit"
  let empty_string = ""
  let space_string = "   "
  let special_chars = "!@#$%^&*()"
  let unicode_string = "æµ‹è¯•ğŸš€"
  
  // æµ‹è¯•å„ç§å­—ç¬¦ä¸²ç±»å‹
  @assertion.assert_eq_string("Hello, MoonBit!", azimuth.greet(normal_string))?
  @assertion.assert_eq_string("Hello, !", azimuth.greet(empty_string))?
  @assertion.assert_eq_string("Hello,   !", azimuth.greet(space_string))?
  @assertion.assert_eq_string("Hello, !@#$%^&*()!", azimuth.greet(special_chars))?
  @assertion.assert_eq_string("Hello, æµ‹è¯•ğŸš€!", azimuth.greet(unicode_string))?
}

test "complex_calculation_scenarios" {
  // å¤æ‚è®¡ç®—åœºæ™¯æµ‹è¯•
  // åœºæ™¯1ï¼šè®¡ç®—çŸ©å½¢å‘¨é•¿å’Œé¢ç§¯
  let length = 15
  let width = 8
  
  let perimeter = azimuth.add(azimuth.multiply(2, length), azimuth.multiply(2, width))
  let area = azimuth.multiply(length, width)
  
  @assertion.assert_eq(46, perimeter)?  // 2*15 + 2*8 = 46
  @assertion.assert_eq(120, area)?      // 15*8 = 120
  
  // åœºæ™¯2ï¼šè®¡ç®—æŠ˜æ‰£ä»·æ ¼
  let original_price = 1000
  let discount_rate = 20  // 20%æŠ˜æ‰£
  let discounted_price = azimuth.multiply(original_price, azimuth.add(100, -discount_rate)) / 100
  
  @assertion.assert_eq(800, discounted_price)?  // 1000 * (100-20) / 100 = 800
}

test "sequential_operations_chain" {
  // è¿ç»­æ“ä½œé“¾æµ‹è¯•
  let initial_value = 10
  
  // è¿ç»­åŠ æ³•ï¼š10 + 5 + 15 + 20 = 50
  let chain_add = azimuth.add(azimuth.add(azimuth.add(initial_value, 5), 15), 20)
  @assertion.assert_eq(50, chain_add)?
  
  // è¿ç»­ä¹˜æ³•ï¼š2 * 3 * 4 * 5 = 120
  let chain_multiply = azimuth.multiply(azimuth.multiply(azimuth.multiply(2, 3), 4), 5)
  @assertion.assert_eq(120, chain_multiply)?
  
  // æ··åˆæ“ä½œï¼š(10 + 5) * (8 - 3) = 15 * 5 = 75
  let mixed_operation = azimuth.multiply(azimuth.add(10, 5), azimuth.add(8, -3))
  @assertion.assert_eq(75, mixed_operation)?
}

test "error_handling_and_validation" {
  // é”™è¯¯å¤„ç†å’ŒéªŒè¯æµ‹è¯•
  let max_val = 2147483647
  let min_val = -2147483648
  
  // éªŒè¯æº¢å‡ºä¿æŠ¤
  @assertion.assert_eq(max_val, azimuth.add(max_val, 1000))?
  @assertion.assert_eq(min_val, azimuth.add(min_val, -1000))?
  @assertion.assert_eq(max_val, azimuth.multiply(max_val, 10))?
  @assertion.assert_eq(min_val, azimuth.multiply(min_val, 10))?
  
  // éªŒè¯ç‰¹æ®Šå€¼å¤„ç†
  @assertion.assert_eq(0, azimuth.multiply(0, max_val))?
  @assertion.assert_eq(0, azimuth.multiply(0, min_val))?
  @assertion.assert_eq(max_val, azimuth.multiply(max_val, 1))?
  @assertion.assert_eq(min_val, azimuth.multiply(min_val, 1))?
}

test "real_world_application_simulations" {
  // å®é™…åº”ç”¨æ¨¡æ‹Ÿæµ‹è¯•
  // åœºæ™¯1ï¼šé“¶è¡Œåˆ©æ¯è®¡ç®—
  let principal = 10000
  let interest_rate = 5  // 5%
  let years = 3
  
  let simple_interest = azimuth.multiply(principal, azimuth.multiply(interest_rate, years))
  let total_amount = azimuth.add(principal, simple_interest)
  
  @assertion.assert_eq(160000, total_amount)?  // 10000 + 10000*5*3 = 160000
  
  // åœºæ™¯2ï¼šæ¸©åº¦è½¬æ¢ï¼ˆæ‘„æ°åº¦è½¬åæ°åº¦ï¼šF = C * 9/5 + 32ï¼Œç®€åŒ–ä¸º F = C * 2 + 30ï¼‰
  let celsius = 25
  let fahrenheit = azimuth.add(azimuth.multiply(celsius, 2), 30)
  @assertion.assert_eq(80, fahrenheit)?  // 25*2 + 30 = 80
}

test "performance_and_stress" {
  // æ€§èƒ½å’Œå‹åŠ›æµ‹è¯•
  // å¤§æ•°è¿ç®—æµ‹è¯•
  let large_number1 = 1000000
  let large_number2 = 2000000
  
  let large_sum = azimuth.add(large_number1, large_number2)
  let large_product = azimuth.multiply(1000, 1000)
  
  @assertion.assert_eq(3000000, large_sum)?
  @assertion.assert_eq(1000000, large_product)?
  
  // é‡å¤è¿ç®—æµ‹è¯•
  let base = 5
  let result1 = azimuth.add(base, azimuth.add(base, azimuth.add(base, azimuth.add(base, base))))
  let result2 = azimuth.multiply(base, azimuth.multiply(base, azimuth.multiply(base, base)))
  
  @assertion.assert_eq(25, result1)?  // 5+5+5+5+5 = 25
  @assertion.assert_eq(625, result2)? // 5*5*5*5 = 625
}

test "data_type_edge_cases" {
  // æ•°æ®ç±»å‹è¾¹ç•Œæƒ…å†µæµ‹è¯•
  // é›¶å€¼è¿ç®—æµ‹è¯•
  @assertion.assert_eq(0, azimuth.multiply(0, 0))?
  @assertion.assert_eq(0, azimuth.multiply(0, 12345))?
  @assertion.assert_eq(0, azimuth.multiply(12345, 0))?
  @assertion.assert_eq(12345, azimuth.add(0, 12345))?
  @assertion.assert_eq(12345, azimuth.add(12345, 0))?
  @assertion.assert_eq(0, azimuth.add(0, 0))?
  
  // å•ä½è¿ç®—æµ‹è¯•
  @assertion.assert_eq(5, azimuth.multiply(5, 1))?
  @assertion.assert_eq(5, azimuth.multiply(1, 5))?
  @assertion.assert_eq(-5, azimuth.multiply(5, -1))?
  @assertion.assert_eq(-5, azimuth.multiply(-1, 5))?
  
  // ç›¸ç­‰æ•°è¿ç®—æµ‹è¯•
  @assertion.assert_eq(10, azimuth.add(5, 5))?
  @assertion.assert_eq(25, azimuth.multiply(5, 5))?
  @assertion.assert_eq(0, azimuth.add(5, -5))?
  @assertion.assert_eq(-25, azimuth.multiply(-5, 5))?
}