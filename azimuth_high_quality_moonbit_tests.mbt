// Azimuth High-Quality MoonBit Test Suite
// é«˜è´¨é‡MoonBitæµ‹è¯•ç”¨ä¾‹ï¼Œè¦†ç›–é¥æµ‹ç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½å’Œè¾¹ç•Œæƒ…å†µ

// æµ‹è¯•1: Spanç”Ÿå‘½å‘¨æœŸç®¡ç†
test "span lifecycle management with proper state transitions" {
  // åˆ›å»ºSpanä¸Šä¸‹æ–‡
  let span_ctx = @azimuth.SpanContext::new(
    "1234567890abcdef1234567890abcdef",
    "1234567890abcdef",
    true,
    "key1=value1,key2=value2"
  )
  
  // åˆ›å»ºSpan
  let span = @azimuth.Span::new("test-span", @azimuth.Internal, span_ctx)
  
  // éªŒè¯åˆå§‹çŠ¶æ€
  assert_eq(@azimuth.Span::name(span), "test-span")
  assert_eq(@azimuth.Span::kind(span), @azimuth.Internal)
  assert_true(@azimuth.Span::is_recording(span))
  assert_eq(@azimuth.Span::status(span), @azimuth.Unset)
  
  // è®¾ç½®SpançŠ¶æ€
  @azimuth.Span::set_status(span, @azimuth.Ok, Some("Operation completed successfully"))
  
  // æ·»åŠ äº‹ä»¶
  @azimuth.Span::add_event(span, "event1", Some([("key1", @azimuth.StringValue("value1"))]))
  
  // ç»“æŸSpan
  @azimuth.Span::end(span)
  
  // éªŒè¯Spanä¸Šä¸‹æ–‡
  let ctx = @azimuth.Span::span_context(span)
  assert_eq(@azimuth.SpanContext::trace_id(ctx), "1234567890abcdef1234567890abcdef")
  assert_eq(@azimuth.SpanContext::span_id(ctx), "1234567890abcdef")
  assert_true(@azimuth.SpanContext::is_sampled(ctx))
  assert_true(@azimuth.SpanContext::is_valid(ctx))
}

// æµ‹è¯•2: Metricsèšåˆæ“ä½œ
test "metrics aggregation operations with different instrument types" {
  // åˆ›å»ºMeterProviderå’ŒMeter
  let provider = @azimuth.MeterProvider::default()
  let meter = @azimuth.MeterProvider::get_meter(provider, "test-meter")
  
  // åˆ›å»ºCounter
  let counter = @azimuth.Meter::create_counter(meter, "test-counter", Some("Test counter"), Some("count"))
  @azimuth.Counter::add(counter, 10.0, Some(@azimuth.Attributes::new()))
  
  // åˆ›å»ºHistogram
  let histogram = @azimuth.Meter::create_histogram(meter, "test-histogram", Some("Test histogram"), Some("ms"))
  @azimuth.Histogram::record(histogram, 100.5, Some(@azimuth.Attributes::new()))
  
  // åˆ›å»ºUpDownCounter
  let updown_counter = @azimuth.Meter::create_updown_counter(meter, "test-updown", Some("Test up-down counter"), Some("value"))
  @azimuth.UpDownCounter::add(updown_counter, 5.0, Some(@azimuth.Attributes::new()))
  
  // åˆ›å»ºGauge
  let gauge = @azimuth.Meter::create_gauge(meter, "test-gauge", Some("Test gauge"), Some("percent"))
  @azimuth.UpDownCounter::add(@azimuth.UpDownCounter::{ name: gauge.name, description: gauge.description, unit: gauge.unit }, 75.5, Some(@azimuth.Attributes::new()))
  
  // éªŒè¯Instrumentå±æ€§
  let counter_instrument = @azimuth.Counter(histogram.name, histogram.description, histogram.unit)
  assert_eq(@azimuth.Instrument::name(counter_instrument), "test-histogram")
  assert_eq(@azimuth.Instrument::description(counter_instrument), Some("Test histogram"))
  assert_eq(@azimuth.Instrument::unit(counter_instrument), Some("ms"))
}

// æµ‹è¯•3: LogRecordä¸Spanå…³è”
test "log record correlation with span context" {
  // åˆ›å»ºSpanä¸Šä¸‹æ–‡
  let span_ctx = @azimuth.SpanContext::new(
    "abcdef1234567890abcdef1234567890",
    "abcdef1234567890",
    true,
    ""
  )
  
  // åˆ›å»ºå¸¦æœ‰Spanä¸Šä¸‹æ–‡çš„LogRecord
  let log_record = @azimuth.LogRecord::new_with_context(
    @azimuth.Info,
    Some("Operation completed successfully"),
    Some(@azimuth.Attributes::new()),
    Some(1735689600000000000L),
    Some(1735689600000000001L),
    Some(span_ctx.trace_id),
    Some(span_ctx.span_id),
    Some(@azimuth.Context::root())
  )
  
  // éªŒè¯LogRecordå±æ€§
  assert_eq(@azimuth.LogRecord::severity_number(log_record), @azimuth.Info)
  match @azimuth.LogRecord::body(log_record) {
    Some(body) => assert_eq(body, "Operation completed successfully")
    None => assert_true(false)
  }
  assert_eq(@azimuth.LogRecord::trace_id(log_record), Some(span_ctx.trace_id))
  assert_eq(@azimuth.LogRecord::span_id(log_record), Some(span_ctx.span_id))
  
  // åˆ›å»ºLoggerå¹¶å‘å‡ºæ—¥å¿—
  let logger_provider = @azimuth.LoggerProvider::default()
  let logger = @azimuth.LoggerProvider::get_logger(logger_provider, "test-logger")
  @azimuth.Logger::emit(logger, log_record)
}

// æµ‹è¯•4: èµ„æºå±æ€§åˆå¹¶ç­–ç•¥
test "resource attributes merge strategy with precedence rules" {
  // åˆ›å»ºåŸºç¡€èµ„æº
  let base_resource = @azimuth.Resource::with_attributes(
    @azimuth.Resource::new(),
    [
      ("service.name", @azimuth.StringValue("base-service")),
      ("service.version", @azimuth.StringValue("1.0.0")),
      ("deployment.environment", @azimuth.StringValue("development"))
    ]
  )
  
  // åˆ›å»ºè¦†ç›–èµ„æº
  let override_resource = @azimuth.Resource::with_attributes(
    @azimuth.Resource::new(),
    [
      ("service.name", @azimuth.StringValue("override-service")),
      ("host.name", @azimuth.StringValue("prod-server-01")),
      ("deployment.environment", @azimuth.StringValue("production"))
    ]
  )
  
  // åˆå¹¶èµ„æº
  let merged_resource = @azimuth.Resource::merge(base_resource, override_resource)
  
  // éªŒè¯åˆå¹¶ç»“æœ - è¦†ç›–èµ„æºåº”è¯¥æœ‰æ›´é«˜ä¼˜å…ˆçº§
  match @azimuth.Resource::get_attribute(merged_resource, "service.name") {
    Some(@azimuth.StringValue(name)) => assert_eq(name, "override-service")
    _ => assert_true(false)
  }
  
  match @azimuth.Resource::get_attribute(merged_resource, "host.name") {
    Some(@azimuth.StringValue(host)) => assert_eq(host, "prod-server-01")
    _ => assert_true(false)
  }
  
  match @azimuth.Resource::get_attribute(merged_resource, "deployment.environment") {
    Some(@azimuth.StringValue(env)) => assert_eq(env, "production")
    _ => assert_true(false)
  }
  
  // éªŒè¯åŸºç¡€èµ„æºä¸­ç‹¬æœ‰çš„å±æ€§
  match @azimuth.Resource::get_attribute(base_resource, "service.version") {
    Some(@azimuth.StringValue(version)) => assert_eq(version, "1.0.0")
    _ => assert_true(false)
  }
}

// æµ‹è¯•5: è·¨æœåŠ¡ä¼ æ’­ä¸€è‡´æ€§
test "cross-service propagation consistency with composite propagator" {
  // åˆ›å»ºä¼ æ’­å™¨
  let trace_propagator = @azimuth.W3CTraceContextPropagator::new()
  let baggage_propagator = @azimuth.W3CBaggagePropagator::new()
  let composite_propagator = @azimuth.CompositePropagator::new([trace_propagator])
  
  // åˆ›å»ºä¸Šä¸‹æ–‡å’Œè½½ä½“
  let ctx = @azimuth.Context::with_value(
    @azimuth.Context::root(),
    @azimuth.ContextKey::new("correlation.id"),
    "12345-67890"
  )
  
  let carrier = @azimuth.TextMapCarrier::new()
  
  // æ³¨å…¥ä¸Šä¸‹æ–‡
  @azimuth.CompositePropagator::inject(composite_propagator, ctx, carrier)
  
  // éªŒè¯æ³¨å…¥çš„traceparent
  match @azimuth.TextMapCarrier::get(carrier, "traceparent") {
    Some(traceparent) => assert_true(traceparent.length() > 0)
    None => assert_true(false)
  }
  
  // æå–ä¸Šä¸‹æ–‡
  let extracted_ctx = @azimuth.CompositePropagator::extract(composite_propagator, carrier)
  
  // éªŒè¯æå–çš„ä¸Šä¸‹æ–‡
  match @azimuth.Context::get(extracted_ctx, @azimuth.ContextKey::new("extracted")) {
    Some(value) => assert_eq(value, "true")
    None => assert_true(false)
  }
}

// æµ‹è¯•6: å¹¶å‘å®‰å…¨æ€§
test "concurrent safety with shared telemetry resources" {
  // åˆ›å»ºå…±äº«èµ„æº
  let shared_attributes = @azimuth.Attributes::new()
  let shared_resource = @azimuth.Resource::new()
  let shared_baggage = @azimuth.Baggage::new()
  
  // æ¨¡æ‹Ÿå¹¶å‘æ“ä½œ - åœ¨å®é™…ç¯å¢ƒä¸­ä¼šæœ‰çœŸæ­£çš„å¹¶å‘
  // è¿™é‡Œæˆ‘ä»¬éªŒè¯æ•°æ®ç»“æ„çš„åŸºæœ¬çº¿ç¨‹å®‰å…¨æ€§
  
  // å¤šæ¬¡è®¾ç½®å±æ€§
  for i = 0; i < 10; i = i + 1 {
    @azimuth.Attributes::set(shared_attributes, "key." + i.to_string(), @azimuth.IntValue(i))
  }
  
  // å¤šæ¬¡æ“ä½œBaggage
  let baggage1 = @azimuth.Baggage::set_entry(shared_baggage, "user.id", "12345")
  let baggage2 = @azimuth.Baggage::set_entry(baggage1, "request.id", "req-67890")
  let baggage3 = @azimuth.Baggage::remove_entry(baggage2, "user.id")
  
  // éªŒè¯æ“ä½œç»“æœ
  match @azimuth.Attributes::get(shared_attributes, "int.key") {
    Some(@azimuth.IntValue(value)) => assert_eq(value, 42)
    _ => assert_true(false)
  }
  
  match @azimuth.Baggage::get_entry(baggage3, "request.id") {
    Some(request_id) => assert_eq(request_id, "req-67890")
    None => assert_true(false)
  }
  
  match @azimuth.Baggage::get_entry(baggage3, "user.id") {
    Some(_) => assert_true(false) // åº”è¯¥å·²è¢«ç§»é™¤
    None => assert_true(true)
  }
}

// æµ‹è¯•7: è¾¹ç•Œæ¡ä»¶å¤„ç†
test "boundary condition handling with extreme values" {
  // æµ‹è¯•ç©ºå­—ç¬¦ä¸²
  let empty_trace_id = ""
  let empty_span_id = ""
  let empty_span_ctx = @azimuth.SpanContext::new(empty_trace_id, empty_span_id, false, "")
  assert_false(@azimuth.SpanContext::is_valid(empty_span_ctx))
  
  // æµ‹è¯•æé•¿å­—ç¬¦ä¸²
  let long_string = "a" * 1000
  let long_span_ctx = @azimuth.SpanContext::new(long_string, long_string, true, "")
  assert_true(@azimuth.SpanContext::is_valid(long_span_ctx))
  
  // æµ‹è¯•æå€¼æ•°å€¼
  let max_int = 2147483647
  let min_int = -2147483648
  let max_double = 1.7976931348623157e+308
  let min_double = -1.7976931348623157e+308
  
  let max_int_attr = @azimuth.IntValue(max_int)
  let min_int_attr = @azimuth.IntValue(min_int)
  let max_double_attr = @azimuth.FloatValue(max_double)
  let min_double_attr = @azimuth.FloatValue(min_double)
  
  // éªŒè¯æå€¼å±æ€§
  match max_int_attr {
    @azimuth.IntValue(value) => assert_eq(value, max_int)
    _ => assert_true(false)
  }
  
  match min_double_attr {
    @azimuth.FloatValue(value) => assert_eq(value, min_double)
    _ => assert_true(false)
  }
  
  // æµ‹è¯•ç©ºæ•°ç»„
  let empty_array = []
  assert_eq(empty_array.length(), 0)
  
  // æµ‹è¯•Noneé€‰é¡¹
  let none_option : Option[String] = None
  match none_option {
    Some(_) => assert_true(false)
    None => assert_true(true)
  }
}

// æµ‹è¯•8: æ€§èƒ½ä¼˜åŒ–åœºæ™¯
test "performance optimization scenarios with batch operations" {
  // åˆ›å»ºå¤§é‡å±æ€§
  let mut large_attributes = @azimuth.Attributes::new()
  
  // æ‰¹é‡è®¾ç½®å±æ€§ - æ¨¡æ‹Ÿæ€§èƒ½ä¼˜åŒ–åœºæ™¯
  for i = 0; i < 100; i = i + 1 {
    @azimuth.Attributes::set(large_attributes, "key." + i.to_string(), @azimuth.StringValue("value." + i.to_string()))
  }
  
  // åˆ›å»ºå¤§é‡Baggageæ¡ç›®
  let mut large_baggage = @azimuth.Baggage::new()
  for i = 0; i < 50; i = i + 1 {
    large_baggage = @azimuth.Baggage::set_entry(large_baggage, "baggage.key." + i.to_string(), "baggage.value." + i.to_string())
  }
  
  // åˆ›å»ºå¤§é‡èµ„æºå±æ€§
  let large_resource = @azimuth.Resource::with_attributes(
    @azimuth.Resource::new(),
    [
      for i = 0; i < 25; i = i + 1:
        ("resource.key." + i.to_string(), @azimuth.StringValue("resource.value." + i.to_string()))
    ]
  )
  
  // éªŒè¯æ€§èƒ½ä¼˜åŒ–æ“ä½œç»“æœ
  match @azimuth.Attributes::get(large_attributes, "string.key") {
    Some(@azimuth.StringValue(value)) => assert_eq(value, "test_value")
    None => assert_true(false)
  }
  
  match @azimuth.Baggage::get_entry(large_baggage, "baggage.key.0") {
    Some(value) => assert_eq(value, "baggage.value.0")
    None => assert_true(false)
  }
  
  match @azimuth.Resource::get_attribute(large_resource, "resource.key.0") {
    Some(@azimuth.StringValue(value)) => assert_eq(value, "resource.value.0")
    None => assert_true(false)
  }
}

// æµ‹è¯•9: å›½é™…åŒ–æ”¯æŒ
test "internationalization support with multilingual text" {
  // æµ‹è¯•å¤šè¯­è¨€æ–‡æœ¬
  let chinese_text = "é¥æµ‹ç³»ç»Ÿ"
  let japanese_text = "ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªã‚·ã‚¹ãƒ†ãƒ "
  let korean_text = "ì›ê²© ì¸¡ì • ì‹œìŠ¤í…œ"
  let arabic_text = "Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¹Ù† Ø¨Ø¹Ø¯"
  let russian_text = "Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ‚ĞµĞ»ĞµĞ¼ĞµÑ‚Ñ€Ğ¸Ğ¸"
  let emoji_text = "ğŸŒğŸ“ŠğŸ“ˆ"
  
  // åˆ›å»ºå¤šè¯­è¨€å±æ€§
  let multilingual_attributes = @azimuth.Attributes::new()
  @azimuth.Attributes::set(multilingual_attributes, "error.message.zh", @azimuth.StringValue(chinese_text))
  @azimuth.Attributes::set(multilingual_attributes, "error.message.ja", @azimuth.StringValue(japanese_text))
  @azimuth.Attributes::set(multilingual_attributes, "error.message.ko", @azimuth.StringValue(korean_text))
  @azimuth.Attributes::set(multilingual_attributes, "error.message.ar", @azimuth.StringValue(arabic_text))
  @azimuth.Attributes::set(multilingual_attributes, "error.message.ru", @azimuth.StringValue(russian_text))
  @azimuth.Attributes::set(multilingual_attributes, "error.message.emoji", @azimuth.StringValue(emoji_text))
  
  // åˆ›å»ºå¤šè¯­è¨€æ—¥å¿—è®°å½•
  let multilingual_log = @azimuth.LogRecord::new_with_context(
    @azimuth.Error,
    Some("æ“ä½œå¤±è´¥: " + chinese_text),
    Some(multilingual_attributes),
    Some(1735689600000000000L),
    None,
    None,
    None,
    None
  )
  
  // éªŒè¯å¤šè¯­è¨€æ–‡æœ¬å¤„ç†
  match @azimuth.LogRecord::body(multilingual_log) {
    Some(body) => assert_true(body.contains(chinese_text))
    None => assert_true(false)
  }
  
  // éªŒè¯å­—ç¬¦ä¸²æ“ä½œ
  assert_eq(chinese_text.length(), 4)
  assert_eq(japanese_text.length(), 8)
  assert_eq(korean_text.length(), 9)
  assert_eq(arabic_text.length(), 17)
  assert_eq(russian_text.length(), 19)
  assert_eq(emoji_text.length(), 3)
  
  // éªŒè¯Unicodeå­—ç¬¦å¤„ç†
  assert_true(chinese_text.contains("é¥"))
  assert_true(japanese_text.contains("ãƒ†"))
  assert_true(korean_text.contains("ì›"))
  assert_true(arabic_text.contains("Ù†"))
  assert_true(russian_text.contains("Ğ¡"))
  assert_true(emoji_text.contains("ğŸŒ"))
}

// æµ‹è¯•10: æ—¶åºæ•°æ®æ“ä½œ
test "time series data operations with temporal aggregations" {
  // åˆ›å»ºæ—¶é’Ÿ
  let clock = @azimuth.Clock::system()
  
  // è·å–å½“å‰æ—¶é—´æˆ³
  let timestamp1 = @azimuth.Clock::now_unix_nanos(clock)
  
  // åˆ›å»ºæ—¶åºæ•°æ®ç‚¹
  let data_point1 = @azimuth.LogRecord::new_with_context(
    @azimuth.Info,
    Some("Data point 1"),
    Some(@azimuth.Attributes::new()),
    Some(timestamp1),
    None,
    None,
    None,
    None
  )
  
  // æ¨¡æ‹Ÿæ—¶é—´æµé€
  let timestamp2 = timestamp1 + 1000000000L // 1ç§’å
  
  let data_point2 = @azimuth.LogRecord::new_with_context(
    @azimuth.Info,
    Some("Data point 2"),
    Some(@azimuth.Attributes::new()),
    Some(timestamp2),
    None,
    None,
    None,
    None
  )
  
  // æ¨¡æ‹Ÿæ—¶é—´æµé€
  let timestamp3 = timestamp2 + 2000000000L // 2ç§’å
  
  let data_point3 = @azimuth.LogRecord::new_with_context(
    @azimuth.Info,
    Some("Data point 3"),
    Some(@azimuth.Attributes::new()),
    Some(timestamp3),
    None,
    None,
    None,
    None
  )
  
  // éªŒè¯æ—¶é—´æˆ³é€’å¢
  assert_true(timestamp2 > timestamp1)
  assert_true(timestamp3 > timestamp2)
  assert_true(timestamp3 > timestamp1)
  
  // éªŒè¯æ—¶é—´å·®è®¡ç®—
  let time_diff1 = timestamp2 - timestamp1
  let time_diff2 = timestamp3 - timestamp2
  let total_time = timestamp3 - timestamp1
  
  assert_eq(time_diff1, 1000000000L)
  assert_eq(time_diff2, 2000000000L)
  assert_eq(total_time, 3000000000L)
  
  // åˆ›å»ºå¸¦æ—¶é—´æˆ³çš„Span
  let span_with_time = @azimuth.Span::new(
    "time-series-span",
    @azimuth.Internal,
    @azimuth.SpanContext::new("trace123", "span456", true, "")
  )
  
  // æ¨¡æ‹ŸSpanæŒç»­æ—¶é—´
  let start_time = @azimuth.Clock::now_unix_nanos(clock)
  // æ‰§è¡Œä¸€äº›æ“ä½œ...
  let end_time = start_time + 500000000L // 0.5ç§’å
  
  // éªŒè¯æ—¶é—´åºåˆ—æ•°æ®çš„å®Œæ•´æ€§
  assert_true(end_time > start_time)
  assert_eq(end_time - start_time, 500000000L)
  
  // åˆ›å»ºæ—¶é—´åºåˆ—èšåˆæ•°æ®
  let time_series_data = [
    (timestamp1, 10.0),
    (timestamp2, 20.0),
    (timestamp3, 15.0)
  ]
  
  // è®¡ç®—å¹³å‡å€¼
  let sum = time_series_data.reduce(fn(acc, data) { acc + data.1 }, 0.0)
  let average = sum / time_series_data.length().to_double()
  
  assert_eq(average, 15.0)
}